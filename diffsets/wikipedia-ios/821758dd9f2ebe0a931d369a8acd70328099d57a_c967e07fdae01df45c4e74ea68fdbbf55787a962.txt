diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index f74d4521f35..ed387a4bfd1 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -8,7 +8,6 @@
 
 /* Begin PBXBuildFile section */
 		0400EB0318AAEEC60043ECE2 /* UINavigationController+SearchNavStack.m in Sources */ = {isa = PBXBuildFile; fileRef = 0400EB0218AAEEC60043ECE2 /* UINavigationController+SearchNavStack.m */; };
-		0406CEF618F8C390007EE43E /* LogEventOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0406CEF518F8C390007EE43E /* LogEventOp.m */; };
 		04082B5318ADA25A00FAF3D6 /* text_field_x_circle_gray.png in Resources */ = {isa = PBXBuildFile; fileRef = 04082B5118ADA25A00FAF3D6 /* text_field_x_circle_gray.png */; };
 		04082B5518ADA25A00FAF3D6 /* text_field_x_circle_gray@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = 04082B5218ADA25A00FAF3D6 /* text_field_x_circle_gray@2x.png */; };
 		040892641935ABBD004CF254 /* UIViewController+StatusBarHeight.m in Sources */ = {isa = PBXBuildFile; fileRef = 040892631935ABBD004CF254 /* UIViewController+StatusBarHeight.m */; };
@@ -37,7 +36,6 @@
 		04292FF2185FBA70002A13FC /* SearchResultCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 04292FF0185FBA70002A13FC /* SearchResultCell.m */; };
 		04292FF4185FBA70002A13FC /* SearchResultPrototypeView.xib in Resources */ = {isa = PBXBuildFile; fileRef = 04292FF1185FBA70002A13FC /* SearchResultPrototypeView.xib */; };
 		04292FF8185FBB0B002A13FC /* SearchResultsController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04292FF7185FBB0B002A13FC /* SearchResultsController.m */; };
-		04293000185FC2C7002A13FC /* QueuesSingleton.m in Sources */ = {isa = PBXBuildFile; fileRef = 04292FFF185FC2C7002A13FC /* QueuesSingleton.m */; };
 		0429300A18604898002A13FC /* SavedPagesResultCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 0429300418604898002A13FC /* SavedPagesResultCell.m */; };
 		0429301018604898002A13FC /* SavedPagesViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0429300918604898002A13FC /* SavedPagesViewController.m */; };
 		042A5B2619253D2A0095E172 /* CenterNavController.m in Sources */ = {isa = PBXBuildFile; fileRef = 042A5B2019253D2A0095E172 /* CenterNavController.m */; };
@@ -48,11 +46,9 @@
 		042B3996192EAEEA0066B270 /* ShareMenuSavePageActivity.m in Sources */ = {isa = PBXBuildFile; fileRef = 042B3995192EAEEA0066B270 /* ShareMenuSavePageActivity.m */; };
 		0433542218A023FE009305F0 /* UIViewController+HideKeyboard.m in Sources */ = {isa = PBXBuildFile; fileRef = 0433542118A023FE009305F0 /* UIViewController+HideKeyboard.m */; };
 		0433542618A093C5009305F0 /* UIView+RemoveConstraints.m in Sources */ = {isa = PBXBuildFile; fileRef = 0433542518A093C5009305F0 /* UIView+RemoveConstraints.m */; };
-		043C668A18BE9A8E00580E9B /* PreviewWikiTextOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 043C668918BE9A8E00580E9B /* PreviewWikiTextOp.m */; };
 		043DAC4B1901C3EE001CD17C /* CreditsViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 043DAC4A1901C3EE001CD17C /* CreditsViewController.m */; };
 		043F18E118D9691D00D8489A /* TopActionSheetLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 043F18DC18D9691D00D8489A /* TopActionSheetLabel.m */; };
 		043F18E518D9691D00D8489A /* UINavigationController+TopActionSheet.m in Sources */ = {isa = PBXBuildFile; fileRef = 043F18E018D9691D00D8489A /* UINavigationController+TopActionSheet.m */; };
-		044213C8191C3C2A006C03BF /* SyncAssetsFileOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 044213C7191C3C2A006C03BF /* SyncAssetsFileOp.m */; };
 		0442F57B19006DCC00F55DF9 /* PageHistoryLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 0442F57A19006DCC00F55DF9 /* PageHistoryLabel.m */; };
 		0447862F185145090050563B /* HistoryResultCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 04478621185145090050563B /* HistoryResultCell.m */; };
 		04478631185145090050563B /* HistoryResultPrototypeView.xib in Resources */ = {isa = PBXBuildFile; fileRef = 04478622185145090050563B /* HistoryResultPrototypeView.xib */; };
@@ -72,17 +68,12 @@
 		045A9F0D18F6090E0057EA85 /* assets in Resources */ = {isa = PBXBuildFile; fileRef = 045A9F0C18F6090E0057EA85 /* assets */; };
 		045EFF1A19A25FEB00D0EDBB /* logo-placeholder-search.png in Resources */ = {isa = PBXBuildFile; fileRef = 045EFF1819A25FEB00D0EDBB /* logo-placeholder-search.png */; };
 		045EFF1B19A25FEB00D0EDBB /* logo-placeholder-search@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = 045EFF1919A25FEB00D0EDBB /* logo-placeholder-search@2x.png */; };
-		0460990A18899A9800B1F2BC /* DownloadSectionWikiTextOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0460990918899A9800B1F2BC /* DownloadSectionWikiTextOp.m */; };
-		0460990E1889A0DD00B1F2BC /* UploadSectionWikiTextOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0460990D1889A0DD00B1F2BC /* UploadSectionWikiTextOp.m */; };
 		0460F8DC19B0F932001BC59B /* CenteredPathView.m in Sources */ = {isa = PBXBuildFile; fileRef = 0460F8DB19B0F932001BC59B /* CenteredPathView.m */; };
-		0463639318A5CCEB0049EE4F /* EditTokenOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0463639218A5CCEB0049EE4F /* EditTokenOp.m */; };
 		0463639818A844570049EE4F /* KeychainCredentials.m in Sources */ = {isa = PBXBuildFile; fileRef = 0463639718A844570049EE4F /* KeychainCredentials.m */; };
 		0472BC18193AD88C00C40BDA /* Section+DisplayHtml.m in Sources */ = {isa = PBXBuildFile; fileRef = 0472BC17193AD88C00C40BDA /* Section+DisplayHtml.m */; };
-		04735E6018A5B42D00C89C30 /* LoginTokenOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04735E5F18A5B42D00C89C30 /* LoginTokenOp.m */; };
 		047528AF19107DAA00F2CDA8 /* Section.m in Sources */ = {isa = PBXBuildFile; fileRef = 047528AE19107DAA00F2CDA8 /* Section.m */; };
 		047528B21913110000F2CDA8 /* Section+LeadSection.m in Sources */ = {isa = PBXBuildFile; fileRef = 047528B11913110000F2CDA8 /* Section+LeadSection.m */; };
 		047528B5191465C400F2CDA8 /* Article.m in Sources */ = {isa = PBXBuildFile; fileRef = 047528B4191465C400F2CDA8 /* Article.m */; };
-		0476967C18BBFC9400071963 /* AccountCreationOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0476967B18BBFC9400071963 /* AccountCreationOp.m */; };
 		047801BE18AE987900DBB747 /* UIButton+ColorMask.m in Sources */ = {isa = PBXBuildFile; fileRef = 047801BD18AE987900DBB747 /* UIButton+ColorMask.m */; };
 		047E74141860509000916964 /* SavedPagesResultPrototypeView.xib in Resources */ = {isa = PBXBuildFile; fileRef = 047E74131860509000916964 /* SavedPagesResultPrototypeView.xib */; };
 		047E95501996DD030046A122 /* NearbyResultCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 047E954C1996DD030046A122 /* NearbyResultCell.m */; };
@@ -92,13 +83,32 @@
 		04821CD119895EDC007558F6 /* ReferenceGradientView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04821CD019895EDC007558F6 /* ReferenceGradientView.m */; };
 		0484E3DE19D9D19B0085D18D /* UIView+ConstraintsScale.m in Sources */ = {isa = PBXBuildFile; fileRef = 0484E3DD19D9D19B0085D18D /* UIView+ConstraintsScale.m */; };
 		0485FECF1994D5AE00141361 /* NearbyResultCell.xib in Resources */ = {isa = PBXBuildFile; fileRef = 0485FECD1994D5AE00141361 /* NearbyResultCell.xib */; };
-		0485FED21994E22400141361 /* NearbyOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 0485FED11994E22400141361 /* NearbyOp.m */; };
+		0487041419F7683300B7D307 /* Cocoapods Notes.txt in Resources */ = {isa = PBXBuildFile; fileRef = 0487041319F7683300B7D307 /* Cocoapods Notes.txt */; };
+		0487045519F824D700B7D307 /* QueuesSingleton.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487044119F824D700B7D307 /* QueuesSingleton.m */; };
+		0487047E19F8262600B7D307 /* AccountCreationTokenFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487045819F8262600B7D307 /* AccountCreationTokenFetcher.m */; };
+		0487047F19F8262600B7D307 /* AccountCreator.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487045A19F8262600B7D307 /* AccountCreator.m */; };
+		0487048019F8262600B7D307 /* AccountLogin.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487045C19F8262600B7D307 /* AccountLogin.m */; };
+		0487048119F8262600B7D307 /* ArticleFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487045E19F8262600B7D307 /* ArticleFetcher.m */; };
+		0487048219F8262600B7D307 /* AssetsFileFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046019F8262600B7D307 /* AssetsFileFetcher.m */; };
+		0487048319F8262600B7D307 /* FetcherBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046319F8262600B7D307 /* FetcherBase.m */; };
+		0487048419F8262600B7D307 /* CaptchaResetter.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046519F8262600B7D307 /* CaptchaResetter.m */; };
+		0487048519F8262600B7D307 /* EditTokenFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046719F8262600B7D307 /* EditTokenFetcher.m */; };
+		0487048619F8262600B7D307 /* LanguageLinksFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046919F8262600B7D307 /* LanguageLinksFetcher.m */; };
+		0487048719F8262600B7D307 /* LoginTokenFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046B19F8262600B7D307 /* LoginTokenFetcher.m */; };
+		0487048819F8262600B7D307 /* NearbyFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046D19F8262600B7D307 /* NearbyFetcher.m */; };
+		0487048919F8262600B7D307 /* PageHistoryFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487046F19F8262600B7D307 /* PageHistoryFetcher.m */; };
+		0487048A19F8262600B7D307 /* PreviewHtmlFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047119F8262600B7D307 /* PreviewHtmlFetcher.m */; };
+		0487048B19F8262600B7D307 /* RandomArticleFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047319F8262600B7D307 /* RandomArticleFetcher.m */; };
+		0487048C19F8262600B7D307 /* SearchResultFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047519F8262600B7D307 /* SearchResultFetcher.m */; };
+		0487048D19F8262600B7D307 /* ThumbnailFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047719F8262600B7D307 /* ThumbnailFetcher.m */; };
+		0487048E19F8262600B7D307 /* WikipediaZeroMessageFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047919F8262600B7D307 /* WikipediaZeroMessageFetcher.m */; };
+		0487048F19F8262600B7D307 /* WikiTextSectionFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047B19F8262600B7D307 /* WikiTextSectionFetcher.m */; };
+		0487049019F8262600B7D307 /* WikiTextSectionUploader.m in Sources */ = {isa = PBXBuildFile; fileRef = 0487047D19F8262600B7D307 /* WikiTextSectionUploader.m */; };
 		048A26771906268100395F53 /* PaddedLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 048A26761906268100395F53 /* PaddedLabel.m */; };
 		0493C2CC1952373100EBB973 /* CoreDataHousekeeping.m in Sources */ = {isa = PBXBuildFile; fileRef = 0493C2CB1952373100EBB973 /* CoreDataHousekeeping.m */; };
 		0493C2D419526A0100EBB973 /* WikiFont-Glyphs.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 0493C2D319526A0100EBB973 /* WikiFont-Glyphs.ttf */; };
 		0493C2D619526FFE00EBB973 /* WikiFont-Glyphs-iOS.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 0493C2D519526FFE00EBB973 /* WikiFont-Glyphs-iOS.ttf */; };
 		049566C218F5F4CB0058EA12 /* ZeroConfigState.m in Sources */ = {isa = PBXBuildFile; fileRef = 049566C118F5F4CB0058EA12 /* ZeroConfigState.m */; };
-		04992BC018B687AF00A6C22B /* SearchOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04992BBF18B687AF00A6C22B /* SearchOp.m */; };
 		049B640C18AAF36200D98BD4 /* UIViewController+SearchChildViewControllers.m in Sources */ = {isa = PBXBuildFile; fileRef = 049B640B18AAF36200D98BD4 /* UIViewController+SearchChildViewControllers.m */; };
 		04A70FD7185BB6C300E24515 /* URLCache.m in Sources */ = {isa = PBXBuildFile; fileRef = 04A70FD6185BB6C300E24515 /* URLCache.m */; };
 		04A81E8618871EB000EEBADB /* Section+ImageRecords.m in Sources */ = {isa = PBXBuildFile; fileRef = 04A81E8518871EB000EEBADB /* Section+ImageRecords.m */; };
@@ -112,27 +122,24 @@
 		04B6050C193522650007185A /* WikiGlyphButton.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B6050B193522650007185A /* WikiGlyphButton.m */; };
 		04B605101935236C0007185A /* WikiGlyphLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B6050F1935236C0007185A /* WikiGlyphLabel.m */; };
 		04B6925018E77B2A00F88D8A /* UIWebView+HideScrollGradient.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B6924F18E77B2A00F88D8A /* UIWebView+HideScrollGradient.m */; };
-		04B78A5318A580AF0050EBF5 /* LoginOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B78A5218A580AF0050EBF5 /* LoginOp.m */; };
 		04B7B9BD18B5570E00A63551 /* CaptchaViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B7B9BC18B5570E00A63551 /* CaptchaViewController.m */; };
 		04B91AA718E34BBC00FFAA1C /* UIView+TemporaryAnimatedXF.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B91AA618E34BBC00FFAA1C /* UIView+TemporaryAnimatedXF.m */; };
 		04B91AAB18E3D9E200FFAA1C /* NSString+FormattedAttributedString.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B91AAA18E3D9E200FFAA1C /* NSString+FormattedAttributedString.m */; };
 		04B91AB718E4D5B200FFAA1C /* TabularScrollView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04B91AB618E4D5B200FFAA1C /* TabularScrollView.m */; };
 		04C0A0781936786000D55325 /* UIViewController+ModalPresent.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C0A0771936786000D55325 /* UIViewController+ModalPresent.m */; };
-		04C43A9D183440B0006C643B /* MWCrumbyTest.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43A9C183440B0006C643B /* MWCrumbyTest.m */; };
 		04C43AA4183440C1006C643B /* MWNetworkActivityIndicatorManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43AA1183440C1006C643B /* MWNetworkActivityIndicatorManager.m */; };
-		04C43AA6183440C1006C643B /* MWNetworkOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43AA3183440C1006C643B /* MWNetworkOp.m */; };
 		04C43AAE18344131006C643B /* CommunicationBridge.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43AAB18344131006C643B /* CommunicationBridge.m */; };
 		04C43ABE183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43AB9183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m */; };
 		04C43AC0183442FC006C643B /* NSString+Extras.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43ABB183442FC006C643B /* NSString+Extras.m */; };
 		04C43AC2183442FC006C643B /* NSURLRequest+DictionaryRequest.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C43ABD183442FC006C643B /* NSURLRequest+DictionaryRequest.m */; };
 		04C695CE18ED08D900D9F2DA /* UIView+SearchSubviews.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C695CD18ED08D900D9F2DA /* UIView+SearchSubviews.m */; };
 		04C695D218ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C695D118ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.m */; };
-		04C8781018F4A42700FA3B99 /* AccountCreationTokenOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C8780F18F4A42700FA3B99 /* AccountCreationTokenOp.m */; };
 		04C91CEB195517250035ED1B /* OnboardingViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C91CEA195517250035ED1B /* OnboardingViewController.m */; };
 		04C91CEE195520990035ED1B /* logo-onboarding-subtitle.png in Resources */ = {isa = PBXBuildFile; fileRef = 04C91CEC195520990035ED1B /* logo-onboarding-subtitle.png */; };
 		04C91CEF195520990035ED1B /* logo-onboarding-subtitle@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = 04C91CED195520990035ED1B /* logo-onboarding-subtitle@2x.png */; };
 		04C91CF219554B310035ED1B /* logo-onboarding.png in Resources */ = {isa = PBXBuildFile; fileRef = 04C91CF019554B310035ED1B /* logo-onboarding.png */; };
 		04C91CF319554B310035ED1B /* logo-onboarding@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = 04C91CF119554B310035ED1B /* logo-onboarding@2x.png */; };
+		04C9509D19EF02980013F3C0 /* EventLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C9509C19EF02980013F3C0 /* EventLogger.m */; };
 		04CBAC7319A9B786009F3D7E /* NSArray+Predicate.m in Sources */ = {isa = PBXBuildFile; fileRef = 04CBAC7219A9B786009F3D7E /* NSArray+Predicate.m */; };
 		04CCA0C01983086D000E982A /* ReferencesVC.m in Sources */ = {isa = PBXBuildFile; fileRef = 04CCA0BF1983086D000E982A /* ReferencesVC.m */; };
 		04CCA0C319830A44000E982A /* ReferenceVC.m in Sources */ = {isa = PBXBuildFile; fileRef = 04CCA0C219830A44000E982A /* ReferenceVC.m */; };
@@ -147,13 +154,9 @@
 		04D122321899B8AC006B9A30 /* AlertWebView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D122311899B8AC006B9A30 /* AlertWebView.m */; };
 		04D149DD18877343006B4104 /* AlertLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D149DA18877343006B4104 /* AlertLabel.m */; };
 		04D149DF18877343006B4104 /* UIViewController+Alert.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D149DC18877343006B4104 /* UIViewController+Alert.m */; };
-		04D149EC18888A0D006B4104 /* DownloadSectionsOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D149EB18888A0D006B4104 /* DownloadSectionsOp.m */; };
 		04D308281998A8AA0034F106 /* NearbyThumbnailView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D308271998A8AA0034F106 /* NearbyThumbnailView.m */; };
 		04D3082B19991CB60034F106 /* logo-placeholder-nearby.png in Resources */ = {isa = PBXBuildFile; fileRef = 04D3082919991CB60034F106 /* logo-placeholder-nearby.png */; };
 		04D3082C19991CB60034F106 /* logo-placeholder-nearby@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = 04D3082A19991CB60034F106 /* logo-placeholder-nearby@2x.png */; };
-		04D34DAB1863D2D600610A87 /* TFHpple.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DA61863D2D600610A87 /* TFHpple.m */; };
-		04D34DAD1863D2D600610A87 /* TFHppleElement.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DA81863D2D600610A87 /* TFHppleElement.m */; };
-		04D34DAF1863D2D600610A87 /* XPathQuery.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DAA1863D2D600610A87 /* XPathQuery.m */; };
 		04D34DB21863D39000610A87 /* libxml2.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 04D34DB11863D39000610A87 /* libxml2.dylib */; };
 		04D34DB91863F69500610A87 /* DiscoveryContext.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DB81863F69500610A87 /* DiscoveryContext.m */; };
 		04D34DBD1863F6A400610A87 /* GalleryImage.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DBC1863F6A400610A87 /* GalleryImage.m */; };
@@ -161,8 +164,6 @@
 		04D34DC91863F6CC00610A87 /* Saved.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DC81863F6CC00610A87 /* Saved.m */; };
 		04D34DD11863F6E600610A87 /* SectionImage.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DD01863F6E600610A87 /* SectionImage.m */; };
 		04D34DE11868E21F00610A87 /* Article+Convenience.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D34DE01868E21F00610A87 /* Article+Convenience.m */; };
-		04D75824189248E900CE2040 /* DownloadLangLinksOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04D75823189248E900CE2040 /* DownloadLangLinksOp.m */; };
-		04DB0BE618BC2E1E00B4BCF3 /* CaptchaResetOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DB0BE518BC2E1E00B4BCF3 /* CaptchaResetOp.m */; };
 		04DB0BEA18BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DB0BE918BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.m */; };
 		04DD89B118BFE63A00DD5DAD /* PreviewAndSaveViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DD89B018BFE63A00DD5DAD /* PreviewAndSaveViewController.m */; };
 		04F0E2EA186EDC1A00468738 /* UIWebView+ElementLocation.m in Sources */ = {isa = PBXBuildFile; fileRef = 04F0E2E9186EDC1A00468738 /* UIWebView+ElementLocation.m */; };
@@ -170,12 +171,9 @@
 		04F27B7518FE0F2E00EDD838 /* PageHistoryResultCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 04F27B6F18FE0F2E00EDD838 /* PageHistoryResultCell.m */; };
 		04F27B7618FE0F2E00EDD838 /* PageHistoryResultPrototypeView.xib in Resources */ = {isa = PBXBuildFile; fileRef = 04F27B7018FE0F2E00EDD838 /* PageHistoryResultPrototypeView.xib */; };
 		04F27B7818FE0F2E00EDD838 /* PageHistoryViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04F27B7418FE0F2E00EDD838 /* PageHistoryViewController.m */; };
-		04F27B7B18FE19B700EDD838 /* PageHistoryOp.m in Sources */ = {isa = PBXBuildFile; fileRef = 04F27B7A18FE19B700EDD838 /* PageHistoryOp.m */; };
 		04F39590186CF80100B0D6FC /* TOCViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04F3958F186CF80100B0D6FC /* TOCViewController.m */; };
 		04FD6C7A184EBFCD002CA02F /* ArticleData.xcdatamodeld in Sources */ = {isa = PBXBuildFile; fileRef = 04FD6C78184EBFCD002CA02F /* ArticleData.xcdatamodeld */; };
 		C9180EC418AED30C006C1DCA /* WikipediaAppUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = C9180EC318AED30C006C1DCA /* WikipediaAppUtils.m */; };
-		C958EE3418CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.m in Sources */ = {isa = PBXBuildFile; fileRef = C958EE3318CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.m */; };
-		C9928B8618AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.m in Sources */ = {isa = PBXBuildFile; fileRef = C9928B8518AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.m */; };
 		D42E75EB18D11237002EA7E5 /* MWLanguageInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = D42E75EA18D11237002EA7E5 /* MWLanguageInfo.m */; };
 		D46CD8C418A1AC4F0042959E /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = D46CD8C018A1AC4F0042959E /* InfoPlist.strings */; };
 		D46CD8C518A1AC4F0042959E /* Localizable.strings in Resources */ = {isa = PBXBuildFile; fileRef = D46CD8C218A1AC4F0042959E /* Localizable.strings */; };
@@ -190,6 +188,8 @@
 		D499144C181D51DE00E6073C /* Main_iPhone.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = D499144A181D51DE00E6073C /* Main_iPhone.storyboard */; };
 		D4991454181D51DE00E6073C /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D4991453181D51DE00E6073C /* Images.xcassets */; };
 		D49B2ED2196C687C002F035D /* PullToRefreshViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = D49B2ED1196C687C002F035D /* PullToRefreshViewController.m */; };
+		D4AD974E19F99E7C00957451 /* libPods-AFNetworking.a in Frameworks */ = {isa = PBXBuildFile; fileRef = D4AD974719F99CD700957451 /* libPods-AFNetworking.a */; };
+		D4AD975019F99E9000957451 /* libPods-hpple.a in Frameworks */ = {isa = PBXBuildFile; fileRef = D4AD974919F99CD700957451 /* libPods-hpple.a */; };
 		D4B0AE0219365F7C00F0AC90 /* EventLoggingFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = D4B0AE0119365F7C00F0AC90 /* EventLoggingFunnel.m */; };
 		D4B0AE051936604700F0AC90 /* EditFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = D4B0AE041936604700F0AC90 /* EditFunnel.m */; };
 		D4B0AE0819366A0A00F0AC90 /* CreateAccountFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = D4B0AE0719366A0A00F0AC90 /* CreateAccountFunnel.m */; };
@@ -205,11 +205,47 @@
 		D4F277FE194235B50032BA38 /* ToCInteractionFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = D4F277FD194235B50032BA38 /* ToCInteractionFunnel.m */; };
 /* End PBXBuildFile section */
 
+/* Begin PBXContainerItemProxy section */
+		D4AD974419F99CD700957451 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+			proxyType = 2;
+			remoteGlobalIDString = 4B97C700A44275378518197B;
+			remoteInfo = Pods;
+		};
+		D4AD974619F99CD700957451 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+			proxyType = 2;
+			remoteGlobalIDString = 1991ADD1F89A00A42B36F91A;
+			remoteInfo = "Pods-AFNetworking";
+		};
+		D4AD974819F99CD700957451 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+			proxyType = 2;
+			remoteGlobalIDString = ACC360DC91D91D8973461A32;
+			remoteInfo = "Pods-hpple";
+		};
+		D4AD974A19F99E4200957451 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+			proxyType = 1;
+			remoteGlobalIDString = FDC9A847FCE7AA138C7D5622;
+			remoteInfo = "Pods-AFNetworking";
+		};
+		D4AD974C19F99E4600957451 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+			proxyType = 1;
+			remoteGlobalIDString = E5A0C6369E917827A057D39A;
+			remoteInfo = "Pods-hpple";
+		};
+/* End PBXContainerItemProxy section */
+
 /* Begin PBXFileReference section */
 		0400EB0118AAEEC60043ECE2 /* UINavigationController+SearchNavStack.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UINavigationController+SearchNavStack.h"; sourceTree = "<group>"; };
 		0400EB0218AAEEC60043ECE2 /* UINavigationController+SearchNavStack.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UINavigationController+SearchNavStack.m"; sourceTree = "<group>"; };
-		0406CEF418F8C390007EE43E /* LogEventOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LogEventOp.h; sourceTree = "<group>"; };
-		0406CEF518F8C390007EE43E /* LogEventOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LogEventOp.m; sourceTree = "<group>"; };
 		04082B5118ADA25A00FAF3D6 /* text_field_x_circle_gray.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = text_field_x_circle_gray.png; sourceTree = "<group>"; };
 		04082B5218ADA25A00FAF3D6 /* text_field_x_circle_gray@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "text_field_x_circle_gray@2x.png"; sourceTree = "<group>"; };
 		040892621935ABBD004CF254 /* UIViewController+StatusBarHeight.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIViewController+StatusBarHeight.h"; sourceTree = "<group>"; };
@@ -219,7 +255,6 @@
 		04090A3A187FB7D000577EDF /* UIView+Debugging.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+Debugging.m"; sourceTree = "<group>"; };
 		040E533A1885FB4E00AFBFE9 /* ImageData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageData.h; sourceTree = "<group>"; };
 		040E533B1885FB4E00AFBFE9 /* ImageData.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ImageData.m; sourceTree = "<group>"; };
-		040E5C4C184564D0007AFE6F /* ArticleDataModel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ArticleDataModel.m; sourceTree = "<group>"; };
 		040E5C4E184566F4007AFE6F /* CoreData.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreData.framework; path = System/Library/Frameworks/CoreData.framework; sourceTree = SDKROOT; };
 		040E5C821846AC13007AFE6F /* ArticleDataContextSingleton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArticleDataContextSingleton.h; sourceTree = "<group>"; };
 		040E5C831846AC13007AFE6F /* ArticleDataContextSingleton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ArticleDataContextSingleton.m; sourceTree = "<group>"; };
@@ -258,8 +293,6 @@
 		04292FF6185FBB0B002A13FC /* SearchResultsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SearchResultsController.h; sourceTree = "<group>"; };
 		04292FF7185FBB0B002A13FC /* SearchResultsController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SearchResultsController.m; sourceTree = "<group>"; };
 		04292FFC185FC026002A13FC /* Defines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Defines.h; sourceTree = "<group>"; };
-		04292FFE185FC2C7002A13FC /* QueuesSingleton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QueuesSingleton.h; sourceTree = "<group>"; };
-		04292FFF185FC2C7002A13FC /* QueuesSingleton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = QueuesSingleton.m; sourceTree = "<group>"; };
 		0429300318604898002A13FC /* SavedPagesResultCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SavedPagesResultCell.h; sourceTree = "<group>"; };
 		0429300418604898002A13FC /* SavedPagesResultCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SavedPagesResultCell.m; sourceTree = "<group>"; };
 		0429300818604898002A13FC /* SavedPagesViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SavedPagesViewController.h; sourceTree = "<group>"; };
@@ -280,8 +313,6 @@
 		0433542118A023FE009305F0 /* UIViewController+HideKeyboard.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIViewController+HideKeyboard.m"; sourceTree = "<group>"; };
 		0433542418A093C5009305F0 /* UIView+RemoveConstraints.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+RemoveConstraints.h"; sourceTree = "<group>"; };
 		0433542518A093C5009305F0 /* UIView+RemoveConstraints.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+RemoveConstraints.m"; sourceTree = "<group>"; };
-		043C668818BE9A8E00580E9B /* PreviewWikiTextOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PreviewWikiTextOp.h; sourceTree = "<group>"; };
-		043C668918BE9A8E00580E9B /* PreviewWikiTextOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PreviewWikiTextOp.m; sourceTree = "<group>"; };
 		043DAC491901C3EE001CD17C /* CreditsViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreditsViewController.h; sourceTree = "<group>"; };
 		043DAC4A1901C3EE001CD17C /* CreditsViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CreditsViewController.m; sourceTree = "<group>"; };
 		043F18DB18D9691D00D8489A /* TopActionSheetLabel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TopActionSheetLabel.h; sourceTree = "<group>"; };
@@ -289,8 +320,6 @@
 		043F18DF18D9691D00D8489A /* UINavigationController+TopActionSheet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UINavigationController+TopActionSheet.h"; sourceTree = "<group>"; };
 		043F18E018D9691D00D8489A /* UINavigationController+TopActionSheet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UINavigationController+TopActionSheet.m"; sourceTree = "<group>"; };
 		043F18F118DCDD3A00D8489A /* WMF_Colors.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMF_Colors.h; sourceTree = "<group>"; };
-		044213C6191C3C2A006C03BF /* SyncAssetsFileOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SyncAssetsFileOp.h; sourceTree = "<group>"; };
-		044213C7191C3C2A006C03BF /* SyncAssetsFileOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SyncAssetsFileOp.m; sourceTree = "<group>"; };
 		0442F57919006DCC00F55DF9 /* PageHistoryLabel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PageHistoryLabel.h; sourceTree = "<group>"; };
 		0442F57A19006DCC00F55DF9 /* PageHistoryLabel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PageHistoryLabel.m; sourceTree = "<group>"; };
 		04478620185145090050563B /* HistoryResultCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HistoryResultCell.h; sourceTree = "<group>"; };
@@ -326,20 +355,13 @@
 		045A9F0C18F6090E0057EA85 /* assets */ = {isa = PBXFileReference; lastKnownFileType = folder; path = assets; sourceTree = "<group>"; };
 		045EFF1819A25FEB00D0EDBB /* logo-placeholder-search.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-placeholder-search.png"; sourceTree = "<group>"; };
 		045EFF1919A25FEB00D0EDBB /* logo-placeholder-search@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-placeholder-search@2x.png"; sourceTree = "<group>"; };
-		0460990818899A9800B1F2BC /* DownloadSectionWikiTextOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DownloadSectionWikiTextOp.h; sourceTree = "<group>"; };
-		0460990918899A9800B1F2BC /* DownloadSectionWikiTextOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DownloadSectionWikiTextOp.m; sourceTree = "<group>"; };
-		0460990C1889A0DD00B1F2BC /* UploadSectionWikiTextOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UploadSectionWikiTextOp.h; sourceTree = "<group>"; };
-		0460990D1889A0DD00B1F2BC /* UploadSectionWikiTextOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = UploadSectionWikiTextOp.m; sourceTree = "<group>"; };
 		0460F8DA19B0F932001BC59B /* CenteredPathView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CenteredPathView.h; sourceTree = "<group>"; };
 		0460F8DB19B0F932001BC59B /* CenteredPathView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CenteredPathView.m; sourceTree = "<group>"; };
-		0463639118A5CCEB0049EE4F /* EditTokenOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EditTokenOp.h; sourceTree = "<group>"; };
-		0463639218A5CCEB0049EE4F /* EditTokenOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = EditTokenOp.m; sourceTree = "<group>"; };
 		0463639618A844570049EE4F /* KeychainCredentials.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = KeychainCredentials.h; sourceTree = "<group>"; };
 		0463639718A844570049EE4F /* KeychainCredentials.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = KeychainCredentials.m; sourceTree = "<group>"; };
+		04649CA619F72B360071E8FA /* libPods.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libPods.a; path = "Pods/build/Debug-iphoneos/libPods.a"; sourceTree = "<group>"; };
 		0472BC16193AD88C00C40BDA /* Section+DisplayHtml.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "Section+DisplayHtml.h"; sourceTree = "<group>"; };
 		0472BC17193AD88C00C40BDA /* Section+DisplayHtml.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "Section+DisplayHtml.m"; sourceTree = "<group>"; };
-		04735E5E18A5B42D00C89C30 /* LoginTokenOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LoginTokenOp.h; sourceTree = "<group>"; };
-		04735E5F18A5B42D00C89C30 /* LoginTokenOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LoginTokenOp.m; sourceTree = "<group>"; };
 		047528A3190F0C2900F2CDA8 /* WikiGlyph_Chars.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikiGlyph_Chars.h; sourceTree = "<group>"; };
 		047528AD19107DAA00F2CDA8 /* Section.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Section.h; sourceTree = "<group>"; };
 		047528AE19107DAA00F2CDA8 /* Section.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Section.m; sourceTree = "<group>"; };
@@ -347,8 +369,6 @@
 		047528B11913110000F2CDA8 /* Section+LeadSection.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "Section+LeadSection.m"; sourceTree = "<group>"; };
 		047528B3191465C400F2CDA8 /* Article.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Article.h; sourceTree = "<group>"; };
 		047528B4191465C400F2CDA8 /* Article.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Article.m; sourceTree = "<group>"; };
-		0476967A18BBFC9400071963 /* AccountCreationOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AccountCreationOp.h; sourceTree = "<group>"; };
-		0476967B18BBFC9400071963 /* AccountCreationOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AccountCreationOp.m; sourceTree = "<group>"; };
 		047801BC18AE987900DBB747 /* UIButton+ColorMask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIButton+ColorMask.h"; sourceTree = "<group>"; };
 		047801BD18AE987900DBB747 /* UIButton+ColorMask.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIButton+ColorMask.m"; sourceTree = "<group>"; };
 		047E74131860509000916964 /* SavedPagesResultPrototypeView.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = SavedPagesResultPrototypeView.xib; sourceTree = "<group>"; };
@@ -365,8 +385,47 @@
 		0484E3DC19D9D19B0085D18D /* UIView+ConstraintsScale.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+ConstraintsScale.h"; sourceTree = "<group>"; };
 		0484E3DD19D9D19B0085D18D /* UIView+ConstraintsScale.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+ConstraintsScale.m"; sourceTree = "<group>"; };
 		0485FECD1994D5AE00141361 /* NearbyResultCell.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = NearbyResultCell.xib; sourceTree = "<group>"; };
-		0485FED01994E22400141361 /* NearbyOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NearbyOp.h; sourceTree = "<group>"; };
-		0485FED11994E22400141361 /* NearbyOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NearbyOp.m; sourceTree = "<group>"; };
+		0487041319F7683300B7D307 /* Cocoapods Notes.txt */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "Cocoapods Notes.txt"; sourceTree = "<group>"; };
+		0487044019F824D700B7D307 /* QueuesSingleton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QueuesSingleton.h; sourceTree = "<group>"; };
+		0487044119F824D700B7D307 /* QueuesSingleton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = QueuesSingleton.m; sourceTree = "<group>"; };
+		0487045719F8262600B7D307 /* AccountCreationTokenFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AccountCreationTokenFetcher.h; sourceTree = "<group>"; };
+		0487045819F8262600B7D307 /* AccountCreationTokenFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AccountCreationTokenFetcher.m; sourceTree = "<group>"; };
+		0487045919F8262600B7D307 /* AccountCreator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AccountCreator.h; sourceTree = "<group>"; };
+		0487045A19F8262600B7D307 /* AccountCreator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AccountCreator.m; sourceTree = "<group>"; };
+		0487045B19F8262600B7D307 /* AccountLogin.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AccountLogin.h; sourceTree = "<group>"; };
+		0487045C19F8262600B7D307 /* AccountLogin.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AccountLogin.m; sourceTree = "<group>"; };
+		0487045D19F8262600B7D307 /* ArticleFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArticleFetcher.h; sourceTree = "<group>"; };
+		0487045E19F8262600B7D307 /* ArticleFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ArticleFetcher.m; sourceTree = "<group>"; };
+		0487045F19F8262600B7D307 /* AssetsFileFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AssetsFileFetcher.h; sourceTree = "<group>"; };
+		0487046019F8262600B7D307 /* AssetsFileFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AssetsFileFetcher.m; sourceTree = "<group>"; };
+		0487046219F8262600B7D307 /* FetcherBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetcherBase.h; sourceTree = "<group>"; };
+		0487046319F8262600B7D307 /* FetcherBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FetcherBase.m; sourceTree = "<group>"; };
+		0487046419F8262600B7D307 /* CaptchaResetter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CaptchaResetter.h; sourceTree = "<group>"; };
+		0487046519F8262600B7D307 /* CaptchaResetter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CaptchaResetter.m; sourceTree = "<group>"; };
+		0487046619F8262600B7D307 /* EditTokenFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EditTokenFetcher.h; sourceTree = "<group>"; };
+		0487046719F8262600B7D307 /* EditTokenFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = EditTokenFetcher.m; sourceTree = "<group>"; };
+		0487046819F8262600B7D307 /* LanguageLinksFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LanguageLinksFetcher.h; sourceTree = "<group>"; };
+		0487046919F8262600B7D307 /* LanguageLinksFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LanguageLinksFetcher.m; sourceTree = "<group>"; };
+		0487046A19F8262600B7D307 /* LoginTokenFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LoginTokenFetcher.h; sourceTree = "<group>"; };
+		0487046B19F8262600B7D307 /* LoginTokenFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LoginTokenFetcher.m; sourceTree = "<group>"; };
+		0487046C19F8262600B7D307 /* NearbyFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NearbyFetcher.h; sourceTree = "<group>"; };
+		0487046D19F8262600B7D307 /* NearbyFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NearbyFetcher.m; sourceTree = "<group>"; };
+		0487046E19F8262600B7D307 /* PageHistoryFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PageHistoryFetcher.h; sourceTree = "<group>"; };
+		0487046F19F8262600B7D307 /* PageHistoryFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PageHistoryFetcher.m; sourceTree = "<group>"; };
+		0487047019F8262600B7D307 /* PreviewHtmlFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PreviewHtmlFetcher.h; sourceTree = "<group>"; };
+		0487047119F8262600B7D307 /* PreviewHtmlFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PreviewHtmlFetcher.m; sourceTree = "<group>"; };
+		0487047219F8262600B7D307 /* RandomArticleFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RandomArticleFetcher.h; sourceTree = "<group>"; };
+		0487047319F8262600B7D307 /* RandomArticleFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = RandomArticleFetcher.m; sourceTree = "<group>"; };
+		0487047419F8262600B7D307 /* SearchResultFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SearchResultFetcher.h; sourceTree = "<group>"; };
+		0487047519F8262600B7D307 /* SearchResultFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SearchResultFetcher.m; sourceTree = "<group>"; };
+		0487047619F8262600B7D307 /* ThumbnailFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ThumbnailFetcher.h; sourceTree = "<group>"; };
+		0487047719F8262600B7D307 /* ThumbnailFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ThumbnailFetcher.m; sourceTree = "<group>"; };
+		0487047819F8262600B7D307 /* WikipediaZeroMessageFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikipediaZeroMessageFetcher.h; sourceTree = "<group>"; };
+		0487047919F8262600B7D307 /* WikipediaZeroMessageFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WikipediaZeroMessageFetcher.m; sourceTree = "<group>"; };
+		0487047A19F8262600B7D307 /* WikiTextSectionFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikiTextSectionFetcher.h; sourceTree = "<group>"; };
+		0487047B19F8262600B7D307 /* WikiTextSectionFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WikiTextSectionFetcher.m; sourceTree = "<group>"; };
+		0487047C19F8262600B7D307 /* WikiTextSectionUploader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikiTextSectionUploader.h; sourceTree = "<group>"; };
+		0487047D19F8262600B7D307 /* WikiTextSectionUploader.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WikiTextSectionUploader.m; sourceTree = "<group>"; };
 		048A26751906268100395F53 /* PaddedLabel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PaddedLabel.h; sourceTree = "<group>"; };
 		048A26761906268100395F53 /* PaddedLabel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; lineEnding = 0; path = PaddedLabel.m; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objc; };
 		0493C2CA1952373100EBB973 /* CoreDataHousekeeping.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreDataHousekeeping.h; sourceTree = "<group>"; };
@@ -376,8 +435,6 @@
 		0493C2D519526FFE00EBB973 /* WikiFont-Glyphs-iOS.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "WikiFont-Glyphs-iOS.ttf"; sourceTree = "<group>"; };
 		049566C018F5F4CB0058EA12 /* ZeroConfigState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZeroConfigState.h; sourceTree = "<group>"; };
 		049566C118F5F4CB0058EA12 /* ZeroConfigState.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZeroConfigState.m; sourceTree = "<group>"; };
-		04992BBE18B687AF00A6C22B /* SearchOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SearchOp.h; sourceTree = "<group>"; };
-		04992BBF18B687AF00A6C22B /* SearchOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SearchOp.m; sourceTree = "<group>"; };
 		049B640A18AAF36200D98BD4 /* UIViewController+SearchChildViewControllers.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIViewController+SearchChildViewControllers.h"; sourceTree = "<group>"; };
 		049B640B18AAF36200D98BD4 /* UIViewController+SearchChildViewControllers.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIViewController+SearchChildViewControllers.m"; sourceTree = "<group>"; };
 		04A70FD5185BB6C300E24515 /* URLCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = URLCache.h; sourceTree = "<group>"; };
@@ -403,8 +460,6 @@
 		04B6050F1935236C0007185A /* WikiGlyphLabel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WikiGlyphLabel.m; sourceTree = "<group>"; };
 		04B6924E18E77B2A00F88D8A /* UIWebView+HideScrollGradient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIWebView+HideScrollGradient.h"; sourceTree = "<group>"; };
 		04B6924F18E77B2A00F88D8A /* UIWebView+HideScrollGradient.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIWebView+HideScrollGradient.m"; sourceTree = "<group>"; };
-		04B78A5118A580AF0050EBF5 /* LoginOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LoginOp.h; sourceTree = "<group>"; };
-		04B78A5218A580AF0050EBF5 /* LoginOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LoginOp.m; sourceTree = "<group>"; };
 		04B7B9BB18B5570E00A63551 /* CaptchaViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CaptchaViewController.h; sourceTree = "<group>"; };
 		04B7B9BC18B5570E00A63551 /* CaptchaViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; lineEnding = 0; path = CaptchaViewController.m; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objc; };
 		04B91AA518E34BBC00FFAA1C /* UIView+TemporaryAnimatedXF.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+TemporaryAnimatedXF.h"; sourceTree = "<group>"; };
@@ -415,34 +470,28 @@
 		04B91AB618E4D5B200FFAA1C /* TabularScrollView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TabularScrollView.m; sourceTree = "<group>"; };
 		04C0A0761936786000D55325 /* UIViewController+ModalPresent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIViewController+ModalPresent.h"; sourceTree = "<group>"; };
 		04C0A0771936786000D55325 /* UIViewController+ModalPresent.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIViewController+ModalPresent.m"; sourceTree = "<group>"; };
-		04C43A9B183440B0006C643B /* MWCrumbyTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MWCrumbyTest.h; sourceTree = "<group>"; };
-		04C43A9C183440B0006C643B /* MWCrumbyTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWCrumbyTest.m; sourceTree = "<group>"; };
 		04C43AA0183440C1006C643B /* MWNetworkActivityIndicatorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MWNetworkActivityIndicatorManager.h; sourceTree = "<group>"; };
 		04C43AA1183440C1006C643B /* MWNetworkActivityIndicatorManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWNetworkActivityIndicatorManager.m; sourceTree = "<group>"; };
-		04C43AA2183440C1006C643B /* MWNetworkOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MWNetworkOp.h; sourceTree = "<group>"; };
-		04C43AA3183440C1006C643B /* MWNetworkOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWNetworkOp.m; sourceTree = "<group>"; };
 		04C43AAA18344131006C643B /* CommunicationBridge.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CommunicationBridge.h; sourceTree = "<group>"; };
 		04C43AAB18344131006C643B /* CommunicationBridge.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CommunicationBridge.m; sourceTree = "<group>"; };
-		04C43AB51834423C006C643B /* NetworkOpCrumbyTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NetworkOpCrumbyTests.m; sourceTree = "<group>"; };
 		04C43AB8183442FC006C643B /* NSRunLoop+TimeOutAndFlag.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSRunLoop+TimeOutAndFlag.h"; sourceTree = "<group>"; };
 		04C43AB9183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSRunLoop+TimeOutAndFlag.m"; sourceTree = "<group>"; };
 		04C43ABA183442FC006C643B /* NSString+Extras.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSString+Extras.h"; sourceTree = "<group>"; };
 		04C43ABB183442FC006C643B /* NSString+Extras.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSString+Extras.m"; sourceTree = "<group>"; };
 		04C43ABC183442FC006C643B /* NSURLRequest+DictionaryRequest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSURLRequest+DictionaryRequest.h"; sourceTree = "<group>"; };
 		04C43ABD183442FC006C643B /* NSURLRequest+DictionaryRequest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSURLRequest+DictionaryRequest.m"; sourceTree = "<group>"; };
-		04C43AC4183446F2006C643B /* NetworkOpTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NetworkOpTests.m; sourceTree = "<group>"; };
 		04C695CC18ED08D900D9F2DA /* UIView+SearchSubviews.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+SearchSubviews.h"; sourceTree = "<group>"; };
 		04C695CD18ED08D900D9F2DA /* UIView+SearchSubviews.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+SearchSubviews.m"; sourceTree = "<group>"; };
 		04C695D018ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIScrollView+NoHorizontalScrolling.h"; sourceTree = "<group>"; };
 		04C695D118ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIScrollView+NoHorizontalScrolling.m"; sourceTree = "<group>"; };
-		04C8780E18F4A42700FA3B99 /* AccountCreationTokenOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AccountCreationTokenOp.h; sourceTree = "<group>"; };
-		04C8780F18F4A42700FA3B99 /* AccountCreationTokenOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AccountCreationTokenOp.m; sourceTree = "<group>"; };
 		04C91CE9195517250035ED1B /* OnboardingViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = OnboardingViewController.h; sourceTree = "<group>"; };
 		04C91CEA195517250035ED1B /* OnboardingViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = OnboardingViewController.m; sourceTree = "<group>"; };
 		04C91CEC195520990035ED1B /* logo-onboarding-subtitle.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-onboarding-subtitle.png"; sourceTree = "<group>"; };
 		04C91CED195520990035ED1B /* logo-onboarding-subtitle@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-onboarding-subtitle@2x.png"; sourceTree = "<group>"; };
 		04C91CF019554B310035ED1B /* logo-onboarding.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-onboarding.png"; sourceTree = "<group>"; };
 		04C91CF119554B310035ED1B /* logo-onboarding@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-onboarding@2x.png"; sourceTree = "<group>"; };
+		04C9509B19EF02980013F3C0 /* EventLogger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventLogger.h; path = EventLogging/EventLogger.h; sourceTree = "<group>"; };
+		04C9509C19EF02980013F3C0 /* EventLogger.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = EventLogger.m; path = EventLogging/EventLogger.m; sourceTree = "<group>"; };
 		04CBAC7119A9B786009F3D7E /* NSArray+Predicate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSArray+Predicate.h"; sourceTree = "<group>"; };
 		04CBAC7219A9B786009F3D7E /* NSArray+Predicate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSArray+Predicate.m"; sourceTree = "<group>"; };
 		04CCA0BE1983086D000E982A /* ReferencesVC.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReferencesVC.h; sourceTree = "<group>"; };
@@ -470,18 +519,10 @@
 		04D149DA18877343006B4104 /* AlertLabel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AlertLabel.m; sourceTree = "<group>"; };
 		04D149DB18877343006B4104 /* UIViewController+Alert.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIViewController+Alert.h"; sourceTree = "<group>"; };
 		04D149DC18877343006B4104 /* UIViewController+Alert.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIViewController+Alert.m"; sourceTree = "<group>"; };
-		04D149EA18888A0D006B4104 /* DownloadSectionsOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DownloadSectionsOp.h; sourceTree = "<group>"; };
-		04D149EB18888A0D006B4104 /* DownloadSectionsOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DownloadSectionsOp.m; sourceTree = "<group>"; };
 		04D308261998A8AA0034F106 /* NearbyThumbnailView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NearbyThumbnailView.h; sourceTree = "<group>"; };
 		04D308271998A8AA0034F106 /* NearbyThumbnailView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NearbyThumbnailView.m; sourceTree = "<group>"; };
 		04D3082919991CB60034F106 /* logo-placeholder-nearby.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-placeholder-nearby.png"; sourceTree = "<group>"; };
 		04D3082A19991CB60034F106 /* logo-placeholder-nearby@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "logo-placeholder-nearby@2x.png"; sourceTree = "<group>"; };
-		04D34DA51863D2D600610A87 /* TFHpple.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TFHpple.h; sourceTree = "<group>"; };
-		04D34DA61863D2D600610A87 /* TFHpple.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TFHpple.m; sourceTree = "<group>"; };
-		04D34DA71863D2D600610A87 /* TFHppleElement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TFHppleElement.h; sourceTree = "<group>"; };
-		04D34DA81863D2D600610A87 /* TFHppleElement.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TFHppleElement.m; sourceTree = "<group>"; };
-		04D34DA91863D2D600610A87 /* XPathQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XPathQuery.h; sourceTree = "<group>"; };
-		04D34DAA1863D2D600610A87 /* XPathQuery.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = XPathQuery.m; sourceTree = "<group>"; };
 		04D34DB11863D39000610A87 /* libxml2.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libxml2.dylib; path = usr/lib/libxml2.dylib; sourceTree = SDKROOT; };
 		04D34DB71863F69500610A87 /* DiscoveryContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DiscoveryContext.h; sourceTree = "<group>"; };
 		04D34DB81863F69500610A87 /* DiscoveryContext.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DiscoveryContext.m; sourceTree = "<group>"; };
@@ -495,10 +536,6 @@
 		04D34DD01863F6E600610A87 /* SectionImage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SectionImage.m; sourceTree = "<group>"; };
 		04D34DDF1868E21F00610A87 /* Article+Convenience.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "Article+Convenience.h"; sourceTree = "<group>"; };
 		04D34DE01868E21F00610A87 /* Article+Convenience.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "Article+Convenience.m"; sourceTree = "<group>"; };
-		04D75822189248E900CE2040 /* DownloadLangLinksOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DownloadLangLinksOp.h; sourceTree = "<group>"; };
-		04D75823189248E900CE2040 /* DownloadLangLinksOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DownloadLangLinksOp.m; sourceTree = "<group>"; };
-		04DB0BE418BC2E1E00B4BCF3 /* CaptchaResetOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CaptchaResetOp.h; sourceTree = "<group>"; };
-		04DB0BE518BC2E1E00B4BCF3 /* CaptchaResetOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CaptchaResetOp.m; sourceTree = "<group>"; };
 		04DB0BE818BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIScrollView+ScrollSubviewToLocation.h"; sourceTree = "<group>"; };
 		04DB0BE918BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIScrollView+ScrollSubviewToLocation.m"; sourceTree = "<group>"; };
 		04DD89AF18BFE63A00DD5DAD /* PreviewAndSaveViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PreviewAndSaveViewController.h; sourceTree = "<group>"; };
@@ -513,17 +550,11 @@
 		04F27B7018FE0F2E00EDD838 /* PageHistoryResultPrototypeView.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = PageHistoryResultPrototypeView.xib; sourceTree = "<group>"; };
 		04F27B7318FE0F2E00EDD838 /* PageHistoryViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PageHistoryViewController.h; sourceTree = "<group>"; };
 		04F27B7418FE0F2E00EDD838 /* PageHistoryViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; lineEnding = 0; path = PageHistoryViewController.m; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objc; };
-		04F27B7918FE19B700EDD838 /* PageHistoryOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PageHistoryOp.h; sourceTree = "<group>"; };
-		04F27B7A18FE19B700EDD838 /* PageHistoryOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PageHistoryOp.m; sourceTree = "<group>"; };
 		04F3958E186CF80100B0D6FC /* TOCViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TOCViewController.h; sourceTree = "<group>"; };
 		04F3958F186CF80100B0D6FC /* TOCViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TOCViewController.m; sourceTree = "<group>"; };
 		04FD6C79184EBFCD002CA02F /* ArticleData.xcdatamodel */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcdatamodel; path = ArticleData.xcdatamodel; sourceTree = "<group>"; };
 		C9180EC218AED30C006C1DCA /* WikipediaAppUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikipediaAppUtils.h; sourceTree = "<group>"; };
 		C9180EC318AED30C006C1DCA /* WikipediaAppUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WikipediaAppUtils.m; sourceTree = "<group>"; };
-		C958EE3218CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DownloadTitlesForRandomArticlesOp.h; sourceTree = "<group>"; };
-		C958EE3318CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DownloadTitlesForRandomArticlesOp.m; sourceTree = "<group>"; };
-		C9928B8418AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DownloadWikipediaZeroMessageOp.h; sourceTree = "<group>"; };
-		C9928B8518AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DownloadWikipediaZeroMessageOp.m; sourceTree = "<group>"; };
 		D42E75E918D11237002EA7E5 /* MWLanguageInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MWLanguageInfo.h; path = "mw-support/MWLanguageInfo.h"; sourceTree = "<group>"; };
 		D42E75EA18D11237002EA7E5 /* MWLanguageInfo.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = MWLanguageInfo.m; path = "mw-support/MWLanguageInfo.m"; sourceTree = "<group>"; };
 		D442F58619709E540013A2CA /* qqq */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = qqq; path = qqq.lproj/Main_iPhone.strings; sourceTree = "<group>"; };
@@ -638,7 +669,6 @@
 		D46CD8CC18A1ACA20042959E /* fr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fr; path = fr.lproj/Main_iPhone.strings; sourceTree = "<group>"; };
 		D46CD8D218A1B10A0042959E /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		D46CD8D318A1B1140042959E /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/Localizable.strings; sourceTree = "<group>"; };
-		D474CC10182AE033002BDE45 /* SiteTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SiteTests.m; sourceTree = "<group>"; };
 		D474CC12182AE07C002BDE45 /* WikipediaApp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WikipediaApp.h; sourceTree = "<group>"; };
 		D474CC13182AE196002BDE45 /* MWSite.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MWSite.h; path = "mw-support/MWSite.h"; sourceTree = "<group>"; };
 		D474CC14182AE196002BDE45 /* MWSite.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = MWSite.m; path = "mw-support/MWSite.m"; sourceTree = "<group>"; };
@@ -665,11 +695,9 @@
 		D499144B181D51DE00E6073C /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main_iPhone.storyboard; sourceTree = "<group>"; };
 		D4991453181D51DE00E6073C /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = wikipedia/Images.xcassets; sourceTree = "<group>"; };
 		D499145A181D51DF00E6073C /* XCTest.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = XCTest.framework; path = Library/Frameworks/XCTest.framework; sourceTree = DEVELOPER_DIR; };
-		D4991462181D51DF00E6073C /* Wikipedia-Tests-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "Wikipedia-Tests-Info.plist"; sourceTree = "<group>"; };
-		D4991464181D51DF00E6073C /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
-		D4991466181D51DF00E6073C /* Wikipedia_Tests.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Wikipedia_Tests.m; sourceTree = "<group>"; };
 		D49B2ED0196C687C002F035D /* PullToRefreshViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PullToRefreshViewController.h; path = PullToRefresh/PullToRefreshViewController.h; sourceTree = "<group>"; };
 		D49B2ED1196C687C002F035D /* PullToRefreshViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = PullToRefreshViewController.m; path = PullToRefresh/PullToRefreshViewController.m; sourceTree = "<group>"; };
+		D4AD973E19F99CD700957451 /* Pods.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.pb-project"; name = Pods.xcodeproj; path = cocoapods/Pods/Pods.xcodeproj; sourceTree = "<group>"; };
 		D4B0AE0019365F7C00F0AC90 /* EventLoggingFunnel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventLoggingFunnel.h; path = EventLogging/EventLoggingFunnel.h; sourceTree = "<group>"; };
 		D4B0AE0119365F7C00F0AC90 /* EventLoggingFunnel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = EventLoggingFunnel.m; path = EventLogging/EventLoggingFunnel.m; sourceTree = "<group>"; };
 		D4B0AE031936604700F0AC90 /* EditFunnel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EditFunnel.h; path = EventLogging/EditFunnel.h; sourceTree = "<group>"; };
@@ -745,7 +773,6 @@
 		D4C16A6419709CDF00CD91AD /* qqq */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = qqq; path = qqq.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		D4C16A6519709CDF00CD91AD /* qqq */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = qqq; path = qqq.lproj/Localizable.strings; sourceTree = "<group>"; };
 		D4CA33D71959FDEC0093588B /* ArticleData 2.xcdatamodel */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcdatamodel; path = "ArticleData 2.xcdatamodel"; sourceTree = "<group>"; };
-		D4DE203018283FF200148CA2 /* CommunicationBridgeTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CommunicationBridgeTests.m; sourceTree = "<group>"; };
 		D4E8A8A2190835C100DA4765 /* DataMigrator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DataMigrator.h; path = wikipedia/DataMigrator.h; sourceTree = SOURCE_ROOT; };
 		D4E8A8A3190835C100DA4765 /* DataMigrator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = DataMigrator.m; path = wikipedia/DataMigrator.m; sourceTree = SOURCE_ROOT; };
 		D4E8A8A519084F1300DA4765 /* SQLiteHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SQLiteHelper.h; sourceTree = "<group>"; };
@@ -753,11 +780,11 @@
 		D4E8A8A819085CEA00DA4765 /* libsqlite3.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libsqlite3.dylib; path = usr/lib/libsqlite3.dylib; sourceTree = SDKROOT; };
 		D4EE00B7182443FC0090790F /* MWPageTitle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MWPageTitle.h; path = "mw-support/MWPageTitle.h"; sourceTree = "<group>"; };
 		D4EE00B8182443FC0090790F /* MWPageTitle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = MWPageTitle.m; path = "mw-support/MWPageTitle.m"; sourceTree = "<group>"; };
-		D4EE00BC1824459D0090790F /* PageTitleTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = PageTitleTests.m; path = "mw-support/PageTitleTests.m"; sourceTree = "<group>"; };
 		D4F277F9194235A00032BA38 /* ProtectedEditAttemptFunnel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ProtectedEditAttemptFunnel.h; path = EventLogging/ProtectedEditAttemptFunnel.h; sourceTree = "<group>"; };
 		D4F277FA194235A00032BA38 /* ProtectedEditAttemptFunnel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = ProtectedEditAttemptFunnel.m; path = EventLogging/ProtectedEditAttemptFunnel.m; sourceTree = "<group>"; };
 		D4F277FC194235B50032BA38 /* ToCInteractionFunnel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ToCInteractionFunnel.h; path = EventLogging/ToCInteractionFunnel.h; sourceTree = "<group>"; };
 		D4F277FD194235B50032BA38 /* ToCInteractionFunnel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = ToCInteractionFunnel.m; path = EventLogging/ToCInteractionFunnel.m; sourceTree = "<group>"; };
+		D82982ED992F47428037BDF2 /* libPods.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libPods.a; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -765,6 +792,8 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				D4AD975019F99E9000957451 /* libPods-hpple.a in Frameworks */,
+				D4AD974E19F99E7C00957451 /* libPods-AFNetworking.a in Frameworks */,
 				D4E8A8A919085CEA00DA4765 /* libsqlite3.dylib in Frameworks */,
 				04D34DB21863D39000610A87 /* libxml2.dylib in Frameworks */,
 				D499143B181D51DE00E6073C /* CoreGraphics.framework in Frameworks */,
@@ -783,7 +812,6 @@
 				040E5C821846AC13007AFE6F /* ArticleDataContextSingleton.h */,
 				040E5C831846AC13007AFE6F /* ArticleDataContextSingleton.m */,
 				04EA7779184E4CED00D2F3C9 /* Model */,
-				04D149E5188889CA006B4104 /* Operations */,
 				D4E8A8A11908357600DA4765 /* Data Migration */,
 				04B0EA42190AFDBA007458AF /* Importer */,
 			);
@@ -864,15 +892,6 @@
 			path = Defines;
 			sourceTree = "<group>";
 		};
-		04292FFD185FC2C7002A13FC /* Queues */ = {
-			isa = PBXGroup;
-			children = (
-				04292FFE185FC2C7002A13FC /* QueuesSingleton.h */,
-				04292FFF185FC2C7002A13FC /* QueuesSingleton.m */,
-			);
-			path = Queues;
-			sourceTree = "<group>";
-		};
 		04293002186030B0002A13FC /* SavedPages */ = {
 			isa = PBXGroup;
 			children = (
@@ -1080,6 +1099,77 @@
 			path = Nearby;
 			sourceTree = "<group>";
 		};
+		0487041519F824D700B7D307 /* Networking */ = {
+			isa = PBXGroup;
+			children = (
+				0487045619F8262600B7D307 /* Fetchers */,
+				0487043F19F824D700B7D307 /* Queues */,
+			);
+			path = Networking;
+			sourceTree = "<group>";
+		};
+		0487043F19F824D700B7D307 /* Queues */ = {
+			isa = PBXGroup;
+			children = (
+				0487044019F824D700B7D307 /* QueuesSingleton.h */,
+				0487044119F824D700B7D307 /* QueuesSingleton.m */,
+			);
+			path = Queues;
+			sourceTree = "<group>";
+		};
+		0487045619F8262600B7D307 /* Fetchers */ = {
+			isa = PBXGroup;
+			children = (
+				0487046119F8262600B7D307 /* BaseFetcher */,
+				0487045719F8262600B7D307 /* AccountCreationTokenFetcher.h */,
+				0487045819F8262600B7D307 /* AccountCreationTokenFetcher.m */,
+				0487045919F8262600B7D307 /* AccountCreator.h */,
+				0487045A19F8262600B7D307 /* AccountCreator.m */,
+				0487045B19F8262600B7D307 /* AccountLogin.h */,
+				0487045C19F8262600B7D307 /* AccountLogin.m */,
+				0487045D19F8262600B7D307 /* ArticleFetcher.h */,
+				0487045E19F8262600B7D307 /* ArticleFetcher.m */,
+				0487045F19F8262600B7D307 /* AssetsFileFetcher.h */,
+				0487046019F8262600B7D307 /* AssetsFileFetcher.m */,
+				0487046419F8262600B7D307 /* CaptchaResetter.h */,
+				0487046519F8262600B7D307 /* CaptchaResetter.m */,
+				0487046619F8262600B7D307 /* EditTokenFetcher.h */,
+				0487046719F8262600B7D307 /* EditTokenFetcher.m */,
+				0487046819F8262600B7D307 /* LanguageLinksFetcher.h */,
+				0487046919F8262600B7D307 /* LanguageLinksFetcher.m */,
+				0487046A19F8262600B7D307 /* LoginTokenFetcher.h */,
+				0487046B19F8262600B7D307 /* LoginTokenFetcher.m */,
+				0487046C19F8262600B7D307 /* NearbyFetcher.h */,
+				0487046D19F8262600B7D307 /* NearbyFetcher.m */,
+				0487046E19F8262600B7D307 /* PageHistoryFetcher.h */,
+				0487046F19F8262600B7D307 /* PageHistoryFetcher.m */,
+				0487047019F8262600B7D307 /* PreviewHtmlFetcher.h */,
+				0487047119F8262600B7D307 /* PreviewHtmlFetcher.m */,
+				0487047219F8262600B7D307 /* RandomArticleFetcher.h */,
+				0487047319F8262600B7D307 /* RandomArticleFetcher.m */,
+				0487047419F8262600B7D307 /* SearchResultFetcher.h */,
+				0487047519F8262600B7D307 /* SearchResultFetcher.m */,
+				0487047619F8262600B7D307 /* ThumbnailFetcher.h */,
+				0487047719F8262600B7D307 /* ThumbnailFetcher.m */,
+				0487047819F8262600B7D307 /* WikipediaZeroMessageFetcher.h */,
+				0487047919F8262600B7D307 /* WikipediaZeroMessageFetcher.m */,
+				0487047A19F8262600B7D307 /* WikiTextSectionFetcher.h */,
+				0487047B19F8262600B7D307 /* WikiTextSectionFetcher.m */,
+				0487047C19F8262600B7D307 /* WikiTextSectionUploader.h */,
+				0487047D19F8262600B7D307 /* WikiTextSectionUploader.m */,
+			);
+			path = Fetchers;
+			sourceTree = "<group>";
+		};
+		0487046119F8262600B7D307 /* BaseFetcher */ = {
+			isa = PBXGroup;
+			children = (
+				0487046219F8262600B7D307 /* FetcherBase.h */,
+				0487046319F8262600B7D307 /* FetcherBase.m */,
+			);
+			path = BaseFetcher;
+			sourceTree = "<group>";
+		};
 		048A26741906268100395F53 /* PaddedLabel */ = {
 			isa = PBXGroup;
 			children = (
@@ -1175,22 +1265,11 @@
 			path = TabularScrollView;
 			sourceTree = "<group>";
 		};
-		04C43A9A183440B0006C643B /* mw-crumbtest */ = {
-			isa = PBXGroup;
-			children = (
-				04C43A9B183440B0006C643B /* MWCrumbyTest.h */,
-				04C43A9C183440B0006C643B /* MWCrumbyTest.m */,
-			);
-			path = "mw-crumbtest";
-			sourceTree = "<group>";
-		};
 		04C43A9F183440C1006C643B /* mw-network */ = {
 			isa = PBXGroup;
 			children = (
 				04C43AA0183440C1006C643B /* MWNetworkActivityIndicatorManager.h */,
 				04C43AA1183440C1006C643B /* MWNetworkActivityIndicatorManager.m */,
-				04C43AA2183440C1006C643B /* MWNetworkOp.h */,
-				04C43AA3183440C1006C643B /* MWNetworkOp.m */,
 			);
 			path = "mw-network";
 			sourceTree = "<group>";
@@ -1367,70 +1446,6 @@
 			path = Alerts;
 			sourceTree = "<group>";
 		};
-		04D149E5188889CA006B4104 /* Operations */ = {
-			isa = PBXGroup;
-			children = (
-				044213C6191C3C2A006C03BF /* SyncAssetsFileOp.h */,
-				044213C7191C3C2A006C03BF /* SyncAssetsFileOp.m */,
-				04F27B7918FE19B700EDD838 /* PageHistoryOp.h */,
-				04F27B7A18FE19B700EDD838 /* PageHistoryOp.m */,
-				0406CEF418F8C390007EE43E /* LogEventOp.h */,
-				0406CEF518F8C390007EE43E /* LogEventOp.m */,
-				043C668818BE9A8E00580E9B /* PreviewWikiTextOp.h */,
-				043C668918BE9A8E00580E9B /* PreviewWikiTextOp.m */,
-				0476967A18BBFC9400071963 /* AccountCreationOp.h */,
-				0476967B18BBFC9400071963 /* AccountCreationOp.m */,
-				04C8780E18F4A42700FA3B99 /* AccountCreationTokenOp.h */,
-				04C8780F18F4A42700FA3B99 /* AccountCreationTokenOp.m */,
-				04DB0BE418BC2E1E00B4BCF3 /* CaptchaResetOp.h */,
-				04DB0BE518BC2E1E00B4BCF3 /* CaptchaResetOp.m */,
-				04992BBE18B687AF00A6C22B /* SearchOp.h */,
-				04992BBF18B687AF00A6C22B /* SearchOp.m */,
-				04B78A5118A580AF0050EBF5 /* LoginOp.h */,
-				04B78A5218A580AF0050EBF5 /* LoginOp.m */,
-				04735E5E18A5B42D00C89C30 /* LoginTokenOp.h */,
-				04735E5F18A5B42D00C89C30 /* LoginTokenOp.m */,
-				0485FED01994E22400141361 /* NearbyOp.h */,
-				0485FED11994E22400141361 /* NearbyOp.m */,
-				0463639118A5CCEB0049EE4F /* EditTokenOp.h */,
-				0463639218A5CCEB0049EE4F /* EditTokenOp.m */,
-				0460990818899A9800B1F2BC /* DownloadSectionWikiTextOp.h */,
-				0460990918899A9800B1F2BC /* DownloadSectionWikiTextOp.m */,
-				0460990C1889A0DD00B1F2BC /* UploadSectionWikiTextOp.h */,
-				0460990D1889A0DD00B1F2BC /* UploadSectionWikiTextOp.m */,
-				04D149EA18888A0D006B4104 /* DownloadSectionsOp.h */,
-				04D149EB18888A0D006B4104 /* DownloadSectionsOp.m */,
-				04D75822189248E900CE2040 /* DownloadLangLinksOp.h */,
-				04D75823189248E900CE2040 /* DownloadLangLinksOp.m */,
-				C9928B8418AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.h */,
-				C9928B8518AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.m */,
-				C958EE3218CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.h */,
-				C958EE3318CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.m */,
-			);
-			path = Operations;
-			sourceTree = "<group>";
-		};
-		04D34DA31863D2D600610A87 /* HTML Parsing */ = {
-			isa = PBXGroup;
-			children = (
-				04D34DA41863D2D600610A87 /* hpple */,
-			);
-			path = "HTML Parsing";
-			sourceTree = "<group>";
-		};
-		04D34DA41863D2D600610A87 /* hpple */ = {
-			isa = PBXGroup;
-			children = (
-				04D34DA51863D2D600610A87 /* TFHpple.h */,
-				04D34DA61863D2D600610A87 /* TFHpple.m */,
-				04D34DA71863D2D600610A87 /* TFHppleElement.h */,
-				04D34DA81863D2D600610A87 /* TFHppleElement.m */,
-				04D34DA91863D2D600610A87 /* XPathQuery.h */,
-				04D34DAA1863D2D600610A87 /* XPathQuery.m */,
-			);
-			path = hpple;
-			sourceTree = "<group>";
-		};
 		04DD89AE18BFE63A00DD5DAD /* Preview */ = {
 			isa = PBXGroup;
 			children = (
@@ -1513,9 +1528,10 @@
 				D499143E181D51DE00E6073C /* Wikipedia */,
 				04E9A78218F73C7200F7ECF7 /* www */,
 				D4991453181D51DE00E6073C /* Images.xcassets */,
-				D4991460181D51DF00E6073C /* Wikipedia-Tests */,
 				D4991437181D51DE00E6073C /* Frameworks */,
 				D4991436181D51DE00E6073C /* Products */,
+				0487041319F7683300B7D307 /* Cocoapods Notes.txt */,
+				D4AD973E19F99CD700957451 /* Pods.xcodeproj */,
 			);
 			sourceTree = "<group>";
 		};
@@ -1530,6 +1546,7 @@
 		D4991437181D51DE00E6073C /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
+				04649CA619F72B360071E8FA /* libPods.a */,
 				041EFC361996A1F800B2CB28 /* MapKit.framework */,
 				D4E8A8A819085CEA00DA4765 /* libsqlite3.dylib */,
 				04D34DB11863D39000610A87 /* libxml2.dylib */,
@@ -1538,6 +1555,7 @@
 				D499143A181D51DE00E6073C /* CoreGraphics.framework */,
 				D499143C181D51DE00E6073C /* UIKit.framework */,
 				D499145A181D51DF00E6073C /* XCTest.framework */,
+				D82982ED992F47428037BDF2 /* libPods.a */,
 			);
 			name = Frameworks;
 			sourceTree = "<group>";
@@ -1559,21 +1577,19 @@
 				04292FFB185FC026002A13FC /* Defines */,
 				D4B0ADFF19365F4600F0AC90 /* EventLogging */,
 				0442F57C1900718600F55DF9 /* Fonts */,
-				04D34DA31863D2D600610A87 /* HTML Parsing */,
 				0493C2C91952373100EBB973 /* Housekeeping */,
 				0466F44C183A30CC00EA1FD7 /* Images */,
 				0463639518A844380049EE4F /* Keychain */,
 				04B60509193522650007185A /* MenuButton */,
 				04B6050D1935236C0007185A /* MenuLabel */,
+				0487041519F824D700B7D307 /* Networking */,
 				048A26741906268100395F53 /* PaddedLabel */,
-				04292FFD185FC2C7002A13FC /* Queues */,
 				0447866C1852B5010050563B /* Session */,
 				04B91AB418E4D58D00FFAA1C /* TabularScrollView */,
 				04C43AB0183441A4006C643B /* View Controllers */,
 				04A70FD4185BB6C300E24515 /* Web Image Interception */,
 				D499143F181D51DE00E6073C /* Supporting Files */,
 				04C43AA818344131006C643B /* mw-bridge */,
-				04C43A9A183440B0006C643B /* mw-crumbtest */,
 				04C43A9F183440C1006C643B /* mw-network */,
 				D4EE00BB182445670090790F /* mw-support */,
 				C9180EC118AED30C006C1DCA /* mw-utils */,
@@ -1593,43 +1609,30 @@
 			name = "Supporting Files";
 			sourceTree = "<group>";
 		};
-		D4991460181D51DF00E6073C /* Wikipedia-Tests */ = {
-			isa = PBXGroup;
-			children = (
-				D4991466181D51DF00E6073C /* Wikipedia_Tests.m */,
-				D4991461181D51DF00E6073C /* Supporting Files */,
-				D4EE00BC1824459D0090790F /* PageTitleTests.m */,
-				D4DE203018283FF200148CA2 /* CommunicationBridgeTests.m */,
-				04C43AB51834423C006C643B /* NetworkOpCrumbyTests.m */,
-				04C43AC4183446F2006C643B /* NetworkOpTests.m */,
-				D474CC10182AE033002BDE45 /* SiteTests.m */,
-				040E5C4C184564D0007AFE6F /* ArticleDataModel.m */,
-			);
-			name = "Wikipedia-Tests";
-			path = "wikipedia-tests";
-			sourceTree = "<group>";
-		};
-		D4991461181D51DF00E6073C /* Supporting Files */ = {
+		D49B2ECF196C684F002F035D /* PullToRefresh */ = {
 			isa = PBXGroup;
 			children = (
-				D4991462181D51DF00E6073C /* Wikipedia-Tests-Info.plist */,
-				D4991463181D51DF00E6073C /* InfoPlist.strings */,
+				D49B2ED0196C687C002F035D /* PullToRefreshViewController.h */,
+				D49B2ED1196C687C002F035D /* PullToRefreshViewController.m */,
 			);
-			name = "Supporting Files";
+			name = PullToRefresh;
 			sourceTree = "<group>";
 		};
-		D49B2ECF196C684F002F035D /* PullToRefresh */ = {
+		D4AD973F19F99CD700957451 /* Products */ = {
 			isa = PBXGroup;
 			children = (
-				D49B2ED0196C687C002F035D /* PullToRefreshViewController.h */,
-				D49B2ED1196C687C002F035D /* PullToRefreshViewController.m */,
+				D4AD974519F99CD700957451 /* libPods.a */,
+				D4AD974719F99CD700957451 /* libPods-AFNetworking.a */,
+				D4AD974919F99CD700957451 /* libPods-hpple.a */,
 			);
-			name = PullToRefresh;
+			name = Products;
 			sourceTree = "<group>";
 		};
 		D4B0ADFF19365F4600F0AC90 /* EventLogging */ = {
 			isa = PBXGroup;
 			children = (
+				04C9509B19EF02980013F3C0 /* EventLogger.h */,
+				04C9509C19EF02980013F3C0 /* EventLogger.m */,
 				D4B0AE0019365F7C00F0AC90 /* EventLoggingFunnel.h */,
 				D4B0AE0119365F7C00F0AC90 /* EventLoggingFunnel.m */,
 				D4B0AE031936604700F0AC90 /* EditFunnel.h */,
@@ -1683,6 +1686,7 @@
 			isa = PBXNativeTarget;
 			buildConfigurationList = D499146A181D51DF00E6073C /* Build configuration list for PBXNativeTarget "Wikipedia" */;
 			buildPhases = (
+				048702AE19F75B0800B7D307 /* ShellScript */,
 				D4991431181D51DE00E6073C /* Sources */,
 				D4991432181D51DE00E6073C /* Frameworks */,
 				04272E7619404CDF00CC682F /* ShellScript */,
@@ -1695,6 +1699,8 @@
 			buildRules = (
 			);
 			dependencies = (
+				D4AD974D19F99E4600957451 /* PBXTargetDependency */,
+				D4AD974B19F99E4200957451 /* PBXTargetDependency */,
 			);
 			name = Wikipedia;
 			productName = "Wikipedia-iOS";
@@ -1800,6 +1806,12 @@
 			mainGroup = D499142C181D51DE00E6073C;
 			productRefGroup = D4991436181D51DE00E6073C /* Products */;
 			projectDirPath = "";
+			projectReferences = (
+				{
+					ProductGroup = D4AD973F19F99CD700957451 /* Products */;
+					ProjectRef = D4AD973E19F99CD700957451 /* Pods.xcodeproj */;
+				},
+			);
 			projectRoot = "";
 			targets = (
 				D4991434181D51DE00E6073C /* Wikipedia */,
@@ -1807,6 +1819,30 @@
 		};
 /* End PBXProject section */
 
+/* Begin PBXReferenceProxy section */
+		D4AD974519F99CD700957451 /* libPods.a */ = {
+			isa = PBXReferenceProxy;
+			fileType = archive.ar;
+			path = libPods.a;
+			remoteRef = D4AD974419F99CD700957451 /* PBXContainerItemProxy */;
+			sourceTree = BUILT_PRODUCTS_DIR;
+		};
+		D4AD974719F99CD700957451 /* libPods-AFNetworking.a */ = {
+			isa = PBXReferenceProxy;
+			fileType = archive.ar;
+			path = "libPods-AFNetworking.a";
+			remoteRef = D4AD974619F99CD700957451 /* PBXContainerItemProxy */;
+			sourceTree = BUILT_PRODUCTS_DIR;
+		};
+		D4AD974919F99CD700957451 /* libPods-hpple.a */ = {
+			isa = PBXReferenceProxy;
+			fileType = archive.ar;
+			path = "libPods-hpple.a";
+			remoteRef = D4AD974819F99CD700957451 /* PBXContainerItemProxy */;
+			sourceTree = BUILT_PRODUCTS_DIR;
+		};
+/* End PBXReferenceProxy section */
+
 /* Begin PBXResourcesBuildPhase section */
 		D4991433181D51DE00E6073C /* Resources */ = {
 			isa = PBXResourcesBuildPhase;
@@ -1817,6 +1853,7 @@
 				045EFF1B19A25FEB00D0EDBB /* logo-placeholder-search@2x.png in Resources */,
 				D4991454181D51DE00E6073C /* Images.xcassets in Resources */,
 				D499144C181D51DE00E6073C /* Main_iPhone.storyboard in Resources */,
+				0487041419F7683300B7D307 /* Cocoapods Notes.txt in Resources */,
 				D46CD8C518A1AC4F0042959E /* Localizable.strings in Resources */,
 				04082B5318ADA25A00FAF3D6 /* text_field_x_circle_gray.png in Resources */,
 				04478631185145090050563B /* HistoryResultPrototypeView.xib in Resources */,
@@ -1896,6 +1933,19 @@
 			shellPath = /bin/sh;
 			shellScript = "scripts/icon-svgs-to-pngs.sh";
 		};
+		048702AE19F75B0800B7D307 /* ShellScript */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "#scripts/run-cocoapods.sh";
+		};
 		D4C16A621970946900CD91AD /* ShellScript */ = {
 			isa = PBXShellScriptBuildPhase;
 			buildActionMask = 2147483647;
@@ -1936,22 +1986,26 @@
 			files = (
 				D49B2ED2196C687C002F035D /* PullToRefreshViewController.m in Sources */,
 				0449E63518A9845C00D51524 /* LoginViewController.m in Sources */,
-				04D149EC18888A0D006B4104 /* DownloadSectionsOp.m in Sources */,
 				04DB0BEA18BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.m in Sources */,
+				0487048B19F8262600B7D307 /* RandomArticleFetcher.m in Sources */,
 				04D34DBD1863F6A400610A87 /* GalleryImage.m in Sources */,
 				047E95501996DD030046A122 /* NearbyResultCell.m in Sources */,
 				042A5B36192591520095E172 /* TopMenuTextField.m in Sources */,
-				04F27B7B18FE19B700EDD838 /* PageHistoryOp.m in Sources */,
 				04AE1C701891B302002D5487 /* NSObject+Extras.m in Sources */,
 				04B7B9BD18B5570E00A63551 /* CaptchaViewController.m in Sources */,
 				04C43AA4183440C1006C643B /* MWNetworkActivityIndicatorManager.m in Sources */,
 				0447863D185145090050563B /* WebViewController.m in Sources */,
+				0487048A19F8262600B7D307 /* PreviewHtmlFetcher.m in Sources */,
 				C9180EC418AED30C006C1DCA /* WikipediaAppUtils.m in Sources */,
 				04CFA126194B94A10088269A /* MenuLabel.m in Sources */,
 				04B0EA4A190B2348007458AF /* PreviewLicenseView.m in Sources */,
+				0487047F19F8262600B7D307 /* AccountCreator.m in Sources */,
+				0487048619F8262600B7D307 /* LanguageLinksFetcher.m in Sources */,
 				0449E63918AAA26A00D51524 /* NSHTTPCookieStorage+CloneCookie.m in Sources */,
 				04C695CE18ED08D900D9F2DA /* UIView+SearchSubviews.m in Sources */,
+				0487048E19F8262600B7D307 /* WikipediaZeroMessageFetcher.m in Sources */,
 				D4F277FB194235A00032BA38 /* ProtectedEditAttemptFunnel.m in Sources */,
+				0487047E19F8262600B7D307 /* AccountCreationTokenFetcher.m in Sources */,
 				049566C218F5F4CB0058EA12 /* ZeroConfigState.m in Sources */,
 				04F27B7518FE0F2E00EDD838 /* PageHistoryResultCell.m in Sources */,
 				D474CC15182AE196002BDE45 /* MWSite.m in Sources */,
@@ -1960,15 +2014,12 @@
 				04530AFB1935C2B500022512 /* EmptySegue.m in Sources */,
 				044BD6B618849AD000FFE4BE /* SectionEditorViewController.m in Sources */,
 				042B3996192EAEEA0066B270 /* ShareMenuSavePageActivity.m in Sources */,
-				04D34DAB1863D2D600610A87 /* TFHpple.m in Sources */,
 				0429301018604898002A13FC /* SavedPagesViewController.m in Sources */,
 				04D149DF18877343006B4104 /* UIViewController+Alert.m in Sources */,
 				04B605101935236C0007185A /* WikiGlyphLabel.m in Sources */,
 				04FD6C7A184EBFCD002CA02F /* ArticleData.xcdatamodeld in Sources */,
 				048A26771906268100395F53 /* PaddedLabel.m in Sources */,
-				C9928B8618AD5C6A00FCCA9A /* DownloadWikipediaZeroMessageOp.m in Sources */,
 				04B91AAB18E3D9E200FFAA1C /* NSString+FormattedAttributedString.m in Sources */,
-				04735E6018A5B42D00C89C30 /* LoginTokenOp.m in Sources */,
 				043F18E518D9691D00D8489A /* UINavigationController+TopActionSheet.m in Sources */,
 				D4EE00B9182443FC0090790F /* MWPageTitle.m in Sources */,
 				04D308281998A8AA0034F106 /* NearbyThumbnailView.m in Sources */,
@@ -1976,7 +2027,9 @@
 				04F0E2EA186EDC1A00468738 /* UIWebView+ElementLocation.m in Sources */,
 				0447866F1852B5010050563B /* SessionSingleton.m in Sources */,
 				D4E8A8A4190835C100DA4765 /* DataMigrator.m in Sources */,
+				0487048519F8262600B7D307 /* EditTokenFetcher.m in Sources */,
 				04CCCFF71935094000E3F60C /* PrimaryMenuTableViewCell.m in Sources */,
+				0487048F19F8262600B7D307 /* WikiTextSectionFetcher.m in Sources */,
 				047528B5191465C400F2CDA8 /* Article.m in Sources */,
 				04CBAC7319A9B786009F3D7E /* NSArray+Predicate.m in Sources */,
 				04CCCFF61935094000E3F60C /* PrimaryMenuViewController.m in Sources */,
@@ -1984,34 +2037,33 @@
 				0447867C1852BBFE0050563B /* NSManagedObjectContext+SimpleFetch.m in Sources */,
 				044BD6A21883302C00FFE4BE /* Image.m in Sources */,
 				04CFA120194900D50088269A /* TopMenuTextFieldContainer.m in Sources */,
-				04293000185FC2C7002A13FC /* QueuesSingleton.m in Sources */,
 				04D34DC91863F6CC00610A87 /* Saved.m in Sources */,
 				04D34DE11868E21F00610A87 /* Article+Convenience.m in Sources */,
 				04D34DB91863F69500610A87 /* DiscoveryContext.m in Sources */,
+				0487048119F8262600B7D307 /* ArticleFetcher.m in Sources */,
 				040892641935ABBD004CF254 /* UIViewController+StatusBarHeight.m in Sources */,
 				04142A8F184F974E006EF779 /* NSDate-Utilities.m in Sources */,
+				0487048C19F8262600B7D307 /* SearchResultFetcher.m in Sources */,
 				04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */,
 				04DD89B118BFE63A00DD5DAD /* PreviewAndSaveViewController.m in Sources */,
 				04C43AC2183442FC006C643B /* NSURLRequest+DictionaryRequest.m in Sources */,
 				040E533C1885FB4E00AFBFE9 /* ImageData.m in Sources */,
-				04DB0BE618BC2E1E00B4BCF3 /* CaptchaResetOp.m in Sources */,
+				0487048819F8262600B7D307 /* NearbyFetcher.m in Sources */,
 				0415581C18ADFA5D00B81A59 /* UIImage+ColorMask.m in Sources */,
-				044213C8191C3C2A006C03BF /* SyncAssetsFileOp.m in Sources */,
 				04A70FD7185BB6C300E24515 /* URLCache.m in Sources */,
-				04992BC018B687AF00A6C22B /* SearchOp.m in Sources */,
 				04C91CEB195517250035ED1B /* OnboardingViewController.m in Sources */,
 				041A3B5E18E11ED90079FF1C /* LanguagesCell.m in Sources */,
-				04C8781018F4A42700FA3B99 /* AccountCreationTokenOp.m in Sources */,
 				043DAC4B1901C3EE001CD17C /* CreditsViewController.m in Sources */,
 				D42E75EB18D11237002EA7E5 /* MWLanguageInfo.m in Sources */,
 				04A81E8618871EB000EEBADB /* Section+ImageRecords.m in Sources */,
+				0487048019F8262600B7D307 /* AccountLogin.m in Sources */,
 				047FF5471889078C009DB293 /* Image+Convenience.m in Sources */,
 				04D149DD18877343006B4104 /* AlertLabel.m in Sources */,
 				0433542618A093C5009305F0 /* UIView+RemoveConstraints.m in Sources */,
 				047801BE18AE987900DBB747 /* UIButton+ColorMask.m in Sources */,
 				0429300A18604898002A13FC /* SavedPagesResultCell.m in Sources */,
+				0487048419F8262600B7D307 /* CaptchaResetter.m in Sources */,
 				04D34DC11863F6B200610A87 /* History.m in Sources */,
-				04D34DAF1863D2D600610A87 /* XPathQuery.m in Sources */,
 				04821CD119895EDC007558F6 /* ReferenceGradientView.m in Sources */,
 				0460F8DC19B0F932001BC59B /* CenteredPathView.m in Sources */,
 				0472BC18193AD88C00C40BDA /* Section+DisplayHtml.m in Sources */,
@@ -2020,16 +2072,15 @@
 				047E95511996DD030046A122 /* NearbyViewController.m in Sources */,
 				04AE520519DB5E0900F89B92 /* NSObject+ConstraintsScale.m in Sources */,
 				04CCCFF01935093A00E3F60C /* SecondaryMenuViewController.m in Sources */,
-				0463639318A5CCEB0049EE4F /* EditTokenOp.m in Sources */,
-				0460990A18899A9800B1F2BC /* DownloadSectionWikiTextOp.m in Sources */,
 				D4B0AE0B19366A2C00F0AC90 /* ReadingActionFunnel.m in Sources */,
 				0452C810195D0F03007925A6 /* UIViewController+ModalPop.m in Sources */,
+				0487049019F8262600B7D307 /* WikiTextSectionUploader.m in Sources */,
 				041C55D21950B27D006CE0EF /* EditSummaryViewController.m in Sources */,
 				04CCA0C01983086D000E982A /* ReferencesVC.m in Sources */,
 				04C43ABE183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m in Sources */,
+				0487048719F8262600B7D307 /* LoginTokenFetcher.m in Sources */,
 				D4B0AE0E19366A5400F0AC90 /* LoginFunnel.m in Sources */,
-				043C668A18BE9A8E00580E9B /* PreviewWikiTextOp.m in Sources */,
-				04C43AA6183440C1006C643B /* MWNetworkOp.m in Sources */,
+				0487048919F8262600B7D307 /* PageHistoryFetcher.m in Sources */,
 				040E5C841846AC13007AFE6F /* ArticleDataContextSingleton.m in Sources */,
 				047528B21913110000F2CDA8 /* Section+LeadSection.m in Sources */,
 				04C43AAE18344131006C643B /* CommunicationBridge.m in Sources */,
@@ -2038,7 +2089,6 @@
 				042A5B2C19253E690095E172 /* BottomMenuViewController.m in Sources */,
 				0433542218A023FE009305F0 /* UIViewController+HideKeyboard.m in Sources */,
 				0484E3DE19D9D19B0085D18D /* UIView+ConstraintsScale.m in Sources */,
-				C958EE3418CE73E600148D13 /* DownloadTitlesForRandomArticlesOp.m in Sources */,
 				0452C803195CB216007925A6 /* UIViewController+ModalsSearch.m in Sources */,
 				04CCA0C319830A44000E982A /* ReferenceVC.m in Sources */,
 				04B91AB718E4D5B200FFAA1C /* TabularScrollView.m in Sources */,
@@ -2047,33 +2097,32 @@
 				04D122321899B8AC006B9A30 /* AlertWebView.m in Sources */,
 				04C0A0781936786000D55325 /* UIViewController+ModalPresent.m in Sources */,
 				D4991449181D51DE00E6073C /* AppDelegate.m in Sources */,
+				04C9509D19EF02980013F3C0 /* EventLogger.m in Sources */,
 				D4E8A8A719084F1300DA4765 /* SQLiteHelper.m in Sources */,
 				04F39590186CF80100B0D6FC /* TOCViewController.m in Sources */,
-				04D75824189248E900CE2040 /* DownloadLangLinksOp.m in Sources */,
-				0485FED21994E22400141361 /* NearbyOp.m in Sources */,
 				04B91AA718E34BBC00FFAA1C /* UIView+TemporaryAnimatedXF.m in Sources */,
 				04224500197F5E09005DD0BF /* AbuseFilterAlert.m in Sources */,
 				D4B0AE0819366A0A00F0AC90 /* CreateAccountFunnel.m in Sources */,
+				0487045519F824D700B7D307 /* QueuesSingleton.m in Sources */,
 				04F27B7818FE0F2E00EDD838 /* PageHistoryViewController.m in Sources */,
 				049B640C18AAF36200D98BD4 /* UIViewController+SearchChildViewControllers.m in Sources */,
 				04A97E8718B81D5D0046B166 /* AccountCreationViewController.m in Sources */,
 				04530AF81935C07500022512 /* ModalContentViewController.m in Sources */,
+				0487048219F8262600B7D307 /* AssetsFileFetcher.m in Sources */,
 				04292FF8185FBB0B002A13FC /* SearchResultsController.m in Sources */,
 				04478633185145090050563B /* HistoryViewController.m in Sources */,
-				0460990E1889A0DD00B1F2BC /* UploadSectionWikiTextOp.m in Sources */,
 				D4B0AE051936604700F0AC90 /* EditFunnel.m in Sources */,
+				0487048319F8262600B7D307 /* FetcherBase.m in Sources */,
 				D4F277FE194235B50032BA38 /* ToCInteractionFunnel.m in Sources */,
 				0400EB0318AAEEC60043ECE2 /* UINavigationController+SearchNavStack.m in Sources */,
-				04B78A5318A580AF0050EBF5 /* LoginOp.m in Sources */,
+				0487048D19F8262600B7D307 /* ThumbnailFetcher.m in Sources */,
 				04530AF51935BF4D00022512 /* ModalMenuAndContentViewController.m in Sources */,
 				041A3B6218E11ED90079FF1C /* LanguagesViewController.m in Sources */,
 				0493C2CC1952373100EBB973 /* CoreDataHousekeeping.m in Sources */,
-				04D34DAD1863D2D600610A87 /* TFHppleElement.m in Sources */,
 				043F18E118D9691D00D8489A /* TopActionSheetLabel.m in Sources */,
 				0412CC621925366C0010E616 /* RootViewController.m in Sources */,
 				04272E7B1940EEBC00CC682F /* AssetsFile.m in Sources */,
 				042A5B2919253E570095E172 /* TopMenuViewController.m in Sources */,
-				04C43A9D183440B0006C643B /* MWCrumbyTest.m in Sources */,
 				D4991445181D51DE00E6073C /* main.m in Sources */,
 				04CFA123194B94980088269A /* MenuButton.m in Sources */,
 				D47BF5D4197870390067C3BC /* SavedPagesFunnel.m in Sources */,
@@ -2085,8 +2134,6 @@
 				04B0EA45190AFDD8007458AF /* ArticleImporter.m in Sources */,
 				042A5B2619253D2A0095E172 /* CenterNavController.m in Sources */,
 				04B162F119284A6F00B1ABC2 /* BottomMenuContainerView.m in Sources */,
-				0406CEF618F8C390007EE43E /* LogEventOp.m in Sources */,
-				0476967C18BBFC9400071963 /* AccountCreationOp.m in Sources */,
 				D4B0AE0219365F7C00F0AC90 /* EventLoggingFunnel.m in Sources */,
 				042A5B2F19257F900095E172 /* TopMenuContainerView.m in Sources */,
 			);
@@ -2094,6 +2141,19 @@
 		};
 /* End PBXSourcesBuildPhase section */
 
+/* Begin PBXTargetDependency section */
+		D4AD974B19F99E4200957451 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = "Pods-AFNetworking";
+			targetProxy = D4AD974A19F99E4200957451 /* PBXContainerItemProxy */;
+		};
+		D4AD974D19F99E4600957451 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = "Pods-hpple";
+			targetProxy = D4AD974C19F99E4600957451 /* PBXContainerItemProxy */;
+		};
+/* End PBXTargetDependency section */
+
 /* Begin PBXVariantGroup section */
 		D46CD8C018A1AC4F0042959E /* InfoPlist.strings */ = {
 			isa = PBXVariantGroup;
@@ -2301,14 +2361,6 @@
 			name = Main_iPhone.storyboard;
 			sourceTree = "<group>";
 		};
-		D4991463181D51DF00E6073C /* InfoPlist.strings */ = {
-			isa = PBXVariantGroup;
-			children = (
-				D4991464181D51DF00E6073C /* en */,
-			);
-			name = InfoPlist.strings;
-			sourceTree = "<group>";
-		};
 /* End PBXVariantGroup section */
 
 /* Begin XCBuildConfiguration section */
@@ -2344,7 +2396,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
 				ONLY_ACTIVE_ARCH = YES;
 				SDKROOT = iphoneos;
 				TARGETED_DEVICE_FAMILY = "1,2";
@@ -2362,11 +2414,13 @@
 				GCC_PREFIX_HEADER = "wikipedia/Wikipedia-Prefix.pch";
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					"/Applications/Xcode51-DP.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include",
 					"$(SDKROOT)/usr/include/libxml2",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/AFNetworking",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/hpple",
 				);
 				INFOPLIST_FILE = "Wikipedia/Wikipedia-Info.plist";
 				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
 				PRODUCT_NAME = Wikipedia;
 				PROVISIONING_PROFILE = "";
 				WRAPPER_EXTENSION = app;
@@ -2405,7 +2459,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
 				ONLY_ACTIVE_ARCH = YES;
 				SDKROOT = iphoneos;
 				TARGETED_DEVICE_FAMILY = "1,2";
@@ -2438,7 +2492,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
 				SDKROOT = iphoneos;
 				TARGETED_DEVICE_FAMILY = "1,2";
 				VALIDATE_PRODUCT = YES;
@@ -2456,11 +2510,13 @@
 				GCC_PREFIX_HEADER = "wikipedia/Wikipedia-Prefix.pch";
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					"/Applications/Xcode51-DP.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include",
 					"$(SDKROOT)/usr/include/libxml2",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/AFNetworking",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/hpple",
 				);
 				INFOPLIST_FILE = "Wikipedia/Wikipedia-Info.plist";
 				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
 				PRODUCT_NAME = Wikipedia;
 				PROVISIONING_PROFILE = "";
 				WRAPPER_EXTENSION = app;
@@ -2478,11 +2534,13 @@
 				GCC_PREFIX_HEADER = "wikipedia/Wikipedia-Prefix.pch";
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					"/Applications/Xcode51-DP.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include",
 					"$(SDKROOT)/usr/include/libxml2",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/AFNetworking",
+					"$(PROJECT_DIR)/cocoapods/Pods/Headers/Public/hpple",
 				);
 				INFOPLIST_FILE = "Wikipedia/Wikipedia-Info.plist";
 				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
 				PRODUCT_NAME = Wikipedia;
 				PROVISIONING_PROFILE = "";
 				WRAPPER_EXTENSION = app;
diff --git a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Debug Wikipedia-iOS.xcscheme b/Wikipedia.xcodeproj/xcshareddata/xcschemes/Debug Wikipedia-iOS.xcscheme
deleted file mode 100644
index b7a6312e42b..00000000000
--- a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Debug Wikipedia-iOS.xcscheme	
+++ /dev/null
@@ -1,117 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<Scheme
-   LastUpgradeVersion = "0600"
-   version = "1.3">
-   <BuildAction
-      parallelizeBuildables = "YES"
-      buildImplicitDependencies = "YES">
-      <BuildActionEntries>
-         <BuildActionEntry
-            buildForTesting = "YES"
-            buildForRunning = "YES"
-            buildForProfiling = "YES"
-            buildForArchiving = "YES"
-            buildForAnalyzing = "YES">
-            <BuildableReference
-               BuildableIdentifier = "primary"
-               BlueprintIdentifier = "D4991434181D51DE00E6073C"
-               BuildableName = "Wikipedia.app"
-               BlueprintName = "Wikipedia"
-               ReferencedContainer = "container:Wikipedia.xcodeproj">
-            </BuildableReference>
-         </BuildActionEntry>
-      </BuildActionEntries>
-   </BuildAction>
-   <TestAction
-      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
-      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
-      shouldUseLaunchSchemeArgsEnv = "YES"
-      buildConfiguration = "Test">
-      <Testables>
-         <TestableReference
-            skipped = "NO">
-            <BuildableReference
-               BuildableIdentifier = "primary"
-               BlueprintIdentifier = "D4991458181D51DF00E6073C"
-               BuildableName = "Wikipedia-iOSTests.xctest"
-               BlueprintName = "Wikipedia-iOSTests"
-               ReferencedContainer = "container:Wikipedia.xcodeproj">
-            </BuildableReference>
-         </TestableReference>
-      </Testables>
-      <MacroExpansion>
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "D4991434181D51DE00E6073C"
-            BuildableName = "Wikipedia.app"
-            BlueprintName = "Wikipedia"
-            ReferencedContainer = "container:Wikipedia.xcodeproj">
-         </BuildableReference>
-      </MacroExpansion>
-   </TestAction>
-   <LaunchAction
-      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
-      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
-      launchStyle = "0"
-      useCustomWorkingDirectory = "NO"
-      buildConfiguration = "Debug"
-      ignoresPersistentStateOnLaunch = "NO"
-      debugDocumentVersioning = "YES"
-      allowLocationSimulation = "YES">
-      <BuildableProductRunnable>
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "D4991434181D51DE00E6073C"
-            BuildableName = "Wikipedia.app"
-            BlueprintName = "Wikipedia"
-            ReferencedContainer = "container:Wikipedia.xcodeproj">
-         </BuildableReference>
-      </BuildableProductRunnable>
-      <CommandLineArguments>
-         <CommandLineArgument
-            argument = "-com.apple.CoreData.SQLDebug 0"
-            isEnabled = "YES">
-         </CommandLineArgument>
-      </CommandLineArguments>
-      <AdditionalOptions>
-         <AdditionalOption
-            key = "MallocStackLogging"
-            value = ""
-            isEnabled = "YES">
-         </AdditionalOption>
-         <AdditionalOption
-            key = "DYLD_INSERT_LIBRARIES"
-            value = "/usr/lib/libgmalloc.dylib"
-            isEnabled = "YES">
-         </AdditionalOption>
-         <AdditionalOption
-            key = "NSZombieEnabled"
-            value = "YES"
-            isEnabled = "YES">
-         </AdditionalOption>
-      </AdditionalOptions>
-   </LaunchAction>
-   <ProfileAction
-      shouldUseLaunchSchemeArgsEnv = "YES"
-      savedToolIdentifier = ""
-      useCustomWorkingDirectory = "NO"
-      buildConfiguration = "Release"
-      debugDocumentVersioning = "YES">
-      <BuildableProductRunnable>
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "D4991434181D51DE00E6073C"
-            BuildableName = "Wikipedia.app"
-            BlueprintName = "Wikipedia"
-            ReferencedContainer = "container:Wikipedia.xcodeproj">
-         </BuildableReference>
-      </BuildableProductRunnable>
-   </ProfileAction>
-   <AnalyzeAction
-      buildConfiguration = "Debug">
-   </AnalyzeAction>
-   <ArchiveAction
-      buildConfiguration = "Release"
-      revealArchiveInOrganizer = "YES">
-   </ArchiveAction>
-</Scheme>
diff --git a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia-iOS.xcscheme b/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia-iOS.xcscheme
index 68b78d9d365..2ddce9c6725 100644
--- a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia-iOS.xcscheme
+++ b/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia-iOS.xcscheme
@@ -6,6 +6,20 @@
       parallelizeBuildables = "YES"
       buildImplicitDependencies = "YES">
       <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "A0E9D3B0EB568914B646A37B"
+               BuildableName = "libPods.a"
+               BlueprintName = "Pods"
+               ReferencedContainer = "container:Pods/Pods.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
          <BuildActionEntry
             buildForTesting = "YES"
             buildForRunning = "YES"
diff --git a/cocoapods notes.txt b/cocoapods notes.txt
new file mode 100644
index 00000000000..889e89834e0
--- /dev/null
+++ b/cocoapods notes.txt	
@@ -0,0 +1,37 @@
+
+Presently, the script "run-cocoapods.sh" calls "pod install --no-integrate"
+which causes the projects in "Podfile" to be downloaded and placed in the
+"Cocoapods/Pods/" directory. The needed source files were then dragged into
+the project manually.
+
+This is less than perfect, but the workspace file and other project 
+integration which happens without the "--no-integrate" flag is still too
+messy. As Cocoapods approaches version 1.0 we can re-assess.
+
+Note: the "Cocoapods/Pods/" directory is wiped every time "run-cocoapods.sh"
+runs. So don't manually place any files in this directory.
+
+The "Podfile" may still be edited to include new Cocoapod dependencies,
+and they will be automatically downloaded on each time "run-cocoapods.sh"
+runs.
+
+When adding new library pods, they will appear automatically in the updated
+Pods.xcodeproj. But to make sure they are available to use in the main project:
+
+1) Go to the main target, 'Build Phases', and the relevant subprojects as
+   a 'target dependency'
+2) Add the subproject's .a output file to the linked libraries list
+3) Go back to 'Build Settings' and if necessary add a subdirectory to
+   the Headers path.
+
+Also note: the "run-cocoapods.sh" script only runs during a build if it
+is un-commented out: "Targets > Wikipedia > Build Phases" then expand the 
+first "Run Script" entry and change "#scripts/run-cocoapods.sh" to
+"scripts/run-cocoapods.sh".
+
+To see if "run-cocoapods.sh" needs to be run, look at the versions specified
+in "Podfile" and compare these with the versions of each library available
+on http://cocoapods.org. If a newer version is available, update the
+"Podfile" version, then uncomment "run-cocoapods.sh" (as outlined above)
+and do a build so the build script runs. After running the build, re-comment
+"run-cocoapods.sh" (as outlined above).
diff --git a/cocoapods/Podfile b/cocoapods/Podfile
new file mode 100644
index 00000000000..482ee3423a1
--- /dev/null
+++ b/cocoapods/Podfile
@@ -0,0 +1,4 @@
+source 'https://github.com/CocoaPods/Specs.git'
+platform :ios, :deployment_target => '6.0'
+pod 'AFNetworking', '~> 2.4'
+pod 'hpple', '~> 0.2'
\ No newline at end of file
diff --git a/cocoapods/Podfile.lock b/cocoapods/Podfile.lock
new file mode 100644
index 00000000000..7085dcd0544
--- /dev/null
+++ b/cocoapods/Podfile.lock
@@ -0,0 +1,33 @@
+PODS:
+  - AFNetworking (2.4.1):
+    - AFNetworking/NSURLConnection
+    - AFNetworking/NSURLSession
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+    - AFNetworking/UIKit
+  - AFNetworking/NSURLConnection (2.4.1):
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+  - AFNetworking/NSURLSession (2.4.1):
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+  - AFNetworking/Reachability (2.4.1)
+  - AFNetworking/Security (2.4.1)
+  - AFNetworking/Serialization (2.4.1)
+  - AFNetworking/UIKit (2.4.1):
+    - AFNetworking/NSURLConnection
+    - AFNetworking/NSURLSession
+  - hpple (0.2.0)
+
+DEPENDENCIES:
+  - AFNetworking (~> 2.4)
+  - hpple (~> 0.2)
+
+SPEC CHECKSUMS:
+  AFNetworking: 0aabc6fae66d6e5d039eeb21c315843c7aae51ab
+  hpple: f4eb7c21a8db83ec264e5d614ec7509e10e5adec
+
+COCOAPODS: 0.34.4
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.h
new file mode 100644
index 00000000000..dfa82f66916
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.h
@@ -0,0 +1,67 @@
+// AFHTTPRequestOperation.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import "AFURLConnectionOperation.h"
+
+/**
+ `AFHTTPRequestOperation` is a subclass of `AFURLConnectionOperation` for requests using the HTTP or HTTPS protocols. It encapsulates the concept of acceptable status codes and content types, which determine the success or failure of a request.
+ */
+@interface AFHTTPRequestOperation : AFURLConnectionOperation
+
+///------------------------------------------------
+/// @name Getting HTTP URL Connection Information
+///------------------------------------------------
+
+/**
+ The last HTTP response received by the operation's connection.
+ */
+@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;
+
+/**
+ Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to an AFHTTPResponse serializer, which uses the raw data as its response object. The serializer validates the status code to be in the `2XX` range, denoting success. If the response serializer generates an error in `-responseObjectForResponse:data:error:`, the `failure` callback of the session task or request operation will be executed; otherwise, the `success` callback will be executed.
+
+ @warning `responseSerializer` must not be `nil`. Setting a response serializer will clear out any cached value 
+ */
+@property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;
+
+/**
+ An object constructed by the `responseSerializer` from the response and response data. Returns `nil` unless the operation `isFinished`, has a `response`, and has `responseData` with non-zero content length. If an error occurs during serialization, `nil` will be returned, and the `error` property will be populated with the serialization error.
+ */
+@property (readonly, nonatomic, strong) id responseObject;
+
+///-----------------------------------------------------------
+/// @name Setting Completion Block Success / Failure Callbacks
+///-----------------------------------------------------------
+
+/**
+ Sets the `completionBlock` property with a block that executes either the specified success or failure block, depending on the state of the request on completion. If `error` returns a value, which can be caused by an unacceptable status code or content type, then `failure` is executed. Otherwise, `success` is executed.
+
+ This method should be overridden in subclasses in order to specify the response object passed into the success block.
+ 
+ @param success The block to be executed on the completion of a successful request. This block has no return value and takes two arguments: the receiver operation and the object constructed from the response data of the request.
+ @param failure The block to be executed on the completion of an unsuccessful request. This block has no return value and takes two arguments: the receiver operation and the error that occurred during the request.
+ */
+- (void)setCompletionBlockWithSuccess:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                              failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.m
new file mode 100644
index 00000000000..1de5812ca14
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation.m
@@ -0,0 +1,206 @@
+// AFHTTPRequestOperation.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFHTTPRequestOperation.h"
+
+static dispatch_queue_t http_request_operation_processing_queue() {
+    static dispatch_queue_t af_http_request_operation_processing_queue;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_http_request_operation_processing_queue = dispatch_queue_create("com.alamofire.networking.http-request.processing", DISPATCH_QUEUE_CONCURRENT);
+    });
+
+    return af_http_request_operation_processing_queue;
+}
+
+static dispatch_group_t http_request_operation_completion_group() {
+    static dispatch_group_t af_http_request_operation_completion_group;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_http_request_operation_completion_group = dispatch_group_create();
+    });
+
+    return af_http_request_operation_completion_group;
+}
+
+#pragma mark -
+
+@interface AFURLConnectionOperation ()
+@property (readwrite, nonatomic, strong) NSURLRequest *request;
+@property (readwrite, nonatomic, strong) NSURLResponse *response;
+@end
+
+@interface AFHTTPRequestOperation ()
+@property (readwrite, nonatomic, strong) NSHTTPURLResponse *response;
+@property (readwrite, nonatomic, strong) id responseObject;
+@property (readwrite, nonatomic, strong) NSError *responseSerializationError;
+@property (readwrite, nonatomic, strong) NSRecursiveLock *lock;
+@end
+
+@implementation AFHTTPRequestOperation
+@dynamic lock;
+
+- (instancetype)initWithRequest:(NSURLRequest *)urlRequest {
+    self = [super initWithRequest:urlRequest];
+    if (!self) {
+        return nil;
+    }
+
+    self.responseSerializer = [AFHTTPResponseSerializer serializer];
+
+    return self;
+}
+
+- (void)setResponseSerializer:(AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
+    NSParameterAssert(responseSerializer);
+
+    [self.lock lock];
+    _responseSerializer = responseSerializer;
+    self.responseObject = nil;
+    self.responseSerializationError = nil;
+    [self.lock unlock];
+}
+
+- (id)responseObject {
+    [self.lock lock];
+    if (!_responseObject && [self isFinished] && !self.error) {
+        NSError *error = nil;
+        self.responseObject = [self.responseSerializer responseObjectForResponse:self.response data:self.responseData error:&error];
+        if (error) {
+            self.responseSerializationError = error;
+        }
+    }
+    [self.lock unlock];
+
+    return _responseObject;
+}
+
+- (NSError *)error {
+    if (_responseSerializationError) {
+        return _responseSerializationError;
+    } else {
+        return [super error];
+    }
+}
+
+#pragma mark - AFHTTPRequestOperation
+
+- (void)setCompletionBlockWithSuccess:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                              failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    // completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warc-retain-cycles"
+#pragma clang diagnostic ignored "-Wgnu"
+    self.completionBlock = ^{
+        if (self.completionGroup) {
+            dispatch_group_enter(self.completionGroup);
+        }
+
+        dispatch_async(http_request_operation_processing_queue(), ^{
+            if (self.error) {
+                if (failure) {
+                    dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^{
+                        failure(self, self.error);
+                    });
+                }
+            } else {
+                id responseObject = self.responseObject;
+                if (self.error) {
+                    if (failure) {
+                        dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^{
+                            failure(self, self.error);
+                        });
+                    }
+                } else {
+                    if (success) {
+                        dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^{
+                            success(self, responseObject);
+                        });
+                    }
+                }
+            }
+
+            if (self.completionGroup) {
+                dispatch_group_leave(self.completionGroup);
+            }
+        });
+    };
+#pragma clang diagnostic pop
+}
+
+#pragma mark - AFURLRequestOperation
+
+- (void)pause {
+    [super pause];
+
+    u_int64_t offset = 0;
+    if ([self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey]) {
+        offset = [(NSNumber *)[self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey] unsignedLongLongValue];
+    } else {
+        offset = [(NSData *)[self.outputStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey] length];
+    }
+
+    NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
+    if ([self.response respondsToSelector:@selector(allHeaderFields)] && [[self.response allHeaderFields] valueForKey:@"ETag"]) {
+        [mutableURLRequest setValue:[[self.response allHeaderFields] valueForKey:@"ETag"] forHTTPHeaderField:@"If-Range"];
+    }
+    [mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];
+    self.request = mutableURLRequest;
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.responseSerializer = [decoder decodeObjectOfClass:[AFHTTPResponseSerializer class] forKey:NSStringFromSelector(@selector(responseSerializer))];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:self.responseSerializer forKey:NSStringFromSelector(@selector(responseSerializer))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPRequestOperation *operation = [super copyWithZone:zone];
+
+    operation.responseSerializer = [self.responseSerializer copyWithZone:zone];
+    operation.completionQueue = self.completionQueue;
+    operation.completionGroup = self.completionGroup;
+
+    return operation;
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.h
new file mode 100644
index 00000000000..9f390294e22
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.h
@@ -0,0 +1,308 @@
+// AFHTTPRequestOperationManager.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <SystemConfiguration/SystemConfiguration.h>
+#import <Availability.h>
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED
+#import <MobileCoreServices/MobileCoreServices.h>
+#else
+#import <CoreServices/CoreServices.h>
+#endif
+
+#import "AFHTTPRequestOperation.h"
+#import "AFURLResponseSerialization.h"
+#import "AFURLRequestSerialization.h"
+#import "AFSecurityPolicy.h"
+#import "AFNetworkReachabilityManager.h"
+
+/**
+ `AFHTTPRequestOperationManager` encapsulates the common patterns of communicating with a web application over HTTP, including request creation, response serialization, network reachability monitoring, and security, as well as request operation management.
+
+ ## Subclassing Notes
+ 
+ Developers targeting iOS 7 or Mac OS X 10.9 or later that deal extensively with a web service are encouraged to subclass `AFHTTPSessionManager`, providing a class method that returns a shared singleton object on which authentication and other configuration can be shared across the application.
+ 
+ For developers targeting iOS 6 or Mac OS X 10.8 or earlier, `AFHTTPRequestOperationManager` may be used to similar effect.
+ 
+ ## Methods to Override
+
+ To change the behavior of all request operation construction for an `AFHTTPRequestOperationManager` subclass, override `HTTPRequestOperationWithRequest:success:failure`.
+
+ ## Serialization
+ 
+ Requests created by an HTTP client will contain default headers and encode parameters according to the `requestSerializer` property, which is an object conforming to `<AFURLRequestSerialization>`. 
+ 
+ Responses received from the server are automatically validated and serialized by the `responseSerializers` property, which is an object conforming to `<AFURLResponseSerialization>`
+
+ ## URL Construction Using Relative Paths
+
+ For HTTP convenience methods, the request serializer constructs URLs from the path relative to the `-baseURL`, using `NSURL +URLWithString:relativeToURL:`, when provided. If `baseURL` is `nil`, `path` needs to resolve to a valid `NSURL` object using `NSURL +URLWithString:`.
+
+ Below are a few examples of how `baseURL` and relative paths interact:
+
+    NSURL *baseURL = [NSURL URLWithString:@"http://example.com/v1/"];
+    [NSURL URLWithString:@"foo" relativeToURL:baseURL];                  // http://example.com/v1/foo
+    [NSURL URLWithString:@"foo?bar=baz" relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz
+    [NSURL URLWithString:@"/foo" relativeToURL:baseURL];                 // http://example.com/foo
+    [NSURL URLWithString:@"foo/" relativeToURL:baseURL];                 // http://example.com/v1/foo
+    [NSURL URLWithString:@"/foo/" relativeToURL:baseURL];                // http://example.com/foo/
+    [NSURL URLWithString:@"http://example2.com/" relativeToURL:baseURL]; // http://example2.com/
+
+ Also important to note is that a trailing slash will be added to any `baseURL` without one. This would otherwise cause unexpected behavior when constructing URLs using paths without a leading slash.
+
+ ## Network Reachability Monitoring
+
+ Network reachability status and change monitoring is available through the `reachabilityManager` property. Applications may choose to monitor network reachability conditions in order to prevent or suspend any outbound requests. See `AFNetworkReachabilityManager` for more details.
+
+ ## NSSecureCoding & NSCopying Caveats
+
+ `AFHTTPRequestOperationManager` conforms to the `NSSecureCoding` and `NSCopying` protocols, allowing operations to be archived to disk, and copied in memory, respectively. There are a few minor caveats to keep in mind, however:
+
+ - Archives and copies of HTTP clients will be initialized with an empty operation queue.
+ - NSSecureCoding cannot serialize / deserialize block properties, so an archive of an HTTP client will not include any reachability callback block that may be set.
+ */
+@interface AFHTTPRequestOperationManager : NSObject <NSSecureCoding, NSCopying>
+
+/**
+ The URL used to monitor reachability, and construct requests from relative paths in methods like `requestWithMethod:URLString:parameters:`, and the `GET` / `POST` / et al. convenience methods.
+ */
+@property (readonly, nonatomic, strong) NSURL *baseURL;
+
+/**
+ Requests created with `requestWithMethod:URLString:parameters:` & `multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:` are constructed with a set of default headers using a parameter serialization specified by this property. By default, this is set to an instance of `AFHTTPRequestSerializer`, which serializes query string parameters for `GET`, `HEAD`, and `DELETE` requests, or otherwise URL-form-encodes HTTP message bodies.
+ 
+ @warning `requestSerializer` must not be `nil`.
+ */
+@property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;
+
+/**
+ Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to a JSON serializer, which serializes data from responses with a `application/json` MIME type, and falls back to the raw data object. The serializer validates the status code to be in the `2XX` range, denoting success. If the response serializer generates an error in `-responseObjectForResponse:data:error:`, the `failure` callback of the session task or request operation will be executed; otherwise, the `success` callback will be executed.
+
+ @warning `responseSerializer` must not be `nil`.
+ */
+@property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;
+
+/**
+ The operation queue on which request operations are scheduled and run.
+ */
+@property (nonatomic, strong) NSOperationQueue *operationQueue;
+
+///-------------------------------
+/// @name Managing URL Credentials
+///-------------------------------
+
+/**
+ Whether request operations should consult the credential storage for authenticating the connection. `YES` by default.
+
+ @see AFURLConnectionOperation -shouldUseCredentialStorage
+ */
+@property (nonatomic, assign) BOOL shouldUseCredentialStorage;
+
+/**
+ The credential used by request operations for authentication challenges.
+
+ @see AFURLConnectionOperation -credential
+ */
+@property (nonatomic, strong) NSURLCredential *credential;
+
+///-------------------------------
+/// @name Managing Security Policy
+///-------------------------------
+
+/**
+ The security policy used by created request operations to evaluate server trust for secure connections. `AFHTTPRequestOperationManager` uses the `defaultPolicy` unless otherwise specified.
+ */
+@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;
+
+///------------------------------------
+/// @name Managing Network Reachability
+///------------------------------------
+
+/**
+ The network reachability manager. `AFHTTPRequestOperationManager` uses the `sharedManager` by default.
+ */
+@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;
+
+///-------------------------------
+/// @name Managing Callback Queues
+///-------------------------------
+
+/**
+ The dispatch queue for the `completionBlock` of request operations. If `NULL` (default), the main queue is used.
+ */
+@property (nonatomic, strong) dispatch_queue_t completionQueue;
+
+/**
+ The dispatch group for the `completionBlock` of request operations. If `NULL` (default), a private dispatch group is used.
+ */
+@property (nonatomic, strong) dispatch_group_t completionGroup;
+
+///---------------------------------------------
+/// @name Creating and Initializing HTTP Clients
+///---------------------------------------------
+
+/**
+ Creates and returns an `AFHTTPRequestOperationManager` object.
+ */
++ (instancetype)manager;
+
+/**
+ Initializes an `AFHTTPRequestOperationManager` object with the specified base URL.
+ 
+ This is the designated initializer.
+ 
+ @param url The base URL for the HTTP client.
+
+ @return The newly-initialized HTTP client
+ */
+- (instancetype)initWithBaseURL:(NSURL *)url;
+
+///---------------------------------------
+/// @name Managing HTTP Request Operations
+///---------------------------------------
+
+/**
+ Creates an `AFHTTPRequestOperation`, and sets the response serializers to that of the HTTP client.
+
+ @param request The request object to be loaded asynchronously during execution of the operation.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the created request operation and the object created from the response data of request.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes two arguments:, the created request operation and the `NSError` object describing the network or parsing error that occurred.
+ */
+- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(NSURLRequest *)request
+                                                    success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                                                    failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+///---------------------------
+/// @name Making HTTP Requests
+///---------------------------
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `GET` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)GET:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `HEAD` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes a single arguments: the request operation.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)HEAD:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(AFHTTPRequestOperation *operation))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `POST` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)POST:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a multipart `POST` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param block A block that takes a single argument and appends data to the HTTP body. The block argument is an object adopting the `AFMultipartFormData` protocol.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)POST:(NSString *)URLString
+                      parameters:(id)parameters
+       constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `PUT` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)PUT:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `PATCH` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)PATCH:(NSString *)URLString
+                       parameters:(id)parameters
+                          success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                          failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+/**
+ Creates and runs an `AFHTTPRequestOperation` with a `DELETE` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the request operation finishes successfully. This block has no return value and takes two arguments: the request operation, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the request operation and the error describing the network or parsing error that occurred.
+
+ @see -HTTPRequestOperationWithRequest:success:failure:
+ */
+- (AFHTTPRequestOperation *)DELETE:(NSString *)URLString
+                        parameters:(id)parameters
+                           success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                           failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure;
+
+@end
+
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.m
new file mode 100644
index 00000000000..4ae72754804
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager.m
@@ -0,0 +1,253 @@
+// AFHTTPRequestOperationManager.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import "AFHTTPRequestOperationManager.h"
+#import "AFHTTPRequestOperation.h"
+
+#import <Availability.h>
+#import <Security/Security.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <UIKit/UIKit.h>
+#endif
+
+@interface AFHTTPRequestOperationManager ()
+@property (readwrite, nonatomic, strong) NSURL *baseURL;
+@end
+
+@implementation AFHTTPRequestOperationManager
+
++ (instancetype)manager {
+    return [[self alloc] initWithBaseURL:nil];
+}
+
+- (instancetype)init {
+    return [self initWithBaseURL:nil];    
+}
+
+- (instancetype)initWithBaseURL:(NSURL *)url {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected
+    if ([[url path] length] > 0 && ![[url absoluteString] hasSuffix:@"/"]) {
+        url = [url URLByAppendingPathComponent:@""];
+    }
+
+    self.baseURL = url;
+
+    self.requestSerializer = [AFHTTPRequestSerializer serializer];
+    self.responseSerializer = [AFJSONResponseSerializer serializer];
+
+    self.securityPolicy = [AFSecurityPolicy defaultPolicy];
+
+    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
+
+    self.operationQueue = [[NSOperationQueue alloc] init];
+
+    self.shouldUseCredentialStorage = YES;
+
+    return self;
+}
+
+#pragma mark -
+
+#ifdef _SYSTEMCONFIGURATION_H
+#endif
+
+- (void)setRequestSerializer:(AFHTTPRequestSerializer <AFURLRequestSerialization> *)requestSerializer {
+    NSParameterAssert(requestSerializer);
+
+    _requestSerializer = requestSerializer;
+}
+
+- (void)setResponseSerializer:(AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
+    NSParameterAssert(responseSerializer);
+
+    _responseSerializer = responseSerializer;
+}
+
+#pragma mark -
+
+- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(NSURLRequest *)request
+                                                    success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                                                    failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
+    operation.responseSerializer = self.responseSerializer;
+    operation.shouldUseCredentialStorage = self.shouldUseCredentialStorage;
+    operation.credential = self.credential;
+    operation.securityPolicy = self.securityPolicy;
+
+    [operation setCompletionBlockWithSuccess:success failure:failure];
+    operation.completionQueue = self.completionQueue;
+    operation.completionGroup = self.completionGroup;
+
+    return operation;
+}
+
+#pragma mark -
+
+- (AFHTTPRequestOperation *)GET:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"GET" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)HEAD:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(AFHTTPRequestOperation *operation))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"HEAD" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:^(AFHTTPRequestOperation *requestOperation, __unused id responseObject) {
+        if (success) {
+            success(requestOperation);
+        }
+    } failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)POST:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)POST:(NSString *)URLString
+                      parameters:(id)parameters
+       constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)PUT:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"PUT" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)PATCH:(NSString *)URLString
+                       parameters:(id)parameters
+                          success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                          failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"PATCH" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+- (AFHTTPRequestOperation *)DELETE:(NSString *)URLString
+                        parameters:(id)parameters
+                           success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
+                           failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
+{
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"DELETE" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
+    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];
+
+    [self.operationQueue addOperation:operation];
+
+    return operation;
+}
+
+#pragma mark - NSObject
+
+- (NSString *)description {
+    return [NSString stringWithFormat:@"<%@: %p, baseURL: %@, operationQueue: %@>", NSStringFromClass([self class]), self, [self.baseURL absoluteString], self.operationQueue];
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    NSURL *baseURL = [decoder decodeObjectForKey:NSStringFromSelector(@selector(baseURL))];
+
+    self = [self initWithBaseURL:baseURL];
+    if (!self) {
+        return nil;
+    }
+
+    self.requestSerializer = [decoder decodeObjectOfClass:[AFHTTPRequestSerializer class] forKey:NSStringFromSelector(@selector(requestSerializer))];
+    self.responseSerializer = [decoder decodeObjectOfClass:[AFHTTPResponseSerializer class] forKey:NSStringFromSelector(@selector(responseSerializer))];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [coder encodeObject:self.baseURL forKey:NSStringFromSelector(@selector(baseURL))];
+    [coder encodeObject:self.requestSerializer forKey:NSStringFromSelector(@selector(requestSerializer))];
+    [coder encodeObject:self.responseSerializer forKey:NSStringFromSelector(@selector(responseSerializer))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPRequestOperationManager *HTTPClient = [[[self class] allocWithZone:zone] initWithBaseURL:self.baseURL];
+
+    HTTPClient.requestSerializer = [self.requestSerializer copyWithZone:zone];
+    HTTPClient.responseSerializer = [self.responseSerializer copyWithZone:zone];
+    
+    return HTTPClient;
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.h
new file mode 100644
index 00000000000..a84fcc554d6
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.h
@@ -0,0 +1,238 @@
+// AFHTTPSessionManager.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <SystemConfiguration/SystemConfiguration.h>
+#import <Availability.h>
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED
+#import <MobileCoreServices/MobileCoreServices.h>
+#else
+#import <CoreServices/CoreServices.h>
+#endif
+
+#import "AFURLSessionManager.h"
+
+/**
+ `AFHTTPSessionManager` is a subclass of `AFURLSessionManager` with convenience methods for making HTTP requests. When a `baseURL` is provided, requests made with the `GET` / `POST` / et al. convenience methods can be made with relative paths.
+ 
+ ## Subclassing Notes
+ 
+ Developers targeting iOS 7 or Mac OS X 10.9 or later that deal extensively with a web service are encouraged to subclass `AFHTTPSessionManager`, providing a class method that returns a shared singleton object on which authentication and other configuration can be shared across the application.
+ 
+ For developers targeting iOS 6 or Mac OS X 10.8 or earlier, `AFHTTPRequestOperationManager` may be used to similar effect.
+
+ ## Methods to Override
+
+ To change the behavior of all data task operation construction, which is also used in the `GET` / `POST` / et al. convenience methods, override `dataTaskWithRequest:completionHandler:`.
+ 
+ ## Serialization
+ 
+ Requests created by an HTTP client will contain default headers and encode parameters according to the `requestSerializer` property, which is an object conforming to `<AFURLRequestSerialization>`.
+ 
+ Responses received from the server are automatically validated and serialized by the `responseSerializers` property, which is an object conforming to `<AFURLResponseSerialization>`
+
+ ## URL Construction Using Relative Paths
+
+ For HTTP convenience methods, the request serializer constructs URLs from the path relative to the `-baseURL`, using `NSURL +URLWithString:relativeToURL:`, when provided. If `baseURL` is `nil`, `path` needs to resolve to a valid `NSURL` object using `NSURL +URLWithString:`.
+ 
+ Below are a few examples of how `baseURL` and relative paths interact:
+
+    NSURL *baseURL = [NSURL URLWithString:@"http://example.com/v1/"];
+    [NSURL URLWithString:@"foo" relativeToURL:baseURL];                  // http://example.com/v1/foo
+    [NSURL URLWithString:@"foo?bar=baz" relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz
+    [NSURL URLWithString:@"/foo" relativeToURL:baseURL];                 // http://example.com/foo
+    [NSURL URLWithString:@"foo/" relativeToURL:baseURL];                 // http://example.com/v1/foo
+    [NSURL URLWithString:@"/foo/" relativeToURL:baseURL];                // http://example.com/foo/
+    [NSURL URLWithString:@"http://example2.com/" relativeToURL:baseURL]; // http://example2.com/
+
+ Also important to note is that a trailing slash will be added to any `baseURL` without one. This would otherwise cause unexpected behavior when constructing URLs using paths without a leading slash.
+ */
+
+#if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000) || (defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090)
+
+@interface AFHTTPSessionManager : AFURLSessionManager <NSSecureCoding, NSCopying>
+
+/**
+ The URL used to monitor reachability, and construct requests from relative paths in methods like `requestWithMethod:URLString:parameters:`, and the `GET` / `POST` / et al. convenience methods.
+ */
+@property (readonly, nonatomic, strong) NSURL *baseURL;
+
+/**
+ Requests created with `requestWithMethod:URLString:parameters:` & `multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:` are constructed with a set of default headers using a parameter serialization specified by this property. By default, this is set to an instance of `AFHTTPRequestSerializer`, which serializes query string parameters for `GET`, `HEAD`, and `DELETE` requests, or otherwise URL-form-encodes HTTP message bodies.
+ 
+ @warning `requestSerializer` must not be `nil`.
+ */
+@property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;
+
+/**
+ Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to an instance of `AFJSONResponseSerializer`.
+
+ @warning `responseSerializer` must not be `nil`.
+ */
+@property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;
+
+///---------------------
+/// @name Initialization
+///---------------------
+
+/**
+ Creates and returns an `AFHTTPSessionManager` object.
+ */
++ (instancetype)manager;
+
+/**
+ Initializes an `AFHTTPSessionManager` object with the specified base URL.
+ 
+ @param url The base URL for the HTTP client.
+
+ @return The newly-initialized HTTP client
+ */
+- (instancetype)initWithBaseURL:(NSURL *)url;
+
+/**
+ Initializes an `AFHTTPSessionManager` object with the specified base URL.
+
+ This is the designated initializer.
+
+ @param url The base URL for the HTTP client.
+ @param configuration The configuration used to create the managed session.
+
+ @return The newly-initialized HTTP client
+ */
+- (instancetype)initWithBaseURL:(NSURL *)url
+           sessionConfiguration:(NSURLSessionConfiguration *)configuration;
+
+///---------------------------
+/// @name Making HTTP Requests
+///---------------------------
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `GET` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)GET:(NSString *)URLString
+                   parameters:(id)parameters
+                      success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                      failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `HEAD` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes a single arguments: the data task.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)HEAD:(NSString *)URLString
+                    parameters:(id)parameters
+                       success:(void (^)(NSURLSessionDataTask *task))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `POST` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)POST:(NSString *)URLString
+                    parameters:(id)parameters
+                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a multipart `POST` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param block A block that takes a single argument and appends data to the HTTP body. The block argument is an object adopting the `AFMultipartFormData` protocol.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)POST:(NSString *)URLString
+                    parameters:(id)parameters
+     constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `PUT` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)PUT:(NSString *)URLString
+                   parameters:(id)parameters
+                      success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                      failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `PATCH` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)PATCH:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                        failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+/**
+ Creates and runs an `NSURLSessionDataTask` with a `DELETE` request.
+
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded according to the client request serializer.
+ @param success A block object to be executed when the task finishes successfully. This block has no return value and takes two arguments: the data task, and the response object created by the client response serializer.
+ @param failure A block object to be executed when the task finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a two arguments: the data task and the error describing the network or parsing error that occurred.
+
+ @see -dataTaskWithRequest:completionHandler:
+ */
+- (NSURLSessionDataTask *)DELETE:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                         failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m
new file mode 100644
index 00000000000..6413297d720
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m
@@ -0,0 +1,321 @@
+// AFHTTPSessionManager.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFHTTPSessionManager.h"
+
+#if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000) || (defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090)
+
+#import "AFURLRequestSerialization.h"
+#import "AFURLResponseSerialization.h"
+
+#import <Availability.h>
+#import <Security/Security.h>
+
+#ifdef _SYSTEMCONFIGURATION_H
+#import <netinet/in.h>
+#import <netinet6/in6.h>
+#import <arpa/inet.h>
+#import <ifaddrs.h>
+#import <netdb.h>
+#endif
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <UIKit/UIKit.h>
+#endif
+
+@interface AFHTTPSessionManager ()
+@property (readwrite, nonatomic, strong) NSURL *baseURL;
+@end
+
+@implementation AFHTTPSessionManager
+
++ (instancetype)manager {
+    return [[[self class] alloc] initWithBaseURL:nil];
+}
+
+- (instancetype)init {
+    return [self initWithBaseURL:nil];
+}
+
+- (instancetype)initWithBaseURL:(NSURL *)url {
+    return [self initWithBaseURL:url sessionConfiguration:nil];
+}
+
+- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
+    return [self initWithBaseURL:nil sessionConfiguration:configuration];
+}
+
+- (instancetype)initWithBaseURL:(NSURL *)url
+           sessionConfiguration:(NSURLSessionConfiguration *)configuration
+{
+    self = [super initWithSessionConfiguration:configuration];
+    if (!self) {
+        return nil;
+    }
+
+    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected
+    if ([[url path] length] > 0 && ![[url absoluteString] hasSuffix:@"/"]) {
+        url = [url URLByAppendingPathComponent:@""];
+    }
+
+    self.baseURL = url;
+
+    self.requestSerializer = [AFHTTPRequestSerializer serializer];
+    self.responseSerializer = [AFJSONResponseSerializer serializer];
+
+    return self;
+}
+
+#pragma mark -
+
+#ifdef _SYSTEMCONFIGURATION_H
+#endif
+
+- (void)setRequestSerializer:(AFHTTPRequestSerializer <AFURLRequestSerialization> *)requestSerializer {
+    NSParameterAssert(requestSerializer);
+
+    _requestSerializer = requestSerializer;
+}
+
+- (void)setResponseSerializer:(AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
+    NSParameterAssert(responseSerializer);
+
+    [super setResponseSerializer:responseSerializer];
+}
+
+#pragma mark -
+
+- (NSURLSessionDataTask *)GET:(NSString *)URLString
+                   parameters:(id)parameters
+                      success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                      failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET" URLString:URLString parameters:parameters success:success failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)HEAD:(NSString *)URLString
+                    parameters:(id)parameters
+                       success:(void (^)(NSURLSessionDataTask *task))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"HEAD" URLString:URLString parameters:parameters success:^(NSURLSessionDataTask *task, __unused id responseObject) {
+        if (success) {
+            success(task);
+        }
+    } failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)POST:(NSString *)URLString
+                    parameters:(id)parameters
+                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"POST" URLString:URLString parameters:parameters success:success failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)POST:(NSString *)URLString
+                    parameters:(id)parameters
+     constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSError *serializationError = nil;
+    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&serializationError];
+    if (serializationError) {
+        if (failure) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
+                failure(nil, serializationError);
+            });
+#pragma clang diagnostic pop
+        }
+
+        return nil;
+    }
+
+    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:nil completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
+        if (error) {
+            if (failure) {
+                failure(task, error);
+            }
+        } else {
+            if (success) {
+                success(task, responseObject);
+            }
+        }
+    }];
+
+    [task resume];
+
+    return task;
+}
+
+- (NSURLSessionDataTask *)PUT:(NSString *)URLString
+                   parameters:(id)parameters
+                      success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                      failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"PUT" URLString:URLString parameters:parameters success:success failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)PATCH:(NSString *)URLString
+                     parameters:(id)parameters
+                        success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                        failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"PATCH" URLString:URLString parameters:parameters success:success failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)DELETE:(NSString *)URLString
+                      parameters:(id)parameters
+                         success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
+                         failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
+{
+    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"DELETE" URLString:URLString parameters:parameters success:success failure:failure];
+
+    [dataTask resume];
+
+    return dataTask;
+}
+
+- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method
+                                       URLString:(NSString *)URLString
+                                      parameters:(id)parameters
+                                         success:(void (^)(NSURLSessionDataTask *, id))success
+                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure
+{
+    NSError *serializationError = nil;
+    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&serializationError];
+    if (serializationError) {
+        if (failure) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
+                failure(nil, serializationError);
+            });
+#pragma clang diagnostic pop
+        }
+
+        return nil;
+    }
+
+    __block NSURLSessionDataTask *dataTask = nil;
+    dataTask = [self dataTaskWithRequest:request completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
+        if (error) {
+            if (failure) {
+                failure(dataTask, error);
+            }
+        } else {
+            if (success) {
+                success(dataTask, responseObject);
+            }
+        }
+    }];
+
+    return dataTask;
+}
+
+#pragma mark - NSObject
+
+- (NSString *)description {
+    return [NSString stringWithFormat:@"<%@: %p, baseURL: %@, session: %@, operationQueue: %@>", NSStringFromClass([self class]), self, [self.baseURL absoluteString], self.session, self.operationQueue];
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    NSURL *baseURL = [decoder decodeObjectOfClass:[NSURL class] forKey:NSStringFromSelector(@selector(baseURL))];
+    NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@"sessionConfiguration"];
+    if (!configuration) {
+        NSString *configurationIdentifier = [decoder decodeObjectOfClass:[NSString class] forKey:@"identifier"];
+        if (configurationIdentifier) {
+#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED >= 80000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1100)
+            configuration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:configurationIdentifier];
+#else
+            configuration = [NSURLSessionConfiguration backgroundSessionConfiguration:configurationIdentifier];
+#endif
+        }
+    }
+
+    self = [self initWithBaseURL:baseURL sessionConfiguration:configuration];
+    if (!self) {
+        return nil;
+    }
+
+    self.requestSerializer = [decoder decodeObjectOfClass:[AFHTTPRequestSerializer class] forKey:NSStringFromSelector(@selector(requestSerializer))];
+    self.responseSerializer = [decoder decodeObjectOfClass:[AFHTTPResponseSerializer class] forKey:NSStringFromSelector(@selector(responseSerializer))];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:self.baseURL forKey:NSStringFromSelector(@selector(baseURL))];
+    if ([self.session.configuration conformsToProtocol:@protocol(NSCoding)]) {
+        [coder encodeObject:self.session.configuration forKey:@"sessionConfiguration"];
+    } else {
+        [coder encodeObject:self.session.configuration.identifier forKey:@"identifier"];
+    }
+    [coder encodeObject:self.requestSerializer forKey:NSStringFromSelector(@selector(requestSerializer))];
+    [coder encodeObject:self.responseSerializer forKey:NSStringFromSelector(@selector(responseSerializer))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPSessionManager *HTTPClient = [[[self class] allocWithZone:zone] initWithBaseURL:self.baseURL sessionConfiguration:self.session.configuration];
+
+    HTTPClient.requestSerializer = [self.requestSerializer copyWithZone:zone];
+    HTTPClient.responseSerializer = [self.responseSerializer copyWithZone:zone];
+    
+    return HTTPClient;
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.h
new file mode 100644
index 00000000000..5e610d887f4
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.h
@@ -0,0 +1,193 @@
+// AFNetworkReachabilityManager.h
+// 
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <SystemConfiguration/SystemConfiguration.h>
+
+typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
+    AFNetworkReachabilityStatusUnknown          = -1,
+    AFNetworkReachabilityStatusNotReachable     = 0,
+    AFNetworkReachabilityStatusReachableViaWWAN = 1,
+    AFNetworkReachabilityStatusReachableViaWiFi = 2,
+};
+
+/**
+ `AFNetworkReachabilityManager` monitors the reachability of domains, and addresses for both WWAN and WiFi network interfaces.
+ 
+ Reachability can be used to determine background information about why a network operation failed, or to trigger a network operation retrying when a connection is established. It should not be used to prevent a user from initiating a network request, as it's possible that an initial request may be required to establish reachability.
+
+ See Apple's Reachability Sample Code (https://developer.apple.com/library/ios/samplecode/reachability/)
+ 
+ @warning Instances of `AFNetworkReachabilityManager` must be started with `-startMonitoring` before reachability status can be determined.
+ */
+@interface AFNetworkReachabilityManager : NSObject
+
+/**
+ The current network reachability status.
+ */
+@property (readonly, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;
+
+/**
+ Whether or not the network is currently reachable.
+ */
+@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;
+
+/**
+ Whether or not the network is currently reachable via WWAN.
+ */
+@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;
+
+/**
+ Whether or not the network is currently reachable via WiFi.
+ */
+@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;
+
+///---------------------
+/// @name Initialization
+///---------------------
+
+/**
+ Returns the shared network reachability manager.
+ */
++ (instancetype)sharedManager;
+
+/**
+ Creates and returns a network reachability manager for the specified domain.
+ 
+ @param domain The domain used to evaluate network reachability.
+ 
+ @return An initialized network reachability manager, actively monitoring the specified domain.
+ */
++ (instancetype)managerForDomain:(NSString *)domain;
+
+/**
+ Creates and returns a network reachability manager for the socket address.
+
+ @param address The socket address (`sockaddr_in`) used to evaluate network reachability.
+
+ @return An initialized network reachability manager, actively monitoring the specified socket address.
+ */
++ (instancetype)managerForAddress:(const void *)address;
+
+/**
+ Initializes an instance of a network reachability manager from the specified reachability object.
+ 
+ @param reachability The reachability object to monitor.
+ 
+ @return An initialized network reachability manager, actively monitoring the specified reachability.
+ */
+- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability;
+
+///--------------------------------------------------
+/// @name Starting & Stopping Reachability Monitoring
+///--------------------------------------------------
+
+/**
+ Starts monitoring for changes in network reachability status.
+ */
+- (void)startMonitoring;
+
+/**
+ Stops monitoring for changes in network reachability status.
+ */
+- (void)stopMonitoring;
+
+///-------------------------------------------------
+/// @name Getting Localized Reachability Description
+///-------------------------------------------------
+
+/**
+ Returns a localized string representation of the current network reachability status.
+ */
+- (NSString *)localizedNetworkReachabilityStatusString;
+
+///---------------------------------------------------
+/// @name Setting Network Reachability Change Callback
+///---------------------------------------------------
+
+/**
+ Sets a callback to be executed when the network availability of the `baseURL` host changes.
+
+ @param block A block object to be executed when the network availability of the `baseURL` host changes.. This block has no return value and takes a single argument which represents the various reachability states from the device to the `baseURL`.
+ */
+- (void)setReachabilityStatusChangeBlock:(void (^)(AFNetworkReachabilityStatus status))block;
+
+@end
+
+///----------------
+/// @name Constants
+///----------------
+
+/**
+ ## Network Reachability
+
+ The following constants are provided by `AFNetworkReachabilityManager` as possible network reachability statuses.
+
+ enum {
+ AFNetworkReachabilityStatusUnknown,
+ AFNetworkReachabilityStatusNotReachable,
+ AFNetworkReachabilityStatusReachableViaWWAN,
+ AFNetworkReachabilityStatusReachableViaWiFi,
+ }
+
+ `AFNetworkReachabilityStatusUnknown`
+ The `baseURL` host reachability is not known.
+
+ `AFNetworkReachabilityStatusNotReachable`
+ The `baseURL` host cannot be reached.
+
+ `AFNetworkReachabilityStatusReachableViaWWAN`
+ The `baseURL` host can be reached via a cellular connection, such as EDGE or GPRS.
+
+ `AFNetworkReachabilityStatusReachableViaWiFi`
+ The `baseURL` host can be reached via a Wi-Fi connection.
+
+ ### Keys for Notification UserInfo Dictionary
+
+ Strings that are used as keys in a `userInfo` dictionary in a network reachability status change notification.
+
+ `AFNetworkingReachabilityNotificationStatusItem`
+ A key in the userInfo dictionary in a `AFNetworkingReachabilityDidChangeNotification` notification.
+ The corresponding value is an `NSNumber` object representing the `AFNetworkReachabilityStatus` value for the current reachability status.
+ */
+
+///--------------------
+/// @name Notifications
+///--------------------
+
+/**
+ Posted when network reachability changes.
+ This notification assigns no notification object. The `userInfo` dictionary contains an `NSNumber` object under the `AFNetworkingReachabilityNotificationStatusItem` key, representing the `AFNetworkReachabilityStatus` value for the current network reachability.
+
+ @warning In order for network reachability to be monitored, include the `SystemConfiguration` framework in the active target's "Link Binary With Library" build phase, and add `#import <SystemConfiguration/SystemConfiguration.h>` to the header prefix of the project (`Prefix.pch`).
+ */
+extern NSString * const AFNetworkingReachabilityDidChangeNotification;
+extern NSString * const AFNetworkingReachabilityNotificationStatusItem;
+
+///--------------------
+/// @name Functions
+///--------------------
+
+/**
+ Returns a localized string representation of an `AFNetworkReachabilityStatus` value.
+ */
+extern NSString * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status);
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.m
new file mode 100644
index 00000000000..1da148282d4
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager.m
@@ -0,0 +1,259 @@
+// AFNetworkReachabilityManager.m
+// 
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFNetworkReachabilityManager.h"
+
+#import <netinet/in.h>
+#import <netinet6/in6.h>
+#import <arpa/inet.h>
+#import <ifaddrs.h>
+#import <netdb.h>
+
+NSString * const AFNetworkingReachabilityDidChangeNotification = @"com.alamofire.networking.reachability.change";
+NSString * const AFNetworkingReachabilityNotificationStatusItem = @"AFNetworkingReachabilityNotificationStatusItem";
+
+typedef void (^AFNetworkReachabilityStatusBlock)(AFNetworkReachabilityStatus status);
+
+typedef NS_ENUM(NSUInteger, AFNetworkReachabilityAssociation) {
+    AFNetworkReachabilityForAddress = 1,
+    AFNetworkReachabilityForAddressPair = 2,
+    AFNetworkReachabilityForName = 3,
+};
+
+NSString * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status) {
+    switch (status) {
+        case AFNetworkReachabilityStatusNotReachable:
+            return NSLocalizedStringFromTable(@"Not Reachable", @"AFNetworking", nil);
+        case AFNetworkReachabilityStatusReachableViaWWAN:
+            return NSLocalizedStringFromTable(@"Reachable via WWAN", @"AFNetworking", nil);
+        case AFNetworkReachabilityStatusReachableViaWiFi:
+            return NSLocalizedStringFromTable(@"Reachable via WiFi", @"AFNetworking", nil);
+        case AFNetworkReachabilityStatusUnknown:
+        default:
+            return NSLocalizedStringFromTable(@"Unknown", @"AFNetworking", nil);
+    }
+}
+
+static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {
+    BOOL isReachable = ((flags & kSCNetworkReachabilityFlagsReachable) != 0);
+    BOOL needsConnection = ((flags & kSCNetworkReachabilityFlagsConnectionRequired) != 0);
+    BOOL canConnectionAutomatically = (((flags & kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags & kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));
+    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically && (flags & kSCNetworkReachabilityFlagsInterventionRequired) == 0);
+    BOOL isNetworkReachable = (isReachable && (!needsConnection || canConnectWithoutUserInteraction));
+
+    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;
+    if (isNetworkReachable == NO) {
+        status = AFNetworkReachabilityStatusNotReachable;
+    }
+#if	TARGET_OS_IPHONE
+    else if ((flags & kSCNetworkReachabilityFlagsIsWWAN) != 0) {
+        status = AFNetworkReachabilityStatusReachableViaWWAN;
+    }
+#endif
+    else {
+        status = AFNetworkReachabilityStatusReachableViaWiFi;
+    }
+
+    return status;
+}
+
+static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) {
+    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);
+    AFNetworkReachabilityStatusBlock block = (__bridge AFNetworkReachabilityStatusBlock)info;
+    if (block) {
+        block(status);
+    }
+
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:@{ AFNetworkingReachabilityNotificationStatusItem: @(status) }];
+    });
+    
+}
+
+static const void * AFNetworkReachabilityRetainCallback(const void *info) {
+    return Block_copy(info);
+}
+
+static void AFNetworkReachabilityReleaseCallback(const void *info) {
+    if (info) {
+        Block_release(info);
+    }
+}
+
+@interface AFNetworkReachabilityManager ()
+@property (readwrite, nonatomic, assign) SCNetworkReachabilityRef networkReachability;
+@property (readwrite, nonatomic, assign) AFNetworkReachabilityAssociation networkReachabilityAssociation;
+@property (readwrite, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;
+@property (readwrite, nonatomic, copy) AFNetworkReachabilityStatusBlock networkReachabilityStatusBlock;
+@end
+
+@implementation AFNetworkReachabilityManager
+
++ (instancetype)sharedManager {
+    static AFNetworkReachabilityManager *_sharedManager = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        struct sockaddr_in address;
+        bzero(&address, sizeof(address));
+        address.sin_len = sizeof(address);
+        address.sin_family = AF_INET;
+
+        _sharedManager = [self managerForAddress:&address];
+    });
+
+    return _sharedManager;
+}
+
++ (instancetype)managerForDomain:(NSString *)domain {
+    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);
+
+    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];
+    manager.networkReachabilityAssociation = AFNetworkReachabilityForName;
+
+    return manager;
+}
+
++ (instancetype)managerForAddress:(const void *)address {
+    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);
+
+    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];
+    manager.networkReachabilityAssociation = AFNetworkReachabilityForAddress;
+
+    return manager;
+}
+
+- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.networkReachability = reachability;
+    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;
+
+    return self;
+}
+
+- (void)dealloc {
+    [self stopMonitoring];
+
+    if (_networkReachability) {
+        CFRelease(_networkReachability);
+        _networkReachability = NULL;
+    }
+}
+
+#pragma mark -
+
+- (BOOL)isReachable {
+    return [self isReachableViaWWAN] || [self isReachableViaWiFi];
+}
+
+- (BOOL)isReachableViaWWAN {
+    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;
+}
+
+- (BOOL)isReachableViaWiFi {
+    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;
+}
+
+#pragma mark -
+
+- (void)startMonitoring {
+    [self stopMonitoring];
+
+    if (!self.networkReachability) {
+        return;
+    }
+
+    __weak __typeof(self)weakSelf = self;
+    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
+        __strong __typeof(weakSelf)strongSelf = weakSelf;
+
+        strongSelf.networkReachabilityStatus = status;
+        if (strongSelf.networkReachabilityStatusBlock) {
+            strongSelf.networkReachabilityStatusBlock(status);
+        }
+
+    };
+
+    SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};
+    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &context);
+    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);
+
+    switch (self.networkReachabilityAssociation) {
+        case AFNetworkReachabilityForName:
+            break;
+        case AFNetworkReachabilityForAddress:
+        case AFNetworkReachabilityForAddressPair:
+        default: {
+            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
+                SCNetworkReachabilityFlags flags;
+                SCNetworkReachabilityGetFlags(self.networkReachability, &flags);
+                AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);
+                dispatch_async(dispatch_get_main_queue(), ^{
+                    callback(status);
+                    
+                    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+                    [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:@{ AFNetworkingReachabilityNotificationStatusItem: @(status) }];
+
+                    
+                });
+            });
+        }
+            break;
+    }
+}
+
+- (void)stopMonitoring {
+    if (!self.networkReachability) {
+        return;
+    }
+
+    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);
+}
+
+#pragma mark -
+
+- (NSString *)localizedNetworkReachabilityStatusString {
+    return AFStringFromNetworkReachabilityStatus(self.networkReachabilityStatus);
+}
+
+#pragma mark -
+
+- (void)setReachabilityStatusChangeBlock:(void (^)(AFNetworkReachabilityStatus status))block {
+    self.networkReachabilityStatusBlock = block;
+}
+
+#pragma mark - NSKeyValueObserving
+
++ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key {
+    if ([key isEqualToString:@"reachable"] || [key isEqualToString:@"reachableViaWWAN"] || [key isEqualToString:@"reachableViaWiFi"]) {
+        return [NSSet setWithObject:@"networkReachabilityStatus"];
+    }
+
+    return [super keyPathsForValuesAffectingValueForKey:key];
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworking.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworking.h
new file mode 100644
index 00000000000..68273da58e0
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFNetworking.h
@@ -0,0 +1,44 @@
+// AFNetworking.h
+//
+// Copyright (c) 2013 AFNetworking (http://afnetworking.com/)
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <Availability.h>
+
+#ifndef _AFNETWORKING_
+    #define _AFNETWORKING_
+
+    #import "AFURLRequestSerialization.h"
+    #import "AFURLResponseSerialization.h"
+    #import "AFSecurityPolicy.h"
+    #import "AFNetworkReachabilityManager.h"
+
+    #import "AFURLConnectionOperation.h"
+    #import "AFHTTPRequestOperation.h"
+    #import "AFHTTPRequestOperationManager.h"
+
+#if ( ( defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090) || \
+      ( defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 ) )
+    #import "AFURLSessionManager.h"
+    #import "AFHTTPSessionManager.h"
+#endif
+
+#endif /* _AFNETWORKING_ */
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.h
new file mode 100644
index 00000000000..b86e76b4dc7
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.h
@@ -0,0 +1,143 @@
+// AFSecurity.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <Security/Security.h>
+
+typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {
+    AFSSLPinningModeNone,
+    AFSSLPinningModePublicKey,
+    AFSSLPinningModeCertificate,
+};
+
+/**
+ `AFSecurityPolicy` evaluates server trust against pinned X.509 certificates and public keys over secure connections.
+ 
+ Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an HTTPS connection with SSL pinning configured and enabled.
+ */
+@interface AFSecurityPolicy : NSObject
+
+/**
+ The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`.
+ */
+@property (nonatomic, assign) AFSSLPinningMode SSLPinningMode;
+
+/**
+ Whether to evaluate an entire SSL certificate chain, or just the leaf certificate. Defaults to `YES`.
+ */
+@property (nonatomic, assign) BOOL validatesCertificateChain;
+
+/**
+ The certificates used to evaluate server trust according to the SSL pinning mode. By default, this property is set to any (`.cer`) certificates included in the app bundle.
+ */
+@property (nonatomic, strong) NSArray *pinnedCertificates;
+
+/**
+ Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`.
+ */
+@property (nonatomic, assign) BOOL allowInvalidCertificates;
+
+/**
+ Whether or not to validate the domain name in the certificates CN field. Defaults to `YES` for `AFSSLPinningModePublicKey` or `AFSSLPinningModeCertificate`, otherwise `NO`.
+ */
+@property (nonatomic, assign) BOOL validatesDomainName;
+
+///-----------------------------------------
+/// @name Getting Specific Security Policies
+///-----------------------------------------
+
+/**
+ Returns the shared default security policy, which does not accept invalid certificates, and does not validate against pinned certificates or public keys.
+ 
+ @return The default security policy.
+ */
++ (instancetype)defaultPolicy;
+
+///---------------------
+/// @name Initialization
+///---------------------
+
+/**
+ Creates and returns a security policy with the specified pinning mode.
+ 
+ @param pinningMode The SSL pinning mode.
+ 
+ @return A new security policy.
+ */
++ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode;
+
+///------------------------------
+/// @name Evaluating Server Trust
+///------------------------------
+
+/**
+ Whether or not the specified server trust should be accepted, based on the security policy.
+
+ This method should be used when responding to an authentication challenge from a server.
+
+ @param serverTrust The X.509 certificate trust of the server.
+
+ @return Whether or not to trust the server.
+ 
+ @warning This method has been deprecated in favor of `-evaluateServerTrust:forDomain:`.
+ */
+- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust DEPRECATED_ATTRIBUTE;
+
+/**
+ Whether or not the specified server trust should be accepted, based on the security policy. 
+ 
+ This method should be used when responding to an authentication challenge from a server.
+ 
+ @param serverTrust The X.509 certificate trust of the server.
+ @param domain The domain of serverTrust. If `nil`, the domain will not be validated.
+ 
+ @return Whether or not to trust the server.
+ */
+- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
+                  forDomain:(NSString *)domain;
+
+@end
+
+///----------------
+/// @name Constants
+///----------------
+
+/**
+ ## SSL Pinning Modes
+
+ The following constants are provided by `AFSSLPinningMode` as possible SSL pinning modes.
+
+ enum {
+ AFSSLPinningModeNone,
+ AFSSLPinningModePublicKey,
+ AFSSLPinningModeCertificate,
+ }
+
+ `AFSSLPinningModeNone`
+ Do not used pinned certificates to validate servers.
+
+ `AFSSLPinningModePublicKey`
+ Validate host certificates against public keys of pinned certificates.
+
+ `AFSSLPinningModeCertificate`
+ Validate host certificates against pinned certificates.
+*/
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.m
new file mode 100644
index 00000000000..f11caaa6367
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFSecurityPolicy.m
@@ -0,0 +1,320 @@
+// AFSecurity.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFSecurityPolicy.h"
+
+// Equivalent of macro in <AssertMacros.h>, without causing compiler warning:
+// "'DebugAssert' is deprecated: first deprecated in OS X 10.8"
+#ifndef AF_Require
+    #define AF_Require(assertion, exceptionLabel)                \
+        do {                                                     \
+            if (__builtin_expect(!(assertion), 0)) {             \
+                goto exceptionLabel;                             \
+            }                                                    \
+        } while (0)
+#endif
+
+#ifndef AF_Require_noErr
+    #define AF_Require_noErr(errorCode, exceptionLabel)          \
+        do {                                                     \
+            if (__builtin_expect(0 != (errorCode), 0)) {         \
+                goto exceptionLabel;                             \
+            }                                                    \
+        } while (0)
+#endif
+
+#if !defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+static NSData * AFSecKeyGetData(SecKeyRef key) {
+    CFDataRef data = NULL;
+
+    AF_Require_noErr(SecItemExport(key, kSecFormatUnknown, kSecItemPemArmour, NULL, &data), _out);
+
+    return (__bridge_transfer NSData *)data;
+
+_out:
+    if (data) {
+        CFRelease(data);
+    }
+
+    return nil;
+}
+#endif
+
+static BOOL AFSecKeyIsEqualToKey(SecKeyRef key1, SecKeyRef key2) {
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    return [(__bridge id)key1 isEqual:(__bridge id)key2];
+#else
+    return [AFSecKeyGetData(key1) isEqual:AFSecKeyGetData(key2)];
+#endif
+}
+
+static id AFPublicKeyForCertificate(NSData *certificate) {
+    id allowedPublicKey = nil;
+    SecCertificateRef allowedCertificate;
+    SecCertificateRef allowedCertificates[1];
+    CFArrayRef tempCertificates = nil;
+    SecPolicyRef policy = nil;
+    SecTrustRef allowedTrust = nil;
+    SecTrustResultType result;
+
+    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
+    AF_Require(allowedCertificate != NULL, _out);
+
+    allowedCertificates[0] = allowedCertificate;
+    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);
+
+    policy = SecPolicyCreateBasicX509();
+    AF_Require_noErr(SecTrustCreateWithCertificates(tempCertificates, policy, &allowedTrust), _out);
+    AF_Require_noErr(SecTrustEvaluate(allowedTrust, &result), _out);
+
+    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);
+
+_out:
+    if (allowedTrust) {
+        CFRelease(allowedTrust);
+    }
+
+    if (policy) {
+        CFRelease(policy);
+    }
+
+    if (tempCertificates) {
+        CFRelease(tempCertificates);
+    }
+
+    if (allowedCertificate) {
+        CFRelease(allowedCertificate);
+    }
+
+    return allowedPublicKey;
+}
+
+static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) {
+    BOOL isValid = NO;
+    SecTrustResultType result;
+    AF_Require_noErr(SecTrustEvaluate(serverTrust, &result), _out);
+
+    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);
+
+_out:
+    return isValid;
+}
+
+static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) {
+    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
+    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];
+
+    for (CFIndex i = 0; i < certificateCount; i++) {
+        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
+        [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)];
+    }
+
+    return [NSArray arrayWithArray:trustChain];
+}
+
+static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) {
+    SecPolicyRef policy = SecPolicyCreateBasicX509();
+    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
+    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];
+    for (CFIndex i = 0; i < certificateCount; i++) {
+        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
+
+        SecCertificateRef someCertificates[] = {certificate};
+        CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL);
+
+        SecTrustRef trust;
+        AF_Require_noErr(SecTrustCreateWithCertificates(certificates, policy, &trust), _out);
+        
+        SecTrustResultType result;
+        AF_Require_noErr(SecTrustEvaluate(trust, &result), _out);
+
+        [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)];
+
+    _out:
+        if (trust) {
+            CFRelease(trust);
+        }
+
+        if (certificates) {
+            CFRelease(certificates);
+        }
+
+        continue;
+    }
+    CFRelease(policy);
+
+    return [NSArray arrayWithArray:trustChain];
+}
+
+#pragma mark -
+
+@interface AFSecurityPolicy()
+@property (readwrite, nonatomic, strong) NSArray *pinnedPublicKeys;
+@end
+
+@implementation AFSecurityPolicy
+
++ (NSArray *)defaultPinnedCertificates {
+    static NSArray *_defaultPinnedCertificates = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        NSBundle *bundle = [NSBundle bundleForClass:[self class]];
+        NSArray *paths = [bundle pathsForResourcesOfType:@"cer" inDirectory:@"."];
+
+        NSMutableArray *certificates = [NSMutableArray arrayWithCapacity:[paths count]];
+        for (NSString *path in paths) {
+            NSData *certificateData = [NSData dataWithContentsOfFile:path];
+            [certificates addObject:certificateData];
+        }
+
+        _defaultPinnedCertificates = [[NSArray alloc] initWithArray:certificates];
+    });
+
+    return _defaultPinnedCertificates;
+}
+
++ (instancetype)defaultPolicy {
+    AFSecurityPolicy *securityPolicy = [[self alloc] init];
+    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;
+
+    return securityPolicy;
+}
+
++ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode {
+    AFSecurityPolicy *securityPolicy = [[self alloc] init];
+    securityPolicy.SSLPinningMode = pinningMode;
+    securityPolicy.validatesDomainName = YES;
+    [securityPolicy setPinnedCertificates:[self defaultPinnedCertificates]];
+
+    return securityPolicy;
+}
+
+- (id)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.validatesCertificateChain = YES;
+
+    return self;
+}
+
+#pragma mark -
+
+- (void)setPinnedCertificates:(NSArray *)pinnedCertificates {
+    _pinnedCertificates = pinnedCertificates;
+
+    if (self.pinnedCertificates) {
+        NSMutableArray *mutablePinnedPublicKeys = [NSMutableArray arrayWithCapacity:[self.pinnedCertificates count]];
+        for (NSData *certificate in self.pinnedCertificates) {
+            id publicKey = AFPublicKeyForCertificate(certificate);
+            if (!publicKey) {
+                continue;
+            }
+            [mutablePinnedPublicKeys addObject:publicKey];
+        }
+        self.pinnedPublicKeys = [NSArray arrayWithArray:mutablePinnedPublicKeys];
+    } else {
+        self.pinnedPublicKeys = nil;
+    }
+}
+
+#pragma mark -
+
+- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust {
+    return [self evaluateServerTrust:serverTrust forDomain:nil];
+}
+
+- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
+                  forDomain:(NSString *)domain
+{
+    NSMutableArray *policies = [NSMutableArray array];
+    if (self.validatesDomainName) {
+        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
+    } else {
+        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];
+    }
+
+    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);
+
+    if (!AFServerTrustIsValid(serverTrust) && !self.allowInvalidCertificates) {
+        return NO;
+    }
+
+    NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);
+    switch (self.SSLPinningMode) {
+        case AFSSLPinningModeNone:
+            return YES;
+        case AFSSLPinningModeCertificate: {
+            NSMutableArray *pinnedCertificates = [NSMutableArray array];
+            for (NSData *certificateData in self.pinnedCertificates) {
+                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
+            }
+            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);
+
+            if (!AFServerTrustIsValid(serverTrust)) {
+                return NO;
+            }
+
+            if (!self.validatesCertificateChain) {
+                return YES;
+            }
+
+            NSUInteger trustedCertificateCount = 0;
+            for (NSData *trustChainCertificate in serverCertificates) {
+                if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
+                    trustedCertificateCount++;
+                }
+            }
+
+            return trustedCertificateCount == [serverCertificates count];
+        }
+        case AFSSLPinningModePublicKey: {
+            NSUInteger trustedPublicKeyCount = 0;
+            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);
+            if (!self.validatesCertificateChain && [publicKeys count] > 0) {
+                publicKeys = @[[publicKeys firstObject]];
+            }
+
+            for (id trustChainPublicKey in publicKeys) {
+                for (id pinnedPublicKey in self.pinnedPublicKeys) {
+                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
+                        trustedPublicKeyCount += 1;
+                    }
+                }
+            }
+
+            return trustedPublicKeyCount > 0 && ((self.validatesCertificateChain && trustedPublicKeyCount == [serverCertificates count]) || (!self.validatesCertificateChain && trustedPublicKeyCount >= 1));
+        }
+    }
+    
+    return NO;
+}
+
+#pragma mark - NSKeyValueObserving
+
++ (NSSet *)keyPathsForValuesAffectingPinnedPublicKeys {
+    return [NSSet setWithObject:@"pinnedCertificates"];
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.h
new file mode 100644
index 00000000000..85435564c3e
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.h
@@ -0,0 +1,328 @@
+// AFURLConnectionOperation.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+#import "AFURLRequestSerialization.h"
+#import "AFURLResponseSerialization.h"
+#import "AFSecurityPolicy.h"
+
+/**
+ `AFURLConnectionOperation` is a subclass of `NSOperation` that implements `NSURLConnection` delegate methods.
+
+ ## Subclassing Notes
+
+ This is the base class of all network request operations. You may wish to create your own subclass in order to implement additional `NSURLConnection` delegate methods (see "`NSURLConnection` Delegate Methods" below), or to provide additional properties and/or class constructors.
+
+ If you are creating a subclass that communicates over the HTTP or HTTPS protocols, you may want to consider subclassing `AFHTTPRequestOperation` instead, as it supports specifying acceptable content types or status codes.
+
+ ## NSURLConnection Delegate Methods
+
+ `AFURLConnectionOperation` implements the following `NSURLConnection` delegate methods:
+
+ - `connection:didReceiveResponse:`
+ - `connection:didReceiveData:`
+ - `connectionDidFinishLoading:`
+ - `connection:didFailWithError:`
+ - `connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite:`
+ - `connection:willCacheResponse:`
+ - `connectionShouldUseCredentialStorage:`
+ - `connection:needNewBodyStream:` 
+ - `connection:willSendRequestForAuthenticationChallenge:`
+
+ If any of these methods are overridden in a subclass, they _must_ call the `super` implementation first.
+
+ ## Callbacks and Completion Blocks
+
+ The built-in `completionBlock` provided by `NSOperation` allows for custom behavior to be executed after the request finishes. It is a common pattern for class constructors in subclasses to take callback block parameters, and execute them conditionally in the body of its `completionBlock`. Make sure to handle cancelled operations appropriately when setting a `completionBlock` (i.e. returning early before parsing response data). See the implementation of any of the `AFHTTPRequestOperation` subclasses for an example of this.
+
+ Subclasses are strongly discouraged from overriding `setCompletionBlock:`, as `AFURLConnectionOperation`'s implementation includes a workaround to mitigate retain cycles, and what Apple rather ominously refers to as ["The Deallocation Problem"](http://developer.apple.com/library/ios/#technotes/tn2109/).
+ 
+ ## SSL Pinning
+ 
+ Relying on the CA trust model to validate SSL certificates exposes your app to security vulnerabilities, such as man-in-the-middle attacks. For applications that connect to known servers, SSL certificate pinning provides an increased level of security, by checking server certificate validity against those specified in the app bundle.
+ 
+ SSL with certificate pinning is strongly recommended for any application that transmits sensitive information to an external webservice.
+
+ Connections will be validated on all matching certificates with a `.cer` extension in the bundle root.
+ 
+ ## App Extensions
+ 
+ When using AFNetworking in an App Extension, `#define AF_APP_EXTENSIONS` to avoid using unavailable APIs.
+
+ ## NSCoding & NSCopying Conformance
+
+ `AFURLConnectionOperation` conforms to the `NSCoding` and `NSCopying` protocols, allowing operations to be archived to disk, and copied in memory, respectively. However, because of the intrinsic limitations of capturing the exact state of an operation at a particular moment, there are some important caveats to keep in mind:
+
+ ### NSCoding Caveats
+
+ - Encoded operations do not include any block or stream properties. Be sure to set `completionBlock`, `outputStream`, and any callback blocks as necessary when using `-initWithCoder:` or `NSKeyedUnarchiver`.
+ - Operations are paused on `encodeWithCoder:`. If the operation was encoded while paused or still executing, its archived state will return `YES` for `isReady`. Otherwise, the state of an operation when encoding will remain unchanged.
+
+ ### NSCopying Caveats
+
+ - `-copy` and `-copyWithZone:` return a new operation with the `NSURLRequest` of the original. So rather than an exact copy of the operation at that particular instant, the copying mechanism returns a completely new instance, which can be useful for retrying operations.
+ - A copy of an operation will not include the `outputStream` of the original.
+ - Operation copies do not include `completionBlock`, as it often strongly captures a reference to `self`, which would otherwise have the unintuitive side-effect of pointing to the _original_ operation when copied.
+ */
+
+@interface AFURLConnectionOperation : NSOperation <NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying>
+
+///-------------------------------
+/// @name Accessing Run Loop Modes
+///-------------------------------
+
+/**
+ The run loop modes in which the operation will run on the network thread. By default, this is a single-member set containing `NSRunLoopCommonModes`.
+ */
+@property (nonatomic, strong) NSSet *runLoopModes;
+
+///-----------------------------------------
+/// @name Getting URL Connection Information
+///-----------------------------------------
+
+/**
+ The request used by the operation's connection.
+ */
+@property (readonly, nonatomic, strong) NSURLRequest *request;
+
+/**
+ The last response received by the operation's connection.
+ */
+@property (readonly, nonatomic, strong) NSURLResponse *response;
+
+/**
+ The error, if any, that occurred in the lifecycle of the request.
+ */
+@property (readonly, nonatomic, strong) NSError *error;
+
+///----------------------------
+/// @name Getting Response Data
+///----------------------------
+
+/**
+ The data received during the request.
+ */
+@property (readonly, nonatomic, strong) NSData *responseData;
+
+/**
+ The string representation of the response data.
+ */
+@property (readonly, nonatomic, copy) NSString *responseString;
+
+/**
+ The string encoding of the response.
+
+ If the response does not specify a valid string encoding, `responseStringEncoding` will return `NSUTF8StringEncoding`.
+ */
+@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;
+
+///-------------------------------
+/// @name Managing URL Credentials
+///-------------------------------
+
+/**
+ Whether the URL connection should consult the credential storage for authenticating the connection. `YES` by default.
+
+ This is the value that is returned in the `NSURLConnectionDelegate` method `-connectionShouldUseCredentialStorage:`.
+ */
+@property (nonatomic, assign) BOOL shouldUseCredentialStorage;
+
+/**
+ The credential used for authentication challenges in `-connection:didReceiveAuthenticationChallenge:`.
+
+ This will be overridden by any shared credentials that exist for the username or password of the request URL, if present.
+ */
+@property (nonatomic, strong) NSURLCredential *credential;
+
+///-------------------------------
+/// @name Managing Security Policy
+///-------------------------------
+
+/**
+ The security policy used to evaluate server trust for secure connections.
+ */
+@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;
+
+///------------------------
+/// @name Accessing Streams
+///------------------------
+
+/**
+ The input stream used to read data to be sent during the request.
+
+ This property acts as a proxy to the `HTTPBodyStream` property of `request`.
+ */
+@property (nonatomic, strong) NSInputStream *inputStream;
+
+/**
+ The output stream that is used to write data received until the request is finished.
+
+ By default, data is accumulated into a buffer that is stored into `responseData` upon completion of the request, with the intermediary `outputStream` property set to `nil`. When `outputStream` is set, the data will not be accumulated into an internal buffer, and as a result, the `responseData` property of the completed request will be `nil`. The output stream will be scheduled in the network thread runloop upon being set.
+ */
+@property (nonatomic, strong) NSOutputStream *outputStream;
+
+///---------------------------------
+/// @name Managing Callback Queues
+///---------------------------------
+
+/**
+ The dispatch queue for `completionBlock`. If `NULL` (default), the main queue is used.
+ */
+@property (nonatomic, strong) dispatch_queue_t completionQueue;
+
+/**
+ The dispatch group for `completionBlock`. If `NULL` (default), a private dispatch group is used.
+ */
+@property (nonatomic, strong) dispatch_group_t completionGroup;
+
+///---------------------------------------------
+/// @name Managing Request Operation Information
+///---------------------------------------------
+
+/**
+ The user info dictionary for the receiver.
+ */
+@property (nonatomic, strong) NSDictionary *userInfo;
+
+///------------------------------------------------------
+/// @name Initializing an AFURLConnectionOperation Object
+///------------------------------------------------------
+
+/**
+ Initializes and returns a newly allocated operation object with a url connection configured with the specified url request.
+ 
+ This is the designated initializer.
+ 
+ @param urlRequest The request object to be used by the operation connection.
+ */
+- (instancetype)initWithRequest:(NSURLRequest *)urlRequest;
+
+///----------------------------------
+/// @name Pausing / Resuming Requests
+///----------------------------------
+
+/**
+ Pauses the execution of the request operation.
+
+ A paused operation returns `NO` for `-isReady`, `-isExecuting`, and `-isFinished`. As such, it will remain in an `NSOperationQueue` until it is either cancelled or resumed. Pausing a finished, cancelled, or paused operation has no effect.
+ */
+- (void)pause;
+
+/**
+ Whether the request operation is currently paused.
+
+ @return `YES` if the operation is currently paused, otherwise `NO`.
+ */
+- (BOOL)isPaused;
+
+/**
+ Resumes the execution of the paused request operation.
+
+ Pause/Resume behavior varies depending on the underlying implementation for the operation class. In its base implementation, resuming a paused requests restarts the original request. However, since HTTP defines a specification for how to request a specific content range, `AFHTTPRequestOperation` will resume downloading the request from where it left off, instead of restarting the original request.
+ */
+- (void)resume;
+
+///----------------------------------------------
+/// @name Configuring Backgrounding Task Behavior
+///----------------------------------------------
+
+/**
+ Specifies that the operation should continue execution after the app has entered the background, and the expiration handler for that background task.
+
+ @param handler A handler to be called shortly before the applications remaining background time reaches 0. The handler is wrapped in a block that cancels the operation, and cleans up and marks the end of execution, unlike the `handler` parameter in `UIApplication -beginBackgroundTaskWithExpirationHandler:`, which expects this to be done in the handler itself. The handler is called synchronously on the main thread, thus blocking the applications suspension momentarily while the application is notified.
+  */
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && !defined(AF_APP_EXTENSIONS)
+- (void)setShouldExecuteAsBackgroundTaskWithExpirationHandler:(void (^)(void))handler;
+#endif
+
+///---------------------------------
+/// @name Setting Progress Callbacks
+///---------------------------------
+
+/**
+ Sets a callback to be called when an undetermined number of bytes have been uploaded to the server.
+
+ @param block A block object to be called when an undetermined number of bytes have been uploaded to the server. This block has no return value and takes three arguments: the number of bytes written since the last time the upload progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body. This block may be called multiple times, and will execute on the main thread.
+ */
+- (void)setUploadProgressBlock:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))block;
+
+/**
+ Sets a callback to be called when an undetermined number of bytes have been downloaded from the server.
+
+ @param block A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes three arguments: the number of bytes read since the last time the download progress block was called, the total bytes read, and the total bytes expected to be read during the request, as initially determined by the expected content size of the `NSHTTPURLResponse` object. This block may be called multiple times, and will execute on the main thread.
+ */
+- (void)setDownloadProgressBlock:(void (^)(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead))block;
+
+///-------------------------------------------------
+/// @name Setting NSURLConnection Delegate Callbacks
+///-------------------------------------------------
+
+/**
+ Sets a block to be executed when the connection will authenticate a challenge in order to download its request, as handled by the `NSURLConnectionDelegate` method `connection:willSendRequestForAuthenticationChallenge:`.
+ 
+ @param block A block object to be executed when the connection will authenticate a challenge in order to download its request. The block has no return type and takes two arguments: the URL connection object, and the challenge that must be authenticated. This block must invoke one of the challenge-responder methods (NSURLAuthenticationChallengeSender protocol).
+ 
+ If `allowsInvalidSSLCertificate` is set to YES, `connection:willSendRequestForAuthenticationChallenge:` will attempt to have the challenge sender use credentials with invalid SSL certificates.
+ */
+- (void)setWillSendRequestForAuthenticationChallengeBlock:(void (^)(NSURLConnection *connection, NSURLAuthenticationChallenge *challenge))block;
+
+/**
+ Sets a block to be executed when the server redirects the request from one URL to another URL, or when the request URL changed by the `NSURLProtocol` subclass handling the request in order to standardize its format, as handled by the `NSURLConnectionDataDelegate` method `connection:willSendRequest:redirectResponse:`.
+
+ @param block A block object to be executed when the request URL was changed. The block returns an `NSURLRequest` object, the URL request to redirect, and takes three arguments: the URL connection object, the the proposed redirected request, and the URL response that caused the redirect.
+ */
+- (void)setRedirectResponseBlock:(NSURLRequest * (^)(NSURLConnection *connection, NSURLRequest *request, NSURLResponse *redirectResponse))block;
+
+
+/**
+ Sets a block to be executed to modify the response a connection will cache, if any, as handled by the `NSURLConnectionDelegate` method `connection:willCacheResponse:`.
+
+ @param block A block object to be executed to determine what response a connection will cache, if any. The block returns an `NSCachedURLResponse` object, the cached response to store in memory or `nil` to prevent the response from being cached, and takes two arguments: the URL connection object, and the cached response provided for the request.
+ */
+- (void)setCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLConnection *connection, NSCachedURLResponse *cachedResponse))block;
+
+///
+
+/**
+
+ */
++ (NSArray *)batchOfRequestOperations:(NSArray *)operations
+                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
+                      completionBlock:(void (^)(NSArray *operations))completionBlock;
+
+@end
+
+///--------------------
+/// @name Notifications
+///--------------------
+
+/**
+ Posted when an operation begins executing.
+ */
+extern NSString * const AFNetworkingOperationDidStartNotification;
+
+/**
+ Posted when an operation finishes.
+ */
+extern NSString * const AFNetworkingOperationDidFinishNotification;
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.m
new file mode 100644
index 00000000000..d8b55e3e3bb
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation.m
@@ -0,0 +1,786 @@
+// AFURLConnectionOperation.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFURLConnectionOperation.h"
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <UIKit/UIKit.h>
+#endif
+
+#if !__has_feature(objc_arc)
+#error AFNetworking must be built with ARC.
+// You can turn on ARC for only AFNetworking files by adding -fobjc-arc to the build phase for each of its files.
+#endif
+
+typedef NS_ENUM(NSInteger, AFOperationState) {
+    AFOperationPausedState      = -1,
+    AFOperationReadyState       = 1,
+    AFOperationExecutingState   = 2,
+    AFOperationFinishedState    = 3,
+};
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && !defined(AF_APP_EXTENSIONS)
+typedef UIBackgroundTaskIdentifier AFBackgroundTaskIdentifier;
+#else
+typedef id AFBackgroundTaskIdentifier;
+#endif
+
+static dispatch_group_t url_request_operation_completion_group() {
+    static dispatch_group_t af_url_request_operation_completion_group;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_url_request_operation_completion_group = dispatch_group_create();
+    });
+
+    return af_url_request_operation_completion_group;
+}
+
+static dispatch_queue_t url_request_operation_completion_queue() {
+    static dispatch_queue_t af_url_request_operation_completion_queue;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_url_request_operation_completion_queue = dispatch_queue_create("com.alamofire.networking.operation.queue", DISPATCH_QUEUE_CONCURRENT );
+    });
+
+    return af_url_request_operation_completion_queue;
+}
+
+static NSString * const kAFNetworkingLockName = @"com.alamofire.networking.operation.lock";
+
+NSString * const AFNetworkingOperationDidStartNotification = @"com.alamofire.networking.operation.start";
+NSString * const AFNetworkingOperationDidFinishNotification = @"com.alamofire.networking.operation.finish";
+
+typedef void (^AFURLConnectionOperationProgressBlock)(NSUInteger bytes, long long totalBytes, long long totalBytesExpected);
+typedef void (^AFURLConnectionOperationAuthenticationChallengeBlock)(NSURLConnection *connection, NSURLAuthenticationChallenge *challenge);
+typedef NSCachedURLResponse * (^AFURLConnectionOperationCacheResponseBlock)(NSURLConnection *connection, NSCachedURLResponse *cachedResponse);
+typedef NSURLRequest * (^AFURLConnectionOperationRedirectResponseBlock)(NSURLConnection *connection, NSURLRequest *request, NSURLResponse *redirectResponse);
+
+static inline NSString * AFKeyPathFromOperationState(AFOperationState state) {
+    switch (state) {
+        case AFOperationReadyState:
+            return @"isReady";
+        case AFOperationExecutingState:
+            return @"isExecuting";
+        case AFOperationFinishedState:
+            return @"isFinished";
+        case AFOperationPausedState:
+            return @"isPaused";
+        default: {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunreachable-code"
+            return @"state";
+#pragma clang diagnostic pop
+        }
+    }
+}
+
+static inline BOOL AFStateTransitionIsValid(AFOperationState fromState, AFOperationState toState, BOOL isCancelled) {
+    switch (fromState) {
+        case AFOperationReadyState:
+            switch (toState) {
+                case AFOperationPausedState:
+                case AFOperationExecutingState:
+                    return YES;
+                case AFOperationFinishedState:
+                    return isCancelled;
+                default:
+                    return NO;
+            }
+        case AFOperationExecutingState:
+            switch (toState) {
+                case AFOperationPausedState:
+                case AFOperationFinishedState:
+                    return YES;
+                default:
+                    return NO;
+            }
+        case AFOperationFinishedState:
+            return NO;
+        case AFOperationPausedState:
+            return toState == AFOperationReadyState;
+        default: {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunreachable-code"
+            switch (toState) {
+                case AFOperationPausedState:
+                case AFOperationReadyState:
+                case AFOperationExecutingState:
+                case AFOperationFinishedState:
+                    return YES;
+                default:
+                    return NO;
+            }
+        }
+#pragma clang diagnostic pop
+    }
+}
+
+@interface AFURLConnectionOperation ()
+@property (readwrite, nonatomic, assign) AFOperationState state;
+@property (readwrite, nonatomic, strong) NSRecursiveLock *lock;
+@property (readwrite, nonatomic, strong) NSURLConnection *connection;
+@property (readwrite, nonatomic, strong) NSURLRequest *request;
+@property (readwrite, nonatomic, strong) NSURLResponse *response;
+@property (readwrite, nonatomic, strong) NSError *error;
+@property (readwrite, nonatomic, strong) NSData *responseData;
+@property (readwrite, nonatomic, copy) NSString *responseString;
+@property (readwrite, nonatomic, assign) NSStringEncoding responseStringEncoding;
+@property (readwrite, nonatomic, assign) long long totalBytesRead;
+@property (readwrite, nonatomic, assign) AFBackgroundTaskIdentifier backgroundTaskIdentifier;
+@property (readwrite, nonatomic, copy) AFURLConnectionOperationProgressBlock uploadProgress;
+@property (readwrite, nonatomic, copy) AFURLConnectionOperationProgressBlock downloadProgress;
+@property (readwrite, nonatomic, copy) AFURLConnectionOperationAuthenticationChallengeBlock authenticationChallenge;
+@property (readwrite, nonatomic, copy) AFURLConnectionOperationCacheResponseBlock cacheResponse;
+@property (readwrite, nonatomic, copy) AFURLConnectionOperationRedirectResponseBlock redirectResponse;
+
+- (void)operationDidStart;
+- (void)finish;
+- (void)cancelConnection;
+@end
+
+@implementation AFURLConnectionOperation
+@synthesize outputStream = _outputStream;
+
++ (void)networkRequestThreadEntryPoint:(id)__unused object {
+    @autoreleasepool {
+        [[NSThread currentThread] setName:@"AFNetworking"];
+
+        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
+        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
+        [runLoop run];
+    }
+}
+
++ (NSThread *)networkRequestThread {
+    static NSThread *_networkRequestThread = nil;
+    static dispatch_once_t oncePredicate;
+    dispatch_once(&oncePredicate, ^{
+        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
+        [_networkRequestThread start];
+    });
+    
+    return _networkRequestThread;
+}
+
+- (instancetype)initWithRequest:(NSURLRequest *)urlRequest {
+    NSParameterAssert(urlRequest);
+
+    self = [super init];
+    if (!self) {
+		return nil;
+    }
+
+    _state = AFOperationReadyState;
+
+    self.lock = [[NSRecursiveLock alloc] init];
+    self.lock.name = kAFNetworkingLockName;
+    
+    self.runLoopModes = [NSSet setWithObject:NSRunLoopCommonModes];
+    
+    self.request = urlRequest;
+    
+    self.shouldUseCredentialStorage = YES;
+
+    self.securityPolicy = [AFSecurityPolicy defaultPolicy];
+
+    return self;
+}
+
+- (void)dealloc {
+    if (_outputStream) {
+        [_outputStream close];
+        _outputStream = nil;
+    }
+    
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && !defined(AF_APP_EXTENSIONS)
+    if (_backgroundTaskIdentifier) {
+        [[UIApplication sharedApplication] endBackgroundTask:_backgroundTaskIdentifier];
+        _backgroundTaskIdentifier = UIBackgroundTaskInvalid;
+    }
+#endif
+}
+
+#pragma mark -
+
+- (void)setResponseData:(NSData *)responseData {
+    [self.lock lock];
+    if (!responseData) {
+        _responseData = nil;
+    } else {
+        _responseData = [NSData dataWithBytes:responseData.bytes length:responseData.length];
+    }
+    [self.lock unlock];
+}
+
+- (NSString *)responseString {
+    [self.lock lock];
+    if (!_responseString && self.response && self.responseData) {
+        self.responseString = [[NSString alloc] initWithData:self.responseData encoding:self.responseStringEncoding];
+    }
+    [self.lock unlock];
+
+    return _responseString;
+}
+
+- (NSStringEncoding)responseStringEncoding {
+    [self.lock lock];
+    if (!_responseStringEncoding && self.response) {
+        NSStringEncoding stringEncoding = NSUTF8StringEncoding;
+        if (self.response.textEncodingName) {
+            CFStringEncoding IANAEncoding = CFStringConvertIANACharSetNameToEncoding((__bridge CFStringRef)self.response.textEncodingName);
+            if (IANAEncoding != kCFStringEncodingInvalidId) {
+                stringEncoding = CFStringConvertEncodingToNSStringEncoding(IANAEncoding);
+            }
+        }
+
+        self.responseStringEncoding = stringEncoding;
+    }
+    [self.lock unlock];
+
+    return _responseStringEncoding;
+}
+
+- (NSInputStream *)inputStream {
+    return self.request.HTTPBodyStream;
+}
+
+- (void)setInputStream:(NSInputStream *)inputStream {
+    NSMutableURLRequest *mutableRequest = [self.request mutableCopy];
+    mutableRequest.HTTPBodyStream = inputStream;
+    self.request = mutableRequest;
+}
+
+- (NSOutputStream *)outputStream {
+    if (!_outputStream) {
+        self.outputStream = [NSOutputStream outputStreamToMemory];
+    }
+
+    return _outputStream;
+}
+
+- (void)setOutputStream:(NSOutputStream *)outputStream {
+    [self.lock lock];
+    if (outputStream != _outputStream) {
+        if (_outputStream) {
+            [_outputStream close];
+        }
+
+        _outputStream = outputStream;
+    }
+    [self.lock unlock];
+}
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && !defined(AF_APP_EXTENSIONS)
+- (void)setShouldExecuteAsBackgroundTaskWithExpirationHandler:(void (^)(void))handler {
+    [self.lock lock];
+    if (!self.backgroundTaskIdentifier) {
+        UIApplication *application = [UIApplication sharedApplication];
+        __weak __typeof(self)weakSelf = self;
+        self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^{
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+            
+            if (handler) {
+                handler();
+            }
+            
+            if (strongSelf) {
+                [strongSelf cancel];
+                
+                [application endBackgroundTask:strongSelf.backgroundTaskIdentifier];
+                strongSelf.backgroundTaskIdentifier = UIBackgroundTaskInvalid;
+            }
+        }];
+    }
+    [self.lock unlock];
+}
+#endif
+
+#pragma mark -
+
+- (void)setState:(AFOperationState)state {
+    if (!AFStateTransitionIsValid(self.state, state, [self isCancelled])) {
+        return;
+    }
+    
+    [self.lock lock];
+    NSString *oldStateKey = AFKeyPathFromOperationState(self.state);
+    NSString *newStateKey = AFKeyPathFromOperationState(state);
+    
+    [self willChangeValueForKey:newStateKey];
+    [self willChangeValueForKey:oldStateKey];
+    _state = state;
+    [self didChangeValueForKey:oldStateKey];
+    [self didChangeValueForKey:newStateKey];
+    [self.lock unlock];
+}
+
+- (void)pause {
+    if ([self isPaused] || [self isFinished] || [self isCancelled]) {
+        return;
+    }
+    
+    [self.lock lock];
+    if ([self isExecuting]) {
+        [self performSelector:@selector(operationDidPause) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
+        
+        dispatch_async(dispatch_get_main_queue(), ^{
+            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:self];
+        });
+    }
+    
+    self.state = AFOperationPausedState;
+    [self.lock unlock];
+}
+
+- (void)operationDidPause {
+    [self.lock lock];
+    [self.connection cancel];
+    [self.lock unlock];
+}
+
+- (BOOL)isPaused {
+    return self.state == AFOperationPausedState;
+}
+
+- (void)resume {
+    if (![self isPaused]) {
+        return;
+    }
+    
+    [self.lock lock];
+    self.state = AFOperationReadyState;
+    
+    [self start];
+    [self.lock unlock];
+}
+
+#pragma mark -
+
+- (void)setUploadProgressBlock:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))block {
+    self.uploadProgress = block;
+}
+
+- (void)setDownloadProgressBlock:(void (^)(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead))block {
+    self.downloadProgress = block;
+}
+
+- (void)setWillSendRequestForAuthenticationChallengeBlock:(void (^)(NSURLConnection *connection, NSURLAuthenticationChallenge *challenge))block {
+    self.authenticationChallenge = block;
+}
+
+- (void)setCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLConnection *connection, NSCachedURLResponse *cachedResponse))block {
+    self.cacheResponse = block;
+}
+
+- (void)setRedirectResponseBlock:(NSURLRequest * (^)(NSURLConnection *connection, NSURLRequest *request, NSURLResponse *redirectResponse))block {
+    self.redirectResponse = block;
+}
+
+#pragma mark - NSOperation
+
+- (void)setCompletionBlock:(void (^)(void))block {
+    [self.lock lock];
+    if (!block) {
+        [super setCompletionBlock:nil];
+    } else {
+        __weak __typeof(self)weakSelf = self;
+        [super setCompletionBlock:^ {
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();
+            dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue();
+#pragma clang diagnostic pop
+
+            dispatch_group_async(group, queue, ^{
+                block();
+            });
+
+            dispatch_group_notify(group, url_request_operation_completion_queue(), ^{
+                [strongSelf setCompletionBlock:nil];
+            });
+        }];
+    }
+    [self.lock unlock];
+}
+
+- (BOOL)isReady {
+    return self.state == AFOperationReadyState && [super isReady];
+}
+
+- (BOOL)isExecuting {
+    return self.state == AFOperationExecutingState;
+}
+
+- (BOOL)isFinished {
+    return self.state == AFOperationFinishedState;
+}
+
+- (BOOL)isConcurrent {
+    return YES;
+}
+
+- (void)start {
+    [self.lock lock];
+    if ([self isCancelled]) {
+        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
+    } else if ([self isReady]) {
+        self.state = AFOperationExecutingState;
+        
+        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
+    }
+    [self.lock unlock];
+}
+
+- (void)operationDidStart {
+    [self.lock lock];
+    if (![self isCancelled]) {
+        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
+        
+        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
+        for (NSString *runLoopMode in self.runLoopModes) {
+            [self.connection scheduleInRunLoop:runLoop forMode:runLoopMode];
+            [self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];
+        }
+        
+        [self.outputStream open];
+        [self.connection start];
+    }
+    [self.lock unlock];
+    
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:self];
+    });
+}
+
+- (void)finish {
+    [self.lock lock];
+    self.state = AFOperationFinishedState;
+    [self.lock unlock];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:self];
+    });
+}
+
+- (void)cancel {
+    [self.lock lock];
+    if (![self isFinished] && ![self isCancelled]) {
+        [super cancel];
+
+        if ([self isExecuting]) {
+            [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
+        }
+    }
+    [self.lock unlock];
+}
+
+- (void)cancelConnection {
+    NSDictionary *userInfo = nil;
+    if ([self.request URL]) {
+        userInfo = [NSDictionary dictionaryWithObject:[self.request URL] forKey:NSURLErrorFailingURLErrorKey];
+    }
+    NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorCancelled userInfo:userInfo];
+
+    if (![self isFinished]) {
+        if (self.connection) {
+            [self.connection cancel];
+            [self performSelector:@selector(connection:didFailWithError:) withObject:self.connection withObject:error];
+        } else {
+            // Accomodate race condition where `self.connection` has not yet been set before cancellation
+            self.error = error;
+            [self finish];
+        }
+    }
+}
+
+#pragma mark -
+
++ (NSArray *)batchOfRequestOperations:(NSArray *)operations
+                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
+                      completionBlock:(void (^)(NSArray *operations))completionBlock
+{
+    if (!operations || [operations count] == 0) {
+        return @[[NSBlockOperation blockOperationWithBlock:^{
+            dispatch_async(dispatch_get_main_queue(), ^{
+                if (completionBlock) {
+                    completionBlock(@[]);
+                }
+            });
+        }]];
+    }
+
+    __block dispatch_group_t group = dispatch_group_create();
+    NSBlockOperation *batchedOperation = [NSBlockOperation blockOperationWithBlock:^{
+        dispatch_group_notify(group, dispatch_get_main_queue(), ^{
+            if (completionBlock) {
+                completionBlock(operations);
+            }
+        });
+    }];
+
+    for (AFURLConnectionOperation *operation in operations) {
+        operation.completionGroup = group;
+        void (^originalCompletionBlock)(void) = [operation.completionBlock copy];
+        __weak __typeof(operation)weakOperation = operation;
+        operation.completionBlock = ^{
+            __strong __typeof(weakOperation)strongOperation = weakOperation;
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+            dispatch_queue_t queue = strongOperation.completionQueue ?: dispatch_get_main_queue();
+#pragma clang diagnostic pop
+            dispatch_group_async(group, queue, ^{
+                if (originalCompletionBlock) {
+                    originalCompletionBlock();
+                }
+
+                NSUInteger numberOfFinishedOperations = [[operations indexesOfObjectsPassingTest:^BOOL(id op, NSUInteger __unused idx,  BOOL __unused *stop) {
+                    return [op isFinished];
+                }] count];
+
+                if (progressBlock) {
+                    progressBlock(numberOfFinishedOperations, [operations count]);
+                }
+
+                dispatch_group_leave(group);
+            });
+        };
+
+        dispatch_group_enter(group);
+        [batchedOperation addDependency:operation];
+    }
+
+    return [operations arrayByAddingObject:batchedOperation];
+}
+
+#pragma mark - NSObject
+
+- (NSString *)description {
+    return [NSString stringWithFormat:@"<%@: %p, state: %@, cancelled: %@ request: %@, response: %@>", NSStringFromClass([self class]), self, AFKeyPathFromOperationState(self.state), ([self isCancelled] ? @"YES" : @"NO"), self.request, self.response];
+}
+
+#pragma mark - NSURLConnectionDelegate
+
+- (void)connection:(NSURLConnection *)connection
+willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
+{
+    if (self.authenticationChallenge) {
+        self.authenticationChallenge(connection, challenge);
+        return;
+    }
+
+    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
+        if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
+            NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
+            [[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];
+        } else {
+            [[challenge sender] cancelAuthenticationChallenge:challenge];
+        }
+    } else {
+        if ([challenge previousFailureCount] == 0) {
+            if (self.credential) {
+                [[challenge sender] useCredential:self.credential forAuthenticationChallenge:challenge];
+            } else {
+                [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];
+            }
+        } else {
+            [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];
+        }
+    }
+}
+
+- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection __unused *)connection {
+    return self.shouldUseCredentialStorage;
+}
+
+- (NSURLRequest *)connection:(NSURLConnection *)connection
+             willSendRequest:(NSURLRequest *)request
+            redirectResponse:(NSURLResponse *)redirectResponse
+{
+    if (self.redirectResponse) {
+        return self.redirectResponse(connection, request, redirectResponse);
+    } else {
+        return request;
+    }
+}
+
+- (void)connection:(NSURLConnection __unused *)connection
+   didSendBodyData:(NSInteger)bytesWritten
+ totalBytesWritten:(NSInteger)totalBytesWritten
+totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite
+{
+    dispatch_async(dispatch_get_main_queue(), ^{
+        if (self.uploadProgress) {
+            self.uploadProgress((NSUInteger)bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
+        }
+    });
+}
+
+- (void)connection:(NSURLConnection __unused *)connection
+didReceiveResponse:(NSURLResponse *)response
+{
+    self.response = response;
+}
+
+- (void)connection:(NSURLConnection __unused *)connection
+    didReceiveData:(NSData *)data
+{
+    NSUInteger length = [data length];
+    while (YES) {
+        NSInteger totalNumberOfBytesWritten = 0;
+        if ([self.outputStream hasSpaceAvailable]) {
+            const uint8_t *dataBuffer = (uint8_t *)[data bytes];
+
+            NSInteger numberOfBytesWritten = 0;
+            while (totalNumberOfBytesWritten < (NSInteger)length) {
+                numberOfBytesWritten = [self.outputStream write:&dataBuffer[(NSUInteger)totalNumberOfBytesWritten] maxLength:(length - (NSUInteger)totalNumberOfBytesWritten)];
+                if (numberOfBytesWritten == -1) {
+                    break;
+                }
+                
+                totalNumberOfBytesWritten += numberOfBytesWritten;
+            }
+
+            break;
+        }
+        
+        if (self.outputStream.streamError) {
+            [self.connection cancel];
+            [self performSelector:@selector(connection:didFailWithError:) withObject:self.connection withObject:self.outputStream.streamError];
+            return;
+        }
+    }
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+        self.totalBytesRead += (long long)length;
+
+        if (self.downloadProgress) {
+            self.downloadProgress(length, self.totalBytesRead, self.response.expectedContentLength);
+        }
+    });
+}
+
+- (void)connectionDidFinishLoading:(NSURLConnection __unused *)connection {
+    self.responseData = [self.outputStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey];
+
+    [self.outputStream close];
+    if (self.responseData) {
+       self.outputStream = nil;
+    }
+
+    self.connection = nil;
+
+    [self finish];
+}
+
+- (void)connection:(NSURLConnection __unused *)connection
+  didFailWithError:(NSError *)error
+{
+    self.error = error;
+
+    [self.outputStream close];
+    if (self.responseData) {
+        self.outputStream = nil;
+    }
+
+    self.connection = nil;
+
+    [self finish];
+}
+
+- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
+                  willCacheResponse:(NSCachedURLResponse *)cachedResponse
+{
+    if (self.cacheResponse) {
+        return self.cacheResponse(connection, cachedResponse);
+    } else {
+        if ([self isCancelled]) {
+            return nil;
+        }
+        
+        return cachedResponse;
+    }
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    NSURLRequest *request = [decoder decodeObjectOfClass:[NSURLRequest class] forKey:NSStringFromSelector(@selector(request))];
+    
+    self = [self initWithRequest:request];
+    if (!self) {
+        return nil;
+    }
+
+    self.state = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(state))] integerValue];
+    self.response = [decoder decodeObjectOfClass:[NSHTTPURLResponse class] forKey:NSStringFromSelector(@selector(response))];
+    self.error = [decoder decodeObjectOfClass:[NSError class] forKey:NSStringFromSelector(@selector(error))];
+    self.responseData = [decoder decodeObjectOfClass:[NSData class] forKey:NSStringFromSelector(@selector(responseData))];
+    self.totalBytesRead = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(totalBytesRead))] longLongValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [self pause];
+    
+    [coder encodeObject:self.request forKey:NSStringFromSelector(@selector(request))];
+    
+    switch (self.state) {
+        case AFOperationExecutingState:
+        case AFOperationPausedState:
+            [coder encodeInteger:AFOperationReadyState forKey:NSStringFromSelector(@selector(state))];
+            break;
+        default:
+            [coder encodeInteger:self.state forKey:NSStringFromSelector(@selector(state))];
+            break;
+    }
+    
+    [coder encodeObject:self.response forKey:NSStringFromSelector(@selector(response))];
+    [coder encodeObject:self.error forKey:NSStringFromSelector(@selector(error))];
+    [coder encodeObject:self.responseData forKey:NSStringFromSelector(@selector(responseData))];
+    [coder encodeInt64:self.totalBytesRead forKey:NSStringFromSelector(@selector(totalBytesRead))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFURLConnectionOperation *operation = [(AFURLConnectionOperation *)[[self class] allocWithZone:zone] initWithRequest:self.request];
+    
+    operation.uploadProgress = self.uploadProgress;
+    operation.downloadProgress = self.downloadProgress;
+    operation.authenticationChallenge = self.authenticationChallenge;
+    operation.cacheResponse = self.cacheResponse;
+    operation.redirectResponse = self.redirectResponse;
+    operation.completionQueue = self.completionQueue;
+    operation.completionGroup = self.completionGroup;
+    
+    return operation;
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.h
new file mode 100644
index 00000000000..17a4e496280
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.h
@@ -0,0 +1,453 @@
+// AFSerialization.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <UIKit/UIKit.h>
+#endif
+
+/**
+ The `AFURLRequestSerialization` protocol is adopted by an object that encodes parameters for a specified HTTP requests. Request serializers may encode parameters as query strings, HTTP bodies, setting the appropriate HTTP header fields as necessary.
+
+ For example, a JSON request serializer may set the HTTP body of the request to a JSON representation, and set the `Content-Type` HTTP header field value to `application/json`.
+ */
+@protocol AFURLRequestSerialization <NSObject, NSSecureCoding, NSCopying>
+
+/**
+ Returns a request with the specified parameters encoded into a copy of the original request.
+
+ @param request The original request.
+ @param parameters The parameters to be encoded.
+ @param error The error that occurred while attempting to encode the request parameters.
+
+ @return A serialized request.
+ */
+- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
+                               withParameters:(id)parameters
+                                        error:(NSError * __autoreleasing *)error;
+
+@end
+
+#pragma mark -
+
+/**
+
+ */
+typedef NS_ENUM(NSUInteger, AFHTTPRequestQueryStringSerializationStyle) {
+    AFHTTPRequestQueryStringDefaultStyle = 0,
+};
+
+@protocol AFMultipartFormData;
+
+/**
+ `AFHTTPRequestSerializer` conforms to the `AFURLRequestSerialization` & `AFURLResponseSerialization` protocols, offering a concrete base implementation of query string / URL form-encoded parameter serialization and default request headers, as well as response status code and content type validation.
+
+ Any request or response serializer dealing with HTTP is encouraged to subclass `AFHTTPRequestSerializer` in order to ensure consistent default behavior.
+ */
+@interface AFHTTPRequestSerializer : NSObject <AFURLRequestSerialization>
+
+/**
+ The string encoding used to serialize parameters. `NSUTF8StringEncoding` by default.
+ */
+@property (nonatomic, assign) NSStringEncoding stringEncoding;
+
+/**
+ Whether created requests can use the devices cellular radio (if present). `YES` by default.
+ 
+ @see NSMutableURLRequest -setAllowsCellularAccess:
+ */
+@property (nonatomic, assign) BOOL allowsCellularAccess;
+
+/**
+ The cache policy of created requests. `NSURLRequestUseProtocolCachePolicy` by default.
+ 
+ @see NSMutableURLRequest -setCachePolicy:
+ */
+@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;
+
+/**
+ Whether created requests should use the default cookie handling. `YES` by default.
+ 
+ @see NSMutableURLRequest -setHTTPShouldHandleCookies:
+ */
+@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;
+
+/**
+ Whether created requests can continue transmitting data before receiving a response from an earlier transmission. `NO` by default
+ 
+ @see NSMutableURLRequest -setHTTPShouldUsePipelining:
+ */
+@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;
+
+/**
+ The network service type for created requests. `NSURLNetworkServiceTypeDefault` by default.
+ 
+ @see NSMutableURLRequest -setNetworkServiceType:
+ */
+@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;
+
+/**
+ The timeout interval, in seconds, for created requests. The default timeout interval is 60 seconds.
+ 
+ @see NSMutableURLRequest -setTimeoutInterval:
+ */
+@property (nonatomic, assign) NSTimeInterval timeoutInterval;
+
+///---------------------------------------
+/// @name Configuring HTTP Request Headers
+///---------------------------------------
+
+/**
+ Default HTTP header field values to be applied to serialized requests.
+ */
+@property (readonly, nonatomic, strong) NSDictionary *HTTPRequestHeaders;
+
+/**
+ Creates and returns a serializer with default configuration.
+ */
++ (instancetype)serializer;
+
+/**
+ Sets the value for the HTTP headers set in request objects made by the HTTP client. If `nil`, removes the existing value for that header.
+
+ @param field The HTTP header to set a default value for
+ @param value The value set as default for the specified header, or `nil`
+ */
+- (void)setValue:(NSString *)value
+forHTTPHeaderField:(NSString *)field;
+
+/**
+ Returns the value for the HTTP headers set in the request serializer.
+
+ @param field The HTTP header to retrieve the default value for
+ 
+ @return The value set as default for the specified header, or `nil`
+ */
+- (NSString *)valueForHTTPHeaderField:(NSString *)field;
+
+/**
+ Sets the "Authorization" HTTP header set in request objects made by the HTTP client to a basic authentication value with Base64-encoded username and password. This overwrites any existing value for this header.
+
+ @param username The HTTP basic auth username
+ @param password The HTTP basic auth password
+ */
+- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
+                                       password:(NSString *)password;
+
+/**
+ @deprecated This method has been deprecated. Use -setValue:forHTTPHeaderField: instead.
+ */
+- (void)setAuthorizationHeaderFieldWithToken:(NSString *)token DEPRECATED_ATTRIBUTE;
+
+
+/**
+ Clears any existing value for the "Authorization" HTTP header.
+ */
+- (void)clearAuthorizationHeader;
+
+///-------------------------------------------------------
+/// @name Configuring Query String Parameter Serialization
+///-------------------------------------------------------
+
+/**
+ HTTP methods for which serialized requests will encode parameters as a query string. `GET`, `HEAD`, and `DELETE` by default.
+ */
+@property (nonatomic, strong) NSSet *HTTPMethodsEncodingParametersInURI;
+
+/**
+ Set the method of query string serialization according to one of the pre-defined styles.
+
+ @param style The serialization style.
+
+ @see AFHTTPRequestQueryStringSerializationStyle
+ */
+- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;
+
+/**
+ Set the a custom method of query string serialization according to the specified block.
+
+ @param block A block that defines a process of encoding parameters into a query string. This block returns the query string and takes three arguments: the request, the parameters to encode, and the error that occurred when attempting to encode parameters for the given request.
+ */
+- (void)setQueryStringSerializationWithBlock:(NSString * (^)(NSURLRequest *request, NSDictionary *parameters, NSError * __autoreleasing *error))block;
+
+///-------------------------------
+/// @name Creating Request Objects
+///-------------------------------
+
+/**
+ @deprecated This method has been deprecated. Use -requestWithMethod:URLString:parameters:error: instead.
+ */
+- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
+                                 URLString:(NSString *)URLString
+                                parameters:(id)parameters DEPRECATED_ATTRIBUTE;
+
+/**
+ Creates an `NSMutableURLRequest` object with the specified HTTP method and URL string.
+
+ If the HTTP method is `GET`, `HEAD`, or `DELETE`, the parameters will be used to construct a url-encoded query string that is appended to the request's URL. Otherwise, the parameters will be encoded according to the value of the `parameterEncoding` property, and set as the request body.
+
+ @param method The HTTP method for the request, such as `GET`, `POST`, `PUT`, or `DELETE`. This parameter must not be `nil`.
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be either set as a query string for `GET` requests, or the request HTTP body.
+ @param error The error that occured while constructing the request.
+
+ @return An `NSMutableURLRequest` object.
+ */
+- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
+                                 URLString:(NSString *)URLString
+                                parameters:(id)parameters
+                                     error:(NSError * __autoreleasing *)error;
+
+/**
+ @deprecated This method has been deprecated. Use -multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:error: instead.
+ */
+- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method
+                                              URLString:(NSString *)URLString
+                                             parameters:(NSDictionary *)parameters
+                              constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block DEPRECATED_ATTRIBUTE;
+
+/**
+ Creates an `NSMutableURLRequest` object with the specified HTTP method and URLString, and constructs a `multipart/form-data` HTTP body, using the specified parameters and multipart form data block. See http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.2
+
+ Multipart form requests are automatically streamed, reading files directly from disk along with in-memory data in a single HTTP body. The resulting `NSMutableURLRequest` object has an `HTTPBodyStream` property, so refrain from setting `HTTPBodyStream` or `HTTPBody` on this request object, as it will clear out the multipart form body stream.
+
+ @param method The HTTP method for the request. This parameter must not be `GET` or `HEAD`, or `nil`.
+ @param URLString The URL string used to create the request URL.
+ @param parameters The parameters to be encoded and set in the request HTTP body.
+ @param block A block that takes a single argument and appends data to the HTTP body. The block argument is an object adopting the `AFMultipartFormData` protocol.
+ @param error The error that occured while constructing the request.
+
+ @return An `NSMutableURLRequest` object
+ */
+- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method
+                                              URLString:(NSString *)URLString
+                                             parameters:(NSDictionary *)parameters
+                              constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                                                  error:(NSError * __autoreleasing *)error;
+
+/**
+ Creates an `NSMutableURLRequest` by removing the `HTTPBodyStream` from a request, and asynchronously writing its contents into the specified file, invoking the completion handler when finished.
+ 
+ @param request The multipart form request.
+ @param fileURL The file URL to write multipart form contents to.
+ @param handler A handler block to execute.
+ 
+ @discussion There is a bug in `NSURLSessionTask` that causes requests to not send a `Content-Length` header when streaming contents from an HTTP body, which is notably problematic when interacting with the Amazon S3 webservice. As a workaround, this method takes a request constructed with `multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:error:`, or any other request with an `HTTPBodyStream`, writes the contents to the specified file and returns a copy of the original request with the `HTTPBodyStream` property set to `nil`. From here, the file can either be passed to `AFURLSessionManager -uploadTaskWithRequest:fromFile:progress:completionHandler:`, or have its contents read into an `NSData` that's assigned to the `HTTPBody` property of the request.
+
+ @see https://github.com/AFNetworking/AFNetworking/issues/1398
+ */
+- (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request
+                             writingStreamContentsToFile:(NSURL *)fileURL
+                                       completionHandler:(void (^)(NSError *error))handler;
+
+@end
+
+#pragma mark -
+
+/**
+ The `AFMultipartFormData` protocol defines the methods supported by the parameter in the block argument of `AFHTTPRequestSerializer -multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:`.
+ */
+@protocol AFMultipartFormData
+
+/**
+ Appends the HTTP header `Content-Disposition: file; filename=#{generated filename}; name=#{name}"` and `Content-Type: #{generated mimeType}`, followed by the encoded file data and the multipart form boundary.
+
+ The filename and MIME type for this data in the form will be automatically generated, using the last path component of the `fileURL` and system associated MIME type for the `fileURL` extension, respectively.
+
+ @param fileURL The URL corresponding to the file whose content will be appended to the form. This parameter must not be `nil`.
+ @param name The name to be associated with the specified data. This parameter must not be `nil`.
+ @param error If an error occurs, upon return contains an `NSError` object that describes the problem.
+
+ @return `YES` if the file data was successfully appended, otherwise `NO`.
+ */
+- (BOOL)appendPartWithFileURL:(NSURL *)fileURL
+                         name:(NSString *)name
+                        error:(NSError * __autoreleasing *)error;
+
+/**
+ Appends the HTTP header `Content-Disposition: file; filename=#{filename}; name=#{name}"` and `Content-Type: #{mimeType}`, followed by the encoded file data and the multipart form boundary.
+
+ @param fileURL The URL corresponding to the file whose content will be appended to the form. This parameter must not be `nil`.
+ @param name The name to be associated with the specified data. This parameter must not be `nil`.
+ @param fileName The file name to be used in the `Content-Disposition` header. This parameter must not be `nil`.
+ @param mimeType The declared MIME type of the file data. This parameter must not be `nil`.
+ @param error If an error occurs, upon return contains an `NSError` object that describes the problem.
+
+ @return `YES` if the file data was successfully appended otherwise `NO`.
+ */
+- (BOOL)appendPartWithFileURL:(NSURL *)fileURL
+                         name:(NSString *)name
+                     fileName:(NSString *)fileName
+                     mimeType:(NSString *)mimeType
+                        error:(NSError * __autoreleasing *)error;
+
+/**
+ Appends the HTTP header `Content-Disposition: file; filename=#{filename}; name=#{name}"` and `Content-Type: #{mimeType}`, followed by the data from the input stream and the multipart form boundary.
+
+ @param inputStream The input stream to be appended to the form data
+ @param name The name to be associated with the specified input stream. This parameter must not be `nil`.
+ @param fileName The filename to be associated with the specified input stream. This parameter must not be `nil`.
+ @param length The length of the specified input stream in bytes.
+ @param mimeType The MIME type of the specified data. (For example, the MIME type for a JPEG image is image/jpeg.) For a list of valid MIME types, see http://www.iana.org/assignments/media-types/. This parameter must not be `nil`.
+ */
+- (void)appendPartWithInputStream:(NSInputStream *)inputStream
+                             name:(NSString *)name
+                         fileName:(NSString *)fileName
+                           length:(int64_t)length
+                         mimeType:(NSString *)mimeType;
+
+/**
+ Appends the HTTP header `Content-Disposition: file; filename=#{filename}; name=#{name}"` and `Content-Type: #{mimeType}`, followed by the encoded file data and the multipart form boundary.
+
+ @param data The data to be encoded and appended to the form data.
+ @param name The name to be associated with the specified data. This parameter must not be `nil`.
+ @param fileName The filename to be associated with the specified data. This parameter must not be `nil`.
+ @param mimeType The MIME type of the specified data. (For example, the MIME type for a JPEG image is image/jpeg.) For a list of valid MIME types, see http://www.iana.org/assignments/media-types/. This parameter must not be `nil`.
+ */
+- (void)appendPartWithFileData:(NSData *)data
+                          name:(NSString *)name
+                      fileName:(NSString *)fileName
+                      mimeType:(NSString *)mimeType;
+
+/**
+ Appends the HTTP headers `Content-Disposition: form-data; name=#{name}"`, followed by the encoded data and the multipart form boundary.
+
+ @param data The data to be encoded and appended to the form data.
+ @param name The name to be associated with the specified data. This parameter must not be `nil`.
+ */
+
+- (void)appendPartWithFormData:(NSData *)data
+                          name:(NSString *)name;
+
+
+/**
+ Appends HTTP headers, followed by the encoded data and the multipart form boundary.
+
+ @param headers The HTTP headers to be appended to the form data.
+ @param body The data to be encoded and appended to the form data. This parameter must not be `nil`.
+ */
+- (void)appendPartWithHeaders:(NSDictionary *)headers
+                         body:(NSData *)body;
+
+/**
+ Throttles request bandwidth by limiting the packet size and adding a delay for each chunk read from the upload stream.
+
+ When uploading over a 3G or EDGE connection, requests may fail with "request body stream exhausted". Setting a maximum packet size and delay according to the recommended values (`kAFUploadStream3GSuggestedPacketSize` and `kAFUploadStream3GSuggestedDelay`) lowers the risk of the input stream exceeding its allocated bandwidth. Unfortunately, there is no definite way to distinguish between a 3G, EDGE, or LTE connection over `NSURLConnection`. As such, it is not recommended that you throttle bandwidth based solely on network reachability. Instead, you should consider checking for the "request body stream exhausted" in a failure block, and then retrying the request with throttled bandwidth.
+
+ @param numberOfBytes Maximum packet size, in number of bytes. The default packet size for an input stream is 16kb.
+ @param delay Duration of delay each time a packet is read. By default, no delay is set.
+ */
+- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes
+                                  delay:(NSTimeInterval)delay;
+
+@end
+
+#pragma mark -
+
+@interface AFJSONRequestSerializer : AFHTTPRequestSerializer
+
+/**
+ Options for writing the request JSON data from Foundation objects. For possible values, see the `NSJSONSerialization` documentation section "NSJSONWritingOptions". `0` by default.
+ */
+@property (nonatomic, assign) NSJSONWritingOptions writingOptions;
+
+/**
+ Creates and returns a JSON serializer with specified reading and writing options.
+
+ @param writingOptions The specified JSON writing options.
+ */
++ (instancetype)serializerWithWritingOptions:(NSJSONWritingOptions)writingOptions;
+
+@end
+
+@interface AFPropertyListRequestSerializer : AFHTTPRequestSerializer
+
+/**
+ The property list format. Possible values are described in "NSPropertyListFormat".
+ */
+@property (nonatomic, assign) NSPropertyListFormat format;
+
+/**
+ @warning The `writeOptions` property is currently unused.
+ */
+@property (nonatomic, assign) NSPropertyListWriteOptions writeOptions;
+
+/**
+ Creates and returns a property list serializer with a specified format, read options, and write options.
+
+ @param format The property list format.
+ @param writeOptions The property list write options.
+ 
+ @warning The `writeOptions` property is currently unused.
+ */
++ (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+                        writeOptions:(NSPropertyListWriteOptions)writeOptions;
+
+@end
+
+///----------------
+/// @name Constants
+///----------------
+
+/**
+ ## Error Domains
+
+ The following error domain is predefined.
+
+ - `NSString * const AFURLRequestSerializationErrorDomain`
+
+ ### Constants
+
+ `AFURLRequestSerializationErrorDomain`
+ AFURLRequestSerializer errors. Error codes for `AFURLRequestSerializationErrorDomain` correspond to codes in `NSURLErrorDomain`.
+ */
+extern NSString * const AFURLRequestSerializationErrorDomain;
+
+/**
+ ## User info dictionary keys
+
+ These keys may exist in the user info dictionary, in addition to those defined for NSError.
+
+ - `NSString * const AFNetworkingOperationFailingURLResponseErrorKey`
+
+ ### Constants
+
+ `AFNetworkingOperationFailingURLRequestErrorKey`
+ The corresponding value is an `NSURLRequest` containing the request of the operation associated with an error. This key is only present in the `AFURLRequestSerializationErrorDomain`.
+ */
+extern NSString * const AFNetworkingOperationFailingURLRequestErrorKey;
+
+/**
+ ## Throttling Bandwidth for HTTP Request Input Streams
+
+ @see -throttleBandwidthWithPacketSize:delay:
+
+ ### Constants
+
+ `kAFUploadStream3GSuggestedPacketSize`
+ Maximum packet size, in number of bytes. Equal to 16kb.
+
+ `kAFUploadStream3GSuggestedDelay`
+ Duration of delay each time a packet is read. Equal to 0.2 seconds.
+ */
+extern NSUInteger const kAFUploadStream3GSuggestedPacketSize;
+extern NSTimeInterval const kAFUploadStream3GSuggestedDelay;
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.m
new file mode 100644
index 00000000000..aea41d9bf59
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization.m
@@ -0,0 +1,1335 @@
+// AFSerialization.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFURLRequestSerialization.h"
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED
+#import <MobileCoreServices/MobileCoreServices.h>
+#else
+#import <CoreServices/CoreServices.h>
+#endif
+
+NSString * const AFURLRequestSerializationErrorDomain = @"com.alamofire.error.serialization.request";
+NSString * const AFNetworkingOperationFailingURLRequestErrorKey = @"com.alamofire.serialization.request.error.response";
+
+typedef NSString * (^AFQueryStringSerializationBlock)(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error);
+
+static NSString * AFBase64EncodedStringFromString(NSString *string) {
+    NSData *data = [NSData dataWithBytes:[string UTF8String] length:[string lengthOfBytesUsingEncoding:NSUTF8StringEncoding]];
+    NSUInteger length = [data length];
+    NSMutableData *mutableData = [NSMutableData dataWithLength:((length + 2) / 3) * 4];
+
+    uint8_t *input = (uint8_t *)[data bytes];
+    uint8_t *output = (uint8_t *)[mutableData mutableBytes];
+
+    for (NSUInteger i = 0; i < length; i += 3) {
+        NSUInteger value = 0;
+        for (NSUInteger j = i; j < (i + 3); j++) {
+            value <<= 8;
+            if (j < length) {
+                value |= (0xFF & input[j]);
+            }
+        }
+
+        static uint8_t const kAFBase64EncodingTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+        NSUInteger idx = (i / 3) * 4;
+        output[idx + 0] = kAFBase64EncodingTable[(value >> 18) & 0x3F];
+        output[idx + 1] = kAFBase64EncodingTable[(value >> 12) & 0x3F];
+        output[idx + 2] = (i + 1) < length ? kAFBase64EncodingTable[(value >> 6)  & 0x3F] : '=';
+        output[idx + 3] = (i + 2) < length ? kAFBase64EncodingTable[(value >> 0)  & 0x3F] : '=';
+    }
+
+    return [[NSString alloc] initWithData:mutableData encoding:NSASCIIStringEncoding];
+}
+
+static NSString * const kAFCharactersToBeEscapedInQueryString = @":/?&=;+!@#$()',*";
+
+static NSString * AFPercentEscapedQueryStringKeyFromStringWithEncoding(NSString *string, NSStringEncoding encoding) {
+    static NSString * const kAFCharactersToLeaveUnescapedInQueryStringPairKey = @"[].";
+
+	return (__bridge_transfer  NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge CFStringRef)string, (__bridge CFStringRef)kAFCharactersToLeaveUnescapedInQueryStringPairKey, (__bridge CFStringRef)kAFCharactersToBeEscapedInQueryString, CFStringConvertNSStringEncodingToEncoding(encoding));
+}
+
+static NSString * AFPercentEscapedQueryStringValueFromStringWithEncoding(NSString *string, NSStringEncoding encoding) {
+	return (__bridge_transfer  NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge CFStringRef)string, NULL, (__bridge CFStringRef)kAFCharactersToBeEscapedInQueryString, CFStringConvertNSStringEncodingToEncoding(encoding));
+}
+
+#pragma mark -
+
+@interface AFQueryStringPair : NSObject
+@property (readwrite, nonatomic, strong) id field;
+@property (readwrite, nonatomic, strong) id value;
+
+- (id)initWithField:(id)field value:(id)value;
+
+- (NSString *)URLEncodedStringValueWithEncoding:(NSStringEncoding)stringEncoding;
+@end
+
+@implementation AFQueryStringPair
+
+- (id)initWithField:(id)field value:(id)value {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.field = field;
+    self.value = value;
+
+    return self;
+}
+
+- (NSString *)URLEncodedStringValueWithEncoding:(NSStringEncoding)stringEncoding {
+    if (!self.value || [self.value isEqual:[NSNull null]]) {
+        return AFPercentEscapedQueryStringKeyFromStringWithEncoding([self.field description], stringEncoding);
+    } else {
+        return [NSString stringWithFormat:@"%@=%@", AFPercentEscapedQueryStringKeyFromStringWithEncoding([self.field description], stringEncoding), AFPercentEscapedQueryStringValueFromStringWithEncoding([self.value description], stringEncoding)];
+    }
+}
+
+@end
+
+#pragma mark -
+
+extern NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary);
+extern NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value);
+
+static NSString * AFQueryStringFromParametersWithEncoding(NSDictionary *parameters, NSStringEncoding stringEncoding) {
+    NSMutableArray *mutablePairs = [NSMutableArray array];
+    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {
+        [mutablePairs addObject:[pair URLEncodedStringValueWithEncoding:stringEncoding]];
+    }
+
+    return [mutablePairs componentsJoinedByString:@"&"];
+}
+
+NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) {
+    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);
+}
+
+NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) {
+    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];
+
+    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"description" ascending:YES selector:@selector(compare:)];
+
+    if ([value isKindOfClass:[NSDictionary class]]) {
+        NSDictionary *dictionary = value;
+        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries
+        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
+            id nestedValue = [dictionary objectForKey:nestedKey];
+            if (nestedValue) {
+                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@"%@[%@]", key, nestedKey] : nestedKey), nestedValue)];
+            }
+        }
+    } else if ([value isKindOfClass:[NSArray class]]) {
+        NSArray *array = value;
+        for (id nestedValue in array) {
+            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@"%@[]", key], nestedValue)];
+        }
+    } else if ([value isKindOfClass:[NSSet class]]) {
+        NSSet *set = value;
+        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
+            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];
+        }
+    } else {
+        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];
+    }
+    
+    return mutableQueryStringComponents;
+}
+
+#pragma mark -
+
+@interface AFStreamingMultipartFormData : NSObject <AFMultipartFormData>
+- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest
+                    stringEncoding:(NSStringEncoding)encoding;
+
+- (NSMutableURLRequest *)requestByFinalizingMultipartFormData;
+@end
+
+#pragma mark -
+
+static NSArray * AFHTTPRequestSerializerObservedKeyPaths() {
+    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];
+    });
+
+    return _AFHTTPRequestSerializerObservedKeyPaths;
+}
+
+static void *AFHTTPRequestSerializerObserverContext = &AFHTTPRequestSerializerObserverContext;
+
+@interface AFHTTPRequestSerializer ()
+@property (readwrite, nonatomic, strong) NSMutableSet *mutableObservedChangedKeyPaths;
+@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableHTTPRequestHeaders;
+@property (readwrite, nonatomic, assign) AFHTTPRequestQueryStringSerializationStyle queryStringSerializationStyle;
+@property (readwrite, nonatomic, copy) AFQueryStringSerializationBlock queryStringSerialization;
+@end
+
+@implementation AFHTTPRequestSerializer
+
++ (instancetype)serializer {
+    return [[self alloc] init];
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.stringEncoding = NSUTF8StringEncoding;
+
+    self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary];
+
+    // Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4
+    NSMutableArray *acceptLanguagesComponents = [NSMutableArray array];
+    [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
+        float q = 1.0f - (idx * 0.1f);
+        [acceptLanguagesComponents addObject:[NSString stringWithFormat:@"%@;q=%0.1g", obj, q]];
+        *stop = q <= 0.5f;
+    }];
+    [self setValue:[acceptLanguagesComponents componentsJoinedByString:@", "] forHTTPHeaderField:@"Accept-Language"];
+
+    NSString *userAgent = nil;
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43
+    userAgent = [NSString stringWithFormat:@"%@/%@ (%@; iOS %@; Scale/%0.2f)", [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleExecutableKey] ?: [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleIdentifierKey], (__bridge id)CFBundleGetValueForInfoDictionaryKey(CFBundleGetMainBundle(), kCFBundleVersionKey) ?: [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];
+#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+    userAgent = [NSString stringWithFormat:@"%@/%@ (Mac OS X %@)", [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleExecutableKey] ?: [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleIdentifierKey], [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"] ?: [[[NSBundle mainBundle] infoDictionary] objectForKey:(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];
+#endif
+#pragma clang diagnostic pop
+    if (userAgent) {
+        if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) {
+            NSMutableString *mutableUserAgent = [userAgent mutableCopy];
+            if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove", false)) {
+                userAgent = mutableUserAgent;
+            }
+        }
+        [self setValue:userAgent forHTTPHeaderField:@"User-Agent"];
+    }
+
+    // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
+    self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@"GET", @"HEAD", @"DELETE", nil];
+
+    self.mutableObservedChangedKeyPaths = [NSMutableSet set];
+    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
+        [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];
+    }
+
+    return self;
+}
+
+- (void)dealloc {
+    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
+        [self removeObserver:self forKeyPath:keyPath context:AFHTTPRequestSerializerObserverContext];
+    }
+}
+
+#pragma mark -
+
+- (NSDictionary *)HTTPRequestHeaders {
+    return [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];
+}
+
+- (void)setValue:(NSString *)value
+forHTTPHeaderField:(NSString *)field
+{
+	[self.mutableHTTPRequestHeaders setValue:value forKey:field];
+}
+
+- (NSString *)valueForHTTPHeaderField:(NSString *)field {
+    return [self.mutableHTTPRequestHeaders valueForKey:field];
+}
+
+- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
+                                       password:(NSString *)password
+{
+	NSString *basicAuthCredentials = [NSString stringWithFormat:@"%@:%@", username, password];
+    [self setValue:[NSString stringWithFormat:@"Basic %@", AFBase64EncodedStringFromString(basicAuthCredentials)] forHTTPHeaderField:@"Authorization"];
+}
+
+- (void)setAuthorizationHeaderFieldWithToken:(NSString *)token {
+    [self setValue:[NSString stringWithFormat:@"Token token=\"%@\"", token] forHTTPHeaderField:@"Authorization"];
+}
+
+- (void)clearAuthorizationHeader {
+	[self.mutableHTTPRequestHeaders removeObjectForKey:@"Authorization"];
+}
+
+#pragma mark -
+
+- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style {
+    self.queryStringSerializationStyle = style;
+    self.queryStringSerialization = nil;
+}
+
+- (void)setQueryStringSerializationWithBlock:(NSString *(^)(NSURLRequest *, NSDictionary *, NSError *__autoreleasing *))block {
+    self.queryStringSerialization = block;
+}
+
+#pragma mark -
+
+- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
+                                 URLString:(NSString *)URLString
+                                parameters:(id)parameters
+{
+    return [self requestWithMethod:method URLString:URLString parameters:parameters error:nil];
+}
+
+- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
+                                 URLString:(NSString *)URLString
+                                parameters:(id)parameters
+                                     error:(NSError *__autoreleasing *)error
+{
+    NSParameterAssert(method);
+    NSParameterAssert(URLString);
+
+    NSURL *url = [NSURL URLWithString:URLString];
+
+    NSParameterAssert(url);
+
+    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
+    mutableRequest.HTTPMethod = method;
+
+    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
+        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
+            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
+        }
+    }
+
+    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];
+
+	return mutableRequest;
+}
+
+- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method
+                                              URLString:(NSString *)URLString
+                                             parameters:(NSDictionary *)parameters
+                              constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+{
+    return [self multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:nil];
+}
+
+- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method
+                                              URLString:(NSString *)URLString
+                                             parameters:(NSDictionary *)parameters
+                              constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block
+                                                  error:(NSError *__autoreleasing *)error
+{
+    NSParameterAssert(method);
+    NSParameterAssert(![method isEqualToString:@"GET"] && ![method isEqualToString:@"HEAD"]);
+
+    NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error];
+
+    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding];
+
+    if (parameters) {
+        for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {
+            NSData *data = nil;
+            if ([pair.value isKindOfClass:[NSData class]]) {
+                data = pair.value;
+            } else if ([pair.value isEqual:[NSNull null]]) {
+                data = [NSData data];
+            } else {
+                data = [[pair.value description] dataUsingEncoding:self.stringEncoding];
+            }
+
+            if (data) {
+                [formData appendPartWithFormData:data name:[pair.field description]];
+            }
+        }
+    }
+
+    if (block) {
+        block(formData);
+    }
+
+    return [formData requestByFinalizingMultipartFormData];
+}
+
+- (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request
+                             writingStreamContentsToFile:(NSURL *)fileURL
+                                       completionHandler:(void (^)(NSError *error))handler
+{
+    if (!request.HTTPBodyStream) {
+        return [request mutableCopy];
+    }
+
+    NSParameterAssert([fileURL isFileURL]);
+
+    NSInputStream *inputStream = request.HTTPBodyStream;
+    NSOutputStream *outputStream = [[NSOutputStream alloc] initWithURL:fileURL append:NO];
+    __block NSError *error = nil;
+
+    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
+        [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+        [outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+
+        [inputStream open];
+        [outputStream open];
+
+        while ([inputStream hasBytesAvailable] && [outputStream hasSpaceAvailable]) {
+            uint8_t buffer[1024];
+
+            NSInteger bytesRead = [inputStream read:buffer maxLength:1024];
+            if (inputStream.streamError || bytesRead < 0) {
+                error = inputStream.streamError;
+                break;
+            }
+
+            NSInteger bytesWritten = [outputStream write:buffer maxLength:(NSUInteger)bytesRead];
+            if (outputStream.streamError || bytesWritten < 0) {
+                error = outputStream.streamError;
+                break;
+            }
+
+            if (bytesRead == 0 && bytesWritten == 0) {
+                break;
+            }
+        }
+
+        [outputStream close];
+        [inputStream close];
+
+        if (handler) {
+            dispatch_async(dispatch_get_main_queue(), ^{
+                handler(error);
+            });
+        }
+    });
+
+    NSMutableURLRequest *mutableRequest = [request mutableCopy];
+    mutableRequest.HTTPBodyStream = nil;
+
+    return mutableRequest;
+}
+
+#pragma mark - AFURLRequestSerialization
+
+- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
+                               withParameters:(id)parameters
+                                        error:(NSError *__autoreleasing *)error
+{
+    NSParameterAssert(request);
+
+    NSMutableURLRequest *mutableRequest = [request mutableCopy];
+
+    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
+        if (![request valueForHTTPHeaderField:field]) {
+            [mutableRequest setValue:value forHTTPHeaderField:field];
+        }
+    }];
+
+    if (parameters) {
+        NSString *query = nil;
+        if (self.queryStringSerialization) {
+            NSError *serializationError;
+            query = self.queryStringSerialization(request, parameters, &serializationError);
+
+            if (serializationError) {
+                if (error) {
+                    *error = serializationError;
+                }
+
+                return nil;
+            }
+        } else {
+            switch (self.queryStringSerializationStyle) {
+                case AFHTTPRequestQueryStringDefaultStyle:
+                    query = AFQueryStringFromParametersWithEncoding(parameters, self.stringEncoding);
+                    break;
+            }
+        }
+
+        if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
+            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&%@" : @"?%@", query]];
+        } else {
+            if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) {
+                [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
+            }
+            [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
+        }
+    }
+
+    return mutableRequest;
+}
+
+#pragma mark - NSKeyValueObserving
+
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(__unused id)object
+                        change:(NSDictionary *)change
+                       context:(void *)context
+{
+    if (context == AFHTTPRequestSerializerObserverContext) {
+        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) {
+            [self.mutableObservedChangedKeyPaths removeObject:keyPath];
+        } else {
+            [self.mutableObservedChangedKeyPaths addObject:keyPath];
+        }
+    }
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [self init];
+    if (!self) {
+        return nil;
+    }
+
+    self.mutableHTTPRequestHeaders = [[decoder decodeObjectOfClass:[NSDictionary class] forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))] mutableCopy];
+    self.queryStringSerializationStyle = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))] unsignedIntegerValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [coder encodeObject:self.mutableHTTPRequestHeaders forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))];
+    [coder encodeInteger:self.queryStringSerializationStyle forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPRequestSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.mutableHTTPRequestHeaders = [self.mutableHTTPRequestHeaders mutableCopyWithZone:zone];
+    serializer.queryStringSerializationStyle = self.queryStringSerializationStyle;
+    serializer.queryStringSerialization = self.queryStringSerialization;
+    
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+static NSString * AFCreateMultipartFormBoundary() {
+    return [NSString stringWithFormat:@"Boundary+%08X%08X", arc4random(), arc4random()];
+}
+
+static NSString * const kAFMultipartFormCRLF = @"\r\n";
+
+static inline NSString * AFMultipartFormInitialBoundary(NSString *boundary) {
+    return [NSString stringWithFormat:@"--%@%@", boundary, kAFMultipartFormCRLF];
+}
+
+static inline NSString * AFMultipartFormEncapsulationBoundary(NSString *boundary) {
+    return [NSString stringWithFormat:@"%@--%@%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];
+}
+
+static inline NSString * AFMultipartFormFinalBoundary(NSString *boundary) {
+    return [NSString stringWithFormat:@"%@--%@--%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];
+}
+
+static inline NSString * AFContentTypeForPathExtension(NSString *extension) {
+#ifdef __UTTYPE__
+    NSString *UTI = (__bridge_transfer NSString *)UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)extension, NULL);
+    NSString *contentType = (__bridge_transfer NSString *)UTTypeCopyPreferredTagWithClass((__bridge CFStringRef)UTI, kUTTagClassMIMEType);
+    if (!contentType) {
+        return @"application/octet-stream";
+    } else {
+        return contentType;
+    }
+#else
+#pragma unused (extension)
+    return @"application/octet-stream";
+#endif
+}
+
+NSUInteger const kAFUploadStream3GSuggestedPacketSize = 1024 * 16;
+NSTimeInterval const kAFUploadStream3GSuggestedDelay = 0.2;
+
+@interface AFHTTPBodyPart : NSObject
+@property (nonatomic, assign) NSStringEncoding stringEncoding;
+@property (nonatomic, strong) NSDictionary *headers;
+@property (nonatomic, copy) NSString *boundary;
+@property (nonatomic, strong) id body;
+@property (nonatomic, assign) unsigned long long bodyContentLength;
+@property (nonatomic, strong) NSInputStream *inputStream;
+
+@property (nonatomic, assign) BOOL hasInitialBoundary;
+@property (nonatomic, assign) BOOL hasFinalBoundary;
+
+@property (readonly, nonatomic, assign, getter = hasBytesAvailable) BOOL bytesAvailable;
+@property (readonly, nonatomic, assign) unsigned long long contentLength;
+
+- (NSInteger)read:(uint8_t *)buffer
+        maxLength:(NSUInteger)length;
+@end
+
+@interface AFMultipartBodyStream : NSInputStream <NSStreamDelegate>
+@property (nonatomic, assign) NSUInteger numberOfBytesInPacket;
+@property (nonatomic, assign) NSTimeInterval delay;
+@property (nonatomic, strong) NSInputStream *inputStream;
+@property (readonly, nonatomic, assign) unsigned long long contentLength;
+@property (readonly, nonatomic, assign, getter = isEmpty) BOOL empty;
+
+- (id)initWithStringEncoding:(NSStringEncoding)encoding;
+- (void)setInitialAndFinalBoundaries;
+- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart;
+@end
+
+#pragma mark -
+
+@interface AFStreamingMultipartFormData ()
+@property (readwrite, nonatomic, copy) NSMutableURLRequest *request;
+@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;
+@property (readwrite, nonatomic, copy) NSString *boundary;
+@property (readwrite, nonatomic, strong) AFMultipartBodyStream *bodyStream;
+@end
+
+@implementation AFStreamingMultipartFormData
+
+- (id)initWithURLRequest:(NSMutableURLRequest *)urlRequest
+          stringEncoding:(NSStringEncoding)encoding
+{
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.request = urlRequest;
+    self.stringEncoding = encoding;
+    self.boundary = AFCreateMultipartFormBoundary();
+    self.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding];
+
+    return self;
+}
+
+- (BOOL)appendPartWithFileURL:(NSURL *)fileURL
+                         name:(NSString *)name
+                        error:(NSError * __autoreleasing *)error
+{
+    NSParameterAssert(fileURL);
+    NSParameterAssert(name);
+
+    NSString *fileName = [fileURL lastPathComponent];
+    NSString *mimeType = AFContentTypeForPathExtension([fileURL pathExtension]);
+
+    return [self appendPartWithFileURL:fileURL name:name fileName:fileName mimeType:mimeType error:error];
+}
+
+- (BOOL)appendPartWithFileURL:(NSURL *)fileURL
+                         name:(NSString *)name
+                     fileName:(NSString *)fileName
+                     mimeType:(NSString *)mimeType
+                        error:(NSError * __autoreleasing *)error
+{
+    NSParameterAssert(fileURL);
+    NSParameterAssert(name);
+    NSParameterAssert(fileName);
+    NSParameterAssert(mimeType);
+
+    if (![fileURL isFileURL]) {
+        NSDictionary *userInfo = @{NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@"Expected URL to be a file URL", @"AFNetworking", nil)};
+        if (error) {
+            *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo];
+        }
+
+        return NO;
+    } else if ([fileURL checkResourceIsReachableAndReturnError:error] == NO) {
+        NSDictionary *userInfo = @{NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@"File URL not reachable.", @"AFNetworking", nil)};
+        if (error) {
+            *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo];
+        }
+
+        return NO;
+    }
+
+    NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[fileURL path] error:error];
+    if (!fileAttributes) {
+        return NO;
+    }
+    
+    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];
+    [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"];
+    [mutableHeaders setValue:mimeType forKey:@"Content-Type"];
+    
+    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];
+    bodyPart.stringEncoding = self.stringEncoding;
+    bodyPart.headers = mutableHeaders;
+    bodyPart.boundary = self.boundary;
+    bodyPart.body = fileURL;
+    bodyPart.bodyContentLength = [[fileAttributes objectForKey:NSFileSize] unsignedLongLongValue];
+    [self.bodyStream appendHTTPBodyPart:bodyPart];
+
+    return YES;
+}
+
+- (void)appendPartWithInputStream:(NSInputStream *)inputStream
+                             name:(NSString *)name
+                         fileName:(NSString *)fileName
+                           length:(int64_t)length
+                         mimeType:(NSString *)mimeType
+{
+    NSParameterAssert(name);
+    NSParameterAssert(fileName);
+    NSParameterAssert(mimeType);
+
+    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];
+    [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"];
+    [mutableHeaders setValue:mimeType forKey:@"Content-Type"];
+
+    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];
+    bodyPart.stringEncoding = self.stringEncoding;
+    bodyPart.headers = mutableHeaders;
+    bodyPart.boundary = self.boundary;
+    bodyPart.body = inputStream;
+
+    bodyPart.bodyContentLength = (unsigned long long)length;
+
+    [self.bodyStream appendHTTPBodyPart:bodyPart];
+}
+
+- (void)appendPartWithFileData:(NSData *)data
+                          name:(NSString *)name
+                      fileName:(NSString *)fileName
+                      mimeType:(NSString *)mimeType
+{
+    NSParameterAssert(name);
+    NSParameterAssert(fileName);
+    NSParameterAssert(mimeType);
+
+    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];
+    [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"];
+    [mutableHeaders setValue:mimeType forKey:@"Content-Type"];
+
+    [self appendPartWithHeaders:mutableHeaders body:data];
+}
+
+- (void)appendPartWithFormData:(NSData *)data
+                          name:(NSString *)name
+{
+    NSParameterAssert(name);
+
+    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];
+    [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"", name] forKey:@"Content-Disposition"];
+
+    [self appendPartWithHeaders:mutableHeaders body:data];
+}
+
+- (void)appendPartWithHeaders:(NSDictionary *)headers
+                         body:(NSData *)body
+{
+    NSParameterAssert(body);
+
+    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];
+    bodyPart.stringEncoding = self.stringEncoding;
+    bodyPart.headers = headers;
+    bodyPart.boundary = self.boundary;
+    bodyPart.bodyContentLength = [body length];
+    bodyPart.body = body;
+
+    [self.bodyStream appendHTTPBodyPart:bodyPart];
+}
+
+- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes
+                                  delay:(NSTimeInterval)delay
+{
+    self.bodyStream.numberOfBytesInPacket = numberOfBytes;
+    self.bodyStream.delay = delay;
+}
+
+- (NSMutableURLRequest *)requestByFinalizingMultipartFormData {
+    if ([self.bodyStream isEmpty]) {
+        return self.request;
+    }
+
+    // Reset the initial and final boundaries to ensure correct Content-Length
+    [self.bodyStream setInitialAndFinalBoundaries];
+    [self.request setHTTPBodyStream:self.bodyStream];
+
+    [self.request setValue:[NSString stringWithFormat:@"multipart/form-data; boundary=%@", self.boundary] forHTTPHeaderField:@"Content-Type"];
+    [self.request setValue:[NSString stringWithFormat:@"%llu", [self.bodyStream contentLength]] forHTTPHeaderField:@"Content-Length"];
+
+    return self.request;
+}
+
+@end
+
+#pragma mark -
+
+@interface NSStream ()
+@property (readwrite) NSStreamStatus streamStatus;
+@property (readwrite, copy) NSError *streamError;
+@end
+
+@interface AFMultipartBodyStream () <NSCopying>
+@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;
+@property (readwrite, nonatomic, strong) NSMutableArray *HTTPBodyParts;
+@property (readwrite, nonatomic, strong) NSEnumerator *HTTPBodyPartEnumerator;
+@property (readwrite, nonatomic, strong) AFHTTPBodyPart *currentHTTPBodyPart;
+@property (readwrite, nonatomic, strong) NSOutputStream *outputStream;
+@property (readwrite, nonatomic, strong) NSMutableData *buffer;
+@end
+
+@implementation AFMultipartBodyStream
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wimplicit-atomic-properties"
+#if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 80000) || (defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1100)
+@synthesize delegate;
+#endif
+@synthesize streamStatus;
+@synthesize streamError;
+#pragma clang diagnostic pop
+
+- (id)initWithStringEncoding:(NSStringEncoding)encoding {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.stringEncoding = encoding;
+    self.HTTPBodyParts = [NSMutableArray array];
+    self.numberOfBytesInPacket = NSIntegerMax;
+
+    return self;
+}
+
+- (void)setInitialAndFinalBoundaries {
+    if ([self.HTTPBodyParts count] > 0) {
+        for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) {
+            bodyPart.hasInitialBoundary = NO;
+            bodyPart.hasFinalBoundary = NO;
+        }
+
+        [[self.HTTPBodyParts objectAtIndex:0] setHasInitialBoundary:YES];
+        [[self.HTTPBodyParts lastObject] setHasFinalBoundary:YES];
+    }
+}
+
+- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart {
+    [self.HTTPBodyParts addObject:bodyPart];
+}
+
+- (BOOL)isEmpty {
+    return [self.HTTPBodyParts count] == 0;
+}
+
+#pragma mark - NSInputStream
+
+- (NSInteger)read:(uint8_t *)buffer
+        maxLength:(NSUInteger)length
+{
+    if ([self streamStatus] == NSStreamStatusClosed) {
+        return 0;
+    }
+
+    NSInteger totalNumberOfBytesRead = 0;
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    while ((NSUInteger)totalNumberOfBytesRead < MIN(length, self.numberOfBytesInPacket)) {
+        if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) {
+            if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) {
+                break;
+            }
+        } else {
+            NSUInteger maxLength = length - (NSUInteger)totalNumberOfBytesRead;
+            NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&buffer[totalNumberOfBytesRead] maxLength:maxLength];
+            if (numberOfBytesRead == -1) {
+                self.streamError = self.currentHTTPBodyPart.inputStream.streamError;
+                break;
+            } else {
+                totalNumberOfBytesRead += numberOfBytesRead;
+
+                if (self.delay > 0.0f) {
+                    [NSThread sleepForTimeInterval:self.delay];
+                }
+            }
+        }
+    }
+#pragma clang diagnostic pop
+
+    return totalNumberOfBytesRead;
+}
+
+- (BOOL)getBuffer:(__unused uint8_t **)buffer
+           length:(__unused NSUInteger *)len
+{
+    return NO;
+}
+
+- (BOOL)hasBytesAvailable {
+    return [self streamStatus] == NSStreamStatusOpen;
+}
+
+#pragma mark - NSStream
+
+- (void)open {
+    if (self.streamStatus == NSStreamStatusOpen) {
+        return;
+    }
+
+    self.streamStatus = NSStreamStatusOpen;
+
+    [self setInitialAndFinalBoundaries];
+    self.HTTPBodyPartEnumerator = [self.HTTPBodyParts objectEnumerator];
+}
+
+- (void)close {
+    self.streamStatus = NSStreamStatusClosed;
+}
+
+- (id)propertyForKey:(__unused NSString *)key {
+    return nil;
+}
+
+- (BOOL)setProperty:(__unused id)property
+             forKey:(__unused NSString *)key
+{
+    return NO;
+}
+
+- (void)scheduleInRunLoop:(__unused NSRunLoop *)aRunLoop
+                  forMode:(__unused NSString *)mode
+{}
+
+- (void)removeFromRunLoop:(__unused NSRunLoop *)aRunLoop
+                  forMode:(__unused NSString *)mode
+{}
+
+- (unsigned long long)contentLength {
+    unsigned long long length = 0;
+    for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) {
+        length += [bodyPart contentLength];
+    }
+
+    return length;
+}
+
+#pragma mark - Undocumented CFReadStream Bridged Methods
+
+- (void)_scheduleInCFRunLoop:(__unused CFRunLoopRef)aRunLoop
+                     forMode:(__unused CFStringRef)aMode
+{}
+
+- (void)_unscheduleFromCFRunLoop:(__unused CFRunLoopRef)aRunLoop
+                         forMode:(__unused CFStringRef)aMode
+{}
+
+- (BOOL)_setCFClientFlags:(__unused CFOptionFlags)inFlags
+                 callback:(__unused CFReadStreamClientCallBack)inCallback
+                  context:(__unused CFStreamClientContext *)inContext {
+    return NO;
+}
+
+#pragma mark - NSCopying
+
+-(id)copyWithZone:(NSZone *)zone {
+    AFMultipartBodyStream *bodyStreamCopy = [[[self class] allocWithZone:zone] initWithStringEncoding:self.stringEncoding];
+
+    for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) {
+        [bodyStreamCopy appendHTTPBodyPart:[bodyPart copy]];
+    }
+
+    [bodyStreamCopy setInitialAndFinalBoundaries];
+
+    return bodyStreamCopy;
+}
+
+@end
+
+#pragma mark -
+
+typedef enum {
+    AFEncapsulationBoundaryPhase = 1,
+    AFHeaderPhase                = 2,
+    AFBodyPhase                  = 3,
+    AFFinalBoundaryPhase         = 4,
+} AFHTTPBodyPartReadPhase;
+
+@interface AFHTTPBodyPart () <NSCopying> {
+    AFHTTPBodyPartReadPhase _phase;
+    NSInputStream *_inputStream;
+    unsigned long long _phaseReadOffset;
+}
+
+- (BOOL)transitionToNextPhase;
+- (NSInteger)readData:(NSData *)data
+           intoBuffer:(uint8_t *)buffer
+            maxLength:(NSUInteger)length;
+@end
+
+@implementation AFHTTPBodyPart
+
+- (id)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    [self transitionToNextPhase];
+
+    return self;
+}
+
+- (void)dealloc {
+    if (_inputStream) {
+        [_inputStream close];
+        _inputStream = nil;
+    }
+}
+
+- (NSInputStream *)inputStream {
+    if (!_inputStream) {
+        if ([self.body isKindOfClass:[NSData class]]) {
+            _inputStream = [NSInputStream inputStreamWithData:self.body];
+        } else if ([self.body isKindOfClass:[NSURL class]]) {
+            _inputStream = [NSInputStream inputStreamWithURL:self.body];
+        } else if ([self.body isKindOfClass:[NSInputStream class]]) {
+            _inputStream = self.body;
+        } else {
+            _inputStream = [NSInputStream inputStreamWithData:[NSData data]];
+        }
+    }
+
+    return _inputStream;
+}
+
+- (NSString *)stringForHeaders {
+    NSMutableString *headerString = [NSMutableString string];
+    for (NSString *field in [self.headers allKeys]) {
+        [headerString appendString:[NSString stringWithFormat:@"%@: %@%@", field, [self.headers valueForKey:field], kAFMultipartFormCRLF]];
+    }
+    [headerString appendString:kAFMultipartFormCRLF];
+
+    return [NSString stringWithString:headerString];
+}
+
+- (unsigned long long)contentLength {
+    unsigned long long length = 0;
+
+    NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding];
+    length += [encapsulationBoundaryData length];
+
+    NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding];
+    length += [headersData length];
+
+    length += _bodyContentLength;
+
+    NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]);
+    length += [closingBoundaryData length];
+
+    return length;
+}
+
+- (BOOL)hasBytesAvailable {
+    // Allows `read:maxLength:` to be called again if `AFMultipartFormFinalBoundary` doesn't fit into the available buffer
+    if (_phase == AFFinalBoundaryPhase) {
+        return YES;
+    }
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcovered-switch-default"
+    switch (self.inputStream.streamStatus) {
+        case NSStreamStatusNotOpen:
+        case NSStreamStatusOpening:
+        case NSStreamStatusOpen:
+        case NSStreamStatusReading:
+        case NSStreamStatusWriting:
+            return YES;
+        case NSStreamStatusAtEnd:
+        case NSStreamStatusClosed:
+        case NSStreamStatusError:
+        default:
+            return NO;
+    }
+#pragma clang diagnostic pop
+}
+
+- (NSInteger)read:(uint8_t *)buffer
+        maxLength:(NSUInteger)length
+{
+    NSInteger totalNumberOfBytesRead = 0;
+
+    if (_phase == AFEncapsulationBoundaryPhase) {
+        NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding];
+        totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
+    }
+
+    if (_phase == AFHeaderPhase) {
+        NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding];
+        totalNumberOfBytesRead += [self readData:headersData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
+    }
+
+    if (_phase == AFBodyPhase) {
+        NSInteger numberOfBytesRead = 0;
+
+        numberOfBytesRead = [self.inputStream read:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
+        if (numberOfBytesRead == -1) {
+            return -1;
+        } else {
+            totalNumberOfBytesRead += numberOfBytesRead;
+
+            if ([self.inputStream streamStatus] >= NSStreamStatusAtEnd) {
+                [self transitionToNextPhase];
+            }
+        }
+    }
+
+    if (_phase == AFFinalBoundaryPhase) {
+        NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]);
+        totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
+    }
+
+    return totalNumberOfBytesRead;
+}
+
+- (NSInteger)readData:(NSData *)data
+           intoBuffer:(uint8_t *)buffer
+            maxLength:(NSUInteger)length
+{
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length));
+    [data getBytes:buffer range:range];
+#pragma clang diagnostic pop
+
+    _phaseReadOffset += range.length;
+
+    if (((NSUInteger)_phaseReadOffset) >= [data length]) {
+        [self transitionToNextPhase];
+    }
+
+    return (NSInteger)range.length;
+}
+
+- (BOOL)transitionToNextPhase {
+    if (![[NSThread currentThread] isMainThread]) {
+        [self performSelectorOnMainThread:@selector(transitionToNextPhase) withObject:nil waitUntilDone:YES];
+        return YES;
+    }
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcovered-switch-default"
+    switch (_phase) {
+        case AFEncapsulationBoundaryPhase:
+            _phase = AFHeaderPhase;
+            break;
+        case AFHeaderPhase:
+            [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
+            [self.inputStream open];
+            _phase = AFBodyPhase;
+            break;
+        case AFBodyPhase:
+            [self.inputStream close];
+            _phase = AFFinalBoundaryPhase;
+            break;
+        case AFFinalBoundaryPhase:
+        default:
+            _phase = AFEncapsulationBoundaryPhase;
+            break;
+    }
+    _phaseReadOffset = 0;
+#pragma clang diagnostic pop
+
+    return YES;
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPBodyPart *bodyPart = [[[self class] allocWithZone:zone] init];
+    
+    bodyPart.stringEncoding = self.stringEncoding;
+    bodyPart.headers = self.headers;
+    bodyPart.bodyContentLength = self.bodyContentLength;
+    bodyPart.body = self.body;
+    bodyPart.boundary = self.boundary;
+    
+    return bodyPart;
+}
+
+@end
+
+#pragma mark -
+
+@implementation AFJSONRequestSerializer
+
++ (instancetype)serializer {
+    return [self serializerWithWritingOptions:(NSJSONWritingOptions)0];
+}
+
++ (instancetype)serializerWithWritingOptions:(NSJSONWritingOptions)writingOptions
+{
+    AFJSONRequestSerializer *serializer = [[self alloc] init];
+    serializer.writingOptions = writingOptions;
+
+    return serializer;
+}
+
+#pragma mark - AFURLRequestSerialization
+
+- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
+                               withParameters:(id)parameters
+                                        error:(NSError *__autoreleasing *)error
+{
+    NSParameterAssert(request);
+
+    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
+        return [super requestBySerializingRequest:request withParameters:parameters error:error];
+    }
+
+    NSMutableURLRequest *mutableRequest = [request mutableCopy];
+
+    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
+        if (![request valueForHTTPHeaderField:field]) {
+            [mutableRequest setValue:value forHTTPHeaderField:field];
+        }
+    }];
+    
+    if (parameters) {
+        if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) {
+            NSString *charset = (__bridge NSString *)CFStringConvertEncodingToIANACharSetName(CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding));
+            [mutableRequest setValue:[NSString stringWithFormat:@"application/json; charset=%@", charset] forHTTPHeaderField:@"Content-Type"];
+        }
+
+        [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]];
+    }
+
+    return mutableRequest;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.writingOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(writingOptions))] unsignedIntegerValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeInteger:self.writingOptions forKey:NSStringFromSelector(@selector(writingOptions))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFJSONRequestSerializer *serializer = [super copyWithZone:zone];
+    serializer.writingOptions = self.writingOptions;
+
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+@implementation AFPropertyListRequestSerializer
+
++ (instancetype)serializer {
+    return [self serializerWithFormat:NSPropertyListXMLFormat_v1_0 writeOptions:0];
+}
+
++ (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+                        writeOptions:(NSPropertyListWriteOptions)writeOptions
+{
+    AFPropertyListRequestSerializer *serializer = [[self alloc] init];
+    serializer.format = format;
+    serializer.writeOptions = writeOptions;
+
+    return serializer;
+}
+
+#pragma mark - AFURLRequestSerializer
+
+- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
+                               withParameters:(id)parameters
+                                        error:(NSError *__autoreleasing *)error
+{
+    NSParameterAssert(request);
+
+    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
+        return [super requestBySerializingRequest:request withParameters:parameters error:error];
+    }
+
+    NSMutableURLRequest *mutableRequest = [request mutableCopy];
+
+    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
+        if (![request valueForHTTPHeaderField:field]) {
+            [mutableRequest setValue:value forHTTPHeaderField:field];
+        }
+    }];
+
+    if (parameters) {
+        if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) {
+            NSString *charset = (__bridge NSString *)CFStringConvertEncodingToIANACharSetName(CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding));
+            [mutableRequest setValue:[NSString stringWithFormat:@"application/x-plist; charset=%@", charset] forHTTPHeaderField:@"Content-Type"];
+        }
+
+        [mutableRequest setHTTPBody:[NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]];
+    }
+
+    return mutableRequest;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.format = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(format))] unsignedIntegerValue];
+    self.writeOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(writeOptions))] unsignedIntegerValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeInteger:self.format forKey:NSStringFromSelector(@selector(format))];
+    [coder encodeObject:@(self.writeOptions) forKey:NSStringFromSelector(@selector(writeOptions))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFPropertyListRequestSerializer *serializer = [super copyWithZone:zone];
+    serializer.format = self.format;
+    serializer.writeOptions = self.writeOptions;
+
+    return serializer;
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.h
new file mode 100644
index 00000000000..ed1204c2dec
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.h
@@ -0,0 +1,302 @@
+// AFSerialization.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+#import <CoreGraphics/CoreGraphics.h>
+
+/**
+ The `AFURLResponseSerialization` protocol is adopted by an object that decodes data into a more useful object representation, according to details in the server response. Response serializers may additionally perform validation on the incoming response and data.
+
+ For example, a JSON response serializer may check for an acceptable status code (`2XX` range) and content type (`application/json`), decoding a valid JSON response into an object.
+ */
+@protocol AFURLResponseSerialization <NSObject, NSSecureCoding, NSCopying>
+
+/**
+ The response object decoded from the data associated with a specified response.
+
+ @param response The response to be processed.
+ @param data The response data to be decoded.
+ @param error The error that occurred while attempting to decode the response data.
+
+ @return The object decoded from the specified response data.
+ */
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error;
+
+@end
+
+#pragma mark -
+
+/**
+ `AFHTTPResponseSerializer` conforms to the `AFURLRequestSerialization` & `AFURLResponseSerialization` protocols, offering a concrete base implementation of query string / URL form-encoded parameter serialization and default request headers, as well as response status code and content type validation.
+
+ Any request or response serializer dealing with HTTP is encouraged to subclass `AFHTTPResponseSerializer` in order to ensure consistent default behavior.
+ */
+@interface AFHTTPResponseSerializer : NSObject <AFURLResponseSerialization>
+
+/**
+ The string encoding used to serialize parameters.
+ */
+@property (nonatomic, assign) NSStringEncoding stringEncoding;
+
+/**
+ Creates and returns a serializer with default configuration.
+ */
++ (instancetype)serializer;
+
+///-----------------------------------------
+/// @name Configuring Response Serialization
+///-----------------------------------------
+
+/**
+ The acceptable HTTP status codes for responses. When non-`nil`, responses with status codes not contained by the set will result in an error during validation.
+
+ See http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+ */
+@property (nonatomic, copy) NSIndexSet *acceptableStatusCodes;
+
+/**
+ The acceptable MIME types for responses. When non-`nil`, responses with a `Content-Type` with MIME types that do not intersect with the set will result in an error during validation.
+ */
+@property (nonatomic, copy) NSSet *acceptableContentTypes;
+
+/**
+ Validates the specified response and data.
+
+ In its base implementation, this method checks for an acceptable status code and content type. Subclasses may wish to add other domain-specific checks.
+
+ @param response The response to be validated.
+ @param data The data associated with the response.
+ @param error The error that occurred while attempting to validate the response.
+
+ @return `YES` if the response is valid, otherwise `NO`.
+ */
+- (BOOL)validateResponse:(NSHTTPURLResponse *)response
+                    data:(NSData *)data
+                   error:(NSError *__autoreleasing *)error;
+
+@end
+
+#pragma mark -
+
+
+/**
+ `AFJSONResponseSerializer` is a subclass of `AFHTTPResponseSerializer` that validates and decodes JSON responses.
+
+ By default, `AFJSONResponseSerializer` accepts the following MIME types, which includes the official standard, `application/json`, as well as other commonly-used types:
+
+ - `application/json`
+ - `text/json`
+ - `text/javascript`
+ */
+@interface AFJSONResponseSerializer : AFHTTPResponseSerializer
+
+/**
+ Options for reading the response JSON data and creating the Foundation objects. For possible values, see the `NSJSONSerialization` documentation section "NSJSONReadingOptions". `0` by default.
+ */
+@property (nonatomic, assign) NSJSONReadingOptions readingOptions;
+
+/**
+ Whether to remove keys with `NSNull` values from response JSON. Defaults to `NO`.
+ */
+@property (nonatomic, assign) BOOL removesKeysWithNullValues;
+
+/**
+ Creates and returns a JSON serializer with specified reading and writing options.
+
+ @param readingOptions The specified JSON reading options.
+ */
++ (instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions;
+
+@end
+
+#pragma mark -
+
+/**
+ `AFXMLParserSerializer` is a subclass of `AFHTTPResponseSerializer` that validates and decodes XML responses as an `NSXMLParser` objects.
+
+ By default, `AFXMLParserSerializer` accepts the following MIME types, which includes the official standard, `application/xml`, as well as other commonly-used types:
+
+ - `application/xml`
+ - `text/xml`
+ */
+@interface AFXMLParserResponseSerializer : AFHTTPResponseSerializer
+
+@end
+
+#pragma mark -
+
+#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
+
+/**
+ `AFXMLDocumentSerializer` is a subclass of `AFHTTPResponseSerializer` that validates and decodes XML responses as an `NSXMLDocument` objects.
+
+ By default, `AFXMLDocumentSerializer` accepts the following MIME types, which includes the official standard, `application/xml`, as well as other commonly-used types:
+
+ - `application/xml`
+ - `text/xml`
+ */
+@interface AFXMLDocumentResponseSerializer : AFHTTPResponseSerializer
+
+/**
+ Input and output options specifically intended for `NSXMLDocument` objects. For possible values, see the `NSJSONSerialization` documentation section "NSJSONReadingOptions". `0` by default.
+ */
+@property (nonatomic, assign) NSUInteger options;
+
+/**
+ Creates and returns an XML document serializer with the specified options.
+
+ @param mask The XML document options.
+ */
++ (instancetype)serializerWithXMLDocumentOptions:(NSUInteger)mask;
+
+@end
+
+#endif
+
+#pragma mark -
+
+/**
+ `AFPropertyListSerializer` is a subclass of `AFHTTPResponseSerializer` that validates and decodes XML responses as an `NSXMLDocument` objects.
+
+ By default, `AFPropertyListSerializer` accepts the following MIME types:
+
+ - `application/x-plist`
+ */
+@interface AFPropertyListResponseSerializer : AFHTTPResponseSerializer
+
+/**
+ The property list format. Possible values are described in "NSPropertyListFormat".
+ */
+@property (nonatomic, assign) NSPropertyListFormat format;
+
+/**
+ The property list reading options. Possible values are described in "NSPropertyListMutabilityOptions."
+ */
+@property (nonatomic, assign) NSPropertyListReadOptions readOptions;
+
+/**
+ Creates and returns a property list serializer with a specified format, read options, and write options.
+
+ @param format The property list format.
+ @param readOptions The property list reading options.
+ */
++ (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+                         readOptions:(NSPropertyListReadOptions)readOptions;
+
+@end
+
+#pragma mark -
+
+/**
+ `AFImageSerializer` is a subclass of `AFHTTPResponseSerializer` that validates and decodes image responses.
+
+ By default, `AFImageSerializer` accepts the following MIME types, which correspond to the image formats supported by UIImage or NSImage:
+
+ - `image/tiff`
+ - `image/jpeg`
+ - `image/gif`
+ - `image/png`
+ - `image/ico`
+ - `image/x-icon`
+ - `image/bmp`
+ - `image/x-bmp`
+ - `image/x-xbitmap`
+ - `image/x-win-bitmap`
+ */
+@interface AFImageResponseSerializer : AFHTTPResponseSerializer
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+/**
+ The scale factor used when interpreting the image data to construct `responseImage`. Specifying a scale factor of 1.0 results in an image whose size matches the pixel-based dimensions of the image. Applying a different scale factor changes the size of the image as reported by the size property. This is set to the value of scale of the main screen by default, which automatically scales images for retina displays, for instance.
+ */
+@property (nonatomic, assign) CGFloat imageScale;
+
+/**
+ Whether to automatically inflate response image data for compressed formats (such as PNG or JPEG). Enabling this can significantly improve drawing performance on iOS when used with `setCompletionBlockWithSuccess:failure:`, as it allows a bitmap representation to be constructed in the background rather than on the main thread. `YES` by default.
+ */
+@property (nonatomic, assign) BOOL automaticallyInflatesResponseImage;
+#endif
+
+@end
+
+#pragma mark -
+
+/**
+ `AFCompoundSerializer` is a subclass of `AFHTTPResponseSerializer` that delegates the response serialization to the first `AFHTTPResponseSerializer` object that returns an object for `responseObjectForResponse:data:error:`, falling back on the default behavior of `AFHTTPResponseSerializer`. This is useful for supporting multiple potential types and structures of server responses with a single serializer.
+ */
+@interface AFCompoundResponseSerializer : AFHTTPResponseSerializer
+
+/**
+ The component response serializers.
+ */
+@property (readonly, nonatomic, copy) NSArray *responseSerializers;
+
+/**
+ Creates and returns a compound serializer comprised of the specified response serializers.
+
+ @warning Each response serializer specified must be a subclass of `AFHTTPResponseSerializer`, and response to `-validateResponse:data:error:`.
+ */
++ (instancetype)compoundSerializerWithResponseSerializers:(NSArray *)responseSerializers;
+
+@end
+
+///----------------
+/// @name Constants
+///----------------
+
+/**
+ ## Error Domains
+
+ The following error domain is predefined.
+
+ - `NSString * const AFURLResponseSerializationErrorDomain`
+
+ ### Constants
+
+ `AFURLResponseSerializationErrorDomain`
+ AFURLResponseSerializer errors. Error codes for `AFURLResponseSerializationErrorDomain` correspond to codes in `NSURLErrorDomain`.
+ */
+extern NSString * const AFURLResponseSerializationErrorDomain;
+
+/**
+ ## User info dictionary keys
+
+ These keys may exist in the user info dictionary, in addition to those defined for NSError.
+
+ - `NSString * const AFNetworkingOperationFailingURLResponseErrorKey`
+ - `NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey`
+
+ ### Constants
+
+ `AFNetworkingOperationFailingURLResponseErrorKey`
+ The corresponding value is an `NSURLResponse` containing the response of the operation associated with an error. This key is only present in the `AFURLResponseSerializationErrorDomain`.
+ 
+ `AFNetworkingOperationFailingURLResponseDataErrorKey`
+ The corresponding value is an `NSData` containing the original data of the operation associated with an error. This key is only present in the `AFURLResponseSerializationErrorDomain`.
+ */
+extern NSString * const AFNetworkingOperationFailingURLResponseErrorKey;
+
+extern NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey;
+
+
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.m
new file mode 100644
index 00000000000..7b042f758ff
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.m
@@ -0,0 +1,793 @@
+// AFSerialization.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFURLResponseSerialization.h"
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <UIKit/UIKit.h>
+#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+#import <Cocoa/Cocoa.h>
+#endif
+
+NSString * const AFURLResponseSerializationErrorDomain = @"com.alamofire.error.serialization.response";
+NSString * const AFNetworkingOperationFailingURLResponseErrorKey = @"com.alamofire.serialization.response.error.response";
+NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey = @"com.alamofire.serialization.response.error.data";
+
+static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) {
+    if (!error) {
+        return underlyingError;
+    }
+
+    if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
+        return error;
+    }
+
+    NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
+    mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;
+
+    return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];
+}
+
+static BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error, NSInteger code, NSString *domain) {
+    if ([error.domain isEqualToString:domain] && error.code == code) {
+        return YES;
+    } else if (error.userInfo[NSUnderlyingErrorKey]) {
+        return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);
+    }
+
+    return NO;
+}
+
+static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {
+    if ([JSONObject isKindOfClass:[NSArray class]]) {
+        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
+        for (id value in (NSArray *)JSONObject) {
+            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
+        }
+
+        return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
+    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
+        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
+        for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {
+            id value = [(NSDictionary *)JSONObject objectForKey:key];
+            if (!value || [value isEqual:[NSNull null]]) {
+                [mutableDictionary removeObjectForKey:key];
+            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
+                [mutableDictionary setObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions) forKey:key];
+            }
+        }
+
+        return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
+    }
+
+    return JSONObject;
+}
+
+@implementation AFHTTPResponseSerializer
+
++ (instancetype)serializer {
+    return [[self alloc] init];
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.stringEncoding = NSUTF8StringEncoding;
+
+    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
+    self.acceptableContentTypes = nil;
+
+    return self;
+}
+
+#pragma mark -
+
+- (BOOL)validateResponse:(NSHTTPURLResponse *)response
+                    data:(NSData *)data
+                   error:(NSError * __autoreleasing *)error
+{
+    BOOL responseIsValid = YES;
+    NSError *validationError = nil;
+
+    if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {
+        if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]]) {
+            if ([data length] > 0) {
+                NSMutableDictionary *mutableUserInfo = [@{
+                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]],
+                                                          NSURLErrorFailingURLErrorKey:[response URL],
+                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,
+                                                        } mutableCopy];
+                if (data) {
+                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
+                }
+
+                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
+            }
+
+            responseIsValid = NO;
+        }
+
+        if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode]) {
+            NSMutableDictionary *mutableUserInfo = [@{
+                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
+                                               NSURLErrorFailingURLErrorKey:[response URL],
+                                               AFNetworkingOperationFailingURLResponseErrorKey: response,
+                                       } mutableCopy];
+
+            if (data) {
+                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
+            }
+
+            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);
+
+            responseIsValid = NO;
+        }
+    }
+
+    if (error && !responseIsValid) {
+        *error = validationError;
+    }
+
+    return responseIsValid;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];
+
+    return data;
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [self init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableStatusCodes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
+    self.acceptableContentTypes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [coder encodeObject:self.acceptableStatusCodes forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
+    [coder encodeObject:self.acceptableContentTypes forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFHTTPResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.acceptableStatusCodes = [self.acceptableStatusCodes copyWithZone:zone];
+    serializer.acceptableContentTypes = [self.acceptableContentTypes copyWithZone:zone];
+
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+@implementation AFJSONResponseSerializer
+
++ (instancetype)serializer {
+    return [self serializerWithReadingOptions:(NSJSONReadingOptions)0];
+}
+
++ (instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions {
+    AFJSONResponseSerializer *serializer = [[self alloc] init];
+    serializer.readingOptions = readingOptions;
+
+    return serializer;
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript", nil];
+
+    return self;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
+        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
+            return nil;
+        }
+    }
+
+    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.
+    // See https://github.com/rails/rails/issues/1742
+    NSStringEncoding stringEncoding = self.stringEncoding;
+    if (response.textEncodingName) {
+        CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName);
+        if (encoding != kCFStringEncodingInvalidId) {
+            stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);
+        }
+    }
+
+    id responseObject = nil;
+    NSError *serializationError = nil;
+    @autoreleasepool {
+        NSString *responseString = [[NSString alloc] initWithData:data encoding:stringEncoding];
+        if (responseString && ![responseString isEqualToString:@" "]) {
+            // Workaround for a bug in NSJSONSerialization when Unicode character escape codes are used instead of the actual character
+            // See http://stackoverflow.com/a/12843465/157142
+            data = [responseString dataUsingEncoding:NSUTF8StringEncoding];
+
+            if (data) {
+                if ([data length] > 0) {
+                    responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];
+                } else {
+                    return nil;
+                }
+            } else {
+                NSDictionary *userInfo = @{
+                                           NSLocalizedDescriptionKey: NSLocalizedStringFromTable(@"Data failed decoding as a UTF-8 string", @"AFNetworking", nil),
+                                           NSLocalizedFailureReasonErrorKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Could not decode string: %@", @"AFNetworking", nil), responseString]
+                                           };
+
+                serializationError = [NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo];
+            }
+        }
+    }
+
+    if (self.removesKeysWithNullValues && responseObject) {
+        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
+    }
+    
+    if (error) {
+        *error = AFErrorWithUnderlyingError(serializationError, *error);
+    }
+    
+    return responseObject;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.readingOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readingOptions))] unsignedIntegerValue];
+    self.removesKeysWithNullValues = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))] boolValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:@(self.readingOptions) forKey:NSStringFromSelector(@selector(readingOptions))];
+    [coder encodeObject:@(self.removesKeysWithNullValues) forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFJSONResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.readingOptions = self.readingOptions;
+    serializer.removesKeysWithNullValues = self.removesKeysWithNullValues;
+
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+@implementation AFXMLParserResponseSerializer
+
++ (instancetype)serializer {
+    AFXMLParserResponseSerializer *serializer = [[self alloc] init];
+
+    return serializer;
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/xml", @"text/xml", nil];
+
+    return self;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSHTTPURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
+        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
+            return nil;
+        }
+    }
+
+    return [[NSXMLParser alloc] initWithData:data];
+}
+
+@end
+
+#pragma mark -
+
+#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
+
+@implementation AFXMLDocumentResponseSerializer
+
++ (instancetype)serializer {
+    return [self serializerWithXMLDocumentOptions:0];
+}
+
++ (instancetype)serializerWithXMLDocumentOptions:(NSUInteger)mask {
+    AFXMLDocumentResponseSerializer *serializer = [[self alloc] init];
+    serializer.options = mask;
+
+    return serializer;
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/xml", @"text/xml", nil];
+
+    return self;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
+        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
+            return nil;
+        }
+    }
+
+    NSError *serializationError = nil;
+    NSXMLDocument *document = [[NSXMLDocument alloc] initWithData:data options:self.options error:&serializationError];
+
+    if (error) {
+        *error = AFErrorWithUnderlyingError(serializationError, *error);
+    }
+
+    return document;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.options = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(options))] unsignedIntegerValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:@(self.options) forKey:NSStringFromSelector(@selector(options))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFXMLDocumentResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.options = self.options;
+
+    return serializer;
+}
+
+@end
+
+#endif
+
+#pragma mark -
+
+@implementation AFPropertyListResponseSerializer
+
++ (instancetype)serializer {
+    return [self serializerWithFormat:NSPropertyListXMLFormat_v1_0 readOptions:0];
+}
+
++ (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+                         readOptions:(NSPropertyListReadOptions)readOptions
+{
+    AFPropertyListResponseSerializer *serializer = [[self alloc] init];
+    serializer.format = format;
+    serializer.readOptions = readOptions;
+
+    return serializer;
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/x-plist", nil];
+
+    return self;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
+        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
+            return nil;
+        }
+    }
+
+    id responseObject;
+    NSError *serializationError = nil;
+
+    if (data) {
+        responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&serializationError];
+    }
+
+    if (error) {
+        *error = AFErrorWithUnderlyingError(serializationError, *error);
+    }
+
+    return responseObject;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.format = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(format))] unsignedIntegerValue];
+    self.readOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readOptions))] unsignedIntegerValue];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:@(self.format) forKey:NSStringFromSelector(@selector(format))];
+    [coder encodeObject:@(self.readOptions) forKey:NSStringFromSelector(@selector(readOptions))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFPropertyListResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.format = self.format;
+    serializer.readOptions = self.readOptions;
+
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#import <CoreGraphics/CoreGraphics.h>
+
+static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) {
+    UIImage *image = [[UIImage alloc] initWithData:data];
+
+    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];
+}
+
+static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) {
+    if (!data || [data length] == 0) {
+        return nil;
+    }
+
+    CGImageRef imageRef = NULL;
+    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
+
+    if ([response.MIMEType isEqualToString:@"image/png"]) {
+        imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);
+    } else if ([response.MIMEType isEqualToString:@"image/jpeg"]) {
+        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
+
+        // CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so if so, fall back to AFImageWithDataAtScale
+        if (imageRef) {
+            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
+            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);
+            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
+                CGImageRelease(imageRef);
+                imageRef = NULL;
+            }
+        }
+    }
+
+    CGDataProviderRelease(dataProvider);
+
+    UIImage *image = AFImageWithDataAtScale(data, scale);
+    if (!imageRef) {
+        if (image.images || !image) {
+            return image;
+        }
+
+        imageRef = CGImageCreateCopy([image CGImage]);
+        if (!imageRef) {
+            return nil;
+        }
+    }
+
+    size_t width = CGImageGetWidth(imageRef);
+    size_t height = CGImageGetHeight(imageRef);
+    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);
+
+    if (width * height > 1024 * 1024 || bitsPerComponent > 8) {
+        CGImageRelease(imageRef);
+
+        return image;
+    }
+
+    size_t bytesPerRow = 0; // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate
+    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
+    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
+    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);
+
+    if (colorSpaceModel == kCGColorSpaceModelRGB) {
+        uint32_t alpha = (bitmapInfo & kCGBitmapAlphaInfoMask);
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wassign-enum"
+        if (alpha == kCGImageAlphaNone) {
+            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
+            bitmapInfo |= kCGImageAlphaNoneSkipFirst;
+        } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
+            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
+            bitmapInfo |= kCGImageAlphaPremultipliedFirst;
+        }
+#pragma clang diagnostic pop
+    }
+
+    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);
+
+    CGColorSpaceRelease(colorSpace);
+
+    if (!context) {
+        CGImageRelease(imageRef);
+
+        return image;
+    }
+
+    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
+    CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);
+
+    CGContextRelease(context);
+
+    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];
+
+    CGImageRelease(inflatedImageRef);
+    CGImageRelease(imageRef);
+    
+    return inflatedImage;
+}
+#endif
+
+
+@implementation AFImageResponseSerializer
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap", nil];
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    self.imageScale = [[UIScreen mainScreen] scale];
+    self.automaticallyInflatesResponseImage = YES;
+#endif
+
+    return self;
+}
+
+#pragma mark - AFURLResponseSerializer
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
+        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
+            return nil;
+        }
+    }
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    if (self.automaticallyInflatesResponseImage) {
+        return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);
+    } else {
+        return AFImageWithDataAtScale(data, self.imageScale);
+    }
+#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+    // Ensure that the image is set to it's correct pixel width and height
+    NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];
+    NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];
+    [image addRepresentation:bitimage];
+
+    return image;
+#endif
+
+    return nil;
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(imageScale))];
+#if CGFLOAT_IS_DOUBLE
+    self.imageScale = [imageScale doubleValue];
+#else
+    self.imageScale = [imageScale floatValue];
+#endif
+
+    self.automaticallyInflatesResponseImage = [decoder decodeBoolForKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
+#endif
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    [coder encodeObject:@(self.imageScale) forKey:NSStringFromSelector(@selector(imageScale))];
+    [coder encodeBool:self.automaticallyInflatesResponseImage forKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
+#endif
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFImageResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+    serializer.imageScale = self.imageScale;
+    serializer.automaticallyInflatesResponseImage = self.automaticallyInflatesResponseImage;
+#endif
+
+    return serializer;
+}
+
+@end
+
+#pragma mark -
+
+@interface AFCompoundResponseSerializer ()
+@property (readwrite, nonatomic, copy) NSArray *responseSerializers;
+@end
+
+@implementation AFCompoundResponseSerializer
+
++ (instancetype)compoundSerializerWithResponseSerializers:(NSArray *)responseSerializers {
+    AFCompoundResponseSerializer *serializer = [[self alloc] init];
+    serializer.responseSerializers = responseSerializers;
+
+    return serializer;
+}
+
+#pragma mark - AFURLResponseSerialization
+
+- (id)responseObjectForResponse:(NSURLResponse *)response
+                           data:(NSData *)data
+                          error:(NSError *__autoreleasing *)error
+{
+    for (id <AFURLResponseSerialization> serializer in self.responseSerializers) {
+        if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
+            continue;
+        }
+
+        NSError *serializerError = nil;
+        id responseObject = [serializer responseObjectForResponse:response data:data error:&serializerError];
+        if (responseObject) {
+            if (error) {
+                *error = AFErrorWithUnderlyingError(serializerError, *error);
+            }
+
+            return responseObject;
+        }
+    }
+    
+    return [super responseObjectForResponse:response data:data error:error];
+}
+
+#pragma mark - NSSecureCoding
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    self = [super initWithCoder:decoder];
+    if (!self) {
+        return nil;
+    }
+
+    self.responseSerializers = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(responseSerializers))];
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [super encodeWithCoder:coder];
+
+    [coder encodeObject:self.responseSerializers forKey:NSStringFromSelector(@selector(responseSerializers))];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    AFCompoundResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
+    serializer.responseSerializers = self.responseSerializers;
+
+    return serializer;
+}
+
+@end
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.h b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.h
new file mode 100644
index 00000000000..6939b7d47f5
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.h
@@ -0,0 +1,529 @@
+// AFURLSessionManager.h
+// 
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import "AFURLResponseSerialization.h"
+#import "AFURLRequestSerialization.h"
+#import "AFSecurityPolicy.h"
+#import "AFNetworkReachabilityManager.h"
+
+/**
+ `AFURLSessionManager` creates and manages an `NSURLSession` object based on a specified `NSURLSessionConfiguration` object, which conforms to `<NSURLSessionTaskDelegate>`, `<NSURLSessionDataDelegate>`, `<NSURLSessionDownloadDelegate>`, and `<NSURLSessionDelegate>`.
+ 
+ ## Subclassing Notes
+ 
+ This is the base class for `AFHTTPSessionManager`, which adds functionality specific to making HTTP requests. If you are looking to extend `AFURLSessionManager` specifically for HTTP, consider subclassing `AFHTTPSessionManager` instead.
+ 
+ ## NSURLSession & NSURLSessionTask Delegate Methods
+ 
+ `AFURLSessionManager` implements the following delegate methods:
+ 
+ ### `NSURLSessionDelegate`
+ 
+ - `URLSession:didBecomeInvalidWithError:`
+ - `URLSession:didReceiveChallenge:completionHandler:`
+ - `URLSessionDidFinishEventsForBackgroundURLSession:`
+
+ ### `NSURLSessionTaskDelegate`
+ 
+ - `URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`
+ - `URLSession:task:didReceiveChallenge:completionHandler:`
+ - `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`
+ - `URLSession:task:didCompleteWithError:`
+
+ ### `NSURLSessionDataDelegate`
+ 
+ - `URLSession:dataTask:didReceiveResponse:completionHandler:`
+ - `URLSession:dataTask:didBecomeDownloadTask:`
+ - `URLSession:dataTask:didReceiveData:`
+ - `URLSession:dataTask:willCacheResponse:completionHandler:`
+
+ ### `NSURLSessionDownloadDelegate`
+
+ - `URLSession:downloadTask:didFinishDownloadingToURL:`
+ - `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`
+ - `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`
+ 
+ If any of these methods are overridden in a subclass, they _must_ call the `super` implementation first.
+ 
+ ## Network Reachability Monitoring
+
+ Network reachability status and change monitoring is available through the `reachabilityManager` property. Applications may choose to monitor network reachability conditions in order to prevent or suspend any outbound requests. See `AFNetworkReachabilityManager` for more details.
+ 
+ ## NSCoding Caveats
+ 
+ - Encoded managers do not include any block properties. Be sure to set delegate callback blocks when using `-initWithCoder:` or `NSKeyedUnarchiver`.
+
+ ## NSCopying Caveats
+
+ - `-copy` and `-copyWithZone:` return a new manager with a new `NSURLSession` created from the configuration of the original.
+ - Operation copies do not include any delegate callback blocks, as they often strongly captures a reference to `self`, which would otherwise have the unintuitive side-effect of pointing to the _original_ session manager when copied.
+ */
+
+#if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000) || (defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090)
+
+@interface AFURLSessionManager : NSObject <NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying>
+
+/**
+ The managed session.
+ */
+@property (readonly, nonatomic, strong) NSURLSession *session;
+
+/**
+ The operation queue on which delegate callbacks are run.
+ */
+@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;
+
+/**
+ Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to an instance of `AFJSONResponseSerializer`.
+
+ @warning `responseSerializer` must not be `nil`.
+ */
+@property (nonatomic, strong) id <AFURLResponseSerialization> responseSerializer;
+
+///-------------------------------
+/// @name Managing Security Policy
+///-------------------------------
+
+/**
+ The security policy used by created request operations to evaluate server trust for secure connections. `AFURLSessionManager` uses the `defaultPolicy` unless otherwise specified.
+ */
+@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;
+
+///--------------------------------------
+/// @name Monitoring Network Reachability
+///--------------------------------------
+
+/**
+ The network reachability manager. `AFURLSessionManager` uses the `sharedManager` by default.
+ */
+@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;
+
+///----------------------------
+/// @name Getting Session Tasks
+///----------------------------
+
+/**
+ The data, upload, and download tasks currently run by the managed session.
+ */
+@property (readonly, nonatomic, strong) NSArray *tasks;
+
+/**
+ The data tasks currently run by the managed session.
+ */
+@property (readonly, nonatomic, strong) NSArray *dataTasks;
+
+/**
+ The upload tasks currently run by the managed session.
+ */
+@property (readonly, nonatomic, strong) NSArray *uploadTasks;
+
+/**
+ The download tasks currently run by the managed session.
+ */
+@property (readonly, nonatomic, strong) NSArray *downloadTasks;
+
+///-------------------------------
+/// @name Managing Callback Queues
+///-------------------------------
+
+/**
+ The dispatch queue for `completionBlock`. If `NULL` (default), the main queue is used.
+ */
+@property (nonatomic, strong) dispatch_queue_t completionQueue;
+
+/**
+ The dispatch group for `completionBlock`. If `NULL` (default), a private dispatch group is used.
+ */
+@property (nonatomic, strong) dispatch_group_t completionGroup;
+
+///---------------------------------
+/// @name Working Around System Bugs
+///---------------------------------
+
+/**
+ Whether to attempt to retry creation of upload tasks for background sessions when initial call returns `nil`. `NO` by default.
+
+ @bug As of iOS 7.0, there is a bug where upload tasks created for background tasks are sometimes `nil`. As a workaround, if this property is `YES`, AFNetworking will follow Apple's recommendation to try creating the task again.
+
+ @see https://github.com/AFNetworking/AFNetworking/issues/1675
+ */
+@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;
+
+///---------------------
+/// @name Initialization
+///---------------------
+
+/**
+ Creates and returns a manager for a session created with the specified configuration. This is the designated initializer.
+ 
+ @param configuration The configuration used to create the managed session.
+ 
+ @return A manager for a newly-created session.
+ */
+- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration;
+
+/**
+ Invalidates the managed session, optionally canceling pending tasks.
+ 
+ @param cancelPendingTasks Whether or not to cancel pending tasks.
+ */
+- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;
+
+///-------------------------
+/// @name Running Data Tasks
+///-------------------------
+
+/**
+ Creates an `NSURLSessionDataTask` with the specified request.
+
+ @param request The HTTP request for the request.
+ @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
+ */
+- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
+                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;
+
+///---------------------------
+/// @name Running Upload Tasks
+///---------------------------
+
+/**
+ Creates an `NSURLSessionUploadTask` with the specified request for a local file.
+
+ @param request The HTTP request for the request.
+ @param fileURL A URL to the local file to be uploaded.
+ @param progress A progress object monitoring the current upload progress.
+ @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
+ 
+ @see `attemptsToRecreateUploadTasksForBackgroundSessions`
+ */
+- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
+                                         fromFile:(NSURL *)fileURL
+                                         progress:(NSProgress * __autoreleasing *)progress
+                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;
+
+/**
+ Creates an `NSURLSessionUploadTask` with the specified request for an HTTP body.
+
+ @param request The HTTP request for the request.
+ @param bodyData A data object containing the HTTP body to be uploaded.
+ @param progress A progress object monitoring the current upload progress.
+ @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
+ */
+- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
+                                         fromData:(NSData *)bodyData
+                                         progress:(NSProgress * __autoreleasing *)progress
+                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;
+
+/**
+ Creates an `NSURLSessionUploadTask` with the specified streaming request.
+
+ @param request The HTTP request for the request.
+ @param progress A progress object monitoring the current upload progress.
+ @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
+ */
+- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request
+                                                 progress:(NSProgress * __autoreleasing *)progress
+                                        completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;
+
+///-----------------------------
+/// @name Running Download Tasks
+///-----------------------------
+
+/**
+ Creates an `NSURLSessionDownloadTask` with the specified request.
+
+ @param request The HTTP request for the request.
+ @param progress A progress object monitoring the current download progress.
+ @param destination A block object to be executed in order to determine the destination of the downloaded file. This block takes two arguments, the target path & the server response, and returns the desired file URL of the resulting download. The temporary file used during the download will be automatically deleted after being moved to the returned URL.
+ @param completionHandler A block to be executed when a task finishes. This block has no return value and takes three arguments: the server response, the path of the downloaded file, and the error describing the network or parsing error that occurred, if any.
+ 
+ @warning If using a background `NSURLSessionConfiguration` on iOS, these blocks will be lost when the app is terminated. Background sessions may prefer to use `-setDownloadTaskDidFinishDownloadingBlock:` to specify the URL for saving the downloaded file, rather than the destination block of this method.
+ */
+- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request
+                                             progress:(NSProgress * __autoreleasing *)progress
+                                          destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
+                                    completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler;
+
+/**
+ Creates an `NSURLSessionDownloadTask` with the specified resume data.
+
+ @param resumeData The data used to resume downloading.
+ @param progress A progress object monitoring the current download progress.
+ @param destination A block object to be executed in order to determine the destination of the downloaded file. This block takes two arguments, the target path & the server response, and returns the desired file URL of the resulting download. The temporary file used during the download will be automatically deleted after being moved to the returned URL.
+ @param completionHandler A block to be executed when a task finishes. This block has no return value and takes three arguments: the server response, the path of the downloaded file, and the error describing the network or parsing error that occurred, if any.
+ */
+- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData
+                                                progress:(NSProgress * __autoreleasing *)progress
+                                             destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
+                                       completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler;
+
+///---------------------------------
+/// @name Getting Progress for Tasks
+///---------------------------------
+
+/**
+ Returns the upload progress of the specified task.
+
+ @param uploadTask The session upload task. Must not be `nil`.
+
+ @return An `NSProgress` object reporting the upload progress of a task, or `nil` if the progress is unavailable.
+ */
+- (NSProgress *)uploadProgressForTask:(NSURLSessionUploadTask *)uploadTask;
+
+/**
+ Returns the download progress of the specified task.
+ 
+ @param downloadTask The session download task. Must not be `nil`.
+ 
+ @return An `NSProgress` object reporting the download progress of a task, or `nil` if the progress is unavailable.
+ */
+- (NSProgress *)downloadProgressForTask:(NSURLSessionDownloadTask *)downloadTask;
+
+///-----------------------------------------
+/// @name Setting Session Delegate Callbacks
+///-----------------------------------------
+
+/**
+ Sets a block to be executed when the managed session becomes invalid, as handled by the `NSURLSessionDelegate` method `URLSession:didBecomeInvalidWithError:`.
+ 
+ @param block A block object to be executed when the managed session becomes invalid. The block has no return value, and takes two arguments: the session, and the error related to the cause of invalidation.
+ */
+- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block;
+
+/**
+ Sets a block to be executed when a connection level authentication challenge has occurred, as handled by the `NSURLSessionDelegate` method `URLSession:didReceiveChallenge:completionHandler:`.
+
+ @param block A block object to be executed when a connection level authentication challenge has occurred. The block returns the disposition of the authentication challenge, and takes three arguments: the session, the authentication challenge, and a pointer to the credential that should be used to resolve the challenge.
+ */
+- (void)setSessionDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block;
+
+///--------------------------------------
+/// @name Setting Task Delegate Callbacks
+///--------------------------------------
+
+/**
+ Sets a block to be executed when a task requires a new request body stream to send to the remote server, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:needNewBodyStream:`.
+
+ @param block A block object to be executed when a task requires a new request body stream.
+ */
+- (void)setTaskNeedNewBodyStreamBlock:(NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;
+
+/**
+ Sets a block to be executed when an HTTP request is attempting to perform a redirection to a different URL, as handled by the `NSURLSessionTaskDelegate` method `URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`.
+ 
+ @param block A block object to be executed when an HTTP request is attempting to perform a redirection to a different URL. The block returns the request to be made for the redirection, and takes four arguments: the session, the task, the redirection response, and the request corresponding to the redirection response.
+ */
+- (void)setTaskWillPerformHTTPRedirectionBlock:(NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;
+
+/**
+ Sets a block to be executed when a session task has received a request specific authentication challenge, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didReceiveChallenge:completionHandler:`.
+ 
+ @param block A block object to be executed when a session task has received a request specific authentication challenge. The block returns the disposition of the authentication challenge, and takes four arguments: the session, the task, the authentication challenge, and a pointer to the credential that should be used to resolve the challenge.
+ */
+- (void)setTaskDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block;
+
+/**
+ Sets a block to be executed periodically to track upload progress, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
+ 
+ @param block A block object to be called when an undetermined number of bytes have been uploaded to the server. This block has no return value and takes five arguments: the session, the task, the number of bytes written since the last time the upload progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body. This block may be called multiple times, and will execute on the main thread.
+ */
+- (void)setTaskDidSendBodyDataBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;
+
+/**
+ Sets a block to be executed as the last message related to a specific task, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didCompleteWithError:`.
+ 
+ @param block A block object to be executed when a session task is completed. The block has no return value, and takes three arguments: the session, the task, and any error that occurred in the process of executing the task.
+ */
+- (void)setTaskDidCompleteBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, NSError *error))block;
+
+///-------------------------------------------
+/// @name Setting Data Task Delegate Callbacks
+///-------------------------------------------
+
+/**
+ Sets a block to be executed when a data task has received a response, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
+
+ @param block A block object to be executed when a data task has received a response. The block returns the disposition of the session response, and takes three arguments: the session, the data task, and the received response.
+ */
+- (void)setDataTaskDidReceiveResponseBlock:(NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;
+
+/**
+ Sets a block to be executed when a data task has become a download task, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didBecomeDownloadTask:`.
+ 
+ @param block A block object to be executed when a data task has become a download task. The block has no return value, and takes three arguments: the session, the data task, and the download task it has become.
+ */
+- (void)setDataTaskDidBecomeDownloadTaskBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;
+
+/**
+ Sets a block to be executed when a data task receives data, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didReceiveData:`.
+ 
+ @param block A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes three arguments: the session, the data task, and the data received. This block may be called multiple times, and will execute on the session manager operation queue.
+ */
+- (void)setDataTaskDidReceiveDataBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;
+
+/**
+ Sets a block to be executed to determine the caching behavior of a data task, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:willCacheResponse:completionHandler:`.
+ 
+ @param block A block object to be executed to determine the caching behavior of a data task. The block returns the response to cache, and takes three arguments: the session, the data task, and the proposed cached URL response.
+ */
+- (void)setDataTaskWillCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;
+
+/**
+ Sets a block to be executed once all messages enqueued for a session have been delivered, as handled by the `NSURLSessionDataDelegate` method `URLSessionDidFinishEventsForBackgroundURLSession:`.
+ 
+ @param block A block object to be executed once all messages enqueued for a session have been delivered. The block has no return value and takes a single argument: the session.
+ */
+- (void)setDidFinishEventsForBackgroundURLSessionBlock:(void (^)(NSURLSession *session))block;
+
+///-----------------------------------------------
+/// @name Setting Download Task Delegate Callbacks
+///-----------------------------------------------
+
+/**
+ Sets a block to be executed when a download task has completed a download, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didFinishDownloadingToURL:`.
+ 
+ @param block A block object to be executed when a download task has completed. The block returns the URL the download should be moved to, and takes three arguments: the session, the download task, and the temporary location of the downloaded file. If the file manager encounters an error while attempting to move the temporary file to the destination, an `AFURLSessionDownloadTaskDidFailToMoveFileNotification` will be posted, with the download task as its object, and the user info of the error.
+ */
+- (void)setDownloadTaskDidFinishDownloadingBlock:(NSURL * (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;
+
+/**
+ Sets a block to be executed periodically to track download progress, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`.
+ 
+ @param block A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes five arguments: the session, the download task, the number of bytes read since the last time the download progress block was called, the total bytes read, and the total bytes expected to be read during the request, as initially determined by the expected content size of the `NSHTTPURLResponse` object. This block may be called multiple times, and will execute on the session manager operation queue.
+ */
+- (void)setDownloadTaskDidWriteDataBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;
+
+/**
+ Sets a block to be executed when a download task has been resumed, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
+ 
+ @param block A block object to be executed when a download task has been resumed. The block has no return value and takes four arguments: the session, the download task, the file offset of the resumed download, and the total number of bytes expected to be downloaded.
+ */
+- (void)setDownloadTaskDidResumeBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;
+
+@end
+
+#endif
+
+///--------------------
+/// @name Notifications
+///--------------------
+
+/**
+ Posted when a task begins executing.
+ 
+ @deprecated Use `AFNetworkingTaskDidResumeNotification` instead.
+ */
+extern NSString * const AFNetworkingTaskDidStartNotification DEPRECATED_ATTRIBUTE;
+
+/**
+ Posted when a task resumes.
+ */
+extern NSString * const AFNetworkingTaskDidResumeNotification;
+
+/**
+ Posted when a task finishes executing. Includes a userInfo dictionary with additional information about the task.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteNotification` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishNotification DEPRECATED_ATTRIBUTE;
+
+/**
+ Posted when a task finishes executing. Includes a userInfo dictionary with additional information about the task.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteNotification;
+
+/**
+ Posted when a task suspends its execution.
+ */
+extern NSString * const AFNetworkingTaskDidSuspendNotification;
+
+/**
+ Posted when a session is invalidated.
+ */
+extern NSString * const AFURLSessionDidInvalidateNotification;
+
+/**
+ Posted when a session download task encountered an error when moving the temporary download file to a specified destination.
+ */
+extern NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;
+
+/**
+ The raw response data of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if response data exists for the task.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteResponseDataKey` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishResponseDataKey DEPRECATED_ATTRIBUTE;
+
+/**
+ The raw response data of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if response data exists for the task.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteResponseDataKey;
+
+/**
+ The serialized response object of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the response was serialized.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteSerializedResponseKey` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishSerializedResponseKey DEPRECATED_ATTRIBUTE;
+
+/**
+ The serialized response object of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the response was serialized.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;
+
+/**
+ The response serializer used to serialize the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the task has an associated response serializer.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteResponseSerializerKey` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishResponseSerializerKey DEPRECATED_ATTRIBUTE;
+
+/**
+ The response serializer used to serialize the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the task has an associated response serializer.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;
+
+/**
+ The file path associated with the download task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an the response data has been stored directly to disk.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteAssetPathKey` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishAssetPathKey DEPRECATED_ATTRIBUTE;
+
+/**
+ The file path associated with the download task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an the response data has been stored directly to disk.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteAssetPathKey;
+
+/**
+ Any error associated with the task, or the serialization of the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an error exists.
+ 
+ @deprecated Use `AFNetworkingTaskDidCompleteErrorKey` instead.
+ */
+extern NSString * const AFNetworkingTaskDidFinishErrorKey DEPRECATED_ATTRIBUTE;
+
+/**
+ Any error associated with the task, or the serialization of the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an error exists.
+ */
+extern NSString * const AFNetworkingTaskDidCompleteErrorKey;
diff --git a/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m
new file mode 100644
index 00000000000..0775c4da522
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m
@@ -0,0 +1,1036 @@
+// AFURLSessionManager.m
+// 
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFURLSessionManager.h"
+
+#if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000) || (defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090)
+
+static dispatch_queue_t url_session_manager_creation_queue() {
+    static dispatch_queue_t af_url_session_manager_creation_queue;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_url_session_manager_creation_queue = dispatch_queue_create("com.alamofire.networking.session.manager.creation", DISPATCH_QUEUE_SERIAL);
+    });
+
+    return af_url_session_manager_creation_queue;
+}
+
+static dispatch_queue_t url_session_manager_processing_queue() {
+    static dispatch_queue_t af_url_session_manager_processing_queue;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_url_session_manager_processing_queue = dispatch_queue_create("com.alamofire.networking.session.manager.processing", DISPATCH_QUEUE_CONCURRENT);
+    });
+
+    return af_url_session_manager_processing_queue;
+}
+
+static dispatch_group_t url_session_manager_completion_group() {
+    static dispatch_group_t af_url_session_manager_completion_group;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        af_url_session_manager_completion_group = dispatch_group_create();
+    });
+
+    return af_url_session_manager_completion_group;
+}
+
+NSString * const AFNetworkingTaskDidResumeNotification = @"com.alamofire.networking.task.resume";
+NSString * const AFNetworkingTaskDidCompleteNotification = @"com.alamofire.networking.task.complete";
+NSString * const AFNetworkingTaskDidSuspendNotification = @"com.alamofire.networking.task.suspend";
+NSString * const AFURLSessionDidInvalidateNotification = @"com.alamofire.networking.session.invalidate";
+NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @"com.alamofire.networking.session.download.file-manager-error";
+
+NSString * const AFNetworkingTaskDidStartNotification = @"com.alamofire.networking.task.resume"; // Deprecated
+NSString * const AFNetworkingTaskDidFinishNotification = @"com.alamofire.networking.task.complete"; // Deprecated
+
+NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @"com.alamofire.networking.task.complete.serializedresponse";
+NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @"com.alamofire.networking.task.complete.responseserializer";
+NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @"com.alamofire.networking.complete.finish.responsedata";
+NSString * const AFNetworkingTaskDidCompleteErrorKey = @"com.alamofire.networking.task.complete.error";
+NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @"com.alamofire.networking.task.complete.assetpath";
+
+NSString * const AFNetworkingTaskDidFinishSerializedResponseKey = @"com.alamofire.networking.task.complete.serializedresponse"; // Deprecated
+NSString * const AFNetworkingTaskDidFinishResponseSerializerKey = @"com.alamofire.networking.task.complete.responseserializer"; // Deprecated
+NSString * const AFNetworkingTaskDidFinishResponseDataKey = @"com.alamofire.networking.complete.finish.responsedata"; // Deprecated
+NSString * const AFNetworkingTaskDidFinishErrorKey = @"com.alamofire.networking.task.complete.error"; // Deprecated
+NSString * const AFNetworkingTaskDidFinishAssetPathKey = @"com.alamofire.networking.task.complete.assetpath"; // Deprecated
+
+static NSString * const AFURLSessionManagerLockName = @"com.alamofire.networking.session.manager.lock";
+
+static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3;
+
+static void * AFTaskStateChangedContext = &AFTaskStateChangedContext;
+
+typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);
+typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);
+
+typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);
+typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);
+typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);
+
+typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);
+typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);
+typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);
+
+typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);
+typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);
+typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);
+typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);
+
+typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
+typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
+typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);
+
+typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error);
+
+#pragma mark -
+
+@interface AFURLSessionManagerTaskDelegate : NSObject <NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate>
+@property (nonatomic, weak) AFURLSessionManager *manager;
+@property (nonatomic, strong) NSMutableData *mutableData;
+@property (nonatomic, strong) NSProgress *progress;
+@property (nonatomic, copy) NSURL *downloadFileURL;
+@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;
+@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;
+@end
+
+@implementation AFURLSessionManagerTaskDelegate
+
+- (instancetype)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    self.mutableData = [NSMutableData data];
+
+    self.progress = [NSProgress progressWithTotalUnitCount:0];
+
+    return self;
+}
+
+#pragma mark - NSURLSessionTaskDelegate
+
+- (void)URLSession:(__unused NSURLSession *)session
+              task:(__unused NSURLSessionTask *)task
+   didSendBodyData:(__unused int64_t)bytesSent
+    totalBytesSent:(int64_t)totalBytesSent
+totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
+{
+    self.progress.totalUnitCount = totalBytesExpectedToSend;
+    self.progress.completedUnitCount = totalBytesSent;
+}
+
+- (void)URLSession:(__unused NSURLSession *)session
+              task:(NSURLSessionTask *)task
+didCompleteWithError:(NSError *)error
+{
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    __strong AFURLSessionManager *manager = self.manager;
+
+    __block id responseObject = nil;
+
+    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
+    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;
+
+    if (self.downloadFileURL) {
+        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
+    } else if (self.mutableData) {
+        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = [NSData dataWithData:self.mutableData];
+    }
+
+    if (error) {
+        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;
+
+        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
+            if (self.completionHandler) {
+                self.completionHandler(task.response, responseObject, error);
+            }
+
+            dispatch_async(dispatch_get_main_queue(), ^{
+                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
+            });
+        });
+    } else {
+        dispatch_async(url_session_manager_processing_queue(), ^{
+            NSError *serializationError = nil;
+            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[NSData dataWithData:self.mutableData] error:&serializationError];
+
+            if (self.downloadFileURL) {
+                responseObject = self.downloadFileURL;
+            }
+
+            if (responseObject) {
+                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
+            }
+
+            if (serializationError) {
+                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
+            }
+
+            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
+                if (self.completionHandler) {
+                    self.completionHandler(task.response, responseObject, serializationError);
+                }
+                
+                dispatch_async(dispatch_get_main_queue(), ^{
+                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
+                });
+            });
+        });
+    }
+#pragma clang diagnostic pop
+}
+
+#pragma mark - NSURLSessionDataTaskDelegate
+
+- (void)URLSession:(__unused NSURLSession *)session
+          dataTask:(__unused NSURLSessionDataTask *)dataTask
+    didReceiveData:(NSData *)data
+{
+    [self.mutableData appendData:data];
+}
+
+#pragma mark - NSURLSessionDownloadTaskDelegate
+
+- (void)URLSession:(NSURLSession *)session
+      downloadTask:(NSURLSessionDownloadTask *)downloadTask
+didFinishDownloadingToURL:(NSURL *)location
+{
+    NSError *fileManagerError = nil;
+    self.downloadFileURL = nil;
+
+    if (self.downloadTaskDidFinishDownloading) {
+        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
+        if (self.downloadFileURL) {
+            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&fileManagerError];
+
+            if (fileManagerError) {
+                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];
+            }
+        }
+    }
+}
+
+- (void)URLSession:(__unused NSURLSession *)session
+      downloadTask:(__unused NSURLSessionDownloadTask *)downloadTask
+      didWriteData:(__unused int64_t)bytesWritten
+ totalBytesWritten:(int64_t)totalBytesWritten
+totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
+{
+    self.progress.totalUnitCount = totalBytesExpectedToWrite;
+    self.progress.completedUnitCount = totalBytesWritten;
+}
+
+- (void)URLSession:(__unused NSURLSession *)session
+      downloadTask:(__unused NSURLSessionDownloadTask *)downloadTask
+ didResumeAtOffset:(int64_t)fileOffset
+expectedTotalBytes:(int64_t)expectedTotalBytes {
+    self.progress.totalUnitCount = expectedTotalBytes;
+    self.progress.completedUnitCount = fileOffset;
+}
+
+@end
+
+#pragma mark -
+
+@interface AFURLSessionManager ()
+@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;
+@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;
+@property (readwrite, nonatomic, strong) NSURLSession *session;
+@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;
+@property (readwrite, nonatomic, strong) NSLock *lock;
+@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;
+@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;
+@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;
+@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;
+@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;
+@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;
+@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;
+@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;
+@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;
+@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;
+@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;
+@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;
+@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;
+@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;
+@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;
+@end
+
+@implementation AFURLSessionManager
+
+- (instancetype)init {
+    return [self initWithSessionConfiguration:nil];
+}
+
+- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    if (!configuration) {
+        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
+    }
+
+    self.sessionConfiguration = configuration;
+
+    self.operationQueue = [[NSOperationQueue alloc] init];
+    self.operationQueue.maxConcurrentOperationCount = 1;
+
+    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];
+
+    self.responseSerializer = [AFJSONResponseSerializer serializer];
+
+    self.securityPolicy = [AFSecurityPolicy defaultPolicy];
+
+    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
+
+    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];
+
+    self.lock = [[NSLock alloc] init];
+    self.lock.name = AFURLSessionManagerLockName;
+    
+    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
+        for (NSURLSessionDataTask *task in dataTasks) {
+            [self addDelegateForDataTask:task completionHandler:nil];
+        }
+        
+        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
+            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
+        }
+        
+        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
+            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
+        }
+    }];
+
+    return self;
+}
+
+#pragma mark -
+
+- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task {
+    NSParameterAssert(task);
+
+    AFURLSessionManagerTaskDelegate *delegate = nil;
+    [self.lock lock];
+    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];
+    [self.lock unlock];
+
+    return delegate;
+}
+
+- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
+            forTask:(NSURLSessionTask *)task
+{
+    NSParameterAssert(task);
+    NSParameterAssert(delegate);
+
+    [task addObserver:self forKeyPath:NSStringFromSelector(@selector(state)) options:(NSKeyValueObservingOptions)(NSKeyValueObservingOptionOld |NSKeyValueObservingOptionNew) context:AFTaskStateChangedContext];
+    [self.lock lock];
+    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
+    [self.lock unlock];
+}
+
+- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
+             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
+    delegate.manager = self;
+    delegate.completionHandler = completionHandler;
+
+    [self setDelegate:delegate forTask:dataTask];
+}
+
+- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask
+                        progress:(NSProgress * __autoreleasing *)progress
+               completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
+    delegate.manager = self;
+    delegate.completionHandler = completionHandler;
+
+    int64_t totalUnitCount = uploadTask.countOfBytesExpectedToSend;
+    if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
+        NSString *contentLength = [uploadTask.originalRequest valueForHTTPHeaderField:@"Content-Length"];
+        if(contentLength) {
+            totalUnitCount = (int64_t) [contentLength longLongValue];
+        }
+    }
+
+    delegate.progress = [NSProgress progressWithTotalUnitCount:totalUnitCount];
+    delegate.progress.pausingHandler = ^{
+        [uploadTask suspend];
+    };
+    delegate.progress.cancellationHandler = ^{
+        [uploadTask cancel];
+    };
+
+    if (progress) {
+        *progress = delegate.progress;
+    }
+
+    [self setDelegate:delegate forTask:uploadTask];
+}
+
+- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask
+                          progress:(NSProgress * __autoreleasing *)progress
+                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
+                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
+{
+    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
+    delegate.manager = self;
+    delegate.completionHandler = completionHandler;
+
+    if (destination) {
+        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) {
+            return destination(location, task.response);
+        };
+    }
+
+    if (progress) {
+        *progress = delegate.progress;
+    }
+
+    [self setDelegate:delegate forTask:downloadTask];
+}
+
+- (void)removeDelegateForTask:(NSURLSessionTask *)task {
+    NSParameterAssert(task);
+
+    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(state)) context:AFTaskStateChangedContext];
+    [self.lock lock];
+    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];
+    [self.lock unlock];
+}
+
+- (void)removeAllDelegates {
+    [self.lock lock];
+    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeAllObjects];
+    [self.lock unlock];
+}
+
+#pragma mark -
+
+- (NSArray *)tasksForKeyPath:(NSString *)keyPath {
+    __block NSArray *tasks = nil;
+    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
+        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
+            tasks = dataTasks;
+        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
+            tasks = uploadTasks;
+        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
+            tasks = downloadTasks;
+        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
+            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@"@unionOfArrays.self"];
+        }
+
+        dispatch_semaphore_signal(semaphore);
+    }];
+
+    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
+
+    return tasks;
+}
+
+- (NSArray *)tasks {
+    return [self tasksForKeyPath:NSStringFromSelector(_cmd)];
+}
+
+- (NSArray *)dataTasks {
+    return [self tasksForKeyPath:NSStringFromSelector(_cmd)];
+}
+
+- (NSArray *)uploadTasks {
+    return [self tasksForKeyPath:NSStringFromSelector(_cmd)];
+}
+
+- (NSArray *)downloadTasks {
+    return [self tasksForKeyPath:NSStringFromSelector(_cmd)];
+}
+
+#pragma mark -
+
+- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks {
+    dispatch_async(dispatch_get_main_queue(), ^{
+        if (cancelPendingTasks) {
+            [self.session invalidateAndCancel];
+        } else {
+            [self.session finishTasksAndInvalidate];
+        }
+    });
+}
+
+#pragma mark -
+
+- (void)setResponseSerializer:(id <AFURLResponseSerialization>)responseSerializer {
+    NSParameterAssert(responseSerializer);
+
+    _responseSerializer = responseSerializer;
+}
+
+#pragma mark -
+
+- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
+                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    __block NSURLSessionDataTask *dataTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        dataTask = [self.session dataTaskWithRequest:request];
+    });
+
+    [self addDelegateForDataTask:dataTask completionHandler:completionHandler];
+
+    return dataTask;
+}
+
+#pragma mark -
+
+- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
+                                         fromFile:(NSURL *)fileURL
+                                         progress:(NSProgress * __autoreleasing *)progress
+                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    __block NSURLSessionUploadTask *uploadTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL];
+    });
+
+    if (!uploadTask && self.attemptsToRecreateUploadTasksForBackgroundSessions && self.session.configuration.identifier) {
+        for (NSUInteger attempts = 0; !uploadTask && attempts < AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) {
+            uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL];
+        }
+    }
+
+    [self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];
+
+    return uploadTask;
+}
+
+- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
+                                         fromData:(NSData *)bodyData
+                                         progress:(NSProgress * __autoreleasing *)progress
+                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    __block NSURLSessionUploadTask *uploadTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData];
+    });
+
+    [self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];
+
+    return uploadTask;
+}
+
+- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request
+                                                 progress:(NSProgress * __autoreleasing *)progress
+                                        completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
+{
+    __block NSURLSessionUploadTask *uploadTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        uploadTask = [self.session uploadTaskWithStreamedRequest:request];
+    });
+
+    [self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];
+
+    return uploadTask;
+}
+
+#pragma mark -
+
+- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request
+                                             progress:(NSProgress * __autoreleasing *)progress
+                                          destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
+                                    completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
+{
+    __block NSURLSessionDownloadTask *downloadTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        downloadTask = [self.session downloadTaskWithRequest:request];
+    });
+
+    [self addDelegateForDownloadTask:downloadTask progress:progress destination:destination completionHandler:completionHandler];
+
+    return downloadTask;
+}
+
+- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData
+                                                progress:(NSProgress * __autoreleasing *)progress
+                                             destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
+                                       completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
+{
+    __block NSURLSessionDownloadTask *downloadTask = nil;
+    dispatch_sync(url_session_manager_creation_queue(), ^{
+        downloadTask = [self.session downloadTaskWithResumeData:resumeData];
+    });
+
+    [self addDelegateForDownloadTask:downloadTask progress:progress destination:destination completionHandler:completionHandler];
+
+    return downloadTask;
+}
+
+#pragma mark -
+
+- (NSProgress *)uploadProgressForTask:(NSURLSessionUploadTask *)uploadTask {
+    return [[self delegateForTask:uploadTask] progress];
+}
+
+- (NSProgress *)downloadProgressForTask:(NSURLSessionDownloadTask *)downloadTask {
+    return [[self delegateForTask:downloadTask] progress];
+}
+
+#pragma mark -
+
+- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block {
+    self.sessionDidBecomeInvalid = block;
+}
+
+- (void)setSessionDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block {
+    self.sessionDidReceiveAuthenticationChallenge = block;
+}
+
+- (void)setDidFinishEventsForBackgroundURLSessionBlock:(void (^)(NSURLSession *session))block {
+    self.didFinishEventsForBackgroundURLSession = block;
+}
+
+#pragma mark -
+
+- (void)setTaskNeedNewBodyStreamBlock:(NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block {
+    self.taskNeedNewBodyStream = block;
+}
+
+- (void)setTaskWillPerformHTTPRedirectionBlock:(NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block {
+    self.taskWillPerformHTTPRedirection = block;
+}
+
+- (void)setTaskDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block {
+    self.taskDidReceiveAuthenticationChallenge = block;
+}
+
+- (void)setTaskDidSendBodyDataBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block {
+    self.taskDidSendBodyData = block;
+}
+
+- (void)setTaskDidCompleteBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, NSError *error))block {
+    self.taskDidComplete = block;
+}
+
+#pragma mark -
+
+- (void)setDataTaskDidReceiveResponseBlock:(NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block {
+    self.dataTaskDidReceiveResponse = block;
+}
+
+- (void)setDataTaskDidBecomeDownloadTaskBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block {
+    self.dataTaskDidBecomeDownloadTask = block;
+}
+
+- (void)setDataTaskDidReceiveDataBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block {
+    self.dataTaskDidReceiveData = block;
+}
+
+- (void)setDataTaskWillCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block {
+    self.dataTaskWillCacheResponse = block;
+}
+
+#pragma mark -
+
+- (void)setDownloadTaskDidFinishDownloadingBlock:(NSURL * (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block {
+    self.downloadTaskDidFinishDownloading = block;
+}
+
+- (void)setDownloadTaskDidWriteDataBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block {
+    self.downloadTaskDidWriteData = block;
+}
+
+- (void)setDownloadTaskDidResumeBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block {
+    self.downloadTaskDidResume = block;
+}
+
+#pragma mark - NSObject
+
+- (NSString *)description {
+    return [NSString stringWithFormat:@"<%@: %p, session: %@, operationQueue: %@>", NSStringFromClass([self class]), self, self.session, self.operationQueue];
+}
+
+- (BOOL)respondsToSelector:(SEL)selector {
+    if (selector == @selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)) {
+        return self.taskWillPerformHTTPRedirection != nil;
+    } else if (selector == @selector(URLSession:dataTask:didReceiveResponse:completionHandler:)) {
+        return self.dataTaskDidReceiveResponse != nil;
+    } else if (selector == @selector(URLSession:dataTask:willCacheResponse:completionHandler:)) {
+        return self.dataTaskWillCacheResponse != nil;
+    } else if (selector == @selector(URLSessionDidFinishEventsForBackgroundURLSession:)) {
+        return self.didFinishEventsForBackgroundURLSession != nil;
+    }
+
+    return [[self class] instancesRespondToSelector:selector];
+}
+
+#pragma mark - NSKeyValueObserving
+
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(id)object
+                        change:(NSDictionary *)change
+                       context:(void *)context
+{
+    if (context == AFTaskStateChangedContext && [keyPath isEqualToString:@"state"]) {
+        if (change[NSKeyValueChangeOldKey] && change[NSKeyValueChangeNewKey] && [change[NSKeyValueChangeNewKey] isEqual:change[NSKeyValueChangeOldKey]]) {
+            return;
+        }
+
+        NSString *notificationName = nil;
+        switch ([(NSURLSessionTask *)object state]) {
+            case NSURLSessionTaskStateRunning:
+                notificationName = AFNetworkingTaskDidResumeNotification;
+                break;
+            case NSURLSessionTaskStateSuspended:
+                notificationName = AFNetworkingTaskDidSuspendNotification;
+                break;
+            case NSURLSessionTaskStateCompleted:
+                // AFNetworkingTaskDidFinishNotification posted by task completion handlers
+            default:
+                break;
+        }
+
+        if (notificationName) {
+            dispatch_async(dispatch_get_main_queue(), ^{
+                [[NSNotificationCenter defaultCenter] postNotificationName:notificationName object:object];
+            });
+        }
+    } else {
+        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
+    }
+}
+
+#pragma mark - NSURLSessionDelegate
+
+- (void)URLSession:(NSURLSession *)session
+didBecomeInvalidWithError:(NSError *)error
+{
+    if (self.sessionDidBecomeInvalid) {
+        self.sessionDidBecomeInvalid(session, error);
+    }
+
+    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
+        NSArray *tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@"@unionOfArrays.self"];
+        for (NSURLSessionTask *task in tasks) {
+            [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(state)) context:AFTaskStateChangedContext];
+        }
+
+        [self removeAllDelegates];
+    }];
+
+    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
+}
+
+- (void)URLSession:(NSURLSession *)session
+didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
+ completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
+{
+    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
+    __block NSURLCredential *credential = nil;
+
+    if (self.sessionDidReceiveAuthenticationChallenge) {
+        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &credential);
+    } else {
+        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
+            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
+                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
+                if (credential) {
+                    disposition = NSURLSessionAuthChallengeUseCredential;
+                } else {
+                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;
+                }
+            } else {
+                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
+            }
+        } else {
+            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
+        }
+    }
+
+    if (completionHandler) {
+        completionHandler(disposition, credential);
+    }
+}
+
+#pragma mark - NSURLSessionTaskDelegate
+
+- (void)URLSession:(NSURLSession *)session
+              task:(NSURLSessionTask *)task
+willPerformHTTPRedirection:(NSHTTPURLResponse *)response
+        newRequest:(NSURLRequest *)request
+ completionHandler:(void (^)(NSURLRequest *))completionHandler
+{
+    NSURLRequest *redirectRequest = request;
+
+    if (self.taskWillPerformHTTPRedirection) {
+        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);
+    }
+
+    if (completionHandler) {
+        completionHandler(redirectRequest);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+              task:(NSURLSessionTask *)task
+didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
+ completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
+{
+    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
+    __block NSURLCredential *credential = nil;
+
+    if (self.taskDidReceiveAuthenticationChallenge) {
+        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &credential);
+    } else {
+        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
+            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
+                disposition = NSURLSessionAuthChallengeUseCredential;
+                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
+            } else {
+                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
+            }
+        } else {
+            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
+        }
+    }
+
+    if (completionHandler) {
+        completionHandler(disposition, credential);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+              task:(NSURLSessionTask *)task
+ needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler
+{
+    NSInputStream *inputStream = nil;
+    
+    if (self.taskNeedNewBodyStream) {
+        inputStream = self.taskNeedNewBodyStream(session, task);
+    } else if (task.originalRequest.HTTPBodyStream && [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) {
+        inputStream = [task.originalRequest.HTTPBodyStream copy];
+    }
+
+    if (completionHandler) {
+        completionHandler(inputStream);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+              task:(NSURLSessionTask *)task
+   didSendBodyData:(int64_t)bytesSent
+    totalBytesSent:(int64_t)totalBytesSent
+totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
+{
+    
+    int64_t totalUnitCount = totalBytesExpectedToSend;
+    if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
+        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@"Content-Length"];
+        if(contentLength) {
+            totalUnitCount = (int64_t) [contentLength longLongValue];
+        }
+    }
+    
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];
+    [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalUnitCount];
+
+    if (self.taskDidSendBodyData) {
+        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+              task:(NSURLSessionTask *)task
+didCompleteWithError:(NSError *)error
+{
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];
+
+    // delegate may be nil when completing a task in the background
+    if (delegate) {
+        [delegate URLSession:session task:task didCompleteWithError:error];
+
+        [self removeDelegateForTask:task];
+    }
+
+    if (self.taskDidComplete) {
+        self.taskDidComplete(session, task, error);
+    }
+
+}
+
+#pragma mark - NSURLSessionDataDelegate
+
+- (void)URLSession:(NSURLSession *)session
+          dataTask:(NSURLSessionDataTask *)dataTask
+didReceiveResponse:(NSURLResponse *)response
+ completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler
+{
+    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;
+
+    if (self.dataTaskDidReceiveResponse) {
+        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);
+    }
+
+    if (completionHandler) {
+        completionHandler(disposition);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+          dataTask:(NSURLSessionDataTask *)dataTask
+didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask
+{
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
+    if (delegate) {
+        [self removeDelegateForTask:dataTask];
+        [self setDelegate:delegate forTask:downloadTask];
+    }
+
+    if (self.dataTaskDidBecomeDownloadTask) {
+        self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+          dataTask:(NSURLSessionDataTask *)dataTask
+    didReceiveData:(NSData *)data
+{
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
+    [delegate URLSession:session dataTask:dataTask didReceiveData:data];
+
+    if (self.dataTaskDidReceiveData) {
+        self.dataTaskDidReceiveData(session, dataTask, data);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+          dataTask:(NSURLSessionDataTask *)dataTask
+ willCacheResponse:(NSCachedURLResponse *)proposedResponse
+ completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
+{
+    NSCachedURLResponse *cachedResponse = proposedResponse;
+
+    if (self.dataTaskWillCacheResponse) {
+        cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);
+    }
+
+    if (completionHandler) {
+        completionHandler(cachedResponse);
+    }
+}
+
+- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
+    if (self.didFinishEventsForBackgroundURLSession) {
+        dispatch_async(dispatch_get_main_queue(), ^{
+            self.didFinishEventsForBackgroundURLSession(session);
+        });
+    }
+}
+
+#pragma mark - NSURLSessionDownloadDelegate
+
+- (void)URLSession:(NSURLSession *)session
+      downloadTask:(NSURLSessionDownloadTask *)downloadTask
+didFinishDownloadingToURL:(NSURL *)location
+{
+    if (self.downloadTaskDidFinishDownloading) {
+        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
+        if (fileURL) {
+            NSError *error = nil;
+            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&error];
+            if (error) {
+                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
+            }
+
+            return;
+        }
+    }
+	
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
+    if (delegate) {
+        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+      downloadTask:(NSURLSessionDownloadTask *)downloadTask
+      didWriteData:(int64_t)bytesWritten
+ totalBytesWritten:(int64_t)totalBytesWritten
+totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
+{
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
+    [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];
+
+    if (self.downloadTaskDidWriteData) {
+        self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
+    }
+}
+
+- (void)URLSession:(NSURLSession *)session
+      downloadTask:(NSURLSessionDownloadTask *)downloadTask
+ didResumeAtOffset:(int64_t)fileOffset
+expectedTotalBytes:(int64_t)expectedTotalBytes
+{
+    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
+    [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];
+
+    if (self.downloadTaskDidResume) {
+        self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);
+    }
+}
+
+#pragma mark - NSSecureCoding
+
++ (BOOL)supportsSecureCoding {
+    return YES;
+}
+
+- (id)initWithCoder:(NSCoder *)decoder {
+    NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@"sessionConfiguration"];
+
+    self = [self initWithSessionConfiguration:configuration];
+    if (!self) {
+        return nil;
+    }
+
+    return self;
+}
+
+- (void)encodeWithCoder:(NSCoder *)coder {
+    [coder encodeObject:self.session.configuration forKey:@"sessionConfiguration"];
+}
+
+#pragma mark - NSCopying
+
+- (id)copyWithZone:(NSZone *)zone {
+    return [[[self class] allocWithZone:zone] initWithSessionConfiguration:self.session.configuration];
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/LICENSE b/cocoapods/Pods/AFNetworking/LICENSE
new file mode 100644
index 00000000000..0616192d003
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/cocoapods/Pods/AFNetworking/README.md b/cocoapods/Pods/AFNetworking/README.md
new file mode 100644
index 00000000000..77d285e27c3
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/README.md
@@ -0,0 +1,383 @@
+<p align="center" >
+  <img src="https://raw.github.com/AFNetworking/AFNetworking/assets/afnetworking-logo.png" alt="AFNetworking" title="AFNetworking">
+</p>
+
+[![Build Status](https://travis-ci.org/AFNetworking/AFNetworking.svg)](https://travis-ci.org/AFNetworking/AFNetworking)
+
+AFNetworking is a delightful networking library for iOS and Mac OS X. It's built on top of the [Foundation URL Loading System](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html), extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.
+
+Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.
+
+Choose AFNetworking for your next project, or migrate over your existing projectsyou'll be happy you did!
+
+## How To Get Started
+
+- [Download AFNetworking](https://github.com/AFNetworking/AFNetworking/archive/master.zip) and try out the included Mac and iPhone example apps
+- Read the ["Getting Started" guide](https://github.com/AFNetworking/AFNetworking/wiki/Getting-Started-with-AFNetworking), [FAQ](https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-FAQ), or [other articles on the Wiki](https://github.com/AFNetworking/AFNetworking/wiki)
+- Check out the [documentation](http://cocoadocs.org/docsets/AFNetworking/2.0.0/) for a comprehensive look at all of the APIs available in AFNetworking
+- Read the [AFNetworking 2.0 Migration Guide](https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide) for an overview of the architectural changes from 1.0.
+
+## Communication
+
+- If you **need help**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/afnetworking). (Tag 'afnetworking')
+- If you'd like to **ask a general question**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/afnetworking).
+- If you **found a bug**, open an issue.
+- If you **have a feature request**, open an issue.
+- If you **want to contribute**, submit a pull request.
+
+### Installation with CocoaPods
+
+[CocoaPods](http://cocoapods.org) is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries like AFNetworking in your projects. See the ["Getting Started" guide for more information](https://github.com/AFNetworking/AFNetworking/wiki/Getting-Started-with-AFNetworking).
+
+#### Podfile
+
+```ruby
+platform :ios, '7.0'
+pod "AFNetworking", "~> 2.0"
+```
+
+## Requirements
+
+| AFNetworking Version | Minimum iOS Target  | Minimum OS X Target  |                                   Notes                                   |
+|:--------------------:|:---------------------------:|:----------------------------:|:-------------------------------------------------------------------------:|
+|          2.x         |            iOS 6            |           OS X 10.8          | Xcode 5 is required. `AFHTTPSessionManager` requires iOS 7 or OS X 10.9. |
+|          [1.x](https://github.com/AFNetworking/AFNetworking/tree/1.x)         |            iOS 5            |         Mac OS X 10.7        |                                                                           |
+|        [0.10.x](https://github.com/AFNetworking/AFNetworking/tree/0.10.x)        |            iOS 4            |         Mac OS X 10.6        |                                                                           |
+
+(OS X projects must support [64-bit with modern Cocoa runtime](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html)).
+
+## Architecture
+
+### NSURLConnection
+
+- `AFURLConnectionOperation`
+- `AFHTTPRequestOperation`
+- `AFHTTPRequestOperationManager`
+
+### NSURLSession _(iOS 7 / Mac OS X 10.9)_
+
+- `AFURLSessionManager`
+- `AFHTTPSessionManager`
+
+### Serialization
+
+* `<AFURLRequestSerialization>`
+  - `AFHTTPRequestSerializer`
+  - `AFJSONRequestSerializer`
+  - `AFPropertyListRequestSerializer`
+* `<AFURLResponseSerialization>`
+  - `AFHTTPResponseSerializer`
+  - `AFJSONResponseSerializer`
+  - `AFXMLParserResponseSerializer`
+  - `AFXMLDocumentResponseSerializer` _(Mac OS X)_
+  - `AFPropertyListResponseSerializer`
+  - `AFImageResponseSerializer`
+  - `AFCompoundResponseSerializer`
+
+### Additional Functionality
+
+- `AFSecurityPolicy`
+- `AFNetworkReachabilityManager`
+
+## Usage
+
+### HTTP Request Operation Manager
+
+`AFHTTPRequestOperationManager` encapsulates the common patterns of communicating with a web application over HTTP, including request creation, response serialization, network reachability monitoring, and security, as well as request operation management.
+
+#### `GET` Request
+
+```objective-c
+AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
+[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
+    NSLog(@"JSON: %@", responseObject);
+} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+    NSLog(@"Error: %@", error);
+}];
+```
+
+#### `POST` URL-Form-Encoded Request
+
+```objective-c
+AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
+NSDictionary *parameters = @{@"foo": @"bar"};
+[manager POST:@"http://example.com/resources.json" parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
+    NSLog(@"JSON: %@", responseObject);
+} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+    NSLog(@"Error: %@", error);
+}];
+```
+
+#### `POST` Multi-Part Request
+
+```objective-c
+AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
+NSDictionary *parameters = @{@"foo": @"bar"};
+NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
+[manager POST:@"http://example.com/resources.json" parameters:parameters constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
+    [formData appendPartWithFileURL:filePath name:@"image" error:nil];
+} success:^(AFHTTPRequestOperation *operation, id responseObject) {
+    NSLog(@"Success: %@", responseObject);
+} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+    NSLog(@"Error: %@", error);
+}];
+```
+
+---
+
+### AFURLSessionManager
+
+`AFURLSessionManager` creates and manages an `NSURLSession` object based on a specified `NSURLSessionConfiguration` object, which conforms to `<NSURLSessionTaskDelegate>`, `<NSURLSessionDataDelegate>`, `<NSURLSessionDownloadDelegate>`, and `<NSURLSessionDelegate>`.
+
+#### Creating a Download Task
+
+```objective-c
+NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
+AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
+
+NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];
+NSURLRequest *request = [NSURLRequest requestWithURL:URL];
+
+NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
+    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
+    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
+} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
+    NSLog(@"File downloaded to: %@", filePath);
+}];
+[downloadTask resume];
+```
+
+#### Creating an Upload Task
+
+```objective-c
+NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
+AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
+
+NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
+NSURLRequest *request = [NSURLRequest requestWithURL:URL];
+
+NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
+NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
+    if (error) {
+        NSLog(@"Error: %@", error);
+    } else {
+        NSLog(@"Success: %@ %@", response, responseObject);
+    }
+}];
+[uploadTask resume];
+```
+
+#### Creating an Upload Task for a Multi-Part Request, with Progress
+
+```objective-c
+NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
+        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil];
+    } error:nil];
+
+AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
+NSProgress *progress = nil;
+
+NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
+    if (error) {
+        NSLog(@"Error: %@", error);
+    } else {
+        NSLog(@"%@ %@", response, responseObject);
+    }
+}];
+
+[uploadTask resume];
+```
+
+#### Creating a Data Task
+
+```objective-c
+NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
+AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
+
+NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
+NSURLRequest *request = [NSURLRequest requestWithURL:URL];
+
+NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
+    if (error) {
+        NSLog(@"Error: %@", error);
+    } else {
+        NSLog(@"%@ %@", response, responseObject);
+    }
+}];
+[dataTask resume];
+```
+
+---
+
+### Request Serialization
+
+Request serializers create requests from URL strings, encoding parameters as either a query string or HTTP body.
+
+```objective-c
+NSString *URLString = @"http://example.com";
+NSDictionary *parameters = @{@"foo": @"bar", @"baz": @[@1, @2, @3]};
+```
+
+#### Query String Parameter Encoding
+
+```objective-c
+[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil];
+```
+
+    GET http://example.com?foo=bar&baz[]=1&baz[]=2&baz[]=3
+
+#### URL Form Parameter Encoding
+
+```objective-c
+[[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];
+```
+
+    POST http://example.com/
+    Content-Type: application/x-www-form-urlencoded
+
+    foo=bar&baz[]=1&baz[]=2&baz[]=3
+
+#### JSON Parameter Encoding
+
+```objective-c
+[[AFJSONRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];
+```
+
+    POST http://example.com/
+    Content-Type: application/json
+
+    {"foo": "bar", "baz": [1,2,3]}
+
+---
+
+### Network Reachability Manager
+
+`AFNetworkReachabilityManager` monitors the reachability of domains, and addresses for both WWAN and WiFi network interfaces.
+
+#### Shared Network Reachability
+
+```objective-c
+[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
+    NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status));
+}];
+```
+
+#### HTTP Manager Reachability
+
+```objective-c
+NSURL *baseURL = [NSURL URLWithString:@"http://example.com/"];
+AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];
+
+NSOperationQueue *operationQueue = manager.operationQueue;
+[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
+    switch (status) {
+        case AFNetworkReachabilityStatusReachableViaWWAN:
+        case AFNetworkReachabilityStatusReachableViaWiFi:
+            [operationQueue setSuspended:NO];
+            break;
+        case AFNetworkReachabilityStatusNotReachable:
+        default:
+            [operationQueue setSuspended:YES];
+            break;
+    }
+}];
+
+[manager.reachabilityManager startMonitoring];
+```
+
+---
+
+### Security Policy
+
+`AFSecurityPolicy` evaluates server trust against pinned X.509 certificates and public keys over secure connections.
+
+Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an HTTPS connection with SSL pinning configured and enabled.
+
+#### Allowing Invalid SSL Certificates
+
+```objective-c
+AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
+manager.securityPolicy.allowInvalidCertificates = YES; // not recommended for production
+```
+
+---
+
+### AFHTTPRequestOperation
+
+`AFHTTPRequestOperation` is a subclass of `AFURLConnectionOperation` for requests using the HTTP or HTTPS protocols. It encapsulates the concept of acceptable status codes and content types, which determine the success or failure of a request.
+
+Although `AFHTTPRequestOperationManager` is usually the best way to go about making requests, `AFHTTPRequestOperation` can be used by itself.
+
+#### `GET` with `AFHTTPRequestOperation`
+
+```objective-c
+NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"];
+NSURLRequest *request = [NSURLRequest requestWithURL:URL];
+AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
+op.responseSerializer = [AFJSONResponseSerializer serializer];
+[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
+    NSLog(@"JSON: %@", responseObject);
+} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+    NSLog(@"Error: %@", error);
+}];
+[[NSOperationQueue mainQueue] addOperation:op];
+```
+
+#### Batch of Operations
+
+```objective-c
+NSMutableArray *mutableOperations = [NSMutableArray array];
+for (NSURL *fileURL in filesToUpload) {
+    NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
+        [formData appendPartWithFileURL:fileURL name:@"images[]" error:nil];
+    }];
+
+    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
+
+    [mutableOperations addObject:operation];
+}
+
+NSArray *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
+    NSLog(@"%lu of %lu complete", numberOfFinishedOperations, totalNumberOfOperations);
+} completionBlock:^(NSArray *operations) {
+    NSLog(@"All operations in batch complete");
+}];
+[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
+```
+
+## Unit Tests
+
+AFNetworking includes a suite of unit tests within the Tests subdirectory. In order to run the unit tests, you must install the testing dependencies via [CocoaPods](http://cocoapods.org/):
+
+    $ cd Tests
+    $ pod install
+
+Once testing dependencies are installed, you can execute the test suite via the 'iOS Tests' and 'OS X Tests' schemes within Xcode.
+
+### Running Tests from the Command Line
+
+Tests can also be run from the command line or within a continuous integration environment. The [`xcpretty`](https://github.com/mneorr/xcpretty) utility needs to be installed before running the tests from the command line:
+
+    $ gem install xcpretty
+
+Once `xcpretty` is installed, you can execute the suite via `rake test`.
+
+## Credits
+
+AFNetworking was originally created by [Scott Raymond](https://github.com/sco/) and [Mattt Thompson](https://github.com/mattt/) in the development of [Gowalla for iPhone](http://en.wikipedia.org/wiki/Gowalla).
+
+AFNetworking's logo was designed by [Alan Defibaugh](http://www.alandefibaugh.com/).
+
+And most of all, thanks to AFNetworking's [growing list of contributors](https://github.com/AFNetworking/AFNetworking/contributors).
+
+## Contact
+
+Follow AFNetworking on Twitter ([@AFNetworking](https://twitter.com/AFNetworking))
+
+### Maintainers
+
+- [Mattt Thompson](http://github.com/mattt) ([@mattt](https://twitter.com/mattt))
+
+## License
+
+AFNetworking is available under the MIT license. See the LICENSE file for more info.
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h
new file mode 100644
index 00000000000..312d680e0d3
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h
@@ -0,0 +1,76 @@
+// AFNetworkActivityIndicatorManager.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+/**
+ `AFNetworkActivityIndicatorManager` manages the state of the network activity indicator in the status bar. When enabled, it will listen for notifications indicating that a network request operation has started or finished, and start or stop animating the indicator accordingly. The number of active requests is incremented and decremented much like a stack or a semaphore, and the activity indicator will animate so long as that number is greater than zero.
+
+ You should enable the shared instance of `AFNetworkActivityIndicatorManager` when your application finishes launching. In `AppDelegate application:didFinishLaunchingWithOptions:` you can do so with the following code:
+
+    [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES];
+
+ By setting `isNetworkActivityIndicatorVisible` to `YES` for `sharedManager`, the network activity indicator will show and hide automatically as requests start and finish. You should not ever need to call `incrementActivityCount` or `decrementActivityCount` yourself.
+
+ See the Apple Human Interface Guidelines section about the Network Activity Indicator for more information:
+ http://developer.apple.com/library/iOS/#documentation/UserExperience/Conceptual/MobileHIG/UIElementGuidelines/UIElementGuidelines.html#//apple_ref/doc/uid/TP40006556-CH13-SW44
+ */
+@interface AFNetworkActivityIndicatorManager : NSObject
+
+/**
+ A Boolean value indicating whether the manager is enabled.
+
+ If YES, the manager will change status bar network activity indicator according to network operation notifications it receives. The default value is NO.
+ */
+@property (nonatomic, assign, getter = isEnabled) BOOL enabled;
+
+/**
+ A Boolean value indicating whether the network activity indicator is currently displayed in the status bar.
+ */
+@property (readonly, nonatomic, assign) BOOL isNetworkActivityIndicatorVisible;
+
+/**
+ Returns the shared network activity indicator manager object for the system.
+
+ @return The systemwide network activity indicator manager.
+ */
++ (instancetype)sharedManager;
+
+/**
+ Increments the number of active network requests. If this number was zero before incrementing, this will start animating the status bar network activity indicator.
+ */
+- (void)incrementActivityCount;
+
+/**
+ Decrements the number of active network requests. If this number becomes zero after decrementing, this will stop animating the status bar network activity indicator.
+ */
+- (void)decrementActivityCount;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.m
new file mode 100644
index 00000000000..c2d855a59c4
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.m
@@ -0,0 +1,171 @@
+// AFNetworkActivityIndicatorManager.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "AFNetworkActivityIndicatorManager.h"
+
+#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED)
+
+#import "AFHTTPRequestOperation.h"
+
+#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000
+#import "AFURLSessionManager.h"
+#endif
+
+static NSTimeInterval const kAFNetworkActivityIndicatorInvisibilityDelay = 0.17;
+
+static NSURLRequest * AFNetworkRequestFromNotification(NSNotification *notification) {
+    if ([[notification object] isKindOfClass:[AFURLConnectionOperation class]]) {
+        return [(AFURLConnectionOperation *)[notification object] request];
+    }
+
+#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000
+    if ([[notification object] respondsToSelector:@selector(originalRequest)]) {
+        return [(NSURLSessionTask *)[notification object] originalRequest];
+    }
+#endif
+
+    return nil;
+}
+
+@interface AFNetworkActivityIndicatorManager ()
+@property (readwrite, nonatomic, assign) NSInteger activityCount;
+@property (readwrite, nonatomic, strong) NSTimer *activityIndicatorVisibilityTimer;
+@property (readonly, nonatomic, getter = isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;
+
+- (void)updateNetworkActivityIndicatorVisibility;
+- (void)updateNetworkActivityIndicatorVisibilityDelayed;
+@end
+
+@implementation AFNetworkActivityIndicatorManager
+@dynamic networkActivityIndicatorVisible;
+
++ (instancetype)sharedManager {
+    static AFNetworkActivityIndicatorManager *_sharedManager = nil;
+    static dispatch_once_t oncePredicate;
+    dispatch_once(&oncePredicate, ^{
+        _sharedManager = [[self alloc] init];
+    });
+
+    return _sharedManager;
+}
+
++ (NSSet *)keyPathsForValuesAffectingIsNetworkActivityIndicatorVisible {
+    return [NSSet setWithObject:@"activityCount"];
+}
+
+- (id)init {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkRequestDidStart:) name:AFNetworkingOperationDidStartNotification object:nil];
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkRequestDidFinish:) name:AFNetworkingOperationDidFinishNotification object:nil];
+
+#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkRequestDidStart:) name:AFNetworkingTaskDidResumeNotification object:nil];
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkRequestDidFinish:) name:AFNetworkingTaskDidSuspendNotification object:nil];
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkRequestDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:nil];
+#endif
+
+    return self;
+}
+
+- (void)dealloc {
+    [[NSNotificationCenter defaultCenter] removeObserver:self];
+
+    [_activityIndicatorVisibilityTimer invalidate];
+}
+
+- (void)updateNetworkActivityIndicatorVisibilityDelayed {
+    if (self.enabled) {
+        // Delay hiding of activity indicator for a short interval, to avoid flickering
+        if (![self isNetworkActivityIndicatorVisible]) {
+            [self.activityIndicatorVisibilityTimer invalidate];
+            self.activityIndicatorVisibilityTimer = [NSTimer timerWithTimeInterval:kAFNetworkActivityIndicatorInvisibilityDelay target:self selector:@selector(updateNetworkActivityIndicatorVisibility) userInfo:nil repeats:NO];
+            [[NSRunLoop mainRunLoop] addTimer:self.activityIndicatorVisibilityTimer forMode:NSRunLoopCommonModes];
+        } else {
+            [self performSelectorOnMainThread:@selector(updateNetworkActivityIndicatorVisibility) withObject:nil waitUntilDone:NO modes:@[NSRunLoopCommonModes]];
+        }
+    }
+}
+
+- (BOOL)isNetworkActivityIndicatorVisible {
+    return self.activityCount > 0;
+}
+
+- (void)updateNetworkActivityIndicatorVisibility {
+    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:[self isNetworkActivityIndicatorVisible]];
+}
+
+- (void)setActivityCount:(NSInteger)activityCount {
+	@synchronized(self) {
+		_activityCount = activityCount;
+	}
+    
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self updateNetworkActivityIndicatorVisibilityDelayed];
+    });
+}
+
+- (void)incrementActivityCount {
+    [self willChangeValueForKey:@"activityCount"];
+	@synchronized(self) {
+		_activityCount++;
+	}
+    [self didChangeValueForKey:@"activityCount"];
+    
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self updateNetworkActivityIndicatorVisibilityDelayed];
+    });
+}
+
+- (void)decrementActivityCount {
+    [self willChangeValueForKey:@"activityCount"];
+	@synchronized(self) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+		_activityCount = MAX(_activityCount - 1, 0);
+#pragma clang diagnostic pop
+	}
+    [self didChangeValueForKey:@"activityCount"];
+    
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self updateNetworkActivityIndicatorVisibilityDelayed];
+    });
+}
+
+- (void)networkRequestDidStart:(NSNotification *)notification {
+    if ([AFNetworkRequestFromNotification(notification) URL]) {
+        [self incrementActivityCount];
+    }
+}
+
+- (void)networkRequestDidFinish:(NSNotification *)notification {
+    if ([AFNetworkRequestFromNotification(notification) URL]) {
+        [self decrementActivityCount];
+    }
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h
new file mode 100644
index 00000000000..1c1f8dd6f8d
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h
@@ -0,0 +1,64 @@
+// UIActivityIndicatorView+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@class AFURLConnectionOperation;
+
+/**
+ This category adds methods to the UIKit framework's `UIActivityIndicatorView` class. The methods in this category provide support for automatically starting and stopping animation depending on the loading state of a request operation or session task.
+ */
+@interface UIActivityIndicatorView (AFNetworking)
+
+///----------------------------------
+/// @name Animating for Session Tasks
+///----------------------------------
+
+/**
+ Binds the animating state to the state of the specified task.
+
+ @param task The task. If `nil`, automatic updating from any previously specified operation will be disabled.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task;
+#endif
+
+///---------------------------------------
+/// @name Animating for Request Operations
+///---------------------------------------
+
+/**
+ Binds the animating state to the execution state of the specified operation.
+ 
+ @param operation The operation. If `nil`, automatic updating from any previously specified operation will be disabled.
+ */
+- (void)setAnimatingWithStateOfOperation:(AFURLConnectionOperation *)operation;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.m
new file mode 100644
index 00000000000..6627dbb1b83
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.m
@@ -0,0 +1,97 @@
+// UIActivityIndicatorView+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIActivityIndicatorView+AFNetworking.h"
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFHTTPRequestOperation.h"
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+#import "AFURLSessionManager.h"
+#endif
+
+@implementation UIActivityIndicatorView (AFNetworking)
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task {
+    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil];
+
+    if (task) {
+        if (task.state != NSURLSessionTaskStateCompleted) {
+            if (task.state == NSURLSessionTaskStateRunning) {
+                [self startAnimating];
+            } else {
+                [self stopAnimating];
+            }
+
+            [notificationCenter addObserver:self selector:@selector(af_startAnimating) name:AFNetworkingTaskDidResumeNotification object:task];
+            [notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidCompleteNotification object:task];
+            [notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidSuspendNotification object:task];
+        }
+    }
+}
+#endif
+
+#pragma mark -
+
+- (void)setAnimatingWithStateOfOperation:(AFURLConnectionOperation *)operation {
+    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+
+    [notificationCenter removeObserver:self name:AFNetworkingOperationDidStartNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingOperationDidFinishNotification object:nil];
+
+    if (operation) {
+        if (![operation isFinished]) {
+            if ([operation isExecuting]) {
+                [self startAnimating];
+            } else {
+                [self stopAnimating];
+            }
+
+            [notificationCenter addObserver:self selector:@selector(af_startAnimating) name:AFNetworkingOperationDidStartNotification object:operation];
+            [notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingOperationDidFinishNotification object:operation];
+        }
+    }
+}
+
+#pragma mark -
+
+- (void)af_startAnimating {
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self startAnimating];
+    });
+}
+
+- (void)af_stopAnimating {
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self stopAnimating];
+    });
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.h
new file mode 100644
index 00000000000..b94f1cb8e09
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.h
@@ -0,0 +1,96 @@
+// UIAlertView+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@class AFURLConnectionOperation;
+
+/**
+ This category adds methods to the UIKit framework's `UIAlertView` class. The methods in this category provide support for automatically showing an alert if a session task or request operation finishes with an error. Alert title and message are filled from the corresponding `localizedDescription` & `localizedRecoverySuggestion` or `localizedFailureReason` of the error.
+ */
+@interface UIAlertView (AFNetworking)
+
+///-------------------------------------
+/// @name Showing Alert for Session Task
+///-------------------------------------
+
+/**
+ Shows an alert view with the error of the specified session task, if any.
+ 
+ @param task The session task.
+ @param delegate The alert view delegate.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
++ (void)showAlertViewForTaskWithErrorOnCompletion:(NSURLSessionTask *)task
+                                         delegate:(id)delegate;
+#endif
+
+/**
+ Shows an alert view with the error of the specified session task, if any, with a custom cancel button title and other button titles.
+ 
+ @param task The session task.
+ @param delegate The alert view delegate.
+ @param cancelButtonTitle The title of the cancel button or nil if there is no cancel button. Using this argument is equivalent to setting the cancel button index to the value returned by invoking addButtonWithTitle: specifying this title.
+ @param otherButtonTitles The title of another button. Using this argument is equivalent to invoking addButtonWithTitle: with this title to add more buttons. Too many buttons can cause the alert view to scroll. For guidelines on the best ways to use an alert in an app, see "Temporary Views". Titles of additional buttons to add to the receiver, terminated with `nil`.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
++ (void)showAlertViewForTaskWithErrorOnCompletion:(NSURLSessionTask *)task
+                                         delegate:(id)delegate
+                                cancelButtonTitle:(NSString *)cancelButtonTitle
+                                otherButtonTitles:(NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION;
+#endif
+
+///------------------------------------------
+/// @name Showing Alert for Request Operation
+///------------------------------------------
+
+/**
+ Shows an alert view with the error of the specified request operation, if any.
+
+ @param operation The request operation.
+ @param delegate The alert view delegate.
+ */
++ (void)showAlertViewForRequestOperationWithErrorOnCompletion:(AFURLConnectionOperation *)operation
+                                                     delegate:(id)delegate;
+
+/**
+ Shows an alert view with the error of the specified request operation, if any, with a custom cancel button title and other button titles.
+
+ @param operation The request operation.
+ @param delegate The alert view delegate.
+ @param cancelButtonTitle The title of the cancel button or nil if there is no cancel button. Using this argument is equivalent to setting the cancel button index to the value returned by invoking addButtonWithTitle: specifying this title.
+ @param otherButtonTitles The title of another button. Using this argument is equivalent to invoking addButtonWithTitle: with this title to add more buttons. Too many buttons can cause the alert view to scroll. For guidelines on the best ways to use an alert in an app, see "Temporary Views". Titles of additional buttons to add to the receiver, terminated with `nil`.
+ */
++ (void)showAlertViewForRequestOperationWithErrorOnCompletion:(AFURLConnectionOperation *)operation
+                                                     delegate:(id)delegate
+                                            cancelButtonTitle:(NSString *)cancelButtonTitle
+                                            otherButtonTitles:(NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.m
new file mode 100644
index 00000000000..b7e2a26cb2b
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.m
@@ -0,0 +1,111 @@
+// UIAlertView+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIAlertView+AFNetworking.h"
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFURLConnectionOperation.h"
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+#import "AFURLSessionManager.h"
+#endif
+
+static void AFGetAlertViewTitleAndMessageFromError(NSError *error, NSString * __autoreleasing *title, NSString * __autoreleasing *message) {
+    if (error.localizedDescription && (error.localizedRecoverySuggestion || error.localizedFailureReason)) {
+        *title = error.localizedDescription;
+
+        if (error.localizedRecoverySuggestion) {
+            *message = error.localizedRecoverySuggestion;
+        } else {
+            *message = error.localizedFailureReason;
+        }
+    } else if (error.localizedDescription) {
+        *title = NSLocalizedStringFromTable(@"Error", @"AFNetworking", @"Fallback Error Description");
+        *message = error.localizedDescription;
+    } else {
+        *title = NSLocalizedStringFromTable(@"Error", @"AFNetworking", @"Fallback Error Description");
+        *message = [NSString stringWithFormat:NSLocalizedStringFromTable(@"%@ Error: %ld", @"AFNetworking", @"Fallback Error Failure Reason Format"), error.domain, (long)error.code];
+    }
+}
+
+@implementation UIAlertView (AFNetworking)
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
++ (void)showAlertViewForTaskWithErrorOnCompletion:(NSURLSessionTask *)task
+                                         delegate:(id)delegate
+{
+    [self showAlertViewForTaskWithErrorOnCompletion:task delegate:delegate cancelButtonTitle:NSLocalizedStringFromTable(@"Dismiss", @"AFNetworking", @"UIAlertView Cancel Button Title") otherButtonTitles:nil, nil];
+}
+
++ (void)showAlertViewForTaskWithErrorOnCompletion:(NSURLSessionTask *)task
+                                         delegate:(id)delegate
+                                cancelButtonTitle:(NSString *)cancelButtonTitle
+                                otherButtonTitles:(NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION
+{
+    __block id observer = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidCompleteNotification object:task queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) {
+
+        NSError *error = notification.userInfo[AFNetworkingTaskDidCompleteErrorKey];
+        if (error) {
+            NSString *title, *message;
+            AFGetAlertViewTitleAndMessageFromError(error, &title, &message);
+
+            [[[UIAlertView alloc] initWithTitle:title message:message delegate:delegate cancelButtonTitle:cancelButtonTitle otherButtonTitles:otherButtonTitles, nil] show];
+        }
+
+        [[NSNotificationCenter defaultCenter] removeObserver:observer name:AFNetworkingTaskDidCompleteNotification object:notification.object];
+    }];
+}
+#endif
+
+#pragma mark -
+
++ (void)showAlertViewForRequestOperationWithErrorOnCompletion:(AFURLConnectionOperation *)operation
+                                                     delegate:(id)delegate
+{
+    [self showAlertViewForRequestOperationWithErrorOnCompletion:operation delegate:delegate cancelButtonTitle:NSLocalizedStringFromTable(@"Dismiss", @"AFNetworking", @"UIAlert View Cancel Button Title") otherButtonTitles:nil, nil];
+}
+
++ (void)showAlertViewForRequestOperationWithErrorOnCompletion:(AFURLConnectionOperation *)operation
+                                                     delegate:(id)delegate
+                                            cancelButtonTitle:(NSString *)cancelButtonTitle
+                                            otherButtonTitles:(NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION
+{
+    __block id observer = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingOperationDidFinishNotification object:operation queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) {
+
+        if (notification.object && [notification.object isKindOfClass:[AFURLConnectionOperation class]]) {
+            NSError *error = [(AFURLConnectionOperation *)notification.object error];
+            if (error) {
+                NSString *title, *message;
+                AFGetAlertViewTitleAndMessageFromError(error, &title, &message);
+
+                [[[UIAlertView alloc] initWithTitle:title message:message delegate:delegate cancelButtonTitle:cancelButtonTitle otherButtonTitles:otherButtonTitles, nil] show];
+            }
+        }
+
+        [[NSNotificationCenter defaultCenter] removeObserver:observer name:AFNetworkingOperationDidFinishNotification object:notification.object];
+    }];
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.h
new file mode 100644
index 00000000000..091b8e90135
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.h
@@ -0,0 +1,179 @@
+// UIButton+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@protocol AFURLResponseSerialization, AFImageCache;
+
+/**
+ This category adds methods to the UIKit framework's `UIButton` class. The methods in this category provide support for loading remote images and background images asynchronously from a URL.
+ */
+@interface UIButton (AFNetworking)
+
+///----------------------------
+/// @name Accessing Image Cache
+///----------------------------
+
+/**
+ The image cache used to improve image loadiing performance on scroll views. By default, `UIButton` will use the `sharedImageCache` of `UIImageView`.
+ */
++ (id <AFImageCache>)sharedImageCache;
+
+/**
+ Set the cache used for image loading.
+
+ @param imageCache The image cache.
+ */
++ (void)setSharedImageCache:(id <AFImageCache>)imageCache;
+
+///------------------------------------
+/// @name Accessing Response Serializer
+///------------------------------------
+
+/**
+ The response serializer used to create an image representation from the server response and response data. By default, this is an instance of `AFImageResponseSerializer`.
+
+ @discussion Subclasses of `AFImageResponseSerializer` could be used to perform post-processing, such as color correction, face detection, or other effects. See https://github.com/AFNetworking/AFCoreImageSerializer
+ */
+@property (nonatomic, strong) id <AFURLResponseSerialization> imageResponseSerializer;
+
+///--------------------
+/// @name Setting Image
+///--------------------
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled.
+ 
+  If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+ 
+ @param state The control state.
+ @param url The URL used for the image request.
+ */
+- (void)setImageForState:(UIControlState)state
+                 withURL:(NSURL *)url;
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled.
+ 
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+ 
+ @param state The control state.
+ @param url The URL used for the image request.
+ @param placeholderImage The image to be set initially, until the image request finishes. If `nil`, the button will not change its image until the image request finishes.
+ */
+- (void)setImageForState:(UIControlState)state
+                 withURL:(NSURL *)url
+        placeholderImage:(UIImage *)placeholderImage;
+
+/**
+ Asynchronously downloads an image from the specified URL request, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled.
+
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+ 
+ If a success block is specified, it is the responsibility of the block to set the image of the button before returning. If no success block is specified, the default behavior of setting the image with `setImage:forState:` is applied.
+
+ @param state The control state.
+ @param urlRequest The URL request used for the image request.
+ @param placeholderImage The image to be set initially, until the image request finishes. If `nil`, the button will not change its image until the image request finishes.
+ @param success A block to be executed when the image request operation finishes successfully. This block has no return value and takes two arguments: the server response and the image. If the image was returned from cache, the request and response parameters will be `nil`.
+ @param failure A block object to be executed when the image request operation finishes unsuccessfully, or that finishes successfully. This block has no return value and takes a single argument: the error that occurred.
+ */
+- (void)setImageForState:(UIControlState)state
+          withURLRequest:(NSURLRequest *)urlRequest
+        placeholderImage:(UIImage *)placeholderImage
+                 success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                 failure:(void (^)(NSError *error))failure;
+
+
+///-------------------------------
+/// @name Setting Background Image
+///-------------------------------
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it as the background image for the specified state once the request is finished. Any previous background image request for the receiver will be cancelled.
+
+ If the background image is cached locally, the background image is set immediately, otherwise the specified placeholder background image will be set immediately, and then the remote background image will be set once the request is finished.
+
+ @param state The control state.
+ @param url The URL used for the background image request.
+ */
+- (void)setBackgroundImageForState:(UIControlState)state
+                           withURL:(NSURL *)url;
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it as the background image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled.
+
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+
+ @param state The control state.
+ @param url The URL used for the background image request.
+ @param placeholderImage The background image to be set initially, until the background image request finishes. If `nil`, the button will not change its background image until the background image request finishes.
+ */
+- (void)setBackgroundImageForState:(UIControlState)state
+                           withURL:(NSURL *)url
+                  placeholderImage:(UIImage *)placeholderImage;
+
+/**
+ Asynchronously downloads an image from the specified URL request, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled.
+
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+
+ If a success block is specified, it is the responsibility of the block to set the image of the button before returning. If no success block is specified, the default behavior of setting the image with `setBackgroundImage:forState:` is applied.
+
+ @param state The control state.
+ @param urlRequest The URL request used for the image request.
+ @param placeholderImage The background image to be set initially, until the background image request finishes. If `nil`, the button will not change its background image until the background image request finishes.
+ */
+- (void)setBackgroundImageForState:(UIControlState)state
+                    withURLRequest:(NSURLRequest *)urlRequest
+                  placeholderImage:(UIImage *)placeholderImage
+                           success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                           failure:(void (^)(NSError *error))failure;
+
+
+///------------------------------
+/// @name Canceling Image Loading
+///------------------------------
+
+/**
+ Cancels any executing image operation for the specified control state of the receiver, if one exists.
+ 
+ @param state The control state.
+ */
+- (void)cancelImageRequestOperationForState:(UIControlState)state;
+
+/**
+ Cancels any executing background image operation for the specified control state of the receiver, if one exists.
+ 
+ @param state The control state.
+ */
+- (void)cancelBackgroundImageRequestOperationForState:(UIControlState)state;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.m
new file mode 100644
index 00000000000..9fb24add62b
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.m
@@ -0,0 +1,262 @@
+// UIButton+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIButton+AFNetworking.h"
+
+#import <objc/runtime.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFURLResponseSerialization.h"
+#import "AFHTTPRequestOperation.h"
+
+#import "UIImageView+AFNetworking.h"
+
+@interface UIButton (_AFNetworking)
+@end
+
+@implementation UIButton (_AFNetworking)
+
++ (NSOperationQueue *)af_sharedImageRequestOperationQueue {
+    static NSOperationQueue *_af_sharedImageRequestOperationQueue = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_sharedImageRequestOperationQueue = [[NSOperationQueue alloc] init];
+        _af_sharedImageRequestOperationQueue.maxConcurrentOperationCount = NSOperationQueueDefaultMaxConcurrentOperationCount;
+    });
+
+    return _af_sharedImageRequestOperationQueue;
+}
+
+#pragma mark -
+
+static const char * af_imageRequestOperationKeyForState(UIControlState state) {
+    return [[NSString stringWithFormat:@"af_imageRequestOperationKeyForState_%lu", (unsigned long)state] cStringUsingEncoding:NSASCIIStringEncoding];
+}
+
+- (AFHTTPRequestOperation *)af_imageRequestOperationForState:(UIControlState)state {
+    return (AFHTTPRequestOperation *)objc_getAssociatedObject(self, af_imageRequestOperationKeyForState(state));
+}
+
+- (void)af_setImageRequestOperation:(AFHTTPRequestOperation *)imageRequestOperation
+                           forState:(UIControlState)state
+{
+    objc_setAssociatedObject(self, af_imageRequestOperationKeyForState(state), imageRequestOperation, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+static const char * af_backgroundImageRequestOperationKeyForState(UIControlState state) {
+    return [[NSString stringWithFormat:@"af_backgroundImageRequestOperationKeyForState_%lu", (unsigned long)state] cStringUsingEncoding:NSASCIIStringEncoding];
+}
+
+- (AFHTTPRequestOperation *)af_backgroundImageRequestOperationForState:(UIControlState)state {
+    return (AFHTTPRequestOperation *)objc_getAssociatedObject(self, af_backgroundImageRequestOperationKeyForState(state));
+}
+
+- (void)af_setBackgroundImageRequestOperation:(AFHTTPRequestOperation *)imageRequestOperation
+                                     forState:(UIControlState)state
+{
+    objc_setAssociatedObject(self, af_backgroundImageRequestOperationKeyForState(state), imageRequestOperation, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+@end
+
+#pragma mark -
+
+@implementation UIButton (AFNetworking)
+
++ (id <AFImageCache>)sharedImageCache {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(sharedImageCache)) ?: [UIImageView sharedImageCache];
+#pragma clang diagnostic pop
+}
+
++ (void)setSharedImageCache:(id <AFImageCache>)imageCache {
+    objc_setAssociatedObject(self, @selector(sharedImageCache), imageCache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+- (id <AFURLResponseSerialization>)imageResponseSerializer {
+    static id <AFURLResponseSerialization> _af_defaultImageResponseSerializer = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_defaultImageResponseSerializer = [AFImageResponseSerializer serializer];
+    });
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(imageResponseSerializer)) ?: _af_defaultImageResponseSerializer;
+#pragma clang diagnostic pop
+}
+
+- (void)setImageResponseSerializer:(id <AFURLResponseSerialization>)serializer {
+    objc_setAssociatedObject(self, @selector(imageResponseSerializer), serializer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+- (void)setImageForState:(UIControlState)state
+                 withURL:(NSURL *)url
+{
+    [self setImageForState:state withURL:url placeholderImage:nil];
+}
+
+- (void)setImageForState:(UIControlState)state
+                 withURL:(NSURL *)url
+        placeholderImage:(UIImage *)placeholderImage
+{
+    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
+    [request addValue:@"image/*" forHTTPHeaderField:@"Accept"];
+
+    [self setImageForState:state withURLRequest:request placeholderImage:placeholderImage success:nil failure:nil];
+}
+
+- (void)setImageForState:(UIControlState)state
+          withURLRequest:(NSURLRequest *)urlRequest
+        placeholderImage:(UIImage *)placeholderImage
+                 success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                 failure:(void (^)(NSError *error))failure
+{
+    [self cancelImageRequestOperationForState:state];
+
+    UIImage *cachedImage = [[[self class] sharedImageCache] cachedImageForRequest:urlRequest];
+    if (cachedImage) {
+        if (success) {
+            success(nil, nil, cachedImage);
+        } else {
+            [self setImage:cachedImage forState:state];
+        }
+
+        [self af_setImageRequestOperation:nil forState:state];
+    } else {
+        if (placeholderImage) {
+            [self setImage:placeholderImage forState:state];
+        }
+
+        __weak __typeof(self)weakSelf = self;
+        AFHTTPRequestOperation *imageRequestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:urlRequest];
+        imageRequestOperation.responseSerializer = self.imageResponseSerializer;
+        [imageRequestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+            if ([[urlRequest URL] isEqual:[operation.request URL]]) {
+                if (success) {
+                    success(operation.request, operation.response, responseObject);
+                } else if (responseObject) {
+                    [strongSelf setImage:responseObject forState:state];
+                }
+            }
+        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+            if ([[urlRequest URL] isEqual:[operation.response URL]]) {
+                if (failure) {
+                    failure(error);
+                }
+            }
+        }];
+
+        [self af_setImageRequestOperation:imageRequestOperation forState:state];
+        [[[self class] af_sharedImageRequestOperationQueue] addOperation:imageRequestOperation];
+    }
+}
+
+#pragma mark -
+
+- (void)setBackgroundImageForState:(UIControlState)state
+                           withURL:(NSURL *)url
+{
+    [self setBackgroundImageForState:state withURL:url placeholderImage:nil];
+}
+
+- (void)setBackgroundImageForState:(UIControlState)state
+                           withURL:(NSURL *)url
+                  placeholderImage:(UIImage *)placeholderImage
+{
+    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
+    [request addValue:@"image/*" forHTTPHeaderField:@"Accept"];
+
+    [self setBackgroundImageForState:state withURLRequest:request placeholderImage:placeholderImage success:nil failure:nil];
+}
+
+- (void)setBackgroundImageForState:(UIControlState)state
+                    withURLRequest:(NSURLRequest *)urlRequest
+                  placeholderImage:(UIImage *)placeholderImage
+                           success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                           failure:(void (^)(NSError *error))failure
+{
+    [self cancelBackgroundImageRequestOperationForState:state];
+
+    UIImage *cachedImage = [[[self class] sharedImageCache] cachedImageForRequest:urlRequest];
+    if (cachedImage) {
+        if (success) {
+            success(nil, nil, cachedImage);
+        } else {
+            [self setBackgroundImage:cachedImage forState:state];
+        }
+
+        [self af_setBackgroundImageRequestOperation:nil forState:state];
+    } else {
+        if (placeholderImage) {
+            [self setBackgroundImage:placeholderImage forState:state];
+        }
+
+        __weak __typeof(self)weakSelf = self;
+        AFHTTPRequestOperation *backgroundImageRequestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:urlRequest];
+        backgroundImageRequestOperation.responseSerializer = self.imageResponseSerializer;
+        [backgroundImageRequestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+            if ([[urlRequest URL] isEqual:[operation.request URL]]) {
+                if (success) {
+                    success(operation.request, operation.response, responseObject);
+                } else if (responseObject) {
+                    [strongSelf setBackgroundImage:responseObject forState:state];
+                }
+            }
+        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+            if ([[urlRequest URL] isEqual:[operation.response URL]]) {
+                if (failure) {
+                    failure(error);
+                }
+            }
+        }];
+
+        [self af_setBackgroundImageRequestOperation:backgroundImageRequestOperation forState:state];
+        [[[self class] af_sharedImageRequestOperationQueue] addOperation:backgroundImageRequestOperation];
+    }
+}
+
+#pragma mark -
+
+- (void)cancelImageRequestOperationForState:(UIControlState)state {
+    [[self af_imageRequestOperationForState:state] cancel];
+    [self af_setImageRequestOperation:nil forState:state];
+}
+
+- (void)cancelBackgroundImageRequestOperationForState:(UIControlState)state {
+    [[self af_backgroundImageRequestOperationForState:state] cancel];
+    [self af_setBackgroundImageRequestOperation:nil forState:state];
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.h
new file mode 100644
index 00000000000..5d523636e88
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.h
@@ -0,0 +1,143 @@
+// UIImageView+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@protocol AFURLResponseSerialization, AFImageCache;
+
+/**
+ This category adds methods to the UIKit framework's `UIImageView` class. The methods in this category provide support for loading remote images asynchronously from a URL.
+ */
+@interface UIImageView (AFNetworking)
+
+///----------------------------
+/// @name Accessing Image Cache
+///----------------------------
+
+/**
+ The image cache used to improve image loadiing performance on scroll views. By default, this is an `NSCache` subclass conforming to the `AFImageCache` protocol, which listens for notification warnings and evicts objects accordingly.
+*/
++ (id <AFImageCache>)sharedImageCache;
+
+/**
+ Set the cache used for image loading.
+ 
+ @param imageCache The image cache.
+ */
++ (void)setSharedImageCache:(id <AFImageCache>)imageCache;
+
+///------------------------------------
+/// @name Accessing Response Serializer
+///------------------------------------
+
+/**
+ The response serializer used to create an image representation from the server response and response data. By default, this is an instance of `AFImageResponseSerializer`.
+ 
+ @discussion Subclasses of `AFImageResponseSerializer` could be used to perform post-processing, such as color correction, face detection, or other effects. See https://github.com/AFNetworking/AFCoreImageSerializer
+ */
+@property (nonatomic, strong) id <AFURLResponseSerialization> imageResponseSerializer;
+
+///--------------------
+/// @name Setting Image
+///--------------------
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it once the request is finished. Any previous image request for the receiver will be cancelled. 
+ 
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+
+ By default, URL requests have a `Accept` header field value of "image / *", a cache policy of `NSURLCacheStorageAllowed` and a timeout interval of 30 seconds, and are set not handle cookies. To configure URL requests differently, use `setImageWithURLRequest:placeholderImage:success:failure:`
+
+ @param url The URL used for the image request.
+ */
+- (void)setImageWithURL:(NSURL *)url;
+
+/**
+ Asynchronously downloads an image from the specified URL, and sets it once the request is finished. Any previous image request for the receiver will be cancelled. 
+ 
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+
+ By default, URL requests have a `Accept` header field value of "image / *", a cache policy of `NSURLCacheStorageAllowed` and a timeout interval of 30 seconds, and are set not handle cookies. To configure URL requests differently, use `setImageWithURLRequest:placeholderImage:success:failure:`
+
+ @param url The URL used for the image request.
+ @param placeholderImage The image to be set initially, until the image request finishes. If `nil`, the image view will not change its image until the image request finishes.
+ */
+- (void)setImageWithURL:(NSURL *)url
+       placeholderImage:(UIImage *)placeholderImage;
+
+/**
+ Asynchronously downloads an image from the specified URL request, and sets it once the request is finished. Any previous image request for the receiver will be cancelled. 
+ 
+ If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished.
+ 
+ If a success block is specified, it is the responsibility of the block to set the image of the image view before returning. If no success block is specified, the default behavior of setting the image with `self.image = image` is applied.
+
+ @param urlRequest The URL request used for the image request.
+ @param placeholderImage The image to be set initially, until the image request finishes. If `nil`, the image view will not change its image until the image request finishes.
+ @param success A block to be executed when the image request operation finishes successfully. This block has no return value and takes three arguments: the request sent from the client, the response received from the server, and the image created from the response data of request. If the image was returned from cache, the request and response parameters will be `nil`.
+ @param failure A block object to be executed when the image request operation finishes unsuccessfully, or that finishes successfully. This block has no return value and takes three arguments: the request sent from the client, the response received from the server, and the error object describing the network or parsing error that occurred.
+ */
+- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest
+              placeholderImage:(UIImage *)placeholderImage
+                       success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                       failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error))failure;
+
+/**
+ Cancels any executing image operation for the receiver, if one exists.
+ */
+- (void)cancelImageRequestOperation;
+
+@end
+
+#pragma mark -
+
+/**
+ The `AFImageCache` protocol is adopted by an object used to cache images loaded by the AFNetworking category on `UIImageView`.
+ */
+@protocol AFImageCache <NSObject>
+
+/**
+ Returns a cached image for the specififed request, if available.
+ 
+ @param request The image request.
+ 
+ @return The cached image.
+ */
+- (UIImage *)cachedImageForRequest:(NSURLRequest *)request;
+
+/**
+ Caches a particular image for the specified request.
+ 
+ @param image The image to cache.
+ @param request The request to be used as a cache key.
+ */
+- (void)cacheImage:(UIImage *)image
+        forRequest:(NSURLRequest *)request;
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.m
new file mode 100644
index 00000000000..c06aa9ca4c2
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.m
@@ -0,0 +1,216 @@
+// UIImageView+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIImageView+AFNetworking.h"
+
+#import <objc/runtime.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFHTTPRequestOperation.h"
+
+@interface AFImageCache : NSCache <AFImageCache>
+@end
+
+#pragma mark -
+
+@interface UIImageView (_AFNetworking)
+@property (readwrite, nonatomic, strong, setter = af_setImageRequestOperation:) AFHTTPRequestOperation *af_imageRequestOperation;
+@end
+
+@implementation UIImageView (_AFNetworking)
+
++ (NSOperationQueue *)af_sharedImageRequestOperationQueue {
+    static NSOperationQueue *_af_sharedImageRequestOperationQueue = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_sharedImageRequestOperationQueue = [[NSOperationQueue alloc] init];
+        _af_sharedImageRequestOperationQueue.maxConcurrentOperationCount = NSOperationQueueDefaultMaxConcurrentOperationCount;
+    });
+
+    return _af_sharedImageRequestOperationQueue;
+}
+
+- (AFHTTPRequestOperation *)af_imageRequestOperation {
+    return (AFHTTPRequestOperation *)objc_getAssociatedObject(self, @selector(af_imageRequestOperation));
+}
+
+- (void)af_setImageRequestOperation:(AFHTTPRequestOperation *)imageRequestOperation {
+    objc_setAssociatedObject(self, @selector(af_imageRequestOperation), imageRequestOperation, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+@end
+
+#pragma mark -
+
+@implementation UIImageView (AFNetworking)
+@dynamic imageResponseSerializer;
+
++ (id <AFImageCache>)sharedImageCache {
+    static AFImageCache *_af_defaultImageCache = nil;
+    static dispatch_once_t oncePredicate;
+    dispatch_once(&oncePredicate, ^{
+        _af_defaultImageCache = [[AFImageCache alloc] init];
+
+        [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidReceiveMemoryWarningNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * __unused notification) {
+            [_af_defaultImageCache removeAllObjects];
+        }];
+    });
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(sharedImageCache)) ?: _af_defaultImageCache;
+#pragma clang diagnostic pop
+}
+
++ (void)setSharedImageCache:(id <AFImageCache>)imageCache {
+    objc_setAssociatedObject(self, @selector(sharedImageCache), imageCache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+- (id <AFURLResponseSerialization>)imageResponseSerializer {
+    static id <AFURLResponseSerialization> _af_defaultImageResponseSerializer = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_defaultImageResponseSerializer = [AFImageResponseSerializer serializer];
+    });
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(imageResponseSerializer)) ?: _af_defaultImageResponseSerializer;
+#pragma clang diagnostic pop
+}
+
+- (void)setImageResponseSerializer:(id <AFURLResponseSerialization>)serializer {
+    objc_setAssociatedObject(self, @selector(imageResponseSerializer), serializer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+- (void)setImageWithURL:(NSURL *)url {
+    [self setImageWithURL:url placeholderImage:nil];
+}
+
+- (void)setImageWithURL:(NSURL *)url
+       placeholderImage:(UIImage *)placeholderImage
+{
+    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
+    [request addValue:@"image/*" forHTTPHeaderField:@"Accept"];
+
+    [self setImageWithURLRequest:request placeholderImage:placeholderImage success:nil failure:nil];
+}
+
+- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest
+              placeholderImage:(UIImage *)placeholderImage
+                       success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, UIImage *image))success
+                       failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error))failure
+{
+    [self cancelImageRequestOperation];
+
+    UIImage *cachedImage = [[[self class] sharedImageCache] cachedImageForRequest:urlRequest];
+    if (cachedImage) {
+        if (success) {
+            success(nil, nil, cachedImage);
+        } else {
+            self.image = cachedImage;
+        }
+
+        self.af_imageRequestOperation = nil;
+    } else {
+        if (placeholderImage) {
+            self.image = placeholderImage;
+        }
+        
+        __weak __typeof(self)weakSelf = self;
+        self.af_imageRequestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:urlRequest];
+        self.af_imageRequestOperation.responseSerializer = self.imageResponseSerializer;
+        [self.af_imageRequestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+            if ([[urlRequest URL] isEqual:[strongSelf.af_imageRequestOperation.request URL]]) {
+                if (success) {
+                    success(urlRequest, operation.response, responseObject);
+                } else if (responseObject) {
+                    strongSelf.image = responseObject;
+                }
+
+                if (operation == strongSelf.af_imageRequestOperation){
+                        strongSelf.af_imageRequestOperation = nil;
+                }
+            }
+
+            [[[strongSelf class] sharedImageCache] cacheImage:responseObject forRequest:urlRequest];
+        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+            __strong __typeof(weakSelf)strongSelf = weakSelf;
+            if ([[urlRequest URL] isEqual:[strongSelf.af_imageRequestOperation.request URL]]) {
+                if (failure) {
+                    failure(urlRequest, operation.response, error);
+                }
+
+                if (operation == strongSelf.af_imageRequestOperation){
+                        strongSelf.af_imageRequestOperation = nil;
+                }
+            }
+        }];
+
+        [[[self class] af_sharedImageRequestOperationQueue] addOperation:self.af_imageRequestOperation];
+    }
+}
+
+- (void)cancelImageRequestOperation {
+    [self.af_imageRequestOperation cancel];
+    self.af_imageRequestOperation = nil;
+}
+
+@end
+
+#pragma mark -
+
+static inline NSString * AFImageCacheKeyFromURLRequest(NSURLRequest *request) {
+    return [[request URL] absoluteString];
+}
+
+@implementation AFImageCache
+
+- (UIImage *)cachedImageForRequest:(NSURLRequest *)request {
+    switch ([request cachePolicy]) {
+        case NSURLRequestReloadIgnoringCacheData:
+        case NSURLRequestReloadIgnoringLocalAndRemoteCacheData:
+            return nil;
+        default:
+            break;
+    }
+
+	return [self objectForKey:AFImageCacheKeyFromURLRequest(request)];
+}
+
+- (void)cacheImage:(UIImage *)image
+        forRequest:(NSURLRequest *)request
+{
+    if (image && request) {
+        [self setObject:image forKey:AFImageCacheKeyFromURLRequest(request)];
+    }
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIKit+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIKit+AFNetworking.h
new file mode 100644
index 00000000000..94082f6cb58
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIKit+AFNetworking.h
@@ -0,0 +1,38 @@
+// UIKit+AFNetworking.h
+//
+// Copyright (c) 2013 AFNetworking (http://afnetworking.com/)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <UIKit/UIKit.h>
+
+#ifndef _UIKIT_AFNETWORKING_
+    #define _UIKIT_AFNETWORKING_
+
+    #import "AFNetworkActivityIndicatorManager.h"
+
+    #import "UIActivityIndicatorView+AFNetworking.h"
+    #import "UIAlertView+AFNetworking.h"
+    #import "UIButton+AFNetworking.h"
+    #import "UIImageView+AFNetworking.h"
+    #import "UIKit+AFNetworking.h"
+    #import "UIProgressView+AFNetworking.h"
+    #import "UIRefreshControl+AFNetworking.h"
+    #import "UIWebView+AFNetworking.h"
+#endif /* _UIKIT_AFNETWORKING_ */
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.h
new file mode 100644
index 00000000000..3f1bc086f5e
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.h
@@ -0,0 +1,88 @@
+// UIProgressView+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@class AFURLConnectionOperation;
+
+/**
+ This category adds methods to the UIKit framework's `UIProgressView` class. The methods in this category provide support for binding the progress to the upload and download progress of a session task or request operation.
+ */
+@interface UIProgressView (AFNetworking)
+
+///------------------------------------
+/// @name Setting Session Task Progress
+///------------------------------------
+
+/**
+ Binds the progress to the upload progress of the specified session task.
+ 
+ @param task The session task.
+ @param animated `YES` if the change should be animated, `NO` if the change should happen immediately.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task
+                                   animated:(BOOL)animated;
+#endif
+
+/**
+ Binds the progress to the download progress of the specified session task.
+
+ @param task The session task.
+ @param animated `YES` if the change should be animated, `NO` if the change should happen immediately.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task
+                                     animated:(BOOL)animated;
+#endif
+
+///------------------------------------
+/// @name Setting Session Task Progress
+///------------------------------------
+
+/**
+ Binds the progress to the upload progress of the specified request operation.
+
+ @param operation The request operation.
+ @param animated `YES` if the change should be animated, `NO` if the change should happen immediately.
+ */
+- (void)setProgressWithUploadProgressOfOperation:(AFURLConnectionOperation *)operation
+                                        animated:(BOOL)animated;
+
+/**
+ Binds the progress to the download progress of the specified request operation.
+
+ @param operation The request operation.
+ @param animated `YES` if the change should be animated, `NO` if the change should happen immediately.
+ */
+- (void)setProgressWithDownloadProgressOfOperation:(AFURLConnectionOperation *)operation
+                                          animated:(BOOL)animated;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.m
new file mode 100644
index 00000000000..927f56d843b
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.m
@@ -0,0 +1,183 @@
+// UIProgressView+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIProgressView+AFNetworking.h"
+
+#import <objc/runtime.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFURLConnectionOperation.h"
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+#import "AFURLSessionManager.h"
+#endif
+
+static void * AFTaskCountOfBytesSentContext = &AFTaskCountOfBytesSentContext;
+static void * AFTaskCountOfBytesReceivedContext = &AFTaskCountOfBytesReceivedContext;
+
+@interface AFURLConnectionOperation (_UIProgressView)
+@property (readwrite, nonatomic, copy) void (^uploadProgress)(NSUInteger bytes, long long totalBytes, long long totalBytesExpected);
+@property (readwrite, nonatomic, assign, setter = af_setUploadProgressAnimated:) BOOL af_uploadProgressAnimated;
+
+@property (readwrite, nonatomic, copy) void (^downloadProgress)(NSUInteger bytes, long long totalBytes, long long totalBytesExpected);
+@property (readwrite, nonatomic, assign, setter = af_setDownloadProgressAnimated:) BOOL af_downloadProgressAnimated;
+@end
+
+@implementation AFURLConnectionOperation (_UIProgressView)
+@dynamic uploadProgress; // Implemented in AFURLConnectionOperation
+@dynamic af_uploadProgressAnimated;
+
+@dynamic downloadProgress; // Implemented in AFURLConnectionOperation
+@dynamic af_downloadProgressAnimated;
+@end
+
+#pragma mark -
+
+@implementation UIProgressView (AFNetworking)
+
+- (BOOL)af_uploadProgressAnimated {
+    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_uploadProgressAnimated)) boolValue];
+}
+
+- (void)af_setUploadProgressAnimated:(BOOL)animated {
+    objc_setAssociatedObject(self, @selector(af_uploadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+- (BOOL)af_downloadProgressAnimated {
+    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_downloadProgressAnimated)) boolValue];
+}
+
+- (void)af_setDownloadProgressAnimated:(BOOL)animated {
+    objc_setAssociatedObject(self, @selector(af_downloadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task
+                                   animated:(BOOL)animated
+{
+    [task addObserver:self forKeyPath:@"state" options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];
+    [task addObserver:self forKeyPath:@"countOfBytesSent" options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];
+
+    [self af_setUploadProgressAnimated:animated];
+}
+
+- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task
+                                     animated:(BOOL)animated
+{
+    [task addObserver:self forKeyPath:@"state" options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];
+    [task addObserver:self forKeyPath:@"countOfBytesReceived" options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];
+
+    [self af_setDownloadProgressAnimated:animated];
+}
+#endif
+
+#pragma mark -
+
+- (void)setProgressWithUploadProgressOfOperation:(AFURLConnectionOperation *)operation
+                                        animated:(BOOL)animated
+{
+    __weak __typeof(self)weakSelf = self;
+    void (^original)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) = [operation.uploadProgress copy];
+    [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
+        if (original) {
+            original(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
+        }
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            if (totalBytesExpectedToWrite > 0) {
+                __strong __typeof(weakSelf)strongSelf = weakSelf;
+                [strongSelf setProgress:(totalBytesWritten / (totalBytesExpectedToWrite * 1.0f)) animated:animated];
+            }
+        });
+    }];
+}
+
+- (void)setProgressWithDownloadProgressOfOperation:(AFURLConnectionOperation *)operation
+                                          animated:(BOOL)animated
+{
+    __weak __typeof(self)weakSelf = self;
+    void (^original)(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead) = [operation.downloadProgress copy];
+    [operation setDownloadProgressBlock:^(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead) {
+        if (original) {
+            original(bytesRead, totalBytesRead, totalBytesExpectedToRead);
+        }
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            if (totalBytesExpectedToRead > 0) {
+                __strong __typeof(weakSelf)strongSelf = weakSelf;
+                [strongSelf setProgress:(totalBytesRead / (totalBytesExpectedToRead  * 1.0f)) animated:animated];
+            }
+        });
+    }];
+}
+
+#pragma mark - NSKeyValueObserving
+
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(id)object
+                        change:(__unused NSDictionary *)change
+                       context:(void *)context
+{
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+    if (context == AFTaskCountOfBytesSentContext || context == AFTaskCountOfBytesReceivedContext) {
+        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {
+            if ([object countOfBytesExpectedToSend] > 0) {
+                dispatch_async(dispatch_get_main_queue(), ^{
+                    [self setProgress:[object countOfBytesSent] / ([object countOfBytesExpectedToSend] * 1.0f) animated:self.af_uploadProgressAnimated];
+                });
+            }
+        }
+
+        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {
+            if ([object countOfBytesExpectedToReceive] > 0) {
+                dispatch_async(dispatch_get_main_queue(), ^{
+                    [self setProgress:[object countOfBytesReceived] / ([object countOfBytesExpectedToReceive] * 1.0f) animated:self.af_downloadProgressAnimated];
+                });
+            }
+        }
+
+        if ([keyPath isEqualToString:NSStringFromSelector(@selector(state))]) {
+            if ([(NSURLSessionTask *)object state] == NSURLSessionTaskStateCompleted) {
+                @try {
+                    [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(state))];
+
+                    if (context == AFTaskCountOfBytesSentContext) {
+                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];
+                    }
+
+                    if (context == AFTaskCountOfBytesReceivedContext) {
+                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];
+                    }
+                }
+                @catch (NSException * __unused exception) {}
+            }
+        }
+    }
+#endif
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.h
new file mode 100644
index 00000000000..37ce772de0d
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.h
@@ -0,0 +1,64 @@
+// UIRefreshControl+AFNetworking.m
+//
+// Copyright (c) 2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@class AFURLConnectionOperation;
+
+/**
+ This category adds methods to the UIKit framework's `UIRefreshControl` class. The methods in this category provide support for automatically begining and ending refreshing depending on the loading state of a request operation or session task.
+ */
+@interface UIRefreshControl (AFNetworking)
+
+///-----------------------------------
+/// @name Refreshing for Session Tasks
+///-----------------------------------
+
+/**
+ Binds the refreshing state to the state of the specified task.
+ 
+ @param task The task. If `nil`, automatic updating from any previously specified operation will be diabled.
+ */
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setRefreshingWithStateOfTask:(NSURLSessionTask *)task;
+#endif
+
+///----------------------------------------
+/// @name Refreshing for Request Operations
+///----------------------------------------
+
+/**
+ Binds the refreshing state to the execution state of the specified operation.
+
+ @param operation The operation. If `nil`, automatic updating from any previously specified operation will be disabled.
+ */
+- (void)setRefreshingWithStateOfOperation:(AFURLConnectionOperation *)operation;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.m
new file mode 100644
index 00000000000..ba28157380c
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.m
@@ -0,0 +1,95 @@
+// UIRefreshControl+AFNetworking.m
+//
+// Copyright (c) 2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIRefreshControl+AFNetworking.h"
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFHTTPRequestOperation.h"
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+#import "AFURLSessionManager.h"
+#endif
+
+@implementation UIRefreshControl (AFNetworking)
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000
+- (void)setRefreshingWithStateOfTask:(NSURLSessionTask *)task {
+    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil];
+
+    if (task) {
+        if (task.state != NSURLSessionTaskStateCompleted) {
+            if (task.state == NSURLSessionTaskStateRunning) {
+                [self beginRefreshing];
+            } else {
+                [self endRefreshing];
+            }
+
+            [notificationCenter addObserver:self selector:@selector(af_beginRefreshing) name:AFNetworkingTaskDidResumeNotification object:task];
+            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidCompleteNotification object:task];
+            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidSuspendNotification object:task];
+        }
+    }
+}
+#endif
+
+- (void)setRefreshingWithStateOfOperation:(AFURLConnectionOperation *)operation {
+    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
+
+    [notificationCenter removeObserver:self name:AFNetworkingOperationDidStartNotification object:nil];
+    [notificationCenter removeObserver:self name:AFNetworkingOperationDidFinishNotification object:nil];
+
+    if (operation) {
+        if (![operation isFinished]) {
+            if ([operation isExecuting]) {
+                [self beginRefreshing];
+            } else {
+                [self endRefreshing];
+            }
+
+            [notificationCenter addObserver:self selector:@selector(af_beginRefreshing) name:AFNetworkingOperationDidStartNotification object:operation];
+            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingOperationDidFinishNotification object:operation];
+        }
+    }
+}
+
+#pragma mark -
+
+- (void)af_beginRefreshing {
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self beginRefreshing];
+    });
+}
+
+- (void)af_endRefreshing {
+    dispatch_async(dispatch_get_main_queue(), ^{
+        [self endRefreshing];
+    });
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.h b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.h
new file mode 100644
index 00000000000..202e8f4ea29
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.h
@@ -0,0 +1,83 @@
+// UIWebView+AFNetworking.h
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import <Foundation/Foundation.h>
+
+#import <Availability.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import <UIKit/UIKit.h>
+
+@class AFHTTPRequestSerializer, AFHTTPResponseSerializer;
+@protocol AFURLRequestSerialization, AFURLResponseSerialization;
+
+/**
+ This category adds methods to the UIKit framework's `UIWebView` class. The methods in this category provide increased control over the request cycle, including progress monitoring and success / failure handling.
+ 
+ @discussion When using these category methods, make sure to assign `delegate` for the web view, which implements `webView:shouldStartLoadWithRequest:navigationType:` appropriately. This allows for tapped links to be loaded through AFNetworking, and can ensure that `canGoBack` & `canGoForward` update their values correctly.
+ */
+@interface UIWebView (AFNetworking)
+
+/**
+ The request serializer used to serialize requests made with the `-loadRequest:...` category methods. By default, this is an instance of `AFHTTPRequestSerializer`.
+ */
+@property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;
+
+/**
+ The response serializer used to serialize responses made with the `-loadRequest:...` category methods. By default, this is an instance of `AFHTTPResponseSerializer`.
+ */
+@property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;
+
+/**
+ Asynchronously loads the specified request.
+ 
+ @param request A URL request identifying the location of the content to load. This must not be `nil`.
+ @param progress A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes three arguments: the number of bytes read since the last time the download progress block was called, the total bytes read, and the total bytes expected to be read during the request, as initially determined by the expected content size of the `NSHTTPURLResponse` object. This block may be called multiple times, and will execute on the main thread.
+ @param success A block object to be executed when the request finishes loading successfully. This block returns the HTML string to be loaded by the web view, and takes two arguments: the response, and the response string.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a single argument: the error that occurred.
+ */
+- (void)loadRequest:(NSURLRequest *)request
+           progress:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))progress
+            success:(NSString * (^)(NSHTTPURLResponse *response, NSString *HTML))success
+            failure:(void (^)(NSError *error))failure;
+
+/**
+ Asynchronously loads the data associated with a particular request with a specified MIME type and text encoding.
+
+ @param request A URL request identifying the location of the content to load. This must not be `nil`.
+ @param MIMEType The MIME type of the content. Defaults to the content type of the response if not specified.
+ @param textEncodingName The IANA encoding name, as in `utf-8` or `utf-16`. Defaults to the response text encoding if not specified.
+ @param progress A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes three arguments: the number of bytes read since the last time the download progress block was called, the total bytes read, and the total bytes expected to be read during the request, as initially determined by the expected content size of the `NSHTTPURLResponse` object. This block may be called multiple times, and will execute on the main thread.
+ @param success A block object to be executed when the request finishes loading successfully. This block returns the data to be loaded by the web view and takes two arguments: the response, and the downloaded data.
+ @param failure A block object to be executed when the request operation finishes unsuccessfully, or that finishes successfully, but encountered an error while parsing the response data. This block has no return value and takes a single argument: the error that occurred.
+ */
+- (void)loadRequest:(NSURLRequest *)request
+           MIMEType:(NSString *)MIMEType
+   textEncodingName:(NSString *)textEncodingName
+           progress:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))progress
+            success:(NSData * (^)(NSHTTPURLResponse *response, NSData *data))success
+            failure:(void (^)(NSError *error))failure;
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.m b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.m
new file mode 100644
index 00000000000..525d02aeadc
--- /dev/null
+++ b/cocoapods/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.m
@@ -0,0 +1,151 @@
+// UIWebView+AFNetworking.m
+//
+// Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#import "UIWebView+AFNetworking.h"
+
+#import <objc/runtime.h>
+
+#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+
+#import "AFHTTPRequestOperation.h"
+#import "AFURLResponseSerialization.h"
+#import "AFURLRequestSerialization.h"
+
+@interface UIWebView (_AFNetworking)
+@property (readwrite, nonatomic, strong, setter = af_setHTTPRequestOperation:) AFHTTPRequestOperation *af_HTTPRequestOperation;
+@end
+
+@implementation UIWebView (_AFNetworking)
+
+- (AFHTTPRequestOperation *)af_HTTPRequestOperation {
+    return (AFHTTPRequestOperation *)objc_getAssociatedObject(self, @selector(af_HTTPRequestOperation));
+}
+
+- (void)af_setHTTPRequestOperation:(AFHTTPRequestOperation *)operation {
+    objc_setAssociatedObject(self, @selector(af_HTTPRequestOperation), operation, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+@end
+
+#pragma mark -
+
+@implementation UIWebView (AFNetworking)
+
+- (AFHTTPRequestSerializer <AFURLRequestSerialization> *)requestSerializer {
+    static AFHTTPRequestSerializer <AFURLRequestSerialization> *_af_defaultRequestSerializer = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_defaultRequestSerializer = [AFHTTPRequestSerializer serializer];
+    });
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(requestSerializer)) ?: _af_defaultRequestSerializer;
+#pragma clang diagnostic pop
+}
+
+- (void)setRequestSerializer:(AFHTTPRequestSerializer<AFURLRequestSerialization> *)requestSerializer {
+    objc_setAssociatedObject(self, @selector(requestSerializer), requestSerializer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+- (AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
+    static AFHTTPResponseSerializer <AFURLResponseSerialization> *_af_defaultResponseSerializer = nil;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _af_defaultResponseSerializer = [AFHTTPResponseSerializer serializer];
+    });
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+    return objc_getAssociatedObject(self, @selector(responseSerializer)) ?: _af_defaultResponseSerializer;
+#pragma clang diagnostic pop
+}
+
+- (void)setResponseSerializer:(AFHTTPResponseSerializer<AFURLResponseSerialization> *)responseSerializer {
+    objc_setAssociatedObject(self, @selector(responseSerializer), responseSerializer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
+#pragma mark -
+
+- (void)loadRequest:(NSURLRequest *)request
+           progress:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))progress
+            success:(NSString * (^)(NSHTTPURLResponse *response, NSString *HTML))success
+            failure:(void (^)(NSError *error))failure
+{
+    [self loadRequest:request MIMEType:nil textEncodingName:nil progress:progress success:^NSData *(NSHTTPURLResponse *response, NSData *data) {
+        NSStringEncoding stringEncoding = NSUTF8StringEncoding;
+        if (response.textEncodingName) {
+            CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName);
+            if (encoding != kCFStringEncodingInvalidId) {
+                stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);
+            }
+        }
+
+        NSString *string = [[NSString alloc] initWithData:data encoding:stringEncoding];
+        if (success) {
+            string = success(response, string);
+        }
+
+        return [string dataUsingEncoding:stringEncoding];
+    } failure:failure];
+}
+
+- (void)loadRequest:(NSURLRequest *)request
+           MIMEType:(NSString *)MIMEType
+   textEncodingName:(NSString *)textEncodingName
+           progress:(void (^)(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite))progress
+            success:(NSData * (^)(NSHTTPURLResponse *response, NSData *data))success
+            failure:(void (^)(NSError *error))failure
+{
+    NSParameterAssert(request);
+
+    if (self.af_HTTPRequestOperation) {
+        [self.af_HTTPRequestOperation cancel];
+    }
+
+    request = [self.requestSerializer requestBySerializingRequest:request withParameters:nil error:nil];
+
+    self.af_HTTPRequestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
+    self.af_HTTPRequestOperation.responseSerializer = self.responseSerializer;
+
+    __weak __typeof(self)weakSelf = self;
+    [self.af_HTTPRequestOperation setDownloadProgressBlock:progress];
+    [self.af_HTTPRequestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id __unused responseObject) {
+        NSData *data = success ? success(operation.response, operation.responseData) : operation.responseData;
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wgnu"
+        __strong __typeof(weakSelf) strongSelf = weakSelf;
+        [strongSelf loadData:data MIMEType:(MIMEType ?: [operation.response MIMEType]) textEncodingName:(textEncodingName ?: [operation.response textEncodingName]) baseURL:[operation.response URL]];
+#pragma clang diagnostic pop
+    } failure:^(AFHTTPRequestOperation * __unused operation, NSError *error) {
+        if (failure) {
+            failure(error);
+        }
+    }];
+
+    [self.af_HTTPRequestOperation start];
+}
+
+@end
+
+#endif
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperation.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperation.h
new file mode 120000
index 00000000000..ac762c82387
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperation.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPRequestOperation.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperationManager.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperationManager.h
new file mode 120000
index 00000000000..9dcc623c638
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPRequestOperationManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPRequestOperationManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPSessionManager.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPSessionManager.h
new file mode 120000
index 00000000000..56feb9fb85e
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFHTTPSessionManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPSessionManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkActivityIndicatorManager.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkActivityIndicatorManager.h
new file mode 120000
index 00000000000..67519d98485
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkActivityIndicatorManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkReachabilityManager.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkReachabilityManager.h
new file mode 120000
index 00000000000..68fc7744f28
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworkReachabilityManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFNetworkReachabilityManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworking.h
new file mode 120000
index 00000000000..a5a38da7dc9
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFSecurityPolicy.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFSecurityPolicy.h
new file mode 120000
index 00000000000..fd1322db9c2
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFSecurityPolicy.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFSecurityPolicy.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFURLConnectionOperation.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLConnectionOperation.h
new file mode 120000
index 00000000000..d9b35fb754f
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLConnectionOperation.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLConnectionOperation.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFURLRequestSerialization.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLRequestSerialization.h
new file mode 120000
index 00000000000..ca8209b81f9
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLRequestSerialization.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLRequestSerialization.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFURLResponseSerialization.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLResponseSerialization.h
new file mode 120000
index 00000000000..e36a765d826
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLResponseSerialization.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLResponseSerialization.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/AFURLSessionManager.h b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLSessionManager.h
new file mode 120000
index 00000000000..835101de7bf
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/AFURLSessionManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLSessionManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIActivityIndicatorView+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIActivityIndicatorView+AFNetworking.h
new file mode 120000
index 00000000000..c534ebfb02a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIActivityIndicatorView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIAlertView+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIAlertView+AFNetworking.h
new file mode 120000
index 00000000000..f9928133851
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIAlertView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIButton+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIButton+AFNetworking.h
new file mode 120000
index 00000000000..8f2e221939a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIButton+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIImageView+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIImageView+AFNetworking.h
new file mode 120000
index 00000000000..a95d67380f1
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIImageView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIKit+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIKit+AFNetworking.h
new file mode 120000
index 00000000000..95017cce573
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIKit+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIKit+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIProgressView+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIProgressView+AFNetworking.h
new file mode 120000
index 00000000000..730b167dcde
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIProgressView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIRefreshControl+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIRefreshControl+AFNetworking.h
new file mode 120000
index 00000000000..8efd8262093
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIRefreshControl+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/AFNetworking/UIWebView+AFNetworking.h b/cocoapods/Pods/Headers/Build/AFNetworking/UIWebView+AFNetworking.h
new file mode 120000
index 00000000000..c8df6ef17b8
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/AFNetworking/UIWebView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/hpple/TFHpple.h b/cocoapods/Pods/Headers/Build/hpple/TFHpple.h
new file mode 120000
index 00000000000..f4e7a36dc2b
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/hpple/TFHpple.h
@@ -0,0 +1 @@
+../../../hpple/TFHpple.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/hpple/TFHppleElement.h b/cocoapods/Pods/Headers/Build/hpple/TFHppleElement.h
new file mode 120000
index 00000000000..f56854016db
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/hpple/TFHppleElement.h
@@ -0,0 +1 @@
+../../../hpple/TFHppleElement.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Build/hpple/XPathQuery.h b/cocoapods/Pods/Headers/Build/hpple/XPathQuery.h
new file mode 120000
index 00000000000..809f046cc0a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Build/hpple/XPathQuery.h
@@ -0,0 +1 @@
+../../../hpple/XPathQuery.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperation.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperation.h
new file mode 120000
index 00000000000..ac762c82387
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperation.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPRequestOperation.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperationManager.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperationManager.h
new file mode 120000
index 00000000000..9dcc623c638
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPRequestOperationManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPRequestOperationManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPSessionManager.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPSessionManager.h
new file mode 120000
index 00000000000..56feb9fb85e
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFHTTPSessionManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFHTTPSessionManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkActivityIndicatorManager.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkActivityIndicatorManager.h
new file mode 120000
index 00000000000..67519d98485
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkActivityIndicatorManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkReachabilityManager.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkReachabilityManager.h
new file mode 120000
index 00000000000..68fc7744f28
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworkReachabilityManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFNetworkReachabilityManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworking.h
new file mode 120000
index 00000000000..a5a38da7dc9
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFSecurityPolicy.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFSecurityPolicy.h
new file mode 120000
index 00000000000..fd1322db9c2
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFSecurityPolicy.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFSecurityPolicy.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFURLConnectionOperation.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLConnectionOperation.h
new file mode 120000
index 00000000000..d9b35fb754f
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLConnectionOperation.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLConnectionOperation.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFURLRequestSerialization.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLRequestSerialization.h
new file mode 120000
index 00000000000..ca8209b81f9
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLRequestSerialization.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLRequestSerialization.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFURLResponseSerialization.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLResponseSerialization.h
new file mode 120000
index 00000000000..e36a765d826
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLResponseSerialization.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLResponseSerialization.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/AFURLSessionManager.h b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLSessionManager.h
new file mode 120000
index 00000000000..835101de7bf
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/AFURLSessionManager.h
@@ -0,0 +1 @@
+../../../AFNetworking/AFNetworking/AFURLSessionManager.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIActivityIndicatorView+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIActivityIndicatorView+AFNetworking.h
new file mode 120000
index 00000000000..c534ebfb02a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIActivityIndicatorView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIAlertView+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIAlertView+AFNetworking.h
new file mode 120000
index 00000000000..f9928133851
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIAlertView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIButton+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIButton+AFNetworking.h
new file mode 120000
index 00000000000..8f2e221939a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIButton+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIImageView+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIImageView+AFNetworking.h
new file mode 120000
index 00000000000..a95d67380f1
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIImageView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIKit+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIKit+AFNetworking.h
new file mode 120000
index 00000000000..95017cce573
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIKit+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIKit+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIProgressView+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIProgressView+AFNetworking.h
new file mode 120000
index 00000000000..730b167dcde
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIProgressView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIRefreshControl+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIRefreshControl+AFNetworking.h
new file mode 120000
index 00000000000..8efd8262093
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIRefreshControl+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/AFNetworking/UIWebView+AFNetworking.h b/cocoapods/Pods/Headers/Public/AFNetworking/UIWebView+AFNetworking.h
new file mode 120000
index 00000000000..c8df6ef17b8
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/AFNetworking/UIWebView+AFNetworking.h
@@ -0,0 +1 @@
+../../../AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/hpple/TFHpple.h b/cocoapods/Pods/Headers/Public/hpple/TFHpple.h
new file mode 120000
index 00000000000..f4e7a36dc2b
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/hpple/TFHpple.h
@@ -0,0 +1 @@
+../../../hpple/TFHpple.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/hpple/TFHppleElement.h b/cocoapods/Pods/Headers/Public/hpple/TFHppleElement.h
new file mode 120000
index 00000000000..f56854016db
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/hpple/TFHppleElement.h
@@ -0,0 +1 @@
+../../../hpple/TFHppleElement.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Headers/Public/hpple/XPathQuery.h b/cocoapods/Pods/Headers/Public/hpple/XPathQuery.h
new file mode 120000
index 00000000000..809f046cc0a
--- /dev/null
+++ b/cocoapods/Pods/Headers/Public/hpple/XPathQuery.h
@@ -0,0 +1 @@
+../../../hpple/XPathQuery.h
\ No newline at end of file
diff --git a/cocoapods/Pods/Manifest.lock b/cocoapods/Pods/Manifest.lock
new file mode 100644
index 00000000000..7085dcd0544
--- /dev/null
+++ b/cocoapods/Pods/Manifest.lock
@@ -0,0 +1,33 @@
+PODS:
+  - AFNetworking (2.4.1):
+    - AFNetworking/NSURLConnection
+    - AFNetworking/NSURLSession
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+    - AFNetworking/UIKit
+  - AFNetworking/NSURLConnection (2.4.1):
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+  - AFNetworking/NSURLSession (2.4.1):
+    - AFNetworking/Reachability
+    - AFNetworking/Security
+    - AFNetworking/Serialization
+  - AFNetworking/Reachability (2.4.1)
+  - AFNetworking/Security (2.4.1)
+  - AFNetworking/Serialization (2.4.1)
+  - AFNetworking/UIKit (2.4.1):
+    - AFNetworking/NSURLConnection
+    - AFNetworking/NSURLSession
+  - hpple (0.2.0)
+
+DEPENDENCIES:
+  - AFNetworking (~> 2.4)
+  - hpple (~> 0.2)
+
+SPEC CHECKSUMS:
+  AFNetworking: 0aabc6fae66d6e5d039eeb21c315843c7aae51ab
+  hpple: f4eb7c21a8db83ec264e5d614ec7509e10e5adec
+
+COCOAPODS: 0.34.4
diff --git a/cocoapods/Pods/Pods.xcodeproj/project.pbxproj b/cocoapods/Pods/Pods.xcodeproj/project.pbxproj
new file mode 100644
index 00000000000..c7f3e6ef7e9
--- /dev/null
+++ b/cocoapods/Pods/Pods.xcodeproj/project.pbxproj
@@ -0,0 +1,2494 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>archiveVersion</key>
+	<string>1</string>
+	<key>classes</key>
+	<dict/>
+	<key>objectVersion</key>
+	<string>46</string>
+	<key>objects</key>
+	<dict>
+		<key>0465E7C1E5F81708640EB722</key>
+		<dict>
+			<key>fileRef</key>
+			<string>257EC0361BEA6D22E213265F</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>04C6BDF8D7AD4CCACCB2FC2E</key>
+		<dict>
+			<key>fileRef</key>
+			<string>26977B8265F67BCCE6E79CFF</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>05416E8135FCF4320CDCB28A</key>
+		<dict>
+			<key>buildConfigurations</key>
+			<array>
+				<string>8BFDAC4E274655DA096EE1B3</string>
+				<string>0626370F6051494182BB836B</string>
+			</array>
+			<key>defaultConfigurationIsVisible</key>
+			<string>0</string>
+			<key>defaultConfigurationName</key>
+			<string>Release</string>
+			<key>isa</key>
+			<string>XCConfigurationList</string>
+		</dict>
+		<key>054B08F0C8CF10D17203EAE7</key>
+		<dict>
+			<key>fileRef</key>
+			<string>465373BE5C4929587BA607AC</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>0626370F6051494182BB836B</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>B22D81AE3CF36C34E86F1951</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>YES</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>GCC_PREFIX_HEADER</key>
+				<string>Target Support Files/Pods-hpple/Pods-hpple-prefix.pch</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_CFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_CPLUSPLUSFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+				<key>VALIDATE_PRODUCT</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Release</string>
+		</dict>
+		<key>075607582871DD1441FF2852</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods.debug.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>08848E7A3FC799FA63B46C68</key>
+		<dict>
+			<key>fileRef</key>
+			<string>E4329317410EBACF8EF522A9</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>097ABC15117B245D424ECA27</key>
+		<dict>
+			<key>fileRef</key>
+			<string>C365C4656527CC69538ED112</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>0C1D42D9BF1CFA3938BD4C74</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>4AC5A293F59F2CAB158E6757</string>
+				<string>93C922390A4003CBFB963039</string>
+				<string>257EC0361BEA6D22E213265F</string>
+				<string>AD99F778AC4E47B8C2328E78</string>
+				<string>AE2607EEA56DFC33410AF39A</string>
+				<string>465373BE5C4929587BA607AC</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>NSURLConnection</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>109EA03193E37AF8D639396D</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>E4329317410EBACF8EF522A9</string>
+				<string>0C1D42D9BF1CFA3938BD4C74</string>
+				<string>3EAAC80DEE4DC8B548AC86CA</string>
+				<string>DCF761398122B24B26E7441E</string>
+				<string>9593C34C21DDAE51FA86FF01</string>
+				<string>2B3AD71907589181D78681B8</string>
+				<string>DB8F87FCDD968745323F4D27</string>
+				<string>9AB609D782AA7572AD7BB1FB</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>AFNetworking</string>
+			<key>path</key>
+			<string>AFNetworking</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>159B682BAC6C5A44DC35840A</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>26F1E03225E99566D883103D</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>NO</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_DYNAMIC_NO_PIC</key>
+				<string>NO</string>
+				<key>GCC_OPTIMIZATION_LEVEL</key>
+				<string>0</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>GCC_PREFIX_HEADER</key>
+				<string>Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix.pch</string>
+				<key>GCC_PREPROCESSOR_DEFINITIONS</key>
+				<array>
+					<string>DEBUG=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>GCC_SYMBOLS_PRIVATE_EXTERN</key>
+				<string>NO</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Debug</string>
+		</dict>
+		<key>1887E80BC6F16CAB9973E838</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>wrapper.framework</string>
+			<key>name</key>
+			<string>MobileCoreServices.framework</string>
+			<key>path</key>
+			<string>Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/System/Library/Frameworks/MobileCoreServices.framework</string>
+			<key>sourceTree</key>
+			<string>DEVELOPER_DIR</string>
+		</dict>
+		<key>1991ADD1F89A00A42B36F91A</key>
+		<dict>
+			<key>explicitFileType</key>
+			<string>archive.ar</string>
+			<key>includeInIndex</key>
+			<string>0</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>path</key>
+			<string>libPods-AFNetworking.a</string>
+			<key>sourceTree</key>
+			<string>BUILT_PRODUCTS_DIR</string>
+		</dict>
+		<key>19EEC18808E583B00C267C57</key>
+		<dict>
+			<key>fileRef</key>
+			<string>623D16E2A42F23D3527D4AF2</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>1ACE51BF846FF9CD8075694E</key>
+		<dict>
+			<key>fileRef</key>
+			<string>68E07FA72B5A7501C61F6DA6</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>1B149B321697E3711CFDCB03</key>
+		<dict>
+			<key>fileRef</key>
+			<string>A7DC6A2F0A6DABC0C0929AF2</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>1F3CDFE42797133642675348</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>wrapper.framework</string>
+			<key>name</key>
+			<string>CoreGraphics.framework</string>
+			<key>path</key>
+			<string>Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/System/Library/Frameworks/CoreGraphics.framework</string>
+			<key>sourceTree</key>
+			<string>DEVELOPER_DIR</string>
+		</dict>
+		<key>20EBAD26AED7D7CF8D3A0F25</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>E57C248683777E073C60AD6A</string>
+				<string>0465E7C1E5F81708640EB722</string>
+				<string>3C5D7D15E52AF5893DEFD520</string>
+				<string>68D7AA9E5797F8CAD87ABEAB</string>
+				<string>832D7AA053DF39E7B58A06A5</string>
+				<string>08848E7A3FC799FA63B46C68</string>
+				<string>097ABC15117B245D424ECA27</string>
+				<string>7E425B9E281D3FE187122153</string>
+				<string>67E0C16B926EC5876F564240</string>
+				<string>471FC0565A4D9A80783CA270</string>
+				<string>75665DE07E8B31062BCFF177</string>
+				<string>ADCADBB5B9E54E1073B6D775</string>
+				<string>6B2A61A198E36B09F1348723</string>
+				<string>DCF97108D38149394B417B81</string>
+				<string>EE47BD0F9704C21223D8B8A6</string>
+				<string>E128380999AEBDD50DC753DB</string>
+				<string>65F35973557D09E3E2051ADE</string>
+				<string>5F697D90DB7CBAC38D609707</string>
+				<string>E2A0DF3D26E4061653656BF0</string>
+			</array>
+			<key>isa</key>
+			<string>PBXHeadersBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>257EC0361BEA6D22E213265F</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFHTTPRequestOperationManager.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPRequestOperationManager.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>25D4B75E2A80509AE5444635</key>
+		<dict>
+			<key>fileRef</key>
+			<string>9630F53485177433D5533504</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>260F3AF1FE0D3D44BFC33B79</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>wrapper.framework</string>
+			<key>name</key>
+			<string>Security.framework</string>
+			<key>path</key>
+			<string>Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/System/Library/Frameworks/Security.framework</string>
+			<key>sourceTree</key>
+			<string>DEVELOPER_DIR</string>
+		</dict>
+		<key>26977B8265F67BCCE6E79CFF</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>wrapper.framework</string>
+			<key>name</key>
+			<string>SystemConfiguration.framework</string>
+			<key>path</key>
+			<string>Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/System/Library/Frameworks/SystemConfiguration.framework</string>
+			<key>sourceTree</key>
+			<string>DEVELOPER_DIR</string>
+		</dict>
+		<key>26F1E03225E99566D883103D</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods-AFNetworking-Private.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>2A1FBE07FA9D0CC3659E6DA4</key>
+		<dict>
+			<key>fileRef</key>
+			<string>1F3CDFE42797133642675348</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>2B3AD71907589181D78681B8</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>C58421329ED632E6A3B99EDC</string>
+				<string>A88BBB882DFB044896CAC34B</string>
+				<string>BBB7D8B92869D32E75E85BE0</string>
+				<string>D84360A51F9C076B59EB8576</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Serialization</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>2BD652846BD6E117952A1F5D</key>
+		<dict>
+			<key>fileRef</key>
+			<string>36290B4D03B0555FD57F890E</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>2E8EF59CC9196603C820DB1F</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIImageView+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIImageView+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>2ED2F6EEC870156299BB0DAC</key>
+		<dict>
+			<key>fileRef</key>
+			<string>F49BA14B4FC575F8AD8EAD6E</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>2F16B018385C6F8FDC92D17A</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods-AFNetworking.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>32885C71CF15CF6DB3BA1C7A</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>7C5825D144921555ED73C79B</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Frameworks</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>36290B4D03B0555FD57F890E</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIAlertView+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIAlertView+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>36396F170DAE83209B9FFB91</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>Pods-hpple-prefix.pch</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>39B7669541E9901100F3F778</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIProgressView+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIProgressView+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>3AE32C3E0C4F14448503CA4E</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIWebView+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIWebView+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>3B441D3EDA8CBB3502C3501B</key>
+		<dict>
+			<key>buildConfigurations</key>
+			<array>
+				<string>159B682BAC6C5A44DC35840A</string>
+				<string>AC6FD8D2E1D44B1CD4B47547</string>
+			</array>
+			<key>defaultConfigurationIsVisible</key>
+			<string>0</string>
+			<key>defaultConfigurationName</key>
+			<string>Release</string>
+			<key>isa</key>
+			<string>XCConfigurationList</string>
+		</dict>
+		<key>3C5D7D15E52AF5893DEFD520</key>
+		<dict>
+			<key>fileRef</key>
+			<string>C5D5E605A7A46FCB108B1E73</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>3DA05AC221091C9849BAD3E5</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>5C377A38D10A2CD4F12AC60C</string>
+				<string>7BF9B2F8F74E410F49A84D3F</string>
+				<string>91608CE08365C60E6A664960</string>
+				<string>438D894034F9CA3C4DEC4CBE</string>
+				<string>EB83FF8F912DCAC97D9B77AC</string>
+				<string>075607582871DD1441FF2852</string>
+				<string>FC98B6B3198F4F6A46322AEC</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Pods</string>
+			<key>path</key>
+			<string>Target Support Files/Pods</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>3E13435AEB7C26FD8E1F8FC0</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>109EA03193E37AF8D639396D</string>
+				<string>65239539C347AF9713A4CE09</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Pods</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>3E47CF5B702B493F5F1A8E76</key>
+		<dict>
+			<key>fileRef</key>
+			<string>4DE792633EEBC4BA2AD2B485</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>3EAAC80DEE4DC8B548AC86CA</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>C5D5E605A7A46FCB108B1E73</string>
+				<string>4DE792633EEBC4BA2AD2B485</string>
+				<string>D9974E2F9C08EEE417E162C5</string>
+				<string>D66C08416F5673A5BE0D5780</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>NSURLSession</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>3EFEF9D3AC3895C7007EC4F1</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIButton+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIButton+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>425C67E16129641880AC020F</key>
+		<dict>
+			<key>buildConfigurations</key>
+			<array>
+				<string>86EE3B76D9ADD4BA211FFFD3</string>
+				<string>4DD70F6BE48BED4CB728390B</string>
+			</array>
+			<key>defaultConfigurationIsVisible</key>
+			<string>0</string>
+			<key>defaultConfigurationName</key>
+			<string>Release</string>
+			<key>isa</key>
+			<string>XCConfigurationList</string>
+		</dict>
+		<key>438D894034F9CA3C4DEC4CBE</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>Pods-environment.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>465373BE5C4929587BA607AC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFURLConnectionOperation.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLConnectionOperation.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>46AB559D04A734598CF66AE6</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>2A1FBE07FA9D0CC3659E6DA4</string>
+				<string>DD2B4C7E1EE416856BD7F3D8</string>
+				<string>6D92D1D612FC76249C0F2980</string>
+				<string>923D502BB5F80D140C16763D</string>
+				<string>04C6BDF8D7AD4CCACCB2FC2E</string>
+			</array>
+			<key>isa</key>
+			<string>PBXFrameworksBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>471FC0565A4D9A80783CA270</key>
+		<dict>
+			<key>fileRef</key>
+			<string>BBB7D8B92869D32E75E85BE0</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>48392DE733C29178380B637A</key>
+		<dict>
+			<key>fileRef</key>
+			<string>A88BBB882DFB044896CAC34B</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>4AC5A293F59F2CAB158E6757</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFHTTPRequestOperation.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPRequestOperation.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>4B97C700A44275378518197B</key>
+		<dict>
+			<key>explicitFileType</key>
+			<string>archive.ar</string>
+			<key>includeInIndex</key>
+			<string>0</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>path</key>
+			<string>libPods.a</string>
+			<key>sourceTree</key>
+			<string>BUILT_PRODUCTS_DIR</string>
+		</dict>
+		<key>4DD70F6BE48BED4CB728390B</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>FC98B6B3198F4F6A46322AEC</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>YES</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_CFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_CPLUSPLUSFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+				<key>VALIDATE_PRODUCT</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Release</string>
+		</dict>
+		<key>4DE792633EEBC4BA2AD2B485</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFHTTPSessionManager.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPSessionManager.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>53DC3DE672F53B977DC7AFD0</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>98E785B8B74C7D5824F6B5B9</string>
+				<string>B22D81AE3CF36C34E86F1951</string>
+				<string>623D16E2A42F23D3527D4AF2</string>
+				<string>36396F170DAE83209B9FFB91</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Support Files</string>
+			<key>path</key>
+			<string>../Target Support Files/Pods-hpple</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>5429CA982636C18FA84520D0</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>6E374124E8620A609A5EDDB1</string>
+			</array>
+			<key>isa</key>
+			<string>PBXFrameworksBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>5857AA4EB897A6416554A758</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>7C34756506CD8BE3F054DCA6</string>
+				<string>72A65B40CA4BF8274C063C29</string>
+				<string>3E47CF5B702B493F5F1A8E76</string>
+				<string>DA0C93FE66AFDAA91D3503A5</string>
+				<string>1ACE51BF846FF9CD8075694E</string>
+				<string>9AFD68BD4E86D8C360185AC1</string>
+				<string>054B08F0C8CF10D17203EAE7</string>
+				<string>48392DE733C29178380B637A</string>
+				<string>E51291C055BDD34807353CA7</string>
+				<string>C81225DD1A5E825CDC4178D2</string>
+				<string>EA1670AFEC96115A6B3691AC</string>
+				<string>5F2D265EB4F74A619C7F0FAE</string>
+				<string>2BD652846BD6E117952A1F5D</string>
+				<string>C192E3D87A5AF38EEA935CE2</string>
+				<string>FA5F32B126514F19B7A61C54</string>
+				<string>25D4B75E2A80509AE5444635</string>
+				<string>1B149B321697E3711CFDCB03</string>
+				<string>761901E8B740961E97922BCB</string>
+			</array>
+			<key>isa</key>
+			<string>PBXSourcesBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>5A46ACE2008B7E1F08F3AD9B</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIImageView+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIImageView+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>5ADFC3ACE009BD19A35CEC69</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>19EEC18808E583B00C267C57</string>
+				<string>7759282C6478E2DA0210B0C8</string>
+				<string>67613AC1E69D495A541ACE40</string>
+				<string>B9DDD9F1EC367FE91EC02A41</string>
+			</array>
+			<key>isa</key>
+			<string>PBXSourcesBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>5C377A38D10A2CD4F12AC60C</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text</string>
+			<key>path</key>
+			<string>Pods-acknowledgements.markdown</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>5C96565D47DA60CE55039768</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFNetworkActivityIndicatorManager.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/AFNetworkActivityIndicatorManager.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>5DB91741E2106918FC804481</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>3DA05AC221091C9849BAD3E5</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Targets Support Files</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>5F2D265EB4F74A619C7F0FAE</key>
+		<dict>
+			<key>fileRef</key>
+			<string>FB5DB4FD1D76714D74ED8B90</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>5F697D90DB7CBAC38D609707</key>
+		<dict>
+			<key>fileRef</key>
+			<string>8226620F63C64ADACC62EDD7</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>623D16E2A42F23D3527D4AF2</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>Pods-hpple-dummy.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>65239539C347AF9713A4CE09</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>FD79AD516A32F136FD01980F</string>
+				<string>C21C86767B67F685CC91CD17</string>
+				<string>F49BA14B4FC575F8AD8EAD6E</string>
+				<string>8310A7038B0D78C18A08B222</string>
+				<string>89768858F184252ADDFC6A96</string>
+				<string>B13ED283705EFFB09D7E5193</string>
+				<string>53DC3DE672F53B977DC7AFD0</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>hpple</string>
+			<key>path</key>
+			<string>hpple</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>65F35973557D09E3E2051ADE</key>
+		<dict>
+			<key>fileRef</key>
+			<string>39B7669541E9901100F3F778</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>67613AC1E69D495A541ACE40</key>
+		<dict>
+			<key>fileRef</key>
+			<string>8310A7038B0D78C18A08B222</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc -DOS_OBJECT_USE_OBJC=0</string>
+			</dict>
+		</dict>
+		<key>67E0C16B926EC5876F564240</key>
+		<dict>
+			<key>fileRef</key>
+			<string>C58421329ED632E6A3B99EDC</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>68D7AA9E5797F8CAD87ABEAB</key>
+		<dict>
+			<key>fileRef</key>
+			<string>D7F1FC20D6B98394EBBFF82D</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>68E07FA72B5A7501C61F6DA6</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFNetworkReachabilityManager.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFNetworkReachabilityManager.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>6B147F6F597FA5779A6A5B7B</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIWebView+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIWebView+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>6B2A61A198E36B09F1348723</key>
+		<dict>
+			<key>fileRef</key>
+			<string>6BC986901109DFA2D0768CCC</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>6BC986901109DFA2D0768CCC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIAlertView+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIAlertView+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>6D249371A9870B15B6514FCA</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIActivityIndicatorView+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>6D92D1D612FC76249C0F2980</key>
+		<dict>
+			<key>fileRef</key>
+			<string>1887E80BC6F16CAB9973E838</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>6E374124E8620A609A5EDDB1</key>
+		<dict>
+			<key>fileRef</key>
+			<string>753F92B7209958C7E403140C</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>6EBCE896D329764497D3463E</key>
+		<dict>
+			<key>containerPortal</key>
+			<string>B7C18A245411F38B6A43F636</string>
+			<key>isa</key>
+			<string>PBXContainerItemProxy</string>
+			<key>proxyType</key>
+			<string>1</string>
+			<key>remoteGlobalIDString</key>
+			<string>E5A0C6369E917827A057D39A</string>
+			<key>remoteInfo</key>
+			<string>Pods-hpple</string>
+		</dict>
+		<key>72A65B40CA4BF8274C063C29</key>
+		<dict>
+			<key>fileRef</key>
+			<string>AD99F778AC4E47B8C2328E78</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>753F92B7209958C7E403140C</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>wrapper.framework</string>
+			<key>name</key>
+			<string>Foundation.framework</string>
+			<key>path</key>
+			<string>Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/System/Library/Frameworks/Foundation.framework</string>
+			<key>sourceTree</key>
+			<string>DEVELOPER_DIR</string>
+		</dict>
+		<key>75665DE07E8B31062BCFF177</key>
+		<dict>
+			<key>fileRef</key>
+			<string>D9974E2F9C08EEE417E162C5</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>75C1F91D36014FA0EDDD43DC</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>EBD3B501654D3F46E8B14F2B</string>
+				<string>32885C71CF15CF6DB3BA1C7A</string>
+				<string>3E13435AEB7C26FD8E1F8FC0</string>
+				<string>AF977BD15F441CFB6CB0A7E1</string>
+				<string>5DB91741E2106918FC804481</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>75E58E47E4E25FD3E8B04D94</key>
+		<dict>
+			<key>fileRef</key>
+			<string>89768858F184252ADDFC6A96</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>760462415E368D0C42A39402</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXTargetDependency</string>
+			<key>target</key>
+			<string>E5A0C6369E917827A057D39A</string>
+			<key>targetProxy</key>
+			<string>6EBCE896D329764497D3463E</string>
+		</dict>
+		<key>761901E8B740961E97922BCB</key>
+		<dict>
+			<key>fileRef</key>
+			<string>3AE32C3E0C4F14448503CA4E</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>7759282C6478E2DA0210B0C8</key>
+		<dict>
+			<key>fileRef</key>
+			<string>C21C86767B67F685CC91CD17</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc -DOS_OBJECT_USE_OBJC=0</string>
+			</dict>
+		</dict>
+		<key>7A87E7F82CDD351DE749AD35</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>83F94E74A5A8F25FBB9A8A52</string>
+				<string>2ED2F6EEC870156299BB0DAC</string>
+				<string>75E58E47E4E25FD3E8B04D94</string>
+			</array>
+			<key>isa</key>
+			<string>PBXHeadersBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>7BF9B2F8F74E410F49A84D3F</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.plist.xml</string>
+			<key>path</key>
+			<string>Pods-acknowledgements.plist</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>7C34756506CD8BE3F054DCA6</key>
+		<dict>
+			<key>fileRef</key>
+			<string>93C922390A4003CBFB963039</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>7C5825D144921555ED73C79B</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>1F3CDFE42797133642675348</string>
+				<string>753F92B7209958C7E403140C</string>
+				<string>1887E80BC6F16CAB9973E838</string>
+				<string>260F3AF1FE0D3D44BFC33B79</string>
+				<string>26977B8265F67BCCE6E79CFF</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>iOS</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>7E425B9E281D3FE187122153</key>
+		<dict>
+			<key>fileRef</key>
+			<string>AE2607EEA56DFC33410AF39A</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>820399BE35D2F7230E34B630</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>Pods-AFNetworking-prefix.pch</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>8226620F63C64ADACC62EDD7</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIRefreshControl+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIRefreshControl+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>8310A7038B0D78C18A08B222</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>TFHppleElement.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>832D7AA053DF39E7B58A06A5</key>
+		<dict>
+			<key>fileRef</key>
+			<string>979D4E8B4BD201FB3E07ED5C</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>83F94E74A5A8F25FBB9A8A52</key>
+		<dict>
+			<key>fileRef</key>
+			<string>FD79AD516A32F136FD01980F</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>853410193A74CB2A9185CBBE</key>
+		<dict>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>CLANG_CXX_LANGUAGE_STANDARD</key>
+				<string>gnu++0x</string>
+				<key>CLANG_CXX_LIBRARY</key>
+				<string>libc++</string>
+				<key>CLANG_ENABLE_MODULES</key>
+				<string>YES</string>
+				<key>CLANG_ENABLE_OBJC_ARC</key>
+				<string>NO</string>
+				<key>CLANG_WARN_BOOL_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_CONSTANT_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_DIRECT_OBJC_ISA_USAGE</key>
+				<string>YES</string>
+				<key>CLANG_WARN_EMPTY_BODY</key>
+				<string>YES</string>
+				<key>CLANG_WARN_ENUM_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_INT_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_OBJC_ROOT_CLASS</key>
+				<string>YES</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>YES</string>
+				<key>GCC_C_LANGUAGE_STANDARD</key>
+				<string>gnu99</string>
+				<key>GCC_DYNAMIC_NO_PIC</key>
+				<string>NO</string>
+				<key>GCC_OPTIMIZATION_LEVEL</key>
+				<string>0</string>
+				<key>GCC_PREPROCESSOR_DEFINITIONS</key>
+				<array>
+					<string>DEBUG=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>GCC_SYMBOLS_PRIVATE_EXTERN</key>
+				<string>NO</string>
+				<key>GCC_WARN_64_TO_32_BIT_CONVERSION</key>
+				<string>YES</string>
+				<key>GCC_WARN_ABOUT_RETURN_TYPE</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNDECLARED_SELECTOR</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNINITIALIZED_AUTOS</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNUSED_FUNCTION</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNUSED_VARIABLE</key>
+				<string>YES</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>ONLY_ACTIVE_ARCH</key>
+				<string>YES</string>
+				<key>STRIP_INSTALLED_PRODUCT</key>
+				<string>NO</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Debug</string>
+		</dict>
+		<key>86EE3B76D9ADD4BA211FFFD3</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>075607582871DD1441FF2852</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>NO</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_DYNAMIC_NO_PIC</key>
+				<string>NO</string>
+				<key>GCC_OPTIMIZATION_LEVEL</key>
+				<string>0</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>GCC_PREPROCESSOR_DEFINITIONS</key>
+				<array>
+					<string>DEBUG=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>GCC_SYMBOLS_PRIVATE_EXTERN</key>
+				<string>NO</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Debug</string>
+		</dict>
+		<key>8967BB0CC414B65CC0ACF0A3</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIKit+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIKit+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>89768858F184252ADDFC6A96</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>XPathQuery.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>8BFDAC4E274655DA096EE1B3</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>B22D81AE3CF36C34E86F1951</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>NO</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_DYNAMIC_NO_PIC</key>
+				<string>NO</string>
+				<key>GCC_OPTIMIZATION_LEVEL</key>
+				<string>0</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>GCC_PREFIX_HEADER</key>
+				<string>Target Support Files/Pods-hpple/Pods-hpple-prefix.pch</string>
+				<key>GCC_PREPROCESSOR_DEFINITIONS</key>
+				<array>
+					<string>DEBUG=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>GCC_SYMBOLS_PRIVATE_EXTERN</key>
+				<string>NO</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Debug</string>
+		</dict>
+		<key>91608CE08365C60E6A664960</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>Pods-dummy.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>923D502BB5F80D140C16763D</key>
+		<dict>
+			<key>fileRef</key>
+			<string>260F3AF1FE0D3D44BFC33B79</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>93C922390A4003CBFB963039</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFHTTPRequestOperation.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPRequestOperation.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>9473898897AE820AF10022E4</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>B177A443A9CA95ED49B8686A</string>
+			</array>
+			<key>isa</key>
+			<string>PBXSourcesBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>9593C34C21DDAE51FA86FF01</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>C365C4656527CC69538ED112</string>
+				<string>E1980A947C8584A384A10EC3</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Security</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>9630F53485177433D5533504</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIProgressView+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIProgressView+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>979D4E8B4BD201FB3E07ED5C</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFNetworkReachabilityManager.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFNetworkReachabilityManager.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>98CB053A36276A0B8ED2075B</key>
+		<dict>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>CLANG_CXX_LANGUAGE_STANDARD</key>
+				<string>gnu++0x</string>
+				<key>CLANG_CXX_LIBRARY</key>
+				<string>libc++</string>
+				<key>CLANG_ENABLE_MODULES</key>
+				<string>YES</string>
+				<key>CLANG_ENABLE_OBJC_ARC</key>
+				<string>NO</string>
+				<key>CLANG_WARN_BOOL_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_CONSTANT_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_DIRECT_OBJC_ISA_USAGE</key>
+				<string>YES</string>
+				<key>CLANG_WARN_EMPTY_BODY</key>
+				<string>YES</string>
+				<key>CLANG_WARN_ENUM_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_INT_CONVERSION</key>
+				<string>YES</string>
+				<key>CLANG_WARN_OBJC_ROOT_CLASS</key>
+				<string>YES</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>NO</string>
+				<key>ENABLE_NS_ASSERTIONS</key>
+				<string>NO</string>
+				<key>GCC_C_LANGUAGE_STANDARD</key>
+				<string>gnu99</string>
+				<key>GCC_PREPROCESSOR_DEFINITIONS</key>
+				<array>
+					<string>RELEASE=1</string>
+				</array>
+				<key>GCC_WARN_64_TO_32_BIT_CONVERSION</key>
+				<string>YES</string>
+				<key>GCC_WARN_ABOUT_RETURN_TYPE</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNDECLARED_SELECTOR</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNINITIALIZED_AUTOS</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNUSED_FUNCTION</key>
+				<string>YES</string>
+				<key>GCC_WARN_UNUSED_VARIABLE</key>
+				<string>YES</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>STRIP_INSTALLED_PRODUCT</key>
+				<string>NO</string>
+				<key>VALIDATE_PRODUCT</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Release</string>
+		</dict>
+		<key>98E785B8B74C7D5824F6B5B9</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods-hpple.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>9AB609D782AA7572AD7BB1FB</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>D7F1FC20D6B98394EBBFF82D</string>
+				<string>5C96565D47DA60CE55039768</string>
+				<string>6D249371A9870B15B6514FCA</string>
+				<string>FB5DB4FD1D76714D74ED8B90</string>
+				<string>6BC986901109DFA2D0768CCC</string>
+				<string>36290B4D03B0555FD57F890E</string>
+				<string>A6B40D6333138630F127E2E7</string>
+				<string>3EFEF9D3AC3895C7007EC4F1</string>
+				<string>2E8EF59CC9196603C820DB1F</string>
+				<string>5A46ACE2008B7E1F08F3AD9B</string>
+				<string>8967BB0CC414B65CC0ACF0A3</string>
+				<string>39B7669541E9901100F3F778</string>
+				<string>9630F53485177433D5533504</string>
+				<string>8226620F63C64ADACC62EDD7</string>
+				<string>A7DC6A2F0A6DABC0C0929AF2</string>
+				<string>6B147F6F597FA5779A6A5B7B</string>
+				<string>3AE32C3E0C4F14448503CA4E</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>UIKit</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>9AFD68BD4E86D8C360185AC1</key>
+		<dict>
+			<key>fileRef</key>
+			<string>E1980A947C8584A384A10EC3</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>A6B40D6333138630F127E2E7</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>UIButton+AFNetworking.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIButton+AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>A7DC6A2F0A6DABC0C0929AF2</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIRefreshControl+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIRefreshControl+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>A88BBB882DFB044896CAC34B</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFURLRequestSerialization.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLRequestSerialization.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>AC6FD8D2E1D44B1CD4B47547</key>
+		<dict>
+			<key>baseConfigurationReference</key>
+			<string>26F1E03225E99566D883103D</string>
+			<key>buildSettings</key>
+			<dict>
+				<key>ALWAYS_SEARCH_USER_PATHS</key>
+				<string>NO</string>
+				<key>COPY_PHASE_STRIP</key>
+				<string>YES</string>
+				<key>DSTROOT</key>
+				<string>/tmp/xcodeproj.dst</string>
+				<key>GCC_PRECOMPILE_PREFIX_HEADER</key>
+				<string>YES</string>
+				<key>GCC_PREFIX_HEADER</key>
+				<string>Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix.pch</string>
+				<key>INSTALL_PATH</key>
+				<string>$(BUILT_PRODUCTS_DIR)</string>
+				<key>IPHONEOS_DEPLOYMENT_TARGET</key>
+				<string>6.0</string>
+				<key>OTHER_CFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_CPLUSPLUSFLAGS</key>
+				<array>
+					<string>-DNS_BLOCK_ASSERTIONS=1</string>
+					<string>$(inherited)</string>
+				</array>
+				<key>OTHER_LDFLAGS</key>
+				<string></string>
+				<key>OTHER_LIBTOOLFLAGS</key>
+				<string></string>
+				<key>PRODUCT_NAME</key>
+				<string>$(TARGET_NAME)</string>
+				<key>PUBLIC_HEADERS_FOLDER_PATH</key>
+				<string>$(TARGET_NAME)</string>
+				<key>SDKROOT</key>
+				<string>iphoneos</string>
+				<key>SKIP_INSTALL</key>
+				<string>YES</string>
+				<key>VALIDATE_PRODUCT</key>
+				<string>YES</string>
+			</dict>
+			<key>isa</key>
+			<string>XCBuildConfiguration</string>
+			<key>name</key>
+			<string>Release</string>
+		</dict>
+		<key>ACC360DC91D91D8973461A32</key>
+		<dict>
+			<key>explicitFileType</key>
+			<string>archive.ar</string>
+			<key>includeInIndex</key>
+			<string>0</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>path</key>
+			<string>libPods-hpple.a</string>
+			<key>sourceTree</key>
+			<string>BUILT_PRODUCTS_DIR</string>
+		</dict>
+		<key>AD99F778AC4E47B8C2328E78</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFHTTPRequestOperationManager.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPRequestOperationManager.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>ADCADBB5B9E54E1073B6D775</key>
+		<dict>
+			<key>fileRef</key>
+			<string>6D249371A9870B15B6514FCA</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>AE2607EEA56DFC33410AF39A</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFURLConnectionOperation.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLConnectionOperation.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>AE3AE9C3B6BFEC0BB455316A</key>
+		<dict>
+			<key>buildConfigurationList</key>
+			<string>425C67E16129641880AC020F</string>
+			<key>buildPhases</key>
+			<array>
+				<string>9473898897AE820AF10022E4</string>
+				<string>5429CA982636C18FA84520D0</string>
+			</array>
+			<key>buildRules</key>
+			<array/>
+			<key>dependencies</key>
+			<array>
+				<string>D7016271521407431AA3616E</string>
+				<string>760462415E368D0C42A39402</string>
+			</array>
+			<key>isa</key>
+			<string>PBXNativeTarget</string>
+			<key>name</key>
+			<string>Pods</string>
+			<key>productName</key>
+			<string>Pods</string>
+			<key>productReference</key>
+			<string>4B97C700A44275378518197B</string>
+			<key>productType</key>
+			<string>com.apple.product-type.library.static</string>
+		</dict>
+		<key>AE42885CE4222F46DA0D23BC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>Pods-AFNetworking-dummy.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>AF977BD15F441CFB6CB0A7E1</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>4B97C700A44275378518197B</string>
+				<string>1991ADD1F89A00A42B36F91A</string>
+				<string>ACC360DC91D91D8973461A32</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Products</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>B13ED283705EFFB09D7E5193</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>XPathQuery.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>B177A443A9CA95ED49B8686A</key>
+		<dict>
+			<key>fileRef</key>
+			<string>91608CE08365C60E6A664960</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>B22D81AE3CF36C34E86F1951</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods-hpple-Private.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>B7C18A245411F38B6A43F636</key>
+		<dict>
+			<key>attributes</key>
+			<dict>
+				<key>LastUpgradeCheck</key>
+				<string>0510</string>
+			</dict>
+			<key>buildConfigurationList</key>
+			<string>D231DE84AC27009DC400F3E7</string>
+			<key>compatibilityVersion</key>
+			<string>Xcode 3.2</string>
+			<key>developmentRegion</key>
+			<string>English</string>
+			<key>hasScannedForEncodings</key>
+			<string>0</string>
+			<key>isa</key>
+			<string>PBXProject</string>
+			<key>knownRegions</key>
+			<array>
+				<string>en</string>
+			</array>
+			<key>mainGroup</key>
+			<string>75C1F91D36014FA0EDDD43DC</string>
+			<key>productRefGroup</key>
+			<string>AF977BD15F441CFB6CB0A7E1</string>
+			<key>projectDirPath</key>
+			<string></string>
+			<key>projectReferences</key>
+			<array/>
+			<key>projectRoot</key>
+			<string></string>
+			<key>targets</key>
+			<array>
+				<string>AE3AE9C3B6BFEC0BB455316A</string>
+				<string>FDC9A847FCE7AA138C7D5622</string>
+				<string>E5A0C6369E917827A057D39A</string>
+			</array>
+		</dict>
+		<key>B9DDD9F1EC367FE91EC02A41</key>
+		<dict>
+			<key>fileRef</key>
+			<string>B13ED283705EFFB09D7E5193</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc -DOS_OBJECT_USE_OBJC=0</string>
+			</dict>
+		</dict>
+		<key>BBB7D8B92869D32E75E85BE0</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFURLResponseSerialization.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLResponseSerialization.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>BD0B29FE5EC4AF1A236130C1</key>
+		<dict>
+			<key>containerPortal</key>
+			<string>B7C18A245411F38B6A43F636</string>
+			<key>isa</key>
+			<string>PBXContainerItemProxy</string>
+			<key>proxyType</key>
+			<string>1</string>
+			<key>remoteGlobalIDString</key>
+			<string>FDC9A847FCE7AA138C7D5622</string>
+			<key>remoteInfo</key>
+			<string>Pods-AFNetworking</string>
+		</dict>
+		<key>C192E3D87A5AF38EEA935CE2</key>
+		<dict>
+			<key>fileRef</key>
+			<string>3EFEF9D3AC3895C7007EC4F1</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>C21C86767B67F685CC91CD17</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>path</key>
+			<string>TFHpple.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>C365C4656527CC69538ED112</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFSecurityPolicy.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFSecurityPolicy.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>C41BF562ECB7E1BF12E62826</key>
+		<dict>
+			<key>fileRef</key>
+			<string>753F92B7209958C7E403140C</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>C58421329ED632E6A3B99EDC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFURLRequestSerialization.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLRequestSerialization.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>C5D5E605A7A46FCB108B1E73</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFHTTPSessionManager.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFHTTPSessionManager.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>C81225DD1A5E825CDC4178D2</key>
+		<dict>
+			<key>fileRef</key>
+			<string>D66C08416F5673A5BE0D5780</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>D231DE84AC27009DC400F3E7</key>
+		<dict>
+			<key>buildConfigurations</key>
+			<array>
+				<string>853410193A74CB2A9185CBBE</string>
+				<string>98CB053A36276A0B8ED2075B</string>
+			</array>
+			<key>defaultConfigurationIsVisible</key>
+			<string>0</string>
+			<key>defaultConfigurationName</key>
+			<string>Release</string>
+			<key>isa</key>
+			<string>XCConfigurationList</string>
+		</dict>
+		<key>D66C08416F5673A5BE0D5780</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFURLSessionManager.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLSessionManager.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>D7016271521407431AA3616E</key>
+		<dict>
+			<key>isa</key>
+			<string>PBXTargetDependency</string>
+			<key>target</key>
+			<string>FDC9A847FCE7AA138C7D5622</string>
+			<key>targetProxy</key>
+			<string>BD0B29FE5EC4AF1A236130C1</string>
+		</dict>
+		<key>D7F1FC20D6B98394EBBFF82D</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFNetworkActivityIndicatorManager.h</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/AFNetworkActivityIndicatorManager.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>D84360A51F9C076B59EB8576</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFURLResponseSerialization.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLResponseSerialization.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>D9974E2F9C08EEE417E162C5</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFURLSessionManager.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFURLSessionManager.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>DA0C93FE66AFDAA91D3503A5</key>
+		<dict>
+			<key>fileRef</key>
+			<string>5C96565D47DA60CE55039768</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>DB8F87FCDD968745323F4D27</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>2F16B018385C6F8FDC92D17A</string>
+				<string>26F1E03225E99566D883103D</string>
+				<string>AE42885CE4222F46DA0D23BC</string>
+				<string>820399BE35D2F7230E34B630</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Support Files</string>
+			<key>path</key>
+			<string>../Target Support Files/Pods-AFNetworking</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>DCF761398122B24B26E7441E</key>
+		<dict>
+			<key>children</key>
+			<array>
+				<string>979D4E8B4BD201FB3E07ED5C</string>
+				<string>68E07FA72B5A7501C61F6DA6</string>
+			</array>
+			<key>isa</key>
+			<string>PBXGroup</string>
+			<key>name</key>
+			<string>Reachability</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>DCF97108D38149394B417B81</key>
+		<dict>
+			<key>fileRef</key>
+			<string>A6B40D6333138630F127E2E7</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>DD2B4C7E1EE416856BD7F3D8</key>
+		<dict>
+			<key>fileRef</key>
+			<string>753F92B7209958C7E403140C</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>E128380999AEBDD50DC753DB</key>
+		<dict>
+			<key>fileRef</key>
+			<string>8967BB0CC414B65CC0ACF0A3</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>E1980A947C8584A384A10EC3</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>AFSecurityPolicy.m</string>
+			<key>path</key>
+			<string>AFNetworking/AFSecurityPolicy.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>E2A0DF3D26E4061653656BF0</key>
+		<dict>
+			<key>fileRef</key>
+			<string>6B147F6F597FA5779A6A5B7B</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>E4329317410EBACF8EF522A9</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>name</key>
+			<string>AFNetworking.h</string>
+			<key>path</key>
+			<string>AFNetworking/AFNetworking.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>E51291C055BDD34807353CA7</key>
+		<dict>
+			<key>fileRef</key>
+			<string>D84360A51F9C076B59EB8576</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>E57C248683777E073C60AD6A</key>
+		<dict>
+			<key>fileRef</key>
+			<string>4AC5A293F59F2CAB158E6757</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>E5A0C6369E917827A057D39A</key>
+		<dict>
+			<key>buildConfigurationList</key>
+			<string>05416E8135FCF4320CDCB28A</string>
+			<key>buildPhases</key>
+			<array>
+				<string>5ADFC3ACE009BD19A35CEC69</string>
+				<string>F45E1F69CCE6FCA077B77FCB</string>
+				<string>7A87E7F82CDD351DE749AD35</string>
+			</array>
+			<key>buildRules</key>
+			<array/>
+			<key>dependencies</key>
+			<array/>
+			<key>isa</key>
+			<string>PBXNativeTarget</string>
+			<key>name</key>
+			<string>Pods-hpple</string>
+			<key>productName</key>
+			<string>Pods-hpple</string>
+			<key>productReference</key>
+			<string>ACC360DC91D91D8973461A32</string>
+			<key>productType</key>
+			<string>com.apple.product-type.library.static</string>
+		</dict>
+		<key>EA1670AFEC96115A6B3691AC</key>
+		<dict>
+			<key>fileRef</key>
+			<string>AE42885CE4222F46DA0D23BC</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>EB83FF8F912DCAC97D9B77AC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.script.sh</string>
+			<key>path</key>
+			<string>Pods-resources.sh</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>EBD3B501654D3F46E8B14F2B</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text</string>
+			<key>name</key>
+			<string>Podfile</string>
+			<key>path</key>
+			<string>../Podfile</string>
+			<key>sourceTree</key>
+			<string>SOURCE_ROOT</string>
+			<key>xcLanguageSpecificationIdentifier</key>
+			<string>xcode.lang.ruby</string>
+		</dict>
+		<key>EE47BD0F9704C21223D8B8A6</key>
+		<dict>
+			<key>fileRef</key>
+			<string>2E8EF59CC9196603C820DB1F</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+		</dict>
+		<key>F45E1F69CCE6FCA077B77FCB</key>
+		<dict>
+			<key>buildActionMask</key>
+			<string>2147483647</string>
+			<key>files</key>
+			<array>
+				<string>C41BF562ECB7E1BF12E62826</string>
+			</array>
+			<key>isa</key>
+			<string>PBXFrameworksBuildPhase</string>
+			<key>runOnlyForDeploymentPostprocessing</key>
+			<string>0</string>
+		</dict>
+		<key>F49BA14B4FC575F8AD8EAD6E</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>TFHppleElement.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>FA5F32B126514F19B7A61C54</key>
+		<dict>
+			<key>fileRef</key>
+			<string>5A46ACE2008B7E1F08F3AD9B</string>
+			<key>isa</key>
+			<string>PBXBuildFile</string>
+			<key>settings</key>
+			<dict>
+				<key>COMPILER_FLAGS</key>
+				<string>-fobjc-arc</string>
+			</dict>
+		</dict>
+		<key>FB5DB4FD1D76714D74ED8B90</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.objc</string>
+			<key>name</key>
+			<string>UIActivityIndicatorView+AFNetworking.m</string>
+			<key>path</key>
+			<string>UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking.m</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>FC98B6B3198F4F6A46322AEC</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>text.xcconfig</string>
+			<key>path</key>
+			<string>Pods.release.xcconfig</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>FD79AD516A32F136FD01980F</key>
+		<dict>
+			<key>includeInIndex</key>
+			<string>1</string>
+			<key>isa</key>
+			<string>PBXFileReference</string>
+			<key>lastKnownFileType</key>
+			<string>sourcecode.c.h</string>
+			<key>path</key>
+			<string>TFHpple.h</string>
+			<key>sourceTree</key>
+			<string>&lt;group&gt;</string>
+		</dict>
+		<key>FDC9A847FCE7AA138C7D5622</key>
+		<dict>
+			<key>buildConfigurationList</key>
+			<string>3B441D3EDA8CBB3502C3501B</string>
+			<key>buildPhases</key>
+			<array>
+				<string>5857AA4EB897A6416554A758</string>
+				<string>46AB559D04A734598CF66AE6</string>
+				<string>20EBAD26AED7D7CF8D3A0F25</string>
+			</array>
+			<key>buildRules</key>
+			<array/>
+			<key>dependencies</key>
+			<array/>
+			<key>isa</key>
+			<string>PBXNativeTarget</string>
+			<key>name</key>
+			<string>Pods-AFNetworking</string>
+			<key>productName</key>
+			<string>Pods-AFNetworking</string>
+			<key>productReference</key>
+			<string>1991ADD1F89A00A42B36F91A</string>
+			<key>productType</key>
+			<string>com.apple.product-type.library.static</string>
+		</dict>
+	</dict>
+	<key>rootObject</key>
+	<string>B7C18A245411F38B6A43F636</string>
+</dict>
+</plist>
diff --git a/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-Private.xcconfig b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-Private.xcconfig
new file mode 100644
index 00000000000..c9eb039c285
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-Private.xcconfig	
@@ -0,0 +1,5 @@
+#include "Pods-AFNetworking.xcconfig"
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Build" "${PODS_ROOT}/Headers/Build/AFNetworking" "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/AFNetworking" "${PODS_ROOT}/Headers/Public/hpple"
+OTHER_LDFLAGS = ${PODS_AFNETWORKING_OTHER_LDFLAGS} -ObjC
+PODS_ROOT = ${SRCROOT}
\ No newline at end of file
diff --git a/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-dummy.m b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-dummy.m
new file mode 100644
index 00000000000..c50a8c61689
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_Pods_AFNetworking : NSObject
+@end
+@implementation PodsDummy_Pods_AFNetworking
+@end
diff --git a/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix.pch b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix.pch
new file mode 100644
index 00000000000..95cf11d9fb0
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix.pch	
@@ -0,0 +1,5 @@
+#ifdef __OBJC__
+#import <UIKit/UIKit.h>
+#endif
+
+#import "Pods-environment.h"
diff --git a/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking.xcconfig b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking.xcconfig
new file mode 100644
index 00000000000..c2f387a4568
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking.xcconfig	
@@ -0,0 +1 @@
+PODS_AFNETWORKING_OTHER_LDFLAGS = -framework "CoreGraphics" -framework "MobileCoreServices" -framework "Security" -framework "SystemConfiguration"
\ No newline at end of file
diff --git a/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-Private.xcconfig b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-Private.xcconfig
new file mode 100644
index 00000000000..ef079fe055a
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-Private.xcconfig	
@@ -0,0 +1,5 @@
+#include "Pods-hpple.xcconfig"
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Build" "${PODS_ROOT}/Headers/Build/hpple" "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/AFNetworking" "${PODS_ROOT}/Headers/Public/hpple" ${PODS_HPPLE_HEADER_SEARCH_PATHS}
+OTHER_LDFLAGS = ${PODS_HPPLE_OTHER_LDFLAGS} -ObjC
+PODS_ROOT = ${SRCROOT}
\ No newline at end of file
diff --git a/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-dummy.m b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-dummy.m
new file mode 100644
index 00000000000..0993e9b05c2
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_Pods_hpple : NSObject
+@end
+@implementation PodsDummy_Pods_hpple
+@end
diff --git a/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-prefix.pch b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-prefix.pch
new file mode 100644
index 00000000000..95cf11d9fb0
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple-prefix.pch	
@@ -0,0 +1,5 @@
+#ifdef __OBJC__
+#import <UIKit/UIKit.h>
+#endif
+
+#import "Pods-environment.h"
diff --git a/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple.xcconfig b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple.xcconfig
new file mode 100644
index 00000000000..1a997d42e37
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods-hpple/Pods-hpple.xcconfig	
@@ -0,0 +1,2 @@
+PODS_HPPLE_HEADER_SEARCH_PATHS = $(SDKROOT)/usr/include/libxml2
+PODS_HPPLE_OTHER_LDFLAGS = -l"xml2"
\ No newline at end of file
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown b/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown
new file mode 100644
index 00000000000..f241921dd66
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown	
@@ -0,0 +1,52 @@
+# Acknowledgements
+This application makes use of the following third party libraries:
+
+## AFNetworking
+
+Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+## hpple
+
+Copyright (c) 2009 Topfunky Corporation, http://topfunky.com
+
+MIT LICENSE
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Generated by CocoaPods - http://cocoapods.org
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.plist b/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.plist
new file mode 100644
index 00000000000..282072b25bb
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods-acknowledgements.plist	
@@ -0,0 +1,86 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>PreferenceSpecifiers</key>
+	<array>
+		<dict>
+			<key>FooterText</key>
+			<string>This application makes use of the following third party libraries:</string>
+			<key>Title</key>
+			<string>Acknowledgements</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
+			<string>Copyright (c) 2013-2014 AFNetworking (http://afnetworking.com/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+</string>
+			<key>Title</key>
+			<string>AFNetworking</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
+			<string>Copyright (c) 2009 Topfunky Corporation, http://topfunky.com
+
+MIT LICENSE
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+</string>
+			<key>Title</key>
+			<string>hpple</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
+			<string>Generated by CocoaPods - http://cocoapods.org</string>
+			<key>Title</key>
+			<string></string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+	</array>
+	<key>StringsTable</key>
+	<string>Acknowledgements</string>
+	<key>Title</key>
+	<string>Acknowledgements</string>
+</dict>
+</plist>
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods-dummy.m b/cocoapods/Pods/Target Support Files/Pods/Pods-dummy.m
new file mode 100644
index 00000000000..ade64bd1a9b
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_Pods : NSObject
+@end
+@implementation PodsDummy_Pods
+@end
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods-environment.h b/cocoapods/Pods/Target Support Files/Pods/Pods-environment.h
new file mode 100644
index 00000000000..432df3a95bf
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods-environment.h	
@@ -0,0 +1,8 @@
+
+// To check if a library is compiled with CocoaPods you
+// can use the `COCOAPODS` macro definition which is
+// defined in the xcconfigs so it is available in
+// headers also when they are imported in the client
+// project.
+
+
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods-resources.sh b/cocoapods/Pods/Target Support Files/Pods/Pods-resources.sh
new file mode 100755
index 00000000000..216f0cf7082
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods-resources.sh	
@@ -0,0 +1,70 @@
+#!/bin/sh
+set -e
+
+mkdir -p "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
+
+RESOURCES_TO_COPY=${PODS_ROOT}/resources-to-copy-${TARGETNAME}.txt
+> "$RESOURCES_TO_COPY"
+
+install_resource()
+{
+  case $1 in
+    *.storyboard)
+      echo "ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile ${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .storyboard`.storyboardc ${PODS_ROOT}/$1 --sdk ${SDKROOT}"
+      ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .storyboard`.storyboardc" "${PODS_ROOT}/$1" --sdk "${SDKROOT}"
+      ;;
+    *.xib)
+        echo "ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile ${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .xib`.nib ${PODS_ROOT}/$1 --sdk ${SDKROOT}"
+      ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .xib`.nib" "${PODS_ROOT}/$1" --sdk "${SDKROOT}"
+      ;;
+    *.framework)
+      echo "mkdir -p ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
+      mkdir -p "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
+      echo "rsync -av ${PODS_ROOT}/$1 ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
+      rsync -av "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
+      ;;
+    *.xcdatamodel)
+      echo "xcrun momc \"${PODS_ROOT}/$1\" \"${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1"`.mom\""
+      xcrun momc "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodel`.mom"
+      ;;
+    *.xcdatamodeld)
+      echo "xcrun momc \"${PODS_ROOT}/$1\" \"${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodeld`.momd\""
+      xcrun momc "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodeld`.momd"
+      ;;
+    *.xcassets)
+      ;;
+    /*)
+      echo "$1"
+      echo "$1" >> "$RESOURCES_TO_COPY"
+      ;;
+    *)
+      echo "${PODS_ROOT}/$1"
+      echo "${PODS_ROOT}/$1" >> "$RESOURCES_TO_COPY"
+      ;;
+  esac
+}
+
+rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from="$RESOURCES_TO_COPY" / "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
+if [[ "${ACTION}" == "install" ]]; then
+  rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from="$RESOURCES_TO_COPY" / "${INSTALL_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
+fi
+rm -f "$RESOURCES_TO_COPY"
+
+if [[ -n "${WRAPPER_EXTENSION}" ]] && [ "`xcrun --find actool`" ] && [ `find . -name '*.xcassets' | wc -l` -ne 0 ]
+then
+  case "${TARGETED_DEVICE_FAMILY}" in
+    1,2)
+      TARGET_DEVICE_ARGS="--target-device ipad --target-device iphone"
+      ;;
+    1)
+      TARGET_DEVICE_ARGS="--target-device iphone"
+      ;;
+    2)
+      TARGET_DEVICE_ARGS="--target-device ipad"
+      ;;
+    *)
+      TARGET_DEVICE_ARGS="--target-device mac"
+      ;;
+  esac
+  find "${PWD}" -name "*.xcassets" -print0 | xargs -0 actool --output-format human-readable-text --notices --warnings --platform "${PLATFORM_NAME}" --minimum-deployment-target "${IPHONEOS_DEPLOYMENT_TARGET}" ${TARGET_DEVICE_ARGS} --compress-pngs --compile "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
+fi
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods.debug.xcconfig b/cocoapods/Pods/Target Support Files/Pods/Pods.debug.xcconfig
new file mode 100644
index 00000000000..608d9a185cf
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods.debug.xcconfig	
@@ -0,0 +1,6 @@
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/AFNetworking" "${PODS_ROOT}/Headers/Public/hpple" $(SDKROOT)/usr/include/libxml2
+OTHER_CFLAGS = $(inherited) -isystem "${PODS_ROOT}/Headers/Public" -isystem "${PODS_ROOT}/Headers/Public/AFNetworking" -isystem "${PODS_ROOT}/Headers/Public/hpple"
+OTHER_LDFLAGS = -ObjC -l"Pods-AFNetworking" -l"Pods-hpple" -l"xml2" -framework "CoreGraphics" -framework "MobileCoreServices" -framework "Security" -framework "SystemConfiguration"
+OTHER_LIBTOOLFLAGS = $(OTHER_LDFLAGS)
+PODS_ROOT = ${SRCROOT}/Pods
\ No newline at end of file
diff --git a/cocoapods/Pods/Target Support Files/Pods/Pods.release.xcconfig b/cocoapods/Pods/Target Support Files/Pods/Pods.release.xcconfig
new file mode 100644
index 00000000000..608d9a185cf
--- /dev/null
+++ b/cocoapods/Pods/Target Support Files/Pods/Pods.release.xcconfig	
@@ -0,0 +1,6 @@
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/AFNetworking" "${PODS_ROOT}/Headers/Public/hpple" $(SDKROOT)/usr/include/libxml2
+OTHER_CFLAGS = $(inherited) -isystem "${PODS_ROOT}/Headers/Public" -isystem "${PODS_ROOT}/Headers/Public/AFNetworking" -isystem "${PODS_ROOT}/Headers/Public/hpple"
+OTHER_LDFLAGS = -ObjC -l"Pods-AFNetworking" -l"Pods-hpple" -l"xml2" -framework "CoreGraphics" -framework "MobileCoreServices" -framework "Security" -framework "SystemConfiguration"
+OTHER_LIBTOOLFLAGS = $(OTHER_LDFLAGS)
+PODS_ROOT = ${SRCROOT}/Pods
\ No newline at end of file
diff --git a/cocoapods/Pods/hpple/LICENSE.txt b/cocoapods/Pods/hpple/LICENSE.txt
new file mode 100644
index 00000000000..8adbad209b5
--- /dev/null
+++ b/cocoapods/Pods/hpple/LICENSE.txt
@@ -0,0 +1,22 @@
+Copyright (c) 2009 Topfunky Corporation, http://topfunky.com
+
+MIT LICENSE
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/cocoapods/Pods/hpple/README.markdown b/cocoapods/Pods/hpple/README.markdown
new file mode 100644
index 00000000000..74312a3df39
--- /dev/null
+++ b/cocoapods/Pods/hpple/README.markdown
@@ -0,0 +1,51 @@
+# DESCRIPTION
+
+Hpple: A nice Objective-C wrapper on the XPathQuery library for parsing HTML.
+
+Inspired by why the lucky stiff's [Hpricot](http://github.com/why/hpricot/tree/master).
+
+# CREDITS
+
+Hpple was created by Geoffrey Grosenbach, [Topfunky Corporation](http://topfunky.com) and [PeepCode Screencasts](http://peepcode.com).
+
+[Contributors](https://github.com/topfunky/hpple/graphs/contributors)
+
+# FEATURES
+
+* Easy searching by XPath (CSS selectors are planned)
+* Parses HTML (XML coming soon)
+* Easy access to tag content, name, and attributes.
+
+# INSTALLATION
+
+* Open your XCode project and the Hpple project.
+* Drag the "Hpple" directory to your project.
+* Add the libxml2.2.dylib framework to your project and search paths as described at [Cocoa with Love](http://cocoawithlove.com/2008/10/using-libxml2-for-parsing-and-xpath.html)
+
+More documentation and short screencast coming soon...
+
+# USAGE
+
+See TFHppleHTMLTest.m in the Hpple project for samples.
+
+<pre>
+#import "TFHpple.h"
+
+NSData  * data      = [NSData dataWithContentsOfFile:@"index.html"];
+
+TFHpple * doc       = [[TFHpple alloc] initWithHTMLData:data];
+NSArray * elements  = [doc search:@"//a[@class='sponsor']"];
+
+TFHppleElement * element = [elements objectAtIndex:0];
+[e text];                       // The text inside the HTML element (the content of the first text node)
+[e tagName];                    // "a"
+[e attributes];                 // NSDictionary of href, class, id, etc.
+[e objectForKey:@"href"];       // Easy access to single attribute
+[e firstChildWithTagName:@"b"]; // The first "b" child node
+
+</pre>
+
+# TODO
+
+* Internal error catching and messages
+* CSS3 selectors in addition to XPath
diff --git a/wikipedia/HTML Parsing/hpple/TFHpple.h b/cocoapods/Pods/hpple/TFHpple.h
similarity index 73%
rename from wikipedia/HTML Parsing/hpple/TFHpple.h
rename to cocoapods/Pods/hpple/TFHpple.h
index 0cb8870d5df..906bf4df7a0 100644
--- a/wikipedia/HTML Parsing/hpple/TFHpple.h	
+++ b/cocoapods/Pods/hpple/TFHpple.h
@@ -32,26 +32,23 @@
 
 #import "TFHppleElement.h"
 
-@interface TFHpple : NSObject 
+@interface TFHpple : NSObject {
+@private
+  NSData * data;
+  BOOL isXML;
+}
 
-- (id) initWithData:(NSData *)theData encoding:(NSString *)encoding isXML:(BOOL)isDataXML;
 - (id) initWithData:(NSData *)theData isXML:(BOOL)isDataXML;
-- (id) initWithXMLData:(NSData *)theData encoding:(NSString *)encoding;
 - (id) initWithXMLData:(NSData *)theData;
-- (id) initWithHTMLData:(NSData *)theData encoding:(NSString *)encoding;
 - (id) initWithHTMLData:(NSData *)theData;
 
-+ (TFHpple *) hppleWithData:(NSData *)theData encoding:(NSString *)encoding isXML:(BOOL)isDataXML;
 + (TFHpple *) hppleWithData:(NSData *)theData isXML:(BOOL)isDataXML;
-+ (TFHpple *) hppleWithXMLData:(NSData *)theData encoding:(NSString *)encoding;
 + (TFHpple *) hppleWithXMLData:(NSData *)theData;
-+ (TFHpple *) hppleWithHTMLData:(NSData *)theData encoding:(NSString *)encoding;
 + (TFHpple *) hppleWithHTMLData:(NSData *)theData;
 
 - (NSArray *) searchWithXPathQuery:(NSString *)xPathOrCSS;
 - (TFHppleElement *) peekAtSearchWithXPathQuery:(NSString *)xPathOrCSS;
 
-@property (nonatomic, readonly) NSData * data;
-@property (nonatomic, readonly) NSString * encoding;
+@property (nonatomic, strong, readonly) NSData * data;
 
 @end
diff --git a/wikipedia/HTML Parsing/hpple/TFHpple.m b/cocoapods/Pods/hpple/TFHpple.m
similarity index 59%
rename from wikipedia/HTML Parsing/hpple/TFHpple.m
rename to cocoapods/Pods/hpple/TFHpple.m
index 690fc768cf4..601b48f6b31 100644
--- a/wikipedia/HTML Parsing/hpple/TFHpple.m	
+++ b/cocoapods/Pods/hpple/TFHpple.m
@@ -30,82 +30,43 @@
 #import "TFHpple.h"
 #import "XPathQuery.h"
 
-@interface TFHpple ()
-{
-    NSData * data;
-    NSString * encoding;
-    BOOL isXML;
-}
-
-@end
-
-
 @implementation TFHpple
 
 @synthesize data;
-@synthesize encoding;
 
 
-- (id) initWithData:(NSData *)theData encoding:(NSString *)theEncoding isXML:(BOOL)isDataXML
+- (id) initWithData:(NSData *)theData isXML:(BOOL)isDataXML
 {
   if (!(self = [super init])) {
     return nil;
   }
 
   data = theData;
-  encoding = theEncoding;
   isXML = isDataXML;
 
   return self;
 }
 
-- (id) initWithData:(NSData *)theData isXML:(BOOL)isDataXML
-{
-    return [self initWithData:theData encoding:nil isXML:isDataXML];
-}
-
-- (id) initWithXMLData:(NSData *)theData encoding:(NSString *)theEncoding
-{
-  return [self initWithData:theData encoding:theEncoding isXML:YES];
-}
-
 - (id) initWithXMLData:(NSData *)theData
 {
-  return [self initWithData:theData encoding:nil isXML:YES];
-}
-
-- (id) initWithHTMLData:(NSData *)theData encoding:(NSString *)theEncoding
-{
-    return [self initWithData:theData encoding:theEncoding isXML:NO];
+  return [self initWithData:theData isXML:YES];
 }
 
 - (id) initWithHTMLData:(NSData *)theData
 {
-  return [self initWithData:theData encoding:nil isXML:NO];
-}
-
-+ (TFHpple *) hppleWithData:(NSData *)theData encoding:(NSString *)theEncoding isXML:(BOOL)isDataXML {
-  return [[[self class] alloc] initWithData:theData encoding:theEncoding isXML:isDataXML];
+  return [self initWithData:theData isXML:NO];
 }
 
 + (TFHpple *) hppleWithData:(NSData *)theData isXML:(BOOL)isDataXML {
-  return [[self class] hppleWithData:theData encoding:nil isXML:isDataXML];
-}
-
-+ (TFHpple *) hppleWithHTMLData:(NSData *)theData encoding:(NSString *)theEncoding {
-  return [[self class] hppleWithData:theData encoding:theEncoding isXML:NO];
+  return [[[self class] alloc] initWithData:theData isXML:isDataXML];
 }
 
 + (TFHpple *) hppleWithHTMLData:(NSData *)theData {
-  return [[self class] hppleWithData:theData encoding:nil isXML:NO];
-}
-
-+ (TFHpple *) hppleWithXMLData:(NSData *)theData encoding:(NSString *)theEncoding {
-  return [[self class] hppleWithData:theData encoding:theEncoding isXML:YES];
+  return [[self class] hppleWithData:theData isXML:NO];
 }
 
 + (TFHpple *) hppleWithXMLData:(NSData *)theData {
-  return [[self class] hppleWithData:theData encoding:nil isXML:YES];
+  return [[self class] hppleWithData:theData isXML:YES];
 }
 
 #pragma mark -
@@ -115,14 +76,14 @@ - (NSArray *) searchWithXPathQuery:(NSString *)xPathOrCSS
 {
   NSArray * detailNodes = nil;
   if (isXML) {
-    detailNodes = PerformXMLXPathQueryWithEncoding(data, xPathOrCSS, encoding);
+    detailNodes = PerformXMLXPathQuery(data, xPathOrCSS);
   } else {
-    detailNodes = PerformHTMLXPathQueryWithEncoding(data, xPathOrCSS, encoding);
+    detailNodes = PerformHTMLXPathQuery(data, xPathOrCSS);
   }
 
   NSMutableArray * hppleElements = [NSMutableArray array];
   for (id node in detailNodes) {
-    [hppleElements addObject:[TFHppleElement hppleElementWithNode:node isXML:isXML withEncoding:encoding]];
+    [hppleElements addObject:[TFHppleElement hppleElementWithNode:node]];
   }
   return hppleElements;
 }
diff --git a/wikipedia/HTML Parsing/hpple/TFHppleElement.h b/cocoapods/Pods/hpple/TFHppleElement.h
similarity index 90%
rename from wikipedia/HTML Parsing/hpple/TFHppleElement.h
rename to cocoapods/Pods/hpple/TFHppleElement.h
index 5af1232bfc9..43e7f57ae3e 100644
--- a/wikipedia/HTML Parsing/hpple/TFHppleElement.h	
+++ b/cocoapods/Pods/hpple/TFHppleElement.h
@@ -30,11 +30,16 @@
 #import <Foundation/Foundation.h>
 
 
-@interface TFHppleElement : NSObject
+@interface TFHppleElement : NSObject {
+@private
+  
+  NSDictionary * node;
+  __unsafe_unretained TFHppleElement *parent;
+}
 
-- (id) initWithNode:(NSDictionary *) theNode isXML:(BOOL)isDataXML withEncoding:(NSString *)theEncoding;
+- (id) initWithNode:(NSDictionary *) theNode;
 
-+ (TFHppleElement *) hppleElementWithNode:(NSDictionary *) theNode isXML:(BOOL)isDataXML withEncoding:(NSString *)theEncoding;
++ (TFHppleElement *) hppleElementWithNode:(NSDictionary *) theNode;
 
 @property (nonatomic, copy, readonly) NSString *raw;
 // Returns this tag's innerHTML content.
@@ -96,11 +101,4 @@
 // Convenience method which can be used instead of firstTextChild.content
 - (NSString *) text;
 
-// Returns elements searched with xpath
-- (NSArray *) searchWithXPathQuery:(NSString *)xPathOrCSS;
-
-// Custom keyed subscripting
-- (id)objectForKeyedSubscript:(id)key;
-
-
 @end
diff --git a/wikipedia/HTML Parsing/hpple/TFHppleElement.m b/cocoapods/Pods/hpple/TFHppleElement.m
similarity index 79%
rename from wikipedia/HTML Parsing/hpple/TFHppleElement.m
rename to cocoapods/Pods/hpple/TFHppleElement.m
index c26274f3ee4..04447467132 100644
--- a/wikipedia/HTML Parsing/hpple/TFHppleElement.m	
+++ b/cocoapods/Pods/hpple/TFHppleElement.m
@@ -29,7 +29,6 @@
 
 
 #import "TFHppleElement.h"
-#import "XPathQuery.h"
 
 static NSString * const TFHppleNodeContentKey           = @"nodeContent";
 static NSString * const TFHppleNodeNameKey              = @"nodeName";
@@ -40,36 +39,25 @@
 static NSString * const TFHppleTextNodeName            = @"text";
 
 @interface TFHppleElement ()
-{    
-    NSDictionary * node;
-    BOOL isXML;
-    NSString *encoding;
-    __unsafe_unretained TFHppleElement *parent;
-}
-
 @property (nonatomic, unsafe_unretained, readwrite) TFHppleElement *parent;
-
 @end
 
 @implementation TFHppleElement
 @synthesize parent;
 
 
-- (id) initWithNode:(NSDictionary *) theNode isXML:(BOOL)isDataXML withEncoding:(NSString *)theEncoding
+- (id) initWithNode:(NSDictionary *) theNode
 {
   if (!(self = [super init]))
     return nil;
 
-    isXML = isDataXML;
-    node = theNode;
-    encoding = theEncoding;
+  node = theNode;
 
   return self;
 }
 
-+ (TFHppleElement *) hppleElementWithNode:(NSDictionary *) theNode isXML:(BOOL)isDataXML withEncoding:(NSString *)theEncoding
-{
-  return [[[self class] alloc] initWithNode:theNode isXML:isDataXML withEncoding:theEncoding];
++ (TFHppleElement *) hppleElementWithNode:(NSDictionary *) theNode {
+  return [[[self class] alloc] initWithNode:theNode];
 }
 
 #pragma mark -
@@ -94,7 +82,7 @@ - (NSArray *) children
 {
   NSMutableArray *children = [NSMutableArray array];
   for (NSDictionary *child in [node objectForKey:TFHppleNodeChildrenKey]) {
-      TFHppleElement *element = [TFHppleElement hppleElementWithNode:child isXML:isXML withEncoding:encoding];
+      TFHppleElement *element = [TFHppleElement hppleElementWithNode:child];
       element.parent = self;
       [children addObject:element];
   }
@@ -198,7 +186,7 @@ - (TFHppleElement *) firstChildWithClassName:(NSString*)className
     return nil;
 }
 
-- (TFHppleElement *) firstTextChild
+- (TFHppleElement *) firstTextChild;
 {
     for (TFHppleElement* child in self.children)
     {
@@ -214,30 +202,4 @@ - (NSString *) text
     return self.firstTextChild.content;
 }
 
-// Returns all elements at xPath.
-- (NSArray *) searchWithXPathQuery:(NSString *)xPathOrCSS
-{
-    
-    NSData *data = [self.raw dataUsingEncoding:NSUTF8StringEncoding];
-
-    NSArray * detailNodes = nil;
-    if (isXML) {
-        detailNodes = PerformXMLXPathQueryWithEncoding(data, xPathOrCSS, encoding);
-    } else {
-        detailNodes = PerformHTMLXPathQueryWithEncoding(data, xPathOrCSS, encoding);
-    }
-    
-    NSMutableArray * hppleElements = [NSMutableArray array];
-    for (id newNode in detailNodes) {
-        [hppleElements addObject:[TFHppleElement hppleElementWithNode:newNode isXML:isXML withEncoding:encoding]];
-    }
-    return hppleElements;
-}
-
-// Custom keyed subscripting
-- (id)objectForKeyedSubscript:(id)key
-{
-    return [self objectForKey:key];
-}
-
 @end
diff --git a/wikipedia/HTML Parsing/hpple/XPathQuery.h b/cocoapods/Pods/hpple/XPathQuery.h
similarity index 58%
rename from wikipedia/HTML Parsing/hpple/XPathQuery.h
rename to cocoapods/Pods/hpple/XPathQuery.h
index 6996a5804ea..54493ce4448 100644
--- a/wikipedia/HTML Parsing/hpple/XPathQuery.h	
+++ b/cocoapods/Pods/hpple/XPathQuery.h
@@ -7,6 +7,4 @@
 //
 
 NSArray *PerformHTMLXPathQuery(NSData *document, NSString *query);
-NSArray *PerformHTMLXPathQueryWithEncoding(NSData *document, NSString *query,NSString *encoding);
 NSArray *PerformXMLXPathQuery(NSData *document, NSString *query);
-NSArray *PerformXMLXPathQueryWithEncoding(NSData *document, NSString *query,NSString *encoding);
diff --git a/wikipedia/HTML Parsing/hpple/XPathQuery.m b/cocoapods/Pods/hpple/XPathQuery.m
similarity index 81%
rename from wikipedia/HTML Parsing/hpple/XPathQuery.m
rename to cocoapods/Pods/hpple/XPathQuery.m
index 717a180a68f..4cbb22c30b8 100644
--- a/wikipedia/HTML Parsing/hpple/XPathQuery.m	
+++ b/cocoapods/Pods/hpple/XPathQuery.m
@@ -168,52 +168,38 @@
 
 NSArray *PerformHTMLXPathQuery(NSData *document, NSString *query)
 {
-    return PerformHTMLXPathQueryWithEncoding(document, query, nil);
-}
-
-NSArray *PerformHTMLXPathQueryWithEncoding(NSData *document, NSString *query,NSString *encoding)
-{
-    xmlDocPtr doc;
+  xmlDocPtr doc;
 
-    /* Load XML document */
-    const char *encoded = encoding ? [encoding cStringUsingEncoding:NSUTF8StringEncoding] : NULL;
+  /* Load XML document */
+  doc = htmlReadMemory([document bytes], (int)[document length], "", NULL, HTML_PARSE_NOWARNING | HTML_PARSE_NOERROR);
 
-    doc = htmlReadMemory([document bytes], (int)[document length], "", encoded, HTML_PARSE_NOWARNING | HTML_PARSE_NOERROR);
-    
-    if (doc == NULL)
+  if (doc == NULL)
     {
-        NSLog(@"Unable to parse.");
-        return nil;
+      NSLog(@"Unable to parse.");
+      return nil;
     }
-    
-    NSArray *result = PerformXPathQuery(doc, query);
-    xmlFreeDoc(doc);
-    
-    return result;
+
+  NSArray *result = PerformXPathQuery(doc, query);
+  xmlFreeDoc(doc);
+
+  return result;
 }
 
 NSArray *PerformXMLXPathQuery(NSData *document, NSString *query)
 {
-    return PerformXMLXPathQueryWithEncoding(document, query, nil);
-}
+  xmlDocPtr doc;
 
-NSArray *PerformXMLXPathQueryWithEncoding(NSData *document, NSString *query,NSString *encoding)
-{
-    xmlDocPtr doc;
-    
-    /* Load XML document */
-    const char *encoded = encoding ? [encoding cStringUsingEncoding:NSUTF8StringEncoding] : NULL;
+  /* Load XML document */
+  doc = xmlReadMemory([document bytes], (int)[document length], "", NULL, XML_PARSE_RECOVER);
 
-    doc = xmlReadMemory([document bytes], (int)[document length], "", encoded, XML_PARSE_RECOVER);
-    
-    if (doc == NULL)
+  if (doc == NULL)
     {
-        NSLog(@"Unable to parse.");
-        return nil;
+      NSLog(@"Unable to parse.");
+      return nil;
     }
-    
-    NSArray *result = PerformXPathQuery(doc, query);
-    xmlFreeDoc(doc);
-    
-    return result;
+
+  NSArray *result = PerformXPathQuery(doc, query);
+  xmlFreeDoc(doc);
+
+  return result;
 }
diff --git a/scripts/run-cocoapods.sh b/scripts/run-cocoapods.sh
new file mode 100755
index 00000000000..0bf12bfe3e0
--- /dev/null
+++ b/scripts/run-cocoapods.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+rm -rf "Cocoapods/Pods"
+cd "Cocoapods"
+pod install --no-integrate
diff --git a/wikipedia-tests/ArticleDataModel.m b/wikipedia-tests/ArticleDataModel.m
deleted file mode 100644
index 0c876391e4a..00000000000
--- a/wikipedia-tests/ArticleDataModel.m
+++ /dev/null
@@ -1,208 +0,0 @@
-//  Created by Monte Hurd on 11/26/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-#import <UIKit/UIKit.h>
-#import <CoreData/CoreData.h>
-#import "ArticleDataContextSingleton.h"
-#import "ArticleCoreDataObjects.h"
-#import "NSManagedObjectContext+SimpleFetch.h"
-
-@interface TestArticleDataModel : XCTestCase{
-
-}
-
-@property (strong, nonatomic) NSManagedObjectContext *dataContext;
-
-@end
-
-@implementation TestArticleDataModel
-
-- (void)setUp
-{
-    [super setUp];
-    // Put setup code here. This method is called before the invocation of each test method in the class.
-}
-
-- (void)tearDown
-{
-    // Put teardown code here. This method is called after the invocation of each test method in the class.
-    [super tearDown];
-}
-
-
-// Named with %% to ensure order of execution
-
-- (void)test_01_CreateArticle
-{
-    NSError *error = nil;
-
-    ArticleDataContextSingleton *dataContext = [ArticleDataContextSingleton sharedInstance];
-    Article *article = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:dataContext.mainContext];
-
-    article.dateCreated = [NSDate date];
-    article.lastScrollY = @123.0f;
-    article.title = @"This is a sample title.";
-
-    // Add history for article
-    History *history0 = [NSEntityDescription insertNewObjectForEntityForName:@"History" inManagedObjectContext:dataContext.mainContext];
-    history0.dateVisited = [NSDate date];
-    [article addHistoryObject:history0];
-
-    History *history1 = [NSEntityDescription insertNewObjectForEntityForName:@"History" inManagedObjectContext:dataContext.mainContext];
-    history1.dateVisited = [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24];
-    [article addHistoryObject:history1];
-
-    // Add prefix context for article
-    DiscoveryContext *preContext = [NSEntityDescription insertNewObjectForEntityForName:@"DiscoveryContext" inManagedObjectContext:dataContext.mainContext];
-    preContext.isPrefix = @YES;
-    preContext.text = @"Some potato chip pre-context.";
-
-    // Add postfix context for article
-    DiscoveryContext *postContext = [NSEntityDescription insertNewObjectForEntityForName:@"DiscoveryContext" inManagedObjectContext:dataContext.mainContext];
-    postContext.isPrefix = @YES;
-    postContext.text = @"Some potato chip post-context.";
-
-    preContext.history = history0;
-    postContext.history = history0;
-
-    // Add sections for article
-    Section *section0 = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:dataContext.mainContext];
-    section0.index = @0;
-    section0.title = @"Potato chip section 0 title";
-    section0.html = @"<b>Potato Chips section 0 html!</b>";
-    section0.tocLevel = @1;
-    section0.dateRetrieved = [NSDate date];
-    section0.anchor = @"potato_anchor_0";
-
-    Section *section1 = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:dataContext.mainContext];
-    section1.index = @1;
-    section1.title = @"Potato chip section 1 title";
-    section1.html = @"<b>Potato Chips section 1 html!</b>";
-    section1.tocLevel = @1;
-    section1.dateRetrieved = [NSDate date];
-    section1.anchor = @"potato_anchor_1";
-
-    article.section = [NSSet setWithObjects:section0, section1, nil];
-
-    // Add saved for article
-    Saved *saved0 = [NSEntityDescription insertNewObjectForEntityForName:@"Saved" inManagedObjectContext:dataContext.mainContext];
-    saved0.dateSaved = [NSDate date];
-    [article addSavedObject:saved0];
-    
-    Saved *saved1 = [NSEntityDescription insertNewObjectForEntityForName:@"Saved" inManagedObjectContext:dataContext.mainContext];
-    saved1.dateSaved = [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24];
-    [article addSavedObject:saved1];
-    
-    history0.discoveryMethod = @"random";
-    history1.discoveryMethod = @"random";
-
-    // Create test image
-    CGRect rect = CGRectMake(0, 0, 10, 10);
-    UIGraphicsBeginImageContextWithOptions(rect.size, NO, 0);
-    [[UIColor redColor] setFill];
-    UIRectFill(rect);
-    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
-    UIGraphicsEndImageContext();
-
-    // Get image data
-    CGDataProviderRef provider = CGImageGetDataProvider(image.CGImage);
-    NSData *imageData = (id)CFBridgingRelease(CGDataProviderCopyData(provider));
-
-    Image *thumb = [NSEntityDescription insertNewObjectForEntityForName:@"Image" inManagedObjectContext:dataContext.mainContext];
-
-    thumb.imageData = [NSEntityDescription insertNewObjectForEntityForName:@"ImageData" inManagedObjectContext:dataContext.mainContext];
-    thumb.imageData.data = imageData;
-    thumb.dataSize = @(imageData.length);
-    thumb.fileName = @"123px-thisThumb.jpg";
-    thumb.fileNameNoSizePrefix = @"thisThumb.jpg";
-    thumb.extension = @"jpg";
-    thumb.mimeType = @"image/jpeg";
-    thumb.imageDescription = @"Sample thumb description";
-    thumb.dateRetrieved = [NSDate date];
-    thumb.dateLastAccessed = [NSDate date];
-    thumb.width = @100.0f;
-    thumb.height = @200.0f;
-    thumb.sourceUrl = @"http://www.this_is_a_placeholder.org/image.jpg";
-    article.thumbnailImage = thumb;
-
-    article.site = @"wikipedia.org";
-    article.domain = @"en";
-    article.domainName = @"English";
-
-    // Save the article!
-    error = nil;
-    [dataContext.mainContext save:&error];
-    XCTAssert(error == nil, @"Could not save article.");
-}
-
-//TODO: Add tests here to confirm tables other than "Article" contain data...
-
-- (void)test_02_DeleteArticles
-{
-    NSError *error = nil;
-    ArticleDataContextSingleton *dataContext = [ArticleDataContextSingleton sharedInstance];
-
-    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
-    NSEntityDescription *entity = [NSEntityDescription entityForName: @"Article"
-                                              inManagedObjectContext: dataContext.mainContext];
-    [fetchRequest setEntity:entity];
-    
-    //NSPredicate *pred = [NSPredicate predicateWithFormat:@"name == %@", @"random"];
-    //[fetchRequest setPredicate:pred];
-
-    error = nil;
-    NSArray *articles = [dataContext.mainContext executeFetchRequest:fetchRequest error:&error];
-    XCTAssert(error == nil, @"Could not retrieve articles to be deleted.");
-    for (Article *article in articles) {
-        [dataContext.mainContext deleteObject:article];
-    }
-    
-    error = nil;
-    [dataContext.mainContext save:&error];
-    XCTAssert(error == nil, @"Could not delete articles.");
-}
-
-- (void)test_03_ConfirmAllArticleDataWasDeleted
-{
-    NSError *error = nil;
-    ArticleDataContextSingleton *dataContext = [ArticleDataContextSingleton sharedInstance];
-
-    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
-    NSEntityDescription *entity = [NSEntityDescription entityForName: @"Article"
-                                              inManagedObjectContext: dataContext.mainContext];
-    [fetchRequest setEntity:entity];
-    
-    //NSPredicate *pred = [NSPredicate predicateWithFormat:@"name == %@", @"random"];
-    //[fetchRequest setPredicate:pred];
-    
-    error = nil;
-    NSArray *articles = [dataContext.mainContext executeFetchRequest:fetchRequest error:&error];
-    XCTAssert(error == nil, @"Could determine how many articles remain.");
-    XCTAssert(articles.count == 0, @"Articles still exist but should not.");
-}
-
-- (void)test_04_ConfirmAllImageDataWasDeleted
-{
-    NSError *error = nil;
-    ArticleDataContextSingleton *dataContext = [ArticleDataContextSingleton sharedInstance];
-
-    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
-    NSEntityDescription *entity = [NSEntityDescription entityForName: @"Image"
-                                              inManagedObjectContext: dataContext.mainContext];
-    [fetchRequest setEntity:entity];
-    
-    //NSPredicate *pred = [NSPredicate predicateWithFormat:@"name == %@", @"random"];
-    //[fetchRequest setPredicate:pred];
-    
-    error = nil;
-    NSArray *images = [dataContext.mainContext executeFetchRequest:fetchRequest error:&error];
-    XCTAssert(error == nil, @"Could determine how many images remain.");
-    
-    // Note: this Assert will probably fail. Left in place as a reminder to implement some way to limit
-    // number of images! Maybe when app starts remove all images older than a certain date, or remove
-    // any in excess of a size threshold?
-    XCTAssert(images.count == 0, @"Images still exist but should not.");
-}
-
-@end
diff --git a/wikipedia-tests/CommunicationBridgeTests.m b/wikipedia-tests/CommunicationBridgeTests.m
deleted file mode 100644
index 8c64bc1c82e..00000000000
--- a/wikipedia-tests/CommunicationBridgeTests.m
+++ /dev/null
@@ -1,127 +0,0 @@
-//  Created by Brion on 11/4/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-#import "CommunicationBridge.h"
-#import "NSRunLoop+TimeOutAndFlag.h"
-
-@interface CommunicationBridgeTests : XCTestCase
-
-@end
-
-@implementation CommunicationBridgeTests {
-    UIWindow *window;
-    UIWebView *webView;
-    CommunicationBridge *bridge;
-}
-
-- (void)setUp
-{
-    [super setUp];
-
-    window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
-    window.screen = [UIScreen mainScreen];
-    webView = [[UIWebView alloc] initWithFrame:window.frame];
-    [window addSubview:webView];
-    [window makeKeyAndVisible]; // ???
-    bridge = [[CommunicationBridge alloc] initWithWebView:webView];
-}
-
-- (void)tearDown
-{
-    [window resignKeyWindow];
-    window = nil;
-    [super tearDown];
-}
-
-- (void)testCreated
-{
-    XCTAssertNotNil(bridge);
-}
-
-- (void)testAddListener
-{
-    JSListener listener = [^(NSString *messageType, NSDictionary *payload) {
-        // whee!
-    } copy];
-    [bridge addListener:@"DOMLoaded" withBlock:listener];
-    NSArray *listeners = [bridge listenersForMessageType:@"DOMLoaded"];
-    XCTAssertNotNil(listeners);
-    XCTAssert(listeners.count > 0);
-    // note: can't check for the actual object as it gets automatically copied due to ARC oddities
-}
-
-- (void)testFireEvent
-{
-    __block NSString *foundMessageType = @"<failed to fire>";
-    __block NSDictionary *foundPayload;
-    JSListener listener = [^(NSString *messageType, NSDictionary *payload) {
-        foundMessageType = messageType;
-        foundPayload = payload;
-    } copy];
-    [bridge addListener:@"TestEvent" withBlock:listener];
-    [bridge fireEvent:@"TestEvent" withPayload:@{}];
-    XCTAssertEqualObjects(foundMessageType, @"TestEvent");
-    XCTAssertNotNil(foundPayload);
-}
-
-- (void)testIsBridgeURL
-{
-    XCTAssertFalse([bridge isBridgeURL:[NSURL URLWithString:@"http://en.wikipedia.org/wiki/Foo"]]);
-    XCTAssertTrue([bridge isBridgeURL:[NSURL URLWithString:@"x-wikipedia-bridge:%7B%7D"]]);
-}
-
-- (void)testExtractBridgePayload
-{
-    NSDictionary *payload = [bridge extractBridgePayload:[NSURL URLWithString:@"x-wikipedia-bridge:%7B%7D"]];
-    XCTAssertNotNil(payload);
-
-    payload = [bridge extractBridgePayload:[NSURL URLWithString:@"x-wikipedia-bridge:%7B%22key%22%3A%22value%22%7D"]];
-    XCTAssertNotNil(payload);
-    XCTAssertEqualObjects(payload[@"key"], @"value");
-}
-
-- (void)testDOMLoaded
-{
-    __block NSString *foundMessageType = @"<failed to fire>";
-    __block BOOL found = NO;
-    
-    XCTAssertFalse(bridge.isDOMReady);
-
-    NSLog(@"QQQ WAITING");
-    [bridge addListener:@"DOMLoaded" withBlock:^(NSString *messageType, NSDictionary *payload) {
-        NSLog(@"QQQ HEY");
-        foundMessageType = messageType;
-        found = YES;
-    }];
-    [[NSRunLoop mainRunLoop] runUntilTimeout:5 orFinishedFlag:&found];
-    NSLog(@"QQQ DONE WAITING");
-
-    XCTAssertEqualObjects(foundMessageType, @"DOMLoaded");
-    XCTAssertTrue(bridge.isDOMReady);
-}
-
-- (void)testStringify
-{
-    XCTAssertEqualObjects(@"\"simple\"", [bridge stringify:@"simple"]);
-    XCTAssertEqualObjects(@"{}", [bridge stringify:@{}]);
-}
-
-- (void)testPingback
-{
-    __block NSString *foundMessageType = @"<failed to fire>";
-    __block BOOL found = NO;
-    
-    NSLog(@"QQQ WAITING");
-    [bridge addListener:@"pong" withBlock:^(NSString *messageType, NSDictionary *payload) {
-        NSLog(@"QQQ HEY");
-        foundMessageType = messageType;
-        found = YES;
-    }];
-    [bridge sendMessage:@"ping" withPayload:@{}];
-    [[NSRunLoop mainRunLoop] runUntilTimeout:5 orFinishedFlag:&found];
-    NSLog(@"QQQ DONE WAITING");
-    
-    XCTAssertEqualObjects(foundMessageType, @"pong");
-}
-@end
diff --git a/wikipedia-tests/NetworkOpCrumbyTests.m b/wikipedia-tests/NetworkOpCrumbyTests.m
deleted file mode 100644
index ea06b9f9bcd..00000000000
--- a/wikipedia-tests/NetworkOpCrumbyTests.m
+++ /dev/null
@@ -1,274 +0,0 @@
-//  Created by Monte Hurd on 11/13/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-#import "NSURLRequest+DictionaryRequest.h"
-#import "MWCrumbyTest.h"
-#import "MWNetworkOp.h"
-#import "NSRunLoop+TimeOutAndFlag.h"
-
-#pragma mark - Defines
-
-#define TEST_ACCOUNT_USERNAME @"montehurd"
-#define TEST_ACCOUNT_PASSWORD @""
-#define TEST_URL @"https://commons.wikimedia.org/w/api.php" //@"https://test.wikipedia.org/w/api.php"
-#define TEST_MAX_DURATION 8.0
-
-@interface NetworkOpCrumbyTests : XCTestCase {
-    NSString *userName_;
-    NSString *userPassword_;
-    __strong MWCrumbyTest *goodPasswordTest;
-    __strong MWCrumbyTest *badPasswordTest;
-}
-
-@end
-
-@implementation NetworkOpCrumbyTests
-
-#pragma mark - setUp and tearDown
-
-- (void)setUp
-{
-    userName_ = TEST_ACCOUNT_USERNAME;
-    userPassword_ = TEST_ACCOUNT_PASSWORD;
-
-    [super setUp];
-    // Put setup code here; it will be run once, before the first test case.
-}
-
-- (void)tearDown
-{
-    // Put teardown code here; it will be run once, after the last test case.
-    [super tearDown];
-}
-
-/*
-#pragma mark - KVO
-
-- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
-{
-    MWCrumbyTest *test = (MWCrumbyTest *)object;
-    
-    NSString *statusDescription = [NSString stringWithFormat:
-                                   @"%@\nTrailhead: %@ | Expected trail: %@ | Trail hiked so far: %@ | Test status: %@",
-                                   test.description,
-                                   NSStringFromSelector(test.kickoffSelector),
-                                   test.expectedTrail,
-                                   (test.trailSoFar.length == 0) ? @"*" : test.trailSoFar,
-                                   [test displayNameForStatus:test.status]
-                                   ];
-    
-    NSLog(@"\n\nTEST STATUS CHANGED, TEST = %@\n\n", statusDescription);
-}
-*/
-
-#pragma mark - Test validation
-
--(void)validateTest:(MWCrumbyTest *)test
-{
-    NSLog(@"\
-    \n\nMWCrumbyTest: [%p] \'%@\'\
-    \n\tFinal State: %@\
-    \n\tFinal Trail: %@\
-    \n\tExpected Trail: %@\
-    ",
-        test,
-        test.description,
-        [test displayNameForStatus:test.status],
-        test.trailSoFar,
-        test.expectedTrail
-    );
-    XCTAssertEqual(test.status, CRUMBY_STATUS_ARRIVED_SAFELY, @"MWCrumbyTest failure: Unexpected Final State.");
-}
-
-#pragma mark - Tests
-
-- (void)testTokenLoginAndFileNameCheckWithGoodPassword
-{
-return;
-    // Note: If enough failed attempts happen, the api appears to sometimes respond with "WrongPass" if correct password is
-    // provided soon after too many failed attempts.
-
-    // Only run this test if a password has been supplied
-    if (userPassword_ == nil) return;
-    if (userPassword_.length == 0) return;
-
-    goodPasswordTest = [[MWCrumbyTest alloc] initWithTrailhead : @selector(test_token_login_namecheck:)
-                                                  target : self
-                                           trailExpected : @"ABCDEFggg"
-                                             description : @"Test token, login and namecheck with good password"
-                  ];
-    //[test addObserver:self forKeyPath:@"status" options:NSKeyValueObservingOptionNew context:nil];
-
-    [goodPasswordTest hike];
-    
-    // Schedule a results check so XCTAssert's can verify and report back.
-    // Needs to be scheduled before runUntilTimeout:orFinishedFlag: is called!
-    [self performSelector:@selector(validateTest:) withObject:goodPasswordTest afterDelay:TEST_MAX_DURATION];
-
-    // Give the async test just a bit more time than maxTestDuration to finish
-    // Don't move this into the "setUp" method! Needs to happen after "hike" is called!
-    __block BOOL asyncTestDone = NO;
-    [[NSRunLoop mainRunLoop] runUntilTimeout:TEST_MAX_DURATION + 0.1 orFinishedFlag:&asyncTestDone];
-}
-
-- (void)testTokenLoginAndFileNameCheckWithBadPassword
-{
-return;
-    // Force a bad password.
-    userPassword_ = @"asdfasdf";
-
-    badPasswordTest = [[MWCrumbyTest alloc] initWithTrailhead : @selector(test_token_login_namecheck:)
-                                                  target : self
-                                           trailExpected : @"ABCDggg"
-                                             description : @"Test token, login and namecheck with bad password"
-                  ];
-    //[test addObserver:self forKeyPath:@"status" options:NSKeyValueObservingOptionNew context:nil];
-
-    [badPasswordTest hike];
-    
-    // Schedule a results check so XCTAssert's can verify and report back.
-    // Needs to be scheduled before runUntilTimeout:orFinishedFlag: is called!
-    [self performSelector:@selector(validateTest:) withObject:badPasswordTest afterDelay:TEST_MAX_DURATION];
-
-    // Give the async test just a bit more time than maxTestDuration to finish
-    // Don't move this into the "setUp" method! Needs to happen after "hike" is called!
-    __block BOOL asyncTestDone = NO;
-    [[NSRunLoop mainRunLoop] runUntilTimeout:TEST_MAX_DURATION + 0.1 orFinishedFlag:&asyncTestDone];
-}
-
-#pragma mark - Test forests
-
--(void)test_token_login_namecheck:(MWCrumbyTest *)test
-{
-return;
-    // Logout op ------
-    MWNetworkOp *logoutOp = [[MWNetworkOp alloc] init];
-    //__weak MWNetworkOp *weakLogoutOp = logoutOp;
-
-    logoutOp.request = [NSURLRequest postRequestWithURL:[NSURL URLWithString:TEST_URL]
-                                             parameters:@{
-                                                          @"action": @"logout",
-                                                          @"format": @"json"
-                                                          }
-                        ];
-    
-    logoutOp.aboutToStart = ^(){
-        
-    };
-    logoutOp.completionBlock = ^{
-        
-    };
-    logoutOp.aboutToDealloc = ^{
-        
-    };
-    // --------
-
-    // Get token op ------
-    MWNetworkOp *getTokenOp = [[MWNetworkOp alloc] init];
-    //__weak MWNetworkOp *weakGetTokenOp = getTokenOp;
-
-    [test dropCrumb:@"A"];
-    
-    [getTokenOp addDependency:logoutOp];
-    getTokenOp.request = [NSURLRequest postRequestWithURL:[NSURL URLWithString:TEST_URL]
-                                               parameters:@{
-                                                            @"action": @"login",
-                                                            @"lgname": userName_,
-                                                            @"format": @"json"
-                                                            }
-                          ];
-
-    getTokenOp.completionBlock = ^{
-        [test dropCrumb:@"B"];
-    };
-    
-    getTokenOp.aboutToDealloc = ^{
-        [test dropCrumb:@"g"];
-    };
-    // --------
-
-    // Login op ------
-    MWNetworkOp *loginOpWithToken = [[MWNetworkOp alloc] init];
-    __weak MWNetworkOp *weakLoginOpWithToken = loginOpWithToken;
-
-    [loginOpWithToken addDependency:getTokenOp];
-    
-    loginOpWithToken.aboutToStart = ^(){
-        
-        [test dropCrumb:@"C"];
-        NSDictionary *json = getTokenOp.jsonRetrieved;
-        NSString *token = json[@"login"][@"token"];
-        NSLog(@"\n\n\nTOKEN RETRIEVED: %@\n\n\n", token);
-        if(!token){
-            [weakLoginOpWithToken cancel];
-        }else{
-            weakLoginOpWithToken.request = [NSURLRequest postRequestWithURL:[NSURL URLWithString:TEST_URL]
-                                                                 parameters:@{
-                                                                              @"action": @"login",
-                                                                              @"lgname": userName_,
-                                                                              @"lgpassword": userPassword_,
-                                                                              @"format": @"json",
-                                                                              @"lgtoken": token
-                                                                              }];
-        }
-    };
-
-    loginOpWithToken.completionBlock = ^{
-        [test dropCrumb:@"D"];
-        NSString *result = weakLoginOpWithToken.jsonRetrieved[@"login"][@"result"];
-        NSLog(@"Login results = %@", weakLoginOpWithToken.jsonRetrieved);
-        if (![result isEqualToString:@"Success"]){
-            // Set error so child ops don't even start!
-            weakLoginOpWithToken.error = [NSError errorWithDomain:@"Login" code:001 userInfo:nil];
-        }
-    };
-    
-    loginOpWithToken.aboutToDealloc = ^{
-        [test dropCrumb:@"g"];
-    };
-    // --------
-
-    // Name check op ------
-    MWNetworkOp *nameCheckOp = [[MWNetworkOp alloc] init];
-    __weak MWNetworkOp *weakNameCheckOp = nameCheckOp;
-
-    [nameCheckOp addDependency:loginOpWithToken];
-
-    nameCheckOp.aboutToStart = ^(){
-        [test dropCrumb:@"E"];
-            weakNameCheckOp.request = [NSURLRequest getRequestWithURL:[NSURL URLWithString:TEST_URL]
-                                                           parameters:@{
-                                                                        @"action": @"query",
-                                                                        @"prop": @"imageinfo",
-                                                                        @"format": @"json",
-                                                                        @"titles": @"File:Asfafasdfas87876.jpg",
-                                                                        }
-                                       ];
-    };
-    
-    nameCheckOp.completionBlock = ^(){
-        [test dropCrumb:@"F"];
-        if (!weakNameCheckOp.error) {
-            NSError *error = nil;
-            NSDictionary *result = [NSJSONSerialization JSONObjectWithData:weakNameCheckOp.dataRetrieved options:0 error:&error];
-            NSLog(@"Name check results = %@", result);
-        }
-    };
-    
-    nameCheckOp.aboutToDealloc = ^{
-        [test dropCrumb:@"g"];
-    };
-    // --------
-
-    // Queue! --------
-    NSOperationQueue *opQueue = [[NSOperationQueue alloc] init];
-
-    [opQueue addOperation:logoutOp];
-    [opQueue addOperation:getTokenOp];
-    [opQueue addOperation:loginOpWithToken];
-    [opQueue addOperation:nameCheckOp];
-    // --------
-}
-
-@end
diff --git a/wikipedia-tests/NetworkOpTests.m b/wikipedia-tests/NetworkOpTests.m
deleted file mode 100644
index 137686e1ffa..00000000000
--- a/wikipedia-tests/NetworkOpTests.m
+++ /dev/null
@@ -1,177 +0,0 @@
-//  Created by Monte Hurd on 10/30/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-// Note: these tests aren't very atomic. Probably refactor when better async unit testing
-// support comes to XCode.
-
-#import <XCTest/XCTest.h>
-#import "MWNetworkOp.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "NSRunLoop+TimeOutAndFlag.h"
-
-@interface NetworkOpTests : XCTestCase
-{
-    NSString *url_;
-
-    // Reminder: do not move NSOperationQueue or asyncTestDone flag here.
-    // These need to be per-test!
-}
-
-@end
-
-@implementation NetworkOpTests
-
-- (void)setUp
-{
-    [super setUp];
-    // Put setup code here. This method is called before the invocation of each test method in the class.
-
-    //url_ = @"https://commons.wikimedia.org/w/api.php";
-    url_ = @"https://test.wikipedia.org/w/api.php";
-}
-
-- (void)tearDown
-{
-    // Put teardown code here. This method is called after the invocation of each test method in the class.
-    [super tearDown];
-    // Add some vertical space between each test's terminal output.
-    NSLog(@"\n\n\n\n\n\n\n\n");
-}
-
-- (void)testTokenRetrievalOp
-{
-    // Simple op configured to request a token.
-    NSLog(@"%@", NSStringFromSelector(_cmd));
-
-    NSOperationQueue *q = [[NSOperationQueue alloc] init];
-    __block BOOL asyncTestDone = NO;
-
-    // To login a token is first retrieved.
-    MWNetworkOp *op = [[MWNetworkOp alloc] init];
-    op.request = [NSURLRequest postRequestWithURL: [NSURL URLWithString:url_]
-                                       parameters: @{
-                                                     @"action": @"login",
-                                                     @"lgname": @"MHurd (WMF)",
-                                                     @"format": @"json"
-                                                     }
-                  ];
-
-    __weak MWNetworkOp *weakOp = op;
-
-    op.completionBlock = ^(){
-        XCTAssertNil(weakOp.error);
-        NSDictionary *result = [NSJSONSerialization JSONObjectWithData:weakOp.dataRetrieved options:0 error:nil];
-        NSLog(@"\n%s data retrieved = %@", __PRETTY_FUNCTION__, result);
-        XCTAssertNotNil(result[@"login"]);
-        XCTAssertNotNil(result[@"login"][@"token"]);
-        asyncTestDone = YES;
-    };
-
-    [q addOperation:op];
-
-    // Give the async test a bit of time to finish.
-    [[NSRunLoop mainRunLoop] runUntilTimeout:10.0 orFinishedFlag:&asyncTestDone];
-}
-
-- (void)testLoginWithTokenOp
-{
-    // Op configured to request a token, then token used with second op to attempt login. Only
-    // asserts that a result was retrieved from the login attempt - that way no actual account
-    // credentials are recorded in the code here.
-    NSLog(@"%@", NSStringFromSelector(_cmd));
-
-    NSOperationQueue *q = [[NSOperationQueue alloc] init];
-    __block BOOL asyncTestDone = NO;
-
-    // First retrieve token.
-    MWNetworkOp *getTokenOp = [[MWNetworkOp alloc] init];
-    getTokenOp.request = [NSURLRequest postRequestWithURL:[NSURL URLWithString:url_]
-                                       parameters:@{
-                                                    @"action": @"login",
-                                                    @"lgname": @"MHurd (WMF)",
-                                                    @"format": @"json"
-                                                    }
-    ];
-
-    // Now make op to take token and use it and a pwd for actual login attempt.
-    MWNetworkOp *loginWithTokenOp = [[MWNetworkOp alloc] init];
-    
-    // The login attempt op should happen *after* the getToken op, so add dependency.
-    [loginWithTokenOp addDependency:getTokenOp];
-    __weak MWNetworkOp *weakLoginWithTokenOp = loginWithTokenOp;
-    
-    // loginWithTokenOp is dependent on getTokenOp, so "aboutToStart" won't fire until getTokenOp is done.
-    loginWithTokenOp.aboutToStart = ^(){
-        XCTAssertNotNil(getTokenOp.dataRetrieved);
-        NSDictionary *result = [NSJSONSerialization JSONObjectWithData:getTokenOp.dataRetrieved options:0 error:nil];
-        NSLog(@"\n%s token retrieved = %@", __PRETTY_FUNCTION__, result);
-        XCTAssertNotNil(result[@"login"]);
-        XCTAssertNotNil(result[@"login"][@"token"]);
-        NSString *token = result[@"login"][@"token"];
-        weakLoginWithTokenOp.request = [NSURLRequest postRequestWithURL:[NSURL URLWithString:url_]
-            parameters:@{
-                         @"action": @"login",
-                         @"lgname": @"MHurd (WMF)",
-                         @"lgpassword": @"NOT MY REAL PWD",
-                         @"format": @"json",
-                         @"lgtoken": token
-        }];
-    };
-
-    // Confirm that a login result was obtained.
-    loginWithTokenOp.completionBlock = ^(){
-        XCTAssertNotNil(weakLoginWithTokenOp.dataRetrieved);
-        NSDictionary *result = [NSJSONSerialization JSONObjectWithData:weakLoginWithTokenOp.dataRetrieved options:0 error:nil];
-        NSLog(@"\n%s login data retrieved = %@", __PRETTY_FUNCTION__, result);
-        XCTAssertNotNil(result[@"login"]);
-        XCTAssertNotNil(result[@"login"][@"result"]);
-
-        // Let the run loop know it can stop waiting.
-        asyncTestDone = YES;
-    };
-
-    // Add the token retrieval and login attempt ops to the q.
-    [q addOperation:getTokenOp];
-    [q addOperation:loginWithTokenOp];
-
-    // Gives the ops a time window within which to complete their tasks before the XCTest considers this unit test done.
-    [[NSRunLoop mainRunLoop] runUntilTimeout:10.0 orFinishedFlag:&asyncTestDone];
-}
-
--(void)testNameCheckOp
-{
-    // Simple op configured to check if a file name already exists on server.
-    NSLog(@"%@", NSStringFromSelector(_cmd));
-
-    NSOperationQueue *q = [[NSOperationQueue alloc] init];
-    __block BOOL asyncTestDone = NO;
-
-    MWNetworkOp *op = [[MWNetworkOp alloc] init];
-    op.request = [NSURLRequest getRequestWithURL: [NSURL URLWithString:url_]
-                                      parameters: @{
-                                                    @"action": @"query",
-                                                    @"prop": @"imageinfo",
-                                                    @"format": @"json",
-                                                    @"titles": @"File:Asfafasdfas87876.jpg",
-                                                    }
-                  ];
-
-    __weak MWNetworkOp *weakOp = op;
-
-    op.completionBlock = ^(){
-        XCTAssertNil(weakOp.error);
-        NSDictionary *result = [NSJSONSerialization JSONObjectWithData:weakOp.dataRetrieved options:0 error:nil];
-        NSLog(@"\n%s data retrieved = %@", __PRETTY_FUNCTION__, result);
-        XCTAssertNotNil(result[@"query"]);
-        XCTAssertNotNil(result[@"query"][@"pages"]);
-        NSLog(@"\n%s file name already taken = %@", __PRETTY_FUNCTION__, result[@"query"][@"pages"][@"-1"] == nil ? @"YES" : @"NO");
-        asyncTestDone = YES;
-    };
-
-    [q addOperation:op];
-
-    // Give the async test a bit of time to finish.
-    [[NSRunLoop mainRunLoop] runUntilTimeout:10.0 orFinishedFlag:&asyncTestDone];
-}
-
-@end
diff --git a/wikipedia-tests/SiteTests.m b/wikipedia-tests/SiteTests.m
deleted file mode 100644
index f8548441e86..00000000000
--- a/wikipedia-tests/SiteTests.m
+++ /dev/null
@@ -1,45 +0,0 @@
-//  Created by Brion on 11/6/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-#import "WikipediaApp.h"
-
-@interface SiteTests : XCTestCase
-
-@end
-
-@implementation SiteTests {
-    MWSite *site;
-}
-
-- (void)setUp
-{
-    [super setUp];
-    site = [[MWSite alloc] initWithDomain:@"en.wikipedia.org"];
-}
-
-- (void)tearDown
-{
-    [super tearDown];
-}
-
-- (void)testDomain
-{
-    XCTAssertEqualObjects(site.domain, @"en.wikipedia.org");
-}
-
-- (void)testEquals
-{
-    MWSite *otherSite = [[MWSite alloc] initWithDomain:@"en.wikipedia.org"];
-    XCTAssertEqualObjects(site, otherSite);
-}
-
-- (void)testLinks
-{
-    XCTAssertEqualObjects([site titleForInternalLink:@"/wiki/India"].prefixedText, @"India");
-    XCTAssertEqualObjects([site titleForInternalLink:@"/wiki/Talk:India"].prefixedText, @"Talk:India");
-    XCTAssertEqualObjects([site titleForInternalLink:@"/wiki/Talk:India#History"].prefixedText, @"Talk:India");
-//    XCTAssertThrows([site titleForInternalLink:@"/upload/foobar"]);
-}
-
-@end
diff --git a/wikipedia-tests/Wikipedia-Tests-Info.plist b/wikipedia-tests/Wikipedia-Tests-Info.plist
deleted file mode 100644
index c0c055c15dc..00000000000
--- a/wikipedia-tests/Wikipedia-Tests-Info.plist
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleDevelopmentRegion</key>
-	<string>en</string>
-	<key>CFBundleExecutable</key>
-	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleIdentifier</key>
-	<string>org.wikimedia.${PRODUCT_NAME:rfc1034identifier}</string>
-	<key>CFBundleInfoDictionaryVersion</key>
-	<string>6.0</string>
-	<key>CFBundlePackageType</key>
-	<string>BNDL</string>
-	<key>CFBundleShortVersionString</key>
-	<string>1.0</string>
-	<key>CFBundleSignature</key>
-	<string>????</string>
-	<key>CFBundleVersion</key>
-	<string>1</string>
-</dict>
-</plist>
diff --git a/wikipedia-tests/Wikipedia_Tests.m b/wikipedia-tests/Wikipedia_Tests.m
deleted file mode 100644
index 12e062de90b..00000000000
--- a/wikipedia-tests/Wikipedia_Tests.m
+++ /dev/null
@@ -1,30 +0,0 @@
-//  Created by Brion on 10/27/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-
-@interface Wikipedia_Tests : XCTestCase
-
-@end
-
-@implementation Wikipedia_Tests
-
-- (void)setUp
-{
-    [super setUp];
-    // Put setup code here. This method is called before the invocation of each test method in the class.
-}
-
-- (void)tearDown
-{
-    // Put teardown code here. This method is called after the invocation of each test method in the class.
-    NSLog(@"done"); // crazy hack for "tests not finished"
-    [super tearDown];
-}
-
-- (void)testExample
-{
-    XCTAssert(YES, @"Confirming tests work!");
-}
-
-@end
diff --git a/wikipedia-tests/en.lproj/InfoPlist.strings b/wikipedia-tests/en.lproj/InfoPlist.strings
deleted file mode 100644
index 477b28ff8f8..00000000000
--- a/wikipedia-tests/en.lproj/InfoPlist.strings
+++ /dev/null
@@ -1,2 +0,0 @@
-/* Localized versions of Info.plist keys */
-
diff --git a/wikipedia-tests/mw-support/PageTitleTests.m b/wikipedia-tests/mw-support/PageTitleTests.m
deleted file mode 100644
index 86e3f8d90c8..00000000000
--- a/wikipedia-tests/mw-support/PageTitleTests.m
+++ /dev/null
@@ -1,50 +0,0 @@
-//  Created by Brion on 11/1/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <XCTest/XCTest.h>
-
-#import "MWPageTitle.h"
-
-@interface PageTitleTests : XCTestCase
-
-@end
-
-@implementation PageTitleTests
-
-- (void)setUp
-{
-    [super setUp];
-    // Put setup code here; it will be run once, before the first test case.
-}
-
-- (void)tearDown
-{
-    // Put teardown code here; it will be run once, after the last test case.
-    
-    // crazy hack for "tests not finished"
-    [NSThread sleepForTimeInterval:1.0];
-    NSLog(@"done");
-    
-    [super tearDown];
-}
-
-- (void)testCreate
-{
-    NSArray *dataSet = @[@{@"prefixed": @"Test-driven development",
-                           @"ns": @"",
-                           @"text": @"Test-driven development"},
-                         @{@"prefixed": @"Talk:Test-driven development",
-                           @"ns": @"Talk",
-                           @"text": @"Test-driven development"}];
-    for (NSDictionary *data in dataSet) {
-        NSString *ns = data[@"ns"];;
-        NSString *text = data[@"text"];
-        
-        MWPageTitle *title = [MWPageTitle titleFromNamespace:ns text:text];
-        XCTAssertEqualObjects(title.namespace, ns, @"Title namespace check");
-        XCTAssertEqualObjects(title.text, text, @"Title text check");
-        XCTAssertEqualObjects(title.prefixedText, data[@"prefixed"], @"Prefixed text check");
-    }
-}
-
-@end
diff --git a/wikipedia/AssetsFile/AssetsFile.m b/wikipedia/AssetsFile/AssetsFile.m
index 03781c528b9..d3dff452289 100644
--- a/wikipedia/AssetsFile/AssetsFile.m
+++ b/wikipedia/AssetsFile/AssetsFile.m
@@ -110,7 +110,8 @@ - (NSArray *)array
 // Returns YES if the local version of the config file doesn't exist or is older than maxAge.
 - (BOOL)isOlderThan:(CGFloat)maxAge
 {
-    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:self.path isDirectory:NO];
+    BOOL isDirectory = NO;
+    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:self.path isDirectory:&isDirectory];
     if (!fileExists){
         NSLog(@"REFRESH NEEDED");
         return YES;
diff --git a/wikipedia/Base.lproj/Main_iPhone.storyboard b/wikipedia/Base.lproj/Main_iPhone.storyboard
index ceec9937598..e65cdfd3314 100644
--- a/wikipedia/Base.lproj/Main_iPhone.storyboard
+++ b/wikipedia/Base.lproj/Main_iPhone.storyboard
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="6245" systemVersion="13F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" initialViewController="1qV-3k-dN1">
+<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="6250" systemVersion="14A389" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" initialViewController="1qV-3k-dN1">
     <dependencies>
-        <deployment defaultVersion="1536" identifier="iOS"/>
+        <deployment identifier="iOS"/>
         <development version="5100" identifier="xcode"/>
-        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="6238"/>
+        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="6244"/>
         <capability name="Alignment constraints with different attributes" minToolsVersion="5.1"/>
     </dependencies>
     <scenes>
diff --git a/wikipedia/Categories/NSObject+Extras.h b/wikipedia/Categories/NSObject+Extras.h
index aa0b8fbfdb8..1192992336f 100644
--- a/wikipedia/Categories/NSObject+Extras.h
+++ b/wikipedia/Categories/NSObject+Extras.h
@@ -7,4 +7,6 @@
 
 -(BOOL)isNull;
 
+-(BOOL)isDict;
+
 @end
diff --git a/wikipedia/Categories/NSObject+Extras.m b/wikipedia/Categories/NSObject+Extras.m
index 47ee42295ca..70ba122f580 100644
--- a/wikipedia/Categories/NSObject+Extras.m
+++ b/wikipedia/Categories/NSObject+Extras.m
@@ -10,4 +10,9 @@ -(BOOL)isNull
     return [self isKindOfClass:[NSNull class]];
 }
 
+-(BOOL)isDict
+{
+    return [self isKindOfClass:[NSDictionary class]];
+}
+
 @end
diff --git a/wikipedia/Categories/NSURLRequest+DictionaryRequest.m b/wikipedia/Categories/NSURLRequest+DictionaryRequest.m
index 2ead3e310b9..eefa10203c7 100644
--- a/wikipedia/Categories/NSURLRequest+DictionaryRequest.m
+++ b/wikipedia/Categories/NSURLRequest+DictionaryRequest.m
@@ -7,7 +7,7 @@
 #import "WikipediaAppUtils.h"
 #import <CoreTelephony/CTCarrier.h>
 #import <CoreTelephony/CTTelephonyNetworkInfo.h>
-#include <SystemConfiguration/SystemConfiguration.h>
+#import <SystemConfiguration/SystemConfiguration.h>
 
 @implementation NSURLRequest (DictionaryRequest)
 
diff --git a/wikipedia/Data/Model/Article.h b/wikipedia/Data/Model/Article.h
index be8b1db76bd..c1cb37fe175 100644
--- a/wikipedia/Data/Model/Article.h
+++ b/wikipedia/Data/Model/Article.h
@@ -9,7 +9,7 @@
 #import <Foundation/Foundation.h>
 #import <CoreData/CoreData.h>
 
-@class GalleryImage, History, Image, Saved, Section;
+@class GalleryImage, History, Image, Saved, Section, Article;
 
 @interface Article : NSManagedObject
 
@@ -34,6 +34,7 @@
 @property (nonatomic, retain) NSSet *saved;
 @property (nonatomic, retain) NSSet *section;
 @property (nonatomic, retain) Image *thumbnailImage;
+
 @end
 
 @interface Article (CoreDataGeneratedAccessors)
diff --git a/wikipedia/Data/Model/Article.m b/wikipedia/Data/Model/Article.m
index 464985a2d81..6eed262a0d4 100644
--- a/wikipedia/Data/Model/Article.m
+++ b/wikipedia/Data/Model/Article.m
@@ -13,7 +13,6 @@
 #import "Saved.h"
 #import "Section.h"
 
-
 @implementation Article
 
 @dynamic articleId;
diff --git a/wikipedia/Data/Operations/AccountCreationOp.h b/wikipedia/Data/Operations/AccountCreationOp.h
deleted file mode 100644
index 3209450125e..00000000000
--- a/wikipedia/Data/Operations/AccountCreationOp.h
+++ /dev/null
@@ -1,27 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-typedef enum {
-    ACCOUNT_CREATION_ERROR_UNKNOWN = 0,
-    ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA = 1
-} AccountCreationOpErrors;
-
-@interface AccountCreationOp : MWNetworkOp
-
-@property (strong, nonatomic) NSString *token;
-
-- (id)initWithDomain: (NSString *) domain
-            userName: (NSString *) userName
-            password: (NSString *) password
-            realName: (NSString *) realName
-               email: (NSString *) email
-           captchaId: (NSString *) captchaId
-         captchaWord: (NSString *) captchaWord
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/AccountCreationOp.m b/wikipedia/Data/Operations/AccountCreationOp.m
deleted file mode 100644
index 2e45b9ea061..00000000000
--- a/wikipedia/Data/Operations/AccountCreationOp.m
+++ /dev/null
@@ -1,139 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "AccountCreationOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@interface AccountCreationOp()
-
-@property (strong, nonatomic) NSString *domain;
-@property (strong, nonatomic) NSString *userName;
-@property (strong, nonatomic) NSString *password;
-@property (strong, nonatomic) NSString *realName;
-@property (strong, nonatomic) NSString *email;
-@property (strong, nonatomic) NSString *captchaId;
-@property (strong, nonatomic) NSString *captchaWord;
-
-@end
-
-@implementation AccountCreationOp
-
--(NSURLRequest *)getRequest
-{
-    NSMutableDictionary *parameters = [@{
-                                         @"action":     @"createaccount",
-                                         @"name":       self.userName,
-                                         @"password":   self.password,
-                                         @"realname":   self.realName,
-                                         @"email":      self.email,
-                                         @"reason":     ([self.domain isEqualToString:@"test"])
-                                                            ? @"iOS App Account Creation Testing"
-                                                            : @"iOS App Account Creation",
-                                         @"language":   ([self.domain isEqualToString:@"test"])
-                                                            ? @"en"
-                                                            : self.domain,
-                                         @"format":     @"json"
-                                         }mutableCopy];
-    
-    if (self.token && self.token.length > 0) {
-        parameters[@"token"] = self.token;
-    }
-    if (self.captchaId && self.captchaId.length > 0) {
-        parameters[@"captchaid"] = self.captchaId;
-    }
-    if (self.captchaWord && self.captchaWord.length > 0) {
-        parameters[@"captchaword"] = self.captchaWord;
-    }
-
-    //NSLog(@"parameters = %@", parameters);
-    return [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:self.domain]
-                                 parameters: parameters
-            ];
-}
-
-- (id)initWithDomain: (NSString *) domain
-            userName: (NSString *) userName
-            password: (NSString *) password
-            realName: (NSString *) realName
-               email: (NSString *) email
-           captchaId: (NSString *) captchaId
-         captchaWord: (NSString *) captchaWord
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        self.domain = domain ? domain : @"";
-        self.userName = userName ? userName : @"";
-        self.password = password ? password : @"";
-        self.realName = realName ? realName : @"";
-        self.email = email ? email : @"";
-        self.captchaId = captchaId ? captchaId : @"";
-        self.captchaWord = captchaWord ? captchaWord : @"";
-
-        __weak AccountCreationOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-            weakSelf.request = [weakSelf getRequest];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            //NSLog(@"Account Creation Op jsonRetrieved = %@", weakSelf.jsonRetrieved);
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                NSInteger errorCode = ACCOUNT_CREATION_ERROR_UNKNOWN;
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Account Creation Op" code:errorCode userInfo:errorDict];
-            }
-
-            if(weakSelf.jsonRetrieved[@"createaccount"]){
-                NSString *createAccountResult = weakSelf.jsonRetrieved[@"createaccount"][@"result"];
-                if ([createAccountResult isEqualToString:@"NeedCaptcha"]) {
-                    NSMutableDictionary *errorDict = @{}.mutableCopy;
-
-                    if (weakSelf.jsonRetrieved[@"createaccount"][@"captcha"]) {
-                        errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"account-creation-captcha-required", nil);
-                        
-                        // Make the capcha id and url available from the error.
-                        errorDict[@"captchaId"] = weakSelf.jsonRetrieved[@"createaccount"][@"captcha"][@"id"];
-                        errorDict[@"captchaUrl"] = weakSelf.jsonRetrieved[@"createaccount"][@"captcha"][@"url"]; 
-                    }
-                    
-                    // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                    weakSelf.error = [NSError errorWithDomain: @"Account Creation Op"
-                                                         code: ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA
-                                                     userInfo: errorDict];
-                }
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            NSString *result = weakSelf.jsonRetrieved[@"createaccount"][@"result"];
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/AccountCreationTokenOp.h b/wikipedia/Data/Operations/AccountCreationTokenOp.h
deleted file mode 100644
index 2301ebde03d..00000000000
--- a/wikipedia/Data/Operations/AccountCreationTokenOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface AccountCreationTokenOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *) domain
-            userName: (NSString *) userName
-            password: (NSString *) password
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/AccountCreationTokenOp.m b/wikipedia/Data/Operations/AccountCreationTokenOp.m
deleted file mode 100644
index 038ef34d675..00000000000
--- a/wikipedia/Data/Operations/AccountCreationTokenOp.m
+++ /dev/null
@@ -1,88 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "AccountCreationTokenOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@interface AccountCreationTokenOp()
-
-@property (strong, nonatomic) NSString *domain;
-@property (strong, nonatomic) NSString *userName;
-@property (strong, nonatomic) NSString *password;
-
-@end
-
-@implementation AccountCreationTokenOp
-
--(NSURLRequest *)getRequest
-{
-    NSMutableDictionary *parameters =
-        @{
-          @"action":     @"createaccount",
-          @"name":       self.userName,
-          @"password":   self.password,
-          @"language":
-              ([self.domain isEqualToString:@"test"]) ?
-                @"en"
-                :
-                self.domain,
-          @"format":     @"json"
-          }.mutableCopy;
-    
-    return [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:self.domain]
-                                 parameters: parameters];
-}
-
-- (id)initWithDomain: (NSString *) domain
-            userName: (NSString *) userName
-            password: (NSString *) password
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-
-{
-    self = [super init];
-    if (self) {
-
-        self.domain = domain ? domain : @"";
-        self.userName = userName ? userName : @"";
-        self.password = password ? password : @"";
-
-        __weak AccountCreationTokenOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-            weakSelf.request = [weakSelf getRequest];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Account Creation Token Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            NSString *result = weakSelf.jsonRetrieved[@"createaccount"][@"token"];
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/CaptchaResetOp.h b/wikipedia/Data/Operations/CaptchaResetOp.h
deleted file mode 100644
index 6d192d5d09b..00000000000
--- a/wikipedia/Data/Operations/CaptchaResetOp.h
+++ /dev/null
@@ -1,14 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface CaptchaResetOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/CaptchaResetOp.m b/wikipedia/Data/Operations/CaptchaResetOp.m
deleted file mode 100644
index d2088128ec3..00000000000
--- a/wikipedia/Data/Operations/CaptchaResetOp.m
+++ /dev/null
@@ -1,63 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "CaptchaResetOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation CaptchaResetOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *parameters = [@{
-                                             @"action": @"fancycaptchareload",
-                                             @"format": @"json"
-                                             }mutableCopy];
-        
-        self.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: parameters
-                        ];
-        
-        __weak CaptchaResetOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Captcha Reset Token Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            NSDictionary *result = weakSelf.jsonRetrieved[@"fancycaptchareload"];
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadLangLinksOp.h b/wikipedia/Data/Operations/DownloadLangLinksOp.h
deleted file mode 100644
index 68fbe474a76..00000000000
--- a/wikipedia/Data/Operations/DownloadLangLinksOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface DownloadLangLinksOp : MWNetworkOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-          allLanguages: (NSArray *)allLanguages
-       completionBlock: (void (^)(NSArray *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadLangLinksOp.m b/wikipedia/Data/Operations/DownloadLangLinksOp.m
deleted file mode 100644
index e29072143ff..00000000000
--- a/wikipedia/Data/Operations/DownloadLangLinksOp.m
+++ /dev/null
@@ -1,102 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "DownloadLangLinksOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation DownloadLangLinksOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-          allLanguages: (NSArray *)allLanguages
-       completionBlock: (void (^)(NSArray *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        self.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: @{
-                                                           @"action": @"query",
-                                                           @"prop": @"langlinks",
-                                                           @"titles": title,
-                                                           @"lllimit": @"500",
-                                                           @"redirects": @"",
-                                                           @"format": @"json"
-                                                           }
-                        ];
-        __weak DownloadLangLinksOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Lang Links Op" code:001 userInfo:errorDict];
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"weakSelf.jsonRetrieved = %@", weakSelf.jsonRetrieved);
-
-            NSArray *langLinks = @[];
-            NSDictionary *pages = weakSelf.jsonRetrieved[@"query"][@"pages"];
-            if (pages) {
-                NSDictionary *page = pages[pages.allKeys[0]];
-                if (page) {
-                    langLinks = page[@"langlinks"];
-                }
-            }
-
-            // Get dictionary with lang code as key and the localized title as the value
-            NSMutableDictionary *langCodeToLocalTitleDict = [@{} mutableCopy];
-            for (NSDictionary *d in langLinks) {
-                langCodeToLocalTitleDict[d[@"lang"]] = d[@"*"];
-            }
-            
-            // Loop through the data from the languages file and add an entry to the
-            // output array for each match found in langCodeToLocalTitleDict including
-            // all of the keys from the lang file and the local title from the downloaded
-            // results. The end results is an array containing dictionaries containing
-            // the lang code, lang name, lang canonical name, and the localized title.
-            // (Also, the output array's lang codes will be ordered the same as they are
-            // in the lang file.)
-            NSMutableArray *outputArray = [@[] mutableCopy];
-            for (NSDictionary *fileDict in allLanguages) {
-                if ([langCodeToLocalTitleDict objectForKey:fileDict[@"code"]]) {
-                
-                    if ([[SessionSingleton sharedInstance].unsupportedCharactersLanguageIds indexOfObject:fileDict[@"code"]] != NSNotFound) continue;
-
-                    [outputArray addObject:@{
-                                             @"code": fileDict[@"code"],
-                                             @"canonical_name": fileDict[@"canonical_name"],
-                                             @"name": fileDict[@"name"],
-                                             @"*": langCodeToLocalTitleDict[fileDict[@"code"]],
-                                             }];
-                }
-            }
-
-            completionBlock(outputArray);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadSectionWikiTextOp.h b/wikipedia/Data/Operations/DownloadSectionWikiTextOp.h
deleted file mode 100644
index 0186545dd7a..00000000000
--- a/wikipedia/Data/Operations/DownloadSectionWikiTextOp.h
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface DownloadSectionWikiTextOp : MWNetworkOp
-
-// Note: "section" parameter needs to be a string because the
-// api returns transcluded section indexes with a "T-" prefix
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-               section: (NSString *)section
-       completionBlock: (void (^)(NSString *, NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadSectionWikiTextOp.m b/wikipedia/Data/Operations/DownloadSectionWikiTextOp.m
deleted file mode 100644
index 7bbcdc52943..00000000000
--- a/wikipedia/Data/Operations/DownloadSectionWikiTextOp.m
+++ /dev/null
@@ -1,84 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "DownloadSectionWikiTextOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation DownloadSectionWikiTextOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-               section: (NSString *)section
-       completionBlock: (void (^)(NSString *, NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        self.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: @{
-                                                           @"action": @"query",
-                                                           @"prop": @"revisions",
-                                                           @"rvprop": @"content",
-                                                           @"rvlimit": @1,
-                                                           @"rvsection": section,
-                                                           @"titles": title,
-                                                           @"meta": @"userinfo", // we need the local user ID for event logging
-                                                           @"format": @"json"
-                                                           }
-                        ];
-        __weak DownloadSectionWikiTextOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Download Wikitext Op" code:001 userInfo:errorDict];
-            }
-         
-            NSString *revision = nil;
-            NSDictionary *pages = weakSelf.jsonRetrieved[@"query"][@"pages"];
-            NSDictionary *userInfo = weakSelf.jsonRetrieved[@"query"][@"userinfo"];
-            if (pages) {
-                NSDictionary *page = pages[pages.allKeys[0]];
-                if (page) {
-                    revision = page[@"revisions"][0][@"*"];
-                }
-            }
-
-            if (!weakSelf.error && !revision) {
-                NSMutableDictionary *errorDict = [@{} mutableCopy];
-                errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"wikitext-download-failed", nil);
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Download Wikitext Op" code:002 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            completionBlock(revision, userInfo);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadSectionsOp.h b/wikipedia/Data/Operations/DownloadSectionsOp.h
deleted file mode 100644
index 1089bb44b79..00000000000
--- a/wikipedia/Data/Operations/DownloadSectionsOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface DownloadSectionsOp : MWNetworkOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-       leadSectionOnly: (BOOL)leadSectionOnly
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadSectionsOp.m b/wikipedia/Data/Operations/DownloadSectionsOp.m
deleted file mode 100644
index 4fe8947409c..00000000000
--- a/wikipedia/Data/Operations/DownloadSectionsOp.m
+++ /dev/null
@@ -1,175 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "DownloadSectionsOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "NSString+Extras.h"
-#import "NSObject+Extras.h"
-#import "ReadingActionFunnel.h"
-
-@implementation DownloadSectionsOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-       leadSectionOnly: (BOOL)leadSectionOnly
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *params =
-        @{
-          @"action": @"mobileview",
-          @"prop": @"sections|text|lastmodified|lastmodifiedby|languagecount|id|protection|editable|displaytitle",
-          @"sectionprop": @"toclevel|line|anchor|level|number|fromtitle|index",
-          @"noheadings": @"true",
-          @"page": title,
-          @"format": @"json"
-          }.mutableCopy;
-        
-        if (!leadSectionOnly) {
-            params[@"onlyrequestedsections"] = @"1";
-            params[@"sections"] = @"1-";
-        }else{
-
-            //Reminder: do not set @"onlyrequestedsections": @"1" for lead section.
-            //Need to see keys for the subsequent sections so the "needsRefresh"
-            //value can be left YES until subsequent sections have been retrieved
-            //(if there's more than a single section).
-
-            params[@"sections"] = @"0";
-            
-            if ([SessionSingleton sharedInstance].sendUsageReports) {
-                ReadingActionFunnel *funnel = [[ReadingActionFunnel alloc] init];
-                params[@"appInstallID"] = funnel.appInstallID;
-            }
-        }
-    
-        self.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                            parameters: params];
-        __weak DownloadSectionsOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-
-                NSString *errorDomain = leadSectionOnly ? @"Section Zero Op" : @"Section Non Zero Op";
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:errorDomain code:001 userInfo:errorDict];
-                
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-
-
-
-
-            NSArray *sections = weakSelf.jsonRetrieved[@"mobileview"][@"sections"];
-
-            NSMutableArray *outputSections = @[].mutableCopy;
-            
-            // The fromtitle tells us if a section was transcluded, but the api sometimes returns false instead
-            // of just leaving it out if the section wasn't transcluded. It is also sometimes the name of the
-            // current article, which is redundant. So here remove the fromtitle key/value in both of these
-            // cases. That way the existense of a "fromtitle" can be relied on as a true transclusion indicator.
-            // Todo: pull this out into own method within this file.
-            for (NSDictionary *section in sections) {
-                NSMutableDictionary *mutableSection = section.mutableCopy;
-                if ([mutableSection[@"fromtitle"] isKindOfClass:[NSString class]]) {
-                    NSString *fromTitle = mutableSection[@"fromtitle"];
-                    if ([[title wikiTitleWithoutUnderscores] isEqualToString:[fromTitle wikiTitleWithoutUnderscores]]) {
-                        [mutableSection removeObjectForKey:@"fromtitle"];
-                    }
-                }else{
-                    [mutableSection removeObjectForKey:@"fromtitle"];
-                }
-                [outputSections addObject:mutableSection];
-            }
-
-
-
-
-
-            NSString *lastmodifiedDateString = weakSelf.jsonRetrieved[@"mobileview"][@"lastmodified"];
-            NSDate *lastmodifiedDate = [lastmodifiedDateString getDateFromIso8601DateString];
-            if (!lastmodifiedDate || [lastmodifiedDate isNull]) {
-                NSLog(@"Bad lastmodified date, will show as recently modified as a workaround");
-                lastmodifiedDate = [[NSDate alloc] init];
-            }
-
-            NSDictionary *lastmodifiedbyDict = weakSelf.jsonRetrieved[@"mobileview"][@"lastmodifiedby"];
-            NSString *lastmodifiedby = @"";
-            if (lastmodifiedbyDict && (![lastmodifiedbyDict isNull]) && lastmodifiedbyDict[@"name"]) {
-                lastmodifiedby = lastmodifiedbyDict[@"name"];
-            }
-            if (!lastmodifiedby || [lastmodifiedby isNull]) lastmodifiedby = @"";
-            
-            NSNumber *languagecount = weakSelf.jsonRetrieved[@"mobileview"][@"languagecount"];
-            if (!languagecount || [languagecount isNull]) languagecount = @1;
-            
-            NSString *redirected = weakSelf.jsonRetrieved[@"mobileview"][@"redirected"];
-            if (!redirected || [redirected isNull]) redirected = @"";
-            
-            NSNumber *articleId = weakSelf.jsonRetrieved[@"mobileview"][@"id"];
-            if (!articleId || [articleId isNull]) articleId = @0;
-            
-            NSNumber *editable = weakSelf.jsonRetrieved[@"mobileview"][@"editable"];
-            if (!editable || [editable isNull]) editable = @NO;
-            
-            NSString *displaytitle = weakSelf.jsonRetrieved[@"mobileview"][@"displaytitle"];
-            if (!displaytitle || [displaytitle isNull]) displaytitle = @"";
-            
-            NSString *protectionStatus = @"";
-            id protection = weakSelf.jsonRetrieved[@"mobileview"][@"protection"];
-            // if empty this can be an array instead of an object/dict!
-            // https://bugzilla.wikimedia.org/show_bug.cgi?id=67054
-            if (protection && [protection isKindOfClass:[NSDictionary class]]) {
-                NSDictionary *protectionDict = (NSDictionary *)protection;
-                if (protectionDict[@"edit"] && [protection[@"edit"] count] > 0) {
-                    protectionStatus = protectionDict[@"edit"][0];
-                }
-            }
-            if (!protectionStatus || [protectionStatus isNull]) protectionStatus = @"";
-
-            NSMutableDictionary *output = @{
-                                            @"sections": outputSections,
-                                            @"lastmodified": lastmodifiedDate,
-                                            @"lastmodifiedby": lastmodifiedby,
-                                            @"redirected": redirected,
-                                            @"displaytitle": displaytitle,
-                                            @"languagecount": languagecount,
-                                            @"articleId": articleId,
-                                            @"editable": editable,
-                                            @"protectionStatus": protectionStatus
-                                            }.mutableCopy;
-
-
-
-            completionBlock(output);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.h b/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.h
deleted file mode 100644
index 21072130c19..00000000000
--- a/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.h
+++ /dev/null
@@ -1,14 +0,0 @@
-//  Created by Adam Baso on 2/14/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface DownloadTitlesForRandomArticlesOp : MWNetworkOp
-
-- (id)initForDomain: (NSString *)domain
-    completionBlock: (void (^)(NSString *title))completionBlock
-     cancelledBlock: (void (^)(NSError *))cancelledBlock
-         errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.m b/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.m
deleted file mode 100644
index dd0a89b5afa..00000000000
--- a/wikipedia/Data/Operations/DownloadTitlesForRandomArticlesOp.m
+++ /dev/null
@@ -1,65 +0,0 @@
-//  Created by Adam Baso on 2/14/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "DownloadTitlesForRandomArticlesOp.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "NSString+Extras.h"
-
-@implementation DownloadTitlesForRandomArticlesOp
-
-- (id)initForDomain: (NSString *)domain
-    completionBlock: (void (^)(NSString *))completionBlock
-     cancelledBlock: (void (^)(NSError *))cancelledBlock
-         errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        // FUTURE FEATURE: Get multiple titles, and cache them so they're readily available
-        // Will need to consider things like article language changes, though.
-        self.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: @{
-                                                           @"action": @"query",
-                                                           @"list": @"random",
-                                                           @"rnlimit": @"1",
-                                                           @"rnnamespace": @"0",
-                                                           @"format": @"json"
-                                                           }
-                        ];
-        __weak DownloadTitlesForRandomArticlesOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            // Check for error
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Random Titles Op" code:001 userInfo:errorDict];
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            NSArray *randomArticles = (NSArray *)weakSelf.jsonRetrieved[@"query"][@"random"];
-            NSDictionary *article = [randomArticles objectAtIndex:0];
-            NSString *title = article[@"title"];
-
-            completionBlock(title);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.h b/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.h
deleted file mode 100644
index 416fde9184b..00000000000
--- a/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.h
+++ /dev/null
@@ -1,14 +0,0 @@
-//  Created by Adam Baso on 2/5/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface DownloadWikipediaZeroMessageOp : MWNetworkOp
-
-- (id)initForDomain: (NSString *)domain
-    completionBlock: (void (^)(NSString *))completionBlock
-     cancelledBlock: (void (^)(NSError *))cancelledBlock
-         errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.m b/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.m
deleted file mode 100644
index 6d3da92fb17..00000000000
--- a/wikipedia/Data/Operations/DownloadWikipediaZeroMessageOp.m
+++ /dev/null
@@ -1,75 +0,0 @@
-//  Created by Adam Baso on 2/5/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "DownloadWikipediaZeroMessageOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "WikipediaAppUtils.h"
-
-@implementation DownloadWikipediaZeroMessageOp
-
-- (id)initForDomain: (NSString *)domain
-    completionBlock: (void (^)(NSString *))completionBlock
-     cancelledBlock: (void (^)(NSError *))cancelledBlock
-         errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        self.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: @{
-                                                           @"action": @"zeroconfig",
-                                                           @"type": @"message",
-                                                           @"agent": [WikipediaAppUtils versionedUserAgent]
-                                                           }
-                        ];
-        __weak DownloadWikipediaZeroMessageOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            NSDictionary *json = weakSelf.jsonRetrieved;
-            
-            // Check for error retrieving message data
-            if(json.count > 0 && json[@"error"]){
-                NSMutableDictionary *errorDict = [json[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Wikipedia Zero Message Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            // NSLog(@"weakSelf.jsonRetrieved = %@", weakSelf.jsonRetrieved);
-            
-            NSString *zeroRatedMessage = json.count > 0 ? [json objectForKey:@"message"] : nil;
-            
-            // For testing Wikipedia Zero visual flourishes.
-            // Go to WebViewController.m and uncomment the W0 part,
-            // then when running the app in the simulator fire the
-            // memory warning to toggle the fake state on or off.
-            if ([SessionSingleton sharedInstance].zeroConfigState.fakeZeroOn) {
-                zeroRatedMessage = @"Free Wikipedia by Test Operator";
-            }
-            
-            if (zeroRatedMessage) {
-                completionBlock(zeroRatedMessage);
-            }
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/EditTokenOp.h b/wikipedia/Data/Operations/EditTokenOp.h
deleted file mode 100644
index 57a957312d7..00000000000
--- a/wikipedia/Data/Operations/EditTokenOp.h
+++ /dev/null
@@ -1,14 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface EditTokenOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/EditTokenOp.m b/wikipedia/Data/Operations/EditTokenOp.m
deleted file mode 100644
index f85481e0b77..00000000000
--- a/wikipedia/Data/Operations/EditTokenOp.m
+++ /dev/null
@@ -1,64 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "EditTokenOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation EditTokenOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *parameters = [@{
-                                             @"action": @"tokens",
-                                             @"type": @"edit",
-                                             @"format": @"json"
-                                             }mutableCopy];
-        
-        self.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: parameters
-                        ];
-        
-        __weak EditTokenOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Edit Token Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            NSDictionary *result = weakSelf.jsonRetrieved;
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/LogEventOp.m b/wikipedia/Data/Operations/LogEventOp.m
deleted file mode 100644
index 508d2d5270a..00000000000
--- a/wikipedia/Data/Operations/LogEventOp.m
+++ /dev/null
@@ -1,48 +0,0 @@
-//  Created by Monte Hurd on 4/11/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "LogEventOp.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "NSString+Extras.h"
-#import "SessionSingleton.h"
-#import "WikipediaAppUtils.h"
-
-#define LOG_ENDPOINT @"https://bits.wikimedia.org/event.gif"
-
-//#define LOG_ENDPOINT @"http://localhost:8000/event.gif"
-
-@implementation LogEventOp
-
-- (id)initWithSchema: (NSString *)schema
-            revision: (int)revision
-               event: (NSDictionary *)event
-                wiki: (NSString *)wiki
-{
-    self = [super init];
-    if (self) {
-
-        NSDictionary *payload =
-        @{
-          @"event"    : event,
-          @"revision" : @(revision),
-          @"schema"   : schema,
-          @"wiki"     : wiki
-          };
-
-        NSData *payloadJsonData = [NSJSONSerialization dataWithJSONObject:payload options:0 error:nil];
-        NSString *payloadJsonString = [[NSString alloc] initWithData:payloadJsonData encoding:NSUTF8StringEncoding];
-        NSLog(@"%@", payloadJsonString);
-        NSString *encodedPayloadJsonString = [payloadJsonString urlEncodedUTF8String];
-        NSString *urlString = [NSString stringWithFormat:@"%@?%@;", LOG_ENDPOINT, encodedPayloadJsonString];
-        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:urlString]];
-        [request addValue:[WikipediaAppUtils versionedUserAgent] forHTTPHeaderField:@"User-Agent"];
-        self.request = request;
-        
-        self.completionBlock = ^(){
-            //NSLog(@"EVENT LOGGING COMPLETED");
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/LoginOp.h b/wikipedia/Data/Operations/LoginOp.h
deleted file mode 100644
index 05ef478b837..00000000000
--- a/wikipedia/Data/Operations/LoginOp.h
+++ /dev/null
@@ -1,18 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface LoginOp : MWNetworkOp
-
-@property (strong, nonatomic) NSString *token;
-
-- (id)initWithUsername: (NSString *)userName
-              password: (NSString *)password
-                domain: (NSString *)domain
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/LoginOp.m b/wikipedia/Data/Operations/LoginOp.m
deleted file mode 100644
index 496831086d8..00000000000
--- a/wikipedia/Data/Operations/LoginOp.m
+++ /dev/null
@@ -1,137 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "LoginOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@interface LoginOp()
-
-@property (strong, nonatomic) NSString *userName;
-@property (strong, nonatomic) NSString *password;
-@property (strong, nonatomic) NSString *domain;
-
-@end
-
-@implementation LoginOp
-
--(NSURLRequest *)getRequest
-{
-    NSMutableDictionary *parameters = [@{
-                                         @"action": @"login",
-                                         @"lgname": self.userName,
-                                         @"lgpassword": self.password,
-                                         @"format": @"json"
-                                         }mutableCopy];
-    
-
-    if (self.token) {
-        parameters[@"lgtoken"] = self.token;
-    }
-
-    return [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:self.domain]
-                                 parameters: parameters
-            ];
-}
-
-- (id)initWithUsername: (NSString *)userName
-              password: (NSString *)password
-                domain: (NSString *)domain
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        self.token = nil;
-        self.userName = userName;
-        self.password = password;
-        self.domain = domain;
-        __weak LoginOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-            weakSelf.request = [weakSelf getRequest];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Login Op" code:001 userInfo:errorDict];
-            }
-
-            if (!weakSelf.error) {
-                
-                //NSLog(@"LoginOp jsonRetrieved = %@", weakSelf.jsonRetrieved);
-                
-                NSString *result = weakSelf.jsonRetrieved[@"login"][@"result"];
-                
-                if (![result isEqualToString:@"Success"]) {
-                    NSMutableDictionary *errorDict = [@{} mutableCopy];
-                    
-                    NSString *errorMessage = [weakSelf getErrorMessageForResult:result];
-                    
-                    errorDict[NSLocalizedDescriptionKey] = errorMessage;
-                    
-                    // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                    weakSelf.error = [NSError errorWithDomain:@"Login Op" code:002 userInfo:errorDict];
-                }
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            NSDictionary *result = weakSelf.jsonRetrieved;
-            //NSString *result = weakSelf.jsonRetrieved[@"login"][@"result"];
-
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
--(NSString *)getErrorMessageForResult:(NSString *)result
-{
-    // Error types from: http://www.mediawiki.org/wiki/API:Login#Errors
-    NSString *errorMessage = [NSString stringWithFormat:@"Unknown login error. Code '%@'", result];
-
-    if ([result isEqualToString:@"NoName"]) {
-        errorMessage = MWLocalizedString(@"login-name-not-found", nil);
-
-    }else if ([result isEqualToString:@"Illegal"]) {
-        errorMessage = MWLocalizedString(@"login-name-illegal", nil);
-
-    }else if ([result isEqualToString:@"NotExists"]) {
-        errorMessage = MWLocalizedString(@"login-name-does-not-exist", nil);
-
-    }else if ([result isEqualToString:@"EmptyPass"]) {
-        errorMessage = MWLocalizedString(@"login-password-empty", nil);
-
-    }else if ([result isEqualToString:@"WrongPass"] || [result isEqualToString:@"WrongPluginPass"]) {
-        errorMessage = MWLocalizedString(@"login-password-wrong", nil);
-
-    }else if ([result isEqualToString:@"Throttled"]) {
-        errorMessage = MWLocalizedString(@"login-throttled", nil);
-
-    }else if ([result isEqualToString:@"Blocked"]) {
-        errorMessage = MWLocalizedString(@"login-user-blocked", nil);
-    }
-    
-    return errorMessage;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/LoginTokenOp.h b/wikipedia/Data/Operations/LoginTokenOp.h
deleted file mode 100644
index ae04203b482..00000000000
--- a/wikipedia/Data/Operations/LoginTokenOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface LoginTokenOp : MWNetworkOp
-
-- (id)initWithUsername: (NSString *)userName
-              password: (NSString *)password
-                domain: (NSString *)domain
-       completionBlock: (void (^)(NSString *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/LoginTokenOp.m b/wikipedia/Data/Operations/LoginTokenOp.m
deleted file mode 100644
index 74e59a3cc80..00000000000
--- a/wikipedia/Data/Operations/LoginTokenOp.m
+++ /dev/null
@@ -1,67 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "LoginTokenOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation LoginTokenOp
-
-- (id)initWithUsername: (NSString *)userName
-              password: (NSString *)password
-                domain: (NSString *)domain
-       completionBlock: (void (^)(NSString *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-        NSMutableDictionary *parameters = [@{
-                                             @"action": @"login",
-                                             @"lgname": userName,
-                                             @"lgpassword": password,
-                                             @"format": @"json"
-                                             }mutableCopy];
-        
-        self.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: parameters
-                        ];
-        __weak LoginTokenOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Login Token Op" code:001 userInfo:errorDict];
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"loginTokenOp jsonRetrieved = %@", weakSelf.jsonRetrieved);
-
-            NSString *token = weakSelf.jsonRetrieved[@"login"][@"token"];
-            
-            completionBlock(token);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/NearbyOp.h b/wikipedia/Data/Operations/NearbyOp.h
deleted file mode 100644
index e999d2977dc..00000000000
--- a/wikipedia/Data/Operations/NearbyOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 8/8/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-#import <CoreLocation/CoreLocation.h>
-
-@interface NearbyOp : MWNetworkOp
-
-- (id)initWithLatitude: (CLLocationDegrees)latitude
-             longitude: (CLLocationDegrees)longitude
-       completionBlock: (void (^)(NSArray *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/NearbyOp.m b/wikipedia/Data/Operations/NearbyOp.m
deleted file mode 100644
index 2332b21a04c..00000000000
--- a/wikipedia/Data/Operations/NearbyOp.m
+++ /dev/null
@@ -1,111 +0,0 @@
-//  Created by Monte Hurd on 8/8/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "NearbyOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "Defines.h"
-
-@implementation NearbyOp
-
-- (id)initWithLatitude: (CLLocationDegrees)latitude
-             longitude: (CLLocationDegrees)longitude
-       completionBlock: (void (^)(NSArray *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSDictionary *parameters =
-        @{
-          @"action": @"query",
-          @"prop": @"coordinates|pageimages",
-          @"colimit": @"50",
-          @"pithumbsize" : @(SEARCH_THUMBNAIL_WIDTH),
-          @"pilimit": @"50",
-          @"generator": @"geosearch",
-          @"ggscoord": [NSString stringWithFormat:@"%f|%f", latitude, longitude],
-          @"ggsradius": @"10000",
-          @"ggslimit": @"50",
-          @"format": @"json"
-          };
-        
-        self.request =
-        [NSURLRequest getRequestWithURL: [NSURL URLWithString:[SessionSingleton sharedInstance].searchApiUrl]
-                             parameters: parameters];
-        
-        __weak NearbyOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"weakSelf.jsonRetrieved = %@", weakSelf.jsonRetrieved);
-            
-            // Check for error.
-            if(([[weakSelf.jsonRetrieved class] isSubclassOfClass:[NSDictionary class]]) && weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Nearby Op" code:001 userInfo:errorDict];
-            }
-
-            NSMutableArray *nearbyResults = @[].mutableCopy;
-            NSDictionary *jsonDict = (NSDictionary *)weakSelf.jsonRetrieved;
-            
-            if (jsonDict.count > 0) {
-                NSDictionary *pages = jsonDict[@"query"][@"pages"];
-                if (pages) {
-                    for (NSDictionary *pageId in pages) {
-                        NSDictionary *page = pages[pageId];
-                        NSArray *coordsArray = page[@"coordinates"];
-                        NSDictionary *coords = coordsArray.firstObject;
-                        NSNumber *pageId = page[@"pageid"];
-                        NSString *pageImage = page[@"pageimage"];
-                        NSDictionary *thumbnail = page[@"thumbnail"];
-                        NSString *title = page[@"title"];
-                        
-                        NSMutableDictionary *d = @{}.mutableCopy;
-                        if(coords)d[@"coordinates"] = coords;
-                        if(pageId)d[@"pageid"] = pageId;
-                        if(pageImage)d[@"pageimage"] = pageImage;
-                        if(thumbnail)d[@"thumbnail"] = thumbnail;
-                        if(title)d[@"title"] = title;
-                        
-                        [nearbyResults addObject:d];
-                    }
-                }
-            }
-
-            if (nearbyResults.count == 0) {
-                NSMutableDictionary *errorDict = @{}.mutableCopy;
-                
-                errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"nearby-none", nil);
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Nearby Op" code:002 userInfo:errorDict];
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            completionBlock(nearbyResults);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/PageHistoryOp.h b/wikipedia/Data/Operations/PageHistoryOp.h
deleted file mode 100644
index e7683f81ad4..00000000000
--- a/wikipedia/Data/Operations/PageHistoryOp.h
+++ /dev/null
@@ -1,15 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface PageHistoryOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *)domain
-               title: (NSString *)title
-     completionBlock: (void (^)(NSMutableArray *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/PageHistoryOp.m b/wikipedia/Data/Operations/PageHistoryOp.m
deleted file mode 100644
index cf322ddb244..00000000000
--- a/wikipedia/Data/Operations/PageHistoryOp.m
+++ /dev/null
@@ -1,143 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "PageHistoryOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "Defines.h"
-#import "NSString+Extras.h"
-#import "NSDate-Utilities.h"
-
-@implementation PageHistoryOp
-
-- (id)initWithDomain: (NSString *)domain
-               title: (NSString *)title
-     completionBlock: (void (^)(NSMutableArray *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-    
-        __weak PageHistoryOp *weakSelf = self;
-        
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-            
-            NSMutableDictionary *parameters = [@{
-                                                 @"action": @"query",
-                                                 @"prop": @"revisions",
-                                                 @"action": @"query",
-                                                 @"rvprop": @"ids|timestamp|user|size|parsedcomment",
-                                                 @"rvlimit": @50,
-                                                 @"rvdir": @"older",
-                                                 @"titles": title,
-                                                 @"format": @"json"
-                                                 } mutableCopy];
-            
-            //NSLog(@"parameters = %@", parameters);
-            
-            weakSelf.request = [NSURLRequest getRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                                 parameters: parameters
-                            ];
-        };
-        
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error.
-            if(([[weakSelf.jsonRetrieved class] isSubclassOfClass:[NSDictionary class]]) && weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Page History Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            NSMutableArray *output = @[].mutableCopy;
-
-            NSMutableDictionary *parentSizes = @{}.mutableCopy;
-            NSMutableDictionary *revisionsByDay = @{}.mutableCopy;
-            
-            NSDictionary *jsonDict = (NSDictionary *)weakSelf.jsonRetrieved;
-
-            if (jsonDict.count > 0) {
-                NSDictionary *pages = jsonDict[@"query"][@"pages"];
-                if (pages) {
-                    for (NSDictionary *page in pages) {
-                        NSString *title = pages[page][@"title"];
-                        for (NSDictionary *revision in pages[page][@"revisions"]) {
-                            NSMutableDictionary *mutableRevision = revision.mutableCopy;
-                            mutableRevision[@"title"] = title;
-                            
-                            parentSizes[revision[@"revid"]] = revision[@"size"];
-                            
-                            NSString *timeStampString = mutableRevision[@"timestamp"];
-                            NSDate *timeStampDate = [timeStampString getDateFromIso8601DateString];
-                            
-                            NSUInteger distanceInDaysToDate = [timeStampDate distanceInDaysToDate:[NSDate date]];
-                            
-                            //NSLog(@"distanceInDaysToDate = %d", [timeStampDate distanceInDaysToDate:[NSDate date]]);
-                            if (!revisionsByDay[@(distanceInDaysToDate)]) {
-                                revisionsByDay[@(distanceInDaysToDate)] = @[].mutableCopy;
-                            }
-                            
-                            NSMutableArray *revisionRowArray = revisionsByDay[@(distanceInDaysToDate)];
-                            [revisionRowArray addObject:mutableRevision];
-                        }
-                    }
-
-                    NSMutableArray *revisionsByDaySorted = @[].mutableCopy;
-                    for (NSNumber *day in [revisionsByDay.allKeys sortedArrayUsingSelector: @selector(compare:)]){
-                        [revisionsByDaySorted addObject:@{
-                                                          @"daysAgo": day,
-                                                          @"revisions": revisionsByDay[day]
-                                                          }];
-                    }
-                    
-                    [weakSelf calculateCharacterDeltasForRevisions:revisionsByDaySorted fromParentSizes:parentSizes];
-                    
-                    output = revisionsByDaySorted;
-                }
-            }
-
-            completionBlock(output);
-        };
-    }
-    return self;
-}
-
--(void)calculateCharacterDeltasForRevisions:(NSMutableArray *)revisions fromParentSizes:(NSDictionary *)parentSizes
-{
-    // Note: always retrieve one more than you're going to show so the oldest item
-    // shown can have it's characterDelta calculated.
-
-    for (NSDictionary *day in revisions) {
-        for (NSMutableDictionary *revision in day[@"revisions"]) {
-            NSNumber *parentId = revision[@"parentid"];
-            if(parentSizes[parentId]){
-                NSNumber *parentSize = parentSizes[parentId];
-                NSNumber *revisionSize = revision[@"size"];
-                revision[@"characterDelta"] = @(revisionSize.integerValue - parentSize.integerValue);
-            }else if (parentId){
-                if (parentId.integerValue == 0) {
-                    revision[@"characterDelta"] = revision[@"size"];
-                }
-            }
-        }
-    }
-}
-
-@end
diff --git a/wikipedia/Data/Operations/PreviewWikiText.h b/wikipedia/Data/Operations/PreviewWikiText.h
deleted file mode 100644
index 5c38439ab25..00000000000
--- a/wikipedia/Data/Operations/PreviewWikiText.h
+++ /dev/null
@@ -1,13 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-
-#import "MWNetworkOp.h"
-
-@interface EditTokenOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/PreviewWikiText.m b/wikipedia/Data/Operations/PreviewWikiText.m
deleted file mode 100644
index f2ee07c1340..00000000000
--- a/wikipedia/Data/Operations/PreviewWikiText.m
+++ /dev/null
@@ -1,63 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-
-#import "EditTokenOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation EditTokenOp
-
-- (id)initWithDomain: (NSString *)domain
-     completionBlock: (void (^)(NSDictionary *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *parameters = [@{
-                                             @"action": @"tokens",
-                                             @"type": @"edit",
-                                             @"format": @"json"
-                                             }mutableCopy];
-        
-        self.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: parameters
-                        ];
-        
-        __weak EditTokenOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Edit Token Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-            
-            NSDictionary *result = weakSelf.jsonRetrieved;
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/PreviewWikiTextOp.h b/wikipedia/Data/Operations/PreviewWikiTextOp.h
deleted file mode 100644
index d4a69244e45..00000000000
--- a/wikipedia/Data/Operations/PreviewWikiTextOp.h
+++ /dev/null
@@ -1,16 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface PreviewWikiTextOp : MWNetworkOp
-
-- (id)initWithDomain: (NSString *)domain
-               title: (NSString *)title
-            wikiText: (NSString *)wikiText
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/PreviewWikiTextOp.m b/wikipedia/Data/Operations/PreviewWikiTextOp.m
deleted file mode 100644
index b94479c6982..00000000000
--- a/wikipedia/Data/Operations/PreviewWikiTextOp.m
+++ /dev/null
@@ -1,73 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "PreviewWikiTextOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation PreviewWikiTextOp
-
-- (id)initWithDomain: (NSString *)domain
-               title: (NSString *)title
-            wikiText: (NSString *)wikiText
-     completionBlock: (void (^)(NSString *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *parameters = [@{
-                                             @"action": @"parse",
-                                             @"sectionpreview": @"true",
-                                             @"pst": @"true",
-                                             @"mobileformat": @"true",
-                                             @"title": title,
-                                             @"prop": @"text",
-                                             @"text": wikiText,
-                                             @"format": @"json"
-                                             }mutableCopy];
-        
-        // Note: "Preview should probably stay as a post, since the wikitext chunk may be pretty long and there may or may not be a limit on URL length some" - Brion
-        self.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                             parameters: parameters
-                        ];
-        
-        __weak PreviewWikiTextOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-            
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Preview WikiText Op" code:001 userInfo:errorDict];
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"weakSelf.jsonRetrieved = %@", weakSelf.jsonRetrieved);
-            NSString *result = weakSelf.jsonRetrieved[@"parse"][@"text"][@"*"];
-            
-            completionBlock(result);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/SearchOp.h b/wikipedia/Data/Operations/SearchOp.h
deleted file mode 100644
index c5112a21e1e..00000000000
--- a/wikipedia/Data/Operations/SearchOp.h
+++ /dev/null
@@ -1,14 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-@interface SearchOp : MWNetworkOp
-
-- (id)initWithSearchTerm: (NSString *)searchTerm
-     completionBlock: (void (^)(NSArray *))completionBlock
-      cancelledBlock: (void (^)(NSError *))cancelledBlock
-          errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/SearchOp.m b/wikipedia/Data/Operations/SearchOp.m
deleted file mode 100644
index 986b548765f..00000000000
--- a/wikipedia/Data/Operations/SearchOp.m
+++ /dev/null
@@ -1,186 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "SearchOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-#import "Defines.h"
-#import "NSString+Extras.h"
-#import "ArticleDataContextSingleton.h"
-#import "ArticleCoreDataObjects.h"
-#import "NSManagedObjectContext+SimpleFetch.h"
-
-@implementation SearchOp
-
-- (id)initWithSearchTerm: (NSString *)searchTerm
-         completionBlock: (void (^)(NSArray *))completionBlock
-          cancelledBlock: (void (^)(NSError *))cancelledBlock
-              errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-
-        NSMutableDictionary *parameters =
-        [@{
-           @"action": @"query",
-           @"generator": @"prefixsearch",
-           @"gpssearch": (searchTerm ? searchTerm : @""),
-           @"gpsnamespace": @0,
-           @"gpslimit": @(SEARCH_MAX_RESULTS),
-           @"prop": @"pageimages",
-           @"piprop": @"thumbnail",
-           @"pithumbsize" : @(SEARCH_THUMBNAIL_WIDTH),
-           @"pilimit": @(SEARCH_MAX_RESULTS),
-           @"format": @"json"
-           } mutableCopy];
-        
-        self.request = [NSURLRequest getRequestWithURL: [NSURL URLWithString:[SessionSingleton sharedInstance].searchApiUrl]
-                                             parameters: parameters
-                        ];
-
-        //NSLog(@"self.request = %@", self.request);
-        
-        __weak SearchOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"weakSelf.jsonRetrieved = %@", weakSelf.jsonRetrieved);
-            
-            // Check for error.
-            if(([[weakSelf.jsonRetrieved class] isSubclassOfClass:[NSDictionary class]]) && weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Search Op" code:001 userInfo:errorDict];
-            }
-
-            // Make output array contain just dictionaries for each result.
-            NSMutableArray *output = @[].mutableCopy;
-            NSDictionary *jsonDict = (NSDictionary *)weakSelf.jsonRetrieved;
-            if (jsonDict.count > 0) {
-                NSDictionary *query = (NSDictionary *)jsonDict[@"query"];
-                if (query) {
-                    NSDictionary *pages = (NSDictionary *)query[@"pages"];
-                    if (pages) {
-                        for (NSDictionary *pageId in pages) {
-
-                            // "dictionaryWithDictionary" used because it creates a deep mutable copy of the __NSCFDictionary.
-                            NSMutableDictionary *page = [NSMutableDictionary dictionaryWithDictionary:pages[pageId]];
-
-                            if (!page) continue;
-
-                            if (!page[@"thumbnail"]) page[@"thumbnail"] = @{}.mutableCopy;
-
-                            page[@"title"] = page[@"title"] ? [page[@"title"] wikiTitleWithoutUnderscores] : @"";
-
-                            if (page) [output addObject:page];
-                        }
-                    }
-                }
-            }
-            
-            // Sort output array by title.
-            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey: @"title"
-                                                                           ascending: YES];
-            NSArray *arraySortedByTitle = [output sortedArrayUsingDescriptors:@[sortDescriptor]];
-            output = arraySortedByTitle.mutableCopy;
-            
-            // Move best match(es) to top of array.
-            NSPredicate *p = [NSPredicate predicateWithFormat:@"title LIKE[c] %@", searchTerm];
-            NSArray *bestMatches = [output filteredArrayUsingPredicate:p];
-            if (bestMatches && (bestMatches.count > 0)) {
-                [output removeObjectsInArray:bestMatches];
-                NSArray* bestMatchesReversed = [[bestMatches reverseObjectEnumerator] allObjects];
-                output = [bestMatchesReversed arrayByAddingObjectsFromArray:output].mutableCopy;
-            }
-
-            // If no matches set error.
-            if (output.count == 0) {
-                NSMutableDictionary *errorDict = @{}.mutableCopy;
-                
-                errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"search-no-matches", nil);
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Search Op" code:002 userInfo:errorDict];
-            }
-
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            // Prepare placeholder Image records.
-            [[ArticleDataContextSingleton sharedInstance].mainContext performBlockAndWait:^(){
-                for (NSDictionary *page in output) {
-                    // If url thumb found, prepare a core data Image object so URLCache
-                    // will know this is an image to intercept.
-                    NSDictionary *thumbData = page[@"thumbnail"];
-                    if (thumbData) {
-                        NSString *src = thumbData[@"source"];
-                        NSNumber *height = thumbData[@"height"];
-                        NSNumber *width = thumbData[@"width"];
-                        if (src && height && width) {
-                            [weakSelf insertPlaceHolderImageEntityIntoContext: [ArticleDataContextSingleton sharedInstance].mainContext
-                                                              forImageWithUrl: src
-                                                                        width: width
-                                                                       height: height];
-                        }
-                    }
-                }
-                NSError *error = nil;
-                [[ArticleDataContextSingleton sharedInstance].mainContext save:&error];
-            }];
-            
-            completionBlock(output);
-        };
-    }
-    return self;
-}
-
-#pragma mark Core data Image record placeholder for thumbnail (so they get cached)
-
--(void)insertPlaceHolderImageEntityIntoContext: (NSManagedObjectContext *)context
-                               forImageWithUrl: (NSString *)url
-                                         width: (NSNumber *)width
-                                        height: (NSNumber *)height
-{
-    Image *existingImage = (Image *)[context getEntityForName: @"Image" withPredicateFormat:@"sourceUrl == %@", [url getUrlWithoutScheme]];
-    // If there's already an image record for this exact url, don't create another one!!!
-    if (!existingImage) {
-        Image *image = [NSEntityDescription insertNewObjectForEntityForName:@"Image" inManagedObjectContext:context];
-        image.imageData = [NSEntityDescription insertNewObjectForEntityForName:@"ImageData" inManagedObjectContext:context];
-        image.imageData.data = [[NSData alloc] init];
-        image.dataSize = @(image.imageData.data.length);
-        image.fileName = [url lastPathComponent];
-        image.fileNameNoSizePrefix = [image.fileName getWikiImageFileNameWithoutSizePrefix];
-        image.extension = [url pathExtension];
-        image.imageDescription = nil;
-        image.sourceUrl = [url getUrlWithoutScheme];
-        image.dateRetrieved = [NSDate date];
-        image.dateLastAccessed = [NSDate date];
-        image.width = @(width.integerValue);
-        image.height = @(height.integerValue);
-        image.mimeType = [image.extension getImageMimeTypeForExtension];
-    }
-}
-
-/*
--(void)dealloc
-{
-    NSLog(@"DEALLOC");
-}
-*/
-
-@end
diff --git a/wikipedia/Data/Operations/SyncAssetsFileOp.h b/wikipedia/Data/Operations/SyncAssetsFileOp.h
deleted file mode 100644
index 44514ed167a..00000000000
--- a/wikipedia/Data/Operations/SyncAssetsFileOp.h
+++ /dev/null
@@ -1,22 +0,0 @@
-//  Created by Monte Hurd on 5/8/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-#import "AssetsFileEnum.h"
-
-@interface SyncAssetsFileOp : MWNetworkOp
-
-// Syncs /AppData/Documents/assets/ file with a remote file.
-
-// Only does so if age of app file exceeds maxAge or if the file isn't found in app.
-
-// Nice because we can sync assets files with any periodicity
-// required just by firing these operations off occasionally.
-
-// They self-cancel if maxAge has not been exceeded, so fire away.
-
-- (id)initForAssetsFile: (AssetsFileEnum)file
-                 maxAge: (CGFloat)maxAge;
-
-@end
diff --git a/wikipedia/Data/Operations/SyncAssetsFileOp.m b/wikipedia/Data/Operations/SyncAssetsFileOp.m
deleted file mode 100644
index c6f08c58b24..00000000000
--- a/wikipedia/Data/Operations/SyncAssetsFileOp.m
+++ /dev/null
@@ -1,65 +0,0 @@
-//  Created by Monte Hurd on 5/8/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "SyncAssetsFileOp.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-#import "AssetsFile.h"
-
-@implementation SyncAssetsFileOp
-
-- (id)initForAssetsFile: (AssetsFileEnum)file
-                 maxAge: (CGFloat)maxAge
-{
-    self = [super init];
-    if (self) {
-    
-        AssetsFile *assetsFile = [[AssetsFile alloc] initWithFile:file];
-        self.request = [NSURLRequest getRequestWithURL: assetsFile.url
-                                            parameters: nil];
-        
-        __weak SyncAssetsFileOp *weakSelf = self;
-        self.aboutToStart = ^{
-            
-            // Cancel the operation if the existing file hasn't aged enough.
-            BOOL shouldRefresh = [assetsFile isOlderThan:maxAge];
-
-            if (!shouldRefresh) {
-                [weakSelf cancel];
-                return;
-            }
-
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if (weakSelf.isCancelled || weakSelf.error) return;
-
-            if (weakSelf.response) {
-                // Make extra sure that weird responses don't get written.
-                if (((NSHTTPURLResponse *)weakSelf.response).statusCode != 200) return;
-            }
-
-            // If it got this far, then a refresh was needed and has completed.
-            if (weakSelf.dataRetrieved) {
-                NSString *jsonString = [[NSString alloc] initWithData:weakSelf.dataRetrieved encoding:NSUTF8StringEncoding];
-                //NSLog(@"jsonString = %@", jsonString);
-                if (!jsonString || (jsonString.length == 0)) return;
-
-                if ([jsonString hasPrefix:@"/*\nInternal error\n*"]) return;
-                
-                NSString *filePath = assetsFile.path;
-                NSError *error = nil;
-                [jsonString writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:&error];
-                if (error) {
-                    NSLog(@"%@", error.localizedDescription);
-                }
-            }
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/UploadSectionWikiTextOp.h b/wikipedia/Data/Operations/UploadSectionWikiTextOp.h
deleted file mode 100644
index 4a52b96ce8a..00000000000
--- a/wikipedia/Data/Operations/UploadSectionWikiTextOp.h
+++ /dev/null
@@ -1,32 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-
-typedef enum {
-    WIKITEXT_UPLOAD_ERROR_UNKNOWN = 0,
-    WIKITEXT_UPLOAD_ERROR_SERVER = 1,
-    WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA = 2,
-    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED = 3,
-    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING = 4,
-    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER = 5
-} UploadSectionWikiTextOpErrors;
-
-@interface UploadSectionWikiTextOp : MWNetworkOp
-
-// Note: "section" parameter needs to be a string because the
-// api returns transcluded section indexes with a "T-" prefix
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-               section: (NSString *)section
-              wikiText: (NSString *)wikiText
-               summary: (NSString *)summary
-             captchaId: (NSString *)captchaId
-           captchaWord: (NSString *)captchaWord
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-;
-
-@end
diff --git a/wikipedia/Data/Operations/UploadSectionWikiTextOp.m b/wikipedia/Data/Operations/UploadSectionWikiTextOp.m
deleted file mode 100644
index 09b1e44eaaa..00000000000
--- a/wikipedia/Data/Operations/UploadSectionWikiTextOp.m
+++ /dev/null
@@ -1,153 +0,0 @@
-//  Created by Monte Hurd on 1/16/14.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "UploadSectionWikiTextOp.h"
-#import "WikipediaAppUtils.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "SessionSingleton.h"
-#import "NSURLRequest+DictionaryRequest.h"
-
-@implementation UploadSectionWikiTextOp
-
-- (id)initForPageTitle: (NSString *)title
-                domain: (NSString *)domain
-               section: (NSString *)section
-              wikiText: (NSString *)wikiText
-               summary: (NSString *)summary
-             captchaId: (NSString *)captchaId
-           captchaWord: (NSString *)captchaWord
-       completionBlock: (void (^)(NSDictionary *))completionBlock
-        cancelledBlock: (void (^)(NSError *))cancelledBlock
-            errorBlock: (void (^)(NSError *))errorBlock
-{
-    self = [super init];
-    if (self) {
-    
-        __weak UploadSectionWikiTextOp *weakSelf = self;
-        self.aboutToStart = ^{
-            [[MWNetworkActivityIndicatorManager sharedManager] push];
-            
-            NSMutableDictionary *editTokens = [SessionSingleton sharedInstance].keychainCredentials.editTokens;
-            NSString *editToken = editTokens[domain];
-            
-            if (!editToken) editToken  = @"+\\";
-            
-            NSMutableDictionary *parameters = [@{
-                                                 @"action": @"edit",
-                                                 @"token": editToken,
-                                                 @"text": wikiText,
-                                                 @"summary": summary,
-                                                 @"section": section,
-                                                 @"title": title,
-                                                 @"format": @"json"
-                                                 } mutableCopy];
-            
-            if (captchaWord) {
-                parameters[@"captchaid"] = captchaId;
-                parameters[@"captchaword"] = captchaWord;
-            }
-            
-            //NSLog(@"parameters = %@", parameters);
-            //weakSelf.request = [NSURLRequest postRequestWithURL: [NSURL URLWithString:@"127.0.0.1"] parameters: parameters];
-            //return;
-            
-            weakSelf.request = [NSURLRequest postRequestWithURL: [[SessionSingleton sharedInstance] urlForDomain:domain]
-                                                     parameters: parameters];
-        };
-        self.completionBlock = ^(){
-            [[MWNetworkActivityIndicatorManager sharedManager] pop];
-            
-            if(weakSelf.isCancelled){
-                cancelledBlock(weakSelf.error);
-                return;
-            }
-
-            //NSLog(@"%@", weakSelf.jsonRetrieved);
-            // Check for error retrieving section zero data.
-            if(weakSelf.jsonRetrieved[@"error"]){
-                NSMutableDictionary *errorDict = [weakSelf.jsonRetrieved[@"error"] mutableCopy];
-                
-                errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Upload Wikitext Op" code:WIKITEXT_UPLOAD_ERROR_SERVER userInfo:errorDict];
-            }
-         
-            NSDictionary *resultDict = weakSelf.jsonRetrieved[@"edit"];
-            NSString *result = resultDict[@"result"];
-
-            if (!weakSelf.error && !result) {
-                NSMutableDictionary *errorDict = [@{} mutableCopy];
-                errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"wikitext-upload-result-unknown", nil);
-                
-                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                weakSelf.error = [NSError errorWithDomain:@"Upload Wikitext Op" code:WIKITEXT_UPLOAD_ERROR_UNKNOWN userInfo:errorDict];
-            }
-
-            if (!weakSelf.error && result && [result isEqualToString:@"Failure"]) {
-            
-            
-                if(weakSelf.jsonRetrieved[@"edit"][@"captcha"]){
-                    NSMutableDictionary *errorDict = [@{} mutableCopy];
-                    
-                    errorDict[NSLocalizedDescriptionKey] = (captchaWord && (captchaWord.length > 0)) ?
-                    MWLocalizedString(@"wikitext-upload-captcha-error", nil)
-                    :
-                    MWLocalizedString(@"wikitext-upload-captcha-needed", nil)
-                    ;
-                    
-                    // Make the capcha id and url available from the error.
-                    errorDict[@"captchaId"] = weakSelf.jsonRetrieved[@"edit"][@"captcha"][@"id"];
-                    errorDict[@"captchaUrl"] = weakSelf.jsonRetrieved[@"edit"][@"captcha"][@"url"];
-                    
-                    // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                    weakSelf.error = [NSError errorWithDomain:@"Upload Wikitext Op" code:WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA userInfo:errorDict];
-                }else if(weakSelf.jsonRetrieved[@"edit"][@"code"]){
-
-                    NSString *abuseFilterCode = weakSelf.jsonRetrieved[@"edit"][@"code"];
-                    UploadSectionWikiTextOpErrors errorType = WIKITEXT_UPLOAD_ERROR_UNKNOWN;
-
-                    if([abuseFilterCode hasPrefix:@"abusefilter-warning"]){
-                        errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING;
-                    }else if([abuseFilterCode hasPrefix:@"abusefilter-disallowed"]){
-                        errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED;
-                    }else if([abuseFilterCode hasPrefix:@"abusefilter"]){
-                        errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER;
-                    }
-                    
-                    switch (errorType) {
-                        case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING:
-                        case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED:
-                        case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER:
-                            {
-                                NSMutableDictionary *errorDict = [@{} mutableCopy];
-                                
-                                errorDict[NSLocalizedDescriptionKey] = weakSelf.jsonRetrieved[@"edit"][@"info"];
-                                
-                                // Make the verbose warning available from the error.
-                                errorDict[@"warning"] = weakSelf.jsonRetrieved[@"edit"][@"warning"];
-                                errorDict[@"code"] = abuseFilterCode;
-                                
-                                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-                                weakSelf.error = [NSError errorWithDomain:@"Upload Wikitext Op" code:errorType userInfo:errorDict];
-                            }
-                            break;
-                            
-                        default:
-                            break;
-                    }
-                }
-            }
-            
-            if (weakSelf.error) {
-                errorBlock(weakSelf.error);
-                return;
-            }
-
-            completionBlock(resultDict);
-        };
-    }
-    return self;
-}
-
-@end
diff --git a/wikipedia/Data/Operations/LogEventOp.h b/wikipedia/EventLogging/EventLogger.h
similarity index 50%
rename from wikipedia/Data/Operations/LogEventOp.h
rename to wikipedia/EventLogging/EventLogger.h
index f910e6cd127..126cdf42785 100644
--- a/wikipedia/Data/Operations/LogEventOp.h
+++ b/wikipedia/EventLogging/EventLogger.h
@@ -1,16 +1,14 @@
 //  Created by Monte Hurd on 4/11/14.
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
-#import "MWNetworkOp.h"
-
-@interface LogEventOp : MWNetworkOp
+@interface EventLogger : NSObject
 
 /**
  * Most code should not call this directly -- use an EventLoggingFunnel subclass.
  */
-- (id)initWithSchema: (NSString *)schema
-            revision: (int)revision
-               event: (NSDictionary *)event
-                wiki: (NSString *)wiki;
+- (instancetype)initAndLogEvent: (NSDictionary *)event
+                      forSchema: (NSString *)schema
+                       revision: (int)revision
+                           wiki: (NSString *)wiki;
 
 @end
diff --git a/wikipedia/EventLogging/EventLogger.m b/wikipedia/EventLogging/EventLogger.m
new file mode 100644
index 00000000000..47346f6d59a
--- /dev/null
+++ b/wikipedia/EventLogging/EventLogger.m
@@ -0,0 +1,44 @@
+//  Created by Monte Hurd on 4/11/14.
+//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "EventLogger.h"
+#import "NSString+Extras.h"
+#import "WikipediaAppUtils.h"
+
+#define LOG_ENDPOINT @"https://bits.wikimedia.org/event.gif"
+//#define LOG_ENDPOINT @"http://localhost:8000/event.gif"
+
+@implementation EventLogger
+
+- (instancetype)initAndLogEvent: (NSDictionary *)event
+                      forSchema: (NSString *)schema
+                       revision: (int)revision
+                           wiki: (NSString *)wiki
+{
+    self = [super init];
+    if (self) {
+        
+        if (event && schema && wiki){
+            NSDictionary *payload =
+            @{
+              @"event"    : event,
+              @"revision" : @(revision),
+              @"schema"   : schema,
+              @"wiki"     : wiki
+              };
+            
+            NSData *payloadJsonData = [NSJSONSerialization dataWithJSONObject:payload options:0 error:nil];
+            NSString *payloadJsonString = [[NSString alloc] initWithData:payloadJsonData encoding:NSUTF8StringEncoding];
+            //NSLog(@"%@", payloadJsonString);
+            NSString *encodedPayloadJsonString = [payloadJsonString urlEncodedUTF8String];
+            NSString *urlString = [NSString stringWithFormat:@"%@?%@;", LOG_ENDPOINT, encodedPayloadJsonString];
+            NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:urlString]];
+            [request addValue:[WikipediaAppUtils versionedUserAgent] forHTTPHeaderField:@"User-Agent"];
+            
+            (void)[[NSURLConnection alloc] initWithRequest:request delegate:nil];
+        }
+    }
+    return self;
+}
+
+@end
diff --git a/wikipedia/EventLogging/EventLoggingFunnel.m b/wikipedia/EventLogging/EventLoggingFunnel.m
index 18c30a3d0f9..d4f2f8172d8 100644
--- a/wikipedia/EventLogging/EventLoggingFunnel.m
+++ b/wikipedia/EventLogging/EventLoggingFunnel.m
@@ -7,7 +7,7 @@
 //
 
 #import "EventLoggingFunnel.h"
-#import "LogEventOp.h"
+#import "EventLogger.h"
 #import "QueuesSingleton.h"
 #import "SessionSingleton.h"
 
@@ -37,12 +37,10 @@ -(void)log:(NSDictionary *)eventData
 -(void)log:(NSDictionary *)eventData forWiki:(NSString *)wiki
 {
     if ([SessionSingleton sharedInstance].sendUsageReports) {
-        LogEventOp *logOp = [[LogEventOp alloc] initWithSchema: self.schema
-                                                      revision: self.revision
-                                                         event: [self preprocessData:eventData]
-                                                          wiki: wiki];
-        
-        [[QueuesSingleton sharedInstance].eventLoggingQ addOperation:logOp];
+        (void)[[EventLogger alloc] initAndLogEvent:[self preprocessData:eventData]
+                                        forSchema: self.schema
+                                         revision: self.revision
+                                             wiki: wiki];
     }
 }
 
diff --git a/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.h b/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.h
new file mode 100644
index 00000000000..37e9f10eb45
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.h
@@ -0,0 +1,29 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, AccountCreationTokenErrorType) {
+    ACCOUNT_CREATION_TOKEN_ERROR_UNKNOWN = 0,
+    ACCOUNT_CREATION_TOKEN_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface AccountCreationTokenFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *domain;
+@property (strong, nonatomic, readonly) NSString *userName;
+@property (strong, nonatomic, readonly) NSString *password;
+@property (strong, nonatomic, readonly) NSString *email;
+@property (strong, nonatomic, readonly) NSString *token;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchTokenForDomain: (NSString *)domain
+                                 userName: (NSString *)userName
+                                 password: (NSString *)password
+                                    email: (NSString *)email
+                              withManager: (AFHTTPRequestOperationManager *)manager
+                       thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.m b/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.m
new file mode 100644
index 00000000000..35ef39d0937
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountCreationTokenFetcher.m
@@ -0,0 +1,126 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "AccountCreationTokenFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@interface AccountCreationTokenFetcher()
+
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *userName;
+@property (strong, nonatomic) NSString *password;
+@property (strong, nonatomic) NSString *email;
+@property (strong, nonatomic) NSString *token;
+
+@end
+
+@implementation AccountCreationTokenFetcher
+
+-(instancetype)initAndFetchTokenForDomain: (NSString *)domain
+                                 userName: (NSString *)userName
+                                 password: (NSString *)password
+                                    email: (NSString *)email
+                              withManager: (AFHTTPRequestOperationManager *)manager
+                       thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.domain = domain ? domain : @"";
+        self.userName = userName ? userName : @"";
+        self.password = password ? password : @"";
+        self.email = email ? email : @"";
+        self.token = @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self fetchTokenWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchTokenWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Token not found."}};
+        }
+        
+        //NSLog(@"ACCT CREATION TOKEN DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Acct Creation Token Fetcher"
+                                        code: ACCOUNT_CREATION_TOKEN_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+        
+        self.token = output[@"token"] ? output[@"token"] : @"";
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"ACCT CREATION TOKEN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    return @{
+             @"action": @"createaccount",
+             @"name": self.userName,
+             @"password": self.password,
+             @"language": ([self.domain isEqualToString:@"test"] ? @"en" : self.domain),
+             @"format": @"json"
+             }.mutableCopy;
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    if([rawResponse isDict]){
+        id createaccount = rawResponse[@"createaccount"];
+        if([createaccount isDict]){
+            NSString *token = createaccount[@"token"];
+            if (token) {
+                return @{@"token": token};
+            }
+        }
+    }
+    return @{};
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ACCT CREATION TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/AccountCreator.h b/wikipedia/Networking/Fetchers/AccountCreator.h
new file mode 100644
index 00000000000..6faa09aa5fa
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountCreator.h
@@ -0,0 +1,28 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, AccountCreationErrorType) {
+    ACCOUNT_CREATION_ERROR_UNKNOWN = 0,
+    ACCOUNT_CREATION_ERROR_API = 1,
+    ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA = 2
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface AccountCreator : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndCreateAccountForUserName: (NSString *)userName
+                                      realName: (NSString *)realName
+                                        domain: (NSString *)domain
+                                      password: (NSString *)password
+                                         email: (NSString *)email
+                                     captchaId: (NSString *)captchaId
+                                   captchaWord: (NSString *)captchaWord
+                                         token: (NSString *)token
+                                   withManager: (AFHTTPRequestOperationManager *)manager
+                            thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/AccountCreator.m b/wikipedia/Networking/Fetchers/AccountCreator.m
new file mode 100644
index 00000000000..1f8871a66af
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountCreator.m
@@ -0,0 +1,169 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "AccountCreator.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "WikipediaAppUtils.h"
+
+@interface AccountCreator()
+
+@property (strong, nonatomic) NSString *token;
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *userName;
+@property (strong, nonatomic) NSString *password;
+
+@property (strong, nonatomic) NSString *realName;
+@property (strong, nonatomic) NSString *email;
+@property (strong, nonatomic) NSString *captchaId;
+@property (strong, nonatomic) NSString *captchaWord;
+
+@end
+
+@implementation AccountCreator
+
+-(instancetype)initAndCreateAccountForUserName: (NSString *)userName
+                                      realName: (NSString *)realName
+                                        domain: (NSString *)domain
+                                      password: (NSString *)password
+                                         email: (NSString *)email
+                                     captchaId: (NSString *)captchaId
+                                   captchaWord: (NSString *)captchaWord
+                                         token: (NSString *)token
+                                   withManager: (AFHTTPRequestOperationManager *)manager
+                            thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.userName = userName ? userName : @"";
+        self.realName = realName ? realName : @"";
+        self.domain = domain ? domain : @"";
+        self.password = password ? password : @"";
+        self.email = email ? email : @"";
+        self.captchaId = captchaId ? captchaId : @"";
+        self.captchaWord = captchaWord ? captchaWord : @"";
+        self.token = token ? token : @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self creationAccountWithManager: manager];
+    }
+    return self;
+}
+
+- (void)creationAccountWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Account creation data not found."}};
+        }
+        
+        //NSLog(@"ACCT CREATION DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Acct Creation Fetcher"
+                                        code: ACCOUNT_CREATION_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSString *result = @"";
+        if (!error) {
+            result = [self getSanitizedResultFromResponse:responseObject];
+
+            if ([result isEqualToString:@"NeedCaptcha"]) {
+                NSMutableDictionary *errorDict = @{}.mutableCopy;
+                
+                if (responseObject[@"createaccount"][@"captcha"]) {
+                    errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"account-creation-captcha-required", nil);
+                    
+                    // Make the capcha id and url available from the error.
+                    errorDict[@"captchaId"] = responseObject[@"createaccount"][@"captcha"][@"id"];
+                    errorDict[@"captchaUrl"] = responseObject[@"createaccount"][@"captcha"][@"url"];
+                }
+                
+                error = [NSError errorWithDomain: @"Account Creation Fetcher"
+                                            code: ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA
+                                        userInfo: errorDict];
+            }
+
+        }
+
+        [self finishWithError: error
+                     userData: result];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"ACCT CREATION TOKEN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    NSMutableDictionary *params =
+    @{
+      @"action": @"createaccount",
+      @"name": self.userName,
+      @"password": self.password,
+      @"realname": self.realName,
+      @"email": self.email,
+      @"reason": ([self.domain isEqualToString:@"test"] ? @"iOS App Account Creation Testing" : @"iOS App Account Creation"),
+      @"language": ([self.domain isEqualToString:@"test"] ? @"en" : self.domain),
+      @"format": @"json"
+      }.mutableCopy;
+    
+    if (self.token && self.token.length > 0) {
+        params[@"token"] = self.token;
+    }
+    if (self.captchaId && self.captchaId.length > 0) {
+        params[@"captchaid"] = self.captchaId;
+    }
+    if (self.captchaWord && self.captchaWord.length > 0) {
+        params[@"captchaword"] = self.captchaWord;
+    }
+    
+    //NSLog(@"params = %@", params);
+    return params;
+}
+
+-(NSString *)getSanitizedResultFromResponse:(NSDictionary *)rawResponse
+{
+    if(![rawResponse isDict]) return @"";
+
+    id createaccount = rawResponse[@"createaccount"];
+
+    if(![createaccount isDict]) return @"";
+
+    NSString *result = createaccount[@"result"];
+    
+    return (result ? result : @"");
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING PAGE HISTORY FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/AccountLogin.h b/wikipedia/Networking/Fetchers/AccountLogin.h
new file mode 100644
index 00000000000..46fff69f9c3
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountLogin.h
@@ -0,0 +1,24 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, LoginErrorType) {
+    LOGIN_ERROR_UNKNOWN = 0,
+    LOGIN_ERROR_API = 1,
+    LOGIN_ERROR_MISC = 2
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface AccountLogin : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndLoginForDomain: (NSString *)domain
+                            userName: (NSString *)userName
+                            password: (NSString *)password
+                               token: (NSString *)token
+                         withManager: (AFHTTPRequestOperationManager *)manager
+                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/AccountLogin.m b/wikipedia/Networking/Fetchers/AccountLogin.m
new file mode 100644
index 00000000000..4d2790aeac5
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AccountLogin.m
@@ -0,0 +1,161 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "AccountLogin.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "WikipediaAppUtils.h"
+
+@interface AccountLogin()
+
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *userName;
+@property (strong, nonatomic) NSString *password;
+@property (strong, nonatomic) NSString *token;
+
+@end
+
+@implementation AccountLogin
+
+-(instancetype)initAndLoginForDomain: (NSString *)domain
+                            userName: (NSString *)userName
+                            password: (NSString *)password
+                               token: (NSString *)token
+                         withManager: (AFHTTPRequestOperationManager *)manager
+                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.domain = domain ? domain : @"";
+        self.userName = userName ? userName : @"";
+        self.password = password ? password : @"";
+        self.token = token ? token : @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self loginWithManager:manager];
+    }
+    return self;
+}
+
+- (void)loginWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Account login info not found."}};
+        }
+        
+        //NSLog(@"LOGIN DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Account Login"
+                                        code: LOGIN_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        NSString *result = output[@"login"][@"result"];
+        if (![result isEqualToString:@"Success"]) {
+            NSMutableDictionary *errorDict = @{}.mutableCopy;
+            NSString *errorMessage = [self getErrorMessageForResult:result];
+            errorDict[NSLocalizedDescriptionKey] = errorMessage;
+            error = [NSError errorWithDomain:@"Account Login" code:LOGIN_ERROR_MISC userInfo:errorDict];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"LOGIN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    NSMutableDictionary *params =
+    @{
+      @"action": @"login",
+      @"lgname": self.userName,
+      @"lgpassword": self.password,
+      @"format": @"json"
+      }.mutableCopy;
+    
+    if (self.token) {
+        params[@"lgtoken"] = self.token;
+    }
+    
+    return params;
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSMutableDictionary *mutableResponse = [NSMutableDictionary dictionaryWithDictionary:rawResponse];
+    // Return the password with the results so it can be added to keychain.
+    mutableResponse[@"password"] = self.password;
+    return mutableResponse;
+}
+
+-(NSString *)getErrorMessageForResult:(NSString *)result
+{
+    // Error types from: http://www.mediawiki.org/wiki/API:Login#Errors
+    NSString *errorMessage = [NSString stringWithFormat:@"Unknown login error. Code '%@'", result];
+
+    if ([result isEqualToString:@"NoName"]) {
+        errorMessage = MWLocalizedString(@"login-name-not-found", nil);
+
+    }else if ([result isEqualToString:@"Illegal"]) {
+        errorMessage = MWLocalizedString(@"login-name-illegal", nil);
+
+    }else if ([result isEqualToString:@"NotExists"]) {
+        errorMessage = MWLocalizedString(@"login-name-does-not-exist", nil);
+
+    }else if ([result isEqualToString:@"EmptyPass"]) {
+        errorMessage = MWLocalizedString(@"login-password-empty", nil);
+
+    }else if ([result isEqualToString:@"WrongPass"] || [result isEqualToString:@"WrongPluginPass"]) {
+        errorMessage = MWLocalizedString(@"login-password-wrong", nil);
+
+    }else if ([result isEqualToString:@"Throttled"]) {
+        errorMessage = MWLocalizedString(@"login-throttled", nil);
+
+    }else if ([result isEqualToString:@"Blocked"]) {
+        errorMessage = MWLocalizedString(@"login-user-blocked", nil);
+    }
+    
+    return errorMessage;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ACCOUNT LOGIN!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/ArticleFetcher.h b/wikipedia/Networking/Fetchers/ArticleFetcher.h
new file mode 100644
index 00000000000..be9a3b15725
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/ArticleFetcher.h
@@ -0,0 +1,23 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, ArticleSectionType) {
+    ARTICLE_SECTION_TYPE_LEAD,
+    ARTICLE_SECTION_TYPE_NON_LEAD
+};
+
+@class Article, AFHTTPRequestOperationManager;
+
+@interface ArticleFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) Article *article;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchSectionsForArticle: (Article *)article
+                                  withManager: (AFHTTPRequestOperationManager *)manager
+                           thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate;
+
+@end
diff --git a/wikipedia/Networking/Fetchers/ArticleFetcher.m b/wikipedia/Networking/Fetchers/ArticleFetcher.m
new file mode 100644
index 00000000000..89ece326501
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/ArticleFetcher.m
@@ -0,0 +1,365 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "ArticleFetcher.h"
+#import "Article.h"
+#import "Section.h"
+#import "QueuesSingleton.h"
+#import "ArticleDataContextSingleton.h"
+#import "ArticleCoreDataObjects.h"
+#import "MWPageTitle.h"
+#import "Section+ImageRecords.h"
+#import "Section+LeadSection.h"
+#import "NSString+Extras.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "SessionSingleton.h"
+#import "ReadingActionFunnel.h"
+#import "NSString+Extras.h"
+#import "NSObject+Extras.h"
+#import "MWNetworkActivityIndicatorManager.h"
+
+@interface ArticleFetcher()
+
+// The Article object to be updated with the downloaded data.
+@property (nonatomic, strong) Article *article;
+
+@end
+
+@implementation ArticleFetcher
+
+-(instancetype)initAndFetchSectionsForArticle: (Article *)article
+                                  withManager: (AFHTTPRequestOperationManager *)manager
+                           thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate
+{
+    self = [super init];
+    if (self) {
+        self.article = article;
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+-(void)fetchWithManager:(AFHTTPRequestOperationManager *)manager
+{
+    NSString *title = self.article.title;
+    NSString *domain = self.article.domain;
+    
+    if (!self.article) {
+        NSLog(@"NO ARTICLE DELEGATE");
+        return;
+    }
+    if (!self.fetchFinishedDelegate) {
+        NSLog(@"NO DOWNLOAD DELEGATE");
+        return;
+    }
+    if(!domain){
+        NSLog(@"NO DOMAIN");
+        return;
+    }
+    if(!title){
+        NSLog(@"NO TITLE");
+        return;
+    }
+
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:domain];
+    
+    void (^getNonLeadSections)() = ^void() {
+        // Get the remaining sections data.
+        NSDictionary *params = [self getParamsForTitle:title leadSectionOnly:NO];
+        
+        [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+        [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+            [[MWNetworkActivityIndicatorManager sharedManager] pop];
+            //NSLog(@"JSON: %@", responseObject);
+            
+            NSDictionary *nonLeadSectionsResults = [self prepareResultsFromResponse:responseObject forTitle:title];
+            
+            [self applyResultsForNonLeadSections:nonLeadSectionsResults];
+
+            [self finishWithError: nil
+                         userData: @(ARTICLE_SECTION_TYPE_NON_LEAD)];
+            
+        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+            [[MWNetworkActivityIndicatorManager sharedManager] pop];
+            NSLog(@"Error: %@", error);
+
+            [self finishWithError: error
+                         userData: @(ARTICLE_SECTION_TYPE_NON_LEAD)];
+
+        }];
+    };
+    
+    
+    // First retrieve lead section data, then get the remaining sections data.
+
+    NSDictionary *params = [self getParamsForTitle:title leadSectionOnly:YES];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        NSDictionary *leadSectionResults = [self prepareResultsFromResponse:responseObject forTitle:title];
+        
+        [self applyResultsForLeadSection:leadSectionResults];
+
+        [self finishWithError: nil
+                     userData: @(ARTICLE_SECTION_TYPE_LEAD)];
+        
+
+        // Now that lead section data has been retrieved, get the remaining sections data.
+        getNonLeadSections();
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+        NSLog(@"Error: %@", error);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: @(ARTICLE_SECTION_TYPE_LEAD)];
+
+    }];
+}
+
+-(NSDictionary *)getParamsForTitle:(NSString *)title leadSectionOnly:(BOOL)leadSectionOnly
+{
+    NSMutableDictionary *params = @{
+    @"format": @"json",
+    @"action": @"mobileview",
+    @"sectionprop": @"toclevel|line|anchor|level|number|fromtitle|index",
+    @"noheadings": @"true",
+    @"page": title,
+    @"prop": @"sections|text|lastmodified|lastmodifiedby|languagecount|id|protection|editable|displaytitle",
+    }.mutableCopy;
+
+    if (!leadSectionOnly) {
+        params[@"onlyrequestedsections"] = @"1";
+        params[@"sections"] = @"1-";
+    }else{
+
+        //Reminder: do not set @"onlyrequestedsections": @"1" for lead section.
+        //Need to see keys for the subsequent sections so the "needsRefresh"
+        //value can be left YES until subsequent sections have been retrieved
+        //(if there's more than a single section).
+
+        params[@"sections"] = @"0";
+        
+        if ([SessionSingleton sharedInstance].sendUsageReports) {
+            ReadingActionFunnel *funnel = [[ReadingActionFunnel alloc] init];
+            params[@"appInstallID"] = funnel.appInstallID;
+        }
+    }
+    return params;
+}
+
+-(NSDictionary *)prepareResultsFromResponse:(NSDictionary *)response forTitle:(NSString *)title
+{
+    // Returns results dictionary with sanitized info from response.
+    
+    NSArray *sections = response[@"mobileview"][@"sections"];
+    
+    NSMutableArray *outputSections = @[].mutableCopy;
+    
+    // The fromtitle tells us if a section was transcluded, but the api sometimes returns false instead
+    // of just leaving it out if the section wasn't transcluded. It is also sometimes the name of the
+    // current article, which is redundant. So here remove the fromtitle key/value in both of these
+    // cases. That way the existense of a "fromtitle" can be relied on as a true transclusion indicator.
+    // Todo: pull this out into own method within this file.
+    for (NSDictionary *section in sections) {
+        NSMutableDictionary *mutableSection = section.mutableCopy;
+        if ([mutableSection[@"fromtitle"] isKindOfClass:[NSString class]]) {
+            NSString *fromTitle = mutableSection[@"fromtitle"];
+            if ([[title wikiTitleWithoutUnderscores] isEqualToString:[fromTitle wikiTitleWithoutUnderscores]]) {
+                [mutableSection removeObjectForKey:@"fromtitle"];
+            }
+        }else{
+            [mutableSection removeObjectForKey:@"fromtitle"];
+        }
+        [outputSections addObject:mutableSection];
+    }
+    
+    NSString *lastmodifiedDateString = response[@"mobileview"][@"lastmodified"];
+    NSDate *lastmodifiedDate = [lastmodifiedDateString getDateFromIso8601DateString];
+    if (!lastmodifiedDate || [lastmodifiedDate isNull]) {
+        NSLog(@"Bad lastmodified date, will show as recently modified as a workaround");
+        lastmodifiedDate = [[NSDate alloc] init];
+    }
+    
+    NSDictionary *lastmodifiedbyDict = response[@"mobileview"][@"lastmodifiedby"];
+    NSString *lastmodifiedby = @"";
+    if (lastmodifiedbyDict && (![lastmodifiedbyDict isNull]) && lastmodifiedbyDict[@"name"]) {
+        lastmodifiedby = lastmodifiedbyDict[@"name"];
+    }
+    if (!lastmodifiedby || [lastmodifiedby isNull]) lastmodifiedby = @"";
+    
+    NSNumber *languagecount = response[@"mobileview"][@"languagecount"];
+    if (!languagecount || [languagecount isNull]) languagecount = @1;
+    
+    NSString *redirected = response[@"mobileview"][@"redirected"];
+    if (!redirected || [redirected isNull]) redirected = @"";
+    
+    NSNumber *articleId = response[@"mobileview"][@"id"];
+    if (!articleId || [articleId isNull]) articleId = @0;
+    
+    NSNumber *editable = response[@"mobileview"][@"editable"];
+    if (!editable || [editable isNull]) editable = @NO;
+
+    NSString *displaytitle = response[@"mobileview"][@"displaytitle"];
+    if (!displaytitle || [displaytitle isNull]) displaytitle = @"";
+    
+    NSString *protectionStatus = @"";
+    id protection = response[@"mobileview"][@"protection"];
+    // if empty this can be an array instead of an object/dict!
+    // https://bugzilla.wikimedia.org/show_bug.cgi?id=67054
+    if (protection && [protection isKindOfClass:[NSDictionary class]]) {
+        NSDictionary *protectionDict = (NSDictionary *)protection;
+        if (protectionDict[@"edit"] && [protection[@"edit"] count] > 0) {
+            protectionStatus = protectionDict[@"edit"][0];
+        }
+    }
+    if (!protectionStatus || [protectionStatus isNull]) protectionStatus = @"";
+    
+    NSMutableDictionary *output = @{
+                                    @"sections": outputSections,
+                                    @"lastmodified": lastmodifiedDate,
+                                    @"lastmodifiedby": lastmodifiedby,
+                                    @"redirected": redirected,
+                                    @"displaytitle": displaytitle,
+                                    @"languagecount": languagecount,
+                                    @"articleId": articleId,
+                                    @"editable": editable,
+                                    @"protectionStatus": protectionStatus
+                                    }.mutableCopy;
+    
+    return output;
+}
+
+-(void)applyResultsForLeadSection:(NSDictionary *)results
+{
+    // Updates the article with the lead section data which was retrieved.
+    
+    [self.article.managedObjectContext performBlockAndWait:^(){
+        
+        // If "needsRefresh", an existing article's data is being retrieved again, so these need
+        // to be updated whether a new article record is being inserted or not as data may have
+        // changed since the article record was first created.
+        self.article.languagecount = results[@"languagecount"];
+        self.article.lastmodified = results[@"lastmodified"];
+        self.article.lastmodifiedby = results[@"lastmodifiedby"];
+        self.article.articleId = results[@"articleId"];
+        self.article.editable = results[@"editable"];
+        self.article.protectionStatus = results[@"protectionStatus"];
+        self.article.displayTitle = results[@"displaytitle"];
+        
+        // Note: Because "retrieveArticleForPageTitle" recurses with the redirected-to title if
+        // the lead section op determines a redirect occurred, the "redirected" value below will
+        // probably never be set.
+        self.article.redirected = results[@"redirected"];
+        
+        //NSDateFormatter *anotherDateFormatter = [[NSDateFormatter alloc] init];
+        //[anotherDateFormatter setDateStyle:NSDateFormatterLongStyle];
+        //[anotherDateFormatter setTimeStyle:NSDateFormatterShortStyle];
+        //NSLog(@"formatted lastmodified = %@", [anotherDateFormatter stringFromDate:self.article.lastmodified]);
+        
+        self.article.lastScrollX = @0.0f;
+        self.article.lastScrollY = @0.0f;
+        
+        // Get article section zero html
+        NSArray *sectionsRetrieved = results[@"sections"];
+        NSDictionary *section0Dict = (sectionsRetrieved.count >= 1) ? sectionsRetrieved[0] : nil;
+        
+        // If there was only one section then we have what we need so no refresh
+        // is needed. Otherwise leave needsRefresh set to YES until subsequent sections
+        // have been retrieved. Reminder: "onlyrequestedsections" is not used
+        // by the mobileview query so that sectionsRetrieved.count will
+        // reflect the article's total number of sections here ("sections"
+        // was set to "0" though so only the first section entry actually has
+        // any html). This fixes the bug which caused subsequent sections to never
+        // be retrieved if the article was navigated away from before they had loaded.
+        self.article.needsRefresh = (sectionsRetrieved.count == 1) ? @NO : @YES;
+        
+        NSString *section0HTML = @"";
+        if (section0Dict && [section0Dict[@"id"] isEqual: @0] && section0Dict[@"text"]) {
+            section0HTML = section0Dict[@"text"];
+        }
+        
+        // Add sections for article
+        Section *section0 = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:self.article.managedObjectContext];
+        // Section index is a string because transclusion sections indexes will start with "T-"
+        section0.index = @"0";
+        section0.level = @"0";
+        section0.number = @"0";
+        section0.sectionId = @0;
+        section0.title = @"";
+        section0.dateRetrieved = [NSDate date];
+        section0.html = section0HTML;
+        section0.anchor = @"";
+        
+        [self.article addSectionObject:section0];
+        
+        [section0 createImageRecordsForHtmlOnContext:self.article.managedObjectContext];
+    }];
+}
+
+-(void)applyResultsForNonLeadSections:(NSDictionary *)results
+{
+    // Updates the article with the non-lead section data which was retrieved.
+    
+    [self.article.managedObjectContext performBlockAndWait:^(){
+        
+        //Non-lead sections have been retreived so set needsRefresh to NO.
+        self.article.needsRefresh = @NO;
+        
+        NSArray *sectionsRetrieved = results[@"sections"];
+        
+        for (NSDictionary *section in sectionsRetrieved) {
+            if (![section[@"id"] isEqual: @0]) {
+                
+                // Add sections for article
+                Section *thisSection = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:self.article.managedObjectContext];
+                
+                // Section index is a string because transclusion sections indexes will start with "T-".
+                if ([section[@"index"] isKindOfClass:[NSString class]]) {
+                    thisSection.index = section[@"index"];
+                }
+                
+                thisSection.title = section[@"line"];
+                
+                if ([section[@"level"] isKindOfClass:[NSString class]]) {
+                    thisSection.level = section[@"level"];
+                }
+                
+                // Section number, from the api, can be 3.5.2 etc, so it's a string.
+                if ([section[@"number"] isKindOfClass:[NSString class]]) {
+                    thisSection.number = section[@"number"];
+                }
+                
+                if (section[@"fromtitle"]) {
+                    thisSection.fromTitle = section[@"fromtitle"];
+                }
+                
+                thisSection.sectionId = section[@"id"];
+                
+                thisSection.html = section[@"text"];
+                thisSection.tocLevel = section[@"toclevel"];
+                thisSection.dateRetrieved = [NSDate date];
+                thisSection.anchor = (section[@"anchor"]) ? section[@"anchor"] : @"";
+                
+                [self.article addSectionObject:thisSection];
+                
+                [thisSection createImageRecordsForHtmlOnContext:self.article.managedObjectContext];
+            }
+        }
+    }];
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ARTICLE FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/AssetsFileFetcher.h b/wikipedia/Networking/Fetchers/AssetsFileFetcher.h
new file mode 100644
index 00000000000..82265254ed2
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AssetsFileFetcher.h
@@ -0,0 +1,23 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+#import "AssetsFileEnum.h"
+
+@class AFHTTPRequestOperationManager;
+
+@interface AssetsFileFetcher : FetcherBase
+
+// Syncs a "/AppData/Documents/assets/" file with a remote file.
+// Only does so if age of app file exceeds maxAge or if the file isn't
+// found in app. Nice because we can sync assets files with any periodicity
+// required just by firing these fetches off occasionally. Self-cancels
+// if maxAge has not been exceeded.
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchAssetsFile: (AssetsFileEnum)file
+                          withManager: (AFHTTPRequestOperationManager *)manager
+                               maxAge: (CGFloat)maxAge;
+
+@end
diff --git a/wikipedia/Networking/Fetchers/AssetsFileFetcher.m b/wikipedia/Networking/Fetchers/AssetsFileFetcher.m
new file mode 100644
index 00000000000..393b1ecef6e
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/AssetsFileFetcher.m
@@ -0,0 +1,80 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "AssetsFileFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "QueuesSingleton.h"
+#import "AssetsFile.h"
+
+@implementation AssetsFileFetcher
+
+-(instancetype)initAndFetchAssetsFile: (AssetsFileEnum)file
+                          withManager: (AFHTTPRequestOperationManager *)manager
+                               maxAge: (CGFloat)maxAge
+{
+    self = [super init];
+    if (self) {
+        self.fetchFinishedDelegate = nil;
+        [self fetchAssetsFile: file
+                       maxAge: maxAge
+                  withManager: manager];
+    }
+    return self;
+}
+
+-(void)fetchAssetsFile: (AssetsFileEnum)file
+                maxAge: (CGFloat)maxAge
+           withManager: (AFHTTPRequestOperationManager *)manager;
+{
+    AssetsFile *assetsFile = [[AssetsFile alloc] initWithFile:file];
+
+    // Cancel the operation if the existing file hasn't aged enough.
+    BOOL shouldRefresh = [assetsFile isOlderThan:maxAge];
+
+    if (!shouldRefresh) return;
+    
+    NSURL *url = assetsFile.url;
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+    
+    [manager GET:url.absoluteString parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        if (operation.response.statusCode != 200) return;
+        
+        //NSString *className = NSStringFromClass ([responseObject class]);
+        //NSLog(@"className = %@", className);
+        //NSLog(@"mimeType = %@", operation.response.MIMEType);
+
+        if (![self isDataResponseValid:responseObject]) return;
+
+        NSString *responseString = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding];
+        
+        if ([responseString hasPrefix:@"/*\nInternal error\n*"]) return;
+        
+        NSError *error = nil;
+        
+        [responseString writeToFile: assetsFile.path
+                         atomically: YES
+                           encoding: NSUTF8StringEncoding
+                              error: &error];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+        NSLog(@"Error: %@", error);
+        //NSLog(@"Error URL: %@", operation.request.URL);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+    }];
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ASSETS FILE FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.h b/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.h
new file mode 100644
index 00000000000..b24f80cd1a7
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.h
@@ -0,0 +1,50 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+
+
+// Enums for the FetchFinishedDelegate protocol method.
+typedef NS_ENUM(NSInteger, FetchFinalStatus) {
+    FETCH_FINAL_STATUS_SUCCEEDED,
+    FETCH_FINAL_STATUS_CANCELLED,
+    FETCH_FINAL_STATUS_FAILED
+};
+
+
+// Protocol for notifying fetchFinishedDelegate that download has completed.
+@protocol FetchFinishedDelegate <NSObject>
+
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error;
+
+@end
+
+
+@interface FetcherBase : NSObject
+
+
+// Object to receive "fetchFinished:" notifications.
+@property (nonatomic, weak) id <FetchFinishedDelegate> fetchFinishedDelegate;
+
+
+
+// Method for sub-classes of FetcherBase to call to cause the fetchFinishedDelegate
+// to be notified via "fetchFinished:" that the fetch is finished.
+
+// Note: FetchFinalStatus is not explicitly passed to this method - it determines
+// the status base on introspection of error.
+- (void)finishWithError: (NSError *)error
+               userData: (id)userData;
+
+
+
+// For some fetchers we need raw NSData responses. (Their managers will
+// have their responseSerializers overridden with "[AFHTTPResponseSerializer serializer]".)
+// This is a quick way to check if the raw data response is potentially valid / contains
+// anything useful.
+-(BOOL)isDataResponseValid:(id)responseObject;
+
+@end
diff --git a/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.m b/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.m
new file mode 100644
index 00000000000..c89412b325a
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/BaseFetcher/FetcherBase.m
@@ -0,0 +1,69 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "FetcherBase.h"
+#import "SessionSingleton.h"
+
+@implementation FetcherBase
+
+- (void)finishWithError: (NSError *)error
+               userData: (id)userData
+{
+    [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
+    
+        [self setConnectionManagementFallbackForError:error];
+        //TODO: this could also be a good place to log error.domain string and error.code?
+    
+        [self.fetchFinishedDelegate fetchFinished: self
+                                         userData: userData
+                                           status: [self getStatusFromError:error]
+                                            error: error];
+    }];
+}
+
+-(FetchFinalStatus)getStatusFromError:(NSError *) error
+{
+    // Examine error to see what status should be used.
+    // Nice as it eliminates lots of repeated code.
+    FetchFinalStatus status = FETCH_FINAL_STATUS_SUCCEEDED;
+    if (error) {
+        status = FETCH_FINAL_STATUS_FAILED;
+        if ([error.domain isEqualToString:NSURLErrorDomain]) {
+            if (error.code == NSURLErrorCancelled) {
+                status = FETCH_FINAL_STATUS_CANCELLED;
+            }
+        }
+    }
+    return status;
+}
+
+-(void)setConnectionManagementFallbackForError:(NSError *)error
+{
+    if (error.domain == NSStreamSocketSSLErrorDomain ||
+        (error.domain == NSURLErrorDomain &&
+         (error.code == NSURLErrorSecureConnectionFailed ||
+          error.code == NSURLErrorServerCertificateHasBadDate ||
+          error.code == NSURLErrorServerCertificateUntrusted ||
+          error.code == NSURLErrorServerCertificateHasUnknownRoot ||
+          error.code == NSURLErrorServerCertificateNotYetValid)
+          //error.code == NSURLErrorCannotLoadFromNetwork) //TODO: check this out later?
+         )
+        ) {
+        [SessionSingleton sharedInstance].fallback = true;
+    }
+}
+
+-(BOOL)isDataResponseValid:(id)responseObject
+{
+    return !(
+             !responseObject
+             ||
+             ![responseObject isKindOfClass:[NSData class]]
+             ||
+             ([responseObject length] == 0)
+             ||
+             ([responseObject length] == 2) // Protect against query returning "[]".
+             );
+}
+
+@end
diff --git a/wikipedia/Networking/Fetchers/CaptchaResetter.h b/wikipedia/Networking/Fetchers/CaptchaResetter.h
new file mode 100644
index 00000000000..e9560391089
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/CaptchaResetter.h
@@ -0,0 +1,20 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, CaptchaResetterErrorType) {
+    CAPTCHA_RESET_ERROR_UNKNOWN = 0,
+    CAPTCHA_RESET_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface CaptchaResetter : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndResetCaptchaForDomain: (NSString *)domain
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/CaptchaResetter.m b/wikipedia/Networking/Fetchers/CaptchaResetter.m
new file mode 100644
index 00000000000..c342ffa5bd7
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/CaptchaResetter.m
@@ -0,0 +1,103 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "CaptchaResetter.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@interface CaptchaResetter()
+
+@property (strong, nonatomic) NSString *domain;
+
+@end
+
+@implementation CaptchaResetter
+
+-(instancetype)initAndResetCaptchaForDomain: (NSString *)domain
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+        self.domain = domain ? domain : @"";
+        self.fetchFinishedDelegate = delegate;
+        [self resetCaptchaWithManager:manager];
+    }
+    return self;
+}
+
+- (void)resetCaptchaWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Captcha Resetter data not found."}};
+        }
+        
+        //NSLog(@"CAPTCHA RESETTER DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Captcha Resetter"
+                                        code: CAPTCHA_RESET_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"CAPTCHA RESETTER FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    return @{
+             @"action": @"fancycaptchareload",
+             @"format": @"json"
+             };
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSDictionary *response = @{};
+    if([rawResponse isDict]){
+        response = rawResponse[@"fancycaptchareload"];
+    }
+    return response;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ACCT CREATION TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/EditTokenFetcher.h b/wikipedia/Networking/Fetchers/EditTokenFetcher.h
new file mode 100644
index 00000000000..7615d79d7e7
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/EditTokenFetcher.h
@@ -0,0 +1,42 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, EditTokenErrorType) {
+    EDIT_TOKEN_ERROR_UNKNOWN = 0,
+    EDIT_TOKEN_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface EditTokenFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *wikiText;
+@property (strong, nonatomic, readonly) NSString *title;
+@property (strong, nonatomic, readonly) NSString *domain;
+@property (strong, nonatomic, readonly) NSString *section;
+@property (strong, nonatomic, readonly) NSString *summary;
+@property (strong, nonatomic, readonly) NSString *captchaId;
+@property (strong, nonatomic, readonly) NSString *captchaWord;
+@property (strong, nonatomic, readonly) NSManagedObjectID *articleID;
+@property (strong, nonatomic, readonly) NSString *token;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+
+// Only the domain is used to actually fetch the token, the other values are
+// parked here so the actual uploader can have quick read-only access to the
+// exact params which kicked off the token request.
+-(instancetype)initAndFetchEditTokenForWikiText: (NSString *)wikiText
+                                      pageTitle: (NSString *)title
+                                         domain: (NSString *)domain
+                                        section: (NSString *)section
+                                        summary: (NSString *)summary
+                                      captchaId: (NSString *)captchaId
+                                    captchaWord: (NSString *)captchaWord
+                                      articleID: (NSManagedObjectID *)articleID
+                                    withManager: (AFHTTPRequestOperationManager *)manager
+                             thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+
+@end
diff --git a/wikipedia/Networking/Fetchers/EditTokenFetcher.m b/wikipedia/Networking/Fetchers/EditTokenFetcher.m
new file mode 100644
index 00000000000..44d975ef93e
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/EditTokenFetcher.m
@@ -0,0 +1,140 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "EditTokenFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@interface EditTokenFetcher()
+
+@property (strong, nonatomic) NSString *wikiText;
+@property (strong, nonatomic) NSString *title;
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *section;
+@property (strong, nonatomic) NSString *summary;
+@property (strong, nonatomic) NSString *captchaId;
+@property (strong, nonatomic) NSString *captchaWord;
+@property (strong, nonatomic) NSManagedObjectID *articleID;
+@property (strong, nonatomic) NSString *token;
+
+@end
+
+@implementation EditTokenFetcher
+
+-(instancetype)initAndFetchEditTokenForWikiText: (NSString *)wikiText
+                                      pageTitle: (NSString *)title
+                                         domain: (NSString *)domain
+                                        section: (NSString *)section
+                                        summary: (NSString *)summary
+                                      captchaId: (NSString *)captchaId
+                                    captchaWord: (NSString *)captchaWord
+                                      articleID: (NSManagedObjectID *)articleID
+                                    withManager: (AFHTTPRequestOperationManager *)manager
+                             thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.wikiText = wikiText ? wikiText : @"";
+        self.title = title ? title : @"";
+        self.domain = domain ? domain : @"";
+        self.section = section ? section : @"";
+        self.summary = summary ? summary : @"";
+        self.captchaId = captchaId ? captchaId : @"";
+        self.captchaWord = captchaWord ? captchaWord : @"";
+        self.articleID = articleID;
+        self.token = @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self fetchTokenWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchTokenWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Edit token not found."}};
+        }
+        
+        //NSLog(@"EDIT TOKEN DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Edit Token Fetcher"
+                                        code: EDIT_TOKEN_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        self.token = output[@"token"] ? output[@"token"] : @"";
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"EDIT TOKEN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    return @{
+             @"action": @"query",
+             @"meta": @"tokens",
+             @"format": @"json"
+             }.mutableCopy;
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    if([rawResponse isDict]){
+        id query = rawResponse[@"query"];
+        if([query isDict]){
+            id tokens = query[@"tokens"];
+            if([tokens isDict]){
+                NSString *token = tokens[@"csrftoken"];
+                if (token) {
+                    return @{@"token": token};
+                }
+            }
+        }
+    }
+    
+    return @{};
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING EDIT TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/LanguageLinksFetcher.h b/wikipedia/Networking/Fetchers/LanguageLinksFetcher.h
new file mode 100644
index 00000000000..ad9278ac638
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/LanguageLinksFetcher.h
@@ -0,0 +1,26 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, LanguageLinksFetchErrorType) {
+    LANGUAGE_LINKS_FETCH_ERROR_UNKNOWN = 0,
+    LANGUAGE_LINKS_FETCH_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface LanguageLinksFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *title;
+@property (strong, nonatomic, readonly) NSString *domain;
+@property (strong, nonatomic, readonly) NSArray *allLanguages;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchLanguageLinksForPageTitle: (NSString *)title
+                                              domain: (NSString *)domain
+                                        allLanguages: (NSArray *)allLanguages
+                                         withManager: (AFHTTPRequestOperationManager *)manager
+                                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/LanguageLinksFetcher.m b/wikipedia/Networking/Fetchers/LanguageLinksFetcher.m
new file mode 100644
index 00000000000..a1067bfc9e8
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/LanguageLinksFetcher.m
@@ -0,0 +1,159 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "LanguageLinksFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "Defines.h"
+#import "WikipediaAppUtils.h"
+
+@interface LanguageLinksFetcher()
+
+@property (strong, nonatomic) NSString *title;
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSArray *allLanguages;
+
+@end
+
+@implementation LanguageLinksFetcher
+
+-(instancetype)initAndFetchLanguageLinksForPageTitle: (NSString *)title
+                                              domain: (NSString *)domain
+                                        allLanguages: (NSArray *)allLanguages
+                                         withManager: (AFHTTPRequestOperationManager *)manager
+                                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.title = title ? title : @"";
+        self.domain = domain ? domain : @"";
+        self.allLanguages = allLanguages;
+
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Language links not found."}};
+        }
+
+        //NSLog(@"LANGUAGE LINKS RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Language Links Fetcher"
+                                        code: LANGUAGE_LINKS_FETCH_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSMutableArray *output = @[].mutableCopy;
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"LANGUAGE LINKS FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    return @{
+             @"action": @"query",
+             @"prop": @"langlinks",
+             @"titles": self.title,
+             @"lllimit": @"500",
+             @"redirects": @"",
+             @"format": @"json"
+             };
+}
+
+-(NSMutableArray *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSArray *langLinks = @[];
+    NSDictionary *pages = rawResponse[@"query"][@"pages"];
+    if (pages) {
+        NSDictionary *page = pages[pages.allKeys[0]];
+        if (page) {
+            langLinks = page[@"langlinks"];
+        }
+    }
+    
+    // Get dictionary with lang code as key and the localized title as the value
+    NSMutableDictionary *langCodeToLocalTitleDict = @{}.mutableCopy;
+    for (NSDictionary *d in langLinks) {
+        NSString *lang = d[@"lang"];
+        NSString *title = d[@"*"];
+        if (lang && title) {
+            langCodeToLocalTitleDict[lang] = title;
+        }
+    }
+    
+    // Loop through the data from the languages file and add an entry to the
+    // output array for each match found in langCodeToLocalTitleDict including
+    // all of the keys from the lang file and the local title from the downloaded
+    // results. The end results is an array containing dictionaries containing
+    // the lang code, lang name, lang canonical name, and the localized title.
+    // (Also, the output array's lang codes will be ordered the same as they are
+    // in the lang file.)
+    NSMutableArray *outputArray = @[].mutableCopy;
+    for (NSDictionary *fileDict in self.allLanguages) {
+        NSString *code = fileDict[@"code"];
+        if (code && [langCodeToLocalTitleDict objectForKey:code]) {
+            
+            if ([[SessionSingleton sharedInstance].unsupportedCharactersLanguageIds indexOfObject:code] != NSNotFound) continue;
+            
+            NSString *canonicalName = fileDict[@"canonical_name"];
+            NSString *name = fileDict[@"name"];
+            
+            if (canonicalName && name) {
+                [outputArray addObject:@{
+                                         @"code": code,
+                                         @"canonical_name": canonicalName,
+                                         @"name": name,
+                                         @"*": langCodeToLocalTitleDict[code],
+                                         }];
+            }
+        }
+    }
+    return outputArray;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING LANGUAGE LINKS FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/LoginTokenFetcher.h b/wikipedia/Networking/Fetchers/LoginTokenFetcher.h
new file mode 100644
index 00000000000..41ff6ee1710
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/LoginTokenFetcher.h
@@ -0,0 +1,27 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, LoginTokenErrorType) {
+    LOGIN_TOKEN_ERROR_UNKNOWN = 0,
+    LOGIN_TOKEN_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface LoginTokenFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *domain;
+@property (strong, nonatomic, readonly) NSString *userName;
+@property (strong, nonatomic, readonly) NSString *password;
+@property (strong, nonatomic, readonly) NSString *token;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchTokenForDomain: (NSString *)domain
+                                 userName: (NSString *)userName
+                                 password: (NSString *)password
+                              withManager: (AFHTTPRequestOperationManager *)manager
+                       thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/LoginTokenFetcher.m b/wikipedia/Networking/Fetchers/LoginTokenFetcher.m
new file mode 100644
index 00000000000..3ed08cef7d3
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/LoginTokenFetcher.m
@@ -0,0 +1,123 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "LoginTokenFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@interface LoginTokenFetcher()
+
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *userName;
+@property (strong, nonatomic) NSString *password;
+@property (strong, nonatomic) NSString *token;
+
+@end
+
+@implementation LoginTokenFetcher
+
+-(instancetype)initAndFetchTokenForDomain: (NSString *)domain
+                                 userName: (NSString *)userName
+                                 password: (NSString *)password
+                              withManager: (AFHTTPRequestOperationManager *)manager
+                       thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.domain = domain ? domain : @"";
+        self.userName = userName ? userName : @"";
+        self.password = password ? password : @"";
+        self.token = @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self fetchTokenWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchTokenWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Login token not found."}};
+        }
+        
+        //NSLog(@"LOGIN TOKEN DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Login Token Fetcher"
+                                        code: LOGIN_TOKEN_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        self.token = output[@"token"] ? output[@"token"] : @"";
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"LOGIN TOKEN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    return @{
+             @"action": @"login",
+             @"lgname": self.userName,
+             @"lgpassword": self.password,
+             @"format": @"json"
+             }.mutableCopy;
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    if([rawResponse isDict]){
+        id login = rawResponse[@"login"];
+        if([login isDict]){
+            NSString *token = login[@"token"];
+            if (token) {
+                return @{@"token": token};
+            }
+        }
+    }
+    
+    return @{};
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING LOGIN TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/NearbyFetcher.h b/wikipedia/Networking/Fetchers/NearbyFetcher.h
new file mode 100644
index 00000000000..237b58ea29f
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/NearbyFetcher.h
@@ -0,0 +1,23 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+#import <CoreLocation/CoreLocation.h>
+
+typedef NS_ENUM(NSInteger, NearbyFetchErrorType) {
+    NEARBY_FETCH_ERROR_UNKNOWN = 0,
+    NEARBY_FETCH_ERROR_API = 1,
+    NEARBY_FETCH_ERROR_NO_RESULTS = 2
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface NearbyFetcher : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchNearbyForLatitude: (CLLocationDegrees)latitude
+                                   longitude: (CLLocationDegrees)longitude
+                                 withManager: (AFHTTPRequestOperationManager *)manager
+                          thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/NearbyFetcher.m b/wikipedia/Networking/Fetchers/NearbyFetcher.m
new file mode 100644
index 00000000000..cc0043558a5
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/NearbyFetcher.m
@@ -0,0 +1,160 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "NearbyFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "Defines.h"
+#import "WikipediaAppUtils.h"
+
+@interface NearbyFetcher()
+
+@property (nonatomic) CLLocationDegrees latitude;
+@property (nonatomic) CLLocationDegrees longitude;
+
+@end
+
+@implementation NearbyFetcher
+
+-(instancetype)initAndFetchNearbyForLatitude: (CLLocationDegrees)latitude
+                                   longitude: (CLLocationDegrees)longitude
+                                 withManager: (AFHTTPRequestOperationManager *)manager
+                          thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.latitude = latitude;
+        self.longitude = longitude;
+
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSString *url = [SessionSingleton sharedInstance].searchApiUrl;
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        //NSLog(@"responseObject: %@", responseObject);
+        //NSString *responseString = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding];
+        //NSLog(@"responseString: %@", responseString);
+        //NSLog(@"response length: %lu", (unsigned long)[responseObject length]);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        // Convert the raw NSData response to a dictionary.
+        if (![self isDataResponseValid:responseObject]){
+            // Fake out an error if bad response received.
+            responseObject = @{@"error": @{@"info": @"Nearby data not found."}};
+        }else{
+            // Should be able to proceed with dictionary conversion.
+            NSError *jsonError = nil;
+            responseObject = [NSJSONSerialization JSONObjectWithData:responseObject options:0 error:&jsonError];
+            responseObject = jsonError ? @{} : responseObject;
+        }
+
+        //NSLog(@"NEARBY DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Nearby Fetcher"
+                                        code: NEARBY_FETCH_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSMutableArray *output = @[].mutableCopy;
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        if (output.count == 0) {
+            NSMutableDictionary *errorDict = @{}.mutableCopy;
+            
+            errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"nearby-none", nil);
+            
+            // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
+            error = [NSError errorWithDomain:@"Nearby Fetcher" code:NEARBY_FETCH_ERROR_NO_RESULTS userInfo:errorDict];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"NEARBY FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    return @{
+             @"action": @"query",
+             @"prop": @"coordinates|pageimages",
+             @"colimit": @"50",
+             @"pithumbsize" : @(SEARCH_THUMBNAIL_WIDTH),
+             @"pilimit": @"50",
+             @"generator": @"geosearch",
+             @"ggscoord": [NSString stringWithFormat:@"%f|%f", self.latitude, self.longitude],
+             @"ggsradius": @"10000",
+             @"ggslimit": @"50",
+             @"format": @"json"
+             };
+}
+
+-(NSMutableArray *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSMutableArray *nearbyResults = @[].mutableCopy;
+    NSDictionary *jsonDict = (NSDictionary *)rawResponse;
+    
+    if (jsonDict.count > 0) {
+        NSDictionary *pages = jsonDict[@"query"][@"pages"];
+        if (pages) {
+            for (NSDictionary *pageId in pages) {
+                NSDictionary *page = pages[pageId];
+                NSArray *coordsArray = page[@"coordinates"];
+                NSDictionary *coords = coordsArray.firstObject;
+                NSNumber *pageId = page[@"pageid"];
+                NSString *pageImage = page[@"pageimage"];
+                NSDictionary *thumbnail = page[@"thumbnail"];
+                NSString *title = page[@"title"];
+                
+                NSMutableDictionary *d = @{}.mutableCopy;
+                if(coords)d[@"coordinates"] = coords;
+                if(pageId)d[@"pageid"] = pageId;
+                if(pageImage)d[@"pageimage"] = pageImage;
+                if(thumbnail)d[@"thumbnail"] = thumbnail;
+                if(title)d[@"title"] = title;
+                
+                [nearbyResults addObject:d];
+            }
+        }
+    }
+    return nearbyResults;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING LOGIN TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/PageHistoryFetcher.h b/wikipedia/Networking/Fetchers/PageHistoryFetcher.h
new file mode 100644
index 00000000000..661c6824979
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/PageHistoryFetcher.h
@@ -0,0 +1,17 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+@class AFHTTPRequestOperationManager;
+
+@interface PageHistoryFetcher : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchHistoryForTitle: (NSString *)title
+                                    domain: (NSString *)domain
+                               withManager: (AFHTTPRequestOperationManager *)manager
+                        thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate;
+
+@end
diff --git a/wikipedia/Networking/Fetchers/PageHistoryFetcher.m b/wikipedia/Networking/Fetchers/PageHistoryFetcher.m
new file mode 100644
index 00000000000..dfe1cde88aa
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/PageHistoryFetcher.m
@@ -0,0 +1,169 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "PageHistoryFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSString+Extras.h"
+#import "NSObject+Extras.h"
+#import "NSDate-Utilities.h"
+
+@implementation PageHistoryFetcher
+
+-(instancetype)initAndFetchHistoryForTitle: (NSString *)title
+                                    domain: (NSString *)domain
+                               withManager: (AFHTTPRequestOperationManager *)manager
+                        thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate
+{
+    self = [super init];
+    if (self) {
+        self.fetchFinishedDelegate = delegate;
+        [self fetchPageHistoryForTitle:title domain:domain withManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchPageHistoryForTitle: (NSString *)title
+                          domain: (NSString *)domain
+                     withManager: (AFHTTPRequestOperationManager *)manager
+{
+
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:domain];
+
+    NSDictionary *params = [self getParamsForTitle:title];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"History not found."}};
+        }
+        
+        //NSLog(@"PAGE HISTORY DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        // Uncomment @"rvdiffto": @(-1) in the parameters to force API error for testing.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain:@"Page History Fetcher" code:001 userInfo:errorDict];
+        }
+
+        NSMutableArray *output = @[].mutableCopy;
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"PAGE HISTORY FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParamsForTitle:(NSString *)title
+{
+    NSMutableDictionary *params = @{
+                                    @"action": @"query",
+                                    @"prop": @"revisions",
+                                    @"rvprop": @"ids|timestamp|user|size|parsedcomment",
+                                    @"rvlimit": @50,
+                                    @"rvdir": @"older",
+                                    @"titles": title,
+                                    @"format": @"json"
+                                    //,@"rvdiffto": @(-1) // Add this to fake out "error" api response.
+                                    }.mutableCopy;
+    return params;
+}
+
+-(NSMutableArray *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSMutableArray *output = @[].mutableCopy;
+    NSMutableDictionary *parentSizes = @{}.mutableCopy;
+    NSMutableDictionary *revisionsByDay = @{}.mutableCopy;
+    
+    if (rawResponse.count > 0) {
+        NSDictionary *pages = rawResponse[@"query"][@"pages"];
+        if (pages) {
+            for (NSDictionary *page in pages) {
+                NSString *title = pages[page][@"title"];
+                for (NSDictionary *revision in pages[page][@"revisions"]) {
+                    NSMutableDictionary *mutableRevision = revision.mutableCopy;
+                    mutableRevision[@"title"] = title;
+                    
+                    parentSizes[revision[@"revid"]] = revision[@"size"];
+                    
+                    NSString *timeStampString = mutableRevision[@"timestamp"];
+                    NSDate *timeStampDate = [timeStampString getDateFromIso8601DateString];
+                    
+                    NSUInteger distanceInDaysToDate = [timeStampDate distanceInDaysToDate:[NSDate date]];
+                    
+                    //NSLog(@"distanceInDaysToDate = %d", [timeStampDate distanceInDaysToDate:[NSDate date]]);
+                    if (!revisionsByDay[@(distanceInDaysToDate)]) {
+                        revisionsByDay[@(distanceInDaysToDate)] = @[].mutableCopy;
+                    }
+                    
+                    NSMutableArray *revisionRowArray = revisionsByDay[@(distanceInDaysToDate)];
+                    [revisionRowArray addObject:mutableRevision];
+                }
+            }
+            
+            NSMutableArray *revisionsByDaySorted = @[].mutableCopy;
+            for (NSNumber *day in [revisionsByDay.allKeys sortedArrayUsingSelector: @selector(compare:)]){
+                [revisionsByDaySorted addObject:@{
+                                                  @"daysAgo": day,
+                                                  @"revisions": revisionsByDay[day]
+                                                  }];
+            }
+            
+            [self calculateCharacterDeltasForRevisions: revisionsByDaySorted
+                                       fromParentSizes: parentSizes];
+            
+            output = revisionsByDaySorted;
+        }
+    }
+    return output;
+}
+
+-(void)calculateCharacterDeltasForRevisions:(NSMutableArray *)revisions fromParentSizes:(NSDictionary *)parentSizes
+{
+    // Note: always retrieve one more than you're going to show so the oldest item
+    // shown can have it's characterDelta calculated.
+
+    for (NSDictionary *day in revisions) {
+        for (NSMutableDictionary *revision in day[@"revisions"]) {
+            NSNumber *parentId = revision[@"parentid"];
+            if(parentSizes[parentId]){
+                NSNumber *parentSize = parentSizes[parentId];
+                NSNumber *revisionSize = revision[@"size"];
+                revision[@"characterDelta"] = @(revisionSize.integerValue - parentSize.integerValue);
+            }else if (parentId){
+                if (parentId.integerValue == 0) {
+                    revision[@"characterDelta"] = revision[@"size"];
+                }
+            }
+        }
+    }
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING PAGE HISTORY FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.h b/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.h
new file mode 100644
index 00000000000..4e1bf5a5291
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.h
@@ -0,0 +1,17 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+@class AFHTTPRequestOperationManager;
+
+@interface PreviewHtmlFetcher : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchHtmlForWikiText: (NSString *)wikiText
+                                     title: (NSString *)title
+                                    domain: (NSString *)domain
+                               withManager: (AFHTTPRequestOperationManager *)manager
+                        thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.m b/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.m
new file mode 100644
index 00000000000..c50edb75a0b
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/PreviewHtmlFetcher.m
@@ -0,0 +1,115 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "PreviewHtmlFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@implementation PreviewHtmlFetcher
+
+-(instancetype)initAndFetchHtmlForWikiText: (NSString *)wikiText
+                                     title: (NSString *)title
+                                    domain: (NSString *)domain
+                               withManager: (AFHTTPRequestOperationManager *)manager
+                        thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate
+{
+    self = [super init];
+    if (self) {
+        self.fetchFinishedDelegate = delegate;
+        [self fetchPreviewForWikiText:wikiText title:title domain:domain withManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchPreviewForWikiText: (NSString *)wikiText
+                          title: (NSString *)title
+                         domain: (NSString *)domain
+                    withManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:domain];
+
+    NSDictionary *params = [self getParamsForTitle:title wikiText:wikiText];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    // Note: "Preview should probably stay as a post, since the wikitext chunk may be
+    // pretty long and there may or may not be a limit on URL length some" - Brion
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Preview not found."}};
+        }
+        
+        //NSLog(@"PREVIEW HTML DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain:@"Preview HTML Fetcher" code:001 userInfo:errorDict];
+        }
+
+        NSString *output = @"";
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"PREVIEW HTML FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParamsForTitle:(NSString *)title wikiText:(NSString *)wikiText
+{
+    return @{
+             @"action": @"parse",
+             @"sectionpreview": @"true",
+             @"pst": @"true",
+             @"mobileformat": @"true",
+             @"title": (title ? title : @""),
+             @"prop": @"text",
+             @"text": (wikiText ? wikiText : @""),
+             @"format": @"json"
+             }.mutableCopy;
+}
+
+-(NSString *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    if(![rawResponse isDict]) return @"";
+
+    id parse = rawResponse[@"parse"];
+    
+    if(![parse isDict]) return @"";
+
+    id text = parse[@"text"];
+    
+    if(![text isDict]) return @"";
+
+    NSString *result = text[@"*"];
+
+    return (result ? result : @"");
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING PAGE HISTORY FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/RandomArticleFetcher.h b/wikipedia/Networking/Fetchers/RandomArticleFetcher.h
new file mode 100644
index 00000000000..ff0cc07e660
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/RandomArticleFetcher.h
@@ -0,0 +1,22 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, RandomArticleFetchErrorType) {
+    RANDOM_ARTICLE_FETCH_ERROR_UNKNOWN = 0,
+    RANDOM_ARTICLE_FETCH_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface RandomArticleFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *domain;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchRandomArticleForDomain: (NSString *)domain
+                                      withManager: (AFHTTPRequestOperationManager *)manager
+                               thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/RandomArticleFetcher.m b/wikipedia/Networking/Fetchers/RandomArticleFetcher.m
new file mode 100644
index 00000000000..9e1e9a45de6
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/RandomArticleFetcher.m
@@ -0,0 +1,107 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "RandomArticleFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "Defines.h"
+#import "WikipediaAppUtils.h"
+
+@interface RandomArticleFetcher()
+
+@property (strong, nonatomic) NSString *domain;
+
+@end
+
+@implementation RandomArticleFetcher
+
+-(instancetype)initAndFetchRandomArticleForDomain: (NSString *)domain
+                                      withManager: (AFHTTPRequestOperationManager *)manager
+                               thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+        self.domain = domain;
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSString *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain].absoluteString;
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Random article data not found."}};
+        }
+
+        //NSLog(@"RANDOM ARTICLE RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Random Article Fetcher"
+                                        code: RANDOM_ARTICLE_FETCH_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSString *output = @"";
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"RANDOM ARTICLE FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    return @{
+             @"action": @"query",
+             @"list": @"random",
+             @"rnlimit": @"1",
+             @"rnnamespace": @"0",
+             @"format": @"json"
+             };
+}
+
+-(NSString *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSArray *randomArticles = (NSArray *)rawResponse[@"query"][@"random"];
+    NSDictionary *article = [randomArticles objectAtIndex:0];
+    NSString *title = article[@"title"];
+    return title;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING LOGIN TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/SearchResultFetcher.h b/wikipedia/Networking/Fetchers/SearchResultFetcher.h
new file mode 100644
index 00000000000..598a69d8f56
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/SearchResultFetcher.h
@@ -0,0 +1,21 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, SearchResultFetcherErrorType) {
+    SEARCH_RESULT_ERROR_UNKNOWN = 0,
+    SEARCH_RESULT_ERROR_API = 1,
+    SEARCH_RESULT_ERROR_NO_MATCHES = 2
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface SearchResultFetcher : FetcherBase
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndSearchForTerm: (NSString *)searchTerm
+                        withManager: (AFHTTPRequestOperationManager *)manager
+                 thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/SearchResultFetcher.m b/wikipedia/Networking/Fetchers/SearchResultFetcher.m
new file mode 100644
index 00000000000..3f27a0bf64a
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/SearchResultFetcher.m
@@ -0,0 +1,230 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "SearchResultFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "Defines.h"
+#import "NSString+Extras.h"
+#import "WikipediaAppUtils.h"
+#import "ArticleDataContextSingleton.h"
+#import "ArticleCoreDataObjects.h"
+#import "NSManagedObjectContext+SimpleFetch.h"
+
+@interface SearchResultFetcher()
+
+@property (strong, nonatomic) NSString *domain;
+
+@end
+
+@implementation SearchResultFetcher
+
+-(instancetype)initAndSearchForTerm: (NSString *)searchTerm
+                        withManager: (AFHTTPRequestOperationManager *)manager
+                 thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+{
+    self = [super init];
+    if (self) {
+        self.fetchFinishedDelegate = delegate;
+        [self searchForTerm:searchTerm withManager:manager];
+    }
+    return self;
+}
+
+- (void)searchForTerm:(NSString *)searchTerm withManager:(AFHTTPRequestOperationManager *)manager
+{
+    NSString *url = [SessionSingleton sharedInstance].searchApiUrl;
+
+    NSDictionary *params = [self getParamsForTerm:searchTerm];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Convert the raw NSData response to a dictionary.
+        if (![self isDataResponseValid:responseObject]){
+            // Fake out an error if bad response received.
+            responseObject = @{@"error": @{@"info": @"Search data not found."}};
+        }else{
+            // Should be able to proceed with dictionary conversion.
+            NSError *jsonError = nil;
+            responseObject = [NSJSONSerialization JSONObjectWithData:responseObject options:0 error:&jsonError];
+            responseObject = jsonError ? @{} : responseObject;
+        }
+        
+        //NSLog(@"CAPTCHA RESETTER DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Search Result Fetcher"
+                                        code: SEARCH_RESULT_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSArray *output = @[];
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject forSearchTerm:searchTerm];
+        }
+
+        // If no matches set error.
+        if (output.count == 0) {
+            NSMutableDictionary *errorDict = @{}.mutableCopy;
+            
+            errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"search-no-matches", nil);
+            
+            // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
+            error = [NSError errorWithDomain:@"Search Result Fetcher" code:SEARCH_RESULT_ERROR_NO_MATCHES userInfo:errorDict];
+        }
+
+        if (!error) [self preparePlaceholderImageRecordsForOutput:output];
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"CAPTCHA RESETTER FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParamsForTerm:(NSString *)searchTerm
+{
+    // Based on https://gerrit.wikimedia.org/r/#/c/158011/2/javascripts/modules/search/SearchApi.js
+    return @{
+             @"action": @"query",
+             @"generator": @"prefixsearch",
+             @"gpssearch": (searchTerm ? searchTerm : @""),
+             @"gpsnamespace": @0,
+             @"gpslimit": @(SEARCH_MAX_RESULTS),
+             @"prop": @"pageimages",
+             @"piprop": @"thumbnail",
+             @"pithumbsize" : @(SEARCH_THUMBNAIL_WIDTH),
+             @"pilimit": @(SEARCH_MAX_RESULTS),
+             @"list": @"prefixsearch",
+             @"pssearch": (searchTerm ? searchTerm : @""),
+             @"pslimit": @(SEARCH_MAX_RESULTS),
+             @"format": @"json"
+             };
+}
+
+-(NSArray *)getSanitizedResponse:(NSDictionary *)rawResponse forSearchTerm:(NSString *)searchTerm
+{
+    // Make output array contain just dictionaries for each result.
+    NSMutableArray *output = @[].mutableCopy;
+    NSDictionary *jsonDict = (NSDictionary *)rawResponse;
+    if (jsonDict.count > 0) {
+        NSDictionary *query = (NSDictionary *)jsonDict[@"query"];
+        if (query) {
+        
+            NSDictionary *pages = (NSDictionary *)query[@"pages"];
+            NSArray *pagesOrdered = (NSArray *)query[@"prefixsearch"];
+            
+            if (pages && pagesOrdered) {
+
+                // Loop through the prefixsearch results (rather than the pages results) so we maintain correct order.
+                // Based on https://gerrit.wikimedia.org/r/#/c/158011/2/javascripts/modules/search/SearchApi.js
+                for (NSDictionary *prefixPage in pagesOrdered) {
+
+                    // "dictionaryWithDictionary" used because it creates a deep mutable copy of the __NSCFDictionary.
+                    NSMutableDictionary *mutablePrefixPage = [NSMutableDictionary dictionaryWithDictionary:prefixPage];
+                    
+                    // Add thumb placeholder.
+                    mutablePrefixPage[@"thumbnail"] = @{}.mutableCopy;
+                    
+                    // Grab the thumbnail info from the non-prefixsearch result for this pageid.
+                    for (NSDictionary *page in pages.allValues) {
+                        id pageId = page[@"pageid"];
+                        id prefixPageId = mutablePrefixPage[@"pageid"];
+                        if (pageId && prefixPageId && [prefixPageId isKindOfClass:[NSNumber class]] && [pageId isKindOfClass:[NSNumber class]]){
+                            if ([prefixPageId isEqualToNumber:pageId]) {
+                                if (page[@"thumbnail"]){
+                                    mutablePrefixPage[@"thumbnail"] = page[@"thumbnail"];
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    
+                    mutablePrefixPage[@"title"] = mutablePrefixPage[@"title"] ? [mutablePrefixPage[@"title"] wikiTitleWithoutUnderscores] : @"";
+                    
+                    if (mutablePrefixPage) [output addObject:mutablePrefixPage];
+                }
+            }
+        }
+    }
+
+    return output;
+}
+
+#pragma mark Core data Image record placeholder for thumbnail (so they get cached)
+
+-(void)preparePlaceholderImageRecordsForOutput:(NSArray *)output
+{
+    // Prepare placeholder Image records.
+    [[ArticleDataContextSingleton sharedInstance].mainContext performBlockAndWait:^(){
+        for (NSDictionary *page in output) {
+            // If url thumb found, prepare a core data Image object so URLCache
+            // will know this is an image to intercept.
+            NSDictionary *thumbData = page[@"thumbnail"];
+            if (thumbData) {
+                NSString *src = thumbData[@"source"];
+                NSNumber *height = thumbData[@"height"];
+                NSNumber *width = thumbData[@"width"];
+                if (src && height && width) {
+                    [self insertPlaceHolderImageEntityIntoContext: [ArticleDataContextSingleton sharedInstance].mainContext
+                                                  forImageWithUrl: src
+                                                            width: width
+                                                           height: height];
+                }
+            }
+        }
+        NSError *error = nil;
+        [[ArticleDataContextSingleton sharedInstance].mainContext save:&error];
+    }];
+}
+
+-(void)insertPlaceHolderImageEntityIntoContext: (NSManagedObjectContext *)context
+                               forImageWithUrl: (NSString *)url
+                                         width: (NSNumber *)width
+                                        height: (NSNumber *)height
+{
+    Image *existingImage = (Image *)[context getEntityForName: @"Image" withPredicateFormat:@"sourceUrl == %@", [url getUrlWithoutScheme]];
+    // If there's already an image record for this exact url, don't create another one!!!
+    if (!existingImage) {
+        Image *image = [NSEntityDescription insertNewObjectForEntityForName:@"Image" inManagedObjectContext:context];
+        image.imageData = [NSEntityDescription insertNewObjectForEntityForName:@"ImageData" inManagedObjectContext:context];
+        image.imageData.data = [[NSData alloc] init];
+        image.dataSize = @(image.imageData.data.length);
+        image.fileName = [url lastPathComponent];
+        image.fileNameNoSizePrefix = [image.fileName getWikiImageFileNameWithoutSizePrefix];
+        image.extension = [url pathExtension];
+        image.imageDescription = nil;
+        image.sourceUrl = [url getUrlWithoutScheme];
+        image.dateRetrieved = [NSDate date];
+        image.dateLastAccessed = [NSDate date];
+        image.width = @(width.integerValue);
+        image.height = @(height.integerValue);
+        image.mimeType = [image.extension getImageMimeTypeForExtension];
+    }
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING ACCT CREATION TOKEN FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/ThumbnailFetcher.h b/wikipedia/Networking/Fetchers/ThumbnailFetcher.h
new file mode 100644
index 00000000000..974081b3ff9
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/ThumbnailFetcher.h
@@ -0,0 +1,23 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, ThumbnailFetchErrorType) {
+    THUMBNAIL_FETCH_ERROR_UNKNOWN = 0,
+    THUMBNAIL_FETCH_ERROR_API = 1,
+    THUMBNAIL_FETCH_ERROR_NOT_FOUND = 2
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface ThumbnailFetcher : FetcherBase
+
+@property (nonatomic, strong, readonly) NSString *url;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchThumbnailFromURL: (NSString *)url
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/ThumbnailFetcher.m b/wikipedia/Networking/Fetchers/ThumbnailFetcher.m
new file mode 100644
index 00000000000..739b9123ce1
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/ThumbnailFetcher.m
@@ -0,0 +1,76 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "ThumbnailFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+
+@interface ThumbnailFetcher()
+
+@property (nonatomic, strong) NSString *url;
+
+@end
+
+@implementation ThumbnailFetcher
+
+-(instancetype)initAndFetchThumbnailFromURL: (NSString *)url
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+        self.url = url;
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:self.url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        NSError *error = nil;
+        if(
+           ![responseObject isKindOfClass:[NSData class]]
+           ||
+           ([responseObject length] == 0)
+           ||
+           !self.url
+           ||
+           (self.url.length == 0)
+           )
+        {
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Thumbnail Fetcher"
+                                        code: THUMBNAIL_FETCH_ERROR_NOT_FOUND
+                                    userInfo: errorDict];
+        }
+
+        [self finishWithError: error
+                     userData: responseObject];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING THUMBNAIL FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.h b/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.h
new file mode 100644
index 00000000000..8be1f7423d3
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.h
@@ -0,0 +1,27 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, WikiTextFetcherErrorType) {
+    WIKITEXT_FETCHER_ERROR_UNKNOWN = 0,
+    WIKITEXT_FETCHER_ERROR_API = 1,
+    WIKITEXT_FETCHER_ERROR_INCOMPLETE = 2
+};
+
+@class AFHTTPRequestOperationManager, Section;
+
+@interface WikiTextSectionFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) Section *section;
+@property (strong, nonatomic, readonly) NSString *title;
+@property (strong, nonatomic, readonly) NSString *domain;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchWikiTextForSection: (Section *)section
+                                        title: (NSString *)title
+                                       domain: (NSString *)domain
+                                  withManager: (AFHTTPRequestOperationManager *)manager
+                           thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.m b/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.m
new file mode 100644
index 00000000000..2b322ca5de6
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikiTextSectionFetcher.m
@@ -0,0 +1,144 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "WikiTextSectionFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "WikipediaAppUtils.h"
+#import "ArticleCoreDataObjects.h"
+
+@interface WikiTextSectionFetcher()
+
+@property (strong, nonatomic) Section *section;
+@property (strong, nonatomic) NSString *title;
+@property (strong, nonatomic) NSString *domain;
+
+@end
+
+@implementation WikiTextSectionFetcher
+
+-(instancetype)initAndFetchWikiTextForSection: (Section *)section
+                                        title: (NSString *)title
+                                       domain: (NSString *)domain
+                                  withManager: (AFHTTPRequestOperationManager *)manager
+                           thenNotifyDelegate: (id <FetchFinishedDelegate>) delegate
+{
+    self = [super init];
+    if (self) {
+        self.section = section;
+        self.title = title ? title : @"";
+        self.domain = domain ? domain : @"";
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWikiTextWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWikiTextWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    // Note: "Preview should probably stay as a post, since the wikitext chunk may be
+    // pretty long and there may or may not be a limit on URL length some" - Brion
+    [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Wikitext not found."}};
+        }
+        
+        //NSLog(@"WIKITEXT RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain:@"Wikitext Fetcher" code:WIKITEXT_FETCHER_ERROR_API userInfo:errorDict];
+        }
+
+        NSDictionary *output = @{};
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+
+            // Handle case where revision or userInfo not retrieved.
+            if (![output objectForKey:@"revision"] || ![output objectForKey:@"userInfo"]) {
+                NSMutableDictionary *errorDict = @{}.mutableCopy;
+                errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"wikitext-download-failed", nil);
+                error = [NSError errorWithDomain:@"Wikitext Fetcher" code:WIKITEXT_FETCHER_ERROR_INCOMPLETE userInfo:errorDict];
+            }
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"WIKITEXT DOWNLOAD FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    return @{
+             @"action": @"query",
+             @"prop": @"revisions",
+             @"rvprop": @"content",
+             @"rvlimit": @1,
+             @"rvsection": self.section.index,
+             @"titles": self.title,
+             @"meta": @"userinfo", // we need the local user ID for event logging
+             @"format": @"json"
+             };
+}
+
+-(NSDictionary *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSMutableDictionary *output = @{}.mutableCopy;
+    if(![rawResponse isDict]) return output;
+
+    NSDictionary *query = rawResponse[@"query"];
+    if(![query isDict]) return output;
+
+    NSDictionary *pages = query[@"pages"];
+    NSDictionary *userInfo = query[@"userinfo"];
+    if(![pages isDict] || ![userInfo isDict]) return output;
+
+    NSString *revision = nil;
+    if (pages && (pages.allKeys.count > 0)) {
+        NSString *key = pages.allKeys[0];
+        if (key) {
+            NSDictionary *page = pages[key];
+            if (page) {
+                revision = page[@"revisions"][0][@"*"];
+            }
+        }
+    }
+
+    if (revision) output[@"revision"] = revision;
+    if (userInfo) output[@"userInfo"] = userInfo;
+    
+    return output;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING PAGE HISTORY FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/WikiTextSectionUploader.h b/wikipedia/Networking/Fetchers/WikiTextSectionUploader.h
new file mode 100644
index 00000000000..bbdfba9cf57
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikiTextSectionUploader.h
@@ -0,0 +1,46 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, WikiTextSectionUploaderErrors) {
+    WIKITEXT_UPLOAD_ERROR_UNKNOWN = 0,
+    WIKITEXT_UPLOAD_ERROR_SERVER = 1,
+    WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA = 2,
+    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED = 3,
+    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING = 4,
+    WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER = 5
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface WikiTextSectionUploader : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *wikiText;
+@property (strong, nonatomic, readonly) NSString *title;
+@property (strong, nonatomic, readonly) NSString *domain;
+@property (strong, nonatomic, readonly) NSString *section;
+@property (strong, nonatomic, readonly) NSString *summary;
+@property (strong, nonatomic, readonly) NSString *captchaId;
+@property (strong, nonatomic, readonly) NSString *captchaWord;
+@property (strong, nonatomic, readonly) NSManagedObjectID *articleID;
+@property (strong, nonatomic, readonly) NSString *token;
+
+// Kick-off method. Results are reported to "delegate" via the
+// FetchFinishedDelegate protocol method.
+
+// Note: "section" parameter needs to be a string because the
+// api returns transcluded section indexes with a "T-" prefix
+-(instancetype)initAndUploadWikiText: (NSString *)wikiText
+                        forPageTitle: (NSString *)title
+                              domain: (NSString *)domain
+                             section: (NSString *)section
+                             summary: (NSString *)summary
+                           captchaId: (NSString *)captchaId
+                         captchaWord: (NSString *)captchaWord
+                           articleID: (NSManagedObjectID *)articleID
+                               token: (NSString *)token
+                         withManager: (AFHTTPRequestOperationManager *)manager
+                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/WikiTextSectionUploader.m b/wikipedia/Networking/Fetchers/WikiTextSectionUploader.m
new file mode 100644
index 00000000000..12d56294b8c
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikiTextSectionUploader.m
@@ -0,0 +1,201 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "WikiTextSectionUploader.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "WikipediaAppUtils.h"
+
+@interface WikiTextSectionUploader()
+
+@property (strong, nonatomic) NSString *wikiText;
+@property (strong, nonatomic) NSString *title;
+@property (strong, nonatomic) NSString *domain;
+@property (strong, nonatomic) NSString *section;
+@property (strong, nonatomic) NSString *summary;
+@property (strong, nonatomic) NSString *captchaId;
+@property (strong, nonatomic) NSString *captchaWord;
+@property (strong, nonatomic) NSManagedObjectID *articleID;
+@property (strong, nonatomic) NSString *token;
+
+@end
+
+@implementation WikiTextSectionUploader
+
+-(instancetype)initAndUploadWikiText: (NSString *)wikiText
+                        forPageTitle: (NSString *)title
+                              domain: (NSString *)domain
+                             section: (NSString *)section
+                             summary: (NSString *)summary
+                           captchaId: (NSString *)captchaId
+                         captchaWord: (NSString *)captchaWord
+                           articleID: (NSManagedObjectID *)articleID
+                               token: (NSString *)token
+                         withManager: (AFHTTPRequestOperationManager *)manager
+                  thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+
+        self.wikiText = wikiText ? wikiText : @"";
+        self.title = title ? title : @"";
+        self.domain = domain ? domain : @"";
+        self.section = section ? section : @"";
+        self.summary = summary ? summary : @"";
+        self.captchaId = captchaId ? captchaId : @"";
+        self.captchaWord = captchaWord ? captchaWord : @"";
+        self.articleID = articleID;
+        self.token = token ? token : @"";
+
+        self.fetchFinishedDelegate = delegate;
+        [self uploadWithManager: manager];
+    }
+    return self;
+}
+
+- (void)uploadWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager POST:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+        //NSLog(@"JSON: %@", responseObject);
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"WikiText upload data not found."}};
+        }
+        
+        //NSLog(@"ACCT CREATION DATA RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"WikiText Uploader"
+                                        code: WIKITEXT_UPLOAD_ERROR_SERVER
+                                    userInfo: errorDict];
+        }
+
+
+        NSDictionary *resultDict = responseObject[@"edit"];
+        NSString *result = resultDict[@"result"];
+        
+        if (!error && !result) {
+            NSMutableDictionary *errorDict = [@{} mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"wikitext-upload-result-unknown", nil);
+            
+            // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
+            error = [NSError errorWithDomain:@"Upload Wikitext Op" code:WIKITEXT_UPLOAD_ERROR_UNKNOWN userInfo:errorDict];
+        }
+        
+        if (!error && result && [result isEqualToString:@"Failure"]) {
+            
+            
+            if(responseObject[@"edit"][@"captcha"]){
+                NSMutableDictionary *errorDict = [@{} mutableCopy];
+                
+                errorDict[NSLocalizedDescriptionKey] = (self.captchaWord && (self.captchaWord.length > 0)) ?
+                MWLocalizedString(@"wikitext-upload-captcha-error", nil)
+                :
+                MWLocalizedString(@"wikitext-upload-captcha-needed", nil)
+                ;
+                
+                // Make the capcha id and url available from the error.
+                errorDict[@"captchaId"] = responseObject[@"edit"][@"captcha"][@"id"];
+                errorDict[@"captchaUrl"] = responseObject[@"edit"][@"captcha"][@"url"];
+                
+                // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
+                error = [NSError errorWithDomain:@"Upload Wikitext Op" code:WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA userInfo:errorDict];
+            }else if(responseObject[@"edit"][@"code"]){
+                
+                NSString *abuseFilterCode = responseObject[@"edit"][@"code"];
+                WikiTextSectionUploaderErrors errorType = WIKITEXT_UPLOAD_ERROR_UNKNOWN;
+                
+                if([abuseFilterCode hasPrefix:@"abusefilter-warning"]){
+                    errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING;
+                }else if([abuseFilterCode hasPrefix:@"abusefilter-disallowed"]){
+                    errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED;
+                }else if([abuseFilterCode hasPrefix:@"abusefilter"]){
+                    errorType = WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER;
+                }
+                
+                switch (errorType) {
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING:
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED:
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER:
+                    {
+                        NSMutableDictionary *errorDict = [@{} mutableCopy];
+                        
+                        errorDict[NSLocalizedDescriptionKey] = responseObject[@"edit"][@"info"];
+                        
+                        // Make the verbose warning available from the error.
+                        errorDict[@"warning"] = responseObject[@"edit"][@"warning"];
+                        errorDict[@"code"] = abuseFilterCode;
+                        
+                        // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
+                        error = [NSError errorWithDomain:@"Upload Wikitext Op" code:errorType userInfo:errorDict];
+                    }
+                        break;
+                        
+                    default:
+                        break;
+                }
+            }
+        }
+
+        [self finishWithError: error
+                     userData: resultDict];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"ACCT CREATION TOKEN FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSMutableDictionary *)getParams
+{
+    NSString *tokenToUse = @"+\\";
+    if (self.token && (self.token.length > 0)) {
+        tokenToUse = self.token;
+    }
+
+    NSMutableDictionary *params =
+    @{
+      @"action": @"edit",
+      @"token": tokenToUse,
+      @"text": self.wikiText,
+      @"summary": self.summary,
+      @"section": self.section,
+      @"title": self.title,
+      @"format": @"json"
+      }.mutableCopy;
+    
+    if (self.captchaWord) {
+        params[@"captchaid"] = self.captchaId;
+        params[@"captchaword"] = self.captchaWord;
+    }
+
+    return params;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING PAGE HISTORY FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.h b/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.h
new file mode 100644
index 00000000000..67e16d5b94c
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.h
@@ -0,0 +1,22 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+#import "FetcherBase.h"
+
+typedef NS_ENUM(NSInteger, WikipediaZeroMessageFetcherErrorType) {
+    WIKIPEDIA_ZERO_MESSAGE_FETCH_ERROR_UNKNOWN = 0,
+    WIKIPEDIA_ZERO_MESSAGE_FETCH_ERROR_API = 1
+};
+
+@class AFHTTPRequestOperationManager;
+
+@interface WikipediaZeroMessageFetcher : FetcherBase
+
+@property (strong, nonatomic, readonly) NSString *domain;
+
+// Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
+-(instancetype)initAndFetchMessageForDomain: (NSString *)domain
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate;
+@end
diff --git a/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.m b/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.m
new file mode 100644
index 00000000000..09ebf28353f
--- /dev/null
+++ b/wikipedia/Networking/Fetchers/WikipediaZeroMessageFetcher.m
@@ -0,0 +1,112 @@
+//  Created by Monte Hurd on 10/9/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "WikipediaZeroMessageFetcher.h"
+#import "AFHTTPRequestOperationManager.h"
+#import "MWNetworkActivityIndicatorManager.h"
+#import "SessionSingleton.h"
+#import "NSObject+Extras.h"
+#import "Defines.h"
+#import "WikipediaAppUtils.h"
+
+@interface WikipediaZeroMessageFetcher()
+
+@property (strong, nonatomic) NSString *domain;
+
+@end
+
+@implementation WikipediaZeroMessageFetcher
+
+-(instancetype)initAndFetchMessageForDomain: (NSString *)domain
+                                withManager: (AFHTTPRequestOperationManager *)manager
+                         thenNotifyDelegate: (id <FetchFinishedDelegate>)delegate
+{
+    self = [super init];
+    if (self) {
+        self.domain = domain ? domain : @"";
+        self.fetchFinishedDelegate = delegate;
+        [self fetchWithManager:manager];
+    }
+    return self;
+}
+
+- (void)fetchWithManager: (AFHTTPRequestOperationManager *)manager
+{
+    NSURL *url = [[SessionSingleton sharedInstance] urlForDomain:self.domain];
+
+    NSDictionary *params = [self getParams];
+    
+    [[MWNetworkActivityIndicatorManager sharedManager] push];
+
+    [manager GET:url.absoluteString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        
+        // Fake out an error if non-dictionary response received.
+        if(![responseObject isDict]){
+            responseObject = @{@"error": @{@"info": @"Wikipedia Zero message not found."}};
+        }
+
+        //NSLog(@"WIKIPEDIA ZERO MESSAGE RETRIEVED = %@", responseObject);
+        
+        // Handle case where response is received, but API reports error.
+        NSError *error = nil;
+        if (responseObject[@"error"]){
+            NSMutableDictionary *errorDict = [responseObject[@"error"] mutableCopy];
+            errorDict[NSLocalizedDescriptionKey] = errorDict[@"info"];
+            error = [NSError errorWithDomain: @"Wikipedia Zero Message Fetcher"
+                                        code: WIKIPEDIA_ZERO_MESSAGE_FETCH_ERROR_API
+                                    userInfo: errorDict];
+        }
+
+        NSString *output = @"";
+        if (!error) {
+            output = [self getSanitizedResponse:responseObject];
+        }
+
+        [self finishWithError: error
+                     userData: output];
+        
+    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+
+        //NSLog(@"WIKIPEDIA ZERO MESSAGE FAIL = %@", error);
+
+        [[MWNetworkActivityIndicatorManager sharedManager] pop];
+
+        [self finishWithError: error
+                     userData: nil];
+    }];
+}
+
+-(NSDictionary *)getParams
+{
+    NSString *agent = [WikipediaAppUtils versionedUserAgent];
+    return @{
+             @"action": @"zeroconfig",
+             @"type": @"message",
+             @"agent": agent ? agent : @""
+             };
+}
+
+-(NSString *)getSanitizedResponse:(NSDictionary *)rawResponse
+{
+    NSString *zeroRatedMessage = rawResponse.count > 0 ? [rawResponse objectForKey:@"message"] : nil;
+    
+    // For testing Wikipedia Zero visual flourishes.
+    // Go to WebViewController.m and uncomment the W0 part,
+    // then when running the app in the simulator fire the
+    // memory warning to toggle the fake state on or off.
+    if ([SessionSingleton sharedInstance].zeroConfigState.fakeZeroOn) {
+        zeroRatedMessage = @"Free Wikipedia by Test Operator";
+    }
+    return zeroRatedMessage;
+}
+
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING LANGUAGE LINKS FETCHER!");
+}
+*/
+
+@end
diff --git a/wikipedia/Networking/Queues/QueuesSingleton.h b/wikipedia/Networking/Queues/QueuesSingleton.h
new file mode 100644
index 00000000000..e1e7b5f8adb
--- /dev/null
+++ b/wikipedia/Networking/Queues/QueuesSingleton.h
@@ -0,0 +1,26 @@
+//  Created by Monte Hurd on 12/6/13.
+//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import <Foundation/Foundation.h>
+
+#import "AFHTTPRequestOperationManager.h"
+
+@interface QueuesSingleton : NSObject
+
+@property (strong, nonatomic) AFHTTPRequestOperationManager *loginFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *articleFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *savedPagesFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *searchResultsFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *zeroRatedMessageFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *sectionWikiTextDownloadManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *sectionWikiTextUploadManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *sectionPreviewHtmlFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *languageLinksFetcher;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *accountCreationFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *pageHistoryFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *assetsFetchManager;
+@property (strong, nonatomic) AFHTTPRequestOperationManager *nearbyFetchManager;
+
++ (QueuesSingleton *)sharedInstance;
+
+@end
diff --git a/wikipedia/Networking/Queues/QueuesSingleton.m b/wikipedia/Networking/Queues/QueuesSingleton.m
new file mode 100644
index 00000000000..eec23366100
--- /dev/null
+++ b/wikipedia/Networking/Queues/QueuesSingleton.m
@@ -0,0 +1,119 @@
+//  Created by Monte Hurd on 12/6/13.
+//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "QueuesSingleton.h"
+#import "WikipediaAppUtils.h"
+
+@implementation QueuesSingleton
+
++ (QueuesSingleton *)sharedInstance
+{
+    static dispatch_once_t once;
+    static id sharedInstance;
+    dispatch_once(&once, ^{
+        sharedInstance = [[self alloc] init];
+    });
+    return sharedInstance;
+}
+
+- (id)init
+{
+    self = [super init];
+    if (self) {
+
+        [self setupManagers];
+
+        [self setRequestHeadersForManagers:@[
+            self.loginFetchManager,
+            self.articleFetchManager,
+            self.savedPagesFetchManager,
+            self.searchResultsFetchManager,
+            self.sectionWikiTextDownloadManager,
+            self.sectionWikiTextUploadManager,
+            self.sectionPreviewHtmlFetchManager,
+            self.languageLinksFetcher,
+            self.zeroRatedMessageFetchManager,
+            self.accountCreationFetchManager,
+            self.pageHistoryFetchManager,
+            self.assetsFetchManager,
+            self.nearbyFetchManager
+        ]];
+
+        [self setDefaultSerializerForManagers:@[
+            self.nearbyFetchManager,
+            self.searchResultsFetchManager,
+            self.assetsFetchManager
+        ]];
+
+        //[self setupQMonitorLogging];
+    }
+    return self;
+}
+
+-(void)setupManagers
+{
+    self.loginFetchManager = [AFHTTPRequestOperationManager manager];
+    self.articleFetchManager = [AFHTTPRequestOperationManager manager];
+    self.savedPagesFetchManager = [AFHTTPRequestOperationManager manager];
+    self.searchResultsFetchManager = [AFHTTPRequestOperationManager manager];
+    self.sectionWikiTextDownloadManager = [AFHTTPRequestOperationManager manager];
+    self.sectionWikiTextUploadManager = [AFHTTPRequestOperationManager manager];
+    self.sectionPreviewHtmlFetchManager = [AFHTTPRequestOperationManager manager];
+    self.languageLinksFetcher = [AFHTTPRequestOperationManager manager];
+    self.zeroRatedMessageFetchManager = [AFHTTPRequestOperationManager manager];
+    self.accountCreationFetchManager = [AFHTTPRequestOperationManager manager];
+    self.pageHistoryFetchManager = [AFHTTPRequestOperationManager manager];
+    self.assetsFetchManager = [AFHTTPRequestOperationManager manager];
+    self.nearbyFetchManager = [AFHTTPRequestOperationManager manager];
+}
+
+-(void)setRequestHeadersForManagers:(NSArray *)managers
+{
+    for (AFHTTPRequestOperationManager *manager in managers.copy) {
+        [self setRequestHeadersForManager:manager];
+    }
+}
+
+-(void)setDefaultSerializerForManagers:(NSArray *)managers
+{
+    // Set the responseSerializer to AFHTTPResponseSerializer, so that it will no longer
+    // try to parse the JSON - needed because we use some managers to fetch different
+    // content types, say, both nearby json api data *and* thumbnails. Thumb responses
+    // are not json! And some managers, like the assetsFetchManager don't retrieve json
+    // at all.
+    // From: http://stackoverflow.com/a/21621530
+    for (AFHTTPRequestOperationManager *manager in managers.copy) {
+        manager.responseSerializer = [AFHTTPResponseSerializer serializer];
+    }
+}
+
+-(void)setRequestHeadersForManager:(AFHTTPRequestOperationManager *)manager
+{
+    [manager.requestSerializer setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
+    [manager.requestSerializer setValue:[WikipediaAppUtils versionedUserAgent] forHTTPHeaderField:@"User-Agent"];
+
+    // x-www-form-urlencoded is default, so probably don't need it.
+    // See: http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1
+    //[manager.requestSerializer setValue:@"application/x-www-form-urlencoded; charset=UTF-8" forHTTPHeaderField:@"Content-Type"];
+}
+
+-(void)setupQMonitorLogging
+{
+    // Listen in on the Q's op counts to ensure they go away properly.
+    [self.articleFetchManager.operationQueue addObserver:self forKeyPath:@"operationCount" options:NSKeyValueObservingOptionNew context:nil];
+    [self.searchResultsFetchManager.operationQueue addObserver:self forKeyPath:@"operationCount" options:NSKeyValueObservingOptionNew context:nil];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
+{
+    if ([keyPath isEqualToString:@"operationCount"]) {
+        dispatch_async(dispatch_get_main_queue(), ^(){
+            NSLog(@"QUEUE OP COUNTS: Search %lu, Article %lu",
+                (unsigned long)self.searchResultsFetchManager.operationQueue.operationCount,
+                (unsigned long)self.articleFetchManager.operationQueue.operationCount
+            );
+        });
+    }
+}
+
+@end
diff --git a/wikipedia/Queues/QueuesSingleton.h b/wikipedia/Queues/QueuesSingleton.h
deleted file mode 100644
index 32712a2472a..00000000000
--- a/wikipedia/Queues/QueuesSingleton.h
+++ /dev/null
@@ -1,30 +0,0 @@
-//  Created by Monte Hurd on 12/6/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import <Foundation/Foundation.h>
-
-@interface QueuesSingleton : NSObject
-
-@property (strong, nonatomic) NSOperationQueue *loginQ;
-@property (strong, nonatomic) NSOperationQueue *articleRetrievalQ;
-@property (strong, nonatomic) NSOperationQueue *searchQ;
-@property (strong, nonatomic) NSOperationQueue *thumbnailQ;
-@property (strong, nonatomic) NSOperationQueue *zeroRatedMessageStringQ;
-
-@property (strong, nonatomic) NSOperationQueue *sectionWikiTextDownloadQ;
-@property (strong, nonatomic) NSOperationQueue *sectionWikiTextUploadQ;
-@property (strong, nonatomic) NSOperationQueue *sectionWikiTextPreviewQ;
-@property (strong, nonatomic) NSOperationQueue *langLinksQ;
-@property (strong, nonatomic) NSOperationQueue *accountCreationQ;
-
-@property (strong, nonatomic) NSOperationQueue *randomArticleQ;
-
-@property (strong, nonatomic) NSOperationQueue *eventLoggingQ;
-@property (strong, nonatomic) NSOperationQueue *pageHistoryQ;
-
-@property (strong, nonatomic) NSOperationQueue *assetsFileSyncQ;
-@property (strong, nonatomic) NSOperationQueue *nearbyQ;
-
-+ (QueuesSingleton *)sharedInstance;
-
-@end
diff --git a/wikipedia/Queues/QueuesSingleton.m b/wikipedia/Queues/QueuesSingleton.m
deleted file mode 100644
index edb7cf9862c..00000000000
--- a/wikipedia/Queues/QueuesSingleton.m
+++ /dev/null
@@ -1,63 +0,0 @@
-//  Created by Monte Hurd on 12/6/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "QueuesSingleton.h"
-
-@implementation QueuesSingleton
-
-+ (QueuesSingleton *)sharedInstance
-{
-    static dispatch_once_t once;
-    static id sharedInstance;
-    dispatch_once(&once, ^{
-        sharedInstance = [[self alloc] init];
-    });
-    return sharedInstance;
-}
-
-- (id)init
-{
-    self = [super init];
-    if (self) {
-        self.loginQ = [[NSOperationQueue alloc] init];
-        self.articleRetrievalQ = [[NSOperationQueue alloc] init];
-        self.searchQ = [[NSOperationQueue alloc] init];
-        self.thumbnailQ = [[NSOperationQueue alloc] init];
-        self.sectionWikiTextDownloadQ = [[NSOperationQueue alloc] init];
-        self.sectionWikiTextUploadQ = [[NSOperationQueue alloc] init];
-        self.sectionWikiTextPreviewQ = [[NSOperationQueue alloc] init];
-        self.langLinksQ = [[NSOperationQueue alloc] init];
-        self.zeroRatedMessageStringQ = [[NSOperationQueue alloc] init];
-        self.accountCreationQ = [[NSOperationQueue alloc] init];
-        self.randomArticleQ = [[NSOperationQueue alloc] init];
-        self.eventLoggingQ = [[NSOperationQueue alloc] init];
-        self.pageHistoryQ = [[NSOperationQueue alloc] init];
-        self.assetsFileSyncQ = [[NSOperationQueue alloc] init];
-        self.nearbyQ = [[NSOperationQueue alloc] init];
-        //[self setupQMonitorLogging];
-    }
-    return self;
-}
-
--(void)setupQMonitorLogging
-{
-    // Listen in on the Q's op counts to ensure they go away properly.
-    [self.articleRetrievalQ addObserver:self forKeyPath:@"operationCount" options:NSKeyValueObservingOptionNew context:nil];
-    [self.searchQ addObserver:self forKeyPath:@"operationCount" options:NSKeyValueObservingOptionNew context:nil];
-    [self.thumbnailQ addObserver:self forKeyPath:@"operationCount" options:NSKeyValueObservingOptionNew context:nil];
-}
-
-- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
-{
-    if ([keyPath isEqualToString:@"operationCount"]) {
-        dispatch_async(dispatch_get_main_queue(), ^(){
-            NSLog(@"QUEUE OP COUNTS: Search %lu, Thumb %lu, Article %lu",
-                (unsigned long)self.searchQ.operationCount,
-                (unsigned long)self.thumbnailQ.operationCount,
-                (unsigned long)self.articleRetrievalQ.operationCount
-            );
-        });
-    }
-}
-
-@end
diff --git a/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.h b/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.h
index 41e1e5eb57f..bae76613d86 100644
--- a/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.h	
+++ b/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.h	
@@ -2,11 +2,11 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
 #import "CaptchaViewController.h"
 #import "CreateAccountFunnel.h"
+#import "FetcherBase.h"
 
-@interface AccountCreationViewController : UIViewController <NetworkOpDelegate, CaptchaViewControllerRefresh, UITextFieldDelegate, UIScrollViewDelegate>
+@interface AccountCreationViewController : UIViewController <FetchFinishedDelegate, CaptchaViewControllerRefresh, UITextFieldDelegate, UIScrollViewDelegate>
 
 @property (weak, nonatomic) IBOutlet UITextField *usernameField;
 @property (weak, nonatomic) IBOutlet UITextField *passwordField;
diff --git a/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.m b/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.m
index 9994329ffe2..7fc5a7c35f8 100644
--- a/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.m	
+++ b/wikipedia/View Controllers/AccountCreation/AccountCreationViewController.m	
@@ -7,9 +7,9 @@
 #import "QueuesSingleton.h"
 #import "SessionSingleton.h"
 #import "UIViewController+Alert.h"
-#import "AccountCreationOp.h"
-#import "AccountCreationTokenOp.h"
-#import "CaptchaResetOp.h"
+#import "AccountCreationTokenFetcher.h"
+#import "AccountCreator.h"
+#import "CaptchaResetter.h"
 #import "UIScrollView+ScrollSubviewToLocation.h"
 #import "LoginViewController.h"
 #import "WMF_Colors.h"
@@ -36,7 +36,6 @@ @interface AccountCreationViewController ()
 @property (nonatomic) BOOL showCaptchaContainer;
 @property (strong, nonatomic) NSString *captchaId;
 @property (strong, nonatomic) NSString *captchaUrl;
-@property (strong, nonatomic) NSString *token;
 @property (weak, nonatomic) IBOutlet PaddedLabel *loginButton;
 @property (weak, nonatomic) IBOutlet PaddedLabel *titleLabel;
 @property (weak, nonatomic) IBOutlet NSLayoutConstraint *usernameUnderlineHeight;
@@ -47,6 +46,8 @@ @interface AccountCreationViewController ()
 
 @property (weak, nonatomic) IBOutlet UIView *createAccountContainerView;
 
+@property (strong, nonatomic) LoginViewController *detachedloginVC;
+
 @end
 
 @implementation AccountCreationViewController
@@ -109,7 +110,6 @@ - (void)viewDidLoad
 
     self.captchaId = @"";
     self.captchaUrl = @"";
-    self.token = @"";
     self.scrollView.delegate = self;
     self.navigationItem.hidesBackButton = YES;
     
@@ -376,42 +376,11 @@ - (void)reloadCaptchaPushed:(id)sender
 
     [self showAlert:MWLocalizedString(@"account-creation-captcha-obtaining", nil) type:ALERT_TYPE_TOP duration:1];
 
-    CaptchaResetOp *captchaResetOp =
-    [[CaptchaResetOp alloc] initWithDomain: [SessionSingleton sharedInstance].domain
-                           completionBlock: ^(NSDictionary *result){
-                               
-                               self.captchaId = result[@"index"];
-                               
-                               NSString *oldCaptchaUrl = self.captchaUrl;
-                               
-                               NSError *error = nil;
-                               NSRegularExpression *regex =
-                               [NSRegularExpression regularExpressionWithPattern: @"wpCaptchaId=([^&]*)"
-                                                                         options: NSRegularExpressionCaseInsensitive
-                                                                           error: &error];
-                               if (!error) {
-                                   NSString *newCaptchaUrl =
-                                   [regex stringByReplacingMatchesInString: oldCaptchaUrl
-                                                                   options: 0
-                                                                     range: NSMakeRange(0, [oldCaptchaUrl length])
-                                                              withTemplate: [NSString stringWithFormat:@"wpCaptchaId=%@", self.captchaId]];
-                                   
-                                   self.captchaUrl = newCaptchaUrl;
-                               }
-                               
-                           } cancelledBlock: ^(NSError *error){
-                               
-                               [self fadeAlert];
-                               
-                           } errorBlock: ^(NSError *error){
-                               [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                               
-                           }];
+    [[QueuesSingleton sharedInstance].accountCreationFetchManager.operationQueue cancelAllOperations];
     
-    captchaResetOp.delegate = self;
-
-    [[QueuesSingleton sharedInstance].accountCreationQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].accountCreationQ addOperation:captchaResetOp];
+    (void)[[CaptchaResetter alloc] initAndResetCaptchaForDomain: [SessionSingleton sharedInstance].domain
+                                                    withManager: [QueuesSingleton sharedInstance].accountCreationFetchManager
+                                             thenNotifyDelegate: self];
 }
 
 // Handle nav bar taps.
@@ -442,20 +411,20 @@ - (void)navItemTappedNotification:(NSNotification *)notification
 
 -(void)login
 {
-    id onboardingVC = [self searchModalsForViewControllerOfClass:[OnboardingViewController class]];
-
     // Create detached loginVC just for logging in.
-    LoginViewController *loginVC = [[LoginViewController alloc] init];
+    self.detachedloginVC = [[LoginViewController alloc] init];
     
     [self showAlert:MWLocalizedString(@"account-creation-logging-in", nil) type:ALERT_TYPE_TOP duration:-1];
     
-    [loginVC loginWithUserName:self.usernameField.text password:self.passwordField.text onSuccess:^{
+    [self.detachedloginVC loginWithUserName:self.usernameField.text password:self.passwordField.text onSuccess:^{
 
         NSString *loggedInMessage = MWLocalizedString(@"main-menu-account-title-logged-in", nil);
         loggedInMessage = [loggedInMessage stringByReplacingOccurrencesOfString: @"$1"
                                                                      withString: self.usernameField.text];
         [self showAlert:loggedInMessage type:ALERT_TYPE_TOP duration:-1];
 
+        id onboardingVC = [self searchModalsForViewControllerOfClass:[OnboardingViewController class]];
+
         if (onboardingVC) {
             [self popModalToRoot];
         }else{
@@ -469,97 +438,116 @@ -(void)login
     }];
 }
 
--(void)save
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
 {
-    static BOOL isAleadySaving = NO;
-    if (isAleadySaving) return;
-    isAleadySaving = YES;
+    if ([sender isKindOfClass:[AccountCreationTokenFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:
+                //NSLog(@"userData = %@", userData);
+                // Pull data for all the fields which were originally passed to the token
+                // fetcher from the userData returned from it. This is to make extra sure
+                // the account creation is working with the same data as the token retrieval.
+                (void)[[AccountCreator alloc] initAndCreateAccountForUserName: [sender userName]
+                                                                             realName: @""
+                                                                               domain: [sender domain]
+                                                                             password: [sender password]
+                                                                                email: [sender email]
+                                                                            captchaId: self.captchaId
+                                                                          captchaWord: self.captchaViewController.captchaTextBox.text
+                                                                                token: [sender token]
+                                                                          withManager: [QueuesSingleton sharedInstance].accountCreationFetchManager
+                                                                   thenNotifyDelegate: self];
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                [self.funnel logError:error.localizedDescription];
+                break;
+        }
+    }
+
+    if ([sender isKindOfClass:[AccountCreator class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:
+                [self.funnel logSuccess];
+                [self showAlert:userData type:ALERT_TYPE_TOP duration:1];
+                [self performSelector:@selector(login) withObject:nil afterDelay:0.6f];
+                //isAleadySaving = NO;
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                [self.funnel logError:error.localizedDescription];
+
+                if (error.code == ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA) {
+                    self.captchaId = error.userInfo[@"captchaId"];
+                    self.captchaUrl = error.userInfo[@"captchaUrl"];
+                    self.showCaptchaContainer = YES;
+                }
+                break;
+        }
+    }
 
+    if ([sender isKindOfClass:[CaptchaResetter class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                
+                self.captchaId = userData[@"index"];
+                
+                NSString *oldCaptchaUrl = self.captchaUrl;
+                
+                NSError *error = nil;
+                NSRegularExpression *regex =
+                [NSRegularExpression regularExpressionWithPattern: @"wpCaptchaId=([^&]*)"
+                                                          options: NSRegularExpressionCaseInsensitive
+                                                            error: &error];
+                if (!error) {
+                    NSString *newCaptchaUrl =
+                    [regex stringByReplacingMatchesInString: oldCaptchaUrl
+                                                    options: 0
+                                                      range: NSMakeRange(0, [oldCaptchaUrl length])
+                                               withTemplate: [NSString stringWithFormat:@"wpCaptchaId=%@", self.captchaId]];
+                    
+                    self.captchaUrl = newCaptchaUrl;
+                }
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+        }
+    }
+}
+
+-(void)save
+{
     // Verify passwords fields match.
     if (![self.passwordField.text isEqualToString:self.passwordRepeatField.text]) {
         [self showAlert:MWLocalizedString(@"account-creation-passwords-mismatched", nil) type:ALERT_TYPE_TOP duration:-1];
-        isAleadySaving = NO;
         return;
     }
 
     // Save!
     [self showAlert:MWLocalizedString(@"account-creation-saving", nil) type:ALERT_TYPE_TOP duration:-1];
 
-    AccountCreationOp *accountCreationOp =
-    [[AccountCreationOp alloc] initWithDomain: [SessionSingleton sharedInstance].domain
-                                     userName: self.usernameField.text
-                                     password: self.passwordField.text
-                                     realName: @""
-                                        email: self.emailField.text
-                                    captchaId: self.captchaId
-                                  captchaWord: self.captchaViewController.captchaTextBox.text
-     
-                              completionBlock: ^(NSString *result){
-                                  
-                                  //NSLog(@"AccountCreationOp result = %@", result);
-                                  
-                                  [self.funnel logSuccess];
-
-                                  dispatch_async(dispatch_get_main_queue(), ^(){
-                                      [self showAlert:result type:ALERT_TYPE_TOP duration:1];
-                                      [self performSelector:@selector(login) withObject:nil afterDelay:0.6f];
-                                      isAleadySaving = NO;
-                                  });
-                                  
-                              } cancelledBlock: ^(NSError *error){
-                                  
-                                  [self fadeAlert];
-                                  isAleadySaving = NO;
-                                  
-                              } errorBlock: ^(NSError *error){
-                                  [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-
-                                  [self.funnel logError:error.localizedDescription];
-
-                                  switch (error.code) {
-                                      case ACCOUNT_CREATION_ERROR_NEEDS_CAPTCHA:{
-                                          self.captchaId = error.userInfo[@"captchaId"];
-                                          dispatch_async(dispatch_get_main_queue(), ^(){
-                                              self.captchaUrl = error.userInfo[@"captchaUrl"];
-                                              self.showCaptchaContainer = YES;
-                                          });
-                                      }
-                                          break;
-                                      default:
-                                          break;
-                                  }
-                                  
-                                  isAleadySaving = NO;
-                              }];
-
-    AccountCreationTokenOp *accountCreationTokenOp =
-    [[AccountCreationTokenOp alloc] initWithDomain: [SessionSingleton sharedInstance].domain
-                                          userName: self.usernameField.text
-                                          password: self.passwordField.text
-                                   completionBlock: ^(NSString *token){
-                                       accountCreationOp.token = token;
-                                   }
-                                    cancelledBlock: ^(NSError *error){
-                                        [self fadeAlert];
-                                        isAleadySaving = NO;
-                                    }
-                                        errorBlock: ^(NSError *error){
-                                            [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                                            isAleadySaving = NO;
-                                        }];
-
-    accountCreationOp.delegate = self;
-    accountCreationTokenOp.delegate = self;
-
-    // The accountCreationTokenOp needs to succeed before the accountCreationOp can begin.
-    [accountCreationOp addDependency:accountCreationTokenOp];
-
-    [[QueuesSingleton sharedInstance].accountCreationQ cancelAllOperations];
-    
-    [QueuesSingleton sharedInstance].loginQ.suspended = YES;
-    [[QueuesSingleton sharedInstance].accountCreationQ addOperation:accountCreationTokenOp];
-    [[QueuesSingleton sharedInstance].accountCreationQ addOperation:accountCreationOp];
-    [QueuesSingleton sharedInstance].loginQ.suspended = NO;
+    [[QueuesSingleton sharedInstance].accountCreationFetchManager.operationQueue cancelAllOperations];
+
+    (void)[[AccountCreationTokenFetcher alloc] initAndFetchTokenForDomain: [SessionSingleton sharedInstance].domain
+                                                                 userName: self.usernameField.text
+                                                                 password: self.passwordField.text
+                                                                    email: self.emailField.text
+                                                              withManager: [QueuesSingleton sharedInstance].accountCreationFetchManager
+                                                       thenNotifyDelegate: self];
 }
 
 - (void)didReceiveMemoryWarning
diff --git a/wikipedia/View Controllers/Credits/CreditsViewController.m b/wikipedia/View Controllers/Credits/CreditsViewController.m
index 64058371116..02c5e1eb1c8 100644
--- a/wikipedia/View Controllers/Credits/CreditsViewController.m	
+++ b/wikipedia/View Controllers/Credits/CreditsViewController.m	
@@ -19,6 +19,8 @@
 #define URL_APP_WIKIFONT @"https://github.com/munmay/WikiFont"
 #define URL_APP_HPPLE @"https://github.com/topfunky/hpple"
 #define URL_APP_NSDATE @"https://github.com/erica/NSDate-Extensions"
+#define URL_APP_AFNETWORKING @"https://github.com/AFNetworking/AFNetworking"
+#define URL_APP_COCOAPODS @"http://cocoapods.org"
 
 #define MENU_ICON_COLOR [UIColor blackColor]
 #define MENU_ICON_FONT_SIZE 24
@@ -31,6 +33,8 @@
     CREDITS_ROW_INDEX_REPO_WIKIFONT,
     CREDITS_ROW_INDEX_REPO_HPPLE,
     CREDITS_ROW_INDEX_REPO_NSDATE,
+    CREDITS_ROW_INDEX_REPO_AFNETWORKING,
+    CREDITS_ROW_INDEX_REPO_COCOAPODS,
     CREDITS_ROW_INDEX_HEADING_BLANK
 } CeditsRowIndex;
 
@@ -260,6 +264,22 @@ -(void)setRowData
           @"url": URL_APP_NSDATE,
           }.mutableCopy
       ,
+      @{
+          @"title": @"AFNetworking",
+          @"tag": @(CREDITS_ROW_INDEX_REPO_AFNETWORKING),
+          @"icon": ltrSafeCaretCharacter,
+          @"type": @(ROW_TYPE_SELECTION),
+          @"url": URL_APP_AFNETWORKING,
+          }.mutableCopy
+      ,
+      @{
+          @"title": @"Cocoapods",
+          @"tag": @(CREDITS_ROW_INDEX_REPO_COCOAPODS),
+          @"icon": ltrSafeCaretCharacter,
+          @"type": @(ROW_TYPE_SELECTION),
+          @"url": URL_APP_COCOAPODS,
+          }.mutableCopy
+      ,
       @{
           @"title": @"",
           @"tag": @(CREDITS_ROW_INDEX_HEADING_BLANK),
diff --git a/wikipedia/View Controllers/Languages/LanguagesViewController.h b/wikipedia/View Controllers/Languages/LanguagesViewController.h
index cf714381f5d..299ed87b670 100644
--- a/wikipedia/View Controllers/Languages/LanguagesViewController.h	
+++ b/wikipedia/View Controllers/Languages/LanguagesViewController.h	
@@ -3,8 +3,9 @@
 
 #import <UIKit/UIKit.h>
 #import "TopMenuViewController.h"
+#import "FetcherBase.h"
 
-@interface LanguagesViewController : UIViewController <UITableViewDataSource, UITableViewDelegate>
+@interface LanguagesViewController : UIViewController <UITableViewDataSource, UITableViewDelegate, FetchFinishedDelegate>
 
 @property (nonatomic) BOOL downloadLanguagesForCurrentArticle;
 
diff --git a/wikipedia/View Controllers/Languages/LanguagesViewController.m b/wikipedia/View Controllers/Languages/LanguagesViewController.m
index afe89172937..4ef6f17a917 100644
--- a/wikipedia/View Controllers/Languages/LanguagesViewController.m	
+++ b/wikipedia/View Controllers/Languages/LanguagesViewController.m	
@@ -4,7 +4,7 @@
 #import "LanguagesViewController.h"
 #import "WikipediaAppUtils.h"
 #import "SessionSingleton.h"
-#import "DownloadLangLinksOp.h"
+#import "LanguageLinksFetcher.h"
 #import "QueuesSingleton.h"
 #import "LanguagesCell.h"
 #import "Defines.h"
@@ -85,7 +85,7 @@ -(void)viewWillDisappear:(BOOL)animated
 {
     [self.filterTextField resignFirstResponder];
 
-    [[QueuesSingleton sharedInstance].langLinksQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].languageLinksFetcher.operationQueue cancelAllOperations];
 
     [[NSNotificationCenter defaultCenter] removeObserver: self
                                                     name: @"NavItemTapped"
@@ -175,37 +175,43 @@ -(void)reloadTableDataFiltered
 
 #pragma mark - Article lang list download op
 
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
+{
+    if ([sender isKindOfClass:[LanguageLinksFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                //[self showAlert:@"Language links loaded."];
+                [self fadeAlert];
+                
+                self.languagesData = userData;
+                [self reloadTableDataFiltered];
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+        }
+    }
+}
+
 -(void)downloadLangLinkData
 {
     [self showAlert:MWLocalizedString(@"article-languages-downloading", nil) type:ALERT_TYPE_TOP duration:-1];
     AssetsFile *assetsFile = [[AssetsFile alloc] initWithFile:ASSETS_FILE_LANGUAGES];
 
-    DownloadLangLinksOp *langLinksOp =
-    [[DownloadLangLinksOp alloc] initForPageTitle: [SessionSingleton sharedInstance].currentArticleTitle
-                                           domain: [SessionSingleton sharedInstance].currentArticleDomain
-                                     allLanguages: assetsFile.array
-                                  completionBlock: ^(NSArray *result){
-                                      
-                                      [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-                                          //[self showAlert:@"Language links loaded."];
-                                          [self fadeAlert];
-
-                                          self.languagesData = result;
-                                          [self reloadTableDataFiltered];
-                                      }];
-                                      
-                                  } cancelledBlock: ^(NSError *error){
-                                      //NSString *errorMsg = error.localizedDescription;
-                                      [self fadeAlert];
-                                      
-                                  } errorBlock: ^(NSError *error){
-                                      //NSString *errorMsg = error.localizedDescription;
-                                      [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                                      
-                                  }];
+    [[QueuesSingleton sharedInstance].languageLinksFetcher.operationQueue cancelAllOperations];
     
-    [[QueuesSingleton sharedInstance].langLinksQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].langLinksQ addOperation:langLinksOp];
+    (void)[[LanguageLinksFetcher alloc] initAndFetchLanguageLinksForPageTitle:[SessionSingleton sharedInstance].currentArticleTitle
+                                                                       domain:[SessionSingleton sharedInstance].currentArticleDomain
+                                                                 allLanguages:assetsFile.array
+                                                                  withManager:[QueuesSingleton sharedInstance].languageLinksFetcher
+                                                           thenNotifyDelegate:self];
 }
 
 #pragma mark - Table protocol methods
diff --git a/wikipedia/View Controllers/Login/LoginViewController.h b/wikipedia/View Controllers/Login/LoginViewController.h
index 85c686245e9..44c1c5df7aa 100644
--- a/wikipedia/View Controllers/Login/LoginViewController.h	
+++ b/wikipedia/View Controllers/Login/LoginViewController.h	
@@ -3,10 +3,10 @@
 
 #import <UIKit/UIKit.h>
 
-#import "MWNetworkOp.h"
 #import "LoginFunnel.h"
+#import "FetcherBase.h"
 
-@interface LoginViewController : UIViewController <NetworkOpDelegate>
+@interface LoginViewController : UIViewController <FetchFinishedDelegate>
 
 - (IBAction)createAccountButtonPushed:(id)sender;
 
diff --git a/wikipedia/View Controllers/Login/LoginViewController.m b/wikipedia/View Controllers/Login/LoginViewController.m
index f406b411b9e..80a7f9615d4 100644
--- a/wikipedia/View Controllers/Login/LoginViewController.m	
+++ b/wikipedia/View Controllers/Login/LoginViewController.m	
@@ -5,8 +5,8 @@
 #import "LoginViewController.h"
 #import "CenterNavController.h"
 #import "QueuesSingleton.h"
-#import "LoginTokenOp.h"
-#import "LoginOp.h"
+#import "LoginTokenFetcher.h"
+#import "AccountLogin.h"
 #import "SessionSingleton.h"
 #import "UIViewController+Alert.h"
 #import "NSHTTPCookieStorage+CloneCookie.h"
@@ -42,6 +42,9 @@ @interface LoginViewController (){
 
 @property (weak, nonatomic) IBOutlet UIView *loginContainerView;
 
+@property (nonatomic, copy) void (^successBlock)();
+@property (nonatomic, copy) void (^failBlock)();
+
 @end
 
 @implementation LoginViewController
@@ -61,6 +64,9 @@ - (void)viewDidLoad
     [super viewDidLoad];
     // Do any additional setup after loading the view.
 
+    self.successBlock = ^(){};
+    self.failBlock = ^(){};
+
     self.titleLabel.font = [UIFont boldSystemFontOfSize:23.0f * MENUS_SCALE_MULTIPLIER];
     self.usernameField.font = [UIFont boldSystemFontOfSize:18.0f * MENUS_SCALE_MULTIPLIER];
     self.passwordField.font = [UIFont boldSystemFontOfSize:18.0f * MENUS_SCALE_MULTIPLIER];
@@ -114,7 +120,21 @@ - (void)viewDidLoad
     self.usernameField.textAlignment = [WikipediaAppUtils rtlSafeAlignment];
     self.passwordField.textAlignment = [WikipediaAppUtils rtlSafeAlignment];
 
-    [self adjustConstraintsScaleForViews:@[self.loginContainerView, self.titleLabel, self.usernameField, self.passwordField, self.createAccountButton]];
+    if (self.loginContainerView) {
+        // Only do this if self.loginContainerView is not nil. This is because the
+        // account areation view controller can create a "detached" instance of the
+        // login view controller after it creates an account - which it uses to
+        // login to the new account. (This detached object object won't have views
+        // so the array below will cause a crash.)
+        [self adjustConstraintsScaleForViews:
+         @[
+           self.loginContainerView,
+           self.titleLabel,
+           self.usernameField,
+           self.passwordField,
+           self.createAccountButton]
+         ];
+    }
 }
 
 -(NSAttributedString *)getAttributedPlaceholderForString:(NSString *)string
@@ -224,6 +244,80 @@ - (void)didReceiveMemoryWarning
     // Dispose of any resources that can be recreated.
 }
 
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
+{
+    if ([sender isKindOfClass:[LoginTokenFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                
+                (void)[[AccountLogin alloc] initAndLoginForDomain: [sender domain]
+                                                         userName: [sender userName]
+                                                         password: [sender password]
+                                                            token: [sender token]
+                                                      withManager: [QueuesSingleton sharedInstance].loginFetchManager
+                                               thenNotifyDelegate: self];
+
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+
+                [self fadeAlert];
+                self.failBlock();
+                
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                self.failBlock();
+                [self.funnel logError:error.localizedDescription];
+                
+                break;
+        }
+    }
+
+    if ([sender isKindOfClass:[AccountLogin class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+
+                //NSLog(@"%@", userData);
+                NSString *loginStatus = userData[@"login"][@"result"];
+                
+                // Login credentials should only be placed in the keychain if they've been authenticated.
+                NSString *normalizedUserName = userData[@"login"][@"lgusername"];
+                [SessionSingleton sharedInstance].keychainCredentials.userName = normalizedUserName;
+                [SessionSingleton sharedInstance].keychainCredentials.password = userData[@"password"];
+                
+                //NSString *result = loginResult[@"login"][@"result"];
+                [self showAlert:loginStatus type:ALERT_TYPE_TOP duration:-1];
+                
+                self.successBlock();
+                
+                [self cloneSessionCookies];
+                //printCookies();
+                
+                [self.funnel logSuccess];
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                self.failBlock();
+                
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                self.failBlock();
+                [self.funnel logError:error.localizedDescription];
+
+                break;
+        }
+    }
+}
+
 -(void)loginWithUserName: (NSString *)userName
                 password: (NSString *)password
                onSuccess: (void (^)(void))successBlock
@@ -235,9 +329,9 @@ -(void)loginWithUserName: (NSString *)userName
     if (!userName) userName = @"";
     if (!password) password = @"";
 
-    if (!successBlock) successBlock = ^(){};
-    if (!failBlock) failBlock = ^(){};
-
+    self.successBlock = (!successBlock) ? ^(){} : successBlock;
+    self.failBlock = (!failBlock) ? ^(){} : failBlock;
+    
     /*
     void (^printCookies)() =  ^void(){
         NSLog(@"\n\n\n\n\n\n\n\n\n\n");
@@ -249,82 +343,13 @@ -(void)loginWithUserName: (NSString *)userName
      */
     
     //[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
-    
-    LoginOp *loginOp =
-    [[LoginOp alloc] initWithUsername: userName
-                             password: password
-                               domain: [SessionSingleton sharedInstance].domain
-                      completionBlock: ^(NSDictionary *loginResult){
-                          
-                          NSLog(@"%@", loginResult);
-                          NSString *loginStatus = loginResult[@"login"][@"result"];
-                          
-                          // Login credentials should only be placed in the keychain if they've been authenticated.
-                          NSString *normalizedUserName = loginResult[@"login"][@"lgusername"];
-                          [SessionSingleton sharedInstance].keychainCredentials.userName = normalizedUserName;
-                          [SessionSingleton sharedInstance].keychainCredentials.password = password;
-                          
-                          //NSString *result = loginResult[@"login"][@"result"];
-                          [self showAlert:loginStatus type:ALERT_TYPE_TOP duration:-1];
-                          
-                          [[NSOperationQueue mainQueue] addOperationWithBlock:successBlock];
-                          
-                          [self cloneSessionCookies];
-                          //printCookies();
-
-                          [self.funnel logSuccess];
-                          
-                      } cancelledBlock: ^(NSError *error){
-                          
-                          [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-
-                          [[NSOperationQueue mainQueue] addOperationWithBlock:failBlock];
-
-                          
-                      } errorBlock: ^(NSError *error){
-                          
-                          [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-
-                          [[NSOperationQueue mainQueue] addOperationWithBlock:failBlock];
-
-
-                          [self.funnel logError:error.localizedDescription];
-                      }];
-    
-    LoginTokenOp *loginTokenOp =
-    [[LoginTokenOp alloc] initWithUsername: userName
-                                  password: password
-                                    domain: [SessionSingleton sharedInstance].domain
-                           completionBlock: ^(NSString *tokenRetrieved){
-                               
-                               NSLog(@"loginTokenOp token = %@", tokenRetrieved);
-                               loginOp.token = tokenRetrieved;
-                           } cancelledBlock: ^(NSError *error){
-                               
-                               [self fadeAlert];
-
-                               [[NSOperationQueue mainQueue] addOperationWithBlock:failBlock];
-                               
-                           } errorBlock: ^(NSError *error){
-                               
-                               [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-
-                               [[NSOperationQueue mainQueue] addOperationWithBlock:failBlock];
-
-                               [self.funnel logError:error.localizedDescription];
-                           }];
-    
-    loginTokenOp.delegate = self;
-    loginOp.delegate = self;
-    
-    // The loginTokenOp needs to succeed before the loginOp can begin.
-    [loginOp addDependency:loginTokenOp];
-    
-    [[QueuesSingleton sharedInstance].loginQ cancelAllOperations];
-    [QueuesSingleton sharedInstance].loginQ.suspended = YES;
-    [[QueuesSingleton sharedInstance].loginQ addOperation:loginTokenOp];
-    [[QueuesSingleton sharedInstance].loginQ addOperation:loginOp];
-    [QueuesSingleton sharedInstance].loginQ.suspended = NO;
+
+    [[QueuesSingleton sharedInstance].loginFetchManager.operationQueue cancelAllOperations];
+    (void)[[LoginTokenFetcher alloc] initAndFetchTokenForDomain: [SessionSingleton sharedInstance].domain
+                                                       userName: userName
+                                                       password: password
+                                                    withManager: [QueuesSingleton sharedInstance].loginFetchManager
+                                             thenNotifyDelegate: self];
 }
 
 -(void)cloneSessionCookies
diff --git a/wikipedia/View Controllers/Navigation/Center/CenterNavController.h b/wikipedia/View Controllers/Navigation/Center/CenterNavController.h
index 89f22eb47b4..0838105cb6a 100644
--- a/wikipedia/View Controllers/Navigation/Center/CenterNavController.h	
+++ b/wikipedia/View Controllers/Navigation/Center/CenterNavController.h	
@@ -1,8 +1,9 @@
 //  Created by Monte Hurd on 12/16/13.
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
-#include "SectionEditorViewController.h"
-#include "MWPageTitle.h"
+#import "SectionEditorViewController.h"
+#import "MWPageTitle.h"
+#import "FetcherBase.h"
 
 typedef enum {
     DISCOVERY_METHOD_SEARCH,
@@ -11,7 +12,7 @@ typedef enum {
     DISCOVERY_METHOD_BACKFORWARD
 } ArticleDiscoveryMethod;
 
-@interface CenterNavController : UINavigationController <UINavigationControllerDelegate>
+@interface CenterNavController : UINavigationController <UINavigationControllerDelegate, FetchFinishedDelegate>
 
 @property (nonatomic, readonly) BOOL isEditorOnNavstack;
 @property (nonatomic, readonly) SectionEditorViewController *editor;
@@ -25,6 +26,7 @@ typedef enum {
 
 -(void)loadTodaysArticle;
 -(void)loadTodaysArticleIfNoCoreDataForCurrentArticle;
+-(void)loadRandomArticle;
 
 -(void) promptFirstTimeZeroOnWithTitleIfAppropriate:(NSString *) title;
 -(void) promptZeroOff;
diff --git a/wikipedia/View Controllers/Navigation/Center/CenterNavController.m b/wikipedia/View Controllers/Navigation/Center/CenterNavController.m
index 54753aa96fb..f93edadac25 100644
--- a/wikipedia/View Controllers/Navigation/Center/CenterNavController.m	
+++ b/wikipedia/View Controllers/Navigation/Center/CenterNavController.m	
@@ -4,23 +4,19 @@
 #import "CenterNavController.h"
 #import "Defines.h"
 #import "WikipediaAppUtils.h"
-
 #import "UINavigationController+SearchNavStack.h"
-
 #import "SessionSingleton.h"
 #import "WebViewController.h"
 #import "SectionEditorViewController.h"
-
 #import "RootViewController.h"
 #import "TopMenuViewController.h"
 #import "TopMenuContainerView.h"
-
 #import "ArticleDataContextSingleton.h"
 #import "NSManagedObjectContext+SimpleFetch.h"
+#import "QueuesSingleton.h"
+#import "RandomArticleFetcher.h"
 
-@interface CenterNavController (){
-
-}
+@interface CenterNavController ()
 
 @property (strong, nonatomic) NSString *wikipediaZeroLearnMoreExternalUrl;
 
@@ -217,4 +213,42 @@ -(void)loadTodaysArticleIfNoCoreDataForCurrentArticle
     }
 }
 
+-(void)loadRandomArticle
+{
+    [[QueuesSingleton sharedInstance].articleFetchManager.operationQueue cancelAllOperations];
+
+    (void)[[RandomArticleFetcher alloc] initAndFetchRandomArticleForDomain: [SessionSingleton sharedInstance].domain
+                                                               withManager: [QueuesSingleton sharedInstance].articleFetchManager
+                                                        thenNotifyDelegate: self];
+}
+
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
+{
+    if ([sender isKindOfClass:[RandomArticleFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                NSString *title = (NSString *)userData;
+                if (title) {
+                    MWPageTitle *pageTitle = [MWPageTitle titleWithString:title];
+                    [NAV loadArticleWithTitle: pageTitle
+                                       domain: [SessionSingleton sharedInstance].domain
+                                     animated: YES
+                              discoveryMethod: DISCOVERY_METHOD_RANDOM
+                            invalidatingCache: NO
+                                   popToWebVC: NO]; // Don't pop - popModal has already been called.
+                }
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                //[NAV showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+        }
+    }
+}
+
 @end
diff --git a/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.h b/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.h
index 19977b82f5f..e34e27abd50 100644
--- a/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.h	
+++ b/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.h	
@@ -3,6 +3,7 @@
 
 #import <UIKit/UIKit.h>
 #import "TopMenuViewController.h"
+#import "FetcherBase.h"
 
 @interface PrimaryMenuViewController : UIViewController <UITableViewDataSource, UITableViewDelegate>
 
diff --git a/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.m b/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.m
index 9d4f6dd9961..9ae7b7c648b 100644
--- a/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.m	
+++ b/wikipedia/View Controllers/Navigation/Primary/PrimaryMenuViewController.m	
@@ -13,8 +13,6 @@
 #import "LoginViewController.h"
 #import "PageHistoryViewController.h"
 #import "UIViewController+Alert.h"
-#import "QueuesSingleton.h"
-#import "DownloadTitlesForRandomArticlesOp.h"
 #import "TopMenuContainerView.h"
 #import "UIViewController+StatusBarHeight.h"
 #import "Defines.h"
@@ -101,8 +99,6 @@ -(void)viewWillAppear:(BOOL)animated
 
     [self setupTableData];
     [self.tableView reloadData];
-    
-    [[QueuesSingleton sharedInstance].randomArticleQ cancelAllOperations];
 }
 
 -(void)viewWillDisappear:(BOOL)animated
@@ -277,7 +273,7 @@ -(void)performActionForItem:(PrimaryMenuItemTag)tag
             break;
         case PRIMARY_MENU_ITEM_RANDOM: {
             //[self showAlert:MWLocalizedString(@"fetching-random-article", nil) type:ALERT_TYPE_TOP duration:-1];
-            [self fetchRandomArticle];
+            [NAV loadRandomArticle];
             [self popModal];
         }
             break;
@@ -312,33 +308,6 @@ -(void)performActionForItem:(PrimaryMenuItemTag)tag
     }
 }
 
--(void)fetchRandomArticle {
-
-    [[QueuesSingleton sharedInstance].randomArticleQ cancelAllOperations];
-
-    DownloadTitlesForRandomArticlesOp *downloadTitlesForRandomArticlesOp =
-        [[DownloadTitlesForRandomArticlesOp alloc] initForDomain: [SessionSingleton sharedInstance].domain
-                                                 completionBlock: ^(NSString *title) {
-                                                     if (title) {
-                                                         MWPageTitle *pageTitle = [MWPageTitle titleWithString:title];
-                                                         dispatch_async(dispatch_get_main_queue(), ^(){
-                                                             [NAV loadArticleWithTitle: pageTitle
-                                                                                domain: [SessionSingleton sharedInstance].domain
-                                                                              animated: YES
-                                                                       discoveryMethod: DISCOVERY_METHOD_RANDOM
-                                                                     invalidatingCache: NO
-                                                                            popToWebVC: NO]; // Don't pop - popModal was already called above.
-                                                         });
-                                                     }
-                                                 } cancelledBlock: ^(NSError *errorCancel) {
-                                                    [self fadeAlert];
-                                                 } errorBlock: ^(NSError *error) {
-                                                    [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                                                 }];
-
-    [[QueuesSingleton sharedInstance].randomArticleQ addOperation:downloadTitlesForRandomArticlesOp];
-}
-
 /*
 #pragma mark - Navigation
 
diff --git a/wikipedia/View Controllers/Nearby/NearbyViewController.h b/wikipedia/View Controllers/Nearby/NearbyViewController.h
index 4627376b67b..f34c3741fa9 100644
--- a/wikipedia/View Controllers/Nearby/NearbyViewController.h	
+++ b/wikipedia/View Controllers/Nearby/NearbyViewController.h	
@@ -5,9 +5,9 @@
 #import <CoreLocation/CoreLocation.h>
 #import "PullToRefreshViewController.h"
 #import "TopMenuViewController.h"
-#import "MWNetworkOp.h"
+#import "FetcherBase.h"
 
-@interface NearbyViewController : PullToRefreshViewController <UITableViewDataSource, UITableViewDelegate, CLLocationManagerDelegate, UIActionSheetDelegate, NetworkOpDelegate>
+@interface NearbyViewController : PullToRefreshViewController <UITableViewDataSource, UITableViewDelegate, CLLocationManagerDelegate, UIActionSheetDelegate, FetchFinishedDelegate>
 
 @property (nonatomic) NavBarMode navBarMode;
 @property (weak, nonatomic) id truePresentingVC;
diff --git a/wikipedia/View Controllers/Nearby/NearbyViewController.m b/wikipedia/View Controllers/Nearby/NearbyViewController.m
index cd9fbfa2a94..14df0261bd1 100644
--- a/wikipedia/View Controllers/Nearby/NearbyViewController.m	
+++ b/wikipedia/View Controllers/Nearby/NearbyViewController.m	
@@ -3,7 +3,8 @@
 
 #import "NearbyViewController.h"
 #import "NearbyResultCell.h"
-#import "NearbyOp.h"
+#import "NearbyFetcher.h"
+#import "ThumbnailFetcher.h"
 #import "QueuesSingleton.h"
 #import "PaddedLabel.h"
 #import "WikipediaAppUtils.h"
@@ -15,39 +16,27 @@
 #import "UIViewController+Alert.h"
 #import "NSString+Extras.h"
 #import <MapKit/MapKit.h>
-#import "MWNetworkActivityIndicatorManager.h"
 #import "Defines.h"
 
 @interface NearbyViewController ()
 
 @property (strong, nonatomic) NSArray *nearbyDataArray;
-
 @property (strong, nonatomic) IBOutlet UITableView *tableView;
-
 @property (strong, nonatomic) CLLocationManager *locationManager;
-
 @property (strong, nonatomic) CLLocation *deviceLocation;
-
 @property (strong, nonatomic) CLHeading *deviceHeading;
-
 @property (nonatomic) dispatch_queue_t imageFetchQ;
-
 @property (strong, nonatomic) UIActionSheet *actionSheet;
-
 @property (strong, nonatomic) NSIndexPath *longPressIndexPath;
-
 @property (nonatomic) BOOL refreshNeeded;
-
 @property (nonatomic, strong) UIImage *placeholderImage;
-
 @property (nonatomic, strong) NSString *cachePath;
-
 @property (nonatomic) BOOL headingAvailable;
 
 @end
 
 /*
-    // NearbyOp returns data formatted as follows:
+    // NearbyFetcher returns data formatted as follows:
 
 	self.nearbyDataArray = (
         (
@@ -164,7 +153,7 @@ -(void)viewWillDisappear:(BOOL)animated
         [self.locationManager stopUpdatingHeading];
     }
 
-    [[QueuesSingleton sharedInstance].nearbyQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].nearbyFetchManager.operationQueue cancelAllOperations];
 
     [super viewWillDisappear:animated];
 
@@ -246,41 +235,90 @@ - (void)locationManager: (CLLocationManager *)manager didFailWithError:(NSError
     [self showAlert:errorMessage type:ALERT_TYPE_TOP duration:-1];
 }
 
--(void)downloadData
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
 {
-    CLLocationDegrees lat1 = self.deviceLocation.coordinate.latitude;
-    CLLocationDegrees long1 = self.deviceLocation.coordinate.longitude;
+    if ([sender isKindOfClass:[NearbyFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                
+                //[self showAlert:MWLocalizedString(@"nearby-loaded", nil) type:ALERT_TYPE_TOP duration:-1];
+                [self fadeAlert];
+                
+                self.nearbyDataArray = @[userData];
+                [self calculateDistances];
+                
+                NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey: @"distance.doubleValue"
+                                                                               ascending: YES];
+                NSArray *arraySortedByDistance = [self.nearbyDataArray[0] sortedArrayUsingDescriptors:@[sortDescriptor]];
+                self.nearbyDataArray = @[arraySortedByDistance];
+                
+                [self.tableView reloadData];
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                NSLog(@"nearby op error = %@", error);
+                //[self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                NSLog(@"nearby op error = %@", error);
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+        }
+    }
 
-    [self showAlert:MWLocalizedString(@"nearby-loading", nil) type:ALERT_TYPE_TOP duration:-1];
-    
-    NearbyOp *nearbyOp = [[NearbyOp alloc] initWithLatitude:lat1 longitude:long1 completionBlock:^(NSArray *result){
-        
-        [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-            //[self showAlert:MWLocalizedString(@"nearby-loaded", nil) type:ALERT_TYPE_TOP duration:-1];
-            [self fadeAlert];
-            
-            self.nearbyDataArray = @[result];
-            [self calculateDistances];
-
-            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey: @"distance.doubleValue"
-                                                                           ascending: YES];
-            NSArray *arraySortedByDistance = [self.nearbyDataArray[0] sortedArrayUsingDescriptors:@[sortDescriptor]];
-            self.nearbyDataArray = @[arraySortedByDistance];
-            
-            [self.tableView reloadData];
-        }];
+    if ([sender isKindOfClass:[ThumbnailFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
         
-    } cancelledBlock:^(NSError *error){
-        NSLog(@"nearby op error = %@", error);
-        //[self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                NSString *fileName = [[sender url] lastPathComponent];
+                
+                // See if cache file found, show it instead of downloading if found.
+                NSString *cacheFilePath = [self.cachePath stringByAppendingPathComponent:fileName];
+                
+                // Save cache file.
+                [userData writeToFile:cacheFilePath atomically:YES];
+                
+                // Then see if cell for this image name is still onscreen and set its image if so.
+                UIImage *image = [UIImage imageWithData:userData];
+                
+                // Check if cell still onscreen! This is important!
+                NSArray *visibleRowIndexPaths = [self.tableView indexPathsForVisibleRows];
+                for (NSIndexPath *thisIndexPath in visibleRowIndexPaths.copy) {
+                    NSArray *sectionData = self.nearbyDataArray[thisIndexPath.section];
+                    NSDictionary *rowData = sectionData[thisIndexPath.row];
+                    NSString *url = rowData[@"thumbnail"][@"source"];
+                    if ([url.lastPathComponent isEqualToString:fileName]) {
+                        NearbyResultCell *cell = (NearbyResultCell *)[self.tableView cellForRowAtIndexPath:thisIndexPath];
+                        [cell.thumbView setImage:image isPlaceHolder:NO];
+                        [cell setNeedsDisplay];
+                        break;
+                    }
+                }
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                
+                break;
+        }
+    }
+}
+
+-(void)downloadData
+{
+    [self showAlert:MWLocalizedString(@"nearby-loading", nil) type:ALERT_TYPE_TOP duration:-1];
 
-    } errorBlock:^(NSError *error){
-        NSLog(@"nearby op error = %@", error);
-        [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-    }];
-   
-    [[QueuesSingleton sharedInstance].nearbyQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].nearbyQ addOperation:nearbyOp];
+    [[QueuesSingleton sharedInstance].nearbyFetchManager.operationQueue cancelAllOperations];
+
+    (void)[[NearbyFetcher alloc] initAndFetchNearbyForLatitude: self.deviceLocation.coordinate.latitude
+                                                     longitude: self.deviceLocation.coordinate.longitude
+                                                   withManager: [QueuesSingleton sharedInstance].nearbyFetchManager
+                                            thenNotifyDelegate: self];
 }
 
 - (void)locationManager: (CLLocationManager *)manager
@@ -445,53 +483,17 @@ - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(N
 
     // See if cache file found, show it instead of downloading if found.
     NSString *cacheFilePath = [self.cachePath stringByAppendingPathComponent:fileName];
-    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:cacheFilePath isDirectory:NO];
+    BOOL isDirectory = NO;
+    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:cacheFilePath isDirectory:&isDirectory];
     if (fileExists) {
         [cell.thumbView setImage:[UIImage imageWithData:[NSData dataWithContentsOfFile:cacheFilePath]] isPlaceHolder:NO];
-        return cell;
+    }else{
+        // No thumb found so fetch it.
+        (void)[[ThumbnailFetcher alloc] initAndFetchThumbnailFromURL: url
+                                                         withManager: [QueuesSingleton sharedInstance].nearbyFetchManager
+                                                  thenNotifyDelegate: self];
     }
-
-    MWNetworkOp *thumbnailOp = [[MWNetworkOp alloc] init];
-    thumbnailOp.delegate = self;
-    thumbnailOp.request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
     
-    __weak MWNetworkOp *weakThumbnailOp = thumbnailOp;
-    thumbnailOp.aboutToStart = ^{
-        //NSLog(@"thumbnail op aboutToStart with request %@", weakThumbnailOp.request);
-        [[MWNetworkActivityIndicatorManager sharedManager] push];
-    };
-    thumbnailOp.completionBlock = ^(){
-        [[MWNetworkActivityIndicatorManager sharedManager] pop];
-        if(weakThumbnailOp.isCancelled){
-            //NSLog(@"thumbnail op completionBlock bailed (because op was cancelled) for %@", searchTerm);
-            return;
-        }
-
-        // Save cache file.
-        [weakThumbnailOp.dataRetrieved writeToFile:cacheFilePath atomically:YES];
-        
-        // Then see if cell for this image name is still onscreen and set its image if so.
-        UIImage *image = [UIImage imageWithData:weakThumbnailOp.dataRetrieved];
-        
-        dispatch_sync(dispatch_get_main_queue(), ^(){
-            //Check if cell still onscreen!
-            NSArray *visibleRowIndexPaths = [self.tableView indexPathsForVisibleRows];
-            for (NSIndexPath *thisIndexPath in visibleRowIndexPaths.copy) {
-                NSArray *sectionData = self.nearbyDataArray[thisIndexPath.section];
-                NSDictionary *rowData = sectionData[thisIndexPath.row];
-                NSString *url = rowData[@"thumbnail"][@"source"];
-                if ([url.lastPathComponent isEqualToString:fileName]) {
-                    NearbyResultCell *cell = (NearbyResultCell *)[self.tableView cellForRowAtIndexPath:thisIndexPath];
-                        [cell.thumbView setImage:image isPlaceHolder:NO];
-                    [cell setNeedsDisplay];
-                    break;
-                }
-            }
-        });
-    };
-    [[QueuesSingleton sharedInstance].nearbyQ addOperation:thumbnailOp];
-
-    //[cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator];
     return cell;
 }
 
diff --git a/wikipedia/View Controllers/PageHistory/PageHistoryViewController.h b/wikipedia/View Controllers/PageHistory/PageHistoryViewController.h
index 8534bbf1534..5813e570e5b 100644
--- a/wikipedia/View Controllers/PageHistory/PageHistoryViewController.h	
+++ b/wikipedia/View Controllers/PageHistory/PageHistoryViewController.h	
@@ -2,10 +2,10 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
+#import "PageHistoryFetcher.h"
 #import "TopMenuViewController.h"
 
-@interface PageHistoryViewController : UIViewController <NetworkOpDelegate, UITableViewDataSource, UITableViewDelegate>
+@interface PageHistoryViewController : UIViewController <FetchFinishedDelegate, UITableViewDataSource, UITableViewDelegate>
 
 @property (nonatomic) NavBarMode navBarMode;
 
diff --git a/wikipedia/View Controllers/PageHistory/PageHistoryViewController.m b/wikipedia/View Controllers/PageHistory/PageHistoryViewController.m
index 91f935cafb3..f6abe6651f6 100644
--- a/wikipedia/View Controllers/PageHistory/PageHistoryViewController.m	
+++ b/wikipedia/View Controllers/PageHistory/PageHistoryViewController.m	
@@ -7,7 +7,6 @@
 #import "SessionSingleton.h"
 #import "QueuesSingleton.h"
 #import "CenterNavController.h"
-#import "PageHistoryOp.h"
 #import "UIViewController+Alert.h"
 #import "NSDate-Utilities.h"
 #import "NSString+Extras.h"
@@ -16,6 +15,7 @@
 #import "UIViewController+ModalPop.h"
 #import "Defines.h"
 #import "PaddedLabel.h"
+#import "FetcherBase.h"
 
 @interface PageHistoryViewController (){
 
@@ -51,7 +51,7 @@ -(void)viewDidAppear:(BOOL)animated
 
 -(void)viewWillDisappear:(BOOL)animated
 {
-    [[QueuesSingleton sharedInstance].pageHistoryQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].pageHistoryFetchManager.operationQueue cancelAllOperations];
 
     [[NSNotificationCenter defaultCenter] removeObserver: self
                                                     name: @"NavItemTapped"
@@ -97,34 +97,39 @@ - (void)viewDidLoad
     self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;
 }
 
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error;
+{
+    if ([sender isKindOfClass:[PageHistoryFetcher class]]) {
+        NSMutableArray *pageHistoryDataArray = (NSMutableArray *)userData;
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:
+
+                self.pageHistoryDataArray = pageHistoryDataArray;
+                [self fadeAlert];
+                [self.tableView reloadData];
+            
+            break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+
+            break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+            break;
+
+        }
+    }
+}
+
 -(void)getPageHistoryData
 {
-    [[QueuesSingleton sharedInstance].pageHistoryQ cancelAllOperations];
-    
-    __weak PageHistoryViewController *weakSelf = self;
-
-    [self showAlert:MWLocalizedString(@"page-history-downloading", nil) type:ALERT_TYPE_TOP duration:-1];
-
-    PageHistoryOp *pageHistoryOp =
-    [[PageHistoryOp alloc] initWithDomain: [SessionSingleton sharedInstance].currentArticleDomain
-                                    title: [SessionSingleton sharedInstance].currentArticleTitle
-                          completionBlock: ^(NSMutableArray * result){
-                              
-                              weakSelf.pageHistoryDataArray = result;
-                              
-                              dispatch_async(dispatch_get_main_queue(), ^(void){
-                                  [self fadeAlert];
-                                  [weakSelf.tableView reloadData];
-                              });
-                          }
-                           cancelledBlock: ^(NSError *error){
-                               [self fadeAlert];
-                           }
-                               errorBlock: ^(NSError *error){
-                                   [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                               }];
-    pageHistoryOp.delegate = self;
-    [[QueuesSingleton sharedInstance].pageHistoryQ addOperation:pageHistoryOp];
+    (void)[[PageHistoryFetcher alloc] initAndFetchHistoryForTitle: [SessionSingleton sharedInstance].currentArticleTitle
+                                                           domain: [SessionSingleton sharedInstance].currentArticleDomain
+                                                      withManager: [QueuesSingleton sharedInstance].pageHistoryFetchManager
+                                               thenNotifyDelegate: self];
 }
 
 - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
diff --git a/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.h b/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.h
index 785e4ba8065..ea4f8d87fa8 100644
--- a/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.h	
+++ b/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.h	
@@ -2,13 +2,13 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
 #import "CaptchaViewController.h"
 #import "EditFunnel.h"
+#import "FetcherBase.h"
 
 @class NSManagedObjectID;
 
-@interface PreviewAndSaveViewController : UIViewController <NetworkOpDelegate, UITextFieldDelegate, CaptchaViewControllerRefresh, UIScrollViewDelegate>
+@interface PreviewAndSaveViewController : UIViewController <FetchFinishedDelegate, UITextFieldDelegate, CaptchaViewControllerRefresh, UIScrollViewDelegate>
 
 @property (strong, nonatomic) NSManagedObjectID *sectionID;
 @property (strong, nonatomic) NSString *wikiText;
diff --git a/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.m b/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.m
index 47ccdb8bc0a..bbc491e6aa7 100644
--- a/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.m	
+++ b/wikipedia/View Controllers/Preview/PreviewAndSaveViewController.m	
@@ -3,16 +3,16 @@
 
 #import "PreviewAndSaveViewController.h"
 #import "WikipediaAppUtils.h"
-#import "PreviewWikiTextOp.h"
+#import "PreviewHtmlFetcher.h"
 #import "UIViewController+Alert.h"
 #import "ArticleCoreDataObjects.h"
 #import "ArticleDataContextSingleton.h"
 #import "QueuesSingleton.h"
 #import "CenterNavController.h"
-#import "UploadSectionWikiTextOp.h"
+#import "WikiTextSectionUploader.h"
 #import "CaptchaViewController.h"
 #import "UIViewController+HideKeyboard.h"
-#import "EditTokenOp.h"
+#import "EditTokenFetcher.h"
 #import "SessionSingleton.h"
 #import "WebViewController.h"
 #import "UINavigationController+SearchNavStack.h"
@@ -440,63 +440,245 @@ -(void)viewWillDisappear:(BOOL)animated
     [super viewWillDisappear:animated];
 }
 
-- (void)preview
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
 {
-    ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
-
-    // Use static flag to prevent preview when preview already in progress.
-    static BOOL isAleadyPreviewing = NO;
-    if (isAleadyPreviewing) return;
-    isAleadyPreviewing = YES;
-
-    [self showAlert:MWLocalizedString(@"wikitext-preview-changes", nil) type:ALERT_TYPE_TOP duration:-1];
-    Section *section = (Section *)[articleDataContext_.mainContext objectWithID:self.sectionID];
-
-    MWLanguageInfo *languageInfo = [MWLanguageInfo languageInfoForCode:section.article.domain];
-    NSString *uidir = ([WikipediaAppUtils isDeviceLanguageRTL] ? @"rtl" : @"ltr");
-
-    PreviewWikiTextOp *previewWikiTextOp =
-    [[PreviewWikiTextOp alloc] initWithDomain: section.article.domain
-                                        title: section.article.title
-                                     wikiText: self.wikiText
-                              completionBlock: ^(NSString *result){
-
-        [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-
-            [self fadeAlert];
-
-            [self resetBridge];
-
-            [self.bridge sendMessage: @"setLanguage"
-                         withPayload: @{
-                                        @"lang": languageInfo.code,
-                                        @"dir": languageInfo.dir,
-                                        @"uidir": uidir
-                                        }];
-
-            [self.bridge sendMessage:@"append" withPayload:@{@"html": result ? result : @""}];
-
-            isAleadyPreviewing = NO;
-            
-        }];
+    if ([sender isKindOfClass:[PreviewHtmlFetcher class]]) {
         
-    } cancelledBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-        isAleadyPreviewing = NO;
+        Section *section = (Section *)[[ArticleDataContextSingleton sharedInstance].mainContext objectWithID:self.sectionID];
+        MWLanguageInfo *languageInfo = [MWLanguageInfo languageInfoForCode:section.article.domain];
+        NSString *uidir = ([WikipediaAppUtils isDeviceLanguageRTL] ? @"rtl" : @"ltr");
         
-    } errorBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                [self fadeAlert];
+                [self resetBridge];
+                [self.bridge sendMessage: @"setLanguage"
+                             withPayload: @{
+                                            @"lang": languageInfo.code,
+                                            @"dir": languageInfo.dir,
+                                            @"uidir": uidir
+                                            }];
+                [self.bridge sendMessage:@"append" withPayload:@{@"html": userData ? userData : @""}];
+            }
+                break;
+            case FETCH_FINAL_STATUS_FAILED:{
+                NSString *errorMsg = error.localizedDescription;
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:{
+                NSString *errorMsg = error.localizedDescription;
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+            }
+                break;
+        }
         
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+    }else if ([sender isKindOfClass:[EditTokenFetcher class]]) {
         
-        isAleadyPreviewing = NO;
-    }];
+        EditTokenFetcher *tokenFetcher = (EditTokenFetcher *)sender;
+        
+        void (^upload)() = ^void() {
+            NSMutableDictionary *editTokens = [SessionSingleton sharedInstance].keychainCredentials.editTokens;
+            NSString *editToken = editTokens[tokenFetcher.domain];
+            (void)[[WikiTextSectionUploader alloc] initAndUploadWikiText: tokenFetcher.wikiText
+                                                            forPageTitle: tokenFetcher.title
+                                                                  domain: tokenFetcher.domain
+                                                                 section: tokenFetcher.section
+                                                                 summary: tokenFetcher.summary
+                                                               captchaId: tokenFetcher.captchaId
+                                                             captchaWord: tokenFetcher.captchaWord
+                                                               articleID: tokenFetcher.articleID
+                                                                   token: editToken
+                                                             withManager: [QueuesSingleton sharedInstance].sectionWikiTextUploadManager
+                                                      thenNotifyDelegate: self];
+        };
+        
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                NSMutableDictionary *editTokens =
+                [SessionSingleton sharedInstance].keychainCredentials.editTokens;
+                //NSLog(@"article.domain = %@", article.domain);
+                NSString *domain = [sender domain];
+                if (domain && tokenFetcher.token) {
+                    editTokens[domain] = tokenFetcher.token;
+                    [SessionSingleton sharedInstance].keychainCredentials.editTokens = editTokens;
+                }
+                upload();
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                
+                // Still try the uploadWikiTextOp even if EditTokenFetcher fails to get a token.
+                // EditTokenFetcher return an anonymous "+\" edit token if it doesn't find an edit token.
+                upload();
+                
+                break;
+        }
+        
+    } else if ([sender isKindOfClass:[WikiTextSectionUploader class]]) {
+        
+        WikiTextSectionUploader *uploader = (WikiTextSectionUploader *)sender;
+        
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                
+                [self.funnel logSavedRevision:[userData[@"newrevid"] intValue]];
+                
+                // Mark article for refreshing and reload it.
+                if (uploader.articleID) {
+                    
+                    WebViewController *webVC = [self.navigationController searchNavStackForViewControllerOfClass:[WebViewController class]];
+                    [webVC reloadCurrentArticleInvalidatingCache:YES];
+                    [ROOT popToViewController:webVC animated:YES];
+                }
+            }
+                break;
+                
+            case FETCH_FINAL_STATUS_CANCELLED:{
+                
+                NSString *errorMsg = error.localizedDescription;
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+            }
+                break;
+                
+            case FETCH_FINAL_STATUS_FAILED:{
+                
+                NSString *errorMsg = error.localizedDescription;
+                
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+                
+                switch (error.code) {
+                    case WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA:
+                    {
+                        
+                        if(ROOT.topMenuViewController.navBarMode == NAVBAR_MODE_EDIT_WIKITEXT_CAPTCHA){
+                            [self.funnel logCaptchaFailure];
+                        }
+                        
+                        // If the server said a captcha was required, present the captcha image.
+                        NSString *captchaUrl = error.userInfo[@"captchaUrl"];
+                        NSString *captchaId = error.userInfo[@"captchaId"];
+                        if (uploader.articleID) {
+                            [[ArticleDataContextSingleton sharedInstance].mainContext performBlockAndWait:^(){
+                                Article *article = (Article *)[[ArticleDataContextSingleton sharedInstance].mainContext objectWithID:uploader.articleID];
+                                if (article) {
+                                    [UIView animateWithDuration:0.2f animations:^{
+                                        
+                                        [self revealCaptcha];
+                                        
+                                        [self.captchaViewController.captchaTextBox performSelector: @selector(becomeFirstResponder)
+                                                                                        withObject: nil
+                                                                                        afterDelay: 0.4f];
+                                        
+                                        [self.captchaViewController showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+                                        
+                                        self.captchaViewController.captchaImageView.image = nil;
+                                        
+                                        dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void){
+                                            // Background thread.
+                                            
+                                            NSURL *captchaImageUrl = [NSURL URLWithString:
+                                                                      [NSString stringWithFormat:@"https://%@.m.%@%@", article.domain, article.site, captchaUrl]
+                                                                      ];
+                                            
+                                            UIImage *captchaImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:captchaImageUrl]];
+                                            
+                                            dispatch_async(dispatch_get_main_queue(), ^(void){
+                                                // Main thread.
+                                                self.captchaViewController.captchaTextBox.text = @"";
+                                                self.captchaViewController.captchaImageView.image = captchaImage;
+                                                self.captchaId = captchaId;
+                                                
+                                                [self.view layoutIfNeeded];
+                                            });
+                                        });
+                                        
+                                    } completion:^(BOOL done){
+                                    }];
+                                }
+                            }];
+                        }
+                    }
+                        break;
+                        
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED:
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING:
+                    case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER:
+                    {
+                        //NSString *warningHtml = error.userInfo[@"warning"];
+                        
+                        [self hideKeyboard];
+                        
+                        NSString *bannerImage = nil;
+                        UIColor *bannerColor = nil;
+                        
+                        if ((error.code == WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED)) {
+                            ROOT.topMenuViewController.navBarMode = NAVBAR_MODE_EDIT_WIKITEXT_DISALLOW;
+                            bannerImage = @"abuse-filter-disallowed.png";
+                            bannerColor = WMF_COLOR_RED;
+                            
+                            self.abuseFilterCode = error.userInfo[@"code"];
+                            [self.funnel logAbuseFilterError:self.abuseFilterCode];
+                            
+                        }else{
+                            ROOT.topMenuViewController.navBarMode = NAVBAR_MODE_EDIT_WIKITEXT_WARNING;
+                            
+                            //[self highlightProgressiveButtons:YES];
+                            
+                            bannerImage = @"abuse-filter-flag-white.png";
+                            bannerColor = WMF_COLOR_ORANGE;
+                            
+                            self.abuseFilterCode = error.userInfo[@"code"];
+                            [self.funnel logAbuseFilterWarning:self.abuseFilterCode];
+                            
+                        }
+                        
+                        // Hides the license panel. Needed if logged in and a disallow is triggered.
+                        [self.navigationController topActionSheetHide];
+                        
+                        [self fadeAlert];
+                        AbuseFilterAlertType alertType =
+                        (error.code == WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED) ? ABUSE_FILTER_DISALLOW : ABUSE_FILTER_WARNING;
+                        [self showAbuseFilterAlertOfType:alertType];
+                        
+                    }
+                        break;
+                        
+                    case WIKITEXT_UPLOAD_ERROR_SERVER:
+                    case WIKITEXT_UPLOAD_ERROR_UNKNOWN:
+                        
+                        [self.funnel logError:error.localizedDescription]; // @fixme is this right msg?
+                        break;
+                        
+                    default:
+                        break;
+                }
+            }
+                break;
+        }
+    }
+}
+
+- (void)preview
+{
+    [self showAlert:MWLocalizedString(@"wikitext-preview-changes", nil) type:ALERT_TYPE_TOP duration:-1];
+ 
+    Section *section = (Section *)[[ArticleDataContextSingleton sharedInstance].mainContext objectWithID:self.sectionID];
 
-    previewWikiTextOp.delegate = self;
+    [[QueuesSingleton sharedInstance].sectionPreviewHtmlFetchManager.operationQueue cancelAllOperations];
 
-    [[QueuesSingleton sharedInstance].sectionWikiTextPreviewQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].sectionWikiTextPreviewQ addOperation:previewWikiTextOp];
+    (void)[[PreviewHtmlFetcher alloc] initAndFetchHtmlForWikiText: self.wikiText
+                                                            title: section.article.title
+                                                           domain: section.article.domain
+                                                      withManager: [QueuesSingleton sharedInstance].sectionPreviewHtmlFetchManager
+                                               thenNotifyDelegate: self];
 }
 
 - (void)didReceiveMemoryWarning
@@ -521,223 +703,41 @@ -(void)saveAutomaticallyIfNecessary
 
 - (void)save
 {
-    NSString *editSummary = [self getSummary];
 
-    // Use static flag to prevent save when save already in progress.
-    static BOOL isAleadySaving = NO;
-    if (isAleadySaving) return;
-    isAleadySaving = YES;
-
-    ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
+//TODO: maybe? if we have credentials, yet the edit token retrieved for an edit
+// is an anonymous token (i think this happens if you try to get an edit token
+// and your login session has expired), need to pop up alert asking user if they
+// want to log in before continuing with their edit
 
     [self showAlert:MWLocalizedString(@"wikitext-upload-save", nil) type:ALERT_TYPE_TOP duration:-1];
-    Section *section = (Section *)[articleDataContext_.mainContext objectWithID:self.sectionID];
-
-    NSManagedObjectID *articleID = section.article.objectID;
-
-    // If fromTitle was set, the section was transcluded, so use the title of the page
-    // it was transcluded from.
-    NSString *title = section.fromTitle ? section.fromTitle : section.article.title;
 
     [self.funnel logSaveAttempt];
     if (self.savedPagesFunnel) {
         [self.savedPagesFunnel logEditAttempt];
     }
 
-    UploadSectionWikiTextOp *uploadWikiTextOp =
-    [[UploadSectionWikiTextOp alloc] initForPageTitle:title domain:section.article.domain section:section.index wikiText:self.wikiText summary:editSummary captchaId:self.captchaId captchaWord:self.captchaViewController.captchaTextBox.text  completionBlock:^(NSDictionary *resultDict){
-        
-        [self.funnel logSavedRevision:[resultDict[@"newrevid"] intValue]];
-
-        // Mark article for refreshing and reload it.
-        if (articleID) {
-            [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-                WebViewController *webVC = [self.navigationController searchNavStackForViewControllerOfClass:[WebViewController class]];
-                [webVC reloadCurrentArticleInvalidatingCache:YES];
-                [ROOT popToViewController:webVC animated:YES];
-                isAleadySaving = NO;
-            }];
-        }
-
-    } cancelledBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-        isAleadySaving = NO;
-        
-    } errorBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-
-        switch (error.code) {
-            case WIKITEXT_UPLOAD_ERROR_NEEDS_CAPTCHA:
-            {
-
-                if(ROOT.topMenuViewController.navBarMode == NAVBAR_MODE_EDIT_WIKITEXT_CAPTCHA){
-                    [self.funnel logCaptchaFailure];
-                }
-            
-                // If the server said a captcha was required, present the captcha image.
-                NSString *captchaUrl = error.userInfo[@"captchaUrl"];
-                NSString *captchaId = error.userInfo[@"captchaId"];
-                if (articleID) {
-                    [articleDataContext_.mainContext performBlockAndWait:^(){
-                        Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-                        if (article) {
-                            [UIView animateWithDuration:0.2f animations:^{
-
-                                [self revealCaptcha];
-
-                                [self.captchaViewController.captchaTextBox performSelector: @selector(becomeFirstResponder)
-                                                                                withObject: nil
-                                                                                afterDelay: 0.4f];
-
-                                [self.captchaViewController showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-
-                                self.captchaViewController.captchaImageView.image = nil;
-
-                                dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void){
-                                    // Background thread.
-                                    
-                                    NSURL *captchaImageUrl = [NSURL URLWithString:
-                                                              [NSString stringWithFormat:@"https://%@.m.%@%@", article.domain, article.site, captchaUrl]
-                                                              ];
-                                    
-                                    UIImage *captchaImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:captchaImageUrl]];
-                                    
-                                    dispatch_async(dispatch_get_main_queue(), ^(void){
-                                        // Main thread.
-                                        self.captchaViewController.captchaTextBox.text = @"";
-                                        self.captchaViewController.captchaImageView.image = captchaImage;
-                                        self.captchaId = captchaId;
-                                        
-                                        [self.view layoutIfNeeded];
-                                    });
-                                });
-
-                            } completion:^(BOOL done){
-                            }];
-                        }
-                    }];
-                }
-            }
-                break;
-                
-            case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED:
-            case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_WARNING:
-            case WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_OTHER:
-            {
-                dispatch_async(dispatch_get_main_queue(), ^(void){
-                    //NSString *warningHtml = error.userInfo[@"warning"];
-                    
-                    [self hideKeyboard];
-                    
-                    NSString *bannerImage = nil;
-                    UIColor *bannerColor = nil;
-                    
-                    if ((error.code == WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED)) {
-                        ROOT.topMenuViewController.navBarMode = NAVBAR_MODE_EDIT_WIKITEXT_DISALLOW;
-                        bannerImage = @"abuse-filter-disallowed.png";
-                        bannerColor = WMF_COLOR_RED;
-
-                        self.abuseFilterCode = error.userInfo[@"code"];
-                        [self.funnel logAbuseFilterError:self.abuseFilterCode];
-
-                    }else{
-                        ROOT.topMenuViewController.navBarMode = NAVBAR_MODE_EDIT_WIKITEXT_WARNING;
-
-                        //[self highlightProgressiveButtons:YES];
-
-                        bannerImage = @"abuse-filter-flag-white.png";
-                        bannerColor = WMF_COLOR_ORANGE;
-
-                        self.abuseFilterCode = error.userInfo[@"code"];
-                        [self.funnel logAbuseFilterWarning:self.abuseFilterCode];
+    [[QueuesSingleton sharedInstance].sectionWikiTextUploadManager.operationQueue cancelAllOperations];
 
-                    }
+    Section *section = (Section *)[[ArticleDataContextSingleton sharedInstance].mainContext objectWithID:self.sectionID];
 
-                    // Hides the license panel. Needed if logged in and a disallow is triggered.
-                    [self.navigationController topActionSheetHide];
-                    
-                    [self fadeAlert];
-                    AbuseFilterAlertType alertType =
-                        (error.code == WIKITEXT_UPLOAD_ERROR_ABUSEFILTER_DISALLOWED) ? ABUSE_FILTER_DISALLOW : ABUSE_FILTER_WARNING;
-                    [self showAbuseFilterAlertOfType:alertType];
-
-                });
-            }
-                break;
-
-            case WIKITEXT_UPLOAD_ERROR_SERVER:
-            case WIKITEXT_UPLOAD_ERROR_UNKNOWN:
-
-                [self.funnel logError:error.localizedDescription]; // @fixme is this right msg?
-                break;
-                
-            default:
-                break;
-        }
-        isAleadySaving = NO;
-    }];
-
-    EditTokenOp *editTokenOp =
-    [[EditTokenOp alloc] initWithDomain: section.article.domain
-                        completionBlock: ^(NSDictionary *result){
-                            //NSLog(@"editTokenOp result = %@", result);
-                            //NSLog(@"editTokenOp result tokens = %@", result[@"tokens"][@"edittoken"]);
-
-                            if (articleID) {
-                                [articleDataContext_.mainContext performBlockAndWait:^(){
-                                    Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-                                    if (article) {
-                                        NSString *editToken = result[@"tokens"][@"edittoken"];
-                                        NSMutableDictionary *editTokens =
-                                            [SessionSingleton sharedInstance].keychainCredentials.editTokens;
-                                        //NSLog(@"article.domain = %@", article.domain);
-                                        editTokens[article.domain] = editToken;
-                                        [SessionSingleton sharedInstance].keychainCredentials.editTokens = editTokens;
-                                    }
-                                }];
-                            }
-
-                        } cancelledBlock: ^(NSError *error){
-                            
-                            [self fadeAlert];
-                            
-                            isAleadySaving = NO;
-                            
-                        } errorBlock: ^(NSError *error){
-                            
-                            [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                            isAleadySaving = NO;
-                            
-                        }];
-
-//TODO: if we have credentials, yet the edit token retrieved for an edit is
-// an anonymous token (i think this happens if you try to get an edit token
-// and your login session has expired), need to pop up alert asking user if they
-// want to log in before continuing with their edit. In this scenario would
-// probably need cancelIfDependentOpsFailed set to YES, then if the user
-// says they don't want to login in (ie continue anon editing) then we would
-// want cancelIfDependentOpsFailed set to NO.
+    // If fromTitle was set, the section was transcluded, so use the title of the page
+    // it was transcluded from.
+    NSString *title = section.fromTitle ? section.fromTitle : section.article.title;
 
-    editTokenOp.delegate = self;
-    uploadWikiTextOp.delegate = self;
-    
-    // Still try the uploadWikiTextOp even if editTokenOp fails to get a token. uploadWikiTextOp
-    // will use an anonymous "+\" edit token if it doesn't find an edit token.
-    editTokenOp.cancelIfDependentOpsFailed = NO;
-    
-    // Try to get an edit token for the page's domain before trying to upload the changes.
-    [uploadWikiTextOp addDependency:editTokenOp];
-    
-    [[QueuesSingleton sharedInstance].sectionWikiTextUploadQ cancelAllOperations];
-    [QueuesSingleton sharedInstance].sectionWikiTextUploadQ.suspended = YES;
-    
-    [[QueuesSingleton sharedInstance].sectionWikiTextUploadQ addOperation:editTokenOp];
-    [[QueuesSingleton sharedInstance].sectionWikiTextUploadQ addOperation:uploadWikiTextOp];
-    
-    [QueuesSingleton sharedInstance].sectionWikiTextUploadQ.suspended = NO;
+    // First try to get an edit token for the page's domain before trying to upload the changes.
+    // Only the domain is used to actually fetch the token, the other values are
+    // parked in EditTokenFetcher so the actual uploader can have quick read-only
+    // access to the exact params which kicked off the token request.
+    (void)[[EditTokenFetcher alloc] initAndFetchEditTokenForWikiText: self.wikiText
+                                                           pageTitle: title
+                                                              domain: section.article.domain
+                                                             section: section.index
+                                                             summary: [self getSummary]
+                                                           captchaId: self.captchaId
+                                                         captchaWord: self.captchaViewController.captchaTextBox.text
+                                                           articleID: section.article.objectID
+                                                         withManager: [QueuesSingleton sharedInstance].sectionWikiTextUploadManager
+                                                  thenNotifyDelegate: self];
 }
 
 -(void)showAbuseFilterAlertOfType:(AbuseFilterAlertType)alertType
diff --git a/wikipedia/View Controllers/References/ReferenceVC.m b/wikipedia/View Controllers/References/ReferenceVC.m
index 0bf988d2490..29f8f338cf8 100644
--- a/wikipedia/View Controllers/References/ReferenceVC.m	
+++ b/wikipedia/View Controllers/References/ReferenceVC.m	
@@ -19,10 +19,12 @@ @interface ReferenceVC ()
 
 @implementation ReferenceVC
 
+/*
 -(void)dealloc
 {
     NSLog(@"dealloc'ing REFERENCE VC!");
 }
+*/
 
 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
 {
diff --git a/wikipedia/View Controllers/SearchResults/SearchResultsController.h b/wikipedia/View Controllers/SearchResults/SearchResultsController.h
index 2abb28a1711..1e668e1d1b7 100644
--- a/wikipedia/View Controllers/SearchResults/SearchResultsController.h	
+++ b/wikipedia/View Controllers/SearchResults/SearchResultsController.h	
@@ -2,9 +2,9 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
+#import "FetcherBase.h"
 
-@interface SearchResultsController : UIViewController <UITableViewDelegate, NetworkOpDelegate>
+@interface SearchResultsController : UIViewController <UITableViewDelegate, FetchFinishedDelegate>
 
 // Presents a view controller which, in its viewWillAppear method, does a
 // search for the NavController's currentSearchString and presents a list
diff --git a/wikipedia/View Controllers/SearchResults/SearchResultsController.m b/wikipedia/View Controllers/SearchResults/SearchResultsController.m
index cfe10db3132..d98a58d1ac2 100644
--- a/wikipedia/View Controllers/SearchResults/SearchResultsController.m	
+++ b/wikipedia/View Controllers/SearchResults/SearchResultsController.m	
@@ -5,8 +5,6 @@
 #import "WikipediaAppUtils.h"
 #import "Defines.h"
 #import "QueuesSingleton.h"
-#import "MWNetworkActivityIndicatorManager.h"
-#import "NSURLRequest+DictionaryRequest.h"
 #import "SearchResultCell.h"
 #import "SessionSingleton.h"
 #import "UIViewController+Alert.h"
@@ -15,8 +13,8 @@
 #import "NSString+Extras.h"
 #import "UIViewController+HideKeyboard.h"
 #import "CenterNavController.h"
-#import "SearchOp.h"
-
+#import "SearchResultFetcher.h"
+#import "ThumbnailFetcher.h"
 #import "RootViewController.h"
 #import "TopMenuViewController.h"
 
@@ -79,8 +77,7 @@ -(void)viewWillAppear:(BOOL)animated
 -(void)viewWillDisappear:(BOOL)animated
 {
     [super viewWillDisappear:animated];
-    [[QueuesSingleton sharedInstance].thumbnailQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].searchQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].searchResultsFetchManager.operationQueue cancelAllOperations];
 }
 
 -(void)refreshSearchResults
@@ -123,11 +120,76 @@ -(void)clearSearchResults
     self.searchResultsOrdered = @[];
     [self.searchResultsTable reloadData];
     
-    [[QueuesSingleton sharedInstance].articleRetrievalQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].thumbnailQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].articleFetchManager.operationQueue cancelAllOperations];
     
-    // Cancel any in-progress article retrieval operations
-    [[QueuesSingleton sharedInstance].searchQ cancelAllOperations];
+    // Cancel any in-progress searches.
+    [[QueuesSingleton sharedInstance].searchResultsFetchManager.operationQueue cancelAllOperations];
+}
+
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error;
+{
+    
+    
+    if ([sender isKindOfClass:[SearchResultFetcher class]]) {
+        
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                [self fadeAlert];
+                self.searchResultsOrdered = userData;
+                ROOT.topMenuViewController.currentSearchResultsOrdered = self.searchResultsOrdered.copy;
+                
+                // We have search titles! Show them right away!
+                // NSLog(@"FIRE ONE! Show search result titles.");
+                [self.searchResultsTable reloadData];
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                [self fadeAlert];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+                break;
+        }
+    }
+
+    if ([sender isKindOfClass:[ThumbnailFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                NSString *fileName = [[sender url] lastPathComponent];
+                
+                // See if cache file found, show it instead of downloading if found.
+                NSString *cacheFilePath = [self.cachePath stringByAppendingPathComponent:fileName];
+                
+                // Save cache file.
+                [userData writeToFile:cacheFilePath atomically:YES];
+                
+                // Then see if cell for this image name is still onscreen and set its image if so.
+                UIImage *image = [UIImage imageWithData:userData];
+                
+                // Check if cell still onscreen! This is important!
+                NSArray *visibleRowIndexPaths = [self.searchResultsTable indexPathsForVisibleRows];
+                for (NSIndexPath *thisIndexPath in visibleRowIndexPaths.copy) {
+                    
+                    NSDictionary *rowData = self.searchResultsOrdered[thisIndexPath.row];
+                    NSString *url = rowData[@"thumbnail"][@"source"];
+                    if ([url.lastPathComponent isEqualToString:fileName]) {
+                        SearchResultCell *cell = (SearchResultCell *)[self.searchResultsTable cellForRowAtIndexPath:thisIndexPath];
+                        cell.imageView.image = image;
+                        [cell setNeedsDisplay];
+                        break;
+                    }
+                }
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+                break;
+        }
+    }
 }
 
 - (void)searchForTerm:(NSString *)searchTerm
@@ -137,35 +199,10 @@ - (void)searchForTerm:(NSString *)searchTerm
     // Show "Searching..." message.
     [self showAlert:MWLocalizedString(@"search-searching", nil) type:ALERT_TYPE_TOP duration:-1];
     
-    // Search for titles op.
-    SearchOp *searchOp =
-    [[SearchOp alloc] initWithSearchTerm: searchTerm
-                         completionBlock: ^(NSArray *searchResults){
-                             
-                             [self fadeAlert];
-                             
-                             self.searchResultsOrdered = searchResults;
-                             
-                             ROOT.topMenuViewController.currentSearchResultsOrdered = self.searchResultsOrdered.copy;
-                             
-                             dispatch_async(dispatch_get_main_queue(), ^(){
-                                 // We have search titles! Show them right away!
-                                 // NSLog(@"FIRE ONE! Show search result titles.");
-                                 [self.searchResultsTable reloadData];
-                             });
-                             
-                         } cancelledBlock: ^(NSError *error){
-                             
-                             [self fadeAlert];
-                             
-                         } errorBlock: ^(NSError *error){
-                             
-                             [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
-                             
-                         }];
-    
-    searchOp.delegate = self;
-    [[QueuesSingleton sharedInstance].searchQ addOperation:searchOp];
+    // Search for titles.
+    (void)[[SearchResultFetcher alloc] initAndSearchForTerm: searchTerm
+                                                withManager: [QueuesSingleton sharedInstance].searchResultsFetchManager
+                                         thenNotifyDelegate: self];
 }
 
 #pragma mark Search term highlighting
@@ -245,55 +282,17 @@ - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(N
 
     // See if cache file found, show it instead of downloading if found.
     NSString *cacheFilePath = [self.cachePath stringByAppendingPathComponent:fileName];
-    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:cacheFilePath isDirectory:NO];
+    BOOL isDirectory = NO;
+    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:cacheFilePath isDirectory:&isDirectory];
     if (fileExists) {
         cell.imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfFile:cacheFilePath]];
-        return cell;
+    }else{
+        // No thumb found so fetch it.
+        (void)[[ThumbnailFetcher alloc] initAndFetchThumbnailFromURL: thumbURL
+                                                         withManager: [QueuesSingleton sharedInstance].searchResultsFetchManager
+                                                  thenNotifyDelegate: self];
     }
-
-    MWNetworkOp *thumbnailOp = [[MWNetworkOp alloc] init];
-    thumbnailOp.delegate = self;
-
-    //NSLog(@"thumbURL  = %@", thumbURL);
-
-    thumbnailOp.request = [NSURLRequest requestWithURL:[NSURL URLWithString:thumbURL]];
-    
-    __weak MWNetworkOp *weakThumbnailOp = thumbnailOp;
-    thumbnailOp.aboutToStart = ^{
-        //NSLog(@"thumbnail op aboutToStart with request %@", weakThumbnailOp.request);
-        [[MWNetworkActivityIndicatorManager sharedManager] push];
-    };
     
-    thumbnailOp.completionBlock = ^(){
-        [[MWNetworkActivityIndicatorManager sharedManager] pop];
-        if(weakThumbnailOp.isCancelled){
-            //NSLog(@"thumbnail op completionBlock bailed (because op was cancelled) for %@", searchTerm);
-            return;
-        }
-        
-        // Save cache file.
-        [weakThumbnailOp.dataRetrieved writeToFile:cacheFilePath atomically:YES];
-        
-        // Then see if cell for this image name is still onscreen and set its image if so.
-        UIImage *image = [UIImage imageWithData:weakThumbnailOp.dataRetrieved];
-        dispatch_sync(dispatch_get_main_queue(), ^(){
-            //Check if cell still onscreen!
-            NSArray *visibleRowIndexPaths = [self.searchResultsTable indexPathsForVisibleRows];
-            for (NSIndexPath *thisIndexPath in visibleRowIndexPaths.copy) {
-                NSDictionary *rowData = self.searchResultsOrdered[thisIndexPath.row];
-                NSString *url = rowData[@"thumbnail"][@"source"];
-                if ([url.lastPathComponent isEqualToString:fileName]) {
-                    SearchResultCell *cell = (SearchResultCell *)[self.searchResultsTable cellForRowAtIndexPath:thisIndexPath];
-                    cell.imageView.image = image;
-                    [cell setNeedsDisplay];
-                    break;
-                }
-            }
-        });
-    };
-    [[QueuesSingleton sharedInstance].thumbnailQ addOperation:thumbnailOp];
-
-    //[cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator];
     return cell;
 }
 
diff --git a/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.h b/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.h
index f118c4a3796..d94b5e2ca17 100644
--- a/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.h	
+++ b/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.h	
@@ -2,16 +2,16 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
+#import "FetcherBase.h"
 #import "EditFunnel.h"
 #import "SavedPagesFunnel.h"
 
 @class NSManagedObjectID;
 
-@interface SectionEditorViewController : UIViewController <UITextViewDelegate, UIScrollViewDelegate, NetworkOpDelegate, UITextFieldDelegate>
+@interface SectionEditorViewController : UIViewController <UITextViewDelegate, UIScrollViewDelegate, FetchFinishedDelegate, UITextFieldDelegate>
 
 @property (strong, nonatomic) NSManagedObjectID *sectionID;
-@property EditFunnel *funnel;
-@property SavedPagesFunnel *savedPagesFunnel;
+@property (strong, nonatomic) EditFunnel *funnel;
+@property (strong, nonatomic) SavedPagesFunnel *savedPagesFunnel;
 
 @end
diff --git a/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.m b/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.m
index 04bdfde7eee..d608ed5deed 100644
--- a/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.m	
+++ b/wikipedia/View Controllers/SectionEditor/SectionEditorViewController.m	
@@ -9,7 +9,7 @@
 #import "Defines.h"
 #import "UIViewController+Alert.h"
 #import "QueuesSingleton.h"
-#import "DownloadSectionWikiTextOp.h"
+#import "WikiTextSectionFetcher.h"
 #import "CenterNavController.h"
 #import "PreviewAndSaveViewController.h"
 #import "WMF_Colors.h"
@@ -31,7 +31,6 @@ @interface SectionEditorViewController (){
 @property (weak, nonatomic) IBOutlet UITextView *editTextView;
 @property (strong, nonatomic) NSString *unmodifiedWikiText;
 @property (nonatomic) CGRect viewKeyboardRect;
-@property (copy) NSString *protectionStatus;
 
 @end
 
@@ -170,63 +169,83 @@ -(void)setScrollsToTop:(BOOL)scrollsToTop
     }
 }
 
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
+{
+    if ([sender isKindOfClass:[WikiTextSectionFetcher class]]) {
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:{
+                
+                WikiTextSectionFetcher *wikiTextSectionFetcher = (WikiTextSectionFetcher *)sender;
+                NSDictionary *resultsDict = (NSDictionary *)userData;
+                NSString *revision = resultsDict[@"revision"];
+                NSDictionary *userInfo = resultsDict[@"userInfo"];
+                
+                self.funnel = [[EditFunnel alloc] initWithUserId:[userInfo[@"id"] intValue]];
+                [self.funnel logStart];
+
+                NSString *protectionStatus = wikiTextSectionFetcher.section.article.protectionStatus;
+
+                if (protectionStatus && [protectionStatus length] > 0) {
+                    NSString *msg;
+                    if ([protectionStatus isEqualToString:@"autoconfirmed"]) {
+                        msg = MWLocalizedString(@"page_protected_autoconfirmed", nil);
+                    } else if ([protectionStatus isEqualToString:@"sysop"]) {
+                        msg = MWLocalizedString(@"page_protected_sysop", nil);
+                    } else {
+                        msg = MWLocalizedString(@"page_protected_other", nil);
+                    }
+                    [self showAlert:msg type:ALERT_TYPE_TOP duration:1];
+                } else {
+                    //[self showAlert:MWLocalizedString(@"wikitext-download-success", nil) type:ALERT_TYPE_TOP duration:1];
+                    [self fadeAlert];
+                }
+                self.unmodifiedWikiText = revision;
+                self.editTextView.attributedText = [self getAttributedString:revision];
+                //[self.editTextView performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0.4f];
+                
+                MWLanguageInfo *lang = [MWLanguageInfo languageInfoForCode:wikiTextSectionFetcher.domain];
+                UITextRange *range = [self.editTextView textRangeFromPosition:self.editTextView.beginningOfDocument toPosition: self.editTextView.endOfDocument];
+                if ([lang.dir isEqualToString:@"rtl"]) {
+                    [self.editTextView setBaseWritingDirection:UITextWritingDirectionRightToLeft forRange:range];
+                } else {
+                    [self.editTextView setBaseWritingDirection:UITextWritingDirectionLeftToRight forRange:range];
+                }
+            }
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:{
+                NSString *errorMsg = error.localizedDescription;
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+            }
+                break;
+            case FETCH_FINAL_STATUS_FAILED:{
+                NSString *errorMsg = error.localizedDescription;
+                [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+            }
+                break;
+        }
+    }
+}
+
 -(void)loadLatestWikiTextForSectionFromServer
 {
     [self showAlert:MWLocalizedString(@"wikitext-downloading", nil) type:ALERT_TYPE_TOP duration:-1];
+
     Section *section = (Section *)[articleDataContext_.mainContext objectWithID:self.sectionID];
-    NSString *domain = section.article.domain;
-    self.protectionStatus = section.article.protectionStatus;
 
     // If fromTitle was set, the section was transcluded, so use the title of the page
     // it was transcluded from.
     NSString *title = section.fromTitle ? section.fromTitle : section.article.title;
 
-    DownloadSectionWikiTextOp *downloadWikiTextOp = [[DownloadSectionWikiTextOp alloc] initForPageTitle:title domain:section.article.domain section:section.index completionBlock:^(NSString *revision, NSDictionary *userInfo) {
-        
-        [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-            
-            self.funnel = [[EditFunnel alloc] initWithUserId:[userInfo[@"id"] intValue]];
-            [self.funnel logStart];
-
-            if (self.protectionStatus && [self.protectionStatus length] > 0) {
-                NSString *msg;
-                if ([self.protectionStatus isEqualToString:@"autoconfirmed"]) {
-                    msg = MWLocalizedString(@"page_protected_autoconfirmed", nil);
-                } else if ([self.protectionStatus isEqualToString:@"sysop"]) {
-                    msg = MWLocalizedString(@"page_protected_sysop", nil);
-                } else {
-                    msg = MWLocalizedString(@"page_protected_other", nil);
-                }
-                [self showAlert:msg type:ALERT_TYPE_TOP duration:1];
-            } else {
-                //[self showAlert:MWLocalizedString(@"wikitext-download-success", nil) type:ALERT_TYPE_TOP duration:1];
-                [self fadeAlert];
-            }
-            self.unmodifiedWikiText = revision;
-            self.editTextView.attributedText = [self getAttributedString:revision];
-            //[self.editTextView performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0.4f];
-            
-            MWLanguageInfo *lang = [MWLanguageInfo languageInfoForCode:domain];
-            UITextRange *range = [self.editTextView textRangeFromPosition:self.editTextView.beginningOfDocument toPosition: self.editTextView.endOfDocument];
-            if ([lang.dir isEqualToString:@"rtl"]) {
-                [self.editTextView setBaseWritingDirection:UITextWritingDirectionRightToLeft forRange:range];
-            } else {
-                [self.editTextView setBaseWritingDirection:UITextWritingDirectionLeftToRight forRange:range];
-            }
-        }];
-        
-    } cancelledBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-        
-    } errorBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-        
-    }];
-
-    [[QueuesSingleton sharedInstance].sectionWikiTextDownloadQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].sectionWikiTextDownloadQ addOperation:downloadWikiTextOp];
+    [[QueuesSingleton sharedInstance].sectionWikiTextDownloadManager.operationQueue cancelAllOperations];
+
+    (void)[[WikiTextSectionFetcher alloc] initAndFetchWikiTextForSection: section
+                                                                   title: title
+                                                                  domain: section.article.domain
+                                                             withManager: [QueuesSingleton sharedInstance].sectionWikiTextDownloadManager
+                                                      thenNotifyDelegate: self];
 }
 
 -(NSAttributedString *)getAttributedString:(NSString *)string
diff --git a/wikipedia/View Controllers/WebView/WebViewController.h b/wikipedia/View Controllers/WebView/WebViewController.h
index 6ba5eba92c9..2ec4d506926 100644
--- a/wikipedia/View Controllers/WebView/WebViewController.h	
+++ b/wikipedia/View Controllers/WebView/WebViewController.h	
@@ -2,12 +2,13 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import <UIKit/UIKit.h>
-#import "MWNetworkOp.h"
 #import "CenterNavController.h"
 #import "MWPageTitle.h"
 #import "PullToRefreshViewController.h"
+#import "Article.h"
+#import "ArticleFetcher.h"
 
-@interface WebViewController : PullToRefreshViewController <UIWebViewDelegate, NetworkOpDelegate, UIScrollViewDelegate, UIGestureRecognizerDelegate, UIAlertViewDelegate>
+@interface WebViewController : PullToRefreshViewController <UIWebViewDelegate, UIScrollViewDelegate, UIGestureRecognizerDelegate, UIAlertViewDelegate, FetchFinishedDelegate>
 
 @property (weak, nonatomic) IBOutlet UIWebView *webView;
 @property (nonatomic) BOOL bottomMenuHidden;
diff --git a/wikipedia/View Controllers/WebView/WebViewController.m b/wikipedia/View Controllers/WebView/WebViewController.m
index 794a1996692..ea78b640879 100644
--- a/wikipedia/View Controllers/WebView/WebViewController.m	
+++ b/wikipedia/View Controllers/WebView/WebViewController.m	
@@ -4,10 +4,9 @@
 #import "WebViewController.h"
 
 #import "WikipediaAppUtils.h"
-#import "DownloadWikipediaZeroMessageOp.h"
+#import "WikipediaZeroMessageFetcher.h"
 #import "ArticleDataContextSingleton.h"
 #import "SectionEditorViewController.h"
-#import "DownloadSectionsOp.h"
 #import "ArticleCoreDataObjects.h"
 #import "CommunicationBridge.h"
 #import "TOCViewController.h"
@@ -33,7 +32,6 @@
 #import "PaddedLabel.h"
 #import "DataMigrator.h"
 #import "ArticleImporter.h"
-#import "SyncAssetsFileOp.h"
 #import "RootViewController.h"
 #import "TopMenuViewController.h"
 #import "BottomMenuViewController.h"
@@ -60,6 +58,9 @@
 #import "NSString+FormattedAttributedString.h"
 #import "SavedPagesFunnel.h"
 
+#import "ArticleFetcher.h"
+#import "AssetsFileFetcher.h"
+
 //#import "UIView+Debugging.h"
 
 #define TOC_TOGGLE_ANIMATION_DURATION @0.225f
@@ -182,7 +183,9 @@ - (void)viewDidLoad
 
     self.panSwipeRecognizer = nil;
 
+    self.zeroStatusLabel.font = [UIFont systemFontOfSize:ALERT_FONT_SIZE];
     self.zeroStatusLabel.text = @"";
+    
     self.referencesVC = nil;
     
     self.sectionToEditId = 0;
@@ -377,6 +380,8 @@ -(void)viewWillAppear:(BOOL)animated
 -(void)viewWillDisappear:(BOOL)animated
 {
     [self tocHideWithDuration:TOC_TOGGLE_ANIMATION_DURATION];
+
+    [[QueuesSingleton sharedInstance].zeroRatedMessageFetchManager.operationQueue cancelAllOperations];
     
     [super viewWillDisappear:animated];
 }
@@ -454,27 +459,18 @@ -(void)downloadAssetsFilesIfNecessary
     // Sync config/ios.json at most once per day.
     CGFloat maxAge = 60 * 60 * 24;
 
-    SyncAssetsFileOp *configSyncOp =
-    [[SyncAssetsFileOp alloc] initForAssetsFile: ASSETS_FILE_CONFIG
-                                         maxAge: maxAge];
-    
-    SyncAssetsFileOp *cssSyncOp =
-    [[SyncAssetsFileOp alloc] initForAssetsFile: ASSETS_FILE_CSS
-                                         maxAge: maxAge];
-    
-    SyncAssetsFileOp *abuseFilterCssSyncOp =
-    [[SyncAssetsFileOp alloc] initForAssetsFile: ASSETS_FILE_CSS_ABUSE_FILTER
-                                         maxAge: maxAge];
-    
-    SyncAssetsFileOp *previewCssSyncOp =
-    [[SyncAssetsFileOp alloc] initForAssetsFile: ASSETS_FILE_CSS_PREVIEW
-                                         maxAge: maxAge];
+    [[QueuesSingleton sharedInstance].assetsFetchManager.operationQueue cancelAllOperations];
+
+    void (^fetch)(AssetsFileEnum) = ^void(AssetsFileEnum type) {
+        (void)[[AssetsFileFetcher alloc] initAndFetchAssetsFile: type
+                                                    withManager: [QueuesSingleton sharedInstance].assetsFetchManager
+                                                         maxAge: maxAge];
+    };
     
-    [[QueuesSingleton sharedInstance].assetsFileSyncQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].assetsFileSyncQ addOperation:configSyncOp];
-    [[QueuesSingleton sharedInstance].assetsFileSyncQ addOperation:cssSyncOp];
-    [[QueuesSingleton sharedInstance].assetsFileSyncQ addOperation:abuseFilterCssSyncOp];
-    [[QueuesSingleton sharedInstance].assetsFileSyncQ addOperation:previewCssSyncOp];
+    fetch(ASSETS_FILE_CONFIG);
+    fetch(ASSETS_FILE_CSS);
+    fetch(ASSETS_FILE_CSS_ABUSE_FILTER);
+    fetch(ASSETS_FILE_CSS_PREVIEW);
 }
 
 #pragma mark Edit section
@@ -1360,6 +1356,8 @@ - (void)didReceiveMemoryWarning
     [super didReceiveMemoryWarning];
     // Dispose of any resources that can be recreated.
 
+    //[self downloadAssetsFilesIfNecessary];
+
     /*
     OnboardingViewController *onboardingVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"OnboardingViewController"];
     [self presentViewController:onboardingVC animated:YES completion:^{}];
@@ -1381,6 +1379,8 @@ - (void)didReceiveMemoryWarning
 
     //ReferencesVC *referencesVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"ReferencesVC"];
     //[self presentViewController:referencesVC animated:YES completion:^{}];
+
+    //NSLog(@"articleFetchManager.operationCount = %lu", (unsigned long)[QueuesSingleton sharedInstance].articleFetchManager.operationQueue.operationCount);
 }
 
 -(void)toggleImageSheet
@@ -1531,330 +1531,241 @@ -(void)reloadCurrentArticleInvalidatingCache:(BOOL)invalidateCache
     showLoadingIndicator: YES];
 }
 
-- (void)retrieveArticleForPageTitle: (MWPageTitle *)pageTitle
-                             domain: (NSString *)domain
-                    discoveryMethod: (NSString *)discoveryMethod
+- (void)fetchFinished: (id)sender
+             userData: (id)userData
+               status: (FetchFinalStatus)status
+                error: (NSError *)error
 {
-    // Cancel any in-progress article retrieval operations
-    [[QueuesSingleton sharedInstance].articleRetrievalQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].searchQ cancelAllOperations];
-    [[QueuesSingleton sharedInstance].thumbnailQ cancelAllOperations];
-
-    __block NSManagedObjectID *articleID =
-    [articleDataContext_.mainContext getArticleIDForTitle: pageTitle.prefixedText
-                                                   domain: domain];
-    BOOL needsRefresh = NO;
-
-    if (articleID) {
-        Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-
-        // Update the history dateVisited timestamp of the article to be visited only
-        // if the article was NOT loaded via back or forward buttons.
-        if (![discoveryMethod isEqualToString:@"backforward"]) {
-            if (article.history.count > 0) { // There should only be a single history item.
-                History *history = [article.history anyObject];
-                history.dateVisited = [NSDate date];
-            }
-        }
+    if ([sender isKindOfClass:[ArticleFetcher class]]) {
         
-        // If article with sections just show them (unless needsRefresh is YES)
-        if (article.section.count > 0 && !article.needsRefresh.boolValue) {
-            [self.tocVC setTocSectionDataForSections:article.section];
-            [self displayArticle:articleID mode:DISPLAY_ALL_SECTIONS];
-            //[self showAlert:MWLocalizedString(@"search-loading-article-loaded", nil) type:ALERT_TYPE_TOP duration:-1];
-            [self fadeAlert];
-            return;
-        }
-        needsRefresh = article.needsRefresh.boolValue;
-    }
-
-    // Retrieve remaining sections op (dependent on first section op)
-    DownloadSectionsOp *remainingSectionsOp =
-    [[DownloadSectionsOp alloc] initForPageTitle: pageTitle.prefixedText
-                                          domain: [SessionSingleton sharedInstance].currentArticleDomain
-                                 leadSectionOnly: NO
-                                 completionBlock: ^(NSDictionary *results){
+        ArticleFetcher *articleFetcher = (ArticleFetcher *)sender;
+        Article *article = articleFetcher.article;
         
-        // Just in case the article wasn't created during the "parent" operation.
-        if (!articleID) return;
-
-        [articleDataContext_.mainContext performBlockAndWait:^(){
-            // The completion block happens on non-main thread, so must get article from articleID again.
-            // Because "you can only use a context on a thread when the context was created on that thread"
-            // this must happen on mainContext as well (see: http://stackoverflow.com/a/6356201/135557)
-            Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-
-            //Non-lead sections have been retreived so set needsRefresh to NO.
-            article.needsRefresh = @NO;
-
-            NSArray *sectionsRetrieved = results[@"sections"];
-
-            for (NSDictionary *section in sectionsRetrieved) {
-                if (![section[@"id"] isEqual: @0]) {
-                                    
-                    // Add sections for article
-                    Section *thisSection = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:articleDataContext_.mainContext];
-
-                    // Section index is a string because transclusion sections indexes will start with "T-".
-                    if ([section[@"index"] isKindOfClass:[NSString class]]) {
-                        thisSection.index = section[@"index"];
+        NSNumber *articleSectionType = (NSNumber *)userData;
+        
+        switch (articleSectionType.integerValue) {
+            case ARTICLE_SECTION_TYPE_LEAD:
+                
+                switch (status) {
+                    case FETCH_FINAL_STATUS_SUCCEEDED:
+                    {
+                        // Redirect if necessary.
+                        NSString *redirectedTitle = article.redirected;
+                        if (redirectedTitle.length > 0) {
+                            // Get discovery method for call to "retrieveArticleForPageTitle:".
+                            // There should only be a single history item (at most).
+                            History *history = [article.history anyObject];
+                            // Get the article's discovery method string.
+                            NSString *discoveryMethod =
+                            (history) ? history.discoveryMethod : [NAV getStringForDiscoveryMethod:DISCOVERY_METHOD_SEARCH];
+                            
+                            // Remove the article so it doesn't get saved.
+                            [article.managedObjectContext deleteObject:article];
+                            
+                            // Redirect!
+                            [self retrieveArticleForPageTitle: [MWPageTitle titleWithString:redirectedTitle]
+                                                       domain: article.domain
+                                              discoveryMethod: discoveryMethod];
+                            return;
+                        }
+                        
+                        // Associate thumbnail with article.
+                        // If search result for this pageTitle had a thumbnail url associated with it, see if
+                        // a core data image object exists with a matching sourceURL. If so make the article
+                        // thumbnailImage property point to that core data image object. This associates the
+                        // search result thumbnail with the article.
+                        NSPredicate *articlePredicate =
+                        [NSPredicate predicateWithFormat:@"(title == %@) AND (thumbnail.source.length > 0)", article.titleObj.text];
+                        NSDictionary *articleDictFromSearchResults =
+                        [ROOT.topMenuViewController.currentSearchResultsOrdered firstMatchForPredicate:articlePredicate];
+                        if (articleDictFromSearchResults) {
+                            NSString *thumbURL = articleDictFromSearchResults[@"thumbnail"][@"source"];
+                            thumbURL = [thumbURL getUrlWithoutScheme];
+                            Image *thumb = (Image *)[article.managedObjectContext getEntityForName: @"Image" withPredicateFormat:@"sourceUrl == %@", thumbURL];
+                            if (thumb) article.thumbnailImage = thumb;
+                        }
+                        
+                        // Actually save the article record.
+                        NSError *err = nil;
+                        [article.managedObjectContext save:&err];
+                        if (err) NSLog(@"Lead section save error = %@", err);
+                        
+                        // Update the toc and web view.
+                        [self.tocVC setTocSectionDataForSections:article.section];
+                        [self displayArticle:article.objectID mode:DISPLAY_LEAD_SECTION];
+                        
                     }
-
-                    thisSection.title = section[@"line"];
-
-                    if ([section[@"level"] isKindOfClass:[NSString class]]) {
-                        thisSection.level = section[@"level"];
+                        break;
+                    case FETCH_FINAL_STATUS_FAILED:
+                    {
+                        NSString *errorMsg = error.localizedDescription;
+                        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+                        
+                        // Remove the article so it doesn't get saved.
+                        [article.managedObjectContext deleteObject:article];
                     }
-
-                    // Section number, from the api, can be 3.5.2 etc, so it's a string.
-                    if ([section[@"number"] isKindOfClass:[NSString class]]) {
-                        thisSection.number = section[@"number"];
+                        break;
+                    case FETCH_FINAL_STATUS_CANCELLED:
+                    {
+                        // Remove the article so it doesn't get saved.
+                        [article.managedObjectContext deleteObject:article];
                     }
-
-                    if (section[@"fromtitle"]) {
-                        thisSection.fromTitle = section[@"fromtitle"];
+                        break;
+                        
+                    default:
+                        break;
+                }
+                
+                break;
+                
+            case ARTICLE_SECTION_TYPE_NON_LEAD:
+                
+                switch (status) {
+                    case FETCH_FINAL_STATUS_SUCCEEDED:
+                    {
+                        // Save the article record.
+                        NSError *err = nil;
+                        [article.managedObjectContext save:&err];
+                        if (err) NSLog(@"Non-lead section save error = %@", err);
+                        
+                        // Update the toc and web view.
+                        [self.tocVC setTocSectionDataForSections:article.section];
+                        [self displayArticle:article.objectID mode:DISPLAY_APPEND_NON_LEAD_SECTIONS];
+                        
                     }
-
-                    thisSection.sectionId = section[@"id"];
-
-                    thisSection.html = section[@"text"];
-                    thisSection.tocLevel = section[@"toclevel"];
-                    thisSection.dateRetrieved = [NSDate date];
-                    thisSection.anchor = (section[@"anchor"]) ? section[@"anchor"] : @"";
-
-                    [article addSectionObject:thisSection];
-
-                    [thisSection createImageRecordsForHtmlOnContext:articleDataContext_.mainContext];
+                        break;
+                    case FETCH_FINAL_STATUS_FAILED:
+                    {
+                        NSString *errorMsg = error.localizedDescription;
+                        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+                    }
+                        break;
+                    case FETCH_FINAL_STATUS_CANCELLED:
+                        [self fadeAlert];
+                        break;
+                        
+                    default:
+                        break;
                 }
-            }
-
-            NSError *error = nil;
-            [articleDataContext_.mainContext save:&error];
-
-            [self.tocVC setTocSectionDataForSections:article.section];
-
-        }];
-        
-        [self displayArticle:articleID mode:DISPLAY_APPEND_NON_LEAD_SECTIONS];
-        //[self showAlert:MWLocalizedString(@"search-loading-article-loaded", nil) type:ALERT_TYPE_TOP duration:-1];
-        //[self fadeAlert];
-
-    } cancelledBlock:^(NSError *error){
-        [self fadeAlert];
-    } errorBlock:^(NSError *error){
-        NSString *errorMsg = error.localizedDescription;
-        if(error.code != 555){ // Quick hack for hiding MWNetworkOp cancel messages.
-            [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
-        }
-    }];
-
-    remainingSectionsOp.delegate = self;
-
-
-    // Retrieve first section op
-    DownloadSectionsOp *firstSectionOp =
-    [[DownloadSectionsOp alloc] initForPageTitle: pageTitle.prefixedText
-                                          domain: [SessionSingleton sharedInstance].currentArticleDomain
-                                 leadSectionOnly: YES
-                                 completionBlock: ^(NSDictionary *dataRetrieved){
-
-
-        NSString *redirectedTitle = [dataRetrieved[@"redirected"] copy];
-
-        // Redirect if the pageTitle which triggered this call to "retrieveArticleForPageTitle"
-        // differs from titleReflectingAnyRedirects.
-        if (redirectedTitle.length > 0) {
-            MWPageTitle *newTitle = [MWPageTitle titleWithString:redirectedTitle];
-            [self retrieveArticleForPageTitle: newTitle
-                                       domain: domain
-                              discoveryMethod: discoveryMethod];
-            return;
+                
+                break;
+            default:
+                break;
         }
 
-        [articleDataContext_.mainContext performBlockAndWait:^(){
-            Article *article = nil;
-
-            if (!articleID) {
-                article = [NSEntityDescription
-                    insertNewObjectForEntityForName:@"Article"
-                    inManagedObjectContext:articleDataContext_.mainContext
-                ];
-                article.title = pageTitle.prefixedText;
-                article.dateCreated = [NSDate date];
-                article.site = [SessionSingleton sharedInstance].site;
-                article.domain = [SessionSingleton sharedInstance].currentArticleDomain;
-                article.domainName = [SessionSingleton sharedInstance].currentArticleDomainName;
-                articleID = article.objectID;
-            }else{
-                article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-            }
-
-            if (needsRefresh) {
-                // If and article needs refreshing remove its sections so they get reloaded too.
-                for (Section *thisSection in [article.section copy]) {
-                    [articleDataContext_.mainContext deleteObject:thisSection];
+    } else if ([sender isKindOfClass:[WikipediaZeroMessageFetcher class]]) {
+
+        switch (status) {
+            case FETCH_FINAL_STATUS_SUCCEEDED:
+            {
+                NSString *title = (NSString *)userData;
+                if (title) {
+                    TopMenuTextFieldContainer *textFieldContainer = [ROOT.topMenuViewController getNavBarItem:NAVBAR_TEXT_FIELD];
+                    textFieldContainer.textField.placeholder = MWLocalizedString(@"search-field-placeholder-text-zero", nil);
+                    
+                    //[self showAlert:title type:ALERT_TYPE_TOP duration:2];
+                    self.zeroStatusLabel.text = title;
+                    self.zeroStatusLabel.padding = UIEdgeInsetsMake(3, 10, 3, 10);
+                    self.zeroStatusLabel.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.93];
+                    
+                    [NAV promptFirstTimeZeroOnWithTitleIfAppropriate:title];
                 }
             }
-
-            // If "needsRefresh", an existing article's data is being retrieved again, so these need
-            // to be updated whether a new article record is being inserted or not as data may have
-            // changed since the article record was first created.
-            article.languagecount = dataRetrieved[@"languagecount"];
-            article.lastmodified = dataRetrieved[@"lastmodified"];
-            article.lastmodifiedby = dataRetrieved[@"lastmodifiedby"];
-            article.articleId = dataRetrieved[@"articleId"];
-            article.editable = dataRetrieved[@"editable"];
-            article.protectionStatus = dataRetrieved[@"protectionStatus"];
-            article.displayTitle = dataRetrieved[@"displaytitle"];
-
-
-            // Note: Because "retrieveArticleForPageTitle" recurses with the redirected-to title if
-            // the lead section op determines a redirect occurred, the "redirected" value below will
-            // probably never be set.
-            article.redirected = dataRetrieved[@"redirected"];
-
-            //NSDateFormatter *anotherDateFormatter = [[NSDateFormatter alloc] init];
-            //[anotherDateFormatter setDateStyle:NSDateFormatterLongStyle];
-            //[anotherDateFormatter setTimeStyle:NSDateFormatterShortStyle];
-            //NSLog(@"formatted lastmodified = %@", [anotherDateFormatter stringFromDate:article.lastmodified]);
-
-            // Associate thumbnail with article.
-            // If search result for this pageTitle had a thumbnail url associated with it, see if
-            // a core data image object exists with a matching sourceURL. If so make the article
-            // thumbnailImage property point to that core data image object. This associates the
-            // search result thumbnail with the article.
-            NSPredicate *articlePredicate =
-                [NSPredicate predicateWithFormat:@"(title == %@) AND (thumbnail.source.length > 0)", pageTitle.text];
-            NSDictionary *articleDictFromSearchResults =
-                [ROOT.topMenuViewController.currentSearchResultsOrdered firstMatchForPredicate:articlePredicate];
-            if (articleDictFromSearchResults) {
-                NSString *thumbURL = articleDictFromSearchResults[@"thumbnail"][@"source"];
-                thumbURL = [thumbURL getUrlWithoutScheme];
-                Image *thumb = (Image *)[articleDataContext_.mainContext getEntityForName: @"Image" withPredicateFormat:@"sourceUrl == %@", thumbURL];
-                if (thumb) article.thumbnailImage = thumb;
-            }
-
-            article.lastScrollX = @0.0f;
-            article.lastScrollY = @0.0f;
-
-            // Get article section zero html
-            NSArray *sectionsRetrieved = dataRetrieved[@"sections"];
-            NSDictionary *section0Dict = (sectionsRetrieved.count >= 1) ? sectionsRetrieved[0] : nil;
-
-            // If there was only one section then we have what we need so no refresh
-            // is needed. Otherwise leave needsRefresh set to YES until subsequent sections
-            // have been retrieved. Reminder: "onlyrequestedsections" is not used
-            // by the mobileview query so that sectionsRetrieved.count will
-            // reflect the article's total number of sections here ("sections"
-            // was set to "0" though so only the first section entry actually has
-            // any html). This fixes the bug which caused subsequent sections to never
-            // be retrieved if the article was navigated away from before they had loaded.
-            article.needsRefresh = (sectionsRetrieved.count == 1) ? @NO : @YES;
-
-            NSString *section0HTML = @"";
-            if (section0Dict && [section0Dict[@"id"] isEqual: @0] && section0Dict[@"text"]) {
-                section0HTML = section0Dict[@"text"];
-            }
-
-            // Add sections for article
-            Section *section0 = [NSEntityDescription insertNewObjectForEntityForName:@"Section" inManagedObjectContext:articleDataContext_.mainContext];
-            // Section index is a string because transclusion sections indexes will start with "T-"
-            section0.index = @"0";
-            section0.level = @"0";
-            section0.number = @"0";
-            section0.sectionId = @0;
-            section0.title = @"";
-            section0.dateRetrieved = [NSDate date];
-            section0.html = section0HTML;
-            section0.anchor = @"";
-            
-            [article addSectionObject:section0];
-
-            [section0 createImageRecordsForHtmlOnContext:articleDataContext_.mainContext];
-
-            // Don't add multiple history items for the same article or back-forward button
-            // behavior becomes a confusing mess.
-            if(article.history.count == 0){
-                // Add history for article
-                History *history0 = [NSEntityDescription insertNewObjectForEntityForName:@"History" inManagedObjectContext:articleDataContext_.mainContext];
-                history0.dateVisited = [NSDate date];
-                //history0.dateVisited = [NSDate dateWithDaysBeforeNow:31];
-                history0.discoveryMethod = discoveryMethod;
-                [article addHistoryObject:history0];
+                break;
+            case FETCH_FINAL_STATUS_FAILED:
+            {
+                
             }
-
-            // Save the article!
-            NSError *error = nil;
-            [articleDataContext_.mainContext save:&error];
-
-            [self.tocVC setTocSectionDataForSections:article.section];
-
-            if (error) {
-                NSLog(@"error = %@", error);
-                NSLog(@"error = %@", error.localizedDescription);
+                break;
+            case FETCH_FINAL_STATUS_CANCELLED:
+            {
+                
             }
-        }];
-
-        [self displayArticle:articleID mode:DISPLAY_LEAD_SECTION];
-        //[self showAlert:MWLocalizedString(@"search-loading-section-remaining", nil) type:ALERT_TYPE_TOP duration:-1];
-
-    } cancelledBlock:^(NSError *error){
-
-        [self loadingIndicatorHide];
-
-        // Remove the article so it doesn't get saved.
-        if (articleID) {
-            Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-            [articleDataContext_.mainContext deleteObject:article];
+                break;
         }
+    }
 
-    } errorBlock:^(NSError *error){
+}
 
-        [self loadingIndicatorHide];
+- (void)retrieveArticleForPageTitle: (MWPageTitle *)pageTitle
+                             domain: (NSString *)domain
+                    discoveryMethod: (NSString *)discoveryMethod
+{
+    // Cancel certain in-progress fetches.
+    [[QueuesSingleton sharedInstance].articleFetchManager.operationQueue cancelAllOperations];
+    [[QueuesSingleton sharedInstance].searchResultsFetchManager.operationQueue cancelAllOperations];
 
-        NSString *errorMsg = error.localizedDescription;
-        [self showAlert:errorMsg type:ALERT_TYPE_TOP duration:-1];
+    [articleDataContext_.mainContext performBlockAndWait:^(){
+        
+        __block NSManagedObjectID *articleID =
+        [articleDataContext_.mainContext getArticleIDForTitle: pageTitle.prefixedText
+                                                       domain: domain];
+        BOOL needsRefresh = NO;
+        
+        Article *article = nil;
         if (articleID) {
-            // Remove the article so it doesn't get saved.
-            Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-            [articleDataContext_.mainContext deleteObject:article];
+            article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
+            
+            // Update the history dateVisited timestamp of the article to be visited only
+            // if the article was NOT loaded via back or forward buttons.
+            if (![discoveryMethod isEqualToString:@"backforward"]) {
+                if (article.history.count > 0) { // There should only be a single history item.
+                    History *history = [article.history anyObject];
+                    history.dateVisited = [NSDate date];
+                }
+            }
+            
+            // If article with sections just show them (unless needsRefresh is YES)
+            if (article.section.count > 0 && !article.needsRefresh.boolValue) {
+                [self.tocVC setTocSectionDataForSections:article.section];
+                [self displayArticle:articleID mode:DISPLAY_ALL_SECTIONS];
+                //[self showAlert:MWLocalizedString(@"search-loading-article-loaded", nil) type:ALERT_TYPE_TOP duration:-1];
+                [self fadeAlert];
+                return;
+            }
+            needsRefresh = article.needsRefresh.boolValue;
+            
+        }else{
+            
+            article = [NSEntityDescription
+                       insertNewObjectForEntityForName:@"Article"
+                       inManagedObjectContext:articleDataContext_.mainContext
+                       ];
+            article.lastmodifiedby = @"";
+            article.redirected = @"";
+            article.title = pageTitle.prefixedText;
+            article.dateCreated = [NSDate date];
+            article.site = [SessionSingleton sharedInstance].site;
+            article.domain = [SessionSingleton sharedInstance].currentArticleDomain;
+            article.domainName = [SessionSingleton sharedInstance].currentArticleDomainName;
+            articleID = article.objectID;
+            
+            // Add history record.
+            // Note: don't add multiple history items for the same article or back-forward
+            // button behavior becomes a confusing mess.
+            History *newHistory =
+            [NSEntityDescription insertNewObjectForEntityForName: @"History"
+                                          inManagedObjectContext: article.managedObjectContext];
+            newHistory.dateVisited = [NSDate date];
+            //newHistory.dateVisited = [NSDate dateWithDaysBeforeNow:31];
+            newHistory.discoveryMethod = discoveryMethod;
+            [article addHistoryObject:newHistory];
         }
         
-        // @TODO potentially do this in the difFailWithError in MWNetworkOp
-        // It seems safe enough, but we didn't want to cause any sort of memory leak
-        if (error.domain == NSStreamSocketSSLErrorDomain ||
-            (error.domain == NSURLErrorDomain &&
-             (error.code == NSURLErrorSecureConnectionFailed ||
-              error.code == NSURLErrorServerCertificateHasBadDate ||
-              error.code == NSURLErrorServerCertificateUntrusted ||
-              error.code == NSURLErrorServerCertificateHasUnknownRoot ||
-              error.code == NSURLErrorServerCertificateNotYetValid)
-             )
-            ) {
-            [SessionSingleton sharedInstance].fallback = true;
+        if (needsRefresh) {
+            // If and article needs refreshing remove its sections so they get reloaded too.
+            for (Section *thisSection in [article.section copy]) {
+                [articleDataContext_.mainContext deleteObject:thisSection];
+            }
         }
-    }];
-
-    firstSectionOp.delegate = self;
-    
-    
-    // Retrieval of remaining sections depends on retrieving first section
-    [remainingSectionsOp addDependency:firstSectionOp];
-    
-    [[QueuesSingleton sharedInstance].articleRetrievalQ addOperation:remainingSectionsOp];
-    [[QueuesSingleton sharedInstance].articleRetrievalQ addOperation:firstSectionOp];
-}
-
-#pragma mark Progress report
+        
+        // "fetchFinished:" above will be notified when articleFetcher has actually retrieved some data.
+        // Note: cast to void to avoid compiler warning: http://stackoverflow.com/a/7915839
+        (void)[[ArticleFetcher alloc] initAndFetchSectionsForArticle: article
+                                                         withManager: [QueuesSingleton sharedInstance].articleFetchManager
+                                                  thenNotifyDelegate: self];
 
--(void)opProgressed:(MWNetworkOp *)op;
-{
-    return;
-    if (op.dataRetrieved.length) {
-        NSLog(@"Receive progress: %lu of %lu", (unsigned long)op.dataRetrieved.length, (unsigned long)op.dataRetrievedExpectedLength);
-    }else{
-        NSLog(@"Send progress: %@ of %@", op.bytesWritten, op.bytesExpectedToWrite);
-    }
+    }];
 }
 
 #pragma mark Display article from core data
@@ -1919,12 +1830,12 @@ - (void)displayArticle:(NSManagedObjectID *)articleID mode:(DisplayMode)mode
             self.scrollOffset = scrollOffset;
         }
 
-
         if (mode != DISPLAY_APPEND_NON_LEAD_SECTIONS) {
             if (![[SessionSingleton sharedInstance] isCurrentArticleMain]) {
                 if (mode == DISPLAY_LEAD_SECTION) {
                     [sectionTextArray addObject: [NSString stringWithFormat:@"<div id='nonLeadSectionsInjectionPoint' style='margin-top:2em;margin-bottom:2em;'>%@</div>", MWLocalizedString(@"search-loading-section-remaining", nil)]];
                 }
+
                 [sectionTextArray addObject: [self renderFooterDivider]];
                 [sectionTextArray addObject: [self renderLastModified:lastModified by:lastModifiedBy]];
                 [sectionTextArray addObject: [self renderLanguageButtonForCount: langCount.integerValue]];
@@ -1961,7 +1872,6 @@ - (void)displayArticle:(NSManagedObjectID *)articleID mode:(DisplayMode)mode
                                    @"dir": languageInfo.dir,
                                    @"uidir": uidir
                                    }];
-        
         if (mode != DISPLAY_APPEND_NON_LEAD_SECTIONS) {
         
             [self.bridge sendMessage:@"append" withPayload:@{@"html": htmlStr}];
@@ -1972,6 +1882,8 @@ - (void)displayArticle:(NSManagedObjectID *)articleID mode:(DisplayMode)mode
             [self.bridge sendMessage:@"injectNonLeadSections" withPayload:@{@"html": htmlStr}];
         }
         // Note: we set the scroll position later, after the size has been calculated
+
+
         
         if (!self.editable) {
             [self.bridge sendMessage:@"setPageProtected" withPayload:@{}];
@@ -2110,52 +2022,28 @@ -(void)scrollToElementOnScreenBeforeRotate
 
 -(void)zeroStateChanged: (NSNotification*) notification
 {
-    [[QueuesSingleton sharedInstance].zeroRatedMessageStringQ cancelAllOperations];
+    [[QueuesSingleton sharedInstance].zeroRatedMessageFetchManager.operationQueue cancelAllOperations];
 
     if ([[[notification userInfo] objectForKey:@"state"] boolValue]) {
-        DownloadWikipediaZeroMessageOp *zeroMessageRetrievalOp =
-        [
-         [DownloadWikipediaZeroMessageOp alloc]
-         initForDomain: [SessionSingleton sharedInstance].currentArticleDomain
-         completionBlock: ^(NSString *title) {
-         
-             if (title) {
-                 dispatch_async(dispatch_get_main_queue(), ^(){
-                 
-                     TopMenuTextFieldContainer *textFieldContainer = [ROOT.topMenuViewController getNavBarItem:NAVBAR_TEXT_FIELD];
-                     textFieldContainer.textField.placeholder = MWLocalizedString(@"search-field-placeholder-text-zero", nil);
-
-                     self.zeroStatusLabel.text = title;
-                     self.zeroStatusLabel.padding = UIEdgeInsetsMake(3, 10, 3, 10);
-                     self.zeroStatusLabel.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.93];
-
-                     [self showAlert:title type:ALERT_TYPE_TOP duration:2];
-                     [NAV promptFirstTimeZeroOnWithTitleIfAppropriate:title];
-                 });
-             }
-         } cancelledBlock:^(NSError *errorCancel) {
-             NSLog(@"error w0 cancel");
-         } errorBlock:^(NSError *errorError) {
-             NSLog(@"error w0 error");
-         }];
-
-        [[QueuesSingleton sharedInstance].zeroRatedMessageStringQ addOperation:zeroMessageRetrievalOp];
-        
+        (void)[[WikipediaZeroMessageFetcher alloc] initAndFetchMessageForDomain: [SessionSingleton sharedInstance].currentArticleDomain
+                                                                    withManager: [QueuesSingleton sharedInstance].zeroRatedMessageFetchManager
+                                                             thenNotifyDelegate: self];
     } else {
-    
         TopMenuTextFieldContainer *textFieldContainer = [ROOT.topMenuViewController getNavBarItem:NAVBAR_TEXT_FIELD];
         textFieldContainer.textField.placeholder = MWLocalizedString(@"search-field-placeholder-text", nil);
         NSString *warnVerbiage = MWLocalizedString(@"zero-charged-verbiage", nil);
 
+        CGFloat duration = 5.0f;
+
+        //[self showAlert:warnVerbiage type:ALERT_TYPE_TOP duration:duration];
         self.zeroStatusLabel.text = warnVerbiage;
         self.zeroStatusLabel.backgroundColor = [UIColor redColor];
         
-        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
+        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
             self.zeroStatusLabel.text = @"";
             self.zeroStatusLabel.padding = UIEdgeInsetsZero;
         });
 
-        [self showAlert:warnVerbiage type:ALERT_TYPE_TOP duration:-1];
         [NAV promptZeroOff];
     }
 }
diff --git a/wikipedia/assets/abusefilter.css b/wikipedia/assets/abusefilter.css
index 40d4271b948..1aeebe8d6ee 100644
--- a/wikipedia/assets/abusefilter.css
+++ b/wikipedia/assets/abusefilter.css
@@ -1,2 +1,2 @@
-html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}#section_0{line-height:1.3}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.content p{margin:.5em 0 1em 0}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #ccc}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content a > img{max-width:100% !important;height:auto !important}.content ul{list-style:square inside}.content ol{list-style:decimal inside}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#f2f2f2;text-align:center}.content table caption{display:block;text-align:left}.content div.magnify{display:none}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}strong,b{font-weight:bold}em,i{font-style:italic}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-09-25T16:25:00Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}dl{margin-left:1em}dl dt{font-weight:bold}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.nomobile{display:none}.plainlinks a{background:none !important;padding:0 !important}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#f9f9f9;text-align:center !important}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}a.edit_section_button{height:32px;width:32px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAANlBMVEUAAAD///9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW+FiFraAAAAEXRSTlMAABAgMEBQYHCAkKCwwNDg8InUWv0AAAGfSURBVHhe7djBjsIgFIXhOwjFeltK3/9lJ4J6SG5dHGgyyaRn1dUXlb8slJ+T9//AC7zACxRiLu37EqXsDPCW9ue2cBLo8/7a/RQwFK9OTwDj3k6Hwbk6Mb/EeRDUojyaHzKMgG4pRmy/ehoAXcklT3h+buoGffU8vDJlQJtfuuG5busEY/Xc28N4EPkp7EHwUaODjSkLIr8Iu/VIELkE2Bj9psDzSBuLQoLIxX1sLEfhQHirQ9rwvLAgcoHdejx4b3IJ8PDOcCBysfklJzToipc9Piu2OKFA5LL5o/xUhAZ9Qi7W40Dkspj8as48OGXkYj0ORH73w/yC8OCMXA5y5sE2lwgPh86Bbi3h+i8506Brc3kYjwb9VkL7lh8N+jaXxXg0GBGayW8WCoSXq+dNzjyIXGx+UXhQm1yCyZkHA8JAfvBosF6h21RvU3vb86B+4lCTcxf4rkTV3PZ9IAiTcxcYvnm94P3Qi9IN6rHXDybL5SAD4IHnZQAMxtu8jIA4E+Q8BKr1xkCcybrOcwhOBsE3JOT+4G+WC7zAC7zAXxMIT+qGYJfyAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/less/../images/edit.png?2014-09-25T16:25:00Z)!ie;background-size:32px 32px;float:right;display:inline-float}.no-editing a.edit_section_button{display:none}.page-protected a.edit_section_button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAXVBMVEUAAAD////Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz8/Pz8/Pz89sbW/Pz89sbW/Pz8/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW+fZUWwAAAAHXRSTlMAABAQICAwMEBAUFBgYHBwgJCgoLDAwNDQ4ODw8PGFG8cAAAHOSURBVHhe7dTLcoMwDAVQxVCXJAoByiPUEf//mcW0Gh5KFrbojrtidUYM9wKnnfOP4AEe4AGCT3JvmuHR3BOAXcDrc/jN87wLeBvmnCUIATnZEUyeC/A7UYHWjeDdQ48PSL68eNOA6GgEH9Nh3m9GsFGASOTB6S7wufrHeLCkGfycwLMKrGgBwm8UoKknD/cCTffn7QSmk+cup51A6ybP+hsGmUCQvd7CTiCST2dAB0pPAcr6VQY0oPRgCqpB005eydvTglxnPlYLWvZ4ezqQ65zxsVrwwvPg7SlBJJ4HH6sDc64ze0qwWnroSAHKeSDRDL6JBGX9eB4FKUH2Sj5WC9p+PQ8lyA1BPnYVZ4NBnOssvS4NvhBp4dl+45nAV+Yv2q3nwakMBICyztnWAwgEzcpDWgchABR1Fp5DCAXTlVdtPAuBINevEB5/pQBQ1rneeAZCQaTVPERdQsGMVn97UZdgMJ89UeccIsDaA7V55SHEgD0vDtCJukSAKQM5kvBiwAtxRF3iwPKtFwm2TIi6RIJvvGgwe+UhxIO55ByCAqylZ0ED9luvt6ABU1kXUIHLWru2LVoDOrAk6tu6KLKMJSVohaMAtTnA4BzgAf4Asb6U9nmPcP4AAAAASUVORK5CYII=);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/less/../images/edit-locked.png?2014-09-25T16:25:00Z)!ie}#mainpage a.edit_section_button{display:none}.content-rtl a.edit_section_button{float:left;-webkit-transform:scaleX(-1);transform:scaleX(-1)}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
-/* cache key: enwiki:resourceloader:filter:minify-css:7:12f4f4cebd4c950021ff8d5d21e36039 */
\ No newline at end of file
+html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}.nomobile{display:none !important}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #CCC}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content a > img{max-width:100% !important;height:auto !important}.content div.magnify{display:none}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}#section_0{line-height:1.3}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content ul{list-style:square inside}.content ol{list-style:decimal inside}dl{margin-left:1em}dl dt{font-weight:bold}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-10-16T19:01:40Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}.plainlinks a{background:none !important;padding:0 !important}.content p{margin:.5em 0 1em 0}strong,b{font-weight:bold}em,i{font-style:italic}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#EEE;text-align:center}.content table caption{display:block;text-align:left}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#F9F9F9;text-align:center !important}.content table.infobox table td{border:none}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}a.edit_section_button{height:32px;width:32px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAANlBMVEUAAAD///9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW+FiFraAAAAEXRSTlMAABAgMEBQYHCAkKCwwNDg8InUWv0AAAGfSURBVHhe7djBjsIgFIXhOwjFeltK3/9lJ4J6SG5dHGgyyaRn1dUXlb8slJ+T9//AC7zACxRiLu37EqXsDPCW9ue2cBLo8/7a/RQwFK9OTwDj3k6Hwbk6Mb/EeRDUojyaHzKMgG4pRmy/ehoAXcklT3h+buoGffU8vDJlQJtfuuG5busEY/Xc28N4EPkp7EHwUaODjSkLIr8Iu/VIELkE2Bj9psDzSBuLQoLIxX1sLEfhQHirQ9rwvLAgcoHdejx4b3IJ8PDOcCBysfklJzToipc9Piu2OKFA5LL5o/xUhAZ9Qi7W40Dkspj8as48OGXkYj0ORH73w/yC8OCMXA5y5sE2lwgPh86Bbi3h+i8506Brc3kYjwb9VkL7lh8N+jaXxXg0GBGayW8WCoSXq+dNzjyIXGx+UXhQm1yCyZkHA8JAfvBosF6h21RvU3vb86B+4lCTcxf4rkTV3PZ9IAiTcxcYvnm94P3Qi9IN6rHXDybL5SAD4IHnZQAMxtu8jIA4E+Q8BKr1xkCcybrOcwhOBsE3JOT+4G+WC7zAC7zAXxMIT+qGYJfyAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/less/../images/edit.png?2014-10-16T19:01:40Z)!ie;background-size:32px 32px;float:right;display:inline-float}.no-editing a.edit_section_button{display:none}.page-protected a.edit_section_button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAXVBMVEUAAAD////Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz8/Pz8/Pz89sbW/Pz89sbW/Pz8/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW+fZUWwAAAAHXRSTlMAABAQICAwMEBAUFBgYHBwgJCgoLDAwNDQ4ODw8PGFG8cAAAHOSURBVHhe7dTLcoMwDAVQxVCXJAoByiPUEf//mcW0Gh5KFrbojrtidUYM9wKnnfOP4AEe4AGCT3JvmuHR3BOAXcDrc/jN87wLeBvmnCUIATnZEUyeC/A7UYHWjeDdQ48PSL68eNOA6GgEH9Nh3m9GsFGASOTB6S7wufrHeLCkGfycwLMKrGgBwm8UoKknD/cCTffn7QSmk+cup51A6ybP+hsGmUCQvd7CTiCST2dAB0pPAcr6VQY0oPRgCqpB005eydvTglxnPlYLWvZ4ezqQ65zxsVrwwvPg7SlBJJ4HH6sDc64ze0qwWnroSAHKeSDRDL6JBGX9eB4FKUH2Sj5WC9p+PQ8lyA1BPnYVZ4NBnOssvS4NvhBp4dl+45nAV+Yv2q3nwakMBICyztnWAwgEzcpDWgchABR1Fp5DCAXTlVdtPAuBINevEB5/pQBQ1rneeAZCQaTVPERdQsGMVn97UZdgMJ89UeccIsDaA7V55SHEgD0vDtCJukSAKQM5kvBiwAtxRF3iwPKtFwm2TIi6RIJvvGgwe+UhxIO55ByCAqylZ0ED9luvt6ABU1kXUIHLWru2LVoDOrAk6tu6KLKMJSVohaMAtTnA4BzgAf4Asb6U9nmPcP4AAAAASUVORK5CYII=);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/less/../images/edit-locked.png?2014-10-16T19:01:40Z)!ie}#mainpage a.edit_section_button{display:none}.content-rtl a.edit_section_button{float:left;-webkit-transform:scaleX(-1);transform:scaleX(-1)}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
+/* cache key: enwiki:resourceloader:filter:minify-css:7:80d903e26a7dc2ed9a3828f15a7550cb */
\ No newline at end of file
diff --git a/wikipedia/assets/preview.css b/wikipedia/assets/preview.css
index e29881eb3f6..928f271ff57 100644
--- a/wikipedia/assets/preview.css
+++ b/wikipedia/assets/preview.css
@@ -1,2 +1,2 @@
-html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}#section_0{line-height:1.3}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.content p{margin:.5em 0 1em 0}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #ccc}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content a > img{max-width:100% !important;height:auto !important}.content ul{list-style:square inside}.content ol{list-style:decimal inside}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#f2f2f2;text-align:center}.content table caption{display:block;text-align:left}.content div.magnify{display:none}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}strong,b{font-weight:bold}em,i{font-style:italic}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-09-25T16:25:00Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}dl{margin-left:1em}dl dt{font-weight:bold}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.nomobile{display:none}.plainlinks a{background:none !important;padding:0 !important}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#f9f9f9;text-align:center !important}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}.edit-page{display:none}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
-/* cache key: enwiki:resourceloader:filter:minify-css:7:5a67d5f3f583184866f262de63408eba */
\ No newline at end of file
+html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}.nomobile{display:none !important}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #CCC}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content a > img{max-width:100% !important;height:auto !important}.content div.magnify{display:none}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}#section_0{line-height:1.3}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content ul{list-style:square inside}.content ol{list-style:decimal inside}dl{margin-left:1em}dl dt{font-weight:bold}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-10-16T19:01:40Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}.plainlinks a{background:none !important;padding:0 !important}.content p{margin:.5em 0 1em 0}strong,b{font-weight:bold}em,i{font-style:italic}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#EEE;text-align:center}.content table caption{display:block;text-align:left}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#F9F9F9;text-align:center !important}.content table.infobox table td{border:none}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}.edit-page{display:none}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
+/* cache key: enwiki:resourceloader:filter:minify-css:7:95ef01fbe5ce0e0d5d6687d1f4e2c3b2 */
\ No newline at end of file
diff --git a/wikipedia/assets/styles.css b/wikipedia/assets/styles.css
index 40d4271b948..1aeebe8d6ee 100644
--- a/wikipedia/assets/styles.css
+++ b/wikipedia/assets/styles.css
@@ -1,2 +1,2 @@
-html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}#section_0{line-height:1.3}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.content p{margin:.5em 0 1em 0}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #ccc}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content a > img{max-width:100% !important;height:auto !important}.content ul{list-style:square inside}.content ol{list-style:decimal inside}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#f2f2f2;text-align:center}.content table caption{display:block;text-align:left}.content div.magnify{display:none}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}strong,b{font-weight:bold}em,i{font-style:italic}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-09-25T16:25:00Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCI+PGRlZnM+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNLS45NTgtNC4yNTljLTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2IDAgLjM5NC4xNDMuNzM2LjMzNiAxLjA0OWwtLjA3LjA1NmMtLjM3My0uNTEzLS45NTQtLjg2Ny0xLjYzNi0uODY3LTEuMTM0IDAtMi4wNTYuOTIyLTIuMDU2IDIuMDU2cy45MjIgMi4wNTYgMi4wNTYgMi4wNTZjLjU5NiAwIDEuMTIxLS4yNjUgMS40OTYtLjY3MS0uMDc1LjIxMy0uMTI2LjQzMy0uMTI2LjY3MSAwIDEuMTM0LjkyMiAyLjA1NiAyLjA1NiAyLjA1NnMyLjA1Ni0uOTIyIDIuMDU2LTIuMDU2YzAtLjQ3Ni0uMTg5LS44OTYtLjQ2Mi0xLjI0NS44MTMuMTU4IDEuNjI3LjQ3NyAyLjIyNCAxLjM5OS0uNDQzLS40NDMtLjcyNy0xLjI0OC0uNzI3LTIuMzM2bC0uMzc4LS4wMjguMzUtLjAxNGMwLTEuMDg3LjI3LTEuODkzLjcxMy0yLjMzNi0uNTc1Ljg4OS0xLjM1NCAxLjIxNi0yLjE0IDEuMzg1LjI0My0uMzM3LjQyLS43MjguNDItMS4xNzUgMC0xLjEzNC0uOTIyLTIuMDU2LTIuMDU2LTIuMDU2eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIj48cGF0aCBkPSJNMC0yLjgyOGwtMi44MjggMi44MjggMi44MjggMi44MjggMi44MjgtMi44MjgtMi44MjgtMi44Mjh6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSJOYU4iLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiPjxwYXRoIGQ9Ik0xMCAwbDQtNC0xNCA0IDE0IDQtNC00eiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9tYXJrZXI+PC9kZWZzPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzA2YyIgZD0iTS41IDMuNTE4aDUuOTgydjUuOTgyaC01Ljk4MnoiLz48cGF0aCBkPSJNNC43NTUtLjE2aDUuMjM0djUuMzlsLTEuNTcxIDEuNTQ0LTEuMzEtMS4zMS0yLjcyNSAyLjcyNS0yLjY4OC0yLjY4OCAyLjgwOC0yLjgwOC0xLjMxLTEuMzF6IiBmaWxsPSIjMDZmIi8+PHBhdGggZD0iTTguOTg0Ljg0NWwuMDIyIDQuODg0LTEuODE3LTEuODE3LTIuODgxIDIuODgxLTEuMjI3LTEuMjI3IDIuODgxLTIuODgxLTEuODUtMS44NTF6IiBmaWxsPSIjZmZmIi8+PC9zdmc+);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-09-25T16:25:00Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}dl{margin-left:1em}dl dt{font-weight:bold}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.nomobile{display:none}.plainlinks a{background:none !important;padding:0 !important}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#f9f9f9;text-align:center !important}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}a.edit_section_button{height:32px;width:32px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAANlBMVEUAAAD///9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW+FiFraAAAAEXRSTlMAABAgMEBQYHCAkKCwwNDg8InUWv0AAAGfSURBVHhe7djBjsIgFIXhOwjFeltK3/9lJ4J6SG5dHGgyyaRn1dUXlb8slJ+T9//AC7zACxRiLu37EqXsDPCW9ue2cBLo8/7a/RQwFK9OTwDj3k6Hwbk6Mb/EeRDUojyaHzKMgG4pRmy/ehoAXcklT3h+buoGffU8vDJlQJtfuuG5busEY/Xc28N4EPkp7EHwUaODjSkLIr8Iu/VIELkE2Bj9psDzSBuLQoLIxX1sLEfhQHirQ9rwvLAgcoHdejx4b3IJ8PDOcCBysfklJzToipc9Piu2OKFA5LL5o/xUhAZ9Qi7W40Dkspj8as48OGXkYj0ORH73w/yC8OCMXA5y5sE2lwgPh86Bbi3h+i8506Brc3kYjwb9VkL7lh8N+jaXxXg0GBGayW8WCoSXq+dNzjyIXGx+UXhQm1yCyZkHA8JAfvBosF6h21RvU3vb86B+4lCTcxf4rkTV3PZ9IAiTcxcYvnm94P3Qi9IN6rHXDybL5SAD4IHnZQAMxtu8jIA4E+Q8BKr1xkCcybrOcwhOBsE3JOT+4G+WC7zAC7zAXxMIT+qGYJfyAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/less/../images/edit.png?2014-09-25T16:25:00Z)!ie;background-size:32px 32px;float:right;display:inline-float}.no-editing a.edit_section_button{display:none}.page-protected a.edit_section_button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAXVBMVEUAAAD////Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz8/Pz8/Pz89sbW/Pz89sbW/Pz8/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW+fZUWwAAAAHXRSTlMAABAQICAwMEBAUFBgYHBwgJCgoLDAwNDQ4ODw8PGFG8cAAAHOSURBVHhe7dTLcoMwDAVQxVCXJAoByiPUEf//mcW0Gh5KFrbojrtidUYM9wKnnfOP4AEe4AGCT3JvmuHR3BOAXcDrc/jN87wLeBvmnCUIATnZEUyeC/A7UYHWjeDdQ48PSL68eNOA6GgEH9Nh3m9GsFGASOTB6S7wufrHeLCkGfycwLMKrGgBwm8UoKknD/cCTffn7QSmk+cup51A6ybP+hsGmUCQvd7CTiCST2dAB0pPAcr6VQY0oPRgCqpB005eydvTglxnPlYLWvZ4ezqQ65zxsVrwwvPg7SlBJJ4HH6sDc64ze0qwWnroSAHKeSDRDL6JBGX9eB4FKUH2Sj5WC9p+PQ8lyA1BPnYVZ4NBnOssvS4NvhBp4dl+45nAV+Yv2q3nwakMBICyztnWAwgEzcpDWgchABR1Fp5DCAXTlVdtPAuBINevEB5/pQBQ1rneeAZCQaTVPERdQsGMVn97UZdgMJ89UeccIsDaA7V55SHEgD0vDtCJukSAKQM5kvBiwAtxRF3iwPKtFwm2TIi6RIJvvGgwe+UhxIO55ByCAqylZ0ED9luvt6ABU1kXUIHLWru2LVoDOrAk6tu6KLKMJSVohaMAtTnA4BzgAf4Asb6U9nmPcP4AAAAASUVORK5CYII=);background-image:url(//bits.wikimedia.org/static-1.25wmf1/extensions/MobileApp/less/../images/edit-locked.png?2014-09-25T16:25:00Z)!ie}#mainpage a.edit_section_button{display:none}.content-rtl a.edit_section_button{float:left;-webkit-transform:scaleX(-1);transform:scaleX(-1)}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
-/* cache key: enwiki:resourceloader:filter:minify-css:7:12f4f4cebd4c950021ff8d5d21e36039 */
\ No newline at end of file
+html,body,div,span,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,ins,em,img,small,strike,strong,sub,sup,tt,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,input,textarea,button,select,table,caption,tbody,tfoot,thead,tr,th,td,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;background:none;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}div#centralNotice{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}button{border:none;background-color:transparent}body{line-height:1;-webkit-tap-highlight-color:transparent}input{line-height:normal}ol,ul{list-style:none}table{border-collapse:collapse}html{-webkit-text-size-adjust:none;font-size:100%}body{font-family:"Helvetica Neue","Helvetica","Nimbus Sans L","Arial","Liberation Sans",sans-serif;line-height:1.4;color:#252525;background:#fff}.content{line-height:1.65;margin:.8em 16px 0;word-wrap:break-word}@media all and (max-width:280px){body{font-size:.8em}.content{margin:0 12px}}.nomobile{display:none !important}.content .thumb{margin:.6em 0}.content .thumb .thumbinner{margin:0 auto;max-width:100%}.content .thumb .thumbinner > div{float:none !important;width:auto !important;clear:both !important}.content .thumb .noresize{width:100%;overflow-x:auto}.content .thumb .noresize img{max-width:none !important}.content .thumbcaption{margin:.5em 0 0;font-size:.8em;line-height:1.5;padding:0 !important;color:#555;width:auto !important}.content .thumbborder{border:1px solid #CCC}.content img{vertical-align:middle}.content .floatright{clear:right;float:right;margin:0 0 .6em .6em}.content .floatleft{clear:left;float:left;margin:0 .6em .6em 0}.content a > img{max-width:100% !important;height:auto !important}.content div.magnify{display:none}ul.gallery{list-style:none;max-width:100%}ul.gallery .gallerybox{display:inline-block;vertical-align:top;max-width:100%}ul.gallery .gallerybox .thumb img{display:block}ul.gallery .gallerybox > div{max-width:100%}ul.gallery .gallerybox > div > .thumb{max-width:100%}ul.gallery .gallerybox .gallerytext{overflow:hidden;padding:2px 4px;word-wrap:break-word;font-size:.8em}#section_0{line-height:1.3}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{line-height:1.3;font-family:"Linux Libertine",Georgia,Times,serif;padding:.5em 0}.pre-content h1,.content h1{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.7em}h2{font-size:1.5em}h3{font-size:1.2em;font-weight:bold}h4{font-weight:bold}blockquote{font-family:"Linux Libertine",Georgia,Times,serif;font-size:1.1em;quotes:"\201C" "\201D";padding:1em 25px 1em 30px;position:relative;overflow:hidden}blockquote:before{content:open-quote;font-size:3em;position:absolute;left:0;top:0}blockquote:after{content:close-quote;font-size:3em;line-height:1;position:absolute;right:0;bottom:0}.content ol ol,.content ol ul,.content ul ol,.content ul ul{margin-left:1em}.content ul{list-style:square inside}.content ol{list-style:decimal inside}dl{margin-left:1em}dl dt{font-weight:bold}.hlist > ul li,ul.hlist li{display:inline-block;margin-right:8px}a{text-decoration:none;color:#002bb8}a:visited{color:#5a3696}a:active{color:#faa700}a:hover{text-decoration:underline}a.new,a.new:visited,a.new:hover{color:#CC0000}a.external{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVElEQVR42n3PgQkAIAhEUXdqJ3dqJ3e6IoTPUSQcgj4EQ5IlUiLE0Jil3PECXhcHGBhZ8kg4hwxAu3MZeCGeyFnAXp4hqNQPnt7QL0nADpD6wHccLvnAKksq8iiaAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.png?2014-10-16T19:01:40Z)!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cdefs%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M-.958-4.259c-1.134%200-2.056.922-2.056%202.056%200%20.394.143.736.336%201.049l-.07.056c-.373-.513-.954-.867-1.636-.867-1.134%200-2.056.922-2.056%202.056s.922%202.056%202.056%202.056c.596%200%201.121-.265%201.496-.671-.075.213-.126.433-.126.671%200%201.134.922%202.056%202.056%202.056s2.056-.922%202.056-2.056c0-.476-.189-.896-.462-1.245.813.158%201.627.477%202.224%201.399-.443-.443-.727-1.248-.727-2.336l-.378-.028.35-.014c0-1.087.27-1.893.713-2.336-.575.889-1.354%201.216-2.14%201.385.243-.337.42-.728.42-1.175%200-1.134-.922-2.056-2.056-2.056z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M0-2.828l-2.828%202.828%202.828%202.828%202.828-2.828-2.828-2.828z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3Cmarker%20orient%3D%22auto%22%20overflow%3D%22visible%22%3E%3Cpath%20d%3D%22M10%200l4-4-14%204%2014%204-4-4z%22%20fill-rule%3D%22evenodd%22%20stroke%3D%22%23000%22%20stroke-width%3D%22NaN%22%2F%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%20d%3D%22M.5%203.518h5.982v5.982h-5.982z%22%2F%3E%3Cpath%20d%3D%22M4.755-.16h5.234v5.39l-1.571%201.544-1.31-1.31-2.725%202.725-2.688-2.688%202.808-2.808-1.31-1.31z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M8.984.845l.022%204.884-1.817-1.817-2.881%202.881-1.227-1.227%202.881-2.881-1.85-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fsvg%3E);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/../MobileFrontend/less/content/images/external-link-ltr-icon.svg?2014-10-16T19:01:40Z)!ie;background-repeat:no-repeat;background-position:center right;padding-right:13px}.content .return-link,.content #mw-mf-last-modified{display:block;font-size:.9em;margin-top:1.5em}.plainlinks a{background:none !important;padding:0 !important}.content p{margin:.5em 0 1em 0}strong,b{font-weight:bold}em,i{font-style:italic}code,pre{padding:1em;font-family:monospace;border:solid 1px #CCC;white-space:pre-wrap}sup{vertical-align:super}sub{vertical-align:sub}sub,sup{font-size:0.75em;line-height:1}.content table{margin:1em 0;overflow:auto;overflow-y:hidden;overflow-x:auto;display:block;width:100% !important}.content table td,.content table th{padding:3px;border:1px #CCC solid}.content table th{font-weight:bold;background-color:#EEE;text-align:center}.content table caption{display:block;text-align:left}.content .tmbox,.content .ambox,.content #coordinates,.content .navbox,.content .vertical-navbox,.content .topicon,.content .metadata{display:none !important}#filetoc,.editsection,.mw-editsection{display:none}.skin-minerva .portal-column-left-wide,.skin-minerva .portal-column-left,.skin-minerva .portal-column-right,.skin-minerva .portal-column-right-narrow{float:none;width:100%}.collapsible td{width:auto !important}.content table{border-spacing:0 !important;float:none !important;margin-left:0 !important;margin-right:0 !important}.content table.infobox{background:#F9F9F9;text-align:center !important}.content table.infobox table td{border:none}.references-column-count{-moz-column-width:35em;-webkit-column-width:35em;column-width:35em}.references li:target{background-color:#ddeeff}.dablink,.rellink{padding:0 0 .6em 0;color:#777;font-size:.8em;font-style:italic}.quotebox{margin:0 0 0.8em !important;width:auto !important}@media all and (max-width:768px){.gallery .gallerybox{width:100% !important}.gallery .gallerybox div{width:100% !important}}a.edit_section_button{height:32px;width:32px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAANlBMVEUAAAD///9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW9sbW+FiFraAAAAEXRSTlMAABAgMEBQYHCAkKCwwNDg8InUWv0AAAGfSURBVHhe7djBjsIgFIXhOwjFeltK3/9lJ4J6SG5dHGgyyaRn1dUXlb8slJ+T9//AC7zACxRiLu37EqXsDPCW9ue2cBLo8/7a/RQwFK9OTwDj3k6Hwbk6Mb/EeRDUojyaHzKMgG4pRmy/ehoAXcklT3h+buoGffU8vDJlQJtfuuG5busEY/Xc28N4EPkp7EHwUaODjSkLIr8Iu/VIELkE2Bj9psDzSBuLQoLIxX1sLEfhQHirQ9rwvLAgcoHdejx4b3IJ8PDOcCBysfklJzToipc9Piu2OKFA5LL5o/xUhAZ9Qi7W40Dkspj8as48OGXkYj0ORH73w/yC8OCMXA5y5sE2lwgPh86Bbi3h+i8506Brc3kYjwb9VkL7lh8N+jaXxXg0GBGayW8WCoSXq+dNzjyIXGx+UXhQm1yCyZkHA8JAfvBosF6h21RvU3vb86B+4lCTcxf4rkTV3PZ9IAiTcxcYvnm94P3Qi9IN6rHXDybL5SAD4IHnZQAMxtu8jIA4E+Q8BKr1xkCcybrOcwhOBsE3JOT+4G+WC7zAC7zAXxMIT+qGYJfyAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/less/../images/edit.png?2014-10-16T19:01:40Z)!ie;background-size:32px 32px;float:right;display:inline-float}.no-editing a.edit_section_button{display:none}.page-protected a.edit_section_button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAXVBMVEUAAAD////Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW/Pz8/Pz8/Pz89sbW/Pz89sbW/Pz8/Pz89sbW/Pz89sbW/Pz89sbW/Pz89sbW+fZUWwAAAAHXRSTlMAABAQICAwMEBAUFBgYHBwgJCgoLDAwNDQ4ODw8PGFG8cAAAHOSURBVHhe7dTLcoMwDAVQxVCXJAoByiPUEf//mcW0Gh5KFrbojrtidUYM9wKnnfOP4AEe4AGCT3JvmuHR3BOAXcDrc/jN87wLeBvmnCUIATnZEUyeC/A7UYHWjeDdQ48PSL68eNOA6GgEH9Nh3m9GsFGASOTB6S7wufrHeLCkGfycwLMKrGgBwm8UoKknD/cCTffn7QSmk+cup51A6ybP+hsGmUCQvd7CTiCST2dAB0pPAcr6VQY0oPRgCqpB005eydvTglxnPlYLWvZ4ezqQ65zxsVrwwvPg7SlBJJ4HH6sDc64ze0qwWnroSAHKeSDRDL6JBGX9eB4FKUH2Sj5WC9p+PQ8lyA1BPnYVZ4NBnOssvS4NvhBp4dl+45nAV+Yv2q3nwakMBICyztnWAwgEzcpDWgchABR1Fp5DCAXTlVdtPAuBINevEB5/pQBQ1rneeAZCQaTVPERdQsGMVn97UZdgMJ89UeccIsDaA7V55SHEgD0vDtCJukSAKQM5kvBiwAtxRF3iwPKtFwm2TIi6RIJvvGgwe+UhxIO55ByCAqylZ0ED9luvt6ABU1kXUIHLWru2LVoDOrAk6tu6KLKMJSVohaMAtTnA4BzgAf4Asb6U9nmPcP4AAAAASUVORK5CYII=);background-image:url(//bits.wikimedia.org/static-1.25wmf4/extensions/MobileApp/less/../images/edit-locked.png?2014-10-16T19:01:40Z)!ie}#mainpage a.edit_section_button{display:none}.content-rtl a.edit_section_button{float:left;-webkit-transform:scaleX(-1);transform:scaleX(-1)}.hide-when-compact{display:none}.mobile-float-reset{float:none !important;width:100% !important}#content .vertical-navbox,#content .navbox{display:none}@media all and (min-width:768px){#content .vertical-navbox,#content .navbox{display:inherit}}@media screen,handheld{.citation *.printonly{display:none}}.citation{word-wrap:break-word}.navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps}.infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{float:left;text-align:left;margin-right:0.5em;width:6em}.hlist dl,.hlist ol,.hlist ul{margin:0;padding:0}.hlist dd,.hlist dt,.hlist li{margin:0;display:inline}.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline}#content .hlist dt:after{content:":"}#content .hlist dd:after,#content .hlist li:after{content:"  ";font-weight:bold}#content .hlist dd:last-child:after,#content .hlist dt:last-child:after,#content .hlist li:last-child:after{content:none}#content .hlist dd dd:first-child:before,#content .hlist dd dt:first-child:before,#content .hlist dd li:first-child:before,#content .hlist dt dd:first-child:before,#content .hlist dt dt:first-child:before,#content .hlist dt li:first-child:before,#content .hlist li dd:first-child:before,#content .hlist li dt:first-child:before,#content .hlist li li:first-child:before{content:" (";font-weight:normal}#content .hlist dd dd:last-child:after,#content .hlist dd dt:last-child:after,#content .hlist dd li:last-child:after,#content .hlist dt dd:last-child:after,#content .hlist dt dt:last-child:after,#content .hlist dt li:last-child:after,#content .hlist li dd:last-child:after,#content .hlist li dt:last-child:after,#content .hlist li li:last-child:after{content:") ";font-weight:normal}#content .hlist ol{counter-reset:list-item}#content .hlist ol > li{counter-increment:list-item}#content .hlist ol > li:before{content:" " counter(list-item) " "}#content .hlist dd ol > li:first-child:before,#content .hlist dt ol > li:first-child:before,#content .hlist li ol > li:first-child:before{content:" (" counter(list-item) " "}.plainlist ul{list-style:none}.compact-ambox table .mbox-image,.compact-ambox table .mbox-imageright,.compact-ambox table .mbox-empty-cell{display:none}.compact-ambox table.ambox{border:none;border-collapse:collapse;background:transparent;margin:0 0 0 1.6em !important;padding:0 !important;width:auto;display:block}.compact-ambox table.mbox-small-left{font-size:100%;width:auto;margin:0}.compact-ambox table .mbox-text{padding:0 !important;margin:0 !important}.compact-ambox table .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:square;list-style-image:url(data:image/gif;base64,R0lGODlhBQANAIAAAGOMnP///yH5BAEAAAEALAAAAAAFAA0AAAIJjI+pu+APo4SpADs=)}.compact-ambox .hide-when-compact{display:none}.rellink,.dablink,.hatnote{font-style:italic}.rellink i,.dablink i,.hatnote i{font-style:normal}div.rellink,div.dablink,div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.geo-default,.geo-dms,.geo-dec{display:inline}.geo-nondefault,.geo-multi-punct{display:none}.longitude,.latitude{white-space:nowrap}.nowrap,.nowraplinks a,.nowraplinks .selflink,sup.reference a{white-space:nowrap}.wrap,.wraplinks a{white-space:normal}.sysop-show,.accountcreator-show,.autoconfirmed-show{display:none}#li-coordinates{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/80px-Edge-firefox.png);float:right;display:none;-webkit-background-size:auto 30px;background-size:auto 30px}.client-js .content_block.coordinates{display:none;text-align:right;margin-bottom:0.5em;font-size:smaller}.client-js .content_block.coordinates .latitude{display:none;padding-left:20px;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/5/57/Edge-firefox.png/50px-Edge-firefox.png);background-repeat:no-repeat;-webkit-background-size:auto 15px;background-size:auto 15px}.alpha #li-coordinates{display:list-item}.client-js .beta .content_block.coordinates{display:block}.client-js .beta .content_block.coordinates .latitude{display:inline}.topicon{display:none}td .sortkey,th .sortkey{display:none;speak:none}.transborder{border:solid transparent}.references-column-count{-moz-column-count:1 !important;-webkit-column-count:1 !important;column-count:1 !important}
+/* cache key: enwiki:resourceloader:filter:minify-css:7:80d903e26a7dc2ed9a3828f15a7550cb */
\ No newline at end of file
diff --git a/wikipedia/mw-crumbtest/MWCrumbyTest.h b/wikipedia/mw-crumbtest/MWCrumbyTest.h
deleted file mode 100644
index 3f49a7605ad..00000000000
--- a/wikipedia/mw-crumbtest/MWCrumbyTest.h
+++ /dev/null
@@ -1,63 +0,0 @@
-//  Created by Monte Hurd on 11/10/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-/*
-This object makes it easier to automate higher-level testing of more complex async 
-code (dependent NSOperations presently). Think unit testing but for things which 
-are not so easily reduced to nice little units. Unity testing? This approach 
-employs a "bread crumb" metaphor to define an execution "trail" which is then 
-verified.
-*/
-
-#define CRUMBY_STATUS_DISPLAY_NAMES @{\
-        @(CRUMBY_STATUS_READY_TO_HIKE) : @"READY TO HIKE",\
-        @(CRUMBY_STATUS_ON_TRAIL) : @"ON TRAIL",\
-        @(CRUMBY_STATUS_OFF_TRAIL) : @"OFF TRAIL",\
-        @(CRUMBY_STATUS_ARRIVED_SAFELY) : @"ARRIVED SAFELY"\
-}
-
-typedef enum {
-    CRUMBY_STATUS_READY_TO_HIKE = 0,
-    CRUMBY_STATUS_ON_TRAIL = 1,
-    CRUMBY_STATUS_OFF_TRAIL = 2,
-    CRUMBY_STATUS_ARRIVED_SAFELY = 3
-} MWCrumbTestStatus;
-
-@interface MWCrumbyTest : NSObject
-
-@property (assign, readonly) MWCrumbTestStatus status;
-@property (copy, readonly) NSString *trailSoFar;
-@property (copy, readonly) NSString *expectedTrail;
-@property (assign, readonly) SEL kickoffSelector;
-@property (copy, readonly) NSString *description;
-
-/*
-Needed a simple way to confirm that async operation(s) for a given task had executed in a 
-pre-determined order. Tell this object's init what testing method to execute to set the 
-test in motion. Then within the callbacks of the various async things that kicked off,
-drop "crumbs". Init is also told what trail (of crumbs) it should expect and the order of
-this expected trail is then verified by this button object as these crumbs are dropped as 
-the execution progresses.
-*/
--(id)initWithTrailhead:(SEL)kickOffSelector target:(id)target trailExpected:(NSString *)trailExpected description:(NSString *)description;
-
-// Drop crumbs at various points to create a trail which will be hiked. Ensure the order
-// and location of drops conforms to the trailExpected passed to init.
-
-// Upper case crumbs must be encountered in order for status to go CRUMBY_STATUS_ARRIVED_SAFELY.
-// Lower case crumbs must be encountered, but the order in which they are encountered doesn't matter.
-// (lower case crumbs handy, say, for ensuring dealloc was called, even if we don't care or can't
-// control exactly when this happens)
--(void)dropCrumb:(NSString *)crumb;
-
-// Begin executing the kickoff selector passed to init. As the execution encounters
-// "dropCrumb" statements this object will verify they are encountered in the order
-// specified in the init's "trailExpected" argument. This object's status and
-// expectedTrail properties may be observed to monitor trail progression.
--(void)hike;
-
--(void)reset;
-
--(NSString *)displayNameForStatus:(MWCrumbTestStatus)status;
-
-@end
diff --git a/wikipedia/mw-crumbtest/MWCrumbyTest.m b/wikipedia/mw-crumbtest/MWCrumbyTest.m
deleted file mode 100644
index 05a6bd676a1..00000000000
--- a/wikipedia/mw-crumbtest/MWCrumbyTest.m
+++ /dev/null
@@ -1,168 +0,0 @@
-//  Created by Monte Hurd on 11/10/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWCrumbyTest.h"
-
-@interface MWCrumbyTest()
-{
-    id kickoffTarget_;
-}
-
-@property (copy, readwrite) NSString *statusDescription;
-@property (assign, readwrite) MWCrumbTestStatus status;
-@property (copy, readwrite) NSString *expectedTrail;
-@property (copy, readwrite) NSString *trailSoFar;
-@property (copy, readwrite) NSString *description;
-@property (assign, readwrite) SEL kickoffSelector;
-
-@end
-
-@implementation MWCrumbyTest
-
-#pragma mark - Init
-
-// Be sure to call init on the main thread
--(id)initWithTrailhead:(SEL)kickOffSelector target:(id)target trailExpected:(NSString *)trailExpected description:(NSString *)description
-{
-    self = [super init];
-    if (self) {
-        _trailSoFar = @"";
-        kickoffTarget_ = target;
-        self.kickoffSelector = kickOffSelector;
-        self.expectedTrail = trailExpected;
-        self.description = description;
-        self.status = CRUMBY_STATUS_READY_TO_HIKE;
-
-        // Ensure any changes to trailSoFar cause status to be updated accordingly
-        NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;
-        [self addObserver:self forKeyPath:@"trailSoFar" options:options context:nil];
-    }
-    return self;
-}
-
-#pragma mark - KVO
-
-- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
-{
-    [self updateStatus];
-}
-
-#pragma mark - Test kickoff
-
--(void)hike
-{
-    [self resetAndKickOffSelector];
-}
-
-#pragma mark - Reset
-
--(void)reset
-{
-    self.trailSoFar = @"";
-}
-
--(void)resetAndKickOffSelector
-{
-    //[[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-        [self reset];
-    //    [kickoffTarget_ performSelector:self.kickoffSelector withObject:self afterDelay:0];
-    //}];
-
-    [kickoffTarget_ performSelectorOnMainThread:self.kickoffSelector withObject:self waitUntilDone:NO];
-}
-
-#pragma mark - Status update
-
--(NSString *)displayNameForStatus:(MWCrumbTestStatus)status
-{
-    return CRUMBY_STATUS_DISPLAY_NAMES[@(status)];
-}
-
--(void)updateStatus
-{
-    NSString *(^sortStringCharacters)(NSString *) = ^NSString*(NSString *str){
-        if (str == nil || str.length == 0) return @"";
-        NSMutableArray *characters = [[NSMutableArray alloc] initWithCapacity:[str length]];
-        for (uint i = 0; i < [str length]; i++) {
-            NSString *ichar  = [NSString stringWithFormat:@"%c", [str characterAtIndex:i]];
-            [characters addObject:ichar];
-        }
-        [characters sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
-        return [characters componentsJoinedByString:@""];
-    };
-
-    MWCrumbTestStatus status = CRUMBY_STATUS_READY_TO_HIKE;
-
-    status = [self areTrailSoFarCrumbsInExpectedOrder] ? CRUMBY_STATUS_ON_TRAIL : CRUMBY_STATUS_OFF_TRAIL;
-
-    if (status == CRUMBY_STATUS_ON_TRAIL) {
-        NSString *lowercaseExpectedTrailCrumbs = [self lowercaseLettersFromString:self.expectedTrail];
-        NSString *lowercaseTrailSoFarCrumbs = [self lowercaseLettersFromString:self.trailSoFar];
-        NSString *uppercaseExpectedTrailCrumbs = [self uppercaseLettersFromString:self.expectedTrail];
-        NSString *uppercaseTrailSoFarCrumbs = [self uppercaseLettersFromString:self.trailSoFar];
-        if (
-            [sortStringCharacters(lowercaseExpectedTrailCrumbs) isEqualToString:sortStringCharacters(lowercaseTrailSoFarCrumbs)]
-                &&
-            [uppercaseExpectedTrailCrumbs isEqualToString:uppercaseTrailSoFarCrumbs]
-        ) {
-            status = CRUMBY_STATUS_ARRIVED_SAFELY;
-        }
-    }else if (self.trailSoFar.length == 0) {
-        status = CRUMBY_STATUS_READY_TO_HIKE;
-    }
-
-    [self setStatus:status];
-}
-
--(NSString *)uppercaseLettersFromString:(NSString *)string
-{
-    NSString *output = @"";
-    for (uint i = 0; i < [string length]; i++) {
-        unichar thisChar = [string characterAtIndex:i];
-        if ([[NSCharacterSet uppercaseLetterCharacterSet] characterIsMember:thisChar]) {
-            //output = [output stringByAppendingString:[NSString stringWithFormat:@"%c", thisChar]];
-            output = [output stringByAppendingString:[[NSString alloc] initWithCharacters:&thisChar length:1]];
-        }
-    }
-    return output;
-}
-
--(NSString *)lowercaseLettersFromString:(NSString *)string
-{
-    NSString *output = @"";
-    for (uint i = 0; i < [string length]; i++) {
-        unichar thisChar = [string characterAtIndex:i];
-        if ([[NSCharacterSet lowercaseLetterCharacterSet] characterIsMember:thisChar]) {
-            //output = [output stringByAppendingString:[NSString stringWithFormat:@"%c", thisChar]];
-            output = [output stringByAppendingString:[[NSString alloc] initWithCharacters:&thisChar length:1]];
-        }
-    }
-    return output;
-}
-
--(BOOL)areTrailSoFarCrumbsInExpectedOrder
-{
-    NSString *uppercaseExpectedTrailCrumbs = [self uppercaseLettersFromString:self.expectedTrail];
-    NSString *uppercaseTrailSoFarCrumbs = [self uppercaseLettersFromString:self.trailSoFar];
-
-    NSRange range = [uppercaseExpectedTrailCrumbs rangeOfString:uppercaseTrailSoFarCrumbs options:NSCaseInsensitiveSearch];
-    if (range.location != NSNotFound){
-        if (range.location == 0) {
-            return YES;
-        }
-    }
-    return NO;
-}
-
-#pragma mark - Drop crumb
-
--(void)dropCrumb:(NSString *)crumb
-{
-    NSAssert(crumb.length == 1, @"Crumbs must be single character!");
-    [[NSOperationQueue mainQueue] addOperationWithBlock: ^ {
-        //NSLog(@"DROPPED CRUMB %@", crumb);
-        self.trailSoFar = (!self.trailSoFar) ? crumb : [self.trailSoFar stringByAppendingString:crumb];
-    }];
-}
-
-@end
diff --git a/wikipedia/mw-network/MWNetworkOp.h b/wikipedia/mw-network/MWNetworkOp.h
deleted file mode 100644
index 0e9f26a9441..00000000000
--- a/wikipedia/mw-network/MWNetworkOp.h
+++ /dev/null
@@ -1,63 +0,0 @@
-//  Created by Monte Hurd on 10/26/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-@class MWNetworkOp;
-
-@protocol NetworkOpDelegate <NSObject>
-    @optional
-        -(void)opStarted:(MWNetworkOp *)op;
-        -(void)opFinished:(MWNetworkOp *)op;
-        -(void)opProgressed:(MWNetworkOp *)op;
-@end
-
-@interface MWNetworkOp : NSOperation <NSURLConnectionDataDelegate>
-
-/*
-"aboutToStart" provides a nice bookend to the built-in NSOperation "completionBlock".
-It allows dependent operations to incorporate some data produced by the operations on
-which they depend (whose operation will be complete by the time aboutToStart is
-invoked because of the dependency) *before* they start. Nice as it allows chained ops
-to basically relay info to ops further down the dependency chain without requiring a
-delegate or controller to marshal inter-op communications (although nothing about
-"aboutToStart" prevents such an arrangement from being used).
-*/
-@property (copy, nonatomic) void(^aboutToStart)(void);
-
-// For testing only. Try not to put things in this block which would cause this op to
-// be retained.
-@property (copy, nonatomic) void(^aboutToDealloc)(void);
-
-// Do not use strong for delegate or the operation will not be released properly.
-@property (weak) id <NetworkOpDelegate> delegate;
-
-@property (copy) NSURLRequest *request;
-@property (strong, nonatomic) NSURLResponse *response;
-
-@property (copy, readonly) NSMutableData *dataRetrieved;
-@property (nonatomic) NSUInteger dataRetrievedExpectedLength;
-
-@property (copy, readonly) NSDictionary *jsonRetrieved;
-
-@property (copy, readonly) NSNumber *bytesWritten;
-@property (copy, readonly) NSNumber *bytesExpectedToWrite;
-
-// Made the error readwrite so from within completionBlock it can be set conditionally
-// to signify the operation didn't retrieve what was desired (checking retrieved json
-// for example to see if login was a success for example). Child ops will then see
-// their parent finished with an error so they won't even start. Because "copy" is used
-// there should be no issue with unwanted retaining preventing the op from being
-// dealloc'ed when it is finished.
-@property (copy, readwrite) NSError *error;
-
-@property (nonatomic) NSTimeInterval initializationTime;
-@property (nonatomic) NSTimeInterval startedTime;
-@property (nonatomic) NSTimeInterval finishedTime;
-
-@property (nonatomic) NSUInteger tag;
-
-// Dependency determines order of execution, but sometimes we want a child op to
-// still execute even if its "parent" operation failed.
-@property (nonatomic) BOOL cancelIfDependentOpsFailed;
-
-@end
-
diff --git a/wikipedia/mw-network/MWNetworkOp.m b/wikipedia/mw-network/MWNetworkOp.m
deleted file mode 100644
index df5de95d4aa..00000000000
--- a/wikipedia/mw-network/MWNetworkOp.m
+++ /dev/null
@@ -1,300 +0,0 @@
-//  Created by Monte Hurd on 10/26/13.
-//  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
-
-#import "MWNetworkOp.h"
-#import "WikipediaAppUtils.h"
-
-@interface MWNetworkOp()
-
-#pragma mark - Private properties
-
-@property (strong, nonatomic) NSURLConnection *connection;
-@property (copy, readwrite) NSNumber *bytesWritten;
-@property (copy, readwrite) NSNumber *bytesExpectedToWrite;
-
-@end
-
-@implementation MWNetworkOp
-{
-    // In concurrent operations, we have to manage the operation's state
-    BOOL executing_;
-    BOOL finished_;
-}
-
-#pragma mark - Init / dealloc
-
-- (void)setDataRetrieved:(NSMutableData *)thisData {
-    _dataRetrieved = thisData;
-}
-
--(NSDictionary *)jsonRetrieved
-{
-    NSError *jsonError = nil;
-    NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:self.dataRetrieved options:0 error:&jsonError];
-    return jsonError ? @{} : jsonDict;
-}
-
--(id)init
-{
-    self = [super init];
-
-    //NSLog(@"NETWORK OP INIT'ED: TAG = %d, POINTER = %p", self.tag, self);
-
-    if (self) {
-        self.cancelIfDependentOpsFailed = YES;
-        self.error = nil;
-        self.connection = nil;
-        self.response = nil;
-        self.dataRetrieved = [[NSMutableData alloc] init];
-        self.request = nil;
-        self.finishedTime = 0;
-        self.startedTime = 0;
-        self.initializationTime = [NSDate timeIntervalSinceReferenceDate];
-        _bytesWritten = nil;
-        _bytesExpectedToWrite = nil;
-        finished_ = NO;
-        executing_ = NO;
-        self.aboutToStart = nil;
-        self.aboutToDealloc = nil;
-        self.tag = NSUIntegerMax;
-        self.dataRetrievedExpectedLength = 0;
-    }
-    return self;
-}
-
--(void)dealloc
-{
-    if (self.aboutToDealloc != nil) self.aboutToDealloc();
-
-    // Easy check to see if this operation is cleaned up when its work is done
-    //NSLog(@"NETWORK OP DEALLOC'ED: TAG = %d, POINTER = %p", self.tag, self);
-}
-
-#pragma mark - Overrides required for concurrency
-
-/*
-    If you are creating a concurrent operation, you need to override the following methods at a minimum:
-        start
-        isConcurrent
-        isExecuting
-        isFinished
-*/
-
--(void)start
-{
-
-    if (self.cancelIfDependentOpsFailed) {
-        // Don't start if *any* parent op failed or had an error.
-        // "Dependent" for MWNetworkOp means dependent on its success!
-        // This is so failures cascade automatically.
-        for (id obj in self.dependencies) {
-            if ([obj isKindOfClass:[MWNetworkOp class]]){
-                MWNetworkOp *op = (MWNetworkOp *)obj;
-                if (op.error || [op isCancelled]) {
-                    [self finishWithError:@"Start method aborted early because parent MWNetworkOp had been cancelled or had an error."];
-                    return;
-                }
-            }
-        }
-    }
-
-    if(finished_ || [self isCancelled]) {
-		[self finishWithError:@"Start method aborted early because op was marked finished or cancelled."];
-		return;
-	}
-
-    if (self.aboutToStart != nil) self.aboutToStart();
-    
-    if (self.request == nil) {
-		[self finishWithError:@"Start method aborted early because request was nil."];
-        return;
-    }
-
-    self.startedTime = [NSDate timeIntervalSinceReferenceDate];
-    
-    if ([(NSObject *)self.delegate respondsToSelector:@selector(opStarted:)]){
-        [(NSObject *)self.delegate performSelectorOnMainThread:@selector(opStarted:) withObject:self waitUntilDone:NO];
-    }
-    // The autoreleasepool is needed to keep the thread from exiting before NSURLConnection finishes
-    // See: http://stackoverflow.com/q/1728631/135557 for more info
-    
-    // From this point on, the operation is officially executing--remember, isExecuting
-    // needs to be KVO compliant!
-    [self willChangeValueForKey:@"isExecuting"];
-    executing_ = YES;
-    [self didChangeValueForKey:@"isExecuting"];
-    
-    // Create the NSURLConnection. Could have done so in init, but delayed until now in case the
-    // operation was never enqueued or was cancelled before starting
-    
-    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self];
-    //NSLog(@"self.request.HTTPBody = %@", [NSString stringWithCString:[self.request.HTTPBody bytes] encoding:NSUTF8StringEncoding]);
-
-    // Keep the thread from exiting before the NSURLConnection finishes.
-    NSDate *distantFutureDate = [NSDate distantFuture];
-    while(!self.isFinished){[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:distantFutureDate];}
-}
-
--(BOOL)isExecuting
-{
-	return executing_;
-}
-
--(BOOL)isFinished
-{
-	return finished_;
-}
-
--(BOOL)isConcurrent
-{
-	return YES;
-}
-
-#pragma mark - Other overrides
-
--(void)cancel
-{
-    // Make it safe to call cancel more than once.
-    if (self.isCancelled) return;
-    
-    // Ensures isCancelled is YES before finishWithError is called (in case any callbacks invoked in finishWithError
-    // call cancel - the isCancelled check above would then prevent recursion)
-    [super cancel];
-    
-    [self finishWithError:@"Cancel method was called."];
-}
-
-#pragma mark - NSURLConnectionDataDelegate methods
-
--(void)connection:(NSURLConnection*) connection didReceiveResponse:(NSURLResponse *)response
-{
-    self.dataRetrievedExpectedLength = (NSUInteger)[response expectedContentLength];
-
-    self.response = response;
-}
-
--(void)setResponse:(NSURLResponse *)response
-{
-    _response = response;
-    
-    [self failIfBadHTTPStatusCode];
-}
-
--(void)failIfBadHTTPStatusCode
-{
-    if (!self.response) return;
-    
-    // If the response is a server or client error finish with an error.
-    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)self.response;
-    NSInteger code = httpResponse.statusCode;
-    if ((code >= 400) && (code <= 499)) {
-        [self finishWithError:[NSString stringWithFormat:@"Client error. HTTP Status Code %ld", (long)code]];
-    }else if ((code >= 500) && (code <= 599)) {
-        [self finishWithError:[NSString stringWithFormat:@"Server error. HTTP Status Code %ld", (long)code]];
-    }
-    //NSLog(@"responseStatusCode = %ld", (long)code);
-    //NSLog(@"allHeaderFields = %@", httpResponse.allHeaderFields);
-}
-
--(void)connectionDidFinishLoading:(NSURLConnection *)connection
-{
-    if([self isCancelled]) {
-        [self finishWithError:@"connectionDidFinishLoading: method saw the op was cancelled."];
-    }else{
-        [self finish];
-    }
-}
-
--(void)connection:(NSURLConnection*) connection didReceiveData:(NSData *)data
-{
-    if([self isCancelled]) {
-        [self finishWithError:@"connection:didReceiveData: method saw the op was cancelled."];
-    }else{
-        [self.dataRetrieved appendData: data];
-        // Enable inspection of the progress of the data being received
-        [self reportProgress];
-    }
-}
-
--(void)connection:(NSURLConnection *)connection didSendBodyData:(NSInteger)bytesWritten totalBytesWritten:(NSInteger)totalBytesWritten totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite
-{
-    self.bytesWritten = [NSNumber numberWithInteger:totalBytesWritten];
-    self.bytesExpectedToWrite = [NSNumber numberWithInteger:totalBytesExpectedToWrite];
-    // Enable inspection of the progress of the data being sent
-    [self reportProgress];
-}
-
-#pragma mark - Progress
-
--(void)reportProgress
-{
-    if ([(NSObject *)self.delegate respondsToSelector:@selector(opProgressed:)]){
-        [(NSObject *)self.delegate performSelectorOnMainThread:@selector(opProgressed:) withObject:self waitUntilDone:NO];
-    }
-}
-
-#pragma mark - NSURLConnectionDelegate methods
-
--(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
-{
-    self.error = error;
-    [self finish];
-}
-
-#pragma mark - Finishers
-
--(void)finish
-{
-    //NSLog(@"NETWORK OP FINISHED: TAG = %d, POINTER = %p, ERROR = %@", self.tag, self, self.error);
-
-    self.finishedTime = [NSDate timeIntervalSinceReferenceDate];
-
-    if(self.connection) {
-        [self.connection cancel];
-        // Don't nil self.connection here - it needs to call its delegates to wrap things up
-    }
-
-    if ([(NSObject *)self.delegate respondsToSelector:@selector(opFinished:)]){
-        [(NSObject *)self.delegate performSelectorOnMainThread:@selector(opFinished:) withObject:self waitUntilDone:NO];
-    }
-
-    // Ensure completionBlock reliably fires before child op's aboutToStart.
-    // Normally an NSOperation setting its "finished" property to YES triggers its "completionBlock" to fire, but
-    // the problem with this behavior is the same action triggers any dependent operations to start, and this is
-    // a problem because the ops that start are started in async fashion just as the completionBlock is, and
-    // sometimes the dependent op starts before completionBlock does! This is bad as it means completionBlock can't
-    // be reliably used to influence dependent ops (in their "aboutToStart" block for example.) To get around this
-    // manually fire completionBlock() before this op signals via KVO that it's finished, then nil out the completion
-    // block so when the op tries to fire it in the normal fashion *after* it's marked finished nothing will happen.
-    
-    // Checking self.isExecuting ensures completionBlocks are not called for ops that never started. Can't complete
-    // something if you never started it!
-    BOOL actuallyStarted = self.isExecuting;
-    if(self.completionBlock && actuallyStarted) self.completionBlock();
-    self.completionBlock = nil;
-
-	// Alert anyone that we are finished
-	[self willChangeValueForKey:@"isExecuting"];
-	executing_ = NO;
-	[self didChangeValueForKey:@"isExecuting"];
-
-    if (actuallyStarted) { // <-- This prevents iOS 6 "went isFinished=YES without being started by the queue it is in" bug
-        [self willChangeValueForKey:@"isFinished"];
-        finished_  = YES;
-        [self didChangeValueForKey:@"isFinished"];
-    }
-
-}
-
--(void)finishWithError:(NSString *)description
-{
-	// Code for being cancelled    
-    self.error = [[NSError alloc] initWithDomain : @"MWNetworkOp.m"
-                                            code : 555
-                                        userInfo : @{
-                                                   NSLocalizedDescriptionKey: MWLocalizedString([@"MWNetworkOp Error: " stringByAppendingString:description], nil)
-                                                   }];
-	[self finish];
-}
-
-@end
