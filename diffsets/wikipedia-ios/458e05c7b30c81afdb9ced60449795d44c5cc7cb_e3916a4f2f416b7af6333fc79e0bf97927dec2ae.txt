diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index a6ad23f6e4d..3fe49d532b1 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -256,6 +256,7 @@
 		0EE7687B1AF982C100A5D046 /* WMFArticleProtocol.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EE7687A1AF982C100A5D046 /* WMFArticleProtocol.m */; };
 		0EE768811AFD25CC00A5D046 /* WMFSearchFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EE768801AFD25CC00A5D046 /* WMFSearchFunnel.m */; };
 		0EEAF0F51B8229D9000D4232 /* WMFHomeSectionHeader.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EEAF0F41B8229D9000D4232 /* WMFHomeSectionHeader.m */; };
+		0EF17AF11BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EF17AF01BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.m */; settings = {ASSET_TAGS = (); }; };
 		0EF451F31B5458F700D621BD /* UITabBarController+WMFExtensions.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EF451F21B5458F700D621BD /* UITabBarController+WMFExtensions.m */; };
 		0EF451F61B545ED100D621BD /* WMFRecentPagesDataSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EF451F51B545ED100D621BD /* WMFRecentPagesDataSource.m */; };
 		0EFAF77D1BC2DE0200A76D34 /* WMFTableOfContentsHeader.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0EFAF77C1BC2DE0200A76D34 /* WMFTableOfContentsHeader.swift */; settings = {ASSET_TAGS = (); }; };
@@ -980,6 +981,8 @@
 		0EE768801AFD25CC00A5D046 /* WMFSearchFunnel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFSearchFunnel.m; sourceTree = "<group>"; };
 		0EEAF0F31B8229D9000D4232 /* WMFHomeSectionHeader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFHomeSectionHeader.h; sourceTree = "<group>"; };
 		0EEAF0F41B8229D9000D4232 /* WMFHomeSectionHeader.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFHomeSectionHeader.m; sourceTree = "<group>"; };
+		0EF17AEF1BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFEditingCollectionViewLayout.h; sourceTree = "<group>"; };
+		0EF17AF01BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFEditingCollectionViewLayout.m; sourceTree = "<group>"; };
 		0EF451F11B5458F700D621BD /* UITabBarController+WMFExtensions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UITabBarController+WMFExtensions.h"; sourceTree = "<group>"; };
 		0EF451F21B5458F700D621BD /* UITabBarController+WMFExtensions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UITabBarController+WMFExtensions.m"; sourceTree = "<group>"; };
 		0EF451F41B545ED100D621BD /* WMFRecentPagesDataSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFRecentPagesDataSource.h; sourceTree = "<group>"; };
@@ -2384,8 +2387,8 @@
 			isa = PBXGroup;
 			children = (
 				0E94AFEE1B209792000BC5EA /* WMFArticleListCollectionViewController.h */,
-				BCF7FC9D1B7BA61B00CDFB8C /* WMFArticleListCollectionViewController_Transitioning.h */,
 				0E94AFEF1B209792000BC5EA /* WMFArticleListCollectionViewController.m */,
+				BCF7FC9D1B7BA61B00CDFB8C /* WMFArticleListCollectionViewController_Transitioning.h */,
 				0E366B371B2F2ACF00ABFB86 /* Layouts */,
 				0E7955BF1B2B389800B055A2 /* TGLStackedViewController */,
 			);
@@ -2457,6 +2460,8 @@
 		0E366B371B2F2ACF00ABFB86 /* Layouts */ = {
 			isa = PBXGroup;
 			children = (
+				0EF17AEF1BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.h */,
+				0EF17AF01BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.m */,
 				0E366B341B2F176700ABFB86 /* WMFOffScreenFlowLayout.h */,
 				0E366B351B2F176700ABFB86 /* WMFOffScreenFlowLayout.m */,
 				0E2B07001B2D1DE200EA2F53 /* WMFBottomStackLayout.h */,
@@ -4144,6 +4149,7 @@
 				BC22F44B1BA33C3F00B64F4B /* WMFSearchResultDistanceProvider.m in Sources */,
 				BC505EF71B59643400537006 /* WMFPageCollectionViewController.m in Sources */,
 				BCE24FDF1B0CF0C7003F054B /* LegacyPhoneGapDataMigrator.m in Sources */,
+				0EF17AF11BCC50ED00ACF54A /* WMFEditingCollectionViewLayout.m in Sources */,
 				042950D41A9D3BA7009BE784 /* UIColor+WMFHexColor.m in Sources */,
 				BCF7FC9B1B7B9ADE00CDFB8C /* WMFLogFormatter.m in Sources */,
 				BCBDC88C1B3A0715003A6D17 /* Cancellable.swift in Sources */,
diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
index 81243323db3..7b06740f1f8 100644
--- a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
@@ -326,16 +326,6 @@ - (void)prepareForTransitionToLayout:(UICollectionViewLayout*)newLayout {
     self.deletePanGesture      = nil;
 }
 
-#pragma mark - Update Attributes
-
-- (void)updateAttibutesWithPanTranslation:(UICollectionViewLayoutAttributes*)item {
-    CGPoint translation = [self.deletePanGesture translationInView:self.collectionView];
-
-    CGRect frame = item.frame;
-    frame.origin.x = translation.x;
-    item.frame     = frame;
-}
-
 #pragma mark - Drag Action
 
 - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
index b084f423c7c..46bed7cc6c5 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
@@ -16,7 +16,7 @@
 #import "WMFArticleViewController.h"
 
 #import <SSDataSources/SSDataSources.h>
-#import <SelfSizingWaterfallCollectionViewLayout/SelfSizingWaterfallCollectionViewLayout.h>
+#import "WMFEditingCollectionViewLayout.h"
 #import <Masonry/Masonry.h>
 
 #import "WMFArticlePreviewCell.h"
@@ -28,10 +28,9 @@
 #import "UIColor+WMFHexColor.h"
 
 @interface WMFArticleListCollectionViewController ()
-<UICollectionViewDelegate, WMFSearchPresentationDelegate>
+<UICollectionViewDelegate, WMFSearchPresentationDelegate, WMFEditingCollectionViewLayoutDelegate>
 
 @property (nonatomic, strong) IBOutlet UICollectionView* collectionView;
-@property (nonatomic, strong) IBOutlet UICollectionViewLayout* collectionViewLayout;
 
 + (Class)collectionViewClass;
 
@@ -62,16 +61,12 @@ - (void)commonInit {
 
 #pragma mark - Accessors
 
-+ (SelfSizingWaterfallCollectionViewLayout*)createLayout {
-    return [SelfSizingWaterfallCollectionViewLayout new];
-}
-
 + (Class)collectionViewClass {
     return [UICollectionView class];
 }
 
 + (UICollectionView*)createCollectionView {
-    return [[[self collectionViewClass] alloc] initWithFrame:CGRectZero collectionViewLayout:[self createLayout]];
+    return [[[self collectionViewClass] alloc] initWithFrame:CGRectZero collectionViewLayout:[SelfSizingWaterfallCollectionViewLayout new]];
 }
 
 - (id<WMFArticleListDynamicDataSource>)dynamicDataSource {
@@ -120,8 +115,20 @@ - (void)setSavedPages:(MWKSavedPageList* __nonnull)savedPages {
     [_dataSource setSavedPageList:savedPages];
 }
 
+- (WMFEditingCollectionViewLayout*)editingLayout {
+    id layout = self.collectionView.collectionViewLayout;
+    if([layout isKindOfClass:[WMFEditingCollectionViewLayout class]]){
+        return layout;
+    }
+    return nil;
+}
+
 - (SelfSizingWaterfallCollectionViewLayout*)flowLayout {
-    return (id)self.collectionView.collectionViewLayout;
+    id layout = self.collectionView.collectionViewLayout;
+    if([layout isKindOfClass:[SelfSizingWaterfallCollectionViewLayout class]]){
+        return layout;
+    }
+    return nil;
 }
 
 - (NSString*)debugDescription {
@@ -164,6 +171,13 @@ - (void)scrollToArticleIfOffscreen:(MWKArticle*)article animated:(BOOL)animated
     [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:animated];
 }
 
+- (void)setupEditingLayout{
+    WMFEditingCollectionViewLayout* layout = [[WMFEditingCollectionViewLayout alloc] init];
+    layout.editingDelegate = self;
+    self.collectionView.collectionViewLayout = layout;
+}
+
+
 #pragma mark - UIViewController
 
 - (void)loadView {
@@ -183,7 +197,8 @@ - (void)loadView {
 
 - (void)viewDidLoad {
     [super viewDidLoad];
-
+    
+    [self setupEditingLayout];
     [self connectCollectionViewAndDataSource];
 
     self.extendedLayoutIncludesOpaqueBars     = YES;
@@ -240,6 +255,21 @@ - (void)collectionView:(UICollectionView*)collectionView didSelectItemAtIndexPat
              discoveryMethod:[self.dataSource discoveryMethod]];
 }
 
+- (BOOL)editingLayout:(WMFEditingCollectionViewLayout*)layout canMoveItemAtIndexPath:(NSIndexPath*)indexPath{
+    return NO;
+}
+
+- (BOOL)editingLayout:(WMFEditingCollectionViewLayout*)layout canDeleteItemAtIndexPath:(NSIndexPath*)indexPath{
+    return [self.dataSource canDeleteItemAtIndexpath:indexPath];
+}
+
+- (void)editingLayout:(WMFEditingCollectionViewLayout*)layout deleteItemAtIndexPath:(NSIndexPath*)indexPath{
+    if([self.dataSource respondsToSelector:@selector(deleteArticleAtIndexPath:)]){
+        [self.dataSource deleteArticleAtIndexPath:indexPath];        
+    }
+}
+
+
 #pragma mark - WMFArticleListTransitioning
 
 - (UIView*)viewForTransition:(WMFArticleListTransition*)transition {
diff --git a/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.h b/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.h
new file mode 100644
index 00000000000..8fc2f6a9ad0
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.h
@@ -0,0 +1,62 @@
+
+#import <UIKit/UIKit.h>
+#import <SelfSizingWaterfallCollectionViewLayout/SelfSizingWaterfallCollectionViewLayout.h>
+
+@protocol WMFEditingCollectionViewLayoutDelegate;
+
+@interface WMFEditingCollectionViewLayout : SelfSizingWaterfallCollectionViewLayout
+
+@property (nonatomic, weak) id<WMFEditingCollectionViewLayoutDelegate> editingDelegate;
+
+@end
+
+
+@protocol WMFEditingCollectionViewLayoutDelegate <NSObject>
+
+@optional
+
+/** Check whether a given cell can be moved.
+ *
+ *
+ * Implement this method to prevent items from
+ * being dragged to another location.
+ *
+ * @param layout The layout requesting the information
+ * @param indexPath Index path of item to be moved.
+ *
+ * @return YES if item can be moved (default); otherwise NO.
+ */
+- (BOOL)editingLayout:(WMFEditingCollectionViewLayout*)layout canMoveItemAtIndexPath:(NSIndexPath*)indexPath;
+
+/** Retarget a item's proposed index path while being moved.
+ *
+ * Implement this method to modify an item's target location
+ * while being dragged to another location, e.g. to prevent
+ * it from being moved to certain locations.
+ *
+ * @param layout The layout requesting the information
+ * @param sourceIndexPath Moving item's original index path.
+ * @param proposedDestinationIndexPath The item's proposed index path during move.
+ *
+ * @return The item's desired index path. Return proposedDestinationIndexPath if
+ *         it is suitable (default); or nil if item should not be moved.
+ */
+- (NSIndexPath*)editingLayout:(WMFEditingCollectionViewLayout*)layout targetIndexPathForMoveFromItemAtIndexPath:(NSIndexPath*)sourceIndexPath toProposedIndexPath:(NSIndexPath*)proposedDestinationIndexPath;
+
+/** Move item in data source while dragging.
+ *
+ * Implement this method to update the collection
+ * view's data source.
+ *
+ * @param layout The layout making the movee
+ * @param fromIndexPath Original item indexPath
+ * @param toIndexPath New item indexPath
+ */
+- (void)editingLayout:(WMFEditingCollectionViewLayout*)layout moveItemAtIndexPath:(NSIndexPath*)fromIndexPath toIndexPath:(NSIndexPath*)toIndexPath;
+
+
+- (BOOL)editingLayout:(WMFEditingCollectionViewLayout*)layout canDeleteItemAtIndexPath:(NSIndexPath*)indexPath;
+
+- (void)editingLayout:(WMFEditingCollectionViewLayout*)layout deleteItemAtIndexPath:(NSIndexPath*)indexPath;
+
+@end
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.m b/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.m
new file mode 100644
index 00000000000..70b9362dfe6
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFEditingCollectionViewLayout.m
@@ -0,0 +1,468 @@
+
+#import "WMFEditingCollectionViewLayout.h"
+#import "UICollectionView+WMFExtensions.h"
+
+#define MOVE_ZOOM 0.95
+
+#define SCROLL_PER_FRAME 5.0
+#define SCROLL_ZONE_TOP 100.0
+#define SCROLL_ZONE_BOTTOM 100.0
+
+typedef NS_ENUM (NSInteger, TGLStackedViewControllerScrollDirection) {
+    TGLStackedViewControllerScrollDirectionNone = 0,
+    TGLStackedViewControllerScrollDirectionDown,
+    TGLStackedViewControllerScrollDirectionUp
+};
+
+@interface WMFEditingCollectionViewLayout ()<UIGestureRecognizerDelegate>
+
+@property (assign, nonatomic) TGLStackedViewControllerScrollDirection scrollDirection;
+@property (strong, nonatomic) CADisplayLink* scrollDisplayLink;
+
+@property (strong, nonatomic) UILongPressGestureRecognizer* moveGestureRecognizer;
+@property (nonatomic, strong) UIPanGestureRecognizer* deletePanGesture;
+
+@property (assign, nonatomic) CGPoint gestureStartLocation;
+
+@property (strong, nonatomic) NSIndexPath* movingIndexPath;
+@property (assign, nonatomic) CGPoint movingCellCenter;
+@property (strong, nonatomic) UIView* movingSnapshotView;
+@property (strong, nonatomic) UIView* bottomSnapshotView;
+
+@end
+
+@implementation WMFEditingCollectionViewLayout
+
+- (void)prepareLayout {
+    [super prepareLayout];
+    
+    if (!self.moveGestureRecognizer) {
+        self.moveGestureRecognizer          = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPress:)];
+        self.moveGestureRecognizer.delegate = self;
+        [self.collectionView addGestureRecognizer:self.moveGestureRecognizer];
+    }
+    
+    if (!self.deletePanGesture) {
+        self.deletePanGesture                        = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panWithGesture:)];
+        self.deletePanGesture.maximumNumberOfTouches = 1;
+        self.deletePanGesture.delegate               = self;
+        [self.collectionView addGestureRecognizer:self.deletePanGesture];
+        [self.collectionView.panGestureRecognizer requireGestureRecognizerToFail:self.deletePanGesture];
+        [self.moveGestureRecognizer requireGestureRecognizerToFail:self.deletePanGesture];
+    }
+}
+
+- (NSArray*)layoutAttributesForElementsInRect:(CGRect)rect {
+    NSArray* layoutAttributes = [super layoutAttributesForElementsInRect:rect];
+    [layoutAttributes enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes* attributes, NSUInteger idx, BOOL * _Nonnull stop) {
+        attributes.hidden = [attributes.indexPath isEqual:self.movingIndexPath];
+    }];
+    return layoutAttributes;
+}
+
+- (UICollectionViewLayoutAttributes*)layoutAttributesForItemAtIndexPath:(NSIndexPath*)indexPath {
+    UICollectionViewLayoutAttributes* attributes = [super layoutAttributesForItemAtIndexPath:indexPath];
+    attributes.hidden = [attributes.indexPath isEqual:self.movingIndexPath];
+    return attributes;
+}
+
+- (void)prepareForTransitionToLayout:(UICollectionViewLayout*)newLayout {
+    [super prepareForTransitionToLayout:newLayout];
+    
+    [self.collectionView removeGestureRecognizer:self.moveGestureRecognizer];
+    [self.collectionView removeGestureRecognizer:self.deletePanGesture];
+    self.moveGestureRecognizer = nil;
+    self.deletePanGesture      = nil;
+}
+
+
+#pragma mark - Drag Action
+
+- (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
+    static CGPoint startCenter;
+    static CGPoint startLocation;
+    
+    switch (recognizer.state) {
+        case UIGestureRecognizerStateBegan: {
+            startLocation = [recognizer locationInView:self.collectionView];
+            
+            NSIndexPath* indexPath = [self.collectionView indexPathForItemAtPoint:startLocation];
+            
+            BOOL canMove = [self.editingDelegate respondsToSelector:@selector(editingLayout:canMoveItemAtIndexPath:)] ? [self.editingDelegate editingLayout: self canMoveItemAtIndexPath:indexPath] : YES;
+            
+            if (indexPath && canMove) {
+                UICollectionViewCell* movingCell = [self.collectionView cellForItemAtIndexPath:indexPath];
+                
+                self.movingSnapshotView       = [movingCell snapshotViewAfterScreenUpdates:YES];
+                self.movingSnapshotView.frame = movingCell.frame;
+                
+                startCenter = self.movingSnapshotView.center;
+                
+                self.movingSnapshotView.alpha = 0.0f;
+                [self.collectionView addSubview:self.movingSnapshotView];
+                
+                self.movingIndexPath = indexPath;
+                
+                __weak typeof(self) weakSelf = self;
+                
+                [UIView animateWithDuration:0.3
+                                      delay:0.0
+                                    options:UIViewAnimationOptionBeginFromCurrentState
+                                 animations:^(void) {
+                                     __strong typeof(self) strongSelf = weakSelf;
+                                     
+                                     if (strongSelf) {
+                                         strongSelf.movingSnapshotView.transform = CGAffineTransformMakeScale(MOVE_ZOOM, MOVE_ZOOM);
+                                         strongSelf.movingSnapshotView.alpha = 1.0f;
+                                     }
+                                 }
+                                 completion:^(BOOL finished) {
+                                 }];
+                
+                self.movingIndexPath = self.movingIndexPath;
+                [self invalidateLayout];
+            }
+            
+            break;
+        }
+            
+        case UIGestureRecognizerStateChanged: {
+            if (self.movingIndexPath) {
+                CGPoint currentLocation = [recognizer locationInView:self.collectionView];
+                CGPoint currentCenter   = startCenter;
+                
+                currentCenter.y += (currentLocation.y - startLocation.y);
+                
+                self.movingSnapshotView.center = currentCenter;
+                
+                if (currentLocation.y < CGRectGetMinY(self.collectionView.bounds) + SCROLL_ZONE_TOP && self.collectionView.contentOffset.y > SCROLL_ZONE_TOP) {
+                    [self startScrollingUp];
+                } else if (currentLocation.y > CGRectGetMaxY(self.collectionView.bounds) - SCROLL_ZONE_BOTTOM && self.collectionView.contentOffset.y < self.collectionView.contentSize.height - CGRectGetHeight(self.collectionView.bounds) - SCROLL_ZONE_BOTTOM) {
+                    [self startScrollingDown];
+                } else if (self.scrollDirection != TGLStackedViewControllerScrollDirectionNone) {
+                    [self stopScrolling];
+                }
+                
+                if (self.scrollDirection == TGLStackedViewControllerScrollDirectionNone) {
+                    [self updateLayoutAtMovingLocation:currentLocation];
+                }
+            }
+            
+            break;
+        }
+            
+        case UIGestureRecognizerStateEnded:
+        case UIGestureRecognizerStateCancelled: {
+            if (self.movingIndexPath) {
+                [self stopScrolling];
+                
+                UICollectionViewLayoutAttributes* layoutAttributes = [self layoutAttributesForItemAtIndexPath:self.movingIndexPath];
+                
+                self.movingIndexPath = nil;
+                
+                __weak typeof(self) weakSelf = self;
+                
+                [UIView animateWithDuration:0.3
+                                      delay:0.0
+                                    options:UIViewAnimationOptionBeginFromCurrentState
+                                 animations:^(void) {
+                                     __strong typeof(self) strongSelf = weakSelf;
+                                     
+                                     if (strongSelf) {
+                                         strongSelf.movingSnapshotView.transform = CGAffineTransformMakeScale(1.0f, 1.0f);
+                                         strongSelf.movingSnapshotView.frame = layoutAttributes.frame;
+                                     }
+                                 }
+                                 completion:^(BOOL finished) {
+                                     __strong typeof(self) strongSelf = weakSelf;
+                                     
+                                     if (strongSelf) {
+                                         [strongSelf.movingSnapshotView removeFromSuperview];
+                                         strongSelf.movingSnapshotView = nil;
+                                         
+                                         self.movingIndexPath = nil;
+                                         [strongSelf invalidateLayout];
+                                     }
+                                 }];
+            }
+            
+            break;
+        }
+            
+        default:
+            
+            break;
+    }
+}
+
+#pragma mark - Drag Helpers
+
+- (void)startScrollingUp {
+    [self startScrollingInDirection:TGLStackedViewControllerScrollDirectionUp];
+}
+
+- (void)startScrollingDown {
+    [self startScrollingInDirection:TGLStackedViewControllerScrollDirectionDown];
+}
+
+- (void)startScrollingInDirection:(TGLStackedViewControllerScrollDirection)direction {
+    if (direction != TGLStackedViewControllerScrollDirectionNone && direction != self.scrollDirection) {
+        [self stopScrolling];
+        
+        self.scrollDirection   = direction;
+        self.scrollDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleScrolling:)];
+        
+        [self.scrollDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
+    }
+}
+
+- (void)stopScrolling {
+    if (self.scrollDirection != TGLStackedViewControllerScrollDirectionNone) {
+        self.scrollDirection = TGLStackedViewControllerScrollDirectionNone;
+        
+        [self.scrollDisplayLink invalidate];
+        self.scrollDisplayLink = nil;
+    }
+}
+
+- (void)handleScrolling:(CADisplayLink*)displayLink {
+    switch (self.scrollDirection) {
+        case TGLStackedViewControllerScrollDirectionUp: {
+            CGPoint offset = self.collectionView.contentOffset;
+            
+            offset.y -= SCROLL_PER_FRAME;
+            
+            if (offset.y > 0.0) {
+                self.collectionView.contentOffset = offset;
+                
+                CGPoint center = self.movingSnapshotView.center;
+                
+                center.y                      -= SCROLL_PER_FRAME;
+                self.movingSnapshotView.center = center;
+            } else {
+                [self stopScrolling];
+                
+                CGPoint currentLocation = [self.moveGestureRecognizer locationInView:self.collectionView];
+                
+                [self updateLayoutAtMovingLocation:currentLocation];
+            }
+            
+            break;
+        }
+            
+        case TGLStackedViewControllerScrollDirectionDown: {
+            CGPoint offset = self.collectionView.contentOffset;
+            
+            offset.y += SCROLL_PER_FRAME;
+            
+            if (offset.y < self.collectionView.contentSize.height - CGRectGetHeight(self.collectionView.bounds)) {
+                self.collectionView.contentOffset = offset;
+                
+                CGPoint center = self.movingSnapshotView.center;
+                
+                center.y                      += SCROLL_PER_FRAME;
+                self.movingSnapshotView.center = center;
+            } else {
+                [self stopScrolling];
+                
+                CGPoint currentLocation = [self.moveGestureRecognizer locationInView:self.collectionView];
+                
+                [self updateLayoutAtMovingLocation:currentLocation];
+            }
+            
+            break;
+        }
+            
+        default:
+            break;
+    }
+}
+
+- (void)updateLayoutAtMovingLocation:(CGPoint)movingLocation {
+    NSIndexPath* oldMovingIndexPath = self.movingIndexPath;
+    NSIndexPath* newMovingIndexPath = [self.collectionView indexPathForItemAtPoint:movingLocation];
+    
+    if ([self.editingDelegate respondsToSelector:@selector(editingLayout:targetIndexPathForMoveFromItemAtIndexPath:toProposedIndexPath:)]) {
+        newMovingIndexPath = [self.editingDelegate editingLayout:self targetIndexPathForMoveFromItemAtIndexPath:oldMovingIndexPath toProposedIndexPath:newMovingIndexPath];
+    }
+    
+    if (newMovingIndexPath != nil && ![newMovingIndexPath isEqual:oldMovingIndexPath]) {
+        __weak typeof(self) weakSelf = self;
+        
+        [self.collectionView performBatchUpdates:^(void) {
+            [weakSelf.collectionView deleteItemsAtIndexPaths:@[ oldMovingIndexPath ]];
+            
+            weakSelf.movingIndexPath = newMovingIndexPath;
+            
+            if ([weakSelf.editingDelegate respondsToSelector:@selector(editingLayout:moveItemAtIndexPath:toIndexPath:)]) {
+                [weakSelf.editingDelegate editingLayout:weakSelf moveItemAtIndexPath:oldMovingIndexPath toIndexPath:newMovingIndexPath];
+            }
+            
+            [weakSelf.collectionView insertItemsAtIndexPaths:@[ newMovingIndexPath ]];
+        }
+                                      completion:nil];
+    }
+}
+
+#pragma mark - UIGestureRecognizer
+
+- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer*)gestureRecognizer {
+    if ([gestureRecognizer isEqual:self.deletePanGesture]) {
+        CGPoint velocity = [(UIPanGestureRecognizer*)gestureRecognizer velocityInView:self.collectionView];
+        if (velocity.y > 0 || velocity.y < 0) {
+            return NO;
+        }
+    }
+    return YES;
+}
+
+#pragma mark - Pan Action
+
+- (IBAction)panWithGesture:(UIPanGestureRecognizer*)pan {
+    switch (pan.state) {
+        case UIGestureRecognizerStateBegan:
+        {
+            CGPoint attachmentPoint = [pan locationInView:self.collectionView];
+            
+            NSIndexPath* touchedIndexPath = [self.collectionView indexPathForItemAtPoint:attachmentPoint];
+            
+            //bail if no index path
+            if (!touchedIndexPath) {
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+            
+            //bail if we can't move
+            if ([self.editingDelegate respondsToSelector:@selector(editingLayout:canDeleteItemAtIndexPath:)] && ![self.editingDelegate editingLayout:self canDeleteItemAtIndexPath:touchedIndexPath]) {
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+            
+            UICollectionViewCell* movingCell = [self.collectionView cellForItemAtIndexPath:touchedIndexPath];
+            
+            //bail if there is no cell
+            if (!movingCell) {
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+            
+            self.movingSnapshotView       = [self.collectionView wmf_snapshotOfCellAtIndexPath:touchedIndexPath];
+            self.movingSnapshotView.frame = movingCell.frame;
+            self.movingCellCenter         = self.movingSnapshotView.center;
+            self.movingIndexPath          = touchedIndexPath;
+            
+            self.bottomSnapshotView       = [self.collectionView wmf_snapshotOfCellsAfterIndexPath:touchedIndexPath];
+            self.bottomSnapshotView.frame = [self.collectionView wmf_rectEnclosingCellsAtIndexPaths:[self.collectionView wmf_visibleIndexPathsOfItemsAfterIndexPath:touchedIndexPath]];
+            
+            [self.collectionView addSubview:self.movingSnapshotView];
+            [self.collectionView addSubview:self.bottomSnapshotView];
+            
+            [self invalidateLayout];
+        }
+            break;
+            
+        case UIGestureRecognizerStateChanged:
+        {
+            if (self.movingIndexPath) {
+                CGPoint translation   = [pan translationInView:self.collectionView];
+                CGPoint currentCenter = self.movingCellCenter;
+                currentCenter.x               += translation.x;
+                self.movingSnapshotView.center = currentCenter;
+            }
+        }
+            break;
+            
+        case UIGestureRecognizerStateEnded:
+        case UIGestureRecognizerStateCancelled:
+        {
+            if (self.movingIndexPath) {
+                CGPoint translation = [pan translationInView:self.collectionView];
+                
+                if (fabs(translation.x) >= self.collectionView.bounds.size.width / 2) {
+                    [self completeDeletionPanAnimationWithGestureRecognizer:pan];
+                    return;
+                }
+                
+                CGPoint velocity = [pan velocityInView:self.collectionView];
+                if (fabs(velocity.x) > 500) {
+                    [self completeDeletionPanAnimationWithGestureRecognizer:pan];
+                    return;
+                }
+                
+                [self cancelDeletionPanAnimationWithGestureRecognizer:pan];
+            }
+        }
+            break;
+            
+        default:
+            break;
+    }
+}
+
+- (void)cancelTouchesInGestureRecognizer:(UIGestureRecognizer*)gesture {
+    gesture.enabled = NO;
+    gesture.enabled = YES;
+}
+
+- (void)completeDeletionPanAnimationWithGestureRecognizer:(UIPanGestureRecognizer*)pan {
+    CGPoint velocity         = [pan velocityInView:self.collectionView];
+    CGPoint finalDestination = self.movingCellCenter;
+    
+    if (velocity.x > 0) {
+        finalDestination.x += CGRectGetWidth(self.collectionView.bounds);
+    } else {
+        finalDestination.x -= CGRectGetWidth(self.collectionView.bounds);
+    }
+    
+    NSIndexPath* indexPath = self.movingIndexPath;
+    
+    [UIView animateWithDuration:0.25 delay:0.0 usingSpringWithDamping:0.8 initialSpringVelocity:velocity.x / finalDestination.x options:0 animations:^{
+        self.movingSnapshotView.center = finalDestination;
+    } completion:^(BOOL finished) {
+        self.movingIndexPath = nil;
+        self.gestureStartLocation = CGPointZero;
+        self.movingCellCenter = CGPointZero;
+        [self.movingSnapshotView removeFromSuperview];
+        self.movingSnapshotView = nil;
+        [self.bottomSnapshotView removeFromSuperview];
+        self.bottomSnapshotView = nil;
+        
+        [self.collectionView performBatchUpdates:^{
+            if ([self.editingDelegate respondsToSelector:@selector(editingLayout:deleteItemAtIndexPath:)]) {
+                [self.editingDelegate editingLayout:self deleteItemAtIndexPath:indexPath];
+            }
+            
+            [self invalidateLayout];
+        } completion:^(BOOL finished) {
+        }];
+    }];
+}
+
+- (void)cancelDeletionPanAnimationWithGestureRecognizer:(UIPanGestureRecognizer*)pan {
+    CGPoint velocity         = [pan velocityInView:self.collectionView];
+    CGPoint finalDestination = self.movingCellCenter;
+    
+    [UIView animateWithDuration:0.25 delay:0.0 usingSpringWithDamping:0.8 initialSpringVelocity:velocity.x / finalDestination.x options:0 animations:^{
+        self.movingSnapshotView.center = finalDestination;
+    } completion:^(BOOL finished) {
+        self.movingIndexPath = nil;
+        self.gestureStartLocation = CGPointZero;
+        self.movingCellCenter = CGPointZero;
+        
+        [self.collectionView performBatchUpdates:^{
+            [self invalidateLayout];
+        } completion:^(BOOL finished) {
+            //For some reason this completion blick fires before the layout is finished resulting in a flicker when updating the moving view.
+            // To compensate, we add a delay in to be sure it is finished before moving
+            dispatchOnMainQueueAfterDelayInSeconds(0.1, ^{
+                [self.movingSnapshotView removeFromSuperview];
+                self.movingSnapshotView = nil;
+                [self.bottomSnapshotView removeFromSuperview];
+                self.bottomSnapshotView = nil;
+            });
+        }];
+    }];
+}
+
+
+@end
