diff --git a/Wikipedia/Code/ArticlePeekPreviewViewController.swift b/Wikipedia/Code/ArticlePeekPreviewViewController.swift
index 1d3168c8e81..0fe8561bf90 100644
--- a/Wikipedia/Code/ArticlePeekPreviewViewController.swift
+++ b/Wikipedia/Code/ArticlePeekPreviewViewController.swift
@@ -4,7 +4,7 @@ import WMF
 @objc(WMFArticlePeekPreviewViewController)
 class ArticlePeekPreviewViewController: UIViewController, Peekable {
     
-    fileprivate let articleURL: URL
+    let articleURL: URL
     fileprivate let dataStore: MWKDataStore
     fileprivate var theme: Theme
     fileprivate let activityIndicatorView: UIActivityIndicatorView = UIActivityIndicatorView(style: UIActivityIndicatorView.Style.whiteLarge)
@@ -66,14 +66,9 @@ class ArticlePeekPreviewViewController: UIViewController, Peekable {
     override func viewDidLoad() {
         super.viewDidLoad()
         view.backgroundColor = theme.colors.paperBackground
-        view.translatesAutoresizingMaskIntoConstraints = false
-        
-        activityIndicatorView.translatesAutoresizingMaskIntoConstraints = false
         activityIndicatorView.style = theme.isDark ? .white : .gray
         activityIndicatorView.startAnimating()
         view.addSubview(activityIndicatorView)
-        
-        expandedArticleView.translatesAutoresizingMaskIntoConstraints = false
         expandedArticleView.isHidden = true
         view.addSubview(expandedArticleView)
         expandedArticleView.updateFonts(with: traitCollection)
diff --git a/Wikipedia/Code/ArticleViewController+LinkPreviewing.swift b/Wikipedia/Code/ArticleViewController+LinkPreviewing.swift
index 3404dc0d0ce..6975019ec7f 100644
--- a/Wikipedia/Code/ArticleViewController+LinkPreviewing.swift
+++ b/Wikipedia/Code/ArticleViewController+LinkPreviewing.swift
@@ -1,28 +1,148 @@
-extension ArticleViewController {
-    static let peekableImageExtensions: Set<String> = ["jpg", "jpeg", "gif", "png", "svg"]
-    
+
+protocol ArticleContextMenuPresenting {
+    // For Context Menus (used in iOS 13 and later)
+    @available(iOS 13.0, *)
+    func webView(_ webView: WKWebView, contextMenuConfigurationForElement elementInfo: WKContextMenuElementInfo, completionHandler: @escaping (UIContextMenuConfiguration?) -> Void)
+    func getPeekViewControllerAsync(for destination: Router.Destination, completion: @escaping (UIViewController?) -> Void)
+
+    // Used for both Context Menus and Peek/Pop
+    func hideFindInPage(_ completion: (() -> Void)?)
+    var configuration: Configuration { get }
+
+    //  For Peek/Pop (used by iOS 12 and earlier, can be removed when the oldest supported version is iOS 13)
+    func getPeekViewController(for destination: Router.Destination) -> UIViewController?
+}
+
+enum ContextMenuCompletionType {
+    case bail
+    case timeout
+    case success
+}
+
+// MARK:- Context Menu for Protocol (iOS 13 and later)
+// All functions in this extension are for Context Menus (used in iOS 13 and later)
+@available(iOS 13.0, *)
+extension ArticleContextMenuPresenting {
+    func contextMenuConfigurationForElement(_ elementInfo: WKContextMenuElementInfo, completionHandler: @escaping (UIContextMenuConfiguration?) -> Void) {
+        let nullConfig = UIContextMenuConfiguration(identifier: nil, previewProvider: nil)
+
+        let nullCompletion = {
+            completionHandler(nullConfig)
+        }
+
+        guard let linkURL = elementInfo.linkURL else {
+            nullCompletion()
+            return
+        }
+
+        //moving into separate function for easier testability
+        contextMenuConfigurationForLinkURL(linkURL) { (completionType, menuConfig) in
+            guard completionType != .bail && completionType != .timeout else {
+                nullCompletion()
+                return
+            }
+
+            completionHandler(menuConfig)
+        }
+    }
+
+    func contextMenuConfigurationForLinkURL(_ linkURL: URL, completionHandler: @escaping (ContextMenuCompletionType, UIContextMenuConfiguration?) -> Void) {
+
+        // It's helpful if we can fetch the article before calling the completion
+        // However, we need to timeout if it takes too long
+        var didCallCompletion = false
+
+        dispatchAfterDelayInSeconds(1.0, DispatchQueue.main) {
+            if (!didCallCompletion) {
+                completionHandler(.timeout, nil)
+                didCallCompletion = true;
+            }
+        }
+
+        getPeekViewControllerAsync(for: linkURL) { (peekParentVC) in
+            assert(Thread.isMainThread)
+            guard let peekParentVC = peekParentVC else {
+                if (!didCallCompletion) {
+                    completionHandler(.bail, nil)
+                    didCallCompletion = true;
+                }
+                return
+            }
+
+            let peekVC = peekParentVC.wmf_PeekableChildViewController
+
+            self.hideFindInPage(nil)
+            let config = UIContextMenuConfiguration(identifier: linkURL as NSURL, previewProvider: { () -> UIViewController? in
+                return peekParentVC
+            }) { (suggestedActions) -> UIMenu? in
+                return self.previewMenuElements(for: peekParentVC, suggestedActions: suggestedActions)
+            }
+
+            if let articlePeekVC = peekVC as? ArticlePeekPreviewViewController {
+                articlePeekVC.fetchArticle {
+                    assert(Thread.isMainThread)
+                    if (!didCallCompletion) {
+                        completionHandler(.success, config)
+                        didCallCompletion = true
+                    }
+                }
+            } else {
+                if (!didCallCompletion) {
+                    completionHandler(.success, config)
+                    didCallCompletion = true
+                }
+            }
+        }
+    }
+
     func getPeekViewControllerAsync(for linkURL: URL, completion: @escaping (UIViewController?) -> Void) {
         let destination = configuration.router.destination(for: linkURL)
         getPeekViewControllerAsync(for: destination, completion: completion)
     }
-    
+
+    func previewMenuElements(for previewViewController: UIViewController, suggestedActions: [UIMenuElement]) -> UIMenu? {
+        guard let vc = previewViewController as? ArticleViewController else {
+            return nil
+        }
+        let legacyActions = vc.previewActions
+        let menuItems = legacyActions.map { (legacyAction) -> UIMenuElement in
+            return UIAction(title: legacyAction.title) { (action) in
+                legacyAction.handler(legacyAction, previewViewController)
+            }
+        }
+        return UIMenu(title: "", image: nil, identifier: nil, options: [], children: menuItems)
+    }
+}
+
+// MARK: Peek/Pop for Protocol (iOS 12 and earlier, on devices w/ 3D Touch)
+// All functions in this extension are for 3D Touch menus. (Can be removed when the oldest supported version is iOS 13.)
+extension ArticleContextMenuPresenting {
     func getPeekViewController(for linkURL: URL) -> UIViewController? {
         let destination = configuration.router.destination(for: linkURL)
         return getPeekViewController(for: destination)
     }
-    
-    func getPeekViewController(for destination: Router.Destination) -> UIViewController? {
-        switch destination {
-        case .article(let articleURL):
-            let articleVC = ArticleViewController(articleURL: articleURL, dataStore: dataStore, theme: theme)
-            articleVC?.articlePreviewingDelegate = self
-            articleVC?.wmf_addPeekableChildViewController(for: articleURL, dataStore: dataStore, theme: theme)
-            return articleVC
-        default:
+
+    func shouldPreview(linkURL: URL?) -> Bool {
+        guard let linkURL = linkURL else {
+            return false
+        }
+        return linkURL.isPreviewable
+    }
+
+    func previewingViewController(for linkURL: URL?) -> UIViewController?  {
+        guard let linkURL = linkURL, let peekVC = getPeekViewController(for: linkURL) else {
             return nil
         }
+        hideFindInPage(nil)
+        return peekVC
     }
-    
+}
+
+// MARK:- Context Menu for ArticleVC (iOS 13 and later)
+// All functions in this extension are for Context Menus (used in iOS 13 and later)
+extension ArticleViewController: ArticleContextMenuPresenting, WKUIDelegate {
+    static let peekableImageExtensions: Set<String> = ["jpg", "jpeg", "gif", "png", "svg"]
+
     func getPeekViewControllerAsync(for destination: Router.Destination, completion: @escaping (UIViewController?) -> Void) {
         switch destination {
         case .inAppLink(let linkURL):
@@ -104,21 +224,40 @@ extension ArticleViewController {
         
         return actions
     }
-    
+
     @available(iOS 13.0, *)
-    func previewMenuElements(for previewViewController: UIViewController, suggestedActions: [UIMenuElement]) -> UIMenu? {
-        guard let vc = previewViewController as? ArticleViewController else {
-            return nil
+    func webView(_ webView: WKWebView, contextMenuConfigurationForElement elementInfo: WKContextMenuElementInfo, completionHandler: @escaping (UIContextMenuConfiguration?) -> Void) {
+        self.contextMenuConfigurationForElement(elementInfo, completionHandler: completionHandler)
+    }
+
+    @available(iOS 13.0, *)
+    func webView(_ webView: WKWebView, contextMenuForElement elementInfo: WKContextMenuElementInfo, willCommitWithAnimator animator: UIContextMenuInteractionCommitAnimating) {
+        guard
+            animator.preferredCommitStyle != .dismiss,
+            let vc = animator.previewViewController
+            else {
+                return
         }
-        let legacyActions = vc.previewActions
-        let menuItems = legacyActions.map { (legacyAction) -> UIMenuElement in
-            return UIAction(title: legacyAction.title) { (action) in
-                legacyAction.handler(legacyAction, previewViewController)
-            }
+
+        animator.addCompletion {
+            self.commitPreview(of: vc)
         }
-        return UIMenu(title: "", image: nil, identifier: nil, options: [], children: menuItems)
     }
-    
+
+    // This function is used by both Peek/Pop and Context Menu (can remove this note when removing rest of Peek/Pop code, when oldest supported version is iOS 13)
+    func getPeekViewController(for destination: Router.Destination) -> UIViewController? {
+        switch destination {
+        case .article(let articleURL):
+            let articleVC = ArticleViewController(articleURL: articleURL, dataStore: dataStore, theme: theme)
+            articleVC?.articlePreviewingDelegate = self
+            articleVC?.wmf_addPeekableChildViewController(for: articleURL, dataStore: dataStore, theme: theme)
+            return articleVC
+        default:
+            return nil
+        }
+    }
+
+    // This function is used by both Peek/Pop and Context Menu (can remove this note when removing rest of Peek/Pop code, when oldest supported version is iOS 13)
     func commitPreview(of viewControllerToCommit: UIViewController) {
         if let vc = viewControllerToCommit as? ArticleViewController {
             vc.wmf_removePeekableChildViewControllers()
@@ -132,125 +271,19 @@ extension ArticleViewController {
     }
 }
 
-extension ArticleViewController: WKUIDelegate {
-    
-    enum ContextMenuCompletionType {
-        case bail
-        case timeout
-        case success
-    }
-    
-    @available(iOS 13.0, *)
-
-    func contextMenuConfigurationForLinkURL(_ linkURL: URL, completionHandler: @escaping (ContextMenuCompletionType, UIContextMenuConfiguration?) -> Void) {
-        
-        // It's helpful if we can fetch the article before calling the completion
-        // However, we need to timeout if it takes too long
-        var didCallCompletion = false
+// MARK: Peek/Pop for ArticleVC (iOS 12 and earlier, on devices w/ 3D Touch)
+// All functions in this extension are for 3D Touch menus. (Can be removed when the oldest supported version is iOS 13.)
+extension ArticleViewController {
 
-        dispatchAfterDelayInSeconds(1.0, DispatchQueue.main) {
-            if (!didCallCompletion) {
-                completionHandler(.timeout, nil)
-                didCallCompletion = true;
-            }
-        }
-        
-        getPeekViewControllerAsync(for: linkURL) { (peekParentVC) in
-            assert(Thread.isMainThread)
-            guard let peekParentVC = peekParentVC else {
-                if (!didCallCompletion) {
-                    completionHandler(.bail, nil)
-                    didCallCompletion = true;
-                }
-                return
-            }
-            
-            let peekVC = peekParentVC.wmf_PeekableChildViewController
-            
-            self.hideFindInPage()
-            let config = UIContextMenuConfiguration(identifier: linkURL as NSURL, previewProvider: { () -> UIViewController? in
-                return peekParentVC
-            }) { (suggestedActions) -> UIMenu? in
-                return self.previewMenuElements(for: peekParentVC, suggestedActions: suggestedActions)
-            }
-            
-            if let articlePeekVC = peekVC as? ArticlePeekPreviewViewController {
-                articlePeekVC.fetchArticle {
-                    assert(Thread.isMainThread)
-                    if (!didCallCompletion) {
-                        completionHandler(.success, config)
-                        didCallCompletion = true
-                    }
-                }
-            } else {
-                if (!didCallCompletion) {
-                    completionHandler(.success, config)
-                    didCallCompletion = true
-                }
-            }
-        }
-    }
-    
-    // MARK: Context menus
-    
-    @available(iOS 13.0, *)
-    func webView(_ webView: WKWebView, contextMenuConfigurationForElement elementInfo: WKContextMenuElementInfo, completionHandler: @escaping (UIContextMenuConfiguration?) -> Void) {
-        
-        let nullConfig = UIContextMenuConfiguration(identifier: nil, previewProvider: nil)
-        
-        let nullCompletion = {
-            completionHandler(nullConfig)
-        }
-        
-        guard let linkURL = elementInfo.linkURL else {
-            nullCompletion()
-            return
-        }
-        
-        //moving into separate function for easier testability
-        contextMenuConfigurationForLinkURL(linkURL) { (completionType, menuConfig) in
-            guard completionType != .bail && completionType != .timeout else {
-                nullCompletion()
-                return
-            }
-            
-            completionHandler(menuConfig)
-        }
-    }
-    
-    @available(iOS 13.0, *)
-    func webView(_ webView: WKWebView, contextMenuForElement elementInfo: WKContextMenuElementInfo, willCommitWithAnimator animator: UIContextMenuInteractionCommitAnimating) {
-        guard
-            animator.preferredCommitStyle != .dismiss,
-            let vc = animator.previewViewController
-            else {
-                return
-        }
-        
-        animator.addCompletion {
-            self.commitPreview(of: vc)
-        }
-    }
-    
-    // MARK: Peek/Pop (can be removed when the oldest supported version is iOS 13)
-    
     func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
-        guard let linkURL = elementInfo.linkURL else {
-            return false
-        }
-        return linkURL.isPreviewable
+        return self.shouldPreview(linkURL: elementInfo.linkURL)
     }
-    
+
     func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
-        guard let linkURL = elementInfo.linkURL, let peekVC = getPeekViewController(for: linkURL) else {
-            return nil
-        }
-        hideFindInPage()
-        return peekVC
+        return self.previewingViewController(for: elementInfo.linkURL)
     }
-    
+
     func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
         commitPreview(of: previewingViewController)
     }
-    
 }
diff --git a/Wikipedia/Code/EditPreviewViewController.swift b/Wikipedia/Code/EditPreviewViewController.swift
index dfa218cb1fe..331d267258d 100644
--- a/Wikipedia/Code/EditPreviewViewController.swift
+++ b/Wikipedia/Code/EditPreviewViewController.swift
@@ -98,6 +98,7 @@ class EditPreviewViewController: ViewController, WMFPreviewSectionLanguageInfoDe
             loggedEditActions.add(EditFunnel.Action.preview)
         }
         apply(theme: theme)
+        previewWebViewContainer.webView.uiDelegate = self
     }
     
     override func viewWillAppear(_ animated: Bool) {
@@ -167,7 +168,6 @@ class EditPreviewViewController: ViewController, WMFPreviewSectionLanguageInfoDe
     }
 }
 
-
 extension EditPreviewViewController: ArticleWebMessageHandling {
     func didRecieve(action: ArticleWebMessagingController.Action) {
         switch action {
@@ -191,3 +191,62 @@ extension EditPreviewViewController: ArticleWebMessageHandling {
         }
     }
 }
+
+// MARK:- Context Menu (iOS 13 and later)
+// All functions in this extension are for Context Menus (used in iOS 13 and later)
+extension EditPreviewViewController: ArticleContextMenuPresenting, WKUIDelegate {
+    func getPeekViewControllerAsync(for destination: Router.Destination, completion: @escaping (UIViewController?) -> Void) {
+        completion(getPeekViewController(for: destination))
+    }
+
+    @available(iOS 13.0, *)
+    func webView(_ webView: WKWebView, contextMenuConfigurationForElement elementInfo: WKContextMenuElementInfo, completionHandler: @escaping (UIContextMenuConfiguration?) -> Void) {
+
+        self.contextMenuConfigurationForElement(elementInfo, completionHandler: completionHandler)
+    }
+
+//    func webView(_ webView: WKWebView, contextMenuForElement elementInfo: WKContextMenuElementInfo, willCommitWithAnimator animator: UIContextMenuInteractionCommitAnimating)
+//    No function with this signature, as we don't want to have any context menu elements in preview - and we get that behavior by default by not implementing this.
+
+    // This function is used by both Peek/Pop and Context Menu (can remove this note when removing rest of Peek/Pop code, when oldest supported version is iOS 13)
+    func getPeekViewController(for destination: Router.Destination) -> UIViewController? {
+        let dataStore = MWKDataStore.shared()
+        switch destination {
+            case .article(let articleURL):
+            return ArticlePeekPreviewViewController(articleURL: articleURL, dataStore: dataStore, theme: theme)
+            default:
+                return nil
+        }
+    }
+
+    // This function is used by both Peek/Pop and Context Menu (can remove this note when removing rest of Peek/Pop code, when oldest supported version is iOS 13)
+    // This function needed is for ArticleContextMenuPresenting, but not applicable to EditPreviewVC
+    func hideFindInPage(_ completion: (() -> Void)? = nil) {
+    }
+}
+
+// MARK: Peek/Pop (iOS 12 and earlier, on devices w/ 3D Touch)
+// All functions in this extension are for 3D Touch menus. (Can be removed when the oldest supported version is iOS 13.)
+extension EditPreviewViewController {
+    var configuration: Configuration {
+        return Configuration.current
+    }
+
+    func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
+        return self.shouldPreview(linkURL: elementInfo.linkURL)
+    }
+
+    func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
+        return self.previewingViewController(for: elementInfo.linkURL)
+    }
+
+    func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
+        // If EditPreviewInternalLinkViewController ever gets refactored, would be nice to break apart it's internal containerView so that here we could wrap
+        // previewingViewController in an EditPreviewInternalLinkViewController. (For now, just loading a new EditPreviewInternalLinkVC would load the articleURL in
+        // viewDidLoad - before we could hijack it - and so we're just reloading our preview again.)
+        guard let url = (previewingViewController as? ArticlePeekPreviewViewController)?.articleURL else {
+            return
+        }
+        showInternalLink(url: url)
+    }
+}
