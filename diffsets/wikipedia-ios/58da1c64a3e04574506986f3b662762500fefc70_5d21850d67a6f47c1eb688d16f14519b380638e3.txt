diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index e724d9e6ce5..f59ebd15878 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -396,6 +396,11 @@
 		53A575FA2602C845009835E6 /* WMFAppViewController+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 53A575F92602C845009835E6 /* WMFAppViewController+Extensions.swift */; };
 		53A575FB2602C845009835E6 /* WMFAppViewController+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 53A575F92602C845009835E6 /* WMFAppViewController+Extensions.swift */; };
 		53A575FC2602C845009835E6 /* WMFAppViewController+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 53A575F92602C845009835E6 /* WMFAppViewController+Extensions.swift */; };
+		5F5E96E52C57E4D6006FDE95 /* SharedLib.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5F5E96E42C57E4D6006FDE95 /* SharedLib.swift */; };
+		5F5E96E62C57E4D6006FDE95 /* SharedLib.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5F5E96E42C57E4D6006FDE95 /* SharedLib.swift */; };
+		5FF60E702C59350600306D6E /* sharedlib in Resources */ = {isa = PBXBuildFile; fileRef = 5FF60E6F2C59350600306D6E /* sharedlib */; };
+		5FF60E712C59350600306D6E /* sharedlib in Resources */ = {isa = PBXBuildFile; fileRef = 5FF60E6F2C59350600306D6E /* sharedlib */; };
+		5FF60E732C59376900306D6E /* SharedLibTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5FF60E722C59376900306D6E /* SharedLibTest.swift */; };
 		67033E142A61B24800896852 /* WatchlistController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 67033E132A61B24800896852 /* WatchlistController.swift */; };
 		67033E152A61B24800896852 /* WatchlistController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 67033E132A61B24800896852 /* WatchlistController.swift */; };
 		67033E162A61B24800896852 /* WatchlistController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 67033E132A61B24800896852 /* WatchlistController.swift */; };
@@ -3241,6 +3246,9 @@
 		535F16D525CE11A300875AAD /* MWKDataStore+LanguageVariantMigration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "MWKDataStore+LanguageVariantMigration.swift"; sourceTree = "<group>"; };
 		53A575F92602C845009835E6 /* WMFAppViewController+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "WMFAppViewController+Extensions.swift"; sourceTree = "<group>"; };
 		53BAB79925DDDEE100A5ED4E /* Wikipedia 6.xcdatamodel */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcdatamodel; path = "Wikipedia 6.xcdatamodel"; sourceTree = "<group>"; };
+		5F5E96E42C57E4D6006FDE95 /* SharedLib.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SharedLib.swift; sourceTree = "<group>"; };
+		5FF60E6F2C59350600306D6E /* sharedlib */ = {isa = PBXFileReference; lastKnownFileType = folder; path = sharedlib; sourceTree = SOURCE_ROOT; };
+		5FF60E722C59376900306D6E /* SharedLibTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SharedLibTest.swift; sourceTree = "<group>"; };
 		67033E132A61B24800896852 /* WatchlistController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WatchlistController.swift; sourceTree = "<group>"; };
 		67033E182A61DC3700896852 /* ArticleViewController+Watchlist.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ArticleViewController+Watchlist.swift"; sourceTree = "<group>"; };
 		67059DB42260D034009811AA /* SchemeHandler.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SchemeHandler.swift; sourceTree = "<group>"; };
@@ -7514,6 +7522,7 @@
 				67BEFFD928AEDF3600606B38 /* WikimediaProject.swift */,
 				673DE3112BAE2C9400E4D431 /* WKProject+Extensions.swift */,
 				67F42EE22AA0E39C003BDCB6 /* UINavigationItem+Extensions.swift */,
+				5F5E96E42C57E4D6006FDE95 /* SharedLib.swift */,
 			);
 			name = Utilities;
 			sourceTree = "<group>";
@@ -7844,6 +7853,7 @@
 				00D280FB247F019C006BEE23 /* Date+ExtensionTests.swift */,
 				FFBA8C1827D824D8009E9B65 /* URL+ExtensionTests.swift */,
 				00A8F58526BDD5E700175B8E /* WidgetSampleContentTests.swift */,
+				5FF60E722C59376900306D6E /* SharedLibTest.swift */,
 			);
 			name = Tests;
 			path = WikipediaUnitTests/Code;
@@ -7953,6 +7963,7 @@
 				D4991453181D51DE00E6073C /* Images.xcassets */,
 				BC7C3A371C0FF94A0057F023 /* Code */,
 				BCF012321AD2FA38008D3675 /* assets */,
+				5FF60E6F2C59350600306D6E /* sharedlib */,
 				D8BA1F1F1DF1E19700502877 /* Resources */,
 			);
 			path = Wikipedia;
@@ -9331,6 +9342,7 @@
 			isa = PBXResourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				5FF60E712C59350600306D6E /* sharedlib in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -9429,6 +9441,7 @@
 				7AE1D3331FCD057200393471 /* Saved.storyboard in Resources */,
 				D8E27BAD1F82B54D00F9D2B3 /* RMessageDefaultDesign.json in Resources */,
 				B01EA07E2022856300813726 /* ScrollableEducationPanelView.xib in Resources */,
+				5FF60E702C59350600306D6E /* sharedlib in Resources */,
 				D84F2BFB1D2FEE6300963D42 /* WMFRandomDiceButton.html in Resources */,
 				7A9524D022665E6400C55CDC /* InsertMediaSettingsImageView.xib in Resources */,
 				7ABE171D2239B8EE006BA309 /* WelcomeContainerViewController.xib in Resources */,
@@ -9915,6 +9928,7 @@
 				D8BDA8C11E71C0760031F4BF /* WMFBlocksKitTests.m in Sources */,
 				B0E8092F1C0D1A0B0065EBC0 /* NSURL+WMFExtrasTests.m in Sources */,
 				B39427441E71F79700D3146D /* NSDictionaryBlocksKitTest.m in Sources */,
+				5FF60E732C59376900306D6E /* SharedLibTest.swift in Sources */,
 				67DAEDF027E8FB63005CF9B6 /* NotificationsCenterDetailViewModelMentionTests.swift in Sources */,
 				B0E808771C0D155A0065EBC0 /* XCTestCase+WMFBundleConvenience.m in Sources */,
 				004281BC25E6EFC4004945B3 /* LSASIHTTPRequestHook.m in Sources */,
@@ -9995,6 +10009,7 @@
 				004281C025E6EFC4004945B3 /* NSString+Matcheable.m in Sources */,
 				004281C425E6EFC4004945B3 /* LSRegexMatcher.m in Sources */,
 				004281C225E6EFC4004945B3 /* LSDataMatcher.m in Sources */,
+				5F5E96E62C57E4D6006FDE95 /* SharedLib.swift in Sources */,
 				004281C625E6EFC4004945B3 /* NSString+Nocilla.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -10383,6 +10398,7 @@
 				7AF8CEED22653406000B7676 /* InsertMediaSelectedImageView.swift in Sources */,
 				838790B32858009000067B1D /* TalkPageFetcher.swift in Sources */,
 				67BF28542C3DEC5300C9F5DE /* AppDelegate.swift in Sources */,
+				5F5E96E52C57E4D6006FDE95 /* SharedLib.swift in Sources */,
 				B08337611DB17DC5002860D2 /* WMFWelcomeAnalyticsViewController.swift in Sources */,
 				6782DBAF2343B812003FA21B /* DiffHeaderCompareView.swift in Sources */,
 				B0D3E70C214AF776007578BA /* DescriptionEditViewController.swift in Sources */,
diff --git a/Wikipedia/Code/SharedLib.swift b/Wikipedia/Code/SharedLib.swift
new file mode 100644
index 00000000000..4eb94395f52
--- /dev/null
+++ b/Wikipedia/Code/SharedLib.swift
@@ -0,0 +1,47 @@
+// Wrapper for JS sharedlib for the iOS and Android apps
+// Experimental as of 2024-07-29
+
+import Foundation
+import JavaScriptCore
+
+public struct MissingAltTextLink {
+    public var text: String
+    public var file: String
+    public var offset: Int
+    public var length: Int
+}
+
+public class AltText {
+    var context: JSContext
+
+    public init() throws {
+        context = JSContext()
+
+        let altPath = Bundle.main.path(forResource: "alt-text", ofType: "js", inDirectory: "sharedlib")!
+
+        let alt = try String(contentsOfFile: altPath)
+
+        context.evaluateScript(alt)
+    }
+
+    public func missingAltTextLinks(text: String, language: String) throws -> [MissingAltTextLink] {
+        let f = context.globalObject.objectForKeyedSubscript("missingAltTextLinks")!
+        let ret = f.call(withArguments:[text, language])
+        var arr = [MissingAltTextLink]()
+        let len = Int(ret?.objectForKeyedSubscript("length").toInt32() ?? 0)
+        for i in 0..<len {
+            let link = ret?.objectAtIndexedSubscript(i)
+            let text = link?.objectForKeyedSubscript("text")?.toString()
+            let file = link?.objectForKeyedSubscript("file")?.toString()
+            let offset = link?.objectForKeyedSubscript("offset")?.toInt32()
+            let length = link?.objectForKeyedSubscript("length")?.toInt32()
+            arr.append(MissingAltTextLink(
+                text: text!,
+                file: file!,
+                offset: Int(offset!),
+                length: Int(length!)
+            ))
+        }
+        return arr
+    }
+}
diff --git a/WikipediaUnitTests/Code/SharedLibTest.swift b/WikipediaUnitTests/Code/SharedLibTest.swift
new file mode 100644
index 00000000000..9e91a560668
--- /dev/null
+++ b/WikipediaUnitTests/Code/SharedLibTest.swift
@@ -0,0 +1,33 @@
+import XCTest
+
+final class SharedLibTest: XCTestCase {
+
+    var alt: AltText?
+
+    override func setUpWithError() throws {
+        alt = try AltText()
+    }
+
+    override func tearDownWithError() throws {
+    }
+
+    func testCaptionNoAlt() throws {
+        let text = "[[File:Test no alt.jpg|caption here]]"
+        let wikitext = "text text " + text + " text text"
+        let result = try alt?.missingAltTextLinks(text: wikitext, language: "en")
+        XCTAssertEqual(result?.count, 1)
+        let link = result?[0]
+        XCTAssertEqual(link?.text, text)
+        XCTAssertEqual(link?.file, "File:Test no alt.jpg")
+        XCTAssertEqual(link?.offset, "text text ".count)
+        XCTAssertEqual(link?.length, text.count)
+    }
+
+    func testCaptionWithAlt() throws {
+        let text = "[[File:Test with alt.jpg|caption here|alt=Cool picture]]"
+        let wikitext = "text text " + text + " text text"
+        let result = try alt?.missingAltTextLinks(text: wikitext, language: "en")
+        XCTAssertEqual(result?.count, 0)
+    }
+
+}
diff --git a/sharedlib/alt-text.js b/sharedlib/alt-text.js
new file mode 100644
index 00000000000..1262ce921a1
--- /dev/null
+++ b/sharedlib/alt-text.js
@@ -0,0 +1,80 @@
+// These are approximations for the link portion of the parser
+// and won't catch all actual links, but should catch most or all
+// manually written links and file invocations.
+const start = "\\[\\[";
+const end = "\\]\\]";
+const nonLink = "[^\\[\\]\\|]+";
+const innerLink = `\\[\\[${nonLink}(?:\|${nonLink})*\]\]`;
+const webLink = `\\[${nonLink}\\]`;
+const span = `(?:${nonLink}|${innerLink}|${webLink})+`;
+
+// Capture the inside part of the link
+const linksRegEx = new RegExp(
+    `${start}(${span}(?:\\|${span})*)${end}`,
+    "dmg"
+);
+
+// @fixme we need to support localized variants;
+// fetch them into a .json for use here, or pass
+// them in from the Swift side maybe?
+const fileRegEx = /^\s*(?:Image|File):.*/i;
+const altRegEx = /^\s*alt\s*=\s*(?:[^\|\]]*)$/i;
+
+function parseLink(offset, length, text, language) {
+    let bits = text.split( /\|/ );
+    let link = {
+        text: '[[' + text + ']]',
+        offset,
+        length,
+        file: null,
+        alt: null,
+    };
+    for (let bit of bits) {
+        if (bit.match(fileRegEx)) {
+            link.file = bit;
+        } else if (bit.match(altRegEx)) {
+            link.alt = bit;
+        }
+    }
+    return link;
+}
+
+function parseLinks(text, language) {
+    let matches = text.matchAll(linksRegEx);
+    let bits = [];
+    for (let m of matches) {
+        let offset = m.indices[0][0];
+        let link = parseLink(offset, m[0].length, m[1], language);
+        bits.push(link);
+    }
+    return bits;
+}
+
+/**
+ * Look for file links/invocations with no alt text.
+ *
+ * @param {string} text input wikitext
+ * @param {string} language code
+ * @returns {Array} list of {text, offset, length, file, alt} of matching links
+ */
+function missingAltTextLinks(text, language) {
+    return parseLinks(text, language).filter((link) => {
+        if (link.file === null) {
+            // Not a file link.
+            return false;
+        }
+        if (link.alt !== null) {
+            // Has alt text specified
+            return false;
+        }
+        // Note: strictly speaking a surrounding ARIA role can prevent
+        // the need here, but this isn't detected in our usage.
+        // We assume these will mostly live in templates and won't come
+        // up here often.
+        return true;
+    });
+}
+
+module.exports = {
+    missingAltTextLinks
+};
diff --git a/sharedlib/package.json b/sharedlib/package.json
new file mode 100644
index 00000000000..a3dd7cda161
--- /dev/null
+++ b/sharedlib/package.json
@@ -0,0 +1,14 @@
+{
+  "name": "sharedlib",
+  "version": "0.0.1",
+  "main": "alt-text.js",
+  "directories": {
+    "test": "tests"
+  },
+  "scripts": {
+    "test": "node tests/test-alt-text.js"
+  },
+  "author": "",
+  "license": "MIT",
+  "description": ""
+}
diff --git a/sharedlib/readme.md b/sharedlib/readme.md
new file mode 100644
index 00000000000..68381c04da1
--- /dev/null
+++ b/sharedlib/readme.md
@@ -0,0 +1,48 @@
+# Sharedlib prototype for Wikipedia mobile app
+
+Wrote some of the logic for missing alt text detection in
+platform-agnostic JavaScript which can be called via JSC
+on iOS, and presumably equivalent setup on Android, if we
+use the same logic there.
+
+If this is too much rigamarole, it's fine to convert this
+code to straight Swift, but it might be worth trying out.
+
+The alt text link parser is simplified and won't catch
+complex cases with templates and such but should handle
+all common hand-written links and generally ignore others.
+
+The `missingAltTextLinks()` function takes a string with
+wikitext, and the language name, and returns an array of
+detected links that don't appear to have an alt text marking.
+
+## Internationalization
+
+Currently it's hardcoded to the English namespace and alt
+keyword names, this needs to be expanded with a list of each
+language's overrides so it can build the appropriate regexes.
+
+## Calling from Swift
+
+`SharedLib.swift` in `Utilities` has the wrapper interfaces
+on the Swift side; `AltText` encapsulates a JSC VM and can
+have its `missingAltTextLinks()` method called to return a
+Swift array of `MissingAltTextLink` structs, each with:
+
+* `text` - string of the full link
+* `offset`, `length` - UTF-16 offset and length of the full link within the input wikitext
+* `file` - the extracted file name from the link, which may have spaces or case normalization needs. Should be suitable for putting into the wiki API for fetching URLs etc.
+
+It should be safe to insert an `alt=blah` before the final "`]]`" in the link string.
+
+## Testing
+
+There's a node CLI test under `tests/`
+
+Run `npm test` inside `sharedlib` dir to run them.
+
+A swift-side unit test confirms the JSC bridge works as expected and will run automatically.
+
+## The files
+
+The `sharedlib` subdirectory is included in the output bundle alongside the `assets`, and `.js` is loaded out of it when instantiating the wrapper class.
diff --git a/sharedlib/tests/test-alt-text.js b/sharedlib/tests/test-alt-text.js
new file mode 100644
index 00000000000..8334fd47b07
--- /dev/null
+++ b/sharedlib/tests/test-alt-text.js
@@ -0,0 +1,105 @@
+let {missingAltTextLinks} = require('../alt-text.js');
+
+let testCases = [
+    {
+        wikiText: '[[File:Foobar.jpg]]',
+        desc: 'Inline image, no alt or caption',
+        expected: [
+            {
+                text: '[[File:Foobar.jpg]]',
+                offset: 0,
+                length: '[[File:Foobar.jpg]]'.length,
+                file: 'File:Foobar.jpg',
+                alt: null,
+            }
+        ]
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|alt=Painting depicting a gazebo]]',
+        desc: 'Inline image, explicit alt',
+        expected: [],
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|Painting depicting a gazebo]]',
+        desc: 'Inline image, implicit alt as caption',
+        expected: [
+            {
+                text: '[[File:Foobar.jpg|Painting depicting a gazebo]]',
+                offset: 0,
+                length: '[[File:Foobar.jpg|Painting depicting a gazebo]]'.length,
+                file: 'File:Foobar.jpg',
+                alt: null,
+            }
+        ]
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|thumb|On display]]',
+        desc: 'Thumbnail image, no alt, has caption',
+        expected: [
+            {
+                text: '[[File:Foobar.jpg|thumb|On display]]',
+                offset: 0,
+                length: '[[File:Foobar.jpg|thumb|On display]]'.length,
+                file: 'File:Foobar.jpg',
+                alt: null,
+            }
+        ]
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|thumb|alt=Painting depicting a gazebo]]',
+        desc: 'Thumbnail image, explicit alt, no caption',
+        expected: []
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|thumb|alt=Painting depicting a gazebo|On display]]',
+        desc: 'Thumbnail image, explicit alt, has caption',
+        expected: []
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|alt=]]',
+        desc: 'Inline image, explicit empty alt',
+        expected: []
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|thumb|alt=]]',
+        desc: 'Thumbnail image, explicit empty alt, no caption',
+        expected: []
+    },
+    {
+        wikiText: '[[File:Foobar.jpg|thumb|alt=|On display]]',
+        desc: 'Thumbnail image, explicit empty alt, has caption',
+        expected: []
+    },
+
+
+    {
+        wikiText: 'bla bla [[File:Foobar.jpg|nice stuff]] and [[File:Baz.jpg|utter madness|alt=Baz]]',
+        desc: 'Two links, one no alt one with alt',
+        expected: [
+            {
+                text: '[[File:Foobar.jpg|nice stuff]]',
+                offset: 'bla bla '.length,
+                length: '[[File:Foobar.jpg|nice stuff]]'.length,
+                file: 'File:Foobar.jpg',
+                alt: null,
+            }
+        ]
+    },
+];
+
+let failures = 0;
+for (let {wikiText, count, desc, expected} of testCases) {
+    let missing = missingAltTextLinks(wikiText, 'en');
+    if (JSON.stringify(expected) !== JSON.stringify(missing)) {
+        console.error("MISMATCH", wikiText);
+        console.error('expected', expected);
+        console.error('got', missing);
+        failures++;
+    } else {
+        console.log("OK", wikiText);
+        console.error('got', missing);
+    }
+}
+if (failures > 0) {
+    process.exit(1);
+}
