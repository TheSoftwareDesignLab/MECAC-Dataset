diff --git a/WMF Framework/CSRFTokenOperation.swift b/WMF Framework/CSRFTokenOperation.swift
index 560836f41ad..1b97504d5fa 100644
--- a/WMF Framework/CSRFTokenOperation.swift	
+++ b/WMF Framework/CSRFTokenOperation.swift	
@@ -86,12 +86,12 @@ public class CSRFTokenOperation<Result>: AsyncOperation {
 
 public class CSRFTokenJSONDictionaryOperation: CSRFTokenOperation<[String: Any]> {
     public override func didFetchToken(_ token: WMFAuthToken, completion: @escaping ([String: Any]?, URLResponse?, Bool?, Error?) -> Void) {
-        self.session.jsonDictionaryTask(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, authorized: token.isAuthorized, completionHandler: completion)?.resume()
+        self.session.jsonDictionaryTask(with: components.url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, authorized: token.isAuthorized, completionHandler: completion)?.resume()
     }
 }
 
 public class CSRFTokenJSONDecodableOperation<Result: Decodable>: CSRFTokenOperation<Result> {
     public override func didFetchToken(_ token: WMFAuthToken, completion: @escaping (Result?, URLResponse?, Bool?, Error?) -> Void) {
-        self.session.jsonDecodableTask(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, authorized: token.isAuthorized, completionHandler: completion)
+        self.session.jsonDecodableTask(with: components.url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, authorized: token.isAuthorized, completionHandler: completion)
     }
 }
diff --git a/WMF Framework/Configuration.swift b/WMF Framework/Configuration.swift
index 21b9ed21391..0fae85458fe 100644
--- a/WMF Framework/Configuration.swift	
+++ b/WMF Framework/Configuration.swift	
@@ -26,23 +26,27 @@ public class Configuration: NSObject {
     struct Domain {
         static let wikipedia = "wikipedia.org"
         static let wikidata = "wikidata.org"
-        static let mediawiki = "mediawiki.org"
+        static let mediaWiki = "mediawiki.org"
         static let wmflabs = "wikipedia.beta.wmflabs.org"
         static let localhost = "localhost"
         static let englishWikipedia = "en.wikipedia.org"
+        static let metaWiki = "meta.wikimedia.org"
     }
     
     struct Path {
         static let wikiResource = "/wiki/"
-        static let mobileAppsServicesAPIComponents = ["", "api", "rest_v1"] // "" to get a leading /
+        static let mobileAppsServicesAPIComponents = ["api", "rest_v1"]
+        static let mediaWikiAPIComponents = ["w", "api.php"]
     }
     
-    public struct API {
+    public struct APIURLComponentsBuilder {
         let hostComponents: URLComponents
         let basePathComponents: [String]
-        func components(byAppending pathComponents: [String]) -> URLComponents {
+        
+        func components(byAppending pathComponents: [String] = [], queryParameters: [String: Any]? = nil) -> URLComponents {
             var components = hostComponents
-            components.path = (basePathComponents + pathComponents).joined(separator: "/") // NSString.path(with: components) removes the trailing slash that the reading list API needs
+            components.replacePercentEncodedPathWithPathComponents(basePathComponents + pathComponents)
+            components.replacePercentEncodedQueryWithQueryParameters(queryParameters)
             return components
         }
     }
@@ -59,38 +63,51 @@ public class Configuration: NSObject {
     
     required init(defaultSiteDomain: String, otherDomains: [String] = []) {
         self.defaultSiteDomain = defaultSiteDomain
-        self.mediaWikiCookieDomain = Domain.mediawiki.withDotPrefix
+        self.mediaWikiCookieDomain = Domain.mediaWiki.withDotPrefix
         self.wikipediaCookieDomain = Domain.wikipedia.withDotPrefix
         self.wikidataCookieDomain = Domain.wikidata.withDotPrefix
         self.centralAuthCookieSourceDomain = self.wikipediaCookieDomain
         self.centralAuthCookieTargetDomains = [self.wikidataCookieDomain, self.mediaWikiCookieDomain]
-        self.wikiResourceDomains = [defaultSiteDomain, Domain.mediawiki] + otherDomains
+        self.wikiResourceDomains = [defaultSiteDomain, Domain.mediaWiki] + otherDomains
     }
     
-    func mobileAppsServicesAPIForHost(_ host: String? = nil) -> API {
+    func mobileAppsServicesAPIURLComponentsBuilderForHost(_ host: String? = nil) -> APIURLComponentsBuilder {
         switch Stage.current {
         case .local:
             let host = host ?? Domain.englishWikipedia
-            let baseComponents = ["", host, "v1"] // "" to get a leading /
+            let baseComponents = [host, "v1"] // "" to get a leading /
             var components = URLComponents()
             components.scheme = Scheme.http
             components.host = Domain.localhost
             components.port = 6927
-            return API(hostComponents: components, basePathComponents: baseComponents)
+            return APIURLComponentsBuilder(hostComponents: components, basePathComponents: baseComponents)
         default:
             var components = URLComponents()
             components.host = host ?? Domain.englishWikipedia
             components.scheme = Scheme.https
-            return API(hostComponents: components, basePathComponents: Path.mobileAppsServicesAPIComponents)
+            return APIURLComponentsBuilder(hostComponents: components, basePathComponents: Path.mobileAppsServicesAPIComponents)
         }
     }
     
-    @objc(mobileAppsServicesAPIURLForHost:appendingPathComponents:)
-    public func mobileAppsServicesAPIURLForHost(_ host: String? = nil, appending pathComponents: [String] = [""]) -> URL? {
-        let api = mobileAppsServicesAPIForHost(host)
-        return api.components(byAppending: pathComponents).url
+    func mediaWikiAPIURLComponentsBuilderForHost(_ host: String? = nil) -> APIURLComponentsBuilder {
+        var components = URLComponents()
+        components.host = host ?? Domain.englishWikipedia
+        components.scheme = Scheme.https
+        return APIURLComponentsBuilder(hostComponents: components, basePathComponents: Path.mediaWikiAPIComponents)
+    }
+    
+    @objc(mobileAppsServicesAPIURLComponentsForHost:appendingPathComponents:)
+    public func mobileAppsServicesAPIURLComponentsForHost(_ host: String? = nil, appending pathComponents: [String] = [""]) -> URLComponents {
+        let builder = mobileAppsServicesAPIURLComponentsBuilderForHost(host)
+        return builder.components(byAppending: pathComponents)
     }
     
+    @objc(mediaWikiAPIURLComponentsForHost:withQueryParameters:)
+    public func mediaWikiAPIURForHost(_ host: String? = nil, with queryParameters: [String: Any]?) -> URLComponents {
+        let builder = mediaWikiAPIURLComponentsBuilderForHost(host)
+        return builder.components(queryParameters: queryParameters)
+    }
+
     @objc public static let current: Configuration = {
         switch Stage.current {
         case .local:
diff --git a/WMF Framework/ReadingListsAPIController.swift b/WMF Framework/ReadingListsAPIController.swift
index ace9aa9a5b8..9be3fa66060 100644
--- a/WMF Framework/ReadingListsAPIController.swift	
+++ b/WMF Framework/ReadingListsAPIController.swift	
@@ -118,7 +118,7 @@ extension APIReadingListEntry {
 
 class ReadingListsAPIController: NSObject {
     public let session = Session.shared // eventually doesn't have to be the singleton
-    private let api = Configuration.current.mobileAppsServicesAPIForHost("en.wikipedia.org")
+    private let api = Configuration.current.mobileAppsServicesAPIURLComponentsBuilderForHost("en.wikipedia.org")
     private let basePathComponents = ["data", "lists"]
     
     private var pendingTasks: [String: Any] = [:]
@@ -153,10 +153,9 @@ class ReadingListsAPIController: NSObject {
 
     fileprivate func get<T>(path: [String], queryParameters: [String: Any]? = nil, completionHandler: @escaping (T?, URLResponse?, Error?) -> Swift.Void) where T : Codable {
         let key = UUID().uuidString
-        var components = api.components(byAppending: basePathComponents + path)
-        components.replacePercentEncodedQueryWithQueryParameters(queryParameters)
+        let components = api.components(byAppending: basePathComponents + path, queryParameters: queryParameters)
         guard
-            let task = session.jsonCodableTask(components: components, method: .get, completionHandler: { (result: T?, errorResult: APIReadingListErrorResponse?, response, error) in
+            let task = session.jsonCodableTask(with: components.url, method: .get, completionHandler: { (result: T?, errorResult: APIReadingListErrorResponse?, response, error) in
             if let errorResult = errorResult, let error = APIReadingListError(rawValue: errorResult.title) {
                 completionHandler(nil, nil, error)
             } else {
@@ -309,8 +308,8 @@ class ReadingListsAPIController: NSObject {
         let title = title.precomposedStringWithCanonicalMapping
         let project = project.precomposedStringWithCanonicalMapping
         let bodyParams = ["project": project, "title": title]
-        // trailing slash is required, server 404s otherwise
-        post(path: ["\(listID)", "entries/"], bodyParameters: bodyParams) { (result, response, error) in
+        // "" for trailing slash is required, server 404s otherwise
+        post(path: ["\(listID)", "entries", ""], bodyParameters: bodyParams) { (result, response, error) in
             if let apiError = error as? APIReadingListError {
                 switch apiError {
                 case .duplicateEntry:
@@ -541,8 +540,8 @@ class ReadingListsAPIController: NSObject {
         if let next = next {
             queryParameters = ["next": next]
         }
-        // trailing slash is required, server 404s otherwise
-        get(path: ["\(readingListID)", "entries/"], queryParameters: queryParameters) { (apiEntriesResponse: APIReadingListEntries?, response, error) in
+        // "" for trailing slash is required, server 404s otherwise
+        get(path: ["\(readingListID)", "entries", ""], queryParameters: queryParameters) { (apiEntriesResponse: APIReadingListEntries?, response, error) in
             guard let apiEntriesResponse = apiEntriesResponse else {
                 completion([], error)
                 return
diff --git a/WMF Framework/Remote Notifications/RemoteNotificationsAPIController.swift b/WMF Framework/Remote Notifications/RemoteNotificationsAPIController.swift
index a0c1b2043d0..9e72dfb8c42 100644
--- a/WMF Framework/Remote Notifications/RemoteNotificationsAPIController.swift	
+++ b/WMF Framework/Remote Notifications/RemoteNotificationsAPIController.swift	
@@ -160,7 +160,7 @@ struct RemoteNotificationsAPIController {
         var components = NotificationsAPI.components
         components.replacePercentEncodedQueryWithQueryParameters(queryParameters)
         if method == .get {
-            let _ = session.jsonDecodableTask(components: components, method: .get, completionHandler: completion)
+            let _ = session.jsonDecodableTask(with: components.url, method: .get, completionHandler: completion)
         } else {
             let _ = session.requestWithCSRF(type: CSRFTokenJSONDecodableOperation.self, components: components, method: method, bodyEncoding: .form, tokenContext: CSRFTokenOperation.TokenContext(tokenName: "token", tokenPlacement: .body), completion: completion)
         }
diff --git a/WMF Framework/URLComponents+Extensions.swift b/WMF Framework/URLComponents+Extensions.swift
index fc5e32582b1..8a9b8e58bae 100644
--- a/WMF Framework/URLComponents+Extensions.swift	
+++ b/WMF Framework/URLComponents+Extensions.swift	
@@ -46,4 +46,17 @@ extension URLComponents {
         }
         percentEncodedQuery = percentEncodedQueryStringFrom(queryParameters)
     }
+    
+    mutating func replacePercentEncodedPathWithPathComponents(_ pathComponents: [String]?) {
+        guard let pathComponents = pathComponents else {
+            percentEncodedPath = "/"
+            return
+        }
+        let characterSet = NSCharacterSet.wmf_URLPathComponentAllowed() ?? CharacterSet.urlPathAllowed
+        let encodedPathComponents = ([""] + pathComponents).compactMap { (component) -> String? in
+            assert(!component.contains("/"))
+            return component.addingPercentEncoding(withAllowedCharacters: characterSet)
+        }
+        percentEncodedPath = encodedPathComponents.joined(separator: "/") // NSString.path(with: components) removes the trailing slash that the reading list API needs
+    }
 }
diff --git a/WMF Framework/WMFAnnouncementsFetcher.m b/WMF Framework/WMFAnnouncementsFetcher.m
index ce1b1f1ced0..732a4a0146c 100644
--- a/WMF Framework/WMFAnnouncementsFetcher.m	
+++ b/WMF Framework/WMFAnnouncementsFetcher.m	
@@ -28,7 +28,7 @@ - (void)fetchAnnouncementsForURL:(NSURL *)siteURL force:(BOOL)force failure:(WMF
         return;
     }
 
-    NSURL *url = [WMFConfiguration.current mobileAppsServicesAPIURLForHost:siteURL.host appendingPathComponents:@[@"feed", @"announcements"]];
+    NSURL *url = [[WMFConfiguration.current mobileAppsServicesAPIURLComponentsForHost:siteURL.host appendingPathComponents:@[@"feed", @"announcements"]] URL];
     
     [self.session getJSONDictionaryFromURL:url ignoreCache:YES completionHandler:^(NSDictionary<NSString *,id> * _Nullable result, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
         if (error) {
diff --git a/WMF Framework/WMFOnThisDayEventsFetcher.m b/WMF Framework/WMFOnThisDayEventsFetcher.m
index 4ded426972c..cef14d0f238 100644
--- a/WMF Framework/WMFOnThisDayEventsFetcher.m	
+++ b/WMF Framework/WMFOnThisDayEventsFetcher.m	
@@ -40,9 +40,8 @@ - (void)fetchOnThisDayEventsForURL:(NSURL *)siteURL month:(NSUInteger)month day:
     NSString *monthString = [NSString stringWithFormat:@"%lu", (unsigned long)month];
     NSString *dayString = [NSString stringWithFormat:@"%lu", (unsigned long)day];
     NSArray<NSString *> *path = @[@"feed", @"onthisday", @"events", monthString, dayString];
-    NSURL *url = [WMFConfiguration.current mobileAppsServicesAPIURLForHost:siteURL.host appendingPathComponents:path];
-
-    [self.session getJSONDictionaryFromURL:url ignoreCache:YES completionHandler:^(NSDictionary<NSString *,id> * _Nullable result, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
+    NSURLComponents *components = [WMFConfiguration.current mobileAppsServicesAPIURLComponentsForHost:siteURL.host appendingPathComponents:path];
+    [self.session getJSONDictionaryFromURL:components.URL ignoreCache:YES completionHandler:^(NSDictionary<NSString *,id> * _Nullable result, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
         if (error) {
             failure(error);
             return;
diff --git a/Wikipedia/Code/MWKDataStore.m b/Wikipedia/Code/MWKDataStore.m
index d3dffa4e31a..dac67d1b1a4 100644
--- a/Wikipedia/Code/MWKDataStore.m
+++ b/Wikipedia/Code/MWKDataStore.m
@@ -1595,22 +1595,12 @@ - (void)updateLocalConfigurationFromRemoteConfigurationWithCompletion:(nullable
     };
 
     __block NSError *updateError = nil;
-    NSError *invalidRequestParametersError = [NSError wmf_errorWithType:WMFErrorTypeInvalidRequestParameters userInfo:nil];
     WMFTaskGroup *taskGroup = [[WMFTaskGroup alloc] init];
 
     // Site info
-    NSURL *siteInfoURL = [NSURL URLWithString:@"https://meta.wikimedia.org/w/api.php?action=query&format=json&meta=siteinfo"];
-    NSURLRequest *siteInfoRequest = [NSURLRequest requestWithURL:siteInfoURL];
-
+    NSURLComponents *components = [[WMFConfiguration current] mediaWikiAPIURLComponentsForHost:@"meta.wikimedia.org" withQueryParameters:@{@"action": @"query", @"format": @"json", @"meta": @"siteinfo"}];
     [taskGroup enter];
-    if (!siteInfoURL || !siteInfoRequest) {
-        updateError = invalidRequestParametersError;
-        [taskGroup leave];
-        return;
-    }
-
-    [[[WMFSession shared] jsonDictionaryTaskWith:siteInfoRequest
-                               completionHandler:^(NSDictionary<NSString *, id> *_Nullable siteInfo, NSURLResponse *_Nullable response, NSError *_Nullable error) {
+    [[WMFSession shared] getJSONDictionaryFromURL:components.URL ignoreCache:YES completionHandler:^(NSDictionary<NSString *, id> *_Nullable siteInfo, NSURLResponse *_Nullable response, NSError *_Nullable error) {
                                    dispatch_async(dispatch_get_main_queue(), ^{
                                        if (error) {
                                            updateError = error;
@@ -1622,20 +1612,11 @@ - (void)updateLocalConfigurationFromRemoteConfigurationWithCompletion:(nullable
                                        [self updateReadingListsLimits:readingListsConfig];
                                        [taskGroup leave];
                                    });
-                               }] resume];
+                               }];
     // Remote config
     NSURL *remoteConfigURL = [NSURL URLWithString:@"https://meta.wikimedia.org/static/current/extensions/MobileApp/config/ios.json"];
-    NSURLRequest *request = [NSURLRequest requestWithURL:remoteConfigURL];
-
     [taskGroup enter];
-    if (!remoteConfigURL || !request) {
-        updateError = invalidRequestParametersError;
-        [taskGroup leave];
-        return;
-    }
-
-    [[[WMFSession shared] jsonDictionaryTaskWith:request
-                               completionHandler:^(NSDictionary<NSString *, id> *_Nullable remoteConfigurationDictionary, NSURLResponse *_Nullable response, NSError *_Nullable error) {
+    [[WMFSession shared] getJSONDictionaryFromURL:remoteConfigURL ignoreCache:YES completionHandler:^(NSDictionary<NSString *, id> *_Nullable remoteConfigurationDictionary, NSURLResponse *_Nullable response, NSError *_Nullable error) {
                                    dispatch_async(dispatch_get_main_queue(), ^{
                                        if (error) {
                                            updateError = error;
@@ -1645,7 +1626,7 @@ - (void)updateLocalConfigurationFromRemoteConfigurationWithCompletion:(nullable
                                        [self updateLocalConfigurationFromRemoteConfiguration:remoteConfigurationDictionary];
                                        [taskGroup leave];
                                    });
-                               }] resume];
+                               }];
 
     [taskGroup waitInBackgroundWithCompletion:^{
         combinedCompletion(updateError);
diff --git a/Wikipedia/Code/NSDateFormatter+WMFExtensions.h b/Wikipedia/Code/NSDateFormatter+WMFExtensions.h
index 93c9aa465ae..0f7ce8d2beb 100644
--- a/Wikipedia/Code/NSDateFormatter+WMFExtensions.h
+++ b/Wikipedia/Code/NSDateFormatter+WMFExtensions.h
@@ -64,6 +64,8 @@
 
 + (instancetype)wmf_yearMonthDayZDateFormatter;
 
-+ (instancetype)wmf_yearMonthDayPathDateFormatter;
++ (instancetype)wmf_yearFormatter; // 1905
++ (instancetype)wmf_monthFormatter; // 05
++ (instancetype)wmf_dayFormatter; // 09
 
 @end
diff --git a/Wikipedia/Code/NSDateFormatter+WMFExtensions.m b/Wikipedia/Code/NSDateFormatter+WMFExtensions.m
index 2b0ade837c2..51d98d0eb72 100644
--- a/Wikipedia/Code/NSDateFormatter+WMFExtensions.m
+++ b/Wikipedia/Code/NSDateFormatter+WMFExtensions.m
@@ -226,15 +226,39 @@ + (instancetype)wmf_yearMonthDayZDateFormatter {
     return _dateFormatter;
 }
 
-+ (instancetype)wmf_yearMonthDayPathDateFormatter {
++ (instancetype)wmf_yearFormatter {
     static NSDateFormatter *_dateFormatter;
     static dispatch_once_t onceToken;
     dispatch_once(&onceToken, ^{
         _dateFormatter = [[NSDateFormatter alloc] init];
-        _dateFormatter.dateFormat = @"yyyy'/'MM'/'dd";
+        _dateFormatter.dateFormat = @"yyyy";
         _dateFormatter.locale = [NSLocale localeWithLocaleIdentifier:@"en"];
     });
     return _dateFormatter;
 }
 
++ (instancetype)wmf_monthFormatter {
+    static NSDateFormatter *_dateFormatter;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _dateFormatter = [[NSDateFormatter alloc] init];
+        _dateFormatter.dateFormat = @"MM";
+        _dateFormatter.locale = [NSLocale localeWithLocaleIdentifier:@"en"];
+    });
+    return _dateFormatter;
+}
+
+
++ (instancetype)wmf_dayFormatter {
+    static NSDateFormatter *_dateFormatter;
+    static dispatch_once_t onceToken;
+    dispatch_once(&onceToken, ^{
+        _dateFormatter = [[NSDateFormatter alloc] init];
+        _dateFormatter.dateFormat = @"dd";
+        _dateFormatter.locale = [NSLocale localeWithLocaleIdentifier:@"en"];
+    });
+    return _dateFormatter;
+}
+
+
 @end
diff --git a/Wikipedia/Code/Session.swift b/Wikipedia/Code/Session.swift
index cac0b907bf8..ec4f62cdab1 100644
--- a/Wikipedia/Code/Session.swift
+++ b/Wikipedia/Code/Session.swift
@@ -135,11 +135,7 @@ import Foundation
         return op
     }
 
-    public func request(components: URLComponents, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json) -> URLRequest? {
-        
-        guard let requestURL = components.url else {
-            return nil
-        }
+    public func request(with requestURL: URL, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json) -> URLRequest? {
         var request = URLRequest(url: requestURL)
         request.httpMethod = method.stringValue
         request.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
@@ -173,8 +169,11 @@ import Foundation
         return request
     }
     
-    public func jsonDictionaryTask(components: URLComponents, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, authorized: Bool? = nil, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Bool?, Error?) -> Swift.Void) -> URLSessionDataTask? {
-        guard let request = request(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding) else {
+    public func jsonDictionaryTask(with url: URL?, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, authorized: Bool? = nil, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Bool?, Error?) -> Swift.Void) -> URLSessionDataTask? {
+        guard let url = url else {
+            return nil
+        }
+        guard let request = request(with: url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding) else {
             return nil
         }
         return jsonDictionaryTask(with: request, completionHandler: { (result, response, error) in
@@ -182,8 +181,11 @@ import Foundation
         })
     }
     
-    public func dataTask(components: URLComponents, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask? {
-        guard let request = request(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding) else {
+    public func dataTask(with url: URL?, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask? {
+        guard let url = url else {
+            return nil
+        }
+        guard let request = request(with: url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding) else {
             return nil
         }
         return defaultURLSession.dataTask(with: request, completionHandler: completionHandler)
@@ -222,8 +224,8 @@ import Foundation
          - response: The URLResponse
          - error: Any network or parsing error
      */
-    public func jsonCodableTask<T, E>(components: URLComponents, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, completionHandler: @escaping (_ result: T?, _ errorResult: E?, _ response: URLResponse?, _ error: Error?) -> Swift.Void) -> URLSessionDataTask? where T : Decodable, E : Decodable {
-        guard let task = dataTask(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, completionHandler: { (data, response, error) in
+    public func jsonCodableTask<T, E>(with url: URL?, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, completionHandler: @escaping (_ result: T?, _ errorResult: E?, _ response: URLResponse?, _ error: Error?) -> Swift.Void) -> URLSessionDataTask? where T : Decodable, E : Decodable {
+        guard let task = dataTask(with: url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, completionHandler: { (data, response, error) in
             self.handleResponse(response)
             guard let data = data else {
                 completionHandler(nil, nil, response, error)
@@ -261,8 +263,8 @@ import Foundation
         return task
     }
 
-    public func jsonDecodableTask<T: Decodable>(components: URLComponents, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, authorized: Bool? = nil, completionHandler: @escaping (_ result: T?, _ response: URLResponse?,_ authorized: Bool?,  _ error: Error?) -> Swift.Void) {
-        guard let task = dataTask(components: components, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, completionHandler: { (data, response, error) in
+    public func jsonDecodableTask<T: Decodable>(with url: URL?, method: Session.Request.Method = .get, bodyParameters: Any? = nil, bodyEncoding: Session.Request.Encoding = .json, authorized: Bool? = nil, completionHandler: @escaping (_ result: T?, _ response: URLResponse?,_ authorized: Bool?,  _ error: Error?) -> Swift.Void) {
+        guard let task = dataTask(with: url, method: method, bodyParameters: bodyParameters, bodyEncoding: bodyEncoding, completionHandler: { (data, response, error) in
             self.handleResponse(response)
             guard let data = data else {
                 completionHandler(nil, response, authorized, error)
@@ -287,7 +289,7 @@ import Foundation
         queue.addOperation(op)
     }
     
-    @discardableResult @objc public func jsonDictionaryTask(with request: URLRequest, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask {
+    @discardableResult private func jsonDictionaryTask(with request: URLRequest, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask {
         return defaultURLSession.dataTask(with: request, completionHandler: { (data, response, error) in
             self.handleResponse(response)
             guard let data = data else {
@@ -307,42 +309,43 @@ import Foundation
         })
     }
     
-    @objc(getJSONDictionaryFromURL:ignoreCache:completionHandler:) public func getJSONDictionary(from url: URL?, ignoreCache: Bool, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Error?) -> Swift.Void) {
+    @objc(getJSONDictionaryFromURL:ignoreCache:completionHandler:)
+    public func getJSONDictionary(from url: URL?, ignoreCache: Bool, completionHandler: @escaping ([String: Any]?, HTTPURLResponse?, Error?) -> Swift.Void) {
         guard let url = url else {
             completionHandler(nil, nil, NSError.wmf_error(with: .invalidRequestParameters))
             return
         }
-        var request = URLRequest(url: url)
+        guard var request = self.request(with: url, method: .get) else {
+            completionHandler(nil, nil, NSError.wmf_error(with: .invalidRequestParameters))
+            return
+        }
         if ignoreCache {
             request.cachePolicy = .reloadIgnoringLocalCacheData
         }
         jsonDictionaryTask(with: request, completionHandler: completionHandler).resume()
     }
     
-    @discardableResult public func apiTask(with articleURL: URL, path: String, completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask? {
+    @discardableResult public func apiTask(with articleURL: URL, path: [String], completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) -> URLSessionDataTask? {
         guard let siteURL = articleURL.wmf_site, let title = articleURL.wmf_titleWithUnderscores else {
             // don't call the completion as this is just a method to get the task
             return nil
         }
-        let api = configuration.mobileAppsServicesAPIForHost(siteURL.host)
-        let encodedTitle = title.addingPercentEncoding(withAllowedCharacters: CharacterSet.wmf_urlPathComponentAllowed) ?? title
-        let pathComponents = api.basePathComponents + [path, encodedTitle]
-        let percentEncodedPath = pathComponents.joined(separator: "/") // NSString.path(with: components) removes the leading slash
-        var components = api.hostComponents
-        components.percentEncodedPath = percentEncodedPath
-        guard let summaryURL = components.url else {
+        let api = configuration.mobileAppsServicesAPIURLComponentsBuilderForHost(siteURL.host)
+        guard let summaryURL = api.components(byAppending: api.basePathComponents + path + [title]).url else {
             // don't call the completion as this is just a method to get the task
             return nil
         }
         
-        var request = URLRequest(url: summaryURL)
+        guard var request = self.request(with: summaryURL) else {
+            return nil
+        }
         //The accept profile is case sensitive https://gerrit.wikimedia.org/r/#/c/356429/
         request.setValue("application/json; charset=utf-8; profile=\"https://www.mediawiki.org/wiki/Specs/Summary/1.1.2\"", forHTTPHeaderField: "Accept")
         return jsonDictionaryTask(with: request, completionHandler: completionHandler)
     }
     
     @objc(fetchAPIPath:withArticleURL:priority:completionHandler:)
-    public func fetchAPI(path: String, with articleURL: URL, priority: Float = URLSessionTask.defaultPriority, completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) {
+    public func fetchAPI(path: [String], with articleURL: URL, priority: Float = URLSessionTask.defaultPriority, completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) {
         guard let task = apiTask(with: articleURL, path: path, completionHandler: completionHandler) else {
             completionHandler(nil, nil, NSError.wmf_error(with: .invalidRequestParameters))
             return
@@ -354,12 +357,12 @@ import Foundation
     
     @objc(fetchMediaForArticleURL:priority:completionHandler:)
     public func fetchMedia(for articleURL: URL, priority: Float = URLSessionTask.defaultPriority, completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) {
-        return fetchAPI(path: "page/media", with: articleURL, completionHandler: completionHandler)
+        return fetchAPI(path: ["page", "media"], with: articleURL, completionHandler: completionHandler)
     }
     
     @objc(fetchSummaryForArticleURL:priority:completionHandler:)
     public func fetchSummary(for articleURL: URL, priority: Float = URLSessionTask.defaultPriority, completionHandler: @escaping ([String: Any]?, URLResponse?, Error?) -> Swift.Void) {
-        return fetchAPI(path: "page/summary", with: articleURL, completionHandler: completionHandler)
+        return fetchAPI(path: ["page", "summary"], with: articleURL, completionHandler: completionHandler)
     }
     
     public func fetchArticleSummaryResponsesForArticles(withURLs articleURLs: [URL], priority: Float = URLSessionTask.defaultPriority, completion: @escaping ([String: [String: Any]]) -> Void) {
diff --git a/Wikipedia/Code/WKWebView+LoadAssetsHtml.swift b/Wikipedia/Code/WKWebView+LoadAssetsHtml.swift
index acad7c0b4dd..4df867d42c1 100644
--- a/Wikipedia/Code/WKWebView+LoadAssetsHtml.swift
+++ b/Wikipedia/Code/WKWebView+LoadAssetsHtml.swift
@@ -48,7 +48,7 @@ extension WKWebView {
         
         var siteCSSLink = ""
         if let host = baseURL.wmf_site?.host,
-            let cssURLString = Configuration.current.mobileAppsServicesAPIURLForHost(host, appending: ["data", "css", "mobile", "site"])?.absoluteString {
+            let cssURLString = Configuration.current.mobileAppsServicesAPIURLComponentsForHost(host, appending: ["data", "css", "mobile", "site"]).url?.absoluteString {
             siteCSSLink = """
             <link href="\(cssURLString)" rel="stylesheet" type="text/css"></link>
             """
diff --git a/Wikipedia/Code/WMFFeedContentFetcher.m b/Wikipedia/Code/WMFFeedContentFetcher.m
index f88e25d1049..d5725426e53 100644
--- a/Wikipedia/Code/WMFFeedContentFetcher.m
+++ b/Wikipedia/Code/WMFFeedContentFetcher.m
@@ -32,14 +32,21 @@ - (instancetype)init {
 }
 
 + (NSURL *)feedContentURLForSiteURL:(NSURL *)siteURL onDate:(NSDate *)date {
-    NSString *datePath = [[NSDateFormatter wmf_yearMonthDayPathDateFormatter] stringFromDate:date];
+    NSString *yearString = nil;
+    NSString *monthString = nil;
+    NSString *dayString = nil;
+    if (date) {
+        yearString = [[NSDateFormatter wmf_yearFormatter] stringFromDate:date];
+        monthString = [[NSDateFormatter wmf_monthFormatter] stringFromDate:date];
+        dayString = [[NSDateFormatter wmf_dayFormatter] stringFromDate:date];
+    }
     NSArray<NSString *> *path = nil;
-    if (datePath) {
-        path = @[@"feed", @"featured", datePath];
+    if (yearString && monthString && dayString) {
+        path = @[@"feed", @"featured", yearString, monthString, dayString];
     } else {
         path = @[@"feed", @"featured"];
     }
-    return [[WMFConfiguration current] mobileAppsServicesAPIURLForHost:siteURL.host appendingPathComponents:path];
+    return [[[WMFConfiguration current] mobileAppsServicesAPIURLComponentsForHost:siteURL.host appendingPathComponents:path] URL];
 }
 
 + (NSRegularExpression *)cacheControlRegex {
@@ -70,8 +77,8 @@ - (void)fetchFeedContentForURL:(NSURL *)siteURL date:(NSDate *)date force:(BOOL)
         return;
     }
 
-    NSURL *url = [[self class] feedContentURLForSiteURL:siteURL onDate:date];
-    [self.session getJSONDictionaryFromURL:url ignoreCache:NO completionHandler:^(NSDictionary<NSString *,id> * _Nullable jsonDictionary, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
+    NSURL *feedURL = [[self class] feedContentURLForSiteURL:siteURL onDate:date];
+    [self.session getJSONDictionaryFromURL:feedURL ignoreCache:NO completionHandler:^(NSDictionary<NSString *,id> * _Nullable jsonDictionary, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
         if (error) {
             failure(error);
             return;
@@ -144,9 +151,9 @@ - (void)fetchPageviewsForURL:(NSURL *)titleURL startDate:(NSDate *)startDate end
     
     NSString *domainPathComponent = [NSString stringWithFormat:@"%@.%@", language, domain];
     NSArray<NSString *> *path = @[@"metrics", @"pageviews", @"per-article", domainPathComponent, @"all-access", @"user", title, @"daily", startDateString, endDateString];
-    NSURL *url = [WMFConfiguration.current mobileAppsServicesAPIURLForHost:titleURL.wmf_siteURL.host appendingPathComponents:path];
+    NSURLComponents *components = [WMFConfiguration.current mobileAppsServicesAPIURLComponentsForHost:titleURL.wmf_siteURL.host appendingPathComponents:path];
     NSCalendar *calendar = [NSCalendar wmf_utcGregorianCalendar];
-    [self.session getJSONDictionaryFromURL:url ignoreCache:NO completionHandler:^(NSDictionary<NSString *,id> * _Nullable responseObject, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
+    [self.session getJSONDictionaryFromURL:components.URL ignoreCache:NO completionHandler:^(NSDictionary<NSString *,id> * _Nullable responseObject, NSHTTPURLResponse * _Nullable response, NSError * _Nullable error) {
         if (error) {
             failure(error);
             return;
