diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index c1bbcb48818..74b4ff7a978 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -26,6 +26,7 @@
 		041A3B5E18E11ED90079FF1C /* LanguagesCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 041A3B5918E11ED90079FF1C /* LanguagesCell.m */; };
 		041A3B6218E11ED90079FF1C /* LanguagesViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 041A3B5D18E11ED90079FF1C /* LanguagesViewController.m */; };
 		041C55D21950B27D006CE0EF /* EditSummaryViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 041C55D11950B27D006CE0EF /* EditSummaryViewController.m */; };
+		041C6206199ED2A20061516F /* Section+TOC.m in Sources */ = {isa = PBXBuildFile; fileRef = 041C6205199ED2A20061516F /* Section+TOC.m */; };
 		04224500197F5E09005DD0BF /* AbuseFilterAlert.m in Sources */ = {isa = PBXBuildFile; fileRef = 042244FC197F5E09005DD0BF /* AbuseFilterAlert.m */; };
 		04224501197F5E09005DD0BF /* BulletedLabel.m in Sources */ = {isa = PBXBuildFile; fileRef = 042244FE197F5E09005DD0BF /* BulletedLabel.m */; };
 		04224502197F5E09005DD0BF /* BulletedLabel.xib in Resources */ = {isa = PBXBuildFile; fileRef = 042244FF197F5E09005DD0BF /* BulletedLabel.xib */; };
@@ -223,6 +224,8 @@
 		041A3B5D18E11ED90079FF1C /* LanguagesViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LanguagesViewController.m; sourceTree = "<group>"; };
 		041C55D01950B27D006CE0EF /* EditSummaryViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EditSummaryViewController.h; sourceTree = "<group>"; };
 		041C55D11950B27D006CE0EF /* EditSummaryViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; lineEnding = 0; path = EditSummaryViewController.m; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objc; };
+		041C6204199ED2A20061516F /* Section+TOC.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "Section+TOC.h"; sourceTree = "<group>"; };
+		041C6205199ED2A20061516F /* Section+TOC.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "Section+TOC.m"; sourceTree = "<group>"; };
 		042244FB197F5E09005DD0BF /* AbuseFilterAlert.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbuseFilterAlert.h; sourceTree = "<group>"; };
 		042244FC197F5E09005DD0BF /* AbuseFilterAlert.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AbuseFilterAlert.m; sourceTree = "<group>"; };
 		042244FD197F5E09005DD0BF /* BulletedLabel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BulletedLabel.h; sourceTree = "<group>"; };
@@ -1208,6 +1211,8 @@
 				0472BC17193AD88C00C40BDA /* Section+DisplayHtml.m */,
 				04A81E8418871EB000EEBADB /* Section+ImageRecords.h */,
 				04A81E8518871EB000EEBADB /* Section+ImageRecords.m */,
+				041C6204199ED2A20061516F /* Section+TOC.h */,
+				041C6205199ED2A20061516F /* Section+TOC.m */,
 				047528B01913110000F2CDA8 /* Section+LeadSection.h */,
 				047528B11913110000F2CDA8 /* Section+LeadSection.m */,
 				047801BC18AE987900DBB747 /* UIButton+ColorMask.h */,
@@ -1982,6 +1987,7 @@
 				04C43AC0183442FC006C643B /* NSString+Extras.m in Sources */,
 				04CCCFEE1935093A00E3F60C /* SecondaryMenuRowView.m in Sources */,
 				0442F57B19006DCC00F55DF9 /* PageHistoryLabel.m in Sources */,
+				041C6206199ED2A20061516F /* Section+TOC.m in Sources */,
 				0447862F185145090050563B /* HistoryResultCell.m in Sources */,
 				04B0EA45190AFDD8007458AF /* ArticleImporter.m in Sources */,
 				042A5B2619253D2A0095E172 /* CenterNavController.m in Sources */,
diff --git a/wikipedia/Base.lproj/Main_iPhone.storyboard b/wikipedia/Base.lproj/Main_iPhone.storyboard
index 2f9eeb3e967..99dbe8f240e 100644
--- a/wikipedia/Base.lproj/Main_iPhone.storyboard
+++ b/wikipedia/Base.lproj/Main_iPhone.storyboard
@@ -97,24 +97,7 @@
                             <scrollView contentMode="scaleToFill" alwaysBounceVertical="YES" showsHorizontalScrollIndicator="NO" translatesAutoresizingMaskIntoConstraints="NO" id="sgu-W1-m18" userLabel="TOC Scroll View">
                                 <rect key="frame" x="0.0" y="0.0" width="320" height="504"/>
                                 <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                <subviews>
-                                    <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="VGj-z3-9mh" userLabel="Scroll Container">
-                                        <rect key="frame" x="0.0" y="0.0" width="320" height="768"/>
-                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
-                                        <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
-                                        <constraints>
-                                            <constraint firstAttribute="width" constant="320" placeholder="YES" id="A8D-SF-YFI"/>
-                                            <constraint firstAttribute="height" constant="768" placeholder="YES" id="E5c-CM-Mg4"/>
-                                        </constraints>
-                                    </view>
-                                </subviews>
                                 <color key="backgroundColor" red="0.047058828175067902" green="0.047058828175067902" blue="0.047058828175067902" alpha="1" colorSpace="deviceRGB"/>
-                                <constraints>
-                                    <constraint firstItem="VGj-z3-9mh" firstAttribute="leading" secondItem="sgu-W1-m18" secondAttribute="leading" id="jVV-fN-1Va"/>
-                                    <constraint firstAttribute="bottom" secondItem="VGj-z3-9mh" secondAttribute="bottom" id="jvc-8X-PKF"/>
-                                    <constraint firstAttribute="trailing" secondItem="VGj-z3-9mh" secondAttribute="trailing" id="lRf-aE-j7a"/>
-                                    <constraint firstItem="VGj-z3-9mh" firstAttribute="top" secondItem="sgu-W1-m18" secondAttribute="top" id="wUS-Kd-nWK"/>
-                                </constraints>
                             </scrollView>
                         </subviews>
                         <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
@@ -128,7 +111,6 @@
                     <freeformSimulatedSizeMetrics key="simulatedDestinationMetrics"/>
                     <size key="freeformSize" width="320" height="504"/>
                     <connections>
-                        <outlet property="scrollContainer" destination="VGj-z3-9mh" id="sBf-vm-TJH"/>
                         <outlet property="scrollView" destination="sgu-W1-m18" id="287-9B-G7M"/>
                     </connections>
                 </viewController>
@@ -1157,6 +1139,9 @@
                                 <rect key="frame" x="0.0" y="0.0" width="320" height="508"/>
                                 <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                 <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
+                                <constraints>
+                                    <constraint firstAttribute="height" constant="508" placeholder="YES" id="vpd-JA-MM4"/>
+                                </constraints>
                                 <dataDetectorType key="dataDetectorTypes"/>
                                 <connections>
                                     <outlet property="delegate" destination="vXZ-lx-hvc" id="Pmz-tr-TG8"/>
@@ -1216,7 +1201,6 @@
                             <constraint firstItem="WeL-Mj-Zsh" firstAttribute="leading" secondItem="gB8-UC-wuQ" secondAttribute="leading" id="TPG-uM-6qs"/>
                             <constraint firstItem="WeL-Mj-Zsh" firstAttribute="leading" secondItem="F4Q-Xc-ImV" secondAttribute="leading" id="akc-jF-1Pw"/>
                             <constraint firstAttribute="bottom" secondItem="F4Q-Xc-ImV" secondAttribute="bottom" placeholder="YES" id="bOy-uv-taw"/>
-                            <constraint firstAttribute="bottom" secondItem="WeL-Mj-Zsh" secondAttribute="bottom" id="myK-xK-1sX"/>
                             <constraint firstItem="gB8-UC-wuQ" firstAttribute="bottom" secondItem="kh9-bI-dsS" secondAttribute="bottom" id="nMr-wt-aMC"/>
                             <constraint firstItem="WeL-Mj-Zsh" firstAttribute="trailing" secondItem="gB8-UC-wuQ" secondAttribute="trailing" id="sLM-fO-nId"/>
                         </constraints>
diff --git a/wikipedia/Categories/Article+Convenience.m b/wikipedia/Categories/Article+Convenience.m
index 146b5b4b9c4..5b04e5c6324 100644
--- a/wikipedia/Categories/Article+Convenience.m
+++ b/wikipedia/Categories/Article+Convenience.m
@@ -35,24 +35,8 @@ -(NSArray *)getSectionImagesUsingContext:(NSManagedObjectContext *)context
 
 -(NSArray *)getSectionsUsingContext:(NSManagedObjectContext *)context
 {
-    NSPredicate * predicate = [NSPredicate predicateWithFormat:@"article == %@", self];
-    
-    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
-    NSEntityDescription *entity = [NSEntityDescription entityForName: @"Section"
-                                              inManagedObjectContext: context];
-    [fetchRequest setEntity:entity];
-    [fetchRequest setPredicate:predicate];
-    
-    // Sort by section.
-    NSSortDescriptor *sectionSort = [[NSSortDescriptor alloc] initWithKey:@"sectionId" ascending:YES selector:nil];
-    [fetchRequest setSortDescriptors:@[sectionSort]];
-    
-    NSError *error = nil;
-    NSArray *sections = [context executeFetchRequest:fetchRequest error:&error];
-    if (error) {
-        NSLog(@"error = %@", error);
-    }
-    return sections;
+    NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"sectionId" ascending:YES];
+    return [self.section sortedArrayUsingDescriptors:@[sort]];
 }
 
 -(UIImage *)getThumbnailUsingContext:(NSManagedObjectContext *)context
diff --git a/wikipedia/Categories/Section+TOC.h b/wikipedia/Categories/Section+TOC.h
new file mode 100644
index 00000000000..894852fa4a9
--- /dev/null
+++ b/wikipedia/Categories/Section+TOC.h
@@ -0,0 +1,10 @@
+//  Created by Monte Hurd on 8/15/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "Section.h"
+
+@interface Section (TOC)
+
+-(id)tocTitle;
+
+@end
diff --git a/wikipedia/Categories/Section+TOC.m b/wikipedia/Categories/Section+TOC.m
new file mode 100644
index 00000000000..5541b63f874
--- /dev/null
+++ b/wikipedia/Categories/Section+TOC.m
@@ -0,0 +1,54 @@
+//  Created by Monte Hurd on 8/15/14.
+//  Copyright (c) 2014 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
+
+#import "Section+TOC.h"
+#import "Section+LeadSection.h"
+#import "Article.h"
+#import "WikipediaAppUtils.h"
+#import "SessionSingleton.h"
+#import "NSString+FormattedAttributedString.h"
+#import "NSString+Extras.h"
+
+@implementation Section (TOC)
+
+-(id)tocTitle
+{
+    BOOL isLead = [self isLeadSection];
+    
+    NSString *title = isLead ? self.article.title : self.title;
+
+    NSString *noHtmlTitle = [title getStringWithoutHTML];
+
+    id titleToUse = isLead ? [self getLeadSectionAttributedTitleForString:noHtmlTitle] : noHtmlTitle;
+
+    return titleToUse;
+}
+
+-(NSAttributedString *)getLeadSectionAttributedTitleForString:(NSString *)string
+{
+    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
+    paragraphStyle.lineSpacing = 8;
+    
+    NSDictionary *contentsHeaderAttributes = @{
+                                    NSFontAttributeName : [UIFont boldSystemFontOfSize:10.5],
+                                    NSKernAttributeName : @(1.25),
+                                    NSParagraphStyleAttributeName : paragraphStyle
+                                    };
+    NSDictionary *sectionTitleAttributes = @{
+                                       NSFontAttributeName : [UIFont fontWithName:@"Times New Roman" size:24]
+                                       };
+    
+    NSString *heading = MWLocalizedString(@"table-of-contents-heading", nil);
+    
+    if ([[SessionSingleton sharedInstance].domain isEqualToString:@"en"]) {
+        heading = [heading uppercaseString];
+    }
+    
+    return [@"$1\n$2" attributedStringWithAttributes: @{}
+                                 substitutionStrings: @[heading, string]
+                              substitutionAttributes: @[contentsHeaderAttributes, sectionTitleAttributes]
+            ];
+    
+}
+
+@end
diff --git a/wikipedia/View Controllers/Navigation/Top/TopMenuViewController.m b/wikipedia/View Controllers/Navigation/Top/TopMenuViewController.m
index 94dcd6d9358..a641339237d 100644
--- a/wikipedia/View Controllers/Navigation/Top/TopMenuViewController.m	
+++ b/wikipedia/View Controllers/Navigation/Top/TopMenuViewController.m	
@@ -339,7 +339,7 @@ -(void)setupNavbarContainerSubviews
 
 -(id)getNavBarItem:(NavBarItemTag)tag
 {
-    for (UIView *view in self.navBarContainer.subviews) {
+    for (UIView *view in [self.navBarContainer.subviews copy]) {
         if (view.tag == tag) return view;
     }
     return nil;
diff --git a/wikipedia/View Controllers/TableOfContents/TOCSectionCellView.m b/wikipedia/View Controllers/TableOfContents/TOCSectionCellView.m
index 9bed049ca82..e6d56226f47 100644
--- a/wikipedia/View Controllers/TableOfContents/TOCSectionCellView.m	
+++ b/wikipedia/View Controllers/TableOfContents/TOCSectionCellView.m	
@@ -31,7 +31,7 @@ -(id)initWithLevel:(NSInteger)level isLead:(BOOL)isLead isRTL:(BOOL)isRTL
         self.isSelected = NO;
         self.isHighlighted = NO;
         self.clipsToBounds = NO;
-        self.opaque = NO;
+        self.opaque = YES;
         self.level = level;
         self.isLead = isLead;
         self.isRTL = isRTL;
@@ -100,4 +100,11 @@ - (void)drawRect:(CGRect)rect {
     }
 }
 
+/*
+-(void)dealloc
+{
+    NSLog(@"DEALLOC'ING toc section cell!");
+}
+*/
+
 @end
diff --git a/wikipedia/View Controllers/TableOfContents/TOCViewController.h b/wikipedia/View Controllers/TableOfContents/TOCViewController.h
index 835aaefd234..93445716d93 100644
--- a/wikipedia/View Controllers/TableOfContents/TOCViewController.h	
+++ b/wikipedia/View Controllers/TableOfContents/TOCViewController.h	
@@ -14,6 +14,9 @@
 
 @property (weak, nonatomic) WebViewController *webVC;
 
-@property (strong, nonatomic) ToCInteractionFunnel *funnel;
+-(void)setTocSectionDataForSections:(NSSet *)sections;
+
+-(void)willShow;
+-(void)didHide;
 
 @end
diff --git a/wikipedia/View Controllers/TableOfContents/TOCViewController.m b/wikipedia/View Controllers/TableOfContents/TOCViewController.m
index 8bcf97bb34f..d0838d00b7b 100644
--- a/wikipedia/View Controllers/TableOfContents/TOCViewController.m	
+++ b/wikipedia/View Controllers/TableOfContents/TOCViewController.m	
@@ -2,37 +2,30 @@
 //  Copyright (c) 2013 Wikimedia Foundation. Provided under MIT-style license; please copy and modify!
 
 #import "TOCViewController.h"
-#import "ArticleDataContextSingleton.h"
-#import "NSManagedObjectContext+SimpleFetch.h"
-#import "ArticleCoreDataObjects.h"
-#import "Article+Convenience.h"
 #import "TOCSectionCellView.h"
 #import "WebViewController.h"
 #import "UIWebView+ElementLocation.h"
-#import "UIView+Debugging.h"
-#import "SessionSingleton.h"
 #import "UIView+RemoveConstraints.h"
 #import "WikipediaAppUtils.h"
 #import "Section+LeadSection.h"
-#import "NSString+FormattedAttributedString.h"
-#import "NSString+Extras.h"
+#import "Section+TOC.h"
+//#import "UIView+Debugging.h"
 
-#define TOC_SECTION_MARGIN 0 //(1.0f / [UIScreen mainScreen].scale)
 #define TOC_SELECTION_OFFSET_Y 48.0f
-#define TOC_DELAY_BETWEEN_SELECTION_AND_ZOOM 0.35f
-#define TOC_TAG_OTHER_LANGUAGES 9999
-
-#define TOC_SELECTION_SCROLL_DURATION 0.2
-
-#define TOC_SUBSECTION_INDENT 6 //15
+#define TOC_SELECTION_SCROLL_DURATION 0.23
+#define TOC_SUBSECTION_INDENT 6
 
 @interface TOCViewController (){
 
 }
 
-@property (strong, nonatomic) NSMutableArray *sectionCells;
+@property (strong, nonatomic) NSArray *sectionCells;
+
+@property (strong, nonatomic) UIView *scrollContainer;
 
-@property (strong, nonatomic) IBOutlet UIView *scrollContainer;
+@property (strong, nonatomic) NSArray *tocSectionData;
+
+@property (strong, nonatomic) ToCInteractionFunnel *funnel;
 
 @end
 
@@ -40,30 +33,33 @@ @implementation TOCViewController
 
 #pragma mark View lifecycle
 
+- (instancetype)initWithCoder:(NSCoder *)coder
+{
+    self = [super initWithCoder:coder];
+    if (self) {
+        self.tocSectionData = @[];
+        self.sectionCells = @[];
+    }
+    return self;
+}
+
 - (void)viewDidLoad
 {
     [super viewDidLoad];
     // Do any additional setup after loading the view.
     
-    self.funnel = [[ToCInteractionFunnel alloc] init];
+    self.view.hidden = YES;
 
-    self.sectionCells = @[].mutableCopy;
+    self.funnel = [[ToCInteractionFunnel alloc] init];
 
     self.scrollView.showsHorizontalScrollIndicator = NO;
     self.scrollView.showsVerticalScrollIndicator = NO;
 
-    self.view.translatesAutoresizingMaskIntoConstraints = NO;
-
+    self.scrollContainer = nil;
     self.navigationItem.hidesBackButton = YES;
 
     UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tocTapped:)];
     [self.view addGestureRecognizer:tap];
-
-    [self constrainScrollContainerWidth];
-    
-    self.scrollContainer.translatesAutoresizingMaskIntoConstraints = NO;
-
-    self.scrollContainer.backgroundColor = [UIColor clearColor];
     
     // Adjust scrollview content inset when contentSize changes so bottom entry can be scrolled to top.
     [self.scrollView addObserver: self
@@ -71,7 +67,6 @@ - (void)viewDidLoad
                          options: NSKeyValueObservingOptionNew|NSKeyValueObservingOptionInitial
                          context: nil];
 
-    [self refreshForCurrentArticle];
 }
 
 - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView
@@ -80,18 +75,36 @@ - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView
     return YES;
 }
 
--(void)viewWillDisappear:(BOOL)animated
+-(void)didHide
 {
     [self.funnel logClose];
-
+    
+    self.scrollView.scrollsToTop = NO;
     self.webVC.webView.scrollView.scrollsToTop = YES;
-
-    [super viewWillDisappear:animated];
+    
+    self.view.hidden = YES;
 }
 
--(void)viewDidAppear:(BOOL)animated
+-(void)willShow
 {
-    [super viewDidAppear:animated];
+    self.view.hidden = NO;
+    
+    // First set offset to zero - needed if toc opened and devices rotates causing toc
+    // to close. If the toc is then opened in new orientation (and the toc had lots of
+    // items and one near the end had been selected) it has trouble moving the selected
+    // section to the top if offset not zeroed out first.
+    self.scrollView.contentOffset = CGPointZero;
+
+    // Ensure cell ancestor views are sized to whatever width the toc happens to be.
+    [self.view setNeedsLayout];
+    [self.scrollView setNeedsLayout];
+    [self.scrollContainer setNeedsLayout];
+    [self.view layoutIfNeeded];
+    // Ensure the cells are sized to whatever width the toc happens to be.
+    [[self.sectionCells copy] makeObjectsPerformSelector:@selector(layoutIfNeeded)];
+
+    // Now move selected item to top.
+    [self centerCellForWebViewTopMostSectionAnimated:NO];
 
     self.scrollView.scrollsToTop = YES;
     self.webVC.webView.scrollView.scrollsToTop = NO;
@@ -103,122 +116,124 @@ -(void)viewDidAppear:(BOOL)animated
 
 -(void)refreshForCurrentArticle
 {
-    self.scrollView.delegate = nil;
+    //NSLog(@"%f", CACurrentMediaTime() - begin);
 
-    [self.scrollContainer.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
+    self.scrollView.delegate = nil;
 
-    [self.sectionCells removeAllObjects];
+    // Set up the scrollContainer fresh every time!
+    [self setupScrollContainer];
 
     [self setupSectionCells];
-
-    for (TOCSectionCellView *cell in self.sectionCells) {
+    
+    for (TOCSectionCellView *cell in [self.sectionCells copy]) {
         [self.scrollContainer addSubview:cell];
     }
+    
+    // Ensure the scrollContainer is scrolled to the top before its sub-views are constrained.
+    self.scrollView.contentOffset = CGPointMake(0, 0);
 
-    if (self.sectionCells.count == 0) return;
+    [self.view setNeedsUpdateConstraints];
     
     // Don't start monitoring scrollView scrolling until view has appeared.
     self.scrollView.delegate = self;
+
+    //CFTimeInterval begin = CACurrentMediaTime();
 }
 
--(void)setupSectionCells
+-(void)setupScrollContainer
 {
-    NSString *currentArticleTitle = [SessionSingleton sharedInstance].currentArticleTitle;
-    NSString *currentArticleDomain = [SessionSingleton sharedInstance].currentArticleDomain;
-    if(currentArticleTitle && currentArticleDomain) {
-        ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
-        [articleDataContext_.mainContext performBlockAndWait:^{
-            NSManagedObjectID *articleID = [articleDataContext_.mainContext getArticleIDForTitle: currentArticleTitle
-                                                                                          domain: currentArticleDomain];
-
-            BOOL isRTL = [WikipediaAppUtils isDeviceLanguageRTL];
-
-            if (articleID) {
-                Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
-                if (article) {
-                    // Get section ids.
-                    NSArray *sections = [article getSectionsUsingContext:articleDataContext_.mainContext];
-                    for (Section *section in sections) {
-                        
-                        NSNumber *tag = section.sectionId;
-                        NSNumber *isLead = @([section isLeadSection]);
-                        NSNumber *sectionLevel = section.tocLevel;
-                        id title = [self getTitleForSection:section];
-                        UIEdgeInsets padding = UIEdgeInsetsZero;
-                        
-                        TOCSectionCellView *cell = [[TOCSectionCellView alloc] initWithLevel:sectionLevel.integerValue isLead:isLead.boolValue isRTL:isRTL];
-                        
-                        if (isLead.boolValue) {
-                            // Use attributed title only for lead section to add "CONTENTS" text above the title.
-                            cell.attributedText = title;
-
-                            CGFloat topPadding = 37;
-                            CGFloat leadingPadding = 12;
-                            CGFloat bottomPadding = 14;
-                            CGFloat trailingPadding = 10;
-
-                            padding = UIEdgeInsetsMake(topPadding, leadingPadding, bottomPadding, trailingPadding);
-                            
-                        }else{
-                            // Faster to not use attributed string for non-lead sections.
-                            cell.text = title;
-
-                            // Indent subsections, but only first 3 levels.
-                            NSInteger tocLevelToUse = ((sectionLevel.integerValue - 1) < 0) ? 0 : sectionLevel.integerValue - 1;
-                            tocLevelToUse = MIN(tocLevelToUse, 3);
-                            CGFloat indent = TOC_SUBSECTION_INDENT;
-                            indent = 12 + (tocLevelToUse * indent);
-
-                            CGFloat vPadding = 16;
-                            CGFloat hPadding = 10;
-
-                            padding = UIEdgeInsetsMake(vPadding, indent, vPadding, hPadding);
-
-                        }
-                        cell.padding = padding;
-                        cell.tag = tag.integerValue;
-                        
-                        [self.sectionCells addObject:cell];
-                    }
-                }
-            }
-        }];
+    if (self.scrollContainer) {
+        [self.scrollContainer removeConstraintsOfViewFromView:self.scrollContainer.superview];
+        [self.scrollContainer removeFromSuperview];
     }
+
+    self.scrollContainer = [[UIView alloc] init];
+    self.scrollContainer.translatesAutoresizingMaskIntoConstraints = NO;
+    self.scrollContainer.opaque = YES;
+
+    NSDictionary *views = @{@"scrollContainer": self.scrollContainer};
+    [self.scrollView addSubview:self.scrollContainer];
+    
+    [self.scrollContainer.superview addConstraints:
+     [NSLayoutConstraint constraintsWithVisualFormat: @"H:|[scrollContainer]|"
+                                             options: 0
+                                             metrics: nil
+                                               views: views]];
+
+    [self.scrollContainer.superview addConstraints:
+     [NSLayoutConstraint constraintsWithVisualFormat: @"V:|[scrollContainer]|"
+                                             options: 0
+                                             metrics: nil
+                                               views: views]];
+    
+    // "constant" is -1.0 to ensure the container width never exceeds the scroll view's width.
+    // This prevents horizontal scrolling within the toc.
+    [self.scrollContainer.superview addConstraint:
+     [NSLayoutConstraint constraintWithItem: self.scrollContainer
+                                  attribute: NSLayoutAttributeWidth
+                                  relatedBy: NSLayoutRelationEqual
+                                     toItem: self.scrollContainer.superview
+                                  attribute: NSLayoutAttributeWidth
+                                 multiplier: 1.0
+                                   constant: -(1.0f / [UIScreen mainScreen].scale)]];
 }
 
--(id)getTitleForSection:(Section *)section
+-(void)updateViewConstraints
 {
-    NSString *title = [section isLeadSection] ? section.article.title : section.title;
-    NSString *noHtmlTitle = [title getStringWithoutHTML];
-    id titleToUse = [section isLeadSection] ? [self getLeadSectionAttributedTitleForString:noHtmlTitle] : noHtmlTitle;
-    return titleToUse;
+    [super updateViewConstraints];
+    [self constrainSectionCells];
 }
 
--(NSAttributedString *)getLeadSectionAttributedTitleForString:(NSString *)string
+-(void)setupSectionCells
 {
-    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
-    paragraphStyle.lineSpacing = 8;
-    
-    NSDictionary *contentsHeaderAttributes = @{
-                                    NSFontAttributeName : [UIFont boldSystemFontOfSize:10.5],
-                                    NSKernAttributeName : @(1.25),
-                                    NSParagraphStyleAttributeName : paragraphStyle
-                                    };
-    NSDictionary *sectionTitleAttributes = @{
-                                       NSFontAttributeName : [UIFont fontWithName:@"Times New Roman" size:24]
-                                       };
-    
-    NSString *heading = MWLocalizedString(@"table-of-contents-heading", nil);
-    
-    if ([[SessionSingleton sharedInstance].domain isEqualToString:@"en"]) {
-        heading = [heading uppercaseString];
+    NSMutableArray *allCells = @[].mutableCopy;
+
+    BOOL isRTL = [WikipediaAppUtils isDeviceLanguageRTL];
+
+    for (NSDictionary *sectionData in [self.tocSectionData copy]) {
+        
+        NSNumber *tag = sectionData[@"id"];
+        NSNumber *isLeadNumber = sectionData[@"isLead"];
+        BOOL isLead = isLeadNumber.boolValue;
+        NSNumber *sectionLevel = sectionData[@"level"];
+        id title = sectionData[@"title"];
+        
+        UIEdgeInsets padding = UIEdgeInsetsZero;
+        
+        TOCSectionCellView *cell = [[TOCSectionCellView alloc] initWithLevel:sectionLevel.integerValue isLead:isLead isRTL:isRTL];
+        
+        if (isLead) {
+            // Use attributed title only for lead section to add "CONTENTS" text above the title.
+            cell.attributedText = title;
+            
+            CGFloat topPadding = 37;
+            CGFloat leadingPadding = 12;
+            CGFloat bottomPadding = 14;
+            CGFloat trailingPadding = 10;
+            
+            padding = UIEdgeInsetsMake(topPadding, leadingPadding, bottomPadding, trailingPadding);
+            
+        }else{
+            // Faster to not use attributed string for non-lead sections.
+            cell.text = title;
+            
+            // Indent subsections, but only first 3 levels.
+            NSInteger tocLevelToUse = ((sectionLevel.integerValue - 1) < 0) ? 0 : sectionLevel.integerValue - 1;
+            tocLevelToUse = MIN(tocLevelToUse, 3);
+            CGFloat indent = TOC_SUBSECTION_INDENT;
+            indent = 12 + (tocLevelToUse * indent);
+            
+            CGFloat vPadding = 16;
+            CGFloat hPadding = 10;
+            
+            padding = UIEdgeInsetsMake(vPadding, indent, vPadding, hPadding);
+        }
+        cell.padding = padding;
+        cell.tag = tag.integerValue;
+        
+        [allCells addObject:cell];
     }
-    
-    return [@"$1\n$2" attributedStringWithAttributes: @{}
-                                 substitutionStrings: @[heading, string]
-                              substitutionAttributes: @[contentsHeaderAttributes, sectionTitleAttributes]
-            ];
-    
+    self.sectionCells = allCells;
 }
 
 #pragma mark Hide
@@ -275,7 +290,7 @@ -(void)scrollWebViewToSectionForCell: (TOCSectionCellView *)cell
 
 -(void)deSelectAllCells
 {
-    for (TOCSectionCellView *cell in self.sectionCells) {
+    for (TOCSectionCellView *cell in [self.sectionCells copy]) {
         // In case other non-TOCSectionCellView views are tacked beneath the TOCSectionCellView's...
         if (![cell isMemberOfClass:[TOCSectionCellView class]]) continue;
         cell.isSelected = NO;
@@ -284,7 +299,7 @@ -(void)deSelectAllCells
 
 -(void)unHighlightAllCells
 {
-    for (TOCSectionCellView *cell in self.sectionCells) {
+    for (TOCSectionCellView *cell in [self.sectionCells copy]) {
         // In case other non-TOCSectionCellView views are tacked beneath the TOCSectionCellView's...
         if (![cell isMemberOfClass:[TOCSectionCellView class]]) continue;
         cell.isHighlighted = NO;
@@ -301,7 +316,7 @@ - (void)scrollViewDidScroll:(UIScrollView *)scrollView
     //BOOL pastFocalCell = NO;
 
     if (scrollView == self.scrollView) {
-        for (TOCSectionCellView *cell in self.sectionCells) {
+        for (TOCSectionCellView *cell in [self.sectionCells copy]) {
 
             // In case other non-TOCSectionCellView views are tacked beneath the TOCSectionCellView's...
             if (![cell isMemberOfClass:[TOCSectionCellView class]]) continue;
@@ -354,7 +369,7 @@ -(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{
 
 - (void)scrollViewScrollingEnded:(UIScrollView *)scrollView
 {
-    for (TOCSectionCellView *cell in self.sectionCells) {
+    for (TOCSectionCellView *cell in [self.sectionCells copy]) {
         if (cell.isSelected) {
 
             [self scrollWebViewToSectionForCell: cell
@@ -369,38 +384,15 @@ -(void)centerCellForWebViewTopMostSectionAnimated:(BOOL)animated
 {
     if (!self.scrollView.isDragging) {
         [self updateHighlightedCellToReflectWebView];
-        [self scrollHighlightedCellToSelectionLineWithDuration:(animated ? 0.2f : 0.0f)];
+        [self scrollHighlightedCellToSelectionLineWithDuration:(animated ? TOC_SELECTION_SCROLL_DURATION : 0.0f)];
     }
 }
 
-#pragma mark Constraints
-
--(void)constrainScrollContainerWidth
-{
-    [self.scrollContainer.superview addConstraint:
-     [NSLayoutConstraint constraintWithItem: self.scrollContainer
-                                  attribute: NSLayoutAttributeWidth
-                                  relatedBy: NSLayoutRelationEqual
-                                     toItem: self.scrollContainer.superview
-                                  attribute: NSLayoutAttributeWidth
-                                 multiplier: 1.0
-                                   constant: -(1.0f / [UIScreen mainScreen].scale)]];
-    // "constant" is -1.0 to ensure the container width never exceeds the scroll view's width.
-    // This prevents horizontal scrolling within the toc.
-}
-
--(void)updateViewConstraints
-{
-    [super updateViewConstraints];
-
-    [self constrainSectionCells];
-}
-
 #pragma mark Highlighted cell
 
 -(TOCSectionCellView *)getHighlightedCell
 {
-    for (TOCSectionCellView *cell in self.sectionCells) {
+    for (TOCSectionCellView *cell in [self.sectionCells copy]) {
         if (cell.isSelected) return cell;
     }
     return nil;
@@ -442,7 +434,7 @@ -(CGFloat)offsetFromSelectionLineForView:(UIView *)view
     // gap from being left between the top of the screen and the selected cell. Would need to change
     // this to actually take the value from [self getSelectionLine] into account if the selection
     // is ever moved from near the top of the screen.
-    return view.frame.origin.y - self.scrollView.contentOffset.y - TOC_SECTION_MARGIN /*- [self getSelectionLine]*/;
+    return view.frame.origin.y - self.scrollView.contentOffset.y /*- [self getSelectionLine]*/;
 }
 
 #pragma mark Scroll limits
@@ -474,13 +466,15 @@ -(void)setScrollViewContentOffset: (CGPoint)contentOffset
 
 -(void)insetToRestrictScrollingTopAndBottomCellsPastCenter
 {
+    if (!self.scrollContainer || (self.scrollContainer.subviews.count == 0)) return;
+
     // Make it so the last TOCSectionCellView can't scroll off top of screen.
     // Assumes a TOCSectionCellView cells come at end.
     UIView *lastView = self.scrollContainer.subviews.lastObject;
 
     // Don't report scrolling when changing inset.
     self.scrollView.delegate = nil;
-    CGFloat insetAmount = self.scrollView.bounds.size.height - lastView.bounds.size.height - (TOC_SECTION_MARGIN * 2.0f);
+    CGFloat insetAmount = self.scrollView.bounds.size.height - lastView.bounds.size.height;
 
     UIEdgeInsets inset = UIEdgeInsetsMake(
         0,
@@ -548,40 +542,73 @@ - (void)didReceiveMemoryWarning
 
 -(void)constrainSectionCells
 {
+    //CFTimeInterval begin = CACurrentMediaTime();
+    if (self.sectionCells.count == 0) return;
 
-//TODO: possibly have these constraints, but also a set which positions cells offscreen, that way
-// they can be animated between?
-
-    [self.scrollContainer removeConstraints:self.scrollContainer.constraints];
-    
-    void (^constrain)(UIView *, NSLayoutAttribute, UIView *, NSLayoutAttribute, CGFloat) = ^void(UIView *view1, NSLayoutAttribute a1, UIView *view2, NSLayoutAttribute a2, CGFloat constant) {
-        [self.scrollContainer addConstraint:
-         [NSLayoutConstraint constraintWithItem: view1
+    NSLayoutConstraint *(^getConstraint)(UIView *, NSLayoutAttribute, UIView *, NSLayoutAttribute, CGFloat) = ^NSLayoutConstraint *(UIView *view1, NSLayoutAttribute a1, UIView *view2, NSLayoutAttribute a2, CGFloat constant) {
+         return [NSLayoutConstraint constraintWithItem: view1
                                       attribute: a1
                                       relatedBy: NSLayoutRelationEqual
                                          toItem: view2
                                       attribute: a2
                                      multiplier: 1.0
-                                       constant: constant]];
+                                       constant: constant];
     };
 
+    CGFloat scale = (1.0f / [UIScreen mainScreen].scale);
+    NSMutableArray *newConstraints = @[].mutableCopy;
     UIView *prevCell = nil;
-    for (UIView *cell in self.sectionCells) {
-        constrain(cell, NSLayoutAttributeLeft, self.scrollContainer, NSLayoutAttributeLeft, 0.0f);
-        constrain(cell, NSLayoutAttributeRight, self.scrollContainer, NSLayoutAttributeRight, (1.0f / [UIScreen mainScreen].scale));
+    for (UIView *cell in [self.sectionCells copy]) {
+        [newConstraints addObject:getConstraint(cell, NSLayoutAttributeLeft, self.scrollContainer, NSLayoutAttributeLeft, 0.0f)];
+        [newConstraints addObject:getConstraint(cell, NSLayoutAttributeRight, self.scrollContainer, NSLayoutAttributeRight, scale)];
         if (self.sectionCells.firstObject == cell) {
-            constrain(cell, NSLayoutAttributeTop, self.scrollContainer, NSLayoutAttributeTop, TOC_SECTION_MARGIN);
+            [newConstraints addObject:getConstraint(cell, NSLayoutAttributeTop, self.scrollContainer, NSLayoutAttributeTop, 0.0f)];
         }
         if (self.sectionCells.lastObject == cell) {
-            constrain(cell, NSLayoutAttributeBottom, self.scrollContainer, NSLayoutAttributeBottom, -TOC_SECTION_MARGIN);
+            [newConstraints addObject:getConstraint(cell, NSLayoutAttributeBottom, self.scrollContainer, NSLayoutAttributeBottom, 0.0f)];
         }
         if (prevCell) {
-            constrain(cell, NSLayoutAttributeTop, prevCell, NSLayoutAttributeBottom, TOC_SECTION_MARGIN);
+            [newConstraints addObject:getConstraint(cell, NSLayoutAttributeTop, prevCell, NSLayoutAttributeBottom, 0.0f)];
         }
         prevCell = cell;
     }
+
+    if (newConstraints.count > 0) {
+        [self.scrollContainer addConstraints:newConstraints];
+    }
+
+    //NSLog(@"%f", CACurrentMediaTime() - begin);
 }
 
+-(void)setTocSectionDataForSections:(NSSet *)sections
+{
+    // Keeps self.tocSectionData updated with toc data for the current article.
+    // Makes it so the toc data is ready to go as soon as the article is displayed
+    // so we don't have to go back though core data to get it when user taps toc
+    // button. MUCH faster.
+    NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"sectionId" ascending:YES];
+    NSArray *sortedSection = [sections sortedArrayUsingDescriptors:@[sort]];
+
+    NSMutableArray *allSectionData = @[].mutableCopy;
+    for (Section *section in [sortedSection copy]) {
+    
+        NSString *title = [section tocTitle];
+        if (!section.sectionId || !section.tocLevel || !title) continue;
+
+        NSDictionary *sectionDict =
+        @{
+          @"id": section.sectionId,
+          @"isLead": @([section isLeadSection]),
+          @"level": section.tocLevel,
+          @"title": title
+        };
+        
+        [allSectionData addObject:sectionDict];
+
+    }
+    self.tocSectionData = allSectionData;
+    [self refreshForCurrentArticle];
+}
 
 /*
 #pragma mark - Navigation
diff --git a/wikipedia/View Controllers/WebView/WebViewController.m b/wikipedia/View Controllers/WebView/WebViewController.m
index 7cb4987ef65..0a4a3ca18cc 100644
--- a/wikipedia/View Controllers/WebView/WebViewController.m	
+++ b/wikipedia/View Controllers/WebView/WebViewController.m	
@@ -52,11 +52,25 @@
 #import "WikiGlyph_Chars.h"
 #import "UINavigationController+TopActionSheet.h"
 #import "ReferencesVC.h"
+#import "WMF_Colors.h"
 
 //#import "UIView+Debugging.h"
 
 #define TOC_TOGGLE_ANIMATION_DURATION @0.225f
 
+#define SCROLL_INDICATOR_LEFT_MARGIN 2.0
+#define SCROLL_INDICATOR_WIDTH 4.0
+#define SCROLL_INDICATOR_HEIGHT 25.0
+#define SCROLL_INDICATOR_CORNER_RADIUS 2.0f
+#define SCROLL_INDICATOR_BORDER_WIDTH 1.0f
+#define SCROLL_INDICATOR_BORDER_COLOR [UIColor lightGrayColor]
+#define SCROLL_INDICATOR_BACKGROUND_COLOR [UIColor whiteColor]
+
+// This controls how fast the swipe has to be (side-to-side).
+#define TOC_SWIPE_TRIGGER_MIN_X_VELOCITY 600.0f
+// This controls what angle from the horizontal axis will trigger the swipe.
+#define TOC_SWIPE_TRIGGER_MAX_ANGLE 45.0f
+
 typedef enum {
     DISPLAY_LEAD_SECTION = 0,
     DISPLAY_APPEND_NON_LEAD_SECTIONS = 1,
@@ -83,10 +97,15 @@ @interface WebViewController (){
 
 @property (weak, nonatomic) IBOutlet NSLayoutConstraint *webViewLeftConstraint;
 @property (weak, nonatomic) IBOutlet NSLayoutConstraint *webViewRightConstraint;
+@property (strong, nonatomic) NSLayoutConstraint *webViewHeightConstraint;
+
+@property (strong, nonatomic) UIView *scrollIndicatorView;
+@property (strong, nonatomic) NSLayoutConstraint *scrollIndicatorViewTopConstraint;
+@property (strong, nonatomic) NSLayoutConstraint *scrollIndicatorViewHeightConstraint;
 
 @property (strong, nonatomic) TOCViewController *tocVC;
-@property (strong, nonatomic) UISwipeGestureRecognizer *tocSwipeLeftRecognizer;
-@property (strong, nonatomic) UISwipeGestureRecognizer *tocSwipeRightRecognizer;
+
+@property (strong, nonatomic) UIPanGestureRecognizer* panSwipeRecognizer;
 
 @property (strong, nonatomic) IBOutlet PaddedLabel *zeroStatusLabel;
 
@@ -140,11 +159,45 @@ - (UIStatusBarAnimation)preferredStatusBarUpdateAnimation
 
 #pragma mark View lifecycle methods
 
+-(void)constrainWebViewHeight
+{
+    // It's important that the web view height be constrained to a multiple of the
+    // self.view's height and that this constraint not be changed - especially during
+    // toc show/hide animations. The height is fixed rather than being constrained to
+    // the bottom of self.view so the web view content doesn't shift around when the
+    // toc is revealed/hidden. This was especially problematic when toggling the toc
+    // when near the bottom of an article.
+    CGFloat heightMultiple = 3.0f;
+
+    self.webViewHeightConstraint = [NSLayoutConstraint constraintWithItem: self.webView
+                                                                attribute: NSLayoutAttributeHeight
+                                                                relatedBy: NSLayoutRelationEqual
+                                                                   toItem: nil
+                                                                attribute: NSLayoutAttributeNotAnAttribute
+                                                               multiplier: 1.0
+                                                                 constant: self.view.frame.size.height * heightMultiple];
+    
+    [self.view addConstraint:self.webViewHeightConstraint];
+    
+    // Set the bottom inset to 0.5 screen height less than the height multiple.
+    // This allows the bottom of the article to be scrolled halfway up the page.
+    heightMultiple -= 0.5f;
+    
+    UIEdgeInsets insets = UIEdgeInsetsMake(0, 0, (self.view.frame.size.height * heightMultiple), 0);
+    self.webView.scrollView.contentInset = insets;
+}
+
 - (void)viewDidLoad
 {
     [super viewDidLoad];
 
     self.scrollingToTop = NO;
+
+    [self constrainWebViewHeight];
+    [self scrollIndicatorSetup];
+
+    self.panSwipeRecognizer = nil;
+
     self.zeroStatusLabel.text = @"";
     self.referencesVC = nil;
     
@@ -193,6 +246,8 @@ - (void)viewDidLoad
 
     [self.webView hideScrollGradient];
 
+    [self tocViewControllerSetup];
+
     [self reloadCurrentArticleInvalidatingCache:NO];
     
     // Restrict the web view from scrolling horizonally.
@@ -201,13 +256,6 @@ - (void)viewDidLoad
                                  options: NSKeyValueObservingOptionNew
                                  context: nil];
 
-    [self.bottomBarView addObserver:self
-                         forKeyPath: @"bounds"
-                            options: NSKeyValueObservingOptionNew
-                            context: nil];
-    
-    [self tocSetupSwipeGestureRecognizers];
-    
     // UIWebView has a bug which causes a black bar to appear at
     // bottom of the web view if toc quickly dragged on and offscreen.
     self.webView.opaque = NO;
@@ -226,23 +274,17 @@ - (void)viewDidLoad
                                                object: nil];
 
     self.view.backgroundColor = CHROME_COLOR;
-    
-
-
-
-
 
+    self.webView.scrollView.scrollsToTop = YES;
+    self.tocVC.scrollView.scrollsToTop = NO;
 
-// Uncomment these lines only if testing onboarding!
-// These lines allow the onboarding to run on every app cold start.
-//[[NSUserDefaults standardUserDefaults] setObject:@YES forKey:@"ShowOnboarding"];
-//[[NSUserDefaults standardUserDefaults] synchronize];
-
-
-
-//self.referencesContainerView.layer.borderWidth = 10;
-//self.referencesContainerView.layer.borderColor = [UIColor redColor].CGColor;
+    // Uncomment these lines only if testing onboarding!
+    // These lines allow the onboarding to run on every app cold start.
+    //[[NSUserDefaults standardUserDefaults] setObject:@YES forKey:@"ShowOnboarding"];
+    //[[NSUserDefaults standardUserDefaults] synchronize];
 
+    //self.referencesContainerView.layer.borderWidth = 10;
+    //self.referencesContainerView.layer.borderColor = [UIColor redColor].CGColor;
 }
 
 -(void)showAlert:(NSString *)alertText
@@ -332,6 +374,69 @@ -(void)viewWillDisappear:(BOOL)animated
     [super viewWillDisappear:animated];
 }
 
+#pragma mark Scroll indicator
+
+-(void)scrollIndicatorSetup
+{
+    self.scrollIndicatorView = [[UIView alloc] init];
+    self.scrollIndicatorView.opaque = YES;
+    self.scrollIndicatorView.backgroundColor = SCROLL_INDICATOR_BACKGROUND_COLOR;
+    self.scrollIndicatorView.translatesAutoresizingMaskIntoConstraints = NO;
+    self.scrollIndicatorView.layer.cornerRadius = SCROLL_INDICATOR_CORNER_RADIUS;
+    self.scrollIndicatorView.layer.borderWidth = SCROLL_INDICATOR_BORDER_WIDTH / [UIScreen mainScreen].scale;
+    self.scrollIndicatorView.layer.borderColor = SCROLL_INDICATOR_BORDER_COLOR.CGColor;
+
+    self.webView.scrollView.showsHorizontalScrollIndicator = NO;
+    self.webView.scrollView.showsVerticalScrollIndicator = NO;
+    
+    [self.webView addSubview:self.scrollIndicatorView];
+
+    self.scrollIndicatorViewTopConstraint =
+    [NSLayoutConstraint constraintWithItem: self.scrollIndicatorView
+                                 attribute: NSLayoutAttributeTop
+                                 relatedBy: NSLayoutRelationEqual
+                                    toItem: self.webView
+                                 attribute: NSLayoutAttributeTop
+                                multiplier: 1.0
+                                  constant: 0.0];
+
+    [self.view addConstraint:self.scrollIndicatorViewTopConstraint];
+
+    [self.view addConstraint:[NSLayoutConstraint constraintWithItem: self.scrollIndicatorView
+                                                          attribute: NSLayoutAttributeTrailing
+                                                          relatedBy: NSLayoutRelationEqual
+                                                             toItem: self.webView
+                                                          attribute: NSLayoutAttributeTrailing
+                                                         multiplier: 1.0
+                                                           constant: -SCROLL_INDICATOR_LEFT_MARGIN]];
+    
+    [self.view addConstraint:[NSLayoutConstraint constraintWithItem: self.scrollIndicatorView
+                                                          attribute: NSLayoutAttributeWidth
+                                                          relatedBy: NSLayoutRelationEqual
+                                                             toItem: nil
+                                                          attribute: NSLayoutAttributeNotAnAttribute
+                                                         multiplier: 1.0
+                                                           constant: SCROLL_INDICATOR_WIDTH]];
+    
+    self.scrollIndicatorViewHeightConstraint =
+    [NSLayoutConstraint constraintWithItem: self.scrollIndicatorView
+                                 attribute: NSLayoutAttributeHeight
+                                 relatedBy: NSLayoutRelationEqual
+                                    toItem: nil
+                                 attribute: NSLayoutAttributeNotAnAttribute
+                                multiplier: 1.0
+                                  constant: SCROLL_INDICATOR_HEIGHT];
+
+    [self.view addConstraint:self.scrollIndicatorViewHeightConstraint];
+}
+
+-(void)scrollIndicatorMove
+{
+    //self.scrollIndicatorView.alpha = [self tocDrawerIsOpen] ? 0.0f : 1.0f;
+    CGFloat percent = self.webView.scrollView.contentOffset.y / (self.webView.scrollView.contentSize.height + 0.0001f);
+    self.scrollIndicatorViewTopConstraint.constant = (percent * self.bottomBarView.frame.origin.y) + 2.0f;
+}
+
 #pragma mark Sync config/ios.json if necessary
 
 -(void)downloadAssetsFilesIfNecessary
@@ -394,11 +499,11 @@ -(void)searchFieldBecameFirstResponder
 
 -(void)updateViewConstraints
 {
-    [self tocConstrainView];
-    
+    [super updateViewConstraints];
+
     [self constrainBottomMenu];
     
-    [super updateViewConstraints];
+    [self tocConstrainView];
 }
 
 #pragma mark Angle from velocity vector
@@ -422,22 +527,9 @@ -(BOOL)tocDrawerIsOpen
     return (self.webViewRightConstraint.constant == 0) ? NO : YES;
 }
 
--(void)tocHideIfSafeToToggleDuringNextRunLoopWithDuration:(NSNumber *)duration
-{
-    if(self.unsafeToToggleTOC || !self.tocVC) return;
-
-    // iOS 6 can blank out the web view this isn't scheduled for next run loop.
-    [[NSRunLoop currentRunLoop] performSelector: @selector(tocHideWithDuration:)
-                                         target: self
-                                       argument: duration
-                                          order: 0
-                                          modes: [NSArray arrayWithObject:@"NSDefaultRunLoopMode"]];
-}
-
 -(void)tocHideWithDuration:(NSNumber *)duration
 {
-    // Ensure one exists to be hidden.
-    if (!self.tocVC) return;
+    if (![self tocDrawerIsOpen]) return;
 
     self.unsafeToToggleTOC = YES;
     
@@ -448,6 +540,7 @@ -(void)tocHideWithDuration:(NSNumber *)duration
     // Clear alerts
     [self fadeAlert];
 
+    [self.view setNeedsUpdateConstraints];
     [UIView animateWithDuration: duration.floatValue
                           delay: 0.0f
                         options: UIViewAnimationOptionBeginFromCurrentState
@@ -455,7 +548,6 @@ -(void)tocHideWithDuration:(NSNumber *)duration
 
                          // If the top menu isn't hidden, reveal the bottom menu.
                          self.bottomMenuHidden = ROOT.topMenuHidden;
-                         [self.view setNeedsUpdateConstraints];
                          
                          self.webView.transform = CGAffineTransformIdentity;
 
@@ -466,45 +558,37 @@ -(void)tocHideWithDuration:(NSNumber *)duration
 
                          [self.view layoutIfNeeded];
                      }completion: ^(BOOL done){
-                         if(self.tocVC) [self tocViewControllerRemove];
+                         [self.tocVC didHide];
                          self.unsafeToToggleTOC = NO;
                          self.webView.scrollView.contentOffset = origScrollPosition;
                      }];
 }
 
--(void)tocShowIfSafeToToggleDuringNextRunLoopWithDuration:(NSNumber *)duration
-{
-    if([[SessionSingleton sharedInstance] isCurrentArticleMain]) return;
-
-    if(self.unsafeToToggleTOC || self.tocVC) return;
-
-    // iOS 6 can blank out the web view this isn't scheduled for next run loop.
-    [[NSRunLoop currentRunLoop] performSelector: @selector(tocShowWithDuration:)
-                                         target: self
-                                       argument: duration
-                                          order: 0
-                                          modes: [NSArray arrayWithObject:@"NSDefaultRunLoopMode"]];
-}
-
 -(void)tocShowWithDuration:(NSNumber *)duration
 {
+    if ([self tocDrawerIsOpen]) return;
+
     self.unsafeToToggleTOC = YES;
 
     // Hide any alerts immediately.
     [self hideAlert];
 
-    // Ensure the toc is rebuilt from scratch! Very weird toc scroll view
-    // resizing issues (can't scroll up to bottom toc entry sometimes, etc)
-    // when choosing different article languages otherwise!
-    if(self.tocVC) [self tocViewControllerRemove];
-    
-    [self tocViewControllerAdd];
+    // setNeedsUpdateConstraints causes updateViewConstraints to be called which is needed because
+    // it calls tocConstrainView which sets the width of the toc view. Needed before the animation
+    // block below because the device may have been rotated so the toc view may need new width.
+    // We want this new width set before the animation begins.
+    [self.view setNeedsUpdateConstraints];
+    // Layout to ensure that the width is in place before the toc view starts to animate to being
+    // onscreen.
+    [self.view layoutIfNeeded];
+    // Among other things, the willShow method then makes the toc cells be the correct size for
+    // the current (potentially new) toc view width.
+    [self.tocVC willShow];
     
-    [self.tocVC centerCellForWebViewTopMostSectionAnimated:NO];
-
     CGFloat webViewScale = [self tocGetWebViewScaleWhenTOCVisible];
     CGAffineTransform xf = CGAffineTransformMakeScale(webViewScale, webViewScale);
 
+    [self.view setNeedsUpdateConstraints];
     [UIView animateWithDuration: duration.floatValue
                           delay: 0.0f
                         options: 0 // UIViewAnimationOptionBeginFromCurrentState <--Don't do this, can cause toc to jump as it appears (if top/bottom menus visibility changes)
@@ -512,60 +596,51 @@ -(void)tocShowWithDuration:(NSNumber *)duration
 
                          self.bottomMenuHidden = YES;
                          self.referencesHidden = YES;
-                         [self.view setNeedsUpdateConstraints];
                          self.webView.transform = xf;
                          self.referencesContainerView.transform = xf;
                          self.bottomBarView.transform = xf;
                          self.webViewRightConstraint.constant = [self tocGetWidthForWebViewScale:webViewScale];
                          [self.view layoutIfNeeded];
                      }completion: ^(BOOL done){
-                         [self.view setNeedsUpdateConstraints];
                          self.unsafeToToggleTOC = NO;
                      }];
 }
 
-- (void)tocViewControllerAdd
+- (void)tocViewControllerSetup
 {
     self.tocVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"TOCViewController"];
     self.tocVC.view.translatesAutoresizingMaskIntoConstraints = NO;
     self.tocVC.webVC = self;
 
     [self addChildViewController:self.tocVC];
-
-    [self.view setNeedsUpdateConstraints];
-        
     [self.view addSubview:self.tocVC.view];
-
+    [self.view setNeedsUpdateConstraints];
     [self.tocVC didMoveToParentViewController:self];
 
-    // This ensures the toc cells assume the proper height for how many lines of text they're displaying before
-    // toc show animation. Otherwise they grow to their height as part of the show animation.
-    [self.tocVC.view layoutIfNeeded];
-
-    // Make the toc's scroll view not scroll until the swipe recognizer fails.
-    [self.tocVC.scrollView.panGestureRecognizer requireGestureRecognizerToFail:self.tocSwipeLeftRecognizer];
-    [self.tocVC.scrollView.panGestureRecognizer requireGestureRecognizerToFail:self.tocSwipeRightRecognizer];
-
-    [self.view.superview layoutIfNeeded];
-}
-
-- (void)tocViewControllerRemove
-{
-    [self.tocVC willMoveToParentViewController:nil];
-    [self.tocVC.view removeFromSuperview];
-    [self.tocVC removeFromParentViewController];
-    
-    self.tocVC = nil;
+    [self tocSetupSwipeGestureRecognizers];
 }
 
 -(void)tocHide
 {
-    [self tocHideIfSafeToToggleDuringNextRunLoopWithDuration:TOC_TOGGLE_ANIMATION_DURATION];
+    if(self.unsafeToToggleTOC) return;
+
+    [self tocHideWithDuration:TOC_TOGGLE_ANIMATION_DURATION];
 }
 
 -(void)tocShow
 {
-    [self tocShowIfSafeToToggleDuringNextRunLoopWithDuration:TOC_TOGGLE_ANIMATION_DURATION];
+    // Prevent toc reveal if pull to refresh in effect.
+    if (self.webView.scrollView.contentOffset.y < 0) return;
+
+    NSString *currentArticleTitle = [SessionSingleton sharedInstance].currentArticleTitle;
+    if (!currentArticleTitle || (currentArticleTitle.length == 0)) return;
+    if (!self.referencesHidden) return;
+
+    if([[SessionSingleton sharedInstance] isCurrentArticleMain]) return;
+
+    if(self.unsafeToToggleTOC) return;
+
+    [self tocShowWithDuration:TOC_TOGGLE_ANIMATION_DURATION];
 }
 
 -(void)tocToggle
@@ -573,6 +648,8 @@ -(void)tocToggle
     // Clear alerts
     [self fadeAlert];
 
+    [self referencesHide];
+
     if ([self tocDrawerIsOpen]) {
         [self tocHide];
     }else{
@@ -580,56 +657,83 @@ -(void)tocToggle
     }
 }
 
--(void)tocSetupSwipeGestureRecognizers
+-(BOOL)shouldPanVelocityTriggerTOC:(CGPoint)panVelocity
 {
-    self.tocSwipeLeftRecognizer =
-    [[UISwipeGestureRecognizer alloc] initWithTarget: self
-                                              action: @selector(tocSwipeLeftHandler:)];
-    
-    self.tocSwipeRightRecognizer =
-    [[UISwipeGestureRecognizer alloc] initWithTarget: self
-                                              action: @selector(tocSwipeRightHandler:)];
-    
-    // Device rtl value is checked since this is what would cause the other constraints to flip.
-    BOOL isRTL = [WikipediaAppUtils isDeviceLanguageRTL];
-
-    [self tocSetupSwipeGestureRecognizer: self.tocSwipeLeftRecognizer
-                            forDirection: (isRTL ? UISwipeGestureRecognizerDirectionRight : UISwipeGestureRecognizerDirectionLeft)];
-
-    [self tocSetupSwipeGestureRecognizer: self.tocSwipeRightRecognizer
-                            forDirection: (isRTL ? UISwipeGestureRecognizerDirectionLeft : UISwipeGestureRecognizerDirectionRight)];
+    CGFloat angleFromHorizontalAxis = [self getAbsoluteHorizontalDegreesFromVelocity:panVelocity];
+    if (
+        (angleFromHorizontalAxis < TOC_SWIPE_TRIGGER_MAX_ANGLE)
+        &&
+        (fabsf(panVelocity.x) > TOC_SWIPE_TRIGGER_MIN_X_VELOCITY)
+    ) {
+        return YES;
+    }
+    return NO;
 }
 
--(void)tocSetupSwipeGestureRecognizer: (UISwipeGestureRecognizer *)recognizer
-                         forDirection: (UISwipeGestureRecognizerDirection)direction
-{
-    recognizer.delegate = self;
-
-    recognizer.direction = direction;
-    
-    [self.view addGestureRecognizer:recognizer];
-
-    // Make the web view's scroll view not scroll until the swipe recognizer fails.
-    [self.webView.scrollView.panGestureRecognizer requireGestureRecognizerToFail:recognizer];
-    
+- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
+{
+    // Don't allow the web view's scroll view or the TOC's scroll view to start vertical scrolling if the
+    // angle and direction of the swipe are within tolerances to trigger TOC toggle. Needed because you
+    // don't want either of these to be scrolling vertically when the TOC is being revealed or hidden.
+    //WHOA! see this: http://stackoverflow.com/a/18834934
+    if (gestureRecognizer == self.panSwipeRecognizer) {
+        if (
+            (otherGestureRecognizer == self.webView.scrollView.panGestureRecognizer)
+            ||
+            (otherGestureRecognizer == self.tocVC.scrollView.panGestureRecognizer)
+        ){
+            UIPanGestureRecognizer *otherPanRecognizer = (UIPanGestureRecognizer *)otherGestureRecognizer;
+            CGPoint velocity = [otherPanRecognizer velocityInView:otherGestureRecognizer.view];
+            if ([self shouldPanVelocityTriggerTOC:velocity]) {
+                // Kill vertical scroll before it starts if we're going to show TOC.
+                self.webView.scrollView.panGestureRecognizer.enabled = NO;
+                self.webView.scrollView.panGestureRecognizer.enabled = YES;
+                self.tocVC.scrollView.panGestureRecognizer.enabled = NO;
+                self.tocVC.scrollView.panGestureRecognizer.enabled = YES;
+            }
+        }
+    }
+    return YES;
 }
 
--(void)tocSwipeLeftHandler:(UISwipeGestureRecognizer *)recognizer
+-(void)tocSetupSwipeGestureRecognizers
 {
-    NSString *currentArticleTitle = [SessionSingleton sharedInstance].currentArticleTitle;
-    if (!currentArticleTitle || (currentArticleTitle.length == 0)) return;
+    // Use pan instead for swipe so we can control speed at which swipe triggers. Idea from:
+    // http://www.mindtreatstudios.com/how-its-made/ios-gesture-recognizer-tips-tricks/
 
-    if (recognizer.state == UIGestureRecognizerStateEnded){
-        if (self.referencesHidden) {
-            [self tocShow];
-        }
-    }
+    self.panSwipeRecognizer =
+        [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanSwipe:)];
+    self.panSwipeRecognizer.delegate = self;
+    self.panSwipeRecognizer.minimumNumberOfTouches = 1;
+    [self.view addGestureRecognizer:self.panSwipeRecognizer];
 }
 
--(void)tocSwipeRightHandler:(UISwipeGestureRecognizer *)recognizer
+- (void)handlePanSwipe:(UIPanGestureRecognizer*)recognizer
 {
     if (recognizer.state == UIGestureRecognizerStateEnded){
-        [self tocHide];
+        
+        CGPoint velocity = [recognizer velocityInView:recognizer.view];
+
+        if (![self shouldPanVelocityTriggerTOC:velocity] || self.webView.scrollView.isDragging) return;
+        
+        // Device rtl value is checked since this is what would cause the other constraints to flip.
+        BOOL isRTL = [WikipediaAppUtils isDeviceLanguageRTL];
+
+        if (velocity.x < 0){
+            //NSLog(@"swipe left");
+            if (isRTL) {
+                [self tocHide];
+            }else{
+                [self tocShow];
+            }
+        }else if (velocity.x > 0){
+            //NSLog(@"swipe right");
+            if (isRTL) {
+                [self tocShow];
+            }else{
+                [self tocHide];
+            }
+        }
     }
 }
 
@@ -657,10 +761,6 @@ -(CGFloat)tocGetWidthForWebViewScale:(CGFloat)webViewScale
 
 -(void)tocConstrainView
 {
-    if (!self.tocVC) return;
-    
-    [self.tocVC.view removeConstraintsOfViewFromView:self.view];
-
     CGFloat webViewScale = [self tocGetWebViewScaleWhenTOCVisible];
     
     NSDictionary *views = @{
@@ -696,6 +796,7 @@ -(void)tocConstrainView
                                                 views: views]
       ];
     
+    [self.tocVC.view removeConstraintsOfViewFromView:self.view];
     [self.view addConstraints:[constraints valueForKeyPath:@"@unionOfArrays.self"]];
 }
 
@@ -706,12 +807,25 @@ -(CGFloat)tocGetPercentOnscreen
     return 1.0f - (fabsf(self.tocVC.view.frame.origin.x) / defaultTOCWidth);
 }
 
+-(BOOL)rectIntersectsWebViewTop:(CGRect)rect
+{
+    CGFloat elementScreenYOffset =
+        rect.origin.y - self.webView.scrollView.contentOffset.y + rect.size.height;
+    return (elementScreenYOffset > 0) && (elementScreenYOffset < rect.size.height);
+}
+
 -(void)tocScrollWebViewToSectionWithElementId: (NSString *)elementId
                                      duration: (CGFloat)duration
                                   thenHideTOC: (BOOL)hideTOC
 {
     CGRect r = [self.webView getWebViewRectForHtmlElementWithId:elementId];
     if (CGRectIsNull(r)) return;
+
+    // Determine if the element is already intersecting the top of the screen.
+    // The method below is more efficient than calling
+    // getScreenRectForHtmlElementWithId again (as it was already called by
+    // getWebViewRectForHtmlElementWithId).
+    // if ([self rectIntersectsWebViewTop:r]) return;
     
     CGPoint point = r.origin;
 
@@ -781,12 +895,6 @@ -(void)observeValueForKeyPath: (NSString *)keyPath
             [self.bridge sendMessage:@"scrollToFragment"
                          withPayload:@{@"hash": self.jumpToFragment}];
         }
-    } else if (
-        (object == self.bottomBarView)
-        &&
-        ([keyPath isEqual:@"bounds"])
-        ) {
-            [self updateWebViewContentAndScrollInsets];
     }
 }
 
@@ -795,7 +903,6 @@ -(void)observeValueForKeyPath: (NSString *)keyPath
 -(void)dealloc
 {
     [self.webView.scrollView removeObserver:self forKeyPath:@"contentSize"];
-    [self.bottomBarView removeObserver:self forKeyPath:@"bounds"];
 
     // This needs to be in dealloc.
     [[NSNotificationCenter defaultCenter] removeObserver: self
@@ -992,6 +1099,15 @@ -(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{
     [self scrollViewScrollingEnded:scrollView];
 }
 
+- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView
+{
+    // If user quickly scrolls web view make toc update when user lifts finger.
+    // (in addition to when scroll ends)
+    if (scrollView == self.webView.scrollView) {
+        [self.tocVC centerCellForWebViewTopMostSectionAnimated:YES];
+    }
+}
+
 -(void)scrollViewScrollingEnded:(UIScrollView *)scrollView
 {
     if (scrollView == self.webView.scrollView) {
@@ -1003,8 +1119,7 @@ -(void)scrollViewScrollingEnded:(UIScrollView *)scrollView
         //NSLog(@"%@", NSStringFromCGPoint(scrollView.contentOffset));
         [self saveWebViewScrollOffset];
         
-        TOCViewController *tocVC = [self searchForChildViewControllerOfClass:[TOCViewController class]];
-        if (tocVC) [tocVC centerCellForWebViewTopMostSectionAnimated:YES];
+        [self.tocVC centerCellForWebViewTopMostSectionAnimated:YES];
 
         self.pullToRefreshView.alpha = 0.0f;
     }
@@ -1088,6 +1203,8 @@ - (void)scrollViewDidScroll:(UIScrollView *)scrollView
     
     [self adjustTopAndBottomMenuVisibilityOnScroll];
 
+    [self scrollIndicatorMove];
+
     [super scrollViewDidScroll:scrollView];
 }
 
@@ -1133,7 +1250,7 @@ -(void)adjustTopAndBottomMenuVisibilityOnScroll
 -(void)animateTopAndBottomMenuReveal
 {
     // Toggle the menus closed on tap (only if they were showing).
-    if (!self.tocVC) {
+    if (![self tocDrawerIsOpen]) {
         if (ROOT.topMenuViewController.navBarMode != NAVBAR_MODE_SEARCH) {
             if (![self tocDrawerIsOpen]){
                 [ROOT animateTopAndBottomMenuHidden:NO];
@@ -1356,6 +1473,7 @@ - (void)retrieveArticleForPageTitle: (MWPageTitle *)pageTitle
         
         // If article with sections just show them (unless needsRefresh is YES)
         if (article.section.count > 0 && !article.needsRefresh.boolValue) {
+            [self.tocVC setTocSectionDataForSections:article.section];
             [self displayArticle:articleID mode:DISPLAY_ALL_SECTIONS];
             //[self showAlert:MWLocalizedString(@"search-loading-article-loaded", nil)];
             [self fadeAlert];
@@ -1426,6 +1544,9 @@ - (void)retrieveArticleForPageTitle: (MWPageTitle *)pageTitle
 
             NSError *error = nil;
             [articleDataContext_.workerContext save:&error];
+
+            [self.tocVC setTocSectionDataForSections:article.section];
+
         }];
         
         [self displayArticle:articleID mode:DISPLAY_APPEND_NON_LEAD_SECTIONS];
@@ -1577,6 +1698,8 @@ - (void)retrieveArticleForPageTitle: (MWPageTitle *)pageTitle
             NSError *error = nil;
             [articleDataContext_.workerContext save:&error];
 
+            [self.tocVC setTocSectionDataForSections:article.section];
+
             if (error) {
                 NSLog(@"error = %@", error);
                 NSLog(@"error = %@", error.localizedDescription);
@@ -1836,8 +1959,6 @@ -(void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOr
     [super didRotateFromInterfaceOrientation:fromInterfaceOrientation];
 
     [self scrollToElementOnScreenBeforeRotate];
-    
-    [self updateWebViewContentAndScrollInsets];
 }
 
 -(void)scrollToElementOnScreenBeforeRotate
@@ -1997,8 +2118,6 @@ -(void)setBottomMenuHidden:(BOOL)bottomMenuHidden
     CGFloat alpha = bottomMenuHidden ? 0.0 : 1.0;
     
     self.bottomBarView.alpha = alpha;
-
-    [self updateWebViewContentAndScrollInsets];
 }
 
 -(void)constrainBottomMenu
@@ -2022,17 +2141,6 @@ -(void)constrainBottomMenu
     [self.view addConstraint:self.bottomBarViewBottomConstraint];
 }
 
--(void)updateWebViewContentAndScrollInsets
-{
-    // Ensure web view can be scrolled to bottom and that scroll indicator doesn't underlap
-    // bottom menu.
-    CGFloat bottomBarHeight = self.bottomBarView.bounds.size.height;
-    if(self.bottomBarView.alpha == 0) bottomBarHeight = 0;
-    UIEdgeInsets insets = UIEdgeInsetsMake(0, 0, bottomBarHeight, 0);
-    self.webView.scrollView.contentInset = insets;
-    self.webView.scrollView.scrollIndicatorInsets = insets;
-}
-
 #pragma mark Languages
 
 -(void)languageButtonPushed
