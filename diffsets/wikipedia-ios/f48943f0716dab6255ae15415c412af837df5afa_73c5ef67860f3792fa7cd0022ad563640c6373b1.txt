diff --git a/WMF Framework/Event Platform/EventPlatformClient.swift b/WMF Framework/Event Platform/EventPlatformClient.swift
index cc61976899b..f17e8ac559b 100644
--- a/WMF Framework/Event Platform/EventPlatformClient.swift	
+++ b/WMF Framework/Event Platform/EventPlatformClient.swift	
@@ -73,10 +73,25 @@ import CocoaLumberjackSwift
     var sessionID: String {
         return userSession.sessionID
     }
-
-    public func resetCaching() {
+    
+    public var sessionStartDate: Date? {
+        return userSession.sessionStartDate
+    }
+        
+    public func reset() {
         samplingController.removeAllSamplingCache()
+        userSession.reset()
     }
+    
+    public typealias DidResetSession = Bool
+    public func appDidBecomeActive() -> DidResetSession {
+        return userSession.appDidBecomeActive()
+    }
+    
+    public func appDidBackground() {
+        userSession.appDidBackground()
+    }
+    
     /**
      * Store events until the library is finished initializing
      *
diff --git a/WMF Framework/Event Platform/MetricsClientBridge.swift b/WMF Framework/Event Platform/MetricsClientBridge.swift
index 54934f74964..430e7f7d592 100644
--- a/WMF Framework/Event Platform/MetricsClientBridge.swift	
+++ b/WMF Framework/Event Platform/MetricsClientBridge.swift	
@@ -4,28 +4,10 @@ import Foundation
 public class MetricsClientBridge: NSObject {
     
     let client = EventPlatformClient.shared
-    let session = UserSession.shared
     
     @objc(sharedInstance) public static let shared: MetricsClientBridge = {
         return MetricsClientBridge()
     }()
-    
-    @objc public func appInBackground() {
-        session.logSessionEndTimestamp()
-    }
-    
-    @objc public func appInForeground() {
-        session.appInForeground()
-    }
-    
-    @objc public func appWillClose() {
-        session.appWillClose()
-    }
-    
-    @objc public func reset() {
-        session.reset()
-    }
-    
 }
 
 // MARK: PeriodicWorker
diff --git a/WMF Framework/UserSession.swift b/WMF Framework/UserSession.swift
index 573ecf4af5a..319b3b34633 100644
--- a/WMF Framework/UserSession.swift	
+++ b/WMF Framework/UserSession.swift	
@@ -8,10 +8,8 @@ public final class UserSession: NSObject {
     @objc public static let shared: UserSession = {
         return UserSession()
     }()
-
-    private let queue = DispatchQueue(label: "UserSessionClient-" + UUID().uuidString)
-
-    public var hasSessionTimedOut: Bool = false
+    
+    // MARK: Internal
 
     /**
      * Return a session identifier
@@ -20,114 +18,85 @@ public final class UserSession: NSObject {
      * The identifier is a string of 20 zero-padded hexadecimal digits
      * representing a uniformly random 80-bit integer.
      */
-    internal var sessionID: String {
-        queue.sync {
-            var _sessionID = UserDefaults.standard.wmf_sessionID
-            guard let sID = _sessionID else {
-                let newID = generateID()
-                _sessionID = newID
-                UserDefaults.standard.wmf_sessionID = _sessionID
-                return newID
-            }
-            return sID
+    var sessionID: String {
+        var _sessionID = UserDefaults.standard.wmf_sessionID
+        guard let sID = _sessionID else {
+            let newID = generateID()
+            _sessionID = newID
+            UserDefaults.standard.wmf_sessionID = _sessionID
+            UserDefaults.standard.wmf_sessionStartTimestamp = Date()
+            return newID
         }
+        return sID
+    }
+    
+    var sessionStartDate: Date? {
+        return UserDefaults.standard.wmf_sessionStartTimestamp
     }
 
     /**
-     * Generates a new identifier using the same algorithm as EPC libraries for
-     * web and Android
+     * Reset the session ID
      */
-    private func generateID() -> String {
-        var id: String = ""
-        for _ in 1...5 {
-            id += String(format: "%04x", arc4random_uniform(65535))
-        }
-        return id
+    func reset() {
+        UserDefaults.standard.wmf_sessionID = nil
+        UserDefaults.standard.wmf_sessionStartTimestamp = nil
+        UserDefaults.standard.wmf_sessionBackgroundTimestamp = nil
     }
 
     /**
-     * Called when user toggles logging permissions in Settings
-     *
-     * This assumes storageManager's deviceID will be reset separately by a
-     * different owner (EventLoggingService's `reset()` method)
+     * If it has been more than 30 minutes since the app entered background state,
+     * a new session is started.
      */
-    public func reset() {
-        resetSession()
+    typealias DidResetSession = Bool
+    func appDidBecomeActive() -> DidResetSession {
+        if self.hasSessionTimedOut() {
+            self.reset()
+            return true
+        }
+        
+        return false
     }
 
     /**
-     * Sets the session start date if there is no valid session
+     * This method should be called upon app background
+     *
+     * We now persist session ID on app close to match session handling with Android
+     * session ends when 30 minutes of inactivity have passed.
      */
-    public var sessionStartDate: Date? {
-        queue.sync {
-            guard let sessionStart = _sessionStartDate else {
-                let newStart = Date()
-                _sessionStartDate = newStart
-                return newStart
-            }
-            return sessionStart
-        }
+    func appDidBackground() {
+        UserDefaults.standard.wmf_sessionBackgroundTimestamp = Date()
     }
-
-    private var _sessionStartDate: Date?
-
+    
+    
+    // MARK: Private
+    
     /**
-     * Unset the session
+     * Generates a new identifier using the same algorithm as EPC libraries for
+     * web and Android
      */
-    public func resetSession() {
-        queue.async {
-            UserDefaults.standard.wmf_sessionID = nil
+    private func generateID() -> String {
+        var id: String = ""
+        for _ in 1...5 {
+            id += String(format: "%04x", arc4random_uniform(65535))
         }
+        return id
     }
-
+    
     /**
      * Check if session expired, based on last active timestamp
      *
      * A new session ID is required if it has been more than 30 minutes since the
      * user was last active (e.g. when app entered background).
      */
-    public func sessionTimedOut() -> Bool {
+    private func hasSessionTimedOut() -> Bool {
+        
         /*
          * A TimeInterval value is always specified in seconds.
          */
-        if let lastTimestamp = UserDefaults.standard.wmf_sessionLastTimestamp {
-            hasSessionTimedOut = lastTimestamp.timeIntervalSinceNow < -1800
-            return hasSessionTimedOut
+        
+        if let lastTimestamp = UserDefaults.standard.wmf_sessionBackgroundTimestamp {
+            return lastTimestamp.timeIntervalSinceNow < -1800
         }
         return true
     }
-
-    /**
-     * This method is called by the application delegate in
-     * `applicationDidBecomeActive()` and re-enables event logging.
-     *
-     * If it has been more than 30 minutes since the app entered background state,
-     * a new session is started.
-     */
-    public func appInForeground() {
-        if sessionTimedOut() {
-            resetSession()
-        }
-    }
-
-    /**
-     * This method is called by the application delegate in
-     * `applicationWillTerminate()`
-     *
-     * We now persist session ID on app close to match session handling with Android
-     * session ends when 30 minutes of inactivity have passed.
-     */
-    public func appWillClose() {
-        UserDefaults.standard.wmf_sessionLastTimestamp = Date()
-    }
-
-    /**
-     * This method is called by the application delegate in
-     * `applicationWillResignActive()` and disables event logging.
-     */
-    @objc public func logSessionEndTimestamp() {
-        UserDefaults.standard.wmf_sessionLastTimestamp = Date()
-
-    }
-
 }
diff --git a/Wikipedia/Code/AppDelegate.m b/Wikipedia/Code/AppDelegate.m
index c59f17873e1..667864ad1b8 100644
--- a/Wikipedia/Code/AppDelegate.m
+++ b/Wikipedia/Code/AppDelegate.m
@@ -100,7 +100,6 @@ - (void)applicationWillEnterForeground:(UIApplication *)application {
 - (void)applicationDidBecomeActive:(UIApplication *)application {
     // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
     [self resumeAppIfNecessary];
-    [[WMFMetricsClientBridge sharedInstance] appInForeground];
 }
 
 - (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler {
@@ -188,7 +187,6 @@ - (void)applicationWillResignActive:(UIApplication *)application {
     // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
     // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
     [[NSUserDefaults standardUserDefaults] wmf_setAppResignActiveDate:[NSDate date]];
-    [[WMFMetricsClientBridge sharedInstance] appInBackground];
 }
 
 - (void)applicationDidEnterBackground:(UIApplication *)application {
@@ -202,7 +200,6 @@ - (void)applicationDidEnterBackground:(UIApplication *)application {
 - (void)applicationWillTerminate:(UIApplication *)application {
     // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
     [self updateDynamicIconShortcutItems];
-    [[WMFMetricsClientBridge sharedInstance] appWillClose];
 }
 
 #pragma mark - Background Fetch
diff --git a/Wikipedia/Code/NSUserDefaults+WMFExtensions.swift b/Wikipedia/Code/NSUserDefaults+WMFExtensions.swift
index ca89778322c..6408dce0b27 100644
--- a/Wikipedia/Code/NSUserDefaults+WMFExtensions.swift
+++ b/Wikipedia/Code/NSUserDefaults+WMFExtensions.swift
@@ -32,7 +32,8 @@ let WMFDidShowNotificationsCenterPushOptInPanel = "WMFDidShowNotificationsCenter
 let WMFSubscribedToEchoNotifications = "WMFSubscribedToEchoNotifications"
 let WMFTappedToImportSharedReadingListSurvey = "WMFTappedToImportSharedReadingListSurvey"
 public let WMFAlwaysDisplayEditNotices = "WMFAlwaysDisplayEditNotices"
-let WMFLastSessionDate =  "WMFLastSessionDate"
+let WMFSessionBackgroundDate =  "WMFSessionBackgroundDate"
+let WMFSessionStartDate =  "WMFSessionStartDate"
 
 @objc public enum WMFAppDefaultTabType: Int {
     case explore
@@ -536,12 +537,21 @@ let WMFLastSessionDate =  "WMFLastSessionDate"
         }
     }
 
-    @objc var wmf_sessionLastTimestamp: Date? {
+    @objc var wmf_sessionBackgroundTimestamp: Date? {
         get {
-            return object(forKey: WMFLastSessionDate) as? Date
+            return object(forKey: WMFSessionBackgroundDate) as? Date
         }
         set {
-            set(newValue, forKey: WMFLastSessionDate)
+            set(newValue, forKey: WMFSessionBackgroundDate)
+        }
+    }
+    
+    @objc var wmf_sessionStartTimestamp: Date? {
+        get {
+            return object(forKey: WMFSessionStartDate) as? Date
+        }
+        set {
+            set(newValue, forKey: WMFSessionStartDate)
         }
     }
 
diff --git a/Wikipedia/Code/SessionsFunnel.swift b/Wikipedia/Code/SessionsFunnel.swift
index 0641756ef0f..364205ba1b3 100644
--- a/Wikipedia/Code/SessionsFunnel.swift
+++ b/Wikipedia/Code/SessionsFunnel.swift
@@ -37,36 +37,42 @@
         EventPlatformClient.shared.submit(stream: .sessions, event: finalEvent)
     }
 
-    @objc public func setSessionStart() {
-        if UserSession.shared.hasSessionTimedOut {
-            defer {
-                resetSession()
-            }
+    @objc public func appDidBecomeActive() {
+        let didReset = EventPlatformClient.shared.appDidBecomeActive()
+        if didReset {
             logPreviousSessionEnd()
+            resetPageLoadMetrics()
+            EventPlatformClient.shared.reset()
         }
     }
     
-    private func resetSession() {
-        resetPageLoadMetrics()
-        UserSession.shared.resetSession()
-        EventPlatformClient.shared.resetCaching()
+    @objc public func appDidBackground() {
+        EventPlatformClient.shared.appDidBackground()
     }
-
-    @objc public func logSessionLastActivity() {
-        UserSession.shared.logSessionEndTimestamp()
+    
+    @objc public func settingsLoggingToggledOff() {
+        
+        // Order is important here - logPreviousSessionEnd uses EventPlatformClient.sessionStartDate, which the reset call in the next line clears out.
+        
+        logPreviousSessionEnd()
+        resetPageLoadMetrics()
+        EventPlatformClient.shared.reset()
     }
 
     /**
      * To match Android, we now log the previous Session when a new session starts
      */
-    @objc public func logPreviousSessionEnd() {
-        guard let sessionStartDate = UserSession.shared.sessionStartDate else {
+    private func logPreviousSessionEnd() {
+        guard let sessionStartDate = EventPlatformClient.shared.sessionStartDate else {
             assertionFailure("Session start date cannot be nil")
             return
         }
         
         calculatePageLoadMetrics()
         logEvent(measure: fabs(sessionStartDate.timeIntervalSinceNow))
+        
+        // Should we do this? Feels weird to mix funnels.
+        // UserHistoryFunnel.shared.logSnapshot()
     }
     
     // MARK: ArticleViewController Load Time Measurement Helpers
diff --git a/Wikipedia/Code/WMFAppViewController.m b/Wikipedia/Code/WMFAppViewController.m
index f3be5ed4e39..1dc962b3f59 100644
--- a/Wikipedia/Code/WMFAppViewController.m
+++ b/Wikipedia/Code/WMFAppViewController.m
@@ -374,7 +374,7 @@ - (void)appWillEnterForegroundWithNotification:(NSNotification *)note {
 
 // When the user launches from a terminated state, resume might not finish before didBecomeActive, so these tasks are held until both items complete
 - (void)performTasksThatShouldOccurAfterBecomeActiveAndResume {
-    [[SessionsFunnel shared] setSessionStart];
+    [[SessionsFunnel shared] appDidBecomeActive];
     [self checkRemoteAppConfigIfNecessary];
     [self.periodicWorkerController start];
     [self.savedArticlesFetcher start];
@@ -1019,7 +1019,7 @@ - (NSTimeInterval)timeBeforeRefreshingExploreFeed {
 }
 
 - (void)pauseApp {
-    [self logSessionEnd];
+    [[SessionsFunnel shared] appDidBackground];
 
     if (![self uiIsLoaded]) {
         [self endPauseAppBackgroundTask];
@@ -1058,13 +1058,6 @@ - (void)didReceiveMemoryWarning {
     [self.dataStore clearMemoryCache];
 }
 
-#pragma mark - Logging
-
-- (void)logSessionEnd {
-    [[UserSession shared] logSessionEndTimestamp];
-    [[UserHistoryFunnel shared] logSnapshot];
-}
-
 #pragma mark - Shortcut
 
 - (BOOL)canProcessShortcutItem:(UIApplicationShortcutItem *)item {
diff --git a/Wikipedia/Code/WMFSettingsViewController.m b/Wikipedia/Code/WMFSettingsViewController.m
index a36bf20f93a..99b65d0443e 100644
--- a/Wikipedia/Code/WMFSettingsViewController.m
+++ b/Wikipedia/Code/WMFSettingsViewController.m
@@ -188,17 +188,12 @@ - (void)disclosureSwitchChanged:(UISwitch *)disclosureSwitch {
 - (void)updateStateForMenuItemType:(WMFSettingsMenuItemType)type isSwitchOnValue:(BOOL)isOn {
     switch (type) {
         case WMFSettingsMenuItemType_SendUsageReports: {
-            WMFMetricsClientBridge *metricsClientBridge = [WMFMetricsClientBridge sharedInstance];
             NSUserDefaults.standardUserDefaults.wmf_sendUsageReports = isOn;
             if (isOn) {
-                [metricsClientBridge reset];
-                [[SessionsFunnel shared] setSessionStart];
                 [[UserHistoryFunnel shared] logStartingSnapshot];
             } else {
-                [[SessionsFunnel shared] logSessionLastActivity];
-                [[SessionsFunnel shared] logPreviousSessionEnd];
                 [[UserHistoryFunnel shared] logSnapshot];
-                [metricsClientBridge reset];
+                [[SessionsFunnel shared] settingsLoggingToggledOff];
             }
         } break;
         default:
