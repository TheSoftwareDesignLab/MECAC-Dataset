diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 42295076032..4a83ca2cd81 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -209,6 +209,8 @@
 		954BA118838BF8BA6B01C34A /* libPods-WikipediaUnitTests.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CE61C6963F825760822A28A /* libPods-WikipediaUnitTests.a */; };
 		BC118C0F1A95894D0072E4D8 /* WikipediaAppUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = C9180EC318AED30C006C1DCA /* WikipediaAppUtils.m */; };
 		BC118C101A9589720072E4D8 /* AssetsFile.m in Sources */ = {isa = PBXBuildFile; fileRef = 04272E791940EEBC00CC682F /* AssetsFile.m */; };
+		BC2CBB8E1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2CBB8D1AA10F400079A313 /* UIView+WMFFrameUtils.m */; };
+		BC2CBB8F1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2CBB8D1AA10F400079A313 /* UIView+WMFFrameUtils.m */; };
 		BC42735D1A7C73B300068882 /* NSArray+Predicate.m in Sources */ = {isa = PBXBuildFile; fileRef = 04CBAC7219A9B786009F3D7E /* NSArray+Predicate.m */; };
 		BC42735E1A7C73B300068882 /* NSArray+PredicateTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BC8309C81A7C370B003FC5C7 /* NSArray+PredicateTests.m */; };
 		BC50C37F1A83C784006DC7AF /* WMFNetworkUtilities.m in Sources */ = {isa = PBXBuildFile; fileRef = BC50C37E1A83C784006DC7AF /* WMFNetworkUtilities.m */; };
@@ -306,6 +308,8 @@
 		BCB66A0C1A85183000C7B1FE /* NSString+WMFHTMLParsing.m in Sources */ = {isa = PBXBuildFile; fileRef = BCB66A0B1A85183000C7B1FE /* NSString+WMFHTMLParsing.m */; };
 		BCB66A0D1A85183000C7B1FE /* NSString+WMFHTMLParsing.m in Sources */ = {isa = PBXBuildFile; fileRef = BCB66A0B1A85183000C7B1FE /* NSString+WMFHTMLParsing.m */; };
 		BCB66A101A851C9B00C7B1FE /* MWKImageListTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BCB66A0F1A851C9B00C7B1FE /* MWKImageListTests.m */; };
+		BCC185D81A9E5628005378F8 /* UILabel+WMFStyling.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */; };
+		BCC185E01A9EC836005378F8 /* UIButton+FrameUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185DF1A9EC836005378F8 /* UIButton+FrameUtils.m */; };
 		BCC185E81A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */; };
 		BCC185E91A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */; };
 		C42D947E1A937DAC00A4871A /* SavedArticlesFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = C42D947D1A937DAC00A4871A /* SavedArticlesFetcher.m */; };
@@ -728,6 +732,8 @@
 		17A2F22335C5256576CEDBDD /* Pods-WikipediaUnitTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-WikipediaUnitTests.release.xcconfig"; path = "Pods/Target Support Files/Pods-WikipediaUnitTests/Pods-WikipediaUnitTests.release.xcconfig"; sourceTree = "<group>"; };
 		357504E50DA104E39C6ACFEB /* Pods.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = Pods.release.xcconfig; path = "Pods/Target Support Files/Pods/Pods.release.xcconfig"; sourceTree = "<group>"; };
 		8CE61C6963F825760822A28A /* libPods-WikipediaUnitTests.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = "libPods-WikipediaUnitTests.a"; sourceTree = BUILT_PRODUCTS_DIR; };
+		BC2CBB8C1AA10F400079A313 /* UIView+WMFFrameUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+WMFFrameUtils.h"; sourceTree = "<group>"; };
+		BC2CBB8D1AA10F400079A313 /* UIView+WMFFrameUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+WMFFrameUtils.m"; sourceTree = "<group>"; };
 		BC4273521A7C736800068882 /* WikipediaUnitTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = WikipediaUnitTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 		BC50C37D1A83C784006DC7AF /* WMFNetworkUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFNetworkUtilities.h; sourceTree = "<group>"; };
 		BC50C37E1A83C784006DC7AF /* WMFNetworkUtilities.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFNetworkUtilities.m; sourceTree = "<group>"; };
@@ -837,6 +843,10 @@
 		BCB66A0A1A85183000C7B1FE /* NSString+WMFHTMLParsing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSString+WMFHTMLParsing.h"; sourceTree = "<group>"; };
 		BCB66A0B1A85183000C7B1FE /* NSString+WMFHTMLParsing.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSString+WMFHTMLParsing.m"; sourceTree = "<group>"; };
 		BCB66A0F1A851C9B00C7B1FE /* MWKImageListTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWKImageListTests.m; sourceTree = "<group>"; };
+		BCC185D61A9E5628005378F8 /* UILabel+WMFStyling.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UILabel+WMFStyling.h"; sourceTree = "<group>"; };
+		BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UILabel+WMFStyling.m"; sourceTree = "<group>"; };
+		BCC185DE1A9EC836005378F8 /* UIButton+FrameUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIButton+FrameUtils.h"; sourceTree = "<group>"; };
+		BCC185DF1A9EC836005378F8 /* UIButton+FrameUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIButton+FrameUtils.m"; sourceTree = "<group>"; };
 		BCC185E61A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UICollectionViewFlowLayout+AttributeUtils.h"; sourceTree = "<group>"; };
 		BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UICollectionViewFlowLayout+AttributeUtils.m"; sourceTree = "<group>"; };
 		C42D947C1A937DAC00A4871A /* SavedArticlesFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SavedArticlesFetcher.h; sourceTree = "<group>"; };
@@ -1832,6 +1842,12 @@
 				BC86B93F1A929D7900B4C039 /* UICollectionViewFlowLayout+WMFItemSizeThatFits.m */,
 				BCC185E61A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.h */,
 				BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */,
+				BCC185D61A9E5628005378F8 /* UILabel+WMFStyling.h */,
+				BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */,
+				BCC185DE1A9EC836005378F8 /* UIButton+FrameUtils.h */,
+				BCC185DF1A9EC836005378F8 /* UIButton+FrameUtils.m */,
+				BC2CBB8C1AA10F400079A313 /* UIView+WMFFrameUtils.h */,
+				BC2CBB8D1AA10F400079A313 /* UIView+WMFFrameUtils.m */,
 			);
 			path = Categories;
 			sourceTree = "<group>";
@@ -2820,6 +2836,7 @@
 				BCB58F7E1A8D1B8400465627 /* MWKImageInfo+MWKImageComparisonTests.m in Sources */,
 				BC50C3841A83C96D006DC7AF /* WMFNetworkUtilities.m in Sources */,
 				BCB669F11A83F71C00C7B1FE /* MWKHistoryEntry.m in Sources */,
+				BC2CBB8F1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */,
 				BCB669EB1A83F71C00C7B1FE /* MWKUser.m in Sources */,
 				BCB669ED1A83F71C00C7B1FE /* MWKImage.m in Sources */,
 				0480AE8C1AA4E61000A9950C /* WMFOptionsFooterViewController.m in Sources */,
@@ -2931,6 +2948,7 @@
 				04142A8F184F974E006EF779 /* NSDate-Utilities.m in Sources */,
 				0487048C19F8262600B7D307 /* SearchResultFetcher.m in Sources */,
 				04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */,
+				BCC185D81A9E5628005378F8 /* UILabel+WMFStyling.m in Sources */,
 				BCB669B11A83F6C400C7B1FE /* MWKRecentSearchList.m in Sources */,
 				04DD89B118BFE63A00DD5DAD /* PreviewAndSaveViewController.m in Sources */,
 				0487048819F8262600B7D307 /* NearbyFetcher.m in Sources */,
@@ -3012,6 +3030,7 @@
 				D4991449181D51DE00E6073C /* AppDelegate.m in Sources */,
 				BCB669A81A83F6C400C7B1FE /* MWKUser.m in Sources */,
 				BCB669AB1A83F6C400C7B1FE /* MWKProtectionStatus.m in Sources */,
+				BCC185E01A9EC836005378F8 /* UIButton+FrameUtils.m in Sources */,
 				04C9509D19EF02980013F3C0 /* EventLogger.m in Sources */,
 				D4E8A8A719084F1300DA4765 /* SQLiteHelper.m in Sources */,
 				04F39590186CF80100B0D6FC /* TOCViewController.m in Sources */,
@@ -3067,6 +3086,7 @@
 				04CCCFEE1935093A00E3F60C /* SecondaryMenuRowView.m in Sources */,
 				0442F57B19006DCC00F55DF9 /* PageHistoryLabel.m in Sources */,
 				041C6206199ED2A20061516F /* MWKSection+TOC.m in Sources */,
+				BC2CBB8E1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */,
 				0447862F185145090050563B /* HistoryResultCell.m in Sources */,
 				04B0EA45190AFDD8007458AF /* ArticleImporter.m in Sources */,
 				042A5B2619253D2A0095E172 /* CenterNavController.m in Sources */,
diff --git a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia.xcscheme b/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia.xcscheme
index ba5ba7e006d..d56ad7ecf6b 100644
--- a/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia.xcscheme
+++ b/Wikipedia.xcodeproj/xcshareddata/xcschemes/Wikipedia.xcscheme
@@ -14,7 +14,7 @@
             buildForAnalyzing = "YES">
             <BuildableReference
                BuildableIdentifier = "primary"
-               BlueprintIdentifier = "03A98BDF68FB2304C1A60393"
+               BlueprintIdentifier = "8C845C5F444AC1E94546AB60"
                BuildableName = "libPods.a"
                BlueprintName = "Pods"
                ReferencedContainer = "container:Pods/Pods.xcodeproj">
@@ -122,7 +122,7 @@
       shouldUseLaunchSchemeArgsEnv = "YES"
       savedToolIdentifier = ""
       useCustomWorkingDirectory = "NO"
-      buildConfiguration = "Release"
+      buildConfiguration = "Debug"
       debugDocumentVersioning = "YES">
       <BuildableProductRunnable>
          <BuildableReference
diff --git a/wikipedia/Categories/UIButton+FrameUtils.h b/wikipedia/Categories/UIButton+FrameUtils.h
new file mode 100644
index 00000000000..11ad1c8cee2
--- /dev/null
+++ b/wikipedia/Categories/UIButton+FrameUtils.h
@@ -0,0 +1,16 @@
+//
+//  UIButton+FrameUtils.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/25/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface UIButton (FrameUtils)
+
+/// Set the receiver's size to fit the contents of the title label's intrinsic content size.
+- (void)wmf_sizeToFitLabelContents;
+
+@end
diff --git a/wikipedia/Categories/UIButton+FrameUtils.m b/wikipedia/Categories/UIButton+FrameUtils.m
new file mode 100644
index 00000000000..61b0c01f903
--- /dev/null
+++ b/wikipedia/Categories/UIButton+FrameUtils.m
@@ -0,0 +1,24 @@
+//
+//  UIButton+FrameUtils.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/25/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "UIButton+FrameUtils.h"
+#import "UIView+WMFFrameUtils.h"
+
+@implementation UIButton (FrameUtils)
+
+- (void)wmf_sizeToFitLabelContents
+{
+#if DEBUG
+    if (!UIEdgeInsetsEqualToEdgeInsets(self.titleEdgeInsets, UIEdgeInsetsZero)) {
+        NSLog(@"WARNING: non-zero edge insets on button label when trying to fit to label contents.");
+    }
+#endif
+    [self wmf_setFrameSize:[self.titleLabel intrinsicContentSize]];
+}
+
+@end
diff --git a/wikipedia/Categories/UILabel+WMFStyling.h b/wikipedia/Categories/UILabel+WMFStyling.h
new file mode 100644
index 00000000000..6f989de847d
--- /dev/null
+++ b/wikipedia/Categories/UILabel+WMFStyling.h
@@ -0,0 +1,15 @@
+//
+//  UILabel+WMFStyling.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/25/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface UILabel (WMFStyling)
+
+- (void)wmf_applyDropShadow;
+
+@end
diff --git a/wikipedia/Categories/UILabel+WMFStyling.m b/wikipedia/Categories/UILabel+WMFStyling.m
new file mode 100644
index 00000000000..0dd36c4fdc0
--- /dev/null
+++ b/wikipedia/Categories/UILabel+WMFStyling.m
@@ -0,0 +1,20 @@
+//
+//  UILabel+WMFStyling.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/25/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "UILabel+WMFStyling.h"
+
+@implementation UILabel (WMFStyling)
+
+- (void)wmf_applyDropShadow
+{
+    self.shadowColor = [UIColor blackColor];
+    self.shadowOffset = CGSizeMake(0.0, 1.0);
+    self.layer.shadowRadius = 0.5;
+}
+
+@end
diff --git a/wikipedia/Categories/UIView+WMFFrameUtils.h b/wikipedia/Categories/UIView+WMFFrameUtils.h
new file mode 100644
index 00000000000..25fdda9afdd
--- /dev/null
+++ b/wikipedia/Categories/UIView+WMFFrameUtils.h
@@ -0,0 +1,30 @@
+//
+//  UIView+WMFFrameUtils.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/27/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface UIView (WMFFrameUtils)
+
+/// Sets the receiver's @c frame.origin, preserving its @c size.
+- (void)wmf_setFrameOrigin:(CGPoint)origin;
+
+/// Sets the receiver's @c frame.size, preserving its @c origin.
+- (void)wmf_setFrameSize:(CGSize)size;
+
+/// Sets the receiver's @c frame by applying @c CGRectInset() with @c width as @c dx and @c height as @c dy.
+- (void)wmf_insetWidth:(float)width height:(float)height;
+
+/**
+ * Expand the receiver's frame while preserving its center by @c padding.
+ * @discussion This method behaves identical to inset, but positive values grow the frame, rather than shrink it.
+ * @see -wmf_insetWidth:height:
+ * @see CGRectInset()
+ */
+- (void)wmf_expandWidth:(float)width height:(float)height;
+
+@end
diff --git a/wikipedia/Categories/UIView+WMFFrameUtils.m b/wikipedia/Categories/UIView+WMFFrameUtils.m
new file mode 100644
index 00000000000..cb64416bf6d
--- /dev/null
+++ b/wikipedia/Categories/UIView+WMFFrameUtils.m
@@ -0,0 +1,33 @@
+//
+//  UIView+WMFFrameUtils.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 2/27/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "UIView+WMFFrameUtils.h"
+
+@implementation UIView (WMFFrameUtils)
+
+- (void)wmf_setFrameOrigin:(CGPoint)origin
+{
+    self.frame = (CGRect) { .origin = origin, .size = self.frame.size };
+}
+
+- (void)wmf_setFrameSize:(CGSize)size
+{
+    self.frame = (CGRect) { .origin = self.frame.origin, .size = size };
+}
+
+- (void)wmf_insetWidth:(float)width height:(float)height
+{
+    self.frame = CGRectInset(self.frame, width, height);
+}
+
+- (void)wmf_expandWidth:(float)width height:(float)height
+{
+    [self wmf_insetWidth:-width height:-height];
+}
+
+@end
diff --git a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m
index 55e82584ceb..d0e96773585 100644
--- a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m	
+++ b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m	
@@ -11,6 +11,7 @@
 #import "PaddedLabel.h"
 #import "UIFont+WMFStyle.h"
 #import "WikiGlyph_Chars.h"
+#import "UILabel+WMFStyling.h"
 
 @interface WMFImageGalleryDetailOverlayView ()
 @property (nonatomic, weak) IBOutlet UILabel *imageDescriptionLabel;
@@ -42,10 +43,14 @@ - (CAGradientLayer*)gradientLayer
 - (void)awakeFromNib
 {
     [super awakeFromNib];
-    [[self gradientLayer] setLocations:@[@0, @1]];
-    [[self gradientLayer] setColors:@[(id)[UIColor blackColor].CGColor, (id)[UIColor clearColor].CGColor]];
-    [[self gradientLayer] setStartPoint:CGPointMake(0.5, 0.7)];
+    [[self gradientLayer] setLocations:@[@0, @0.6, @1]];
+    [[self gradientLayer] setColors:@[(id)[UIColor blackColor].CGColor,
+                                      (id)[UIColor colorWithWhite:0 alpha:0.55859375].CGColor,
+                                      (id)[UIColor clearColor].CGColor]];
+    [[self gradientLayer] setStartPoint:CGPointMake(0.5, 1.0)];
     [[self gradientLayer] setEndPoint:CGPointMake(0.5, 0.0)];
+    [self.ownerButton.titleLabel wmf_applyDropShadow];
+    [self.imageDescriptionLabel wmf_applyDropShadow];
 }
 
 - (IBAction)didTapOwnerButton
diff --git a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib
index 014ee8e2cbe..096d36d7b1a 100644
--- a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib	
+++ b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib	
@@ -12,13 +12,14 @@
             <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
             <subviews>
                 <label opaque="NO" userInteractionEnabled="NO" contentMode="scaleToFill" verticalHuggingPriority="249" horizontalCompressionResistancePriority="250" verticalCompressionResistancePriority="250" placeholderIntrinsicWidth="388" placeholderIntrinsicHeight="100" text="" lineBreakMode="tailTruncation" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" preferredMaxLayoutWidth="0.0" translatesAutoresizingMaskIntoConstraints="NO" id="I6f-Vm-XuX" userLabel="Image Description">
-                    <rect key="frame" x="20" y="20" width="398" height="87"/>
-                    <fontDescription key="fontDescription" type="system" pointSize="17"/>
+                    <rect key="frame" x="20" y="20" width="398" height="95"/>
+                    <fontDescription key="fontDescription" type="system" pointSize="14"/>
                     <color key="textColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
                     <nil key="highlightedColor"/>
                 </label>
                 <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="fill" contentVerticalAlignment="fill" lineBreakMode="tailTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="l6E-b6-poB">
-                    <rect key="frame" x="20" y="115" width="398" height="34"/>
+                    <rect key="frame" x="20" y="123" width="398" height="26"/>
+                    <fontDescription key="fontDescription" type="system" pointSize="11"/>
                     <state key="normal">
                         <color key="titleColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
                         <color key="titleShadowColor" white="0.5" alpha="1" colorSpace="calibratedWhite"/>
diff --git a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m
index c1ae0b79669..7bb8f7b2e64 100644
--- a/wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m	
+++ b/wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m	
@@ -23,6 +23,9 @@
 #import "UICollectionViewFlowLayout+WMFItemSizeThatFits.h"
 #import "UIViewController+Alert.h"
 #import "UICollectionViewFlowLayout+AttributeUtils.h"
+#import "UILabel+WMFStyling.h"
+#import "UIButton+FrameUtils.h"
+#import "UIView+WMFFrameUtils.h"
 
 // Model
 #import "MWKDataStore.h"
@@ -42,179 +45,168 @@
 #define ImgGalleryLog(...)
 #endif
 
-NSDictionary* WMFIndexImageInfo(NSArray* imageInfo)
-{
-    return [imageInfo bk_index:^id<NSCopying>(MWKImageInfo* info) {
-        return info.imageAssociationValue ?: [NSNull null];
+NSDictionary* WMFIndexImageInfo(NSArray* imageInfo){
+    return [imageInfo bk_index:^id < NSCopying > (MWKImageInfo* info) {
+        return info.imageAssociationValue ? : [NSNull null];
     }];
 }
 
 @interface WMFImageGalleryViewController ()
 <UIGestureRecognizerDelegate, UICollectionViewDelegateFlowLayout>
-{
-    MWKImageInfoFetcher *_imageInfoFetcher;
-    AFHTTPRequestOperationManager *_imageFetcher;
-    NSDictionary *_indexedImageInfo;
-    NSArray *_uniqueArticleImages;
-}
 
 @property (nonatomic) BOOL didApplyInitialVisibleImageIndex;
 @property (nonatomic) NSUInteger preRotationVisibleImageIndex;
 
-@property (nonatomic, weak, readonly) UICollectionViewFlowLayout *collectionViewFlowLayout;
-@property (nonatomic, weak, readonly) UIButton *closeButton;
-@property (nonatomic, getter=isChromeHidden) BOOL chromeHidden;
-@property (nonatomic, weak, readonly) UITapGestureRecognizer *chromeTapGestureRecognizer;
+@property (nonatomic, weak, readonly) UICollectionViewFlowLayout* collectionViewFlowLayout;
+@property (nonatomic, weak, readonly) UIButton* closeButton;
+@property (nonatomic, getter = isChromeHidden) BOOL chromeHidden;
+@property (nonatomic, weak, readonly) UITapGestureRecognizer* chromeTapGestureRecognizer;
 
-@property (nonatomic, strong, readonly) AFHTTPRequestOperationManager *imageFetcher;
-@property (nonatomic, strong, readonly) MWKImageInfoFetcher *imageInfoFetcher;
+@property (nonatomic, strong, readonly) AFHTTPRequestOperationManager* imageFetcher;
+@property (nonatomic, strong, readonly) MWKImageInfoFetcher* imageInfoFetcher;
 
 /// Array of the article's images without duplicates in order of appearance.
-@property (nonatomic, strong, readonly) NSArray *uniqueArticleImages;
+@property (nonatomic, strong, readonly) NSArray* uniqueArticleImages;
 
 /// Map of canonical filenames to image info objects.
-@property (nonatomic, strong, readonly) NSDictionary *indexedImageInfo;
+@property (nonatomic, strong, readonly) NSDictionary* indexedImageInfo;
 
 /// Map of URLs to bitmaps, serves as a simple cache for uncompressed images.
 // !!!: This means we're store image data in 2 different memory locations, but we save a lot of time by not decoding
-@property (nonatomic, strong, readonly) NSMutableDictionary *bitmapsForImageURL;
+@property (nonatomic, strong, readonly) NSMutableDictionary* bitmapsForImageURL;
 
 - (MWKDataStore*)dataStore;
 
 @end
 
-static NSAttributedString* ConcatOwnerAndLicense(NSString *owner, MWKLicense *license)
-{
-    NSMutableAttributedString *result = [NSMutableAttributedString new];
-    NSString *licenseGlyph = [license toGlyph];
+static NSAttributedString* ConcatOwnerAndLicense(NSString* owner, MWKLicense* license){
+    NSMutableAttributedString* result = [NSMutableAttributedString new];
+    NSString* licenseGlyph            = [license toGlyph] ? : WIKIGLYPH_CITE;
     if (licenseGlyph) {
+        // hand-tuning glyph size & baseline offset until all glyphs are positioned & padded in a uniform way
         [result appendAttributedString:
          [[NSAttributedString alloc]
-          initWithString:[licenseGlyph stringByAppendingString:@" "]
-          attributes:@{NSFontAttributeName: [UIFont wmf_glyphFontOfSize:[UIFont labelFontSize]],
-                       NSForegroundColorAttributeName: [UIColor whiteColor]}]];
+          initWithString:licenseGlyph
+              attributes:@{NSFontAttributeName: [UIFont wmf_glyphFontOfSize:19.f],
+                           NSForegroundColorAttributeName: [UIColor whiteColor],
+                           NSBaselineOffsetAttributeName: @(-1.5f)}]];
     }
-    if (owner) {
-        [result appendAttributedString:
-         [[NSAttributedString alloc]
-          initWithString:owner
-          attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:[UIFont labelFontSize]],
+
+    [result appendAttributedString:
+     [[NSAttributedString alloc]
+      initWithString:[@" " stringByAppendingString:owner ? : MWLocalizedString(@"image-gallery-unknown-owner", nil)]
+          attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:11.f],
                        NSForegroundColorAttributeName: [UIColor whiteColor]}]];
-    }
+
     return result;
 }
 
 static NSString* const WMFImageGalleryCollectionViewCellReuseId = @"WMFImageGalleryCollectionViewCellReuseId";
 
 @implementation WMFImageGalleryViewController
+@synthesize imageInfoFetcher    = _imageInfoFetcher;
+@synthesize imageFetcher        = _imageFetcher;
+@synthesize indexedImageInfo    = _indexedImageInfo;
+@synthesize uniqueArticleImages = _uniqueArticleImages;
 
-- (instancetype)initWithArticle:(MWKArticle *)article
-{
+- (instancetype)initWithArticle:(MWKArticle*)article {
     // TODO(bgerstle): use non-zero inset, disable bouncing, and customize scroll target to land images in center
-    UICollectionViewFlowLayout *defaultLayout = [[UICollectionViewFlowLayout alloc] init];
-    defaultLayout.sectionInset = UIEdgeInsetsZero;
+    UICollectionViewFlowLayout* defaultLayout = [[UICollectionViewFlowLayout alloc] init];
+    defaultLayout.sectionInset            = UIEdgeInsetsZero;
     defaultLayout.minimumInteritemSpacing = 0.f;
-    defaultLayout.minimumLineSpacing = 0.f;
-    defaultLayout.scrollDirection = UICollectionViewScrollDirectionHorizontal;
+    defaultLayout.minimumLineSpacing      = 0.f;
+    defaultLayout.scrollDirection         = UICollectionViewScrollDirectionHorizontal;
     // itemSize is based on view bounds, so we need to wait until it is about to appear to set it
 
     self = [super initWithCollectionViewLayout:defaultLayout];
     if (self) {
-        _article = article;
+        _article            = article;
         _bitmapsForImageURL = [NSMutableDictionary dictionaryWithCapacity:[_uniqueArticleImages count]];
-        _chromeHidden = NO;
+        _chromeHidden       = NO;
     }
     return self;
 }
 
-- (BOOL)prefersStatusBarHidden
-{
+- (BOOL)prefersStatusBarHidden {
     return YES;
 }
 
-- (void)didReceiveMemoryWarning
-{
+- (void)didReceiveMemoryWarning {
     [super didReceiveMemoryWarning];
     [self.bitmapsForImageURL removeAllObjects];
 }
 
 #pragma mark - Getters
 
-- (NSArray*)uniqueArticleImages
-{
+- (NSArray*)uniqueArticleImages {
     if (!_uniqueArticleImages) {
-         _uniqueArticleImages = [self.article.images uniqueLargestVariants];
+        _uniqueArticleImages = [self.article.images uniqueLargestVariants];
     }
     return _uniqueArticleImages;
 }
 
-- (NSDictionary*)indexedImageInfo
-{
+- (NSDictionary*)indexedImageInfo {
     if (!_indexedImageInfo) {
         _indexedImageInfo = WMFIndexImageInfo([self.dataStore imageInfoForArticle:self.article]);
     }
     return _indexedImageInfo;
 }
 
-- (AFHTTPRequestOperationManager*)imageFetcher
-{
+- (AFHTTPRequestOperationManager*)imageFetcher {
     if (!_imageFetcher) {
-        _imageFetcher = [AFHTTPRequestOperationManager wmf_createDefaultManager];
+        _imageFetcher                    = [AFHTTPRequestOperationManager wmf_createDefaultManager];
         _imageFetcher.responseSerializer = [AFImageResponseSerializer serializer];
     }
     return _imageFetcher;
 }
 
-- (MWKImageInfoFetcher*)imageInfoFetcher
-{
+- (MWKImageInfoFetcher*)imageInfoFetcher {
     if (!_imageInfoFetcher) {
         _imageInfoFetcher = [[MWKImageInfoFetcher alloc] initWithDelegate:nil];
     }
     return _imageInfoFetcher;
 }
 
-- (MWKDataStore*)dataStore
-{
+- (MWKDataStore*)dataStore {
     return self.article.dataStore;
 }
 
-- (UICollectionViewFlowLayout*)collectionViewFlowLayout
-{
-    UICollectionViewFlowLayout *flowLayout = (UICollectionViewFlowLayout*)self.collectionView.collectionViewLayout;
+- (UICollectionViewFlowLayout*)collectionViewFlowLayout {
+    UICollectionViewFlowLayout* flowLayout = (UICollectionViewFlowLayout*)self.collectionView.collectionViewLayout;
     if ([flowLayout isKindOfClass:[UICollectionViewFlowLayout class]]) {
         return flowLayout;
     } else if (flowLayout) {
         [NSException raise:@"InvalidCollectionViewLayoutSubclass"
                     format:@"%@ expected %@ to be a subclass of %@",
-                            self, flowLayout, NSStringFromClass([UICollectionViewFlowLayout class])];
+         self, flowLayout, NSStringFromClass([UICollectionViewFlowLayout class])];
     }
     return nil;
 }
 
-- (NSUInteger)mostVisibleItemIndex
-{
+- (NSUInteger)mostVisibleItemIndex {
     return [self.collectionViewFlowLayout wmf_indexPathClosestToContentOffset].item;
 }
 
 #pragma mark - Networking & Persistence
 
-- (void)fetchImageInfo
-{
+- (void)fetchImageInfo {
     [[MWNetworkActivityIndicatorManager sharedManager] push];
-    AFHTTPRequestOperation *requestOperation = [self.imageInfoFetcher fetchInfoForArticle:self.article];
+    AFHTTPRequestOperation* requestOperation = [self.imageInfoFetcher fetchInfoForArticle:self.article];
     requestOperation.completionQueue = dispatch_get_main_queue();
 
-    __weak WMFImageGalleryViewController *weakSelf = self;
-    [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
+    __weak WMFImageGalleryViewController* weakSelf = self;
+    [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation* operation, id responseObject) {
         [[MWNetworkActivityIndicatorManager sharedManager] pop];
-        WMFImageGalleryViewController *strSelf = weakSelf;
-        if (!strSelf) { return; }
+        WMFImageGalleryViewController* strSelf = weakSelf;
+        if (!strSelf) {
+            return;
+        }
         // persist to disk then update UI
         [[strSelf dataStore] saveImageInfo:operation.responseObject forArticle:strSelf.article];
         [strSelf updateImageInfo:operation.responseObject];
-    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
+    } failure:^(AFHTTPRequestOperation* operation, NSError* error) {
         [[MWNetworkActivityIndicatorManager sharedManager] pop];
-        WMFImageGalleryViewController *strSelf = weakSelf;
+        WMFImageGalleryViewController* strSelf = weakSelf;
         BOOL wasCancelled = [operation.error.domain isEqualToString:NSURLErrorDomain]
                             && operation.error.code == NSURLErrorCancelled;
         if (strSelf && !wasCancelled) {
@@ -223,8 +215,7 @@ - (void)fetchImageInfo
     }];
 }
 
-- (void)updateImageInfo:(NSArray*)imageInfo
-{
+- (void)updateImageInfo:(NSArray*)imageInfo {
     _indexedImageInfo = WMFIndexImageInfo(imageInfo);
     [self.collectionView reloadItemsAtIndexPaths:self.collectionView.indexPathsForVisibleItems];
 }
@@ -232,8 +223,7 @@ - (void)updateImageInfo:(NSArray*)imageInfo
 #pragma mark - View event handling
 
 - (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation
-                                duration:(NSTimeInterval)duration
-{
+                                duration:(NSTimeInterval)duration {
     [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];
     NSUInteger const currentImageIndex = [self mostVisibleItemIndex];
     ImgGalleryLog(@"Will scroll to %u after rotation animation finishes.", currentImageIndex);
@@ -248,13 +238,12 @@ - (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrie
                      }];
 }
 
-- (void)viewDidLayoutSubviews
-{
+- (void)viewDidLayoutSubviews {
     [super viewDidLayoutSubviews];
 
     /*
-     only apply visible image index once the collection view has been populated with cells, otherwise calls to get
-     layout attributes of the item at `visibleImageIndex` will return `nil` (on iOS 6, at least)
+       only apply visible image index once the collection view has been populated with cells, otherwise calls to get
+       layout attributes of the item at `visibleImageIndex` will return `nil` (on iOS 6, at least)
      */
     if (!self.didApplyInitialVisibleImageIndex && self.collectionView.visibleCells.count) {
         [self applyVisibleImageIndex:NO];
@@ -264,54 +253,47 @@ - (void)viewDidLayoutSubviews
     }
 }
 
-//- (void)viewWillAppear:(BOOL)animated
-//{
-//    [super viewWillAppear:animated];
-//}
-
-- (void)viewDidAppear:(BOOL)animated
-{
+- (void)viewDidAppear:(BOOL)animated {
     [super viewDidAppear:animated];
     // fetch after appearing so we don't do work while the animation is rendering
     [self fetchImageInfo];
 }
 
-- (void)viewDidLoad
-{
+- (void)viewDidLoad {
     [super viewDidLoad];
 
-    // this prevents white lines from appearing during rotation animations on iOS 6
-    self.view.backgroundColor = [UIColor blackColor];
+    UIButton* closeButton = [[UIButton alloc] initWithFrame:CGRectZero];
+
+    // the title must be set first!
+    closeButton.titleLabel.font = [UIFont wmf_glyphFontOfSize:22.f];
+    [closeButton setTitle:WIKIGLYPH_X forState:UIControlStateNormal];
 
     // manually layout closeButton so we can programmatically increase it's hit size
-    NSString* closeButtonTitle = WIKIGLYPH_X;
-    UIFont* closeButtonFont = [UIFont wmf_glyphFontOfSize:[UIFont buttonFontSize]];
-    CGRect closeButtonFrame = CGRectInset((CGRect){
-                                            .origin = CGPointMake(8.f, 8.f),
-                                            .size = [closeButtonTitle sizeWithFont:closeButtonFont]
-                                          },
-                                          -15.f,
-                                          -15.f);
-    UIButton *closeButton = [[UIButton alloc] initWithFrame:closeButtonFrame];
-    closeButton.titleLabel.font = closeButtonFont;
-    [closeButton setTitle:closeButtonTitle forState:UIControlStateNormal];
-    [closeButton setTitleShadowColor:[UIColor blackColor] forState:UIControlStateNormal];
-    closeButton.titleLabel.shadowOffset = CGSizeMake(1.f, 1.f);
+    [closeButton wmf_setFrameOrigin:CGPointMake(18.f, 12.f)];
+    [closeButton wmf_sizeToFitLabelContents];
+    [closeButton wmf_expandWidth:15.f height:15.f];
+
+    // apply visual effects
     [closeButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
+    [closeButton setTitleShadowColor:[UIColor blackColor] forState:UIControlStateNormal];
+    [closeButton.titleLabel wmf_applyDropShadow];
+
+    // setup actions
     [closeButton addTarget:self
                     action:@selector(didTouchCloseButton:)
           forControlEvents:UIControlEventTouchUpInside];
+
     [self.view addSubview:closeButton];
     _closeButton = closeButton;
 
-    UITapGestureRecognizer *chromeTapGestureRecognizer =
+    UITapGestureRecognizer* chromeTapGestureRecognizer =
         [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(didTapView:)];
 
     // make sure taps don't interfere w/ other gestures
-    chromeTapGestureRecognizer.delaysTouchesBegan = NO;
-    chromeTapGestureRecognizer.delaysTouchesEnded = NO;
+    chromeTapGestureRecognizer.delaysTouchesBegan   = NO;
+    chromeTapGestureRecognizer.delaysTouchesEnded   = NO;
     chromeTapGestureRecognizer.cancelsTouchesInView = NO;
-    chromeTapGestureRecognizer.delegate = self;
+    chromeTapGestureRecognizer.delegate             = self;
 
     // NOTE(bgerstle): recognizer must be added to collection view so as to not disrupt interactions w/ overlay UI
     [self.collectionView addGestureRecognizer:chromeTapGestureRecognizer];
@@ -325,58 +307,52 @@ - (void)viewDidLoad
 
 #pragma mark - Chrome
 
-- (void)didTapView:(UITapGestureRecognizer*)sender
-{
+- (void)didTapView:(UITapGestureRecognizer*)sender {
     [self toggleChromeHidden:YES];
 }
 
-- (void)toggleChromeHidden:(BOOL)animated
-{
+- (void)toggleChromeHidden:(BOOL)animated {
     [self setChromeHidden:![self isChromeHidden] animated:animated];
 }
 
-- (void)setChromeHidden:(BOOL)hidden
-{
+- (void)setChromeHidden:(BOOL)hidden {
     [self setChromeHidden:hidden animated:NO];
 }
 
-- (void)setChromeHidden:(BOOL)hidden animated:(BOOL)animated
-{
-    if (_chromeHidden == hidden) { return; }
+- (void)setChromeHidden:(BOOL)hidden animated:(BOOL)animated {
+    if (_chromeHidden == hidden) {
+        return;
+    }
     _chromeHidden = hidden;
     [self applyChromeHidden:animated];
 }
 
-- (void)applyChromeHiddenToSubview:(UIView*)subview animated:(BOOL)animated
-{
+- (void)applyChromeHiddenToSubview:(UIView*)subview animated:(BOOL)animated {
     if (animated) {
-        CATransition *fadeAnimation = [CATransition animation];
-        fadeAnimation.type = kCATransitionFade;
+        CATransition* fadeAnimation = [CATransition animation];
+        fadeAnimation.type     = kCATransitionFade;
         fadeAnimation.duration = [CATransaction animationDuration];
         [subview.layer addAnimation:fadeAnimation forKey:@"com.wikimedia.wikipedia.imagegallery.chrome"];
     }
     [subview setHidden:[self isChromeHidden]];
 }
 
-- (void)applyChromeHidden:(BOOL)animated
-{
+- (void)applyChromeHidden:(BOOL)animated {
     [self applyChromeHiddenToSubview:self.closeButton animated:animated];
-    for (WMFImageGalleryCollectionViewCell *cell in self.collectionView.visibleCells) {
+    for (WMFImageGalleryCollectionViewCell* cell in self.collectionView.visibleCells) {
         [self applyChromeHiddenToSubview:cell.detailOverlayView animated:animated];
     }
 }
 
 #pragma mark - Dismissal
 
-- (void)didTouchCloseButton:(id)sender
-{
+- (void)didTouchCloseButton:(id)sender {
     [self dismissViewControllerAnimated:YES completion:nil];
 }
 
 #pragma mark - Visible Image Index
 
-- (void)applyVisibleImageIndex:(BOOL)animated
-{
+- (void)applyVisibleImageIndex:(BOOL)animated {
     if ([self isViewLoaded]) {
         // can't use scrollToItem because it doesn't handle post-rotation scrolling well on iOS 6
         UICollectionViewLayoutAttributes* visibleImageAttributes =
@@ -389,35 +365,32 @@ - (void)applyVisibleImageIndex:(BOOL)animated
     }
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated
-{
+- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated {
     [self setVisibleImageIndex:visibleImageIndex animated:animated forceViewUpdate:NO];
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated forceViewUpdate:(BOOL)force
-{
-    if (!force && visibleImageIndex == _visibleImageIndex) { return; }
+- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated forceViewUpdate:(BOOL)force {
+    if (!force && visibleImageIndex == _visibleImageIndex) {
+        return;
+    }
     NSParameterAssert(visibleImageIndex < self.uniqueArticleImages.count);
     _visibleImageIndex = visibleImageIndex;
     [self applyVisibleImageIndex:animated];
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex
-{
+- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex {
     [self setVisibleImageIndex:visibleImageIndex animated:NO];
 }
 
 #pragma mark - UIGestureRecognizerDelegate
 
-- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer
-        shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
-{
+- (BOOL)                             gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
+    shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer*)otherGestureRecognizer {
     return gestureRecognizer != self.chromeTapGestureRecognizer;
 }
 
-- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer
-        shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
-{
+- (BOOL)                  gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
+    shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer*)otherGestureRecognizer {
     return gestureRecognizer == self.chromeTapGestureRecognizer;
 }
 
@@ -425,33 +398,31 @@ - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer
 
 #pragma mark Delegate
 
-- (CGSize)collectionView:(UICollectionView *)collectionView
-                  layout:(UICollectionViewLayout *)collectionViewLayout
-  sizeForItemAtIndexPath:(NSIndexPath *)indexPath
-{
+- (CGSize)  collectionView:(UICollectionView*)collectionView
+                    layout:(UICollectionViewLayout*)collectionViewLayout
+    sizeForItemAtIndexPath:(NSIndexPath*)indexPath {
     return [self.collectionViewFlowLayout wmf_itemSizeThatFits:self.view.bounds.size];
 }
 
 #pragma mark DataSource
 
-- (UICollectionViewCell*)collectionView:(UICollectionView *)collectionView
-                 cellForItemAtIndexPath:(NSIndexPath *)indexPath
-{
-    WMFImageGalleryCollectionViewCell *cell =
+- (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView
+                 cellForItemAtIndexPath:(NSIndexPath*)indexPath {
+    WMFImageGalleryCollectionViewCell* cell =
         (WMFImageGalleryCollectionViewCell*)
         [collectionView dequeueReusableCellWithReuseIdentifier:WMFImageGalleryCollectionViewCellReuseId
                                                   forIndexPath:indexPath];
 
-    MWKImage *imageStub = self.uniqueArticleImages[indexPath.item];
-    MWKImageInfo *infoForImage = self.indexedImageInfo[imageStub.infoAssociationValue];
+    MWKImage* imageStub        = self.uniqueArticleImages[indexPath.item];
+    MWKImageInfo* infoForImage = self.indexedImageInfo[imageStub.infoAssociationValue];
 
     cell.detailOverlayView.hidden = [self isChromeHidden];
 
-    cell.detailOverlayView.imageDescriptionLabel.text = infoForImage.imageDescription ?: @"";
+    cell.detailOverlayView.imageDescriptionLabel.text = infoForImage.imageDescription ? : @"";
 
     [cell.detailOverlayView.ownerButton
      setAttributedTitle:ConcatOwnerAndLicense(infoForImage.owner, infoForImage.license)
-     forState:UIControlStateNormal];
+               forState:UIControlStateNormal];
 
     cell.detailOverlayView.ownerTapCallback = ^{
         [[UIApplication sharedApplication] openURL:infoForImage.license.URL];
@@ -462,19 +433,17 @@ - (UICollectionViewCell*)collectionView:(UICollectionView *)collectionView
     return cell;
 }
 
-- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
-{
+- (NSInteger)collectionView:(UICollectionView*)collectionView numberOfItemsInSection:(NSInteger)section {
     return self.uniqueArticleImages.count;
 }
 
 #pragma mark - Cell Updates
 
-- (void)updateImageAtIndexPath:(NSIndexPath*)indexPath
-{
+- (void)updateImageAtIndexPath:(NSIndexPath*)indexPath {
     NSParameterAssert(indexPath);
-    MWKImage *image = self.uniqueArticleImages[indexPath.item];
-    MWKImageInfo *infoForImage = self.indexedImageInfo[image.infoAssociationValue];
-    WMFImageGalleryCollectionViewCell *cell =
+    MWKImage* image                         = self.uniqueArticleImages[indexPath.item];
+    MWKImageInfo* infoForImage              = self.indexedImageInfo[image.infoAssociationValue];
+    WMFImageGalleryCollectionViewCell* cell =
         (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:indexPath];
     [self updateImageForCell:cell atIndexPath:indexPath image:image info:infoForImage];
 }
@@ -482,12 +451,11 @@ - (void)updateImageAtIndexPath:(NSIndexPath*)indexPath
 - (void)updateImageForCell:(WMFImageGalleryCollectionViewCell*)cell
                atIndexPath:(NSIndexPath*)indexPath
                      image:(MWKImage*)image
-                      info:(MWKImageInfo*)infoForImage
-{
+                      info:(MWKImageInfo*)infoForImage {
     NSParameterAssert(cell);
     NSParameterAssert(indexPath);
     NSParameterAssert(image);
-    UIImage *cachedBitmap = infoForImage.imageThumbURL ? self.bitmapsForImageURL[infoForImage.imageThumbURL] : nil;
+    UIImage* cachedBitmap = infoForImage.imageThumbURL ? self.bitmapsForImageURL[infoForImage.imageThumbURL] : nil;
     if (cachedBitmap) {
         ImgGalleryLog(@"Using cached bitmap for %@ at %@", infoForImage.imageThumbURL, indexPath);
         cell.image = cachedBitmap;
@@ -499,9 +467,10 @@ - (void)updateImageForCell:(WMFImageGalleryCollectionViewCell*)cell
     }
 }
 
-- (void)fetchImage:(NSURL*)imageURL forCellAtIndexPath:(NSIndexPath*)indexPath
-{
-    if (!imageURL) { return; }
+- (void)fetchImage:(NSURL*)imageURL forCellAtIndexPath:(NSIndexPath*)indexPath {
+    if (!imageURL) {
+        return;
+    }
     NSParameterAssert(indexPath);
 
     ImgGalleryLog(@"Fetching image at %@ for cell %@", imageURL.absoluteString, indexPath);
@@ -509,30 +478,32 @@ - (void)fetchImage:(NSURL*)imageURL forCellAtIndexPath:(NSIndexPath*)indexPath
     // TEMP(bgerstle): create a MWKImage record to ensure compressed image data is written to disk and cached
     [[[MWKImage alloc] initWithArticle:self.article sourceURL:imageURL.absoluteString] save];
 
-    __weak WMFImageGalleryViewController *weakSelf = self;
-    AFHTTPRequestOperation *request =
+    __weak WMFImageGalleryViewController* weakSelf = self;
+    AFHTTPRequestOperation* request                =
         [self.imageFetcher
          wmf_idempotentGET:imageURL.absoluteString
-         parameters:nil
-         success:^(AFHTTPRequestOperation *operation, UIImage *image) {
-             dispatch_async(dispatch_get_main_queue(), ^{
-                 [[MWNetworkActivityIndicatorManager sharedManager] pop];
-                 WMFImageGalleryViewController *strSelf = weakSelf;
-                 if (!strSelf) { return; }
-                 ImgGalleryLog(@"Retrieved high-res image at %@ for cell %@", imageURL, indexPath);
-                 NSCParameterAssert(image);
-                 self.bitmapsForImageURL[imageURL] = image;
-                 WMFImageGalleryCollectionViewCell *cell =
-                     (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:indexPath];
-                 cell.image = image;
-             });
-         }
-         failure:^(AFHTTPRequestOperation *operation, NSError *error) {
-             ImgGalleryLog(@"Failed to fetch image at %@ for cell %@: %@", operation.request.URL, indexPath, error);
-             dispatch_async(dispatch_get_main_queue(), ^{
-                 [[MWNetworkActivityIndicatorManager sharedManager] pop];
-             });
-         }];
+                parameters:nil
+                   success:^(AFHTTPRequestOperation* operation, UIImage* image) {
+                       dispatch_async(dispatch_get_main_queue(), ^{
+            [[MWNetworkActivityIndicatorManager sharedManager] pop];
+            WMFImageGalleryViewController* strSelf = weakSelf;
+            if (!strSelf) {
+                return;
+            }
+            ImgGalleryLog(@"Retrieved high-res image at %@ for cell %@", imageURL, indexPath);
+            NSCParameterAssert(image);
+            self.bitmapsForImageURL[imageURL] = image;
+            WMFImageGalleryCollectionViewCell* cell =
+                (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:indexPath];
+            cell.image = image;
+        });
+                   }
+                   failure:^(AFHTTPRequestOperation* operation, NSError* error) {
+                       ImgGalleryLog(@"Failed to fetch image at %@ for cell %@: %@", operation.request.URL, indexPath, error);
+                       dispatch_async(dispatch_get_main_queue(), ^{
+            [[MWNetworkActivityIndicatorManager sharedManager] pop];
+        });
+                   }];
 
     if (request) {
         // request will be nil if no request was sent (if another operation is already requesting the specified image)
diff --git a/wikipedia/en.lproj/Localizable.strings b/wikipedia/en.lproj/Localizable.strings
index c2c6fa0a6ba..2bd166a761f 100644
--- a/wikipedia/en.lproj/Localizable.strings
+++ b/wikipedia/en.lproj/Localizable.strings
@@ -279,3 +279,5 @@
 "nearby-wifi" = "Enabling Wi-Fi can help your device better determine your location.";
 
 "update-progress-label" = "Upgrading local data";
+
+"image-gallery-unknown-owner" = "Uploader unknown.";
\ No newline at end of file
diff --git a/wikipedia/qqq.lproj/Localizable.strings b/wikipedia/qqq.lproj/Localizable.strings
index 5fd396905a6..c4129a3d56b 100644
--- a/wikipedia/qqq.lproj/Localizable.strings
+++ b/wikipedia/qqq.lproj/Localizable.strings
@@ -252,3 +252,4 @@
 "nearby-location-general-error" = "General location determination error message";
 "nearby-wifi" = "Alert text telling user how to improve location accuracy";
 "update-progress-label" = "Label shown during automatic upgrade of local data to new internal format. May be on screen very briefly or for a few seconds.";
+"image-gallery-unknown-owner" = "Fallback text for when an item in the image gallery doesn't have a specified owner.";
\ No newline at end of file
