diff --git a/Wikipedia/UI-V5/WMFArticleContainerViewController+TOC.swift b/Wikipedia/UI-V5/WMFArticleContainerViewController+TOC.swift
index ea01f31a948..ecbc84d5029 100644
--- a/Wikipedia/UI-V5/WMFArticleContainerViewController+TOC.swift
+++ b/Wikipedia/UI-V5/WMFArticleContainerViewController+TOC.swift
@@ -16,7 +16,8 @@ extension WMFArticleContainerViewController : WMFTableOfContentsViewControllerDe
         dispatchOnMainQueueAfterDelayInSeconds(0.25) {
             self.dismissViewControllerAnimated(true, completion: nil)
             if let section = item as? MWKSection {
-                self.webViewController.scrollToSection(section)
+                // HAX: webview has issues scrolling when browser view is out of bounds, disable animation if needed
+                self.webViewController.scrollToSection(section, animated: self.webViewController.isWebContentVisible)
             } else if let footerItem = item as? TableOfContentsFooterItem {
                 self.webViewController.scrollToFooterAtIndex(UInt(footerItem.footerViewIndex.rawValue))
             } else {
diff --git a/Wikipedia/View Controllers/WebView/WebViewController.h b/Wikipedia/View Controllers/WebView/WebViewController.h
index 9878bfd1260..38a2f6e88b7 100644
--- a/Wikipedia/View Controllers/WebView/WebViewController.h	
+++ b/Wikipedia/View Controllers/WebView/WebViewController.h	
@@ -28,14 +28,50 @@ NS_ASSUME_NONNULL_BEGIN
  */
 @property (nonatomic, strong, nonnull, readonly) NSString* selectedText;
 
+/**
+ *  Animates the scroll view to the given fragment in the browser view.
+ *
+ *  @param fragment The fragment to scroll to.
+ *
+ *  @see scrollToFragment:animated:
+ */
 - (void)scrollToFragment:(NSString*)fragment;
 
-- (void)scrollToSection:(MWKSection*)section;
+/**
+ *  Scroll to the given fragment in the browser view.
+ *
+ *  @param fragment The fragment to scroll to.
+ *  @param animated Whether or not to animate
+ */
+- (void)scrollToFragment:(NSString*)fragment animated:(BOOL)animated;
+
+/**
+ *  Scroll to the @c anchor of the given section.
+ *
+ *  @param section  The section to scroll to.
+ *  @param animated Whether or not to animate.
+ *
+ *  @see scrollToFragment:animated:
+ */
+- (void)scrollToSection:(MWKSection*)section animated:(BOOL)animated;
+
 - (nullable MWKSection*)currentVisibleSection;
 
 - (void)scrollToVerticalOffset:(CGFloat)offset;
 - (CGFloat)currentVerticalOffset;
 
+/**
+ *  Check if web content is visible.
+ *
+ *  Queries the internal browser view to see if it's within its scroll view's content frame.
+ *
+ *  @warning This is only intended to be used for workarounds related to internal browser view behavior, only use
+ *           if no other options are available.
+ *
+ *  @return Whether or not the receiver's internal browser view is visible.
+ */
+@property (nonatomic, assign, readonly) BOOL isWebContentVisible;
+
 #pragma mark - Header & Footers
 
 /**
diff --git a/Wikipedia/View Controllers/WebView/WebViewController.m b/Wikipedia/View Controllers/WebView/WebViewController.m
index 007ccad8f22..4b56697206c 100644
--- a/Wikipedia/View Controllers/WebView/WebViewController.m	
+++ b/Wikipedia/View Controllers/WebView/WebViewController.m	
@@ -372,10 +372,19 @@ - (CGFloat)clientBoundingRectVerticalOffset {
 }
 
 - (void)scrollToFragment:(NSString*)fragment {
+    [self scrollToFragment:fragment animated:YES];
+}
+
+- (void)scrollToFragment:(NSString*)fragment animated:(BOOL)animated {
     if (fragment.length == 0) {
         // No section so scroll to top. (Used when "Introduction" is selected.)
-        [self.webView.scrollView scrollRectToVisible:CGRectMake(0, 1, 1, 1) animated:YES];
+        [self.webView.scrollView scrollRectToVisible:CGRectMake(0, 1, 1, 1) animated:animated];
     } else {
+        if (!animated) {
+            [self.webView.wmf_javascriptContext.globalObject invokeMethod:@"scrollToFragment"
+                                                            withArguments:@[fragment]];
+            return;
+        }
         CGRect r = [self.webView getScreenRectForHtmlElementWithId:fragment];
         if (!CGRectIsNull(r)) {
             CGPoint elementOrigin =
@@ -386,8 +395,8 @@ - (void)scrollToFragment:(NSString*)fragment {
     }
 }
 
-- (void)scrollToSection:(MWKSection*)section {
-    [self scrollToFragment:section.anchor];
+- (void)scrollToSection:(MWKSection*)section animated:(BOOL)animated {
+    [self scrollToFragment:section.anchor animated:animated];
 }
 
 - (nullable MWKSection*)currentVisibleSection {
@@ -405,6 +414,10 @@ - (CGFloat)currentVerticalOffset {
     return self.webView.scrollView.contentOffset.y;
 }
 
+- (BOOL)isWebContentVisible {
+    return CGRectIntersectsRect(self.webView.scrollView.wmf_contentFrame, self.webView.wmf_browserView.frame);
+}
+
 - (BOOL)rectIntersectsWebViewTop:(CGRect)rect {
     CGFloat elementScreenYOffset =
         rect.origin.y - self.webView.scrollView.contentOffset.y + rect.size.height;
