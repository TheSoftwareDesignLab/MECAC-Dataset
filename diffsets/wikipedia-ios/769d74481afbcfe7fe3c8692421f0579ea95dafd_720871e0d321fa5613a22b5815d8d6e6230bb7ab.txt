diff --git a/Widgets/Widgets/OnThisDayWidget.swift b/Widgets/Widgets/OnThisDayWidget.swift
index 07cce1bba50..d42ae8902de 100644
--- a/Widgets/Widgets/OnThisDayWidget.swift
+++ b/Widgets/Widgets/OnThisDayWidget.swift
@@ -38,7 +38,14 @@ struct OnThisDayProvider: TimelineProvider {
     func getTimeline(in context: Context, completion: @escaping (Timeline<OnThisDayEntry>) -> Void) {
         dataStore.fetchLatestAvailableOnThisDayEntry { entry in
             let currentDate = Date()
-            let timeline = Timeline(entries: [entry], policy: .after(currentDate.dateAtMidnight() ?? currentDate))
+            let nextUpdate: Date
+            if entry.error == nil {
+                nextUpdate = currentDate.dateAtMidnight() ?? currentDate
+            } else {
+                let components = DateComponents(hour: 2)
+                nextUpdate = Calendar.current.date(byAdding: components, to: currentDate) ?? currentDate
+            }
+            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
             completion(timeline)
         }
     }
diff --git a/Widgets/Widgets/PictureOfTheDayWidget.swift b/Widgets/Widgets/PictureOfTheDayWidget.swift
index 510f59630ac..1c30a0166f6 100644
--- a/Widgets/Widgets/PictureOfTheDayWidget.swift
+++ b/Widgets/Widgets/PictureOfTheDayWidget.swift
@@ -187,7 +187,15 @@ struct PictureOfTheDayProvider: TimelineProvider {
 	func getTimeline(in context: Context, completion: @escaping (Timeline<PictureOfTheDayEntry>) -> Void) {
 		dataStore.fetchLatestAvailablePictureEntry { entry in
 			let currentDate = Date()
-			let timeline = Timeline(entries: [entry], policy: .after(currentDate.dateAtMidnight() ?? currentDate))
+            let nextUpdate: Date
+            let isError = (entry.imageDescription == dataStore.sampleEntry.imageDescription)
+            if !isError {
+                nextUpdate = currentDate.dateAtMidnight() ?? currentDate
+            } else {
+                let components = DateComponents(hour: 2)
+                nextUpdate = Calendar.current.date(byAdding: components, to: currentDate) ?? currentDate
+            }
+            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
 			completion(timeline)
 		}
 	}
diff --git a/Widgets/Widgets/TopReadWidget.swift b/Widgets/Widgets/TopReadWidget.swift
index c1111d2ea41..c655bbd6f06 100644
--- a/Widgets/Widgets/TopReadWidget.swift
+++ b/Widgets/Widgets/TopReadWidget.swift
@@ -162,7 +162,16 @@ struct TopReadProvider: TimelineProvider {
 
 	func getTimeline(in context: Context, completion: @escaping (Timeline<TopReadEntry>) -> Void) {
 		dataStore.fetchLatestAvailableTopRead { entry in
-			let timeline = Timeline(entries: [entry], policy: .atEnd)
+            let timeline: Timeline<TopReadEntry>
+            let isError = (entry.groupURL == nil)
+            if !isError {
+                timeline = Timeline(entries: [entry], policy: .atEnd)
+            } else {
+                let currentDate = Date()
+                let components = DateComponents(hour: 2)
+                let nextUpdate = Calendar.current.date(byAdding: components, to: currentDate) ?? currentDate
+                timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
+            }
 			completion(timeline)
 		}
 	}
