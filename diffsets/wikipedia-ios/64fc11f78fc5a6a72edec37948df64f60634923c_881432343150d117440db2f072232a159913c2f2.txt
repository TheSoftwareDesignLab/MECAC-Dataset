diff --git a/Wikipedia-iOS/Categories/UIWebView+ElementLocation.h b/Wikipedia-iOS/Categories/UIWebView+ElementLocation.h
index 179be13b7c0..907edd07c12 100644
--- a/Wikipedia-iOS/Categories/UIWebView+ElementLocation.h
+++ b/Wikipedia-iOS/Categories/UIWebView+ElementLocation.h
@@ -11,4 +11,6 @@
 - (CGPoint)getScreenCoordsForHtmlImageWithSrc:(NSString *)src;
 - (CGPoint)getWebViewCoordsForHtmlImageWithSrc:(NSString *)src;
 
+- (NSInteger)getIndexOfTopOnScreenElementWithPrefix:(NSString *)prefix count:(NSUInteger)count;
+
 @end
diff --git a/Wikipedia-iOS/Categories/UIWebView+ElementLocation.m b/Wikipedia-iOS/Categories/UIWebView+ElementLocation.m
index a3cf238e717..89228e57ff8 100644
--- a/Wikipedia-iOS/Categories/UIWebView+ElementLocation.m
+++ b/Wikipedia-iOS/Categories/UIWebView+ElementLocation.m
@@ -16,6 +16,12 @@ - (CGPoint)getScreenCoordsForHtmlImageWithSrc:(NSString *)src
     NSString *top = (NSString *)jsonDict[@"top"];
     NSString *left = (NSString *)jsonDict[@"left"];
     
+    void (^zeroOutNulls)(NSString **) = ^(NSString **str){
+        if ([*str isMemberOfClass:[NSNull class]]) *str = @"0";
+    };
+    zeroOutNulls(&top);
+    zeroOutNulls(&left);
+
     return CGPointMake(left.floatValue, top.floatValue);
 }
 
@@ -36,12 +42,21 @@ - (CGRect)getScreenRectForHtmlElementWithId:(NSString *)elementId
     if (jsonString.length == 0) return CGRectNull;
     NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
     NSError *error = nil;
-    NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&error];
+    NSMutableDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&error];
     if (error) return CGRectNull;
+    
     NSString *top = (NSString *)jsonDict[@"top"];
     NSString *left = (NSString *)jsonDict[@"left"];
     NSString *width = (NSString *)jsonDict[@"width"];
     NSString *height = (NSString *)jsonDict[@"height"];
+
+    void (^zeroOutNulls)(NSString **) = ^(NSString **str){
+        if ([*str isMemberOfClass:[NSNull class]]) *str = @"0";
+    };
+    zeroOutNulls(&top);
+    zeroOutNulls(&left);
+    zeroOutNulls(&width);
+    zeroOutNulls(&height);
     
     return CGRectMake(left.floatValue, top.floatValue, width.floatValue, height.floatValue);
 }
@@ -57,4 +72,14 @@ - (CGRect)getWebViewRectForHtmlElementWithId:(NSString *)elementId
     return r;
 }
 
+- (NSInteger)getIndexOfTopOnScreenElementWithPrefix:(NSString *)prefix count:(NSUInteger)count
+{
+    // Checks all html elements in the web view which have id's of format prefix string followed
+    // by count index (if prefix is "things_" and count is 3 it will check "thing_0", "thing_1"
+    // and "thing_2") to see if they are onscreen. Returns index of first one found to be so.
+    NSString *strToEval = [NSString stringWithFormat:@"getIndexOfFirstOnScreenElementWithTopGreaterThanY('%@', %lu, %f);", prefix, (unsigned long)count, self.scrollView.contentOffset.y];
+    NSString *result = [self stringByEvaluatingJavaScriptFromString:strToEval];
+    return (result) ? result.integerValue : -1;
+}
+
 @end
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.h b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.h
index 0c04ce81ef3..566a2e89e29 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.h	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.h	
@@ -10,4 +10,8 @@
 @property (nonatomic) BOOL isHighlighted;
 @property (nonatomic) BOOL isSelected;
 
+-(void)resetSectionImageViewsBorderStyle;
+
+-(NSArray *)imagesIntersectingYOffset:(CGFloat)yOffset inView:(UIView *)view;
+
 @end
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m
index 00da1c7fdc2..e32e947b676 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m	
@@ -18,6 +18,10 @@ @interface TOCSectionCellView(){
 @property (nonatomic) CGFloat imageIndentMarginMin;
 @property (nonatomic) CGFloat imageMargin;
 @property (nonatomic) CGSize imageSize;
+@property (nonatomic, retain) NSNumber *tocLevel;
+
+@property (strong, nonatomic) NSMutableArray *imageViewsConstraints;
+@property (strong, nonatomic) NSMutableArray *titleLabelConstraints;
 
 @end
 
@@ -27,17 +31,19 @@ - (id)init
 {
     self = [super init];
     if (self) {
+        self.tocLevel = @(0);
         self.sectionId = nil;
         self.sectionImageIds = @[];
+        
+        self.imageViewsConstraints = [@[]mutableCopy];
+        self.titleLabelConstraints = [@[]mutableCopy];
+        
         self.titleLabel = [[UILabel alloc] init];
+        //self.titleLabel.layer.borderWidth = 1.0f;
         self.sectionImageViews = [@[] mutableCopy];
         self.titleLabel.translatesAutoresizingMaskIntoConstraints = NO;
         self.titleLabel.numberOfLines = 10;
         [self addSubview:self.titleLabel];
-        [self constrainTitleLabel];
-
-        //self.layer.borderWidth = 1.0f / [UIScreen mainScreen].scale;
-        //self.layer.borderColor = [UIColor colorWithWhite:1.0f alpha:0.3f].CGColor;
         
         self.indentMargin = 0.0f;
         self.indentMarginMin = 6.0f;
@@ -49,10 +55,12 @@ - (id)init
         self.imageSize = CGSizeMake(60.0f, 40.0f);
 
         self.isHighlighted = NO;
-        self.isSelected = NO;
         
         self.clipsToBounds = YES;
-        
+
+        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.7];
+
+        //self.layer.borderColor = [UIColor colorWithWhite:1.0f alpha:0.3f].CGColor;
         //self.layer.borderWidth = 1.0 / [UIScreen mainScreen].scale;
     }
     return self;
@@ -60,40 +68,17 @@ - (id)init
 
 -(void)setIsHighlighted:(BOOL)isHighlighted
 {
-    //self.alpha = (isHighlighted) ? 0.0f : 1.0f;
-    //self.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8];
-
     if (isHighlighted) {
-        self.backgroundColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:0.8];
-        //self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
-        //self.layer.borderColor = [UIColor colorWithWhite:1.0 alpha:1.0].CGColor;
-        //self.layer.borderWidth = 1.0 / [UIScreen mainScreen].scale;
+        self.titleLabel.textColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0];
     }else{
-        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.7];
-        //self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
-        //self.layer.borderColor = [UIColor colorWithWhite:0.0 alpha:1.0].CGColor;
-        //self.layer.borderWidth = 0.0;
+        self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
     }
-    if (!isHighlighted) self.isSelected = NO;
+    
     if (isHighlighted) self.alpha = 1.0f;
     
     _isHighlighted = isHighlighted;
 }
 
--(void)setIsSelected:(BOOL)isSelected
-{
-    if (isSelected) {
-        //self.layer.borderColor = [UIColor colorWithWhite:1.0 alpha:1.0].CGColor;
-        self.titleLabel.textColor = [UIColor colorWithWhite:0.0 alpha:1.0];
-    }else{
-        //self.layer.borderColor = [UIColor clearColor].CGColor;
-        self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
-    }
-    if (isSelected) self.alpha = 1.0f;
-
-    _isSelected = isSelected;
-}
-
 -(void)setSectionId:(NSManagedObjectID *)sectionId
 {
     if (sectionId) {
@@ -101,15 +86,16 @@ -(void)setSectionId:(NSManagedObjectID *)sectionId
         Section *section = (Section *)[articleDataContext_.mainContext objectWithID:sectionId];
         
         self.tag = section.index.integerValue;
-        
-        [self indentTitleLabel: section.tocLevel];
 
         self.titleLabel.text = (section.index.integerValue == 0) ? section.article.title : section.title;
         
+        // Add tocLevel for debugging.
+        //self.titleLabel.text = [NSString stringWithFormat:@"%@-%@ : %@", section.index, section.tocLevel, self.titleLabel.text];
+        
         if (section.index.integerValue == 0) {
-            self.titleLabel.font = [UIFont fontWithName:@"Georgia-Bold" size:22];
+            self.titleLabel.font = [UIFont fontWithName:@"Georgia" size:24];
         }else{
-            self.titleLabel.font = [UIFont fontWithName:@"Georgia-Bold" size:17];
+            self.titleLabel.font = [UIFont fontWithName:@"Georgia" size:18];
         }
         
         // Remove previous images.
@@ -118,9 +104,14 @@ -(void)setSectionId:(NSManagedObjectID *)sectionId
 
         if (self.sectionImageIds.count > 0) {
             [self addSectionImageViews];
-            // Constrain section images
-            [self constrainSectionImages:section.tocLevel];
+            [self resetSectionImageViewsBorderStyle];
         }
+//TODO: if section index is 0 tack a toggle view on top of it (on right side) then hook up to animate changes to
+// label and image constraints to provide for switching between current layout and a larger vertically stacked
+// image layout and another layout with just a single tiny thumbnail (from 1st img) to left of section title w/
+// section title tabbed over at tocLevel.
+        self.tocLevel = section.tocLevel;
+
     }else{
         self.titleLabel.text = @"";
     }
@@ -128,11 +119,19 @@ -(void)setSectionId:(NSManagedObjectID *)sectionId
     _sectionId = sectionId;
 }
 
+-(void)resetSectionImageViewsBorderStyle
+{
+//TODO: create object for section images so things like their highlighted state can be more easily managed/encapsulated.
+    for (UIView *i in self.sectionImageViews) {
+        i.layer.borderColor = [UIColor whiteColor].CGColor;
+        //i.layer.borderWidth = 1.0f / [UIScreen mainScreen].scale;
+        //i.layer.cornerRadius = 80.0f;
+    }
+}
+
 -(void)addSectionImageViews
 {
     ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
-    UIColor *borderColor = [UIColor colorWithWhite:1.0 alpha:1.0];
-    
     // Add section images
     NSUInteger i = 0;
     for (NSManagedObjectID *sectionImageId in self.sectionImageIds) {
@@ -143,10 +142,10 @@ -(void)addSectionImageViews
         i++;
         imageView.contentMode = UIViewContentModeScaleAspectFill;
         imageView.clipsToBounds = YES;
-        imageView.layer.borderColor = borderColor.CGColor;
-        imageView.layer.borderWidth = 1.0f / [UIScreen mainScreen].scale;
-        imageView.layer.cornerRadius = 0.0f;
         imageView.userInteractionEnabled = YES;
+
+        imageView.layer.borderWidth = 4.0 / [UIScreen mainScreen].scale;
+
         // Needed because sometimes these images have transparency.
         imageView.backgroundColor = [UIColor colorWithWhite:1.0f alpha:0.5f];
         
@@ -157,42 +156,46 @@ -(void)addSectionImageViews
     }
 }
 
--(void)indentTitleLabel:(NSNumber *)tocLevel
+-(void)updateConstraints
 {
-    for (NSLayoutConstraint *c in self.constraints) {
-        if ((c.firstItem == self.titleLabel) && (c.firstAttribute == NSLayoutAttributeLeft)) {
-            c.constant = (tocLevel.floatValue * self.indentMargin) + self.indentMarginMin;
-            break;
-        }
-    }
+    [self removeConstraints:self.constraints];
+    [self constrainTitleLabel:self.tocLevel];
+    [self constrainSectionImages:self.tocLevel];
+    
+    [super updateConstraints];
 }
 
 -(void)constrainSectionImages:(NSNumber *)tocLevel
 {
-    NSLayoutConstraint *titleLabelBottomConstraint = nil;
-    for (NSLayoutConstraint *c in self.constraints) {
-        if ((c.firstItem == self.titleLabel) && (c.firstAttribute == NSLayoutAttributeBottom)) {
-            titleLabelBottomConstraint = c;
-            break;
+    [self removeConstraints:self.imageViewsConstraints];
+    
+    if(self.sectionImageViews.count > 0){
+        NSLayoutConstraint *titleLabelBottomConstraint = nil;
+        for (NSLayoutConstraint *c in self.constraints) {
+            if ((c.firstItem == self.titleLabel) && (c.firstAttribute == NSLayoutAttributeBottom)) {
+                titleLabelBottomConstraint = c;
+                break;
+            }
         }
+        [self removeConstraint:titleLabelBottomConstraint];
     }
-    
-    [self removeConstraint:titleLabelBottomConstraint];
-    
 
     void (^constrain)(UIView *, NSLayoutAttribute, UIView *, NSLayoutAttribute, CGFloat) = ^void(UIView *view1, NSLayoutAttribute a1, UIView *view2, NSLayoutAttribute a2, CGFloat constant) {
-        [self addConstraint:
-         [NSLayoutConstraint constraintWithItem: view1
+        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem: view1
                                       attribute: a1
                                       relatedBy: NSLayoutRelationEqual
                                          toItem: view2
                                       attribute: a2
                                      multiplier: 1.0
-                                       constant: constant]];
+                                       constant: constant];
+        [self addConstraint:constraint];
+        [self.imageViewsConstraints addObject:constraint];
     };
 
     UIImageView *prevImage = nil;
     for (UIImageView *imageView in self.sectionImageViews) {
+
+        // Default layout with horizontal row of images beneath title label.
         constrain(imageView, NSLayoutAttributeBottom, self, NSLayoutAttributeBottom, -self.imageMargin);
         constrain(imageView, NSLayoutAttributeWidth, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.width);
         constrain(imageView, NSLayoutAttributeHeight, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.height);
@@ -204,33 +207,68 @@ -(void)constrainSectionImages:(NSNumber *)tocLevel
             constrain(imageView, NSLayoutAttributeLeft, prevImage, NSLayoutAttributeRight, self.imageMargin);
         }
         prevImage = imageView;
+
+//TODO: hook up swapping out the constraints above to the constraits below to a toggle. Animate the transistion.
+        continue;
+        
+        // Layout with vertically stacked image beneath title layout.
+        self.imageSize = CGSizeMake(160.0f, 160.0f);
+        constrain(imageView, NSLayoutAttributeRight, self, NSLayoutAttributeRight, -self.imageMargin);
+        constrain(imageView, NSLayoutAttributeWidth, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.width);
+        constrain(imageView, NSLayoutAttributeHeight, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.height);
+        if (self.sectionImageViews.firstObject == imageView) {
+            constrain(imageView, NSLayoutAttributeTop, self.titleLabel, NSLayoutAttributeBottom, 0);
+        }
+        if (self.sectionImageViews.lastObject == imageView) {
+            constrain(imageView, NSLayoutAttributeBottom, self, NSLayoutAttributeBottom, -self.imageMargin);
+        }
+        if (prevImage) {
+            constrain(imageView, NSLayoutAttributeTop, prevImage, NSLayoutAttributeBottom, self.imageMargin);
+        }
+        prevImage = imageView;
     }
 }
 
--(void)constrainTitleLabel
+-(void)constrainTitleLabel:(NSNumber *)tocLevel
 {
+    [self removeConstraints:self.titleLabelConstraints];
     void (^constrainTitleLabel)(NSLayoutAttribute, CGFloat) = ^void(NSLayoutAttribute a, CGFloat constant) {
-        [self addConstraint:
-         [NSLayoutConstraint constraintWithItem: self.titleLabel
+        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem: self.titleLabel
                                       attribute: a
                                       relatedBy: NSLayoutRelationEqual
                                          toItem: self
                                       attribute: a
                                      multiplier: 1.0
-                                       constant: constant]];
+                                       constant: constant];
+
+        [self addConstraint:constraint];
+        [self.titleLabelConstraints addObject:constraint];
     };
     
-    constrainTitleLabel(NSLayoutAttributeLeft, 0);
+    NSInteger tocLevelToUse = ((self.tocLevel.intValue - 1) < 0) ? 0 : self.tocLevel.intValue - 1;
+    constrainTitleLabel(NSLayoutAttributeLeft, (tocLevelToUse * self.indentMargin) + self.indentMarginMin);
     constrainTitleLabel(NSLayoutAttributeRight, -5);
     constrainTitleLabel(NSLayoutAttributeTop, 0);
     constrainTitleLabel(NSLayoutAttributeBottom, 0);
     
-    [self addConstraints:
-     [NSLayoutConstraint constraintsWithVisualFormat: @"V:[titleLabel(>=50)]"
+    NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat: @"V:[titleLabel(>=50)]"
                                              options: 0
                                              metrics: 0
-                                               views: @{@"titleLabel": self.titleLabel}]];
+                                               views: @{@"titleLabel": self.titleLabel}];
+    [self addConstraints:constraints];
+    [self.titleLabelConstraints addObjectsFromArray:constraints];
+}
 
+-(NSArray *)imagesIntersectingYOffset:(CGFloat)yOffset inView:(UIView *)view;
+{
+    NSMutableArray *imagesIntersectingYOffset = [@[] mutableCopy];
+    for (UIView *v in self.sectionImageViews) {
+        CGPoint p = [v convertPoint:CGPointZero toView:view];
+        if ((p.y < yOffset) && ((p.y + v.frame.size.height) > yOffset)) {
+            [imagesIntersectingYOffset addObject:v];
+        }
+    }
+    return imagesIntersectingYOffset;
 }
 
 /*
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m
index 1628c1d923c..06c2c71a6b6 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m	
@@ -39,7 +39,7 @@ - (void)viewDidLoad
 
     // If this is YES the focal cell's selection will be scrolled to when the TOC stops sliding.
     // If this is NO the focal cell's section will be jumped to as soon as cell becomes focal.
-    self.animateWebScrollAsFocalCellChanges = YES;
+    self.animateWebScrollAsFocalCellChanges = NO;
  
     self.sectionIds = [@[]mutableCopy];
     self.sectionImageIds = [@{} mutableCopy];
@@ -48,8 +48,6 @@ - (void)viewDidLoad
     [self.scrollView setShowsHorizontalScrollIndicator:NO];
     [self.scrollView setShowsVerticalScrollIndicator:NO];
 
-    self.scrollView.delegate = self;
-
     // Get data for sections and section images.
     [self getSectionIds];
     [self getSectionImageIds];
@@ -60,8 +58,6 @@ - (void)viewDidLoad
         [self.scrollContainer addSubview:cell];
     }
     
-    [self constrainSectionCells];
-
     self.view.translatesAutoresizingMaskIntoConstraints = NO;
 
     self.navigationItem.hidesBackButton = YES;
@@ -76,23 +72,64 @@ - (void)viewDidLoad
     self.scrollContainer.backgroundColor = [UIColor clearColor];
 }
 
-#pragma mark Constrain scroll container
+-(void)viewWillAppear:(BOOL)animated
+{
+    [super viewWillAppear:animated];
 
--(void)constrainScrollContainer
+    //WebViewController *webVC = (WebViewController *)self.parentViewController;
+
+//TODO: Need to remove and reset these web view animations on rotate before using them.
+/*
+ Have the web view controller do this after rotate conditionally if it sees these animations
+ are in effect - for it to do this the shrinkReset and skewReset methods would need to
+ remove animations for keys WEBVIEW_SHRINK and WEBVIEW_SKEW once they finish resetting.
+ This way the webVC can know if either of these animations are in effect by just looking
+ for animations for these keys.
+*/
+    //[webVC shrinkAndAlignRightWithScale:0.6f];
+    //[webVC skewWithEyePosition:-2000.0f angle:7.5f];
+
+    if (self.sectionCells.count == 0) return;
+    
+    // Temporarily set content insets to allow top cell to be completely off bottom of screen.
+    [self insetToRestrictScrollingToHeight:@(self.scrollView.frame.size.height)];
+
+    // Move all cells just off bottom of screen.
+    [self setScrollViewContentOffset:CGPointMake(0.0f, -self.scrollView.frame.size.height)];
+
+    [self updateHighlightedCellToReflectWebView];
+}
+
+-(void)viewWillDisappear:(BOOL)animated
 {
-    [self.scrollContainer.superview addConstraint:
-     [NSLayoutConstraint constraintWithItem: self.scrollContainer
-                                  attribute: NSLayoutAttributeWidth
-                                  relatedBy: NSLayoutRelationEqual
-                                     toItem: self.scrollContainer.superview
-                                  attribute: NSLayoutAttributeWidth
-                                 multiplier: 1.0
-                                   constant: 0]];
+    [super viewWillDisappear:animated];
+
+    //WebViewController *webVC = (WebViewController *)self.parentViewController;
+    //[webVC shrinkReset];
+    //[webVC skewReset];
+}
+
+-(void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
+{
+    [self scrollHighlightedCellToScreenCenter];
+    [self cascadeSectionCellsAlphaFromMiddle];
+}
+
+-(void)viewDidAppear:(BOOL)animated
+{
+    [super viewDidAppear:animated];
+    
+    // Don't start monitoring scrollView scrolling until view has appeared.
+    self.scrollView.delegate = self;
+
+    [self scrollHighlightedCellToScreenCenter];
+
+    [self cascadeSectionCellsAlphaFromMiddle];
 }
 
 #pragma mark Data retrieval
 
-//TODO: these 2 methods have a lot in common...
+//TODO: these 2 methods have a lot in common... refactor and stuff.
 
 -(void) getSectionIds
 {
@@ -146,12 +183,6 @@ -(void)tocTapped:(id)sender
     [self performSelector:@selector(hideTOC) withObject:nil afterDelay:0.15f];
 }
 
--(void)hideScrollingOffScreenBottom
-{
-    CGPoint p = CGPointMake(0.0f, -self.scrollView.frame.size.height);
-    [self.scrollView setContentOffset:p animated:YES];
-}
-
 -(void)hideTOC
 {
     [self.view removeFromSuperview];
@@ -166,35 +197,34 @@ -(void)navigateToSelection:(UITapGestureRecognizer *)sender
     UIView *view = tapRecognizer.view;
     CGPoint loc = [tapRecognizer locationInView:view];
     UIView *subview = [view hitTest:loc withEvent:nil];
+
     if ([subview isMemberOfClass:[UIImageView class]]) {
-        [self scrollWebViewToImageForCell:(UIImageView *)subview animated:YES];
+        if ([subview.superview isMemberOfClass:[TOCSectionCellView class]]) {
+            TOCSectionCellView *cell = (TOCSectionCellView*)subview.superview;
+            cell.isHighlighted = YES;
+        }
+
+        [self scrollWebViewToImageForCell:(UIImageView *)subview animated:NO];
         //NSLog(@"image tap index = %ld, section index = %ld", (long)subview.tag, (long)subview.superview.tag);
     }else if ([subview isMemberOfClass:[TOCSectionCellView class]]) {
-        [self scrollWebViewToSectionForCell:(TOCSectionCellView *)subview animated:YES];
+        [self scrollWebViewToSectionForCell:(TOCSectionCellView *)subview animated:NO];
         //NSLog(@"section cell tap index = %ld", (long)subview.tag);
     }
 }
 
 -(void)scrollWebViewToSectionForCell:(TOCSectionCellView *)cell animated:(BOOL)animated
 {
-    cell.isSelected = YES;
     cell.isHighlighted = YES;
 
     WebViewController *webVC = (WebViewController *)self.parentViewController;
     NSString *elementId = [NSString stringWithFormat:@"content_block_%ld", (long)cell.tag];
     CGPoint p = [webVC.webView getWebViewRectForHtmlElementWithId:elementId].origin;
+
     [self scrollWebView:webVC.webView toPoint:p animated:animated];
 }
 
 -(void)scrollWebViewToImageForCell:(UIImageView *)imageView animated:(BOOL)animated
 {
-
-if ([imageView.superview isMemberOfClass:[TOCSectionCellView class]]) {
-    TOCSectionCellView *cell = (TOCSectionCellView*)imageView.superview;
-    cell.isSelected = YES;
-    cell.isHighlighted = YES;
-}
-
     NSManagedObjectID *sectionId = self.sectionIds[imageView.superview.tag];
     NSArray *sectionImageIds = self.sectionImageIds[sectionId];
     NSManagedObjectID *sectionImageId = sectionImageIds[imageView.tag];
@@ -204,13 +234,14 @@ -(void)scrollWebViewToImageForCell:(UIImageView *)imageView animated:(BOOL)anima
     
     WebViewController *webVC = (WebViewController *)self.parentViewController;
     CGPoint p = [webVC.webView getWebViewCoordsForHtmlImageWithSrc:sectionImage.image.sourceUrl];
+    p.y = p.y - 23;
+
     [self scrollWebView:webVC.webView toPoint:p animated:animated];
 }
 
 -(void)scrollWebView:(UIWebView *)webView toPoint:(CGPoint)point animated:(BOOL)animated
 {
     point.x = webView.scrollView.contentOffset.x;
-    point.y = point.y - 23;
     [webView.scrollView setContentOffset:point animated:animated];
 }
 
@@ -225,39 +256,76 @@ -(void)unHighlightAllCells
 
 - (void)scrollViewDidScroll:(UIScrollView *)scrollView
 {
-    static CGFloat lastHighlightedCellTag = 0;
     if (scrollView == self.scrollView) {
+        CGFloat focalOffset = self.scrollView.frame.size.height / 2.0f;
         for (TOCSectionCellView *cell in self.sectionCells) {
+
+//TODO: TOCSectionCellView has a "TODO:" about making a section image object for managing their state. Do that.
+// Expecially note the "v.layer.borderColor" stuff below - doesn't belong here.
+            [cell resetSectionImageViewsBorderStyle];
+            NSArray *centerlineIntersectingCellImages = [cell imagesIntersectingYOffset:focalOffset inView:self.scrollView.superview];
+            
+//TODO: allow this image border highlighting for vertically stacked image layout.
+/*
+            for (UIImageView *v in centerlineIntersectingCellImages) {
+                v.layer.borderColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0].CGColor;
+            }
+*/
             if ([self isCellFocalCell:cell]) {
                 [self unHighlightAllCells];
                 cell.isHighlighted = YES;
-                lastHighlightedCellTag = cell.tag;
+            }
+
+            BOOL shouldAttemptScrollToImage = (centerlineIntersectingCellImages.count > 0) ? YES : NO;
+            BOOL shouldAttemptScrollToSection = ((!shouldAttemptScrollToImage) && cell.isHighlighted) ? YES : NO;
+
+//TODO: allow "shouldAttemptScrollToImage" to be used for vertically stacked image layout.
+shouldAttemptScrollToImage = NO;
+
+            /*
+             // Probably never do this here - to much "bridge" traffic for each scroll pixel move...
+             WebViewController *webVC = (WebViewController *)self.parentViewController;
+             NSInteger indexOfFirstOnscreenSection = [webVC.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:self.sectionCells.count];
+             NSString *elementId = [NSString stringWithFormat:@"content_block_%ld", (long)indexOfFirstOnscreenSection];
+             CGPoint p = [webVC.webView getWebViewRectForHtmlElementWithId:elementId].origin;
+             if ((p.y < 0) || (p.y > 100)) shouldAttemptScrollToSection = YES;
+             */
+            
+            if (shouldAttemptScrollToImage) {
+                UIImageView *i = (UIImageView *)centerlineIntersectingCellImages[0];
+                    [self scrollWebViewToImageForCell:i animated:NO];
+            }
+
+            if (shouldAttemptScrollToSection){
                 if (!self.animateWebScrollAsFocalCellChanges) {
-                    [self scrollWebViewToSectionForCell:cell animated:NO];
+                        [self scrollWebViewToSectionForCell:cell animated:NO];
                 }
-            }else{
-                if (lastHighlightedCellTag == cell.tag) continue;
-                cell.isHighlighted = NO;
             }
         }
     }
-    
     [self cascadeSectionCellsAlphaFromMiddle];
 }
 
 -(void)cascadeSectionCellsAlphaFromMiddle
 {
+
+//TODO: the layout with the large vertically stacked images should *not* cascasde cell alpha.
+//return;
+
     CGFloat minAlpha = 0.25f;
+
     //CGFloat whiteLevel = 0.0f;
     CGFloat halfContainerHeight = self.scrollView.frame.size.height / 2.0f;
     // Proportionately fade out cells around middle cell.
     for (TOCSectionCellView *cell in self.sectionCells) {
-        if (cell.isHighlighted) continue;
+//      if (cell.isHighlighted) continue;
 
         //if (self.sectionCells.firstObject != cell) continue;
         //if (self.sectionCells.lastObject != cell) continue;
 
-        CGFloat distanceFromCenter = cell.center.y - self.scrollView.contentOffset.y - halfContainerHeight;
+        CGFloat distanceFromCenter = [self offsetFromCenterForView:cell];
+
+        //if (distanceFromCenter < 0) distanceFromCenter *= 1.5;
 
         CGFloat alpha = fabsf((fabsf(distanceFromCenter) - halfContainerHeight) / halfContainerHeight);
         //alpha = 1.0f - alpha; // Inverts alpha.
@@ -279,7 +347,7 @@ -(BOOL)isCellFocalCell:(TOCSectionCellView *)cell
     p.x -= self.scrollView.frame.origin.x;
     p.y -= self.scrollView.frame.origin.y;
     if ((p.y < focalOffset) && ((p.y + cell.frame.size.height) > focalOffset)) {
-        if (!cell.isHighlighted) {
+        if (!cell.isHighlighted || (cell.isHighlighted && (cell.tag == 0))) {
             return YES;
         }
     }
@@ -308,12 +376,31 @@ - (void)scrollViewScrollingEnded:(UIScrollView *)scrollView
     }
 }
 
-#pragma mark Resize with parent view controller
+#pragma mark Constraints
 
-- (void)didMoveToParentViewController:(UIViewController *)parent
+-(void)constrainScrollContainer
 {
-    [super didMoveToParentViewController:parent];
+    [self.scrollContainer.superview addConstraint:
+     [NSLayoutConstraint constraintWithItem: self.scrollContainer
+                                  attribute: NSLayoutAttributeWidth
+                                  relatedBy: NSLayoutRelationEqual
+                                     toItem: self.scrollContainer.superview
+                                  attribute: NSLayoutAttributeWidth
+                                 multiplier: 1.0
+                                   constant: 0]];
+}
+
+-(void)updateViewConstraints
+{
+    [super updateViewConstraints];
+
+    [self constrainSectionCells];
+
+    [self constrainTOCView];
+}
 
+- (void)constrainTOCView
+{
     float margin = 0.0f;
     void (^constrain)(NSLayoutAttribute, float) = ^void(NSLayoutAttribute a, float constant) {
         [self.view.superview addConstraint:[NSLayoutConstraint constraintWithItem:self.view
@@ -329,60 +416,124 @@ - (void)didMoveToParentViewController:(UIViewController *)parent
     constrain(NSLayoutAttributeRight, -margin);
     constrain(NSLayoutAttributeTop, margin);
     constrain(NSLayoutAttributeBottom, -margin);
-    
-    [self updateScrollContentInset];
-    
-    [self revealFromBottomToMidScreen];
 }
 
--(void)revealFromBottomToMidScreen
+#pragma mark Highlighted cell
+
+-(TOCSectionCellView *)getHighlightedCell
+{
+    for (TOCSectionCellView *cell in self.sectionCells) {
+        if (cell.isHighlighted) return cell;
+    }
+    return nil;
+}
+
+-(void)scrollHighlightedCellToScreenCenter
 {
     if (self.sectionCells.count == 0) return;
-    UIView *firstCell = (UIView *)[self.sectionCells firstObject];
+    TOCSectionCellView *highlightedCell = [self getHighlightedCell];
+
+    // Return if no cell highlighted.
+    if (!highlightedCell) return;
+
+    // Temporarily set content insets to allow top cell to be completely off bottom of screen.
+    [self insetToRestrictScrollingToHeight:@(self.scrollView.frame.size.height)];
+
+    // Calculate highlighted cell's offset from screen center.
+    CGFloat distanceFromCenter = [self offsetFromCenterForView:highlightedCell];
+
+    // Scroll highlighted to screen center (animated).
+    CGPoint contentOffset = self.scrollView.contentOffset;
+    contentOffset.y += distanceFromCenter;
     
-    // First move just off bottom of screen.
-    CGPoint p = CGPointMake(0.0f, -self.scrollView.frame.size.height);
-    [self.scrollView setContentOffset:p animated:NO];
+    //NSLog(@"contentOffset.y = %f", contentOffset.y);
+    [self setScrollViewContentOffset:contentOffset];
+
+    // After delay (to allow animated scroll above to complete) reset content
+    // insets to prevent first and last cells from scrolling past screen center.
+    [self performSelector:@selector(insetToRestrictScrollingTopAndBottomCellsPastCenter) withObject:nil afterDelay:0.35f];
+}
+
+-(CGFloat)offsetFromCenterForView:(UIView *)view
+{
+    return view.center.y - self.scrollView.contentOffset.y - self.scrollView.frame.size.height / 2.0f;
+}
+
+#pragma mark Scroll limits
+
+-(void)insetToRestrictScrollingToHeight:(NSNumber *)height
+{
+    // Don't report scrolling when changing inset.
+    self.scrollView.delegate = nil;
+
+    self.scrollView.contentInset = UIEdgeInsetsMake(
+        height.floatValue - TOC_SECTION_MARGIN,
+        0,
+        height.floatValue - TOC_SECTION_MARGIN,
+        0
+    );
+    self.scrollView.delegate = self;
+}
 
-    // Now scroll up to just below center of screen.
-    CGPoint p2 = CGPointMake(
-                            0.0f,
-                            -(self.scrollView.contentInset.top + firstCell.frame.size.height) / 2.0f
-                            );
-    [self.scrollView setContentOffset:p2 animated:YES];
+-(void)setScrollViewContentOffset:(CGPoint)contentOffset
+{
+    // Don't report scrolling when changing offset.
+    self.scrollView.delegate = nil;
+    [self.scrollView setContentOffset:contentOffset animated:NO];
+    self.scrollView.delegate = self;
 }
 
-- (void)viewDidLayoutSubviews
+-(void)insetToRestrictScrollingTopAndBottomCellsPastCenter
 {
-    [self updateScrollContentInset];
+    // Don't report scrolling when changing inset.
+    self.scrollView.delegate = nil;
+    CGFloat halfHeight = self.scrollView.frame.size.height / 2.0f;
+
+//TODO: the vertially stacked image layout should do "insetToRestrictScrollingToHeight", but the default layout
+// should not. Presently both are using "insetToRestrictScrollingToHeight" because of the line below.
+[self insetToRestrictScrollingToHeight:@(halfHeight)];
+return;
+    
+    self.scrollView.contentInset = UIEdgeInsetsMake(
+        halfHeight - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.firstObject).frame.size.height / 2.0f),
+        0,
+        halfHeight - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.lastObject).frame.size.height / 2.0f),
+        0
+    );
+    self.scrollView.delegate = self;
 }
 
--(void)updateScrollContentInset
+-(void)updateHighlightedCellToReflectWebView
 {
-    // Allows the scrollview to scroll the bottom cell all the way to the top and top all the way to bottom.
-    if (self.sectionCells.count > 0) {
-        UIView *lastCell = (UIView *)[self.sectionCells lastObject];
-        UIView *firstCell = (UIView *)[self.sectionCells firstObject];
-        CGFloat f = self.scrollView.frame.size.height - firstCell.frame.size.height;
-        f -= TOC_SECTION_MARGIN;
-        CGFloat l = self.scrollView.frame.size.height - lastCell.frame.size.height;
-        l -= TOC_SECTION_MARGIN;
-        self.scrollView.contentInset = UIEdgeInsetsMake(f, 0, l, 0);
+    // Highlight cell for section currently nearest top of webview.
+    if (self.sectionCells.count > 0){
+        [self unHighlightAllCells];
+        WebViewController *webVC = (WebViewController *)self.parentViewController;
+        NSInteger indexOfFirstOnscreenSection = [webVC.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:self.sectionCells.count];
+        if (indexOfFirstOnscreenSection < self.sectionCells.count) {
+            ((TOCSectionCellView *)self.sectionCells[indexOfFirstOnscreenSection]).isHighlighted = YES;
+        }
     }
 }
 
+#pragma mark Memory
+
 - (void)didReceiveMemoryWarning
 {
     [super didReceiveMemoryWarning];
     // Dispose of any resources that can be recreated.
 }
 
+#pragma mark Section cells
+
 -(void)constrainSectionCells
 {
 
-//TODO: have these constrains, but also a set which positions cells offscreen, that way
+//TODO: have these constraints, but also a set which positions cells offscreen, that way
 // they can be animated between.
 
+    [self.scrollContainer removeConstraints:self.scrollContainer.constraints];
+    
     void (^constrain)(UIView *, NSLayoutAttribute, UIView *, NSLayoutAttribute, CGFloat) = ^void(UIView *view1, NSLayoutAttribute a1, UIView *view2, NSLayoutAttribute a2, CGFloat constant) {
         [self.scrollContainer addConstraint:
          [NSLayoutConstraint constraintWithItem: view1
@@ -423,39 +574,6 @@ -(void)getSectionCells
     }
 }
 
--(NSString *)getSectionsWithImageDebuggingString
-{
-    ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
-    
-    NSMutableArray *tempTocArray = [@[]mutableCopy];
-    
-    for (NSManagedObjectID *sectionId in self.sectionIds) {
-        
-        Section *section = (Section *)[articleDataContext_.workerContext objectWithID:sectionId];
-        
-        NSString *tabs = [@"" stringByPaddingToLength:section.tocLevel.integerValue withString:@"\t" startingAtIndex:0];
-        
-        NSArray *sectionImageIds = self.sectionImageIds[sectionId];
-        
-        NSMutableArray *imgStrArray = [@[]mutableCopy];
-        for (NSManagedObjectID *sectionImageId in sectionImageIds) {
-            SectionImage *sectionImage = (SectionImage *)[articleDataContext_.workerContext objectWithID:sectionImageId];
-            [imgStrArray addObject:[NSString stringWithFormat:@"%@\t*%@", tabs, sectionImage.image.fileName]];
-        }
-        
-        NSString *sectionString = [NSString stringWithFormat:@"%@%@-%@: %@\n%@\n",
-                                   tabs,
-                                   section.index,
-                                   section.tocLevel,
-                                   section.title,
-                                   [imgStrArray componentsJoinedByString:@"\n"]
-                                   ];
-        [tempTocArray addObject:sectionString];
-    }
-    
-    return [tempTocArray componentsJoinedByString:@"\n"];
-}
-
 /*
 #pragma mark - Navigation
 
diff --git a/Wikipedia-iOS/View Controllers/WebView/WebViewController.h b/Wikipedia-iOS/View Controllers/WebView/WebViewController.h
index c4cd0b5deb5..0e886f60aad 100644
--- a/Wikipedia-iOS/View Controllers/WebView/WebViewController.h	
+++ b/Wikipedia-iOS/View Controllers/WebView/WebViewController.h	
@@ -23,4 +23,9 @@
 - (IBAction)actionButtonPushed:(id)sender;
 - (IBAction)bookmarkButtonPushed:(id)sender;
 
+-(void)shrinkAndAlignRightWithScale:(CGFloat)scale;
+-(void)shrinkReset;
+-(void)skewWithEyePosition:(CGFloat)eyePosition angle:(CGFloat)angle;
+-(void)skewReset;
+
 @end
diff --git a/Wikipedia-iOS/View Controllers/WebView/WebViewController.m b/Wikipedia-iOS/View Controllers/WebView/WebViewController.m
index 132c16cb265..9a1a20c4de4 100644
--- a/Wikipedia-iOS/View Controllers/WebView/WebViewController.m	
+++ b/Wikipedia-iOS/View Controllers/WebView/WebViewController.m	
@@ -39,6 +39,7 @@ @interface WebViewController (){
 @property (weak, nonatomic) SearchNavController *searchNavController;
 @property (nonatomic) CGPoint scrollOffset;
 @property (nonatomic) BOOL unsafeToScroll;
+@property (nonatomic) NSInteger indexOfFirstOnscreenSectionBeforeRotate;
 
 @end
 
@@ -74,6 +75,7 @@ - (void)viewDidLoad
     [super viewDidLoad];
 
     self.searchNavController = (SearchNavController *)self.navigationController;
+    self.indexOfFirstOnscreenSectionBeforeRotate = 0;
 
     self.searchResultsController = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"SearchResultsController"];
     self.searchResultsController.webViewController = self;
@@ -899,6 +901,60 @@ - (void)displayArticle:(Article *)article
     }];
 }
 
+#pragma mark Shrink and skew
+
+-(CABasicAnimation *)animationForPath:(NSString *)path toValue:(NSValue *)value duration:(CGFloat)duration
+{
+    CABasicAnimation *a = [CABasicAnimation animationWithKeyPath:path];
+    a.fillMode = kCAFillModeForwards;
+    a.autoreverses = NO;
+    a.duration = duration;
+    a.removedOnCompletion = NO;
+    CGFloat delay = 0.0f;
+    [a setBeginTime:CACurrentMediaTime() + delay];
+    a.toValue = value;
+    return a;
+}
+
+-(void)shrinkAndAlignRightWithScale:(CGFloat)scale
+{
+    // Shrink web view and move it up against right side of screen.
+    CGSize size = self.webView.frame.size;
+    CGPoint alignRightOffset = CGPointMake(
+        (size.width - (size.width * scale)) / 2.0f,
+        -(size.height - (size.height * scale)) / 2.0f
+    );
+    CATransform3D xf = CATransform3DIdentity;
+    xf = CATransform3DTranslate(xf, alignRightOffset.x, alignRightOffset.y, 0);
+    xf = CATransform3DScale(xf, scale, scale, 1.0f);
+    CABasicAnimation *shrinkAnimation = [self animationForPath:@"transform" toValue:[NSValue valueWithCATransform3D:xf] duration:0.2f];
+    [self.webView.layer addAnimation:shrinkAnimation forKey:@"WEBVIEW_SHRINK"];
+}
+
+-(void)skewWithEyePosition:(CGFloat)eyePosition angle:(CGFloat)angle
+{
+    // Skew the web view a bit.
+    //CGFloat eyePosition = -2000;
+    //CGFloat angle = 7.5f;
+    CATransform3D perspective = CATransform3DIdentity;
+    perspective.m34 = -1.0 / eyePosition;
+    CATransform3D rotationAndPerspectiveTransform = CATransform3DRotate(perspective, angle * M_PI / 180.0f, 0.0f, 1.0f, 0.0f);
+    CABasicAnimation *skewAnimation = [self animationForPath:@"sublayerTransform" toValue:[NSValue valueWithCATransform3D:rotationAndPerspectiveTransform] duration:0.2f];
+    [self.webView.layer addAnimation:skewAnimation forKey:@"WEBVIEW_SKEW"];
+}
+
+-(void)shrinkReset
+{
+    CABasicAnimation *resetShrinkAnimation = [self animationForPath:@"transform" toValue:[NSValue valueWithCATransform3D:CATransform3DIdentity] duration:0.2f];
+    [self.webView.layer addAnimation:resetShrinkAnimation forKey:@"WEBVIEW_SHRINK_RESET"];
+}
+
+-(void)skewReset
+{
+    CABasicAnimation *resetSkewAnimation = [self animationForPath:@"sublayerTransform" toValue:[NSValue valueWithCATransform3D:CATransform3DIdentity] duration:0.2f];
+    [self.webView.layer addAnimation:resetSkewAnimation forKey:@"WEBVIEW_SKEW_RESET"];
+}
+
 #pragma mark Action methods
 
 - (IBAction)backButtonPushed:(id)sender {
@@ -929,4 +985,33 @@ - (IBAction)bookmarkButtonPushed:(id)sender {
 - (IBAction)menuButtonPushed:(id)sender {
 }
 
+#pragma mark Scroll to last section after rotate
+
+-(void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration
+{
+    [articleDataContext_.mainContext performBlockAndWait:^(){
+        NSManagedObjectID *articleID = [articleDataContext_.mainContext getArticleIDForTitle:[self getCurrentArticleTitle]];
+        Article *article = (Article *)[articleDataContext_.mainContext objectWithID:articleID];
+
+        self.indexOfFirstOnscreenSectionBeforeRotate = [self.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:article.section.count];
+    }];    
+    //self.view.alpha = 0.0f;
+}
+
+-(void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
+{
+    [self performSelector:@selector(scrollToIndexOfFirstOnscreenSectionBeforeRotate) withObject:nil afterDelay:0.15f];
+}
+
+-(void)scrollToIndexOfFirstOnscreenSectionBeforeRotate{
+    if(self.indexOfFirstOnscreenSectionBeforeRotate == -1)return;
+    NSString *elementId = [NSString stringWithFormat:@"content_block_%ld", (long)self.indexOfFirstOnscreenSectionBeforeRotate];
+    CGPoint p = [self.webView getWebViewRectForHtmlElementWithId:elementId].origin;
+    p.x = self.webView.scrollView.contentOffset.x;
+    [self.webView.scrollView setContentOffset:p animated:YES];
+    //[UIView animateWithDuration:0.05f animations:^{
+    //    self.view.alpha = 1.0f;
+    //}];
+}
+
 @end
diff --git a/Wikipedia-iOS/mw-bridge/css/pagestyles.css b/Wikipedia-iOS/mw-bridge/css/pagestyles.css
index 7e1104320ae..28424dff4c3 100644
--- a/Wikipedia-iOS/mw-bridge/css/pagestyles.css
+++ b/Wikipedia-iOS/mw-bridge/css/pagestyles.css
@@ -19,7 +19,7 @@ body {
     margin-top:0px;
     margin-bottom:12px;
     padding:6px;
-    padding-top:0px;
+    padding-top:6px;
     padding-bottom:0px;
 }
 
diff --git a/Wikipedia-iOS/mw-bridge/js/elementLocation.js b/Wikipedia-iOS/mw-bridge/js/elementLocation.js
index 9a271ac5e87..2450057ee4f 100644
--- a/Wikipedia-iOS/mw-bridge/js/elementLocation.js
+++ b/Wikipedia-iOS/mw-bridge/js/elementLocation.js
@@ -36,3 +36,13 @@ function getElementRect(element) {
 function getElementRectAsJson(element) {
     return JSON.stringify(getElementRect(element));
 }
+
+function getIndexOfFirstOnScreenElementWithTopGreaterThanY(elementPrefix, elementCount, y){
+    for (var i = 0; i < elementCount; ++i) {
+        var div = document.getElementById(elementPrefix + i);
+        if(div == null) continue;
+        var rect = getElementRect(div);
+        if( (rect['top'] >= 0) || ((rect['top'] + rect['height']) >= 0)) return i;
+    }
+    return -1;
+}
