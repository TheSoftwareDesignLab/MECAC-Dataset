diff --git a/WMF Framework/WidgetController.swift b/WMF Framework/WidgetController.swift
index 9908ec01019..6270552934a 100644
--- a/WMF Framework/WidgetController.swift	
+++ b/WMF Framework/WidgetController.swift	
@@ -32,16 +32,52 @@ public final class WidgetController: NSObject {
 	}
     
     /// For requesting background time from widgets
-    /// - Parameter reason: the reason for requesting background time
-    /// - Parameter userCompletion: completion to be called from within the background task completion
-    /// - Returns a completion block to be called when the background task is completed
-    public func startBackgroundTask<T>(reason: String, userCompletion: @escaping (T) ->  Void) -> (T) -> Void  {
+    /// - Parameter userCompletion: the completion block to call with the result
+    /// - Parameter task: block that takes the `MWKDataStore` to use for updates and the completion block to call when done as parameters
+    public func startWidgetUpdateTask<T>(_ userCompletion: @escaping (T) -> Void, _ task: @escaping (MWKDataStore, @escaping (T) -> Void) -> Void)  {
         let processInfo = ProcessInfo.processInfo
-        let start = processInfo.beginActivity(options: .background, reason: reason)
-        return { entry in
-            userCompletion(entry)
+        let start = processInfo.beginActivity(options: .background, reason: "Updating Wikipedia Widgets - " + UUID().uuidString)
+        let dataStore = getRetainedSharedDataStore()
+        task(dataStore, { result in
+            userCompletion(result)
+            self.releaseSharedDataStore()
             processInfo.endActivity(start)
+        })
+    }
+    
+    private var dataStoreRetainCount: Int = 0
+    private var _dataStore: MWKDataStore?
+    private let lock = NSRecursiveLock()
+    
+    /// Returns a `MWKDataStore`for use with widget updates.
+    /// Manages a shared instance and a reference count for use by multiple widgets.
+    /// Call `releaseSharedDataStore()` when finished with the data store.
+    private func getRetainedSharedDataStore() -> MWKDataStore {
+        lock.lock()
+        defer {
+            dataStoreRetainCount += 1
+            lock.unlock()
         }
+        if let dataStore = _dataStore {
+            return dataStore
+        }
+        let dataStore = MWKDataStore()
+        _dataStore = dataStore
+        return dataStore
     }
-
+    
+    /// Releases the shared `MWKDataStore` returned by `getRetainedSharedDataStore()`.
+    private func releaseSharedDataStore() {
+        lock.lock()
+        defer {
+            lock.unlock()
+        }
+        dataStoreRetainCount -= 1
+        guard dataStoreRetainCount <= 0 else {
+            return
+        }
+        _dataStore = nil
+        dataStoreRetainCount = 0
+    }
+    
 }
diff --git a/Widgets/Widgets/OnThisDayWidget.swift b/Widgets/Widgets/OnThisDayWidget.swift
index bde42f4e807..817a0b25940 100644
--- a/Widgets/Widgets/OnThisDayWidget.swift
+++ b/Widgets/Widgets/OnThisDayWidget.swift
@@ -83,9 +83,6 @@ final class OnThisDayData {
     static let shared = OnThisDayData()
 
     private var imageInfoFetcher = MWKImageInfoFetcher()
-    private var dataStore: MWKDataStore {
-        MWKDataStore.shared()
-    }
 
     // From https://en.wikipedia.org/api/rest_v1/feed/onthisday/events/01/15, taken on 03 Sept 2020.
     let placeholderEntry = OnThisDayEntry(isRTLLanguage: false,
@@ -105,40 +102,38 @@ final class OnThisDayData {
                                           yearRange: CommonStrings.onThisDayHeaderDateRangeMessage(with: "en", locale: Locale(identifier: "en"), lastEvent: "69", firstEvent: "2019"))
 
     // MARK: Public
-
-    private var siteURL: URL? {
-        return dataStore.languageLinkController.appLanguage?.siteURL()
-    }
     
     func fetchLatestAvailableOnThisDayEntry(usingCache: Bool = false, _ userCompletion: @escaping (OnThisDayEntry) -> Void) {
-        let completion =  WidgetController.shared.startBackgroundTask(reason: "Update On This Day Widget", userCompletion: userCompletion)
-        guard let appLanguage = MWKDataStore.shared().languageLinkController.appLanguage, WMFOnThisDayEventsFetcher.isOnThisDaySupported(by: appLanguage.languageCode) else {
-            let errorEntry = OnThisDayEntry.errorEntry(for: .featureNotSupportedInLanguage)
-            completion(errorEntry)
-            return
-        }
-
-        let moc = dataStore.viewContext
-        moc.perform {
-            guard let latest = moc.newestVisibleGroup(of: .onThisDay, forSiteURL: self.siteURL),
-                  latest.isForToday
-            else {
-                guard !usingCache else {
-                    completion(self.placeholderEntry)
+        WidgetController.shared.startWidgetUpdateTask(userCompletion) { (dataStore, completion) in
+            guard let appLanguage = dataStore.languageLinkController.appLanguage,
+                WMFOnThisDayEventsFetcher.isOnThisDaySupported(by: appLanguage.languageCode) else {
+                let errorEntry = OnThisDayEntry.errorEntry(for: .featureNotSupportedInLanguage)
+                completion(errorEntry)
+                return
+            }
+            let siteURL = appLanguage.siteURL()
+            let moc = dataStore.viewContext
+            moc.perform {
+                guard let latest = moc.newestVisibleGroup(of: .onThisDay, forSiteURL: siteURL),
+                      latest.isForToday
+                else {
+                    guard !usingCache else {
+                        completion(self.placeholderEntry)
+                        return
+                    }
+                    self.fetchLatestOnThisDayEntryFromNetwork(with: dataStore, siteURL: siteURL, completion)
                     return
                 }
-                self.fetchLatestOnThisDayEntryFromNetwork(completion)
-                return
+                self.assembleOnThisDayFromContentGroup(latest, completion: completion)
             }
-            self.assembleOnThisDayFromContentGroup(latest, completion: completion)
         }
     }
     
-    func fetchLatestOnThisDayEntryFromNetwork(_ completion: @escaping (OnThisDayEntry) -> Void) {
+    func fetchLatestOnThisDayEntryFromNetwork(with dataStore: MWKDataStore, siteURL: URL, _ completion: @escaping (OnThisDayEntry) -> Void) {
         dataStore.feedContentController.updateFeedSourcesUserInitiated(false) {
-            let moc = self.dataStore.viewContext
+            let moc = dataStore.viewContext
             moc.perform {
-                guard let latest = moc.newestVisibleGroup(of: .onThisDay, forSiteURL: self.siteURL) else {
+                guard let latest = moc.newestVisibleGroup(of: .onThisDay, forSiteURL: siteURL) else {
                     // If there's no content even after a network fetch, it's likely an error
                     self.handleNoInternetError(completion)
                     return
diff --git a/Widgets/Widgets/TopReadWidget.swift b/Widgets/Widgets/TopReadWidget.swift
index e1809a31f20..682ef6dde2f 100644
--- a/Widgets/Widgets/TopReadWidget.swift
+++ b/Widgets/Widgets/TopReadWidget.swift
@@ -33,49 +33,45 @@ final class TopReadData {
 
 	// MARK: Public
 
-	private var dataStore: MWKDataStore {
-		MWKDataStore.shared()
-	}
-
     func fetchLatestAvailableTopRead(usingCache: Bool = false, completion userCompletion: @escaping (TopReadEntry) -> Void) {
-        let completion =  WidgetController.shared.startBackgroundTask(reason: "Update Top Read Widget", userCompletion: userCompletion)
-        let moc = dataStore.viewContext
-        moc.perform {
-            guard let latest = moc.newestVisibleGroup(of: .topRead), latest.isForToday else {
-                guard !usingCache else {
-                    completion(self.placeholder)
+        WidgetController.shared.startWidgetUpdateTask(userCompletion) { (dataStore, completion) in
+            let moc = dataStore.viewContext
+            moc.perform {
+                guard let latest = moc.newestVisibleGroup(of: .topRead), latest.isForToday else {
+                    guard !usingCache else {
+                        completion(self.placeholder)
+                        return
+                    }
+                    self.fetchLatestAvailableTopReadFromNetwork(from: dataStore, completion: completion)
                     return
                 }
-                self.fetchLatestAvailableTopReadFromNetwork(completion: completion)
-                return
+                self.assembleTopReadFromContentGroup(latest, with: dataStore, usingImageCache: usingCache, completion: completion)
             }
-            self.assembleTopReadFromContentGroup(latest, usingImageCache: usingCache, completion: completion)
         }
     }
     
-    func fetchLatestAvailableTopReadFromNetwork(completion: @escaping (TopReadEntry) -> Void) {
+    func fetchLatestAvailableTopReadFromNetwork(from dataStore: MWKDataStore, completion: @escaping (TopReadEntry) -> Void) {
         dataStore.feedContentController.updateFeedSourcesUserInitiated(false) {
-            let moc = self.dataStore.viewContext
+            let moc = dataStore.viewContext
             moc.perform {
                 guard let latest = moc.newestVisibleGroup(of: .topRead) else {
                     completion(self.placeholder)
                     return
                 }
-                self.assembleTopReadFromContentGroup(latest, completion: completion)
+                self.assembleTopReadFromContentGroup(latest, with: dataStore, completion: completion)
             }
         }
     }
     
-    func assembleTopReadFromContentGroup(_ topRead: WMFContentGroup, usingImageCache: Bool = false, completion: @escaping (TopReadEntry) -> Void) {
+    func assembleTopReadFromContentGroup(_ topRead: WMFContentGroup, with dataStore: MWKDataStore, usingImageCache: Bool = false, completion: @escaping (TopReadEntry) -> Void) {
         guard let results = topRead.contentPreview as? [WMFFeedTopReadArticlePreview] else {
             completion(placeholder)
             return
         }
 
         var rankedElements: [TopReadEntry.RankedElement] = []
-
         for article in results {
-            if let articlePreview = self.dataStore.fetchArticle(with: article.articleURL) {
+            if let articlePreview = dataStore.fetchArticle(with: article.articleURL) {
                 if let viewCounts = articlePreview.pageViewsSortedByDate {
                     rankedElements.append(.init(title: article.displayTitle, description: article.wikidataDescription ?? article.snippet ?? "", articleURL: article.articleURL, thumbnailURL: article.thumbnailURL, viewCounts: viewCounts))
                 }
