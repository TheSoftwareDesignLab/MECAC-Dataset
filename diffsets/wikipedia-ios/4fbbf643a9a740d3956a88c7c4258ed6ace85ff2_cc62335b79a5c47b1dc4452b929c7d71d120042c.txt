diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index f637d2ca802..28a062c1017 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -194,6 +194,8 @@
 		0E366B481B2F614E00ABFB86 /* PromiseKit.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B461B2F614E00ABFB86 /* PromiseKit.swift */; };
 		0E366B4B1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B4A1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m */; };
 		0E36C2271AE0B59D00C58CFF /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D4991453181D51DE00E6073C /* Images.xcassets */; };
+		0E466E521B41F83500E91992 /* WMFArticlePopupTransition.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E466E511B41F83500E91992 /* WMFArticlePopupTransition.m */; };
+		0E466E551B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E466E541B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.m */; };
 		0E7955C71B2B389800B055A2 /* TGLStackedLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */; };
 		0E7955D01B2B659500B055A2 /* WMFArticleCardTranstion.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E7955CD1B2B659500B055A2 /* WMFArticleCardTranstion.m */; };
 		0E94AFEA1B209721000BC5EA /* iPhone_Root.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 0E94AFE91B209721000BC5EA /* iPhone_Root.storyboard */; };
@@ -750,6 +752,10 @@
 		0E366B491B308A2600ABFB86 /* UIStoryboard+WMFExtensions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIStoryboard+WMFExtensions.h"; sourceTree = "<group>"; };
 		0E366B4A1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIStoryboard+WMFExtensions.m"; sourceTree = "<group>"; };
 		0E36C2281AE0B5BD00C58CFF /* SourceIcons.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = SourceIcons.xcassets; path = Wikipedia/SourceIcons.xcassets; sourceTree = "<group>"; };
+		0E466E501B41F83500E91992 /* WMFArticlePopupTransition.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFArticlePopupTransition.h; sourceTree = "<group>"; };
+		0E466E511B41F83500E91992 /* WMFArticlePopupTransition.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFArticlePopupTransition.m; sourceTree = "<group>"; };
+		0E466E531B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFScrollViewTopPanGestureRecognizer.h; sourceTree = "<group>"; };
+		0E466E541B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFScrollViewTopPanGestureRecognizer.m; sourceTree = "<group>"; };
 		0E7955C21B2B389800B055A2 /* TGLStackedLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TGLStackedLayout.h; sourceTree = "<group>"; };
 		0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TGLStackedLayout.m; sourceTree = "<group>"; };
 		0E7955CC1B2B659500B055A2 /* WMFArticleCardTranstion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFArticleCardTranstion.h; sourceTree = "<group>"; };
@@ -2033,6 +2039,10 @@
 			children = (
 				0E7955CC1B2B659500B055A2 /* WMFArticleCardTranstion.h */,
 				0E7955CD1B2B659500B055A2 /* WMFArticleCardTranstion.m */,
+				0E466E501B41F83500E91992 /* WMFArticlePopupTransition.h */,
+				0E466E511B41F83500E91992 /* WMFArticlePopupTransition.m */,
+				0E466E531B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.h */,
+				0E466E541B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.m */,
 			);
 			name = Transition;
 			sourceTree = "<group>";
@@ -2802,6 +2812,7 @@
 		D499142D181D51DE00E6073C /* Project object */ = {
 			isa = PBXProject;
 			attributes = {
+				LastSwiftUpdateCheck = 0700;
 				LastUpgradeCheck = 0600;
 				ORGANIZATIONNAME = "Wikimedia Foundation";
 				TargetAttributes = {
@@ -3245,10 +3256,12 @@
 				04CCCFF71935094000E3F60C /* PrimaryMenuTableViewCell.m in Sources */,
 				BCAC50C11AF3F7460015936C /* NSBundle+WMFInfoUtils.m in Sources */,
 				0EFB0F201B31EE2D00D05C08 /* GalleryImage.m in Sources */,
+				0E466E521B41F83500E91992 /* WMFArticlePopupTransition.m in Sources */,
 				0487048F19F8262600B7D307 /* WikiTextSectionFetcher.m in Sources */,
 				0EA4402E1AA6281200B09DBA /* NSDateFormatter+WMFExtensions.m in Sources */,
 				C913C89C1A94019A00BEEAF0 /* WMFSuggestedPagesFunnel.m in Sources */,
 				04EDEE2A1A215DBC00798076 /* UITableView+DynamicCellHeight.m in Sources */,
+				0E466E551B42D9DD00E91992 /* WMFScrollViewTopPanGestureRecognizer.m in Sources */,
 				BC69C3141AB0C1FF0090B039 /* WMFImageInfoController.m in Sources */,
 				04CBAC7319A9B786009F3D7E /* NSArray+Predicate.m in Sources */,
 				0EFB0F1D1B31EE2D00D05C08 /* NSManagedObjectContext+SimpleFetch.m in Sources */,
diff --git a/Wikipedia/UI-V5/WMFAppViewController.m b/Wikipedia/UI-V5/WMFAppViewController.m
index 5a41c1b910d..d7cc0b95a88 100644
--- a/Wikipedia/UI-V5/WMFAppViewController.m
+++ b/Wikipedia/UI-V5/WMFAppViewController.m
@@ -9,6 +9,7 @@
 #import "UIStoryboard+WMFExtensions.h"
 #import <Masonry/Masonry.h>
 
+
 @interface WMFAppViewController ()<WMFSearchViewControllerDelegate>
 @property (strong, nonatomic) IBOutlet UIView* searchContainerView;
 @property (strong, nonatomic) IBOutlet UIView* articleListContainerView;
diff --git a/Wikipedia/UI-V5/WMFArticleCardTranstion.h b/Wikipedia/UI-V5/WMFArticleCardTranstion.h
index 8af34d44e23..6268d612e0a 100644
--- a/Wikipedia/UI-V5/WMFArticleCardTranstion.h
+++ b/Wikipedia/UI-V5/WMFArticleCardTranstion.h
@@ -1,5 +1,4 @@
 
-#import <Foundation/Foundation.h>
 @import UIKit;
 
 @interface WMFArticleCardTranstion : UIPercentDrivenInteractiveTransition <UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning, UIViewControllerInteractiveTransitioning>
@@ -30,15 +29,11 @@
  */
 @property (assign, nonatomic) CGFloat presentCardOffset;
 
-/**
- *  Is the transisiton dismissing?
- */
-@property (nonatomic, assign, readonly) BOOL isDismissing;
 
 /**
- *  Is the transition Presenting?
- *  (Convienence, just !self.isDismissing)
+ *  Set to NO to disable interactive dismissal
+ *  Default is YES
  */
-@property (nonatomic, assign, readonly) BOOL isPresenting;
+@property (assign, nonatomic) BOOL dismissInteractively;
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleCardTranstion.m b/Wikipedia/UI-V5/WMFArticleCardTranstion.m
index 905175ed2e1..8c5f6d81766 100644
--- a/Wikipedia/UI-V5/WMFArticleCardTranstion.m
+++ b/Wikipedia/UI-V5/WMFArticleCardTranstion.m
@@ -8,9 +8,9 @@ @interface WMFArticleCardTranstion ()
 @property (strong, nonatomic) UIView* movingCardSnapshot;
 @property (strong, nonatomic) UIView* overlappingCardSnapshot;
 
+@property (nonatomic, assign, readwrite) BOOL isPresented;
 @property (nonatomic, assign, readwrite) BOOL isDismissing;
-
-#pragma mark - Interactive Dismiss Animation Properties
+@property (nonatomic, assign, readwrite) BOOL isPresenting;
 
 @property (strong, nonatomic) UIPanGestureRecognizer* recognizer;
 @property (assign, nonatomic) BOOL interactionInProgress;
@@ -21,10 +21,12 @@ @interface WMFArticleCardTranstion ()
 
 @implementation WMFArticleCardTranstion
 
-#pragma mark - Accessors
-
-- (BOOL)isPresenting {
-    return !self.isDismissing;
+- (instancetype)init {
+    self = [super init];
+    if (self) {
+        _dismissInteractively = YES;
+    }
+    return self;
 }
 
 #pragma mark - UIViewControllerTransitioningDelegate
@@ -52,24 +54,33 @@ - (NSTimeInterval)transitionDuration:(id<UIViewControllerContextTransitioning>)t
 }
 
 - (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
-    if (self.isPresenting) {
+    if (self.isPresented) {
+        [self animateDismiss:transitionContext];
+    } else {
         UIViewController* toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
         self.recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
         [toVC.view addGestureRecognizer:self.recognizer];
         self.presentedViewController = toVC;
 
         [self animatePresentation:transitionContext];
-    } else {
-        [self animateDismiss:transitionContext];
     }
 }
 
 #pragma mark - UIViewControllerInteractiveTransitioning
 
+- (void)startInteractiveTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
+    [super startInteractiveTransition:transitionContext];
+    self.interactionInProgress = YES;
+}
+
 - (CGFloat)completionSpeed {
     return (1 - self.percentComplete) * 1.5;
 }
 
+- (UIViewAnimationCurve)completionCurve {
+    return UIViewAnimationCurveEaseOut;
+}
+
 #pragma mark - Animation
 
 - (void)animatePresentation:(id<UIViewControllerContextTransitioning>)transitionContext {
@@ -111,6 +122,7 @@ - (void)animatePresentation:(id<UIViewControllerContextTransitioning>)transition
     [containerView addSubview:snapshotView];
     [containerView addSubview:overlappingCards];
 
+    self.isPresenting = YES;
     [UIView animateKeyframesWithDuration:self.nonInteractiveDuration delay:0.0 options:UIViewKeyframeAnimationOptionCalculationModeCubic animations:^{
         [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:1.0 animations:^{
             snapshotView.frame = finalSnapshotFrame;
@@ -127,6 +139,9 @@ - (void)animatePresentation:(id<UIViewControllerContextTransitioning>)transition
     } completion:^(BOOL finished) {
         toView.alpha = 1.0;
 
+        self.isPresenting = NO;
+        self.isPresented = ![transitionContext transitionWasCancelled];
+
         [snapshotView removeFromSuperview];
         [overlappingCards removeFromSuperview];
 
@@ -154,6 +169,7 @@ - (void)animateDismiss:(id<UIViewControllerContextTransitioning>)transitionConte
     [containerView addSubview:snapshotView];
     [containerView addSubview:overlappingCards];
 
+    self.isDismissing = YES;
     [UIView animateKeyframesWithDuration:self.nonInteractiveDuration delay:0.0 options:UIViewKeyframeAnimationOptionCalculationModeCubic animations:^{
         [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:1.0 animations:^{
             snapshotView.frame = finalSnapshotFrame;
@@ -172,6 +188,9 @@ - (void)animateDismiss:(id<UIViewControllerContextTransitioning>)transitionConte
             fromView.alpha = 1.0;
         }
 
+        self.isDismissing = NO;
+        self.isPresented = [transitionContext transitionWasCancelled];
+
         [snapshotView removeFromSuperview];
         [overlappingCards removeFromSuperview];
 
@@ -179,16 +198,14 @@ - (void)animateDismiss:(id<UIViewControllerContextTransitioning>)transitionConte
     }];
 }
 
-#pragma mark - Dismiss GestureRecognizer
+#pragma mark - Gesture
 
 - (void)handleGesture:(UIPanGestureRecognizer*)recognizer {
     switch (recognizer.state) {
         case UIGestureRecognizerStateBegan: {
-            CGPoint translation = [recognizer translationInView:self.recognizer.view];
-            BOOL topToBottom    = translation.y > 0;
-            if (topToBottom) {
-                self.interactionInProgress = YES;
-                self.isDismissing          = YES;
+            CGPoint translation     = [recognizer translationInView:recognizer.view];
+            BOOL swipeIsTopToBottom = translation.y > 0;
+            if (swipeIsTopToBottom) {
                 [self.presentedViewController dismissViewControllerAnimated:YES completion:nil];
             }
             break;
@@ -196,7 +213,7 @@ - (void)handleGesture:(UIPanGestureRecognizer*)recognizer {
 
         case UIGestureRecognizerStateChanged: {
             if (self.interactionInProgress) {
-                CGPoint distanceTraveled = [recognizer translationInView:self.recognizer.view];
+                CGPoint distanceTraveled = [recognizer translationInView:recognizer.view];
                 CGFloat percent          = distanceTraveled.y / self.totalCardAnimationDistance;
                 if (percent > 0.99) {
                     percent = 0.99;
@@ -207,21 +224,25 @@ - (void)handleGesture:(UIPanGestureRecognizer*)recognizer {
         }
 
         case UIGestureRecognizerStateEnded: {
-            BOOL fastSwipe = [self.recognizer velocityInView:self.recognizer.view].y > self.totalCardAnimationDistance;
+            if (self.percentComplete >= 0.33) {
+                [self finishInteractiveTransition];
+                return;
+            }
+
+            BOOL fastSwipe = [recognizer velocityInView:recognizer.view].y > self.totalCardAnimationDistance;
 
-            if ((self.percentComplete >= 0.33) || fastSwipe) {
+            if (fastSwipe) {
                 [self finishInteractiveTransition];
-            } else {
-                [self cancelInteractiveTransition];
+                return;
             }
 
-            self.isDismissing = NO;
+            [self cancelInteractiveTransition];
+
             break;
         }
 
         default:
             [self cancelInteractiveTransition];
-            self.isDismissing = NO;
             break;
     }
 }
diff --git a/Wikipedia/UI-V5/WMFArticlePopupTransition.h b/Wikipedia/UI-V5/WMFArticlePopupTransition.h
new file mode 100644
index 00000000000..cf2fc006ae1
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticlePopupTransition.h
@@ -0,0 +1,41 @@
+
+@import UIKit;
+
+
+#import <UIKit/UIKit.h>
+
+@interface WMFArticlePopupTransition : UIPercentDrivenInteractiveTransition <UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning, UIViewControllerInteractiveTransitioning>
+
+- (instancetype)initWithPresentingViewController:(UIViewController*)presentingViewController presentedViewController:(UIViewController*)presentedViewController contentScrollView:(UIScrollView*)scrollView;
+
+@property (nonatomic, weak, readonly) UIViewController* modalController;
+
+@property (nonatomic, weak, readonly) UIScrollView* scrollView;
+
+/**
+ *  Duration of the animation when not interactive
+ */
+@property (assign, nonatomic) NSTimeInterval nonInteractiveDuration;
+
+/**
+ *  Set to control the height of the popup.
+ *  Set before presenting
+ *  Default is 300.0
+ */
+@property (assign, nonatomic) CGFloat popupHeight;
+
+/**
+ *  Set to NO to disable interactive presentation
+ *  Default is YES
+ */
+@property (assign, nonatomic) BOOL presentInteractively;
+
+/**
+ *  Set to NO to disable interactive dismissal
+ *  Default is YES
+ */
+@property (assign, nonatomic) BOOL dismissInteractively;
+
+
+
+@end
diff --git a/Wikipedia/UI-V5/WMFArticlePopupTransition.m b/Wikipedia/UI-V5/WMFArticlePopupTransition.m
new file mode 100644
index 00000000000..c40a2c4a75e
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticlePopupTransition.m
@@ -0,0 +1,373 @@
+
+
+#import "WMFArticlePopupTransition.h"
+#import "WMFScrollViewTopPanGestureRecognizer.h"
+
+@interface WMFArticlePopupTransition ()<UIGestureRecognizerDelegate>
+
+@property (nonatomic, weak, readwrite) UIViewController* presentingViewController;
+@property (nonatomic, weak, readwrite) UIViewController* presentedViewController;
+@property (nonatomic, weak, readwrite) UIScrollView* scrollView;
+
+@property (nonatomic, assign, readwrite) BOOL isPresented;
+@property (nonatomic, assign, readwrite) BOOL isDismissing;
+@property (nonatomic, assign, readwrite) BOOL isPresenting;
+
+@property (strong, nonatomic) UIPanGestureRecognizer* presentGestureRecognizer;
+@property (strong, nonatomic) WMFScrollViewTopPanGestureRecognizer* dismissGestureRecognizer;
+@property (assign, nonatomic) BOOL interactionInProgress;
+
+@property (assign, nonatomic) CGFloat popupAnimationDuration;
+@property (strong, nonatomic) CADisplayLink* popupAnimationTimer;
+@property (assign, nonatomic) CGFloat popupAnimationStartTime;
+@property (assign, nonatomic) CGFloat popupHeightAsProgress;
+@property (assign, nonatomic) CGFloat totalCardAnimationDistance;
+
+@end
+
+
+@implementation WMFArticlePopupTransition
+
+- (instancetype)initWithPresentingViewController:(UIViewController*)presentingViewController presentedViewController:(UIViewController*)presentedViewController contentScrollView:(UIScrollView*)scrollView {
+    self = [super init];
+    if (self) {
+        _presentInteractively     = YES;
+        _dismissInteractively     = YES;
+        _popupHeight              = 300.0;
+        _popupAnimationDuration   = 0.3;
+        _presentingViewController = presentingViewController;
+        _presentedViewController  = presentedViewController;
+        _scrollView               = scrollView;
+        [self addPresentGestureRecoginizer];
+    }
+    return self;
+}
+
+- (void)setPresentInteractively:(BOOL)presentInteractively {
+    _presentInteractively = presentInteractively;
+    [self addPresentGestureRecoginizer];
+}
+
+- (void)setDismissInteractively:(BOOL)dismissInteractively {
+    _dismissInteractively = dismissInteractively;
+    [self addDismissGestureRecognizer];
+}
+
+#pragma mark - UIViewControllerTransitioningDelegate
+
+- (id<UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController*)presented presentingController:(UIViewController*)presenting sourceController:(UIViewController*)source {
+    return self;
+}
+
+- (id<UIViewControllerAnimatedTransitioning>)animationControllerForDismissedController:(UIViewController*)dismissed {
+    return self;
+}
+
+- (id<UIViewControllerInteractiveTransitioning>)interactionControllerForPresentation:(id<UIViewControllerAnimatedTransitioning>)animator {
+    if (self.presentInteractively) {
+        return self;
+    }
+    return nil;
+}
+
+- (id<UIViewControllerInteractiveTransitioning>)interactionControllerForDismissal:(id<UIViewControllerAnimatedTransitioning>)animator {
+    if (self.dismissInteractively) {
+        return self;
+    }
+    return nil;
+}
+
+#pragma mark - UIViewAnimatedTransistioning
+
+- (NSTimeInterval)transitionDuration:(id<UIViewControllerContextTransitioning>)transitionContext {
+    return self.nonInteractiveDuration;
+}
+
+- (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
+    self.totalCardAnimationDistance = CGRectGetHeight([transitionContext containerView].frame);
+
+    if (self.isPresented) {
+        [self animateDismiss:transitionContext];
+    } else {
+        [self animatePresentation:transitionContext];
+    }
+}
+
+#pragma mark - UIViewControllerInteractiveTransitioning
+
+- (void)startInteractiveTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
+    //this needs to happen before super becuase it is used to modify the animations that start in the super call
+    self.interactionInProgress = YES;
+    [super startInteractiveTransition:transitionContext];
+
+    if (!self.isPresented) {
+        //Animate the transition partially to get the view on screen
+        [self animateToPopupPosition];
+    }
+}
+
+- (CGFloat)completionSpeed {
+    return (1 - self.percentComplete) * 1.5;
+}
+
+- (UIViewAnimationCurve)completionCurve {
+    return UIViewAnimationCurveEaseOut;
+}
+
+#pragma mark - Animation
+
+- (CGFloat)animationProgressFromHeight:(CGFloat)height {
+    return height / self.totalCardAnimationDistance;
+}
+
+- (void)animateToPopupPosition {
+    self.popupHeightAsProgress   = [self animationProgressFromHeight:self.popupHeight];
+    self.popupAnimationStartTime = CACurrentMediaTime();
+    self.popupAnimationTimer     = [CADisplayLink displayLinkWithTarget:self selector:@selector(animatePopupWithTimer:)];
+    [self.popupAnimationTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
+}
+
+- (void)animatePopupWithTimer:(CADisplayLink*)link {
+    NSTimeInterval elapedTime = link.timestamp - self.popupAnimationStartTime;
+    CGFloat percentComplete   = MIN(1.0, elapedTime / self.popupAnimationDuration) * self.popupHeightAsProgress;
+    NSLog(@"%f", percentComplete);
+
+    [self updateInteractiveTransition:percentComplete];
+
+    if (percentComplete >= self.popupHeightAsProgress) {
+        [link invalidate];
+        link = nil;
+    }
+}
+
+- (void)animatePresentation:(id<UIViewControllerContextTransitioning>)transitionContext {
+    UIView* containerView = [transitionContext containerView];
+
+//    UIViewController* fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
+    UIViewController* toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
+
+//    UIView* fromView = fromVC.view;
+    UIView* toView = toVC.view;
+
+    //Setup toView
+    CGRect toViewFinalFrame = [transitionContext finalFrameForViewController:toVC];
+
+    CGRect toViewStartFrame;
+
+    if ([toView superview]) {
+        toViewStartFrame = [containerView convertRect:toView.frame fromView:[toView superview]];
+    } else {
+        toViewStartFrame          = toViewFinalFrame;
+        toViewStartFrame.origin.y = CGRectGetHeight(containerView.bounds);
+    }
+
+    toView.frame = toViewStartFrame;
+    [containerView addSubview:toView];
+
+    self.isPresenting = YES;
+
+    [self performAnimations:^{
+        toView.frame = toViewFinalFrame;
+    } completion:^(BOOL finished) {
+        self.isPresenting = NO;
+        self.isPresented = ![transitionContext transitionWasCancelled];
+
+        [self addDismissGestureRecognizer];
+        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    }];
+}
+
+- (void)animateDismiss:(id<UIViewControllerContextTransitioning>)transitionContext {
+    UIView* containerView = [transitionContext containerView];
+
+    UIViewController* fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
+//    UIViewController* toVC   = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
+
+    UIView* fromView = fromVC.view;
+//    UIView* toView   = toVC.view;
+
+    //Setup fromView
+    CGRect fromViewStartFrame = fromView.frame;
+    CGRect fromViewFinalFrame = fromViewStartFrame;
+    fromViewFinalFrame.origin.y = CGRectGetHeight(containerView.bounds);
+    fromView.frame              = fromViewStartFrame;
+    [containerView addSubview:fromView];
+
+    self.isPresenting = YES;
+    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
+        fromView.frame = fromViewFinalFrame;
+    } completion:^(BOOL finished) {
+        self.isPresenting = NO;
+        self.isPresented = [transitionContext transitionWasCancelled];
+        [self addPresentGestureRecoginizer];
+
+        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    }];
+}
+
+- (void)performAnimations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion {
+    if (self.interactionInProgress) {
+        [UIView animateWithDuration:self.nonInteractiveDuration delay:0.0 options:UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionCurveLinear animations:^{
+            if (animations) {
+                animations();
+            }
+        } completion:^(BOOL finished) {
+            if (completion) {
+                completion(finished);
+            }
+        }];
+    } else {
+        [UIView animateWithDuration:self.nonInteractiveDuration delay:0.0 usingSpringWithDamping:0.8 initialSpringVelocity:0.0 options:0 animations:^{
+            if (animations) {
+                animations();
+            }
+        } completion:^(BOOL finished) {
+            if (completion) {
+                completion(finished);
+            }
+        }];
+    }
+}
+
+#pragma mark - UIGestureRecognizerDelegate
+
+- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer*)gestureRecognizer {
+    return YES;
+}
+
+- (BOOL)gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer*)otherGestureRecognizer {
+    return YES;
+}
+
+#pragma mark - Gestures
+
+- (void)addPresentGestureRecoginizer {
+    if (self.isPresented) {
+        return;
+    }
+
+    if (self.dismissGestureRecognizer) {
+        [self.presentedViewController.view removeGestureRecognizer:self.dismissGestureRecognizer];
+        self.dismissGestureRecognizer.delegate = nil;
+        self.dismissGestureRecognizer          = nil;
+    }
+
+    if (!self.presentGestureRecognizer) {
+        self.presentGestureRecognizer          = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePresentGesture:)];
+        self.presentGestureRecognizer.delegate = self;
+        [self.presentedViewController.view addGestureRecognizer:self.presentGestureRecognizer];
+    }
+}
+
+- (void)addDismissGestureRecognizer {
+    if (!self.isPresented) {
+        return;
+    }
+
+    if (self.presentGestureRecognizer) {
+        [self.presentedViewController.view removeGestureRecognizer:self.presentGestureRecognizer];
+        self.presentGestureRecognizer.delegate = nil;
+        self.presentGestureRecognizer          = nil;
+    }
+
+    if (!self.dismissGestureRecognizer) {
+        self.dismissGestureRecognizer          = (id)[[WMFScrollViewTopPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleDismissGesture:)];
+        self.dismissGestureRecognizer.delegate = self;
+        [self.presentedViewController.view addGestureRecognizer:self.dismissGestureRecognizer];
+        [self.dismissGestureRecognizer setScrollview:self.scrollView];
+    }
+}
+
+- (void)handlePresentGesture:(UIPanGestureRecognizer*)recognizer {
+    switch (recognizer.state) {
+        case UIGestureRecognizerStateBegan: {
+            break;
+        }
+
+        case UIGestureRecognizerStateChanged: {
+            CGPoint distanceTraveled = [recognizer locationInView:recognizer.view];
+            CGFloat percent          = distanceTraveled.y / self.totalCardAnimationDistance;
+            percent = 1 - percent;
+
+            if (percent > 0.99) {
+                percent = 0.99;
+            }
+
+            [self updateInteractiveTransition:percent];
+            break;
+        }
+
+        case UIGestureRecognizerStateEnded: {
+            if (self.percentComplete >= 0.33) {
+                [self finishInteractiveTransition];
+                return;
+            }
+
+            BOOL fastSwipe = [recognizer velocityInView:recognizer.view].y < self.totalCardAnimationDistance;
+
+            if (fastSwipe) {
+                [self finishInteractiveTransition];
+                return;
+            }
+
+            [self cancelInteractiveTransition];
+
+            break;
+        }
+
+        default:
+            [self cancelInteractiveTransition];
+            break;
+    }
+}
+
+- (void)handleDismissGesture:(UIPanGestureRecognizer*)recognizer {
+    switch (recognizer.state) {
+        case UIGestureRecognizerStateBegan: {
+            CGPoint translation     = [recognizer translationInView:recognizer.view];
+            BOOL swipeIsTopToBottom = translation.y > 0;
+            if (swipeIsTopToBottom) {
+                [self.presentedViewController dismissViewControllerAnimated:YES completion:nil];
+            }
+
+            break;
+        }
+
+        case UIGestureRecognizerStateChanged: {
+            CGPoint distanceTraveled = [recognizer translationInView:recognizer.view];
+            CGFloat percent          = distanceTraveled.y / self.totalCardAnimationDistance;
+            if (percent > 0.99) {
+                percent = 0.99;
+            }
+
+            [self updateInteractiveTransition:percent];
+
+            break;
+        }
+
+        case UIGestureRecognizerStateEnded: {
+            if (self.percentComplete >= 0.33) {
+                [self finishInteractiveTransition];
+                return;
+            }
+
+            BOOL fastSwipe = [recognizer velocityInView:recognizer.view].y > self.totalCardAnimationDistance;
+
+            if (fastSwipe) {
+                [self finishInteractiveTransition];
+                return;
+            }
+
+            [self cancelInteractiveTransition];
+
+
+            break;
+        }
+
+        default:
+            [self cancelInteractiveTransition];
+            break;
+    }
+}
+
+@end
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.h b/Wikipedia/UI-V5/WMFArticleViewController.h
index 56c41c73ea7..7f77c440b8e 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.h
+++ b/Wikipedia/UI-V5/WMFArticleViewController.h
@@ -3,6 +3,8 @@
 
 @interface WMFArticleViewController : UIViewController
 
++ (instancetype)articleViewControllerFromDefaultStoryBoard;
+
 @property (nonatomic, assign) CGFloat contentTopInset;
 
 @property (nonatomic, strong) MWKSavedPageList* savedPages;
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.m b/Wikipedia/UI-V5/WMFArticleViewController.m
index 7d53af7d1b8..6863bb07ec5 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleViewController.m
@@ -1,10 +1,13 @@
 
 #import "WMFArticleViewController.h"
 #import <Masonry/Masonry.h>
-#import "WMFArticlePresenter.h"
 #import "Wikipedia-Swift.h"
 #import "PromiseKit.h"
 #import "UIButton+WMFButton.h"
+#import "WebViewController.h"
+#import "UIStoryboard+WMFExtensions.h"
+#import "UIViewController+WMFStoryboardUtilities.h"
+
 
 @interface WMFArticleViewController ()
 
@@ -16,8 +19,16 @@ @interface WMFArticleViewController ()
 
 @implementation WMFArticleViewController
 
++ (instancetype)articleViewControllerFromDefaultStoryBoard {
+    return [[UIStoryboard wmf_appRootStoryBoard] wmf_instantiateViewControllerWithIdentifierFromClass:[WMFArticleViewController class]];
+}
+
 - (IBAction)readButtonTapped:(id)sender {
-    [[WMFArticlePresenter sharedInstance] presentArticleWithTitle:self.article.title discoveryMethod:MWKHistoryDiscoveryMethodSearch];
+    WebViewController* webVC   = [WebViewController wmf_initialViewControllerFromClassStoryboard];
+    UINavigationController* nc = [[UINavigationController alloc] initWithRootViewController:webVC];
+    [self presentViewController:nc animated:YES completion:^{
+        [webVC navigateToPage:self.article.title discoveryMethod:MWKHistoryDiscoveryMethodUnknown];
+    }];
 }
 
 - (void)setContentTopInset:(CGFloat)contentTopInset {
diff --git a/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.h b/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.h
new file mode 100644
index 00000000000..96d6baf11b4
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.h
@@ -0,0 +1,9 @@
+
+#import <UIKit/UIKit.h>
+
+@interface WMFScrollViewTopPanGestureRecognizer : UIPanGestureRecognizer
+
+@property (nonatomic, weak) UIScrollView* scrollview;
+
+@end
+
diff --git a/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.m b/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.m
new file mode 100644
index 00000000000..8e83ee76eb9
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFScrollViewTopPanGestureRecognizer.m
@@ -0,0 +1,48 @@
+#import "WMFScrollViewTopPanGestureRecognizer.h"
+#import <UIKit/UIGestureRecognizerSubclass.h>
+
+@interface WMFScrollViewTopPanGestureRecognizer ()
+@property (nonatomic, strong) NSNumber* isFail;
+@end
+
+@implementation WMFScrollViewTopPanGestureRecognizer
+
+- (void)reset {
+    [super reset];
+    self.isFail = nil;
+}
+
+- (void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event {
+    [super touchesMoved:touches withEvent:event];
+
+    if (!self.scrollview) {
+        return;
+    }
+
+    if (self.state == UIGestureRecognizerStateFailed) {
+        return;
+    }
+    CGPoint nowPoint  = [touches.anyObject locationInView:self.view];
+    CGPoint prevPoint = [touches.anyObject previousLocationInView:self.view];
+
+    if (self.isFail) {
+        if (self.isFail.boolValue) {
+            self.state = UIGestureRecognizerStateFailed;
+        }
+        return;
+    }
+
+    CGFloat topVerticalOffset = -self.scrollview.contentInset.top;
+
+    if (nowPoint.y > prevPoint.y && self.scrollview.contentOffset.y <= topVerticalOffset) {
+        self.isFail = @NO;
+    } else if (self.scrollview.contentOffset.y >= topVerticalOffset) {
+        self.state  = UIGestureRecognizerStateFailed;
+        self.isFail = @YES;
+    } else {
+        self.isFail = @NO;
+    }
+}
+
+@end
+
diff --git a/Wikipedia/View Controllers/WebView/WebViewController.m b/Wikipedia/View Controllers/WebView/WebViewController.m
index dbf2d5658c5..ba2c5468146 100644
--- a/Wikipedia/View Controllers/WebView/WebViewController.m	
+++ b/Wikipedia/View Controllers/WebView/WebViewController.m	
@@ -5,7 +5,6 @@
 #import <Masonry/Masonry.h>
 #import "NSString+WMFHTMLParsing.h"
 
-#import "PrimaryMenuViewController.h"
 #import "UIBarButtonItem+WMFButtonConvenience.h"
 #import "RandomArticleFetcher.h"
 #import "MWKSiteInfoFetcher.h"
@@ -15,6 +14,7 @@
 #import "Wikipedia-Swift.h"
 #import "PromiseKit.h"
 
+#import <BlocksKit/BlocksKit+UIKit.h>
 
 #import "WMFShareCardViewController.h"
 #import "WMFShareFunnel.h"
@@ -22,6 +22,9 @@
 #import "UIWebView+WMFSuppressSelection.h"
 #import "WMFArticlePresenter.h"
 #import "UIView+WMFRTLMirroring.h"
+#import "WMFArticlePopupTransition.h"
+#import "WMFArticleViewController.h"
+
 
 typedef NS_ENUM (NSInteger, WMFWebViewAlertType) {
     WMFWebViewAlertZeroWebPage,
@@ -46,6 +49,8 @@ @interface WebViewController () <LanguageSelectionDelegate, WMFWebViewFooterCont
 @property (strong, nonatomic) WMFShareOptionsViewController* shareOptionsViewController;
 @property (strong, nonatomic) NSString* wikipediaZeroLearnMoreExternalUrl;
 
+@property (strong, nonatomic) WMFArticlePopupTransition* popupTransition;
+
 @end
 
 @implementation WebViewController
@@ -94,20 +99,12 @@ - (UIStatusBarAnimation)preferredStatusBarUpdateAnimation {
 
 - (void)setupTopMenuButtons {
     @weakify(self)
-    UIBarButtonItem * buttonW = [UIBarButtonItem wmf_buttonType:WMFButtonTypeW handler:^(id sender){
-        @strongify(self)
-        UINavigationController * nc = [[UINavigationController alloc] initWithRootViewController:[PrimaryMenuViewController wmf_initialViewControllerFromClassStoryboard]];
-        [nc.navigationBar setBarTintColor:[UIColor blackColor]];
-        [nc.navigationBar setTranslucent:NO];
-        [self presentViewController:nc animated:YES completion:nil];
-    }];
 
-    UIBarButtonItem* buttonMagnify = [UIBarButtonItem wmf_buttonType:WMFButtonTypeMagnify handler:^(id sender){
-        @strongify(self)
-        [self dismissViewControllerAnimated : YES completion : nil];
+    UIBarButtonItem * done = [[UIBarButtonItem alloc] bk_initWithBarButtonSystemItem:UIBarButtonSystemItemDone handler:^(id sender) {
+        [self dismissViewControllerAnimated:YES completion:NULL];
     }];
 
-    self.navigationItem.leftBarButtonItems = @[buttonW, buttonMagnify];
+    self.navigationItem.leftBarButtonItem = done;
 
     self.buttonTOC = [UIBarButtonItem wmf_buttonType:WMFButtonTypeTableOfContents
                                              handler:^(id sender){
@@ -115,7 +112,7 @@ - (void)setupTopMenuButtons {
         [self tocToggle];
     }];
 
-    self.navigationItem.rightBarButtonItems = @[self.buttonTOC];
+    self.navigationItem.rightBarButtonItem = self.buttonTOC;
 }
 
 - (void)setupBottomMenuButtons {
@@ -257,8 +254,6 @@ - (void)viewDidLoad {
 
     [self tocSetupSwipeGestureRecognizers];
 
-    [self reloadCurrentArticleFromCache];
-
     // Restrict the web view from scrolling horizonally.
     [self.webView.scrollView addObserver:self
                               forKeyPath:@"contentSize"
@@ -806,13 +801,10 @@ - (CommunicationBridge*)bridge {
             }
 
             if ([href wmf_isInternalLink]) {
-                // Ensure the menu is visible when navigating to new page.
-                [strSelf animateTopAndBottomMenuReveal];
-
                 MWKTitle* pageTitle = [[SessionSingleton sharedInstance].currentArticleSite titleWithInternalLink:href];
+                MWKArticle* article = [[MWKArticle alloc] initWithTitle:pageTitle dataStore:strSelf.session.dataStore];
 
-                [strSelf navigateToPage:pageTitle
-                        discoveryMethod:MWKHistoryDiscoveryMethodLink];
+                [strSelf presentPopupForArticle:article];
             } else if ([href hasPrefix:@"http:"] || [href hasPrefix:@"https:"] || [href hasPrefix:@"//"]) {
                 // A standard external link, either explicitly http(s) or left protocol-relative on web meaning http(s)
                 if ([href hasPrefix:@"//"]) {
@@ -1190,26 +1182,6 @@ - (BOOL)scrollViewShouldScrollToTop:(UIScrollView*)scrollView {
 
 - (void)didReceiveMemoryWarning {
     [super didReceiveMemoryWarning];
-    // Dispose of any resources that can be recreated.
-
-    //[self showOnboarding];
-
-    //self.buttonTOC.disabled = !self.buttonTOC.disabled;
-    //self.buttonTOC.disabledColor = [UIColor redColor];
-
-    //[self downloadAssetsFilesIfNecessary];
-
-    //DataHousekeeping *dataHouseKeeping = [[DataHousekeeping alloc] init];
-    //[dataHouseKeeping performHouseKeeping];
-
-    // Do not remove the following commented toggle. It's for testing W0 stuff.
-    //[self.session.zeroConfigState toggleFakeZeroOn];
-
-
-    //ReferencesVC *referencesVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"ReferencesVC"];
-    //[self presentViewController:referencesVC animated:YES completion:^{}];
-
-    //NSLog(@"articleFetchManager.operationCount = %lu", (unsigned long)[QueuesSingleton sharedInstance].articleFetchManager.operationQueue.operationCount);
 }
 
 - (void)updateHistoryDateVisitedForArticleBeingNavigatedFrom {
@@ -1320,6 +1292,20 @@ - (void)retrieveArticleForPageTitle:(MWKTitle*)pageTitle
     }
 }
 
+- (void)presentPopupForArticle:(MWKArticle*)article {
+    WMFArticleViewController* vc = [WMFArticleViewController articleViewControllerFromDefaultStoryBoard];
+    vc.savedPages      = self.session.userDataStore.savedPageList;
+    vc.article         = article;
+    vc.contentTopInset = 64.0;
+
+    self.popupTransition                        = [[WMFArticlePopupTransition alloc] initWithPresentingViewController:self presentedViewController:vc contentScrollView:nil];
+    self.popupTransition.nonInteractiveDuration = 0.5;
+    vc.transitioningDelegate                    = self.popupTransition;
+    vc.modalPresentationStyle                   = UIModalPresentationCustom;
+
+    [self presentViewController:vc animated:YES completion:NULL];
+}
+
 #pragma mark - ArticleFetcherDelegate
 
 - (void)articleFetcher:(ArticleFetcher*)savedArticlesFetcher
