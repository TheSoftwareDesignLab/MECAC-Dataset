diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 28c63cdf63a..18579f4bedc 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -2508,6 +2508,7 @@
 			children = (
 				BCDBCC6D1BDA59CC002298FC /* WMFArticleContainerViewController+TOC.swift */,
 				BC7FA4BF1BD6A687006CA1A3 /* View Controller */,
+				0E9DFEB11BDEBAEA0032606E /* Animation */,
 				BC7FA4C01BD6A693006CA1A3 /* Cell */,
 				BC7FA4C11BD6A69E006CA1A3 /* Items */,
 			);
@@ -2609,6 +2610,15 @@
 			name = "App View Controller";
 			sourceTree = "<group>";
 		};
+		0E9DFEB11BDEBAEA0032606E /* Animation */ = {
+			isa = PBXGroup;
+			children = (
+				0E2143041BBF178500609E5D /* WMFTableOfContentsPresentationController.swift */,
+				0E2143061BBF187300609E5D /* WMFTableOfContentsAnimator.swift */,
+			);
+			name = Animation;
+			sourceTree = "<group>";
+		};
 		0EA1791D1BD95910004FF529 /* Random */ = {
 			isa = PBXGroup;
 			children = (
@@ -2919,8 +2929,6 @@
 			isa = PBXGroup;
 			children = (
 				0E4D1CF71BBD7F49009BEB64 /* WMFTableOfContentsViewController.swift */,
-				0E2143041BBF178500609E5D /* WMFTableOfContentsPresentationController.swift */,
-				0E2143061BBF187300609E5D /* WMFTableOfContentsAnimator.swift */,
 			);
 			name = "View Controller";
 			sourceTree = "<group>";
diff --git a/Wikipedia/UI-V5/WMFTableOfContentsAnimator.swift b/Wikipedia/UI-V5/WMFTableOfContentsAnimator.swift
index c5a84af3c5f..027fa23b6c7 100644
--- a/Wikipedia/UI-V5/WMFTableOfContentsAnimator.swift
+++ b/Wikipedia/UI-V5/WMFTableOfContentsAnimator.swift
@@ -1,23 +1,95 @@
 
 import UIKit
 
-class WMFTableOfContentsAnimator: NSObject, UIViewControllerAnimatedTransitioning {
+// MARK: - Delegate
+@objc public protocol WMFTableOfContentsAnimatorDelegate {
     
-    // MARK: - init
-    let isPresenting :Bool
+    func tableOfContentsAnimatorDidTapBackground(controller: WMFTableOfContentsAnimator)
+}
+
+public class WMFTableOfContentsAnimator: UIPercentDrivenInteractiveTransition, UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning, UIGestureRecognizerDelegate, WMFTableOfContentsPresentationControllerTapDelegate {
     
-    init(isPresenting: Bool) {
-        self.isPresenting = isPresenting
+    // MARK: - init
+    public required init(presentingViewController: UIViewController, presentedViewController: UIViewController) {
+        self.presentingViewController = presentingViewController
+        self.presentedViewController = presentedViewController
+        self.isPresenting = true
+        self.isInteractive = false
         super.init()
+        self.presentingViewController!.view.addGestureRecognizer(self.presentationGesture)
+    }
+    
+    deinit {
+        self.presentationGesture.view?.removeGestureRecognizer(self.presentationGesture)
+        self.presentationGesture.removeTarget(self, action: Selector("handlePanGesture:"))
+        removeDismissalGestureRecognizer()
+    }
+    
+    weak var presentingViewController: UIViewController?
+    
+    weak var presentedViewController: UIViewController?
+
+    weak public var delegate: WMFTableOfContentsAnimatorDelegate?
+    
+    private(set) public var isPresenting: Bool
+    
+    private(set) public var isInteractive: Bool
+    
+    
+    // MARK: - WMFTableOfContentsPresentationControllerTapDelegate
+    public func tableOfContentsPresentationControllerDidTapBackground(controller: WMFTableOfContentsPresentationController) {
+        delegate?.tableOfContentsAnimatorDidTapBackground(self)
     }
     
+    // MARK: - UIViewControllerTransitioningDelegate
+    public func presentationControllerForPresentedViewController(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -> UIPresentationController? {
+        guard presented == self.presentedViewController else {
+            return nil
+        }
+        return WMFTableOfContentsPresentationController(presentedViewController: presented, presentingViewController: presenting, tapDelegate: self)
+    }
+    
+    public func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
+        guard presented == self.presentedViewController else {
+            return nil
+        }
+        self.isPresenting = true
+        return self
+    }
+    
+    public func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
+        guard dismissed == self.presentedViewController else {
+            return nil
+        }
+        self.isPresenting = false
+        return self
+    }
+    
+    public func interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
+        if self.isInteractive {
+            return self
+        }else{
+            return nil
+        }
+    }
+    
+    public func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
+        if self.isInteractive {
+            return self
+        }else{
+            return nil
+        }
+    }
+
     // MARK: - UIViewControllerAnimatedTransitioning
-    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -> NSTimeInterval {
+    public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -> NSTimeInterval {
         return self.isPresenting ? 0.5 : 0.8
     }
     
-    func animateTransition(transitionContext: UIViewControllerContextTransitioning)  {
+    public func animateTransition(transitionContext: UIViewControllerContextTransitioning)  {
         if isPresenting {
+            removeDismissalGestureRecognizer()
+            addDismissalGestureRecognizer(transitionContext.containerView()!)
             animatePresentationWithTransitionContext(transitionContext)
         }
         else {
@@ -32,14 +104,16 @@ class WMFTableOfContentsAnimator: NSObject, UIViewControllerAnimatedTransitionin
         let containerView = transitionContext.containerView()!
         
         // Position the presented view off the top of the container view
-        presentedControllerView.frame = transitionContext.finalFrameForViewController(presentedController)
-        presentedControllerView.center.x += containerView.bounds.size.width
+        var f = transitionContext.finalFrameForViewController(presentedController)
+        f.origin.x += f.size.width
+        presentedControllerView.frame = f
         
         containerView.addSubview(presentedControllerView)
         
-        // Animate the presented view to it's final position
-        UIView.animateWithDuration(self.transitionDuration(transitionContext), delay: 0.0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
-            presentedControllerView.center.x -= containerView.bounds.size.width
+        animateTransition(self.isInteractive, duration: self.transitionDuration(transitionContext), animations: { () -> Void in
+            var f = presentedControllerView.frame
+            f.origin.x -= f.size.width
+            presentedControllerView.frame = f
             }, completion: {(completed: Bool) -> Void in
                 transitionContext.completeTransition(!transitionContext.transitionWasCancelled())
         })
@@ -47,13 +121,164 @@ class WMFTableOfContentsAnimator: NSObject, UIViewControllerAnimatedTransitionin
     
     func animateDismissalWithTransitionContext(transitionContext: UIViewControllerContextTransitioning) {
         let presentedControllerView = transitionContext.viewForKey(UITransitionContextFromViewKey)!
-        let containerView = transitionContext.containerView()!
         
-        // Animate the presented view off the bottom of the view
-        UIView.animateWithDuration(self.transitionDuration(transitionContext), delay: 0.0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
-            presentedControllerView.center.x += containerView.bounds.size.width
+        animateTransition(self.isInteractive, duration: self.transitionDuration(transitionContext), animations: { () -> Void in
+            var f = presentedControllerView.frame
+            f.origin.x += f.size.width
+            presentedControllerView.frame = f
+
             }, completion: {(completed: Bool) -> Void in
                 transitionContext.completeTransition(!transitionContext.transitionWasCancelled())
         })
     }
+    
+    func animateTransition(interactive: Bool, duration: NSTimeInterval, animations: () -> Void, completion: ((Bool) -> Void)?){
+        
+        if(interactive){
+            UIView.animateWithDuration(duration, delay: 0.0, options: .CurveLinear, animations: { () -> Void in
+                animations()
+                }, completion: { (completed: Bool) -> Void in
+                    completion?(completed)
+            })
+    
+        }else{
+            UIView.animateWithDuration(duration, delay: 0.0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
+                animations()
+                }, completion: {(completed: Bool) -> Void in
+                    completion?(completed)
+            })
+        }
+    }
+    
+    
+    // MARK: - Gestures
+    lazy var presentationGesture: UIScreenEdgePanGestureRecognizer = {
+        let gesture = UIScreenEdgePanGestureRecognizer.init(target: self, action: Selector("handlePresentationGesture:"))
+        gesture.edges = .Right
+        return gesture
+    }()
+    
+    var dismissalGesture: UIPanGestureRecognizer?
+    
+    func addDismissalGestureRecognizer(containerView: UIView) {
+        let gesture = UIPanGestureRecognizer.init(target: self, action: Selector("handleDismissalGesture:"))
+        gesture.delegate = self
+        containerView.addGestureRecognizer(gesture)
+        self.dismissalGesture = gesture
+    }
+
+    func removeDismissalGestureRecognizer() {
+        if let dismissalGesture = self.dismissalGesture {
+            dismissalGesture.view?.removeGestureRecognizer(dismissalGesture)
+            dismissalGesture.removeTarget(self, action: Selector("handleDismissalGesture:"))
+        }
+        self.dismissalGesture = nil
+    }
+    func handlePresentationGesture(gesture: UIScreenEdgePanGestureRecognizer) {
+        
+        switch(gesture.state) {
+        case (.Began):
+            self.isInteractive = true
+            self.presentingViewController?.presentViewController(self.presentedViewController!, animated: true, completion: nil)
+        case (.Changed):
+            let position = gesture.locationInView(gesture.view);
+            let distanceFromRight = CGRectGetMaxX(gesture.view!.bounds) - position.x
+            let transitionProgress = distanceFromRight / CGRectGetMaxX(gesture.view!.bounds)
+            self.updateInteractiveTransition(transitionProgress)
+        case (.Ended):
+            self.isInteractive = false
+            let velocityRequiredToPresent = -CGRectGetWidth(gesture.view!.bounds)
+            let velocityRequiredToDismiss = CGRectGetWidth(gesture.view!.bounds)
+            
+            let velocityX = gesture.velocityInView(gesture.view).x
+            if velocityX > velocityRequiredToDismiss{
+                self.cancelInteractiveTransition()
+                return
+            }
+            
+            if velocityX > velocityRequiredToPresent{
+                self.finishInteractiveTransition()
+                return
+            }
+            
+            let progressRequiredToPresent = 0.33
+            
+            if(self.percentComplete >= CGFloat(progressRequiredToPresent)){
+                self.finishInteractiveTransition()
+                return
+            }
+            
+            self.cancelInteractiveTransition()
+            
+        case (.Cancelled):
+            self.isInteractive = false
+            self.cancelInteractiveTransition()
+            
+        default :
+            break
+        }
+    }
+    
+    func handleDismissalGesture(gesture: UIScreenEdgePanGestureRecognizer) {
+        
+        switch(gesture.state) {
+        case (.Began):
+            self.isInteractive = true
+            self.presentingViewController?.dismissViewControllerAnimated(true, completion: nil)
+        case (.Changed):
+//            let position = gesture.locationInView(gesture.view)
+            let translation = gesture.translationInView(gesture.view)
+            let transitionProgress = translation.x / CGRectGetMaxX(self.presentedViewController!.view.bounds)
+            self.updateInteractiveTransition(transitionProgress)
+            print(transitionProgress)
+        case (.Ended):
+            self.isInteractive = false
+            let velocityRequiredToPresent = -CGRectGetMaxX(gesture.view!.bounds)
+            let velocityRequiredToDismiss = CGRectGetWidth(gesture.view!.bounds)
+            
+            let velocityX = gesture.velocityInView(gesture.view).x
+            if velocityX > velocityRequiredToDismiss{
+                self.finishInteractiveTransition()
+                return
+            }
+            
+            if velocityX > velocityRequiredToPresent{
+                self.cancelInteractiveTransition()
+                return
+            }
+            
+            let progressRequiredToDismiss = 0.33
+            
+            if(self.percentComplete >= CGFloat(progressRequiredToDismiss)){
+                self.finishInteractiveTransition()
+                return
+            }
+            
+            self.cancelInteractiveTransition()
+            
+        case (.Cancelled):
+            self.isInteractive = false
+            self.cancelInteractiveTransition()
+            
+        default :
+            break
+        }
+    }
+    
+    // MARK: - UIGestureRecognizerDelegate
+    public func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -> Bool {
+        guard gestureRecognizer == self.dismissalGesture else {
+            return true
+        }
+        
+        if let translation = self.dismissalGesture?.translationInView(dismissalGesture?.view) {
+            if(translation.x > 0){
+                return true
+            }else{
+                return false
+            }
+        }else{
+            return false
+        }
+    }
 }
