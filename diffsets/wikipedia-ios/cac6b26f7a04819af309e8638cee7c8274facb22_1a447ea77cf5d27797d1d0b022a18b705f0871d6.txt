diff --git a/WMF Framework/UIView+SemanticContent.swift b/WMF Framework/UIView+SemanticContent.swift
index 94a0da70a53..a7c3f645660 100644
--- a/WMF Framework/UIView+SemanticContent.swift	
+++ b/WMF Framework/UIView+SemanticContent.swift	
@@ -1,3 +1,15 @@
+public enum HorizontalAlignment : Int {
+    case center
+    case left
+    case right
+}
+
+public enum VerticalAlignment : Int {
+    case center
+    case top
+    case bottom
+}
+
 extension UIView {
     public var wmf_effectiveUserInterfaceLayoutDirection: UIUserInterfaceLayoutDirection {
         if #available(iOS 10.0, *) {
@@ -7,20 +19,69 @@ extension UIView {
         }
     }
     
-    public func wmf_preferredFrame(at point: CGPoint, fitting size: CGSize, alignedBy semanticContentAttribute: UISemanticContentAttribute, apply: Bool) -> CGRect {
-        let viewSize = sizeThatFits(size)
-        var actualX = point.x
-        let actualWidth = min(viewSize.width, size.width)
-        if semanticContentAttribute == .forceRightToLeft {
-            actualX = point.x + size.width - actualWidth
+    public func wmf_preferredFrame(at point: CGPoint, maximumViewSize: CGSize, minimumLayoutAreaSize: CGSize = CGSize(width: UIViewNoIntrinsicMetric, height: UIViewNoIntrinsicMetric), horizontalAlignment: HorizontalAlignment, verticalAlignment: VerticalAlignment, apply: Bool) -> CGRect {
+        let viewSize = sizeThatFits(maximumViewSize)
+        var x = point.x
+        var y = point.y
+        
+        let viewWidth: CGFloat
+        if maximumViewSize.width == UIViewNoIntrinsicMetric { // width can be anything
+            viewWidth = viewSize.width
+        } else {
+            viewWidth = min(maximumViewSize.width, viewSize.width)
+        }
+        
+        let viewHeight: CGFloat
+        if maximumViewSize.height == UIViewNoIntrinsicMetric { // height can be anything
+            viewHeight = viewSize.height
+        } else {
+            viewHeight = min(maximumViewSize.width, viewSize.height)
+        }
+        
+        let widthToFit: CGFloat
+        if minimumLayoutAreaSize.width == UIViewNoIntrinsicMetric { // width can be 0
+            widthToFit = viewWidth
+        } else {
+            widthToFit = max(minimumLayoutAreaSize.width, viewWidth)
         }
-        let fitFrame = CGRect(x: actualX, y: point.y, width: actualWidth, height: viewSize.height)
+        
+        let heightToFit: CGFloat
+        if minimumLayoutAreaSize.height == UIViewNoIntrinsicMetric { // height can be 0
+            heightToFit = viewHeight
+        } else {
+            heightToFit = max(minimumLayoutAreaSize.height, viewHeight)
+        }
+        
+        switch verticalAlignment {
+        case .center:
+            y += floor(0.5*heightToFit - 0.5*viewHeight)
+        case .bottom:
+            y += (heightToFit - viewHeight)
+        case .top:
+            break
+        }
+        
+        switch horizontalAlignment {
+        case .center:
+            x += floor(0.5*widthToFit - 0.5*viewWidth)
+        case .right:
+            x += (widthToFit - viewWidth)
+        case .left:
+            break
+        }
+        
+        let fitFrame = CGRect(x: x, y: y, width: viewWidth, height: viewHeight)
         if apply {
             frame = fitFrame
         }
         return fitFrame
     }
     
+    public func wmf_preferredFrame(at point: CGPoint, fitting size: CGSize, alignedBy semanticContentAttribute: UISemanticContentAttribute, apply: Bool) -> CGRect {
+        let horizontalAlignment: HorizontalAlignment = semanticContentAttribute == .forceRightToLeft ? .right : .left
+        return wmf_preferredFrame(at: point, maximumViewSize: size, minimumLayoutAreaSize: size, horizontalAlignment: horizontalAlignment, verticalAlignment: .top, apply: apply)
+    }
+    
     @objc(wmf_preferredFrameAtPoint:fittingAvailableWidth:alignedBySemanticContentAttribute:apply:)
     public func wmf_preferredFrame(at point: CGPoint, fitting availableWidth: CGFloat, alignedBy semanticContentAttribute: UISemanticContentAttribute, apply: Bool) -> CGRect {
         let size = CGSize(width: availableWidth, height: CGFloat.greatestFiniteMagnitude)
@@ -30,6 +91,8 @@ extension UIView {
     public func wmf_preferredHeight(at point: CGPoint, fitting availableWidth: CGFloat, alignedBy semanticContentAttribute: UISemanticContentAttribute, spacing: CGFloat, apply: Bool) -> CGFloat {
         return wmf_preferredFrame(at: point, fitting: availableWidth, alignedBy: semanticContentAttribute, apply: apply).layoutHeight(with: spacing)
     }
+    
+    
 }
 
 extension UILabel {
diff --git a/Wikipedia/Code/ArticleRightAlignedImageCollectionViewCell.swift b/Wikipedia/Code/ArticleRightAlignedImageCollectionViewCell.swift
index c9f5066d5f8..6da5b7e1946 100644
--- a/Wikipedia/Code/ArticleRightAlignedImageCollectionViewCell.swift
+++ b/Wikipedia/Code/ArticleRightAlignedImageCollectionViewCell.swift
@@ -22,11 +22,12 @@ open class ArticleRightAlignedImageCollectionViewCell: ArticleCollectionViewCell
     override open func sizeThatFits(_ size: CGSize, apply: Bool) -> CGSize {
         let isRTL = articleSemanticContentAttribute == .forceRightToLeft
         var widthMinusMargins = size.width - margins.left - margins.right
-        let heightMinusMargins = size.height - margins.top - margins.bottom
-
+        let minHeight = imageViewDimension + margins.top + margins.bottom
+        let minHeightMinusMargins = minHeight - margins.top - margins.bottom
+        
         if !isImageViewHidden {
             if (apply) {
-                let imageViewY = margins.top + round(0.5*heightMinusMargins - 0.5*imageViewDimension)
+                let imageViewY = margins.top + round(0.5*minHeightMinusMargins - 0.5*imageViewDimension)
                 var x = margins.right
                 if !isRTL {
                     x = size.width - x - imageViewDimension
@@ -42,11 +43,19 @@ open class ArticleRightAlignedImageCollectionViewCell: ArticleCollectionViewCell
         }
         var origin = CGPoint(x: x, y: margins.top)
         
-        let titleLabelFrame = titleLabel.wmf_preferredFrame(at: origin, fitting: widthMinusMargins, alignedBy: articleSemanticContentAttribute, apply: apply)
-        origin.y += titleLabelFrame.layoutHeight(with: spacing)
-        
-        let descriptionLabelFrame = descriptionLabel.wmf_preferredFrame(at: origin, fitting: widthMinusMargins, alignedBy: articleSemanticContentAttribute, apply: apply)
-        origin.y += descriptionLabelFrame.layoutHeight(with: spacing)
+        if descriptionLabel.wmf_hasText || !isSaveButtonHidden {
+            let titleLabelFrame = titleLabel.wmf_preferredFrame(at: origin, fitting: widthMinusMargins, alignedBy: articleSemanticContentAttribute, apply: apply)
+            origin.y += titleLabelFrame.layoutHeight(with: spacing)
+            
+            let descriptionLabelFrame = descriptionLabel.wmf_preferredFrame(at: origin, fitting: widthMinusMargins, alignedBy: articleSemanticContentAttribute, apply: apply)
+            origin.y += descriptionLabelFrame.layoutHeight(with: spacing)
+            descriptionLabel.isHidden = false
+        } else {
+            let horizontalAlignment: HorizontalAlignment = articleSemanticContentAttribute == .forceRightToLeft ? .right : .left
+            let titleLabelFrame = titleLabel.wmf_preferredFrame(at: origin, maximumViewSize: CGSize(width: widthMinusMargins, height: UIViewNoIntrinsicMetric), minimumLayoutAreaSize: CGSize(width: UIViewNoIntrinsicMetric, height: minHeightMinusMargins), horizontalAlignment: horizontalAlignment, verticalAlignment: .center, apply: apply)
+            origin.y += titleLabelFrame.layoutHeight(with: spacing)
+            descriptionLabel.isHidden = true
+        }
 
         if !isSaveButtonHidden {
             origin.y += saveButtonTopSpacing
@@ -60,7 +69,7 @@ open class ArticleRightAlignedImageCollectionViewCell: ArticleCollectionViewCell
             separator.frame = CGRect(x: 0, y: origin.y - singlePixelDimension, width: size.width, height: singlePixelDimension)
         }
         
-        let height = isImageViewHidden ? origin.y : max(origin.y, imageViewDimension + margins.top + margins.bottom)
+        let height = max(origin.y, minHeight)
         return CGSize(width: size.width, height: height)
     }
 }
diff --git a/Wikipedia/Code/PlacesViewController.swift b/Wikipedia/Code/PlacesViewController.swift
index c5fe2362723..44b1f81f4a0 100644
--- a/Wikipedia/Code/PlacesViewController.swift
+++ b/Wikipedia/Code/PlacesViewController.swift
@@ -1,6 +1,5 @@
 import UIKit
 import WMF
-import TUSafariActivity
 #if OSM
 import Mapbox
 #endif
diff --git a/Wikipedia/Code/WMFExploreCollectionViewController.m b/Wikipedia/Code/WMFExploreCollectionViewController.m
index 0c3d5b5432e..4371fd858ad 100644
--- a/Wikipedia/Code/WMFExploreCollectionViewController.m
+++ b/Wikipedia/Code/WMFExploreCollectionViewController.m
@@ -658,14 +658,14 @@ - (WMFLayoutEstimate)collectionView:(UICollectionView *)collectionView estimated
                 case WMFFeedDisplayTypeStory: {
                     WMFNewsCollectionViewCell *cell = [self placeholderCellForIdentifier:reuseIdentifier];
                     [self configureNewsCell:cell withContentGroup:section layoutOnly:YES];
-                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, CGFLOAT_MAX)];
+                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, UIViewNoIntrinsicMetric)];
                     estimate.height = size.height;
                     break;
                 }
                 case WMFFeedDisplayTypeEvent: {
                     WMFOnThisDayExploreCollectionViewCell *cell = [self placeholderCellForIdentifier:reuseIdentifier];
                     [self configureOnThisDayCell:cell withContentGroup:section layoutOnly:YES];
-                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, CGFLOAT_MAX)];
+                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, UIViewNoIntrinsicMetric)];
                     estimate.height = size.height;
                     break;
                 }
@@ -673,7 +673,7 @@ - (WMFLayoutEstimate)collectionView:(UICollectionView *)collectionView estimated
                     WMFArticleCollectionViewCell *cell = [self placeholderCellForIdentifier:reuseIdentifier];
                     [cell prepareForReuse];
                     [self configureArticleCell:cell withSection:section displayType:displayType withArticle:article atIndexPath:indexPath layoutOnly:YES];
-                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, CGFLOAT_MAX)];
+                    CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, UIViewNoIntrinsicMetric)];
                     estimate.height = size.height;
                     break;
                 }
@@ -692,7 +692,7 @@ - (WMFLayoutEstimate)collectionView:(UICollectionView *)collectionView estimated
         case WMFFeedDisplayTypeAnnouncement: {
             WMFAnnouncementCollectionViewCell *cell = [self placeholderCellForIdentifier:@"WMFAnnouncementCollectionViewCell"];
             [self configureAnnouncementCell:cell withContentGroup:section atIndexPath:indexPath];
-            CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, CGFLOAT_MAX)];
+            CGSize size = [cell sizeThatFits:CGSizeMake(columnWidth, UIViewNoIntrinsicMetric)];
             estimate.height = size.height;
             estimate.precalculated = YES;
         } break;
