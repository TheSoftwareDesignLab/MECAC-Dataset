diff --git a/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftCoreImage.dylib b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftCoreImage.dylib
new file mode 100755
index 00000000000..71c6608b2c9
Binary files /dev/null and b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftCoreImage.dylib differ
diff --git a/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftMetal.dylib b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftMetal.dylib
new file mode 100755
index 00000000000..f654e9a7386
Binary files /dev/null and b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftMetal.dylib differ
diff --git a/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftQuartzCore.dylib b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftQuartzCore.dylib
new file mode 100755
index 00000000000..2617bb97208
Binary files /dev/null and b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftQuartzCore.dylib differ
diff --git a/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftUIKit.dylib b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftUIKit.dylib
new file mode 100755
index 00000000000..3fb34152992
Binary files /dev/null and b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftUIKit.dylib differ
diff --git a/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftos.dylib b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftos.dylib
new file mode 100755
index 00000000000..23d4921c432
Binary files /dev/null and b/Carthage/Build/iOS/FBSnapshotTestCase.framework/Frameworks/libswiftos.dylib differ
diff --git a/WMF Framework/WMF.h b/WMF Framework/WMF.h
index a9579190a5d..6626adaf1cf 100644
--- a/WMF Framework/WMF.h	
+++ b/WMF Framework/WMF.h	
@@ -99,6 +99,7 @@ FOUNDATION_EXPORT const unsigned char WMFVersionString[];
 #import <WMF/WMFFeedImage.h>
 #import <WMF/WMFFeedNewsStory.h>
 #import <WMF/WMFFeedOnThisDayEvent.h>
+#import <WMF/WMFOnThisDayEventsFetcher.h>
 
 #import <WMF/WMFLocationManager.h>
 #import <WMF/CLLocationManager+WMFLocationManagers.h>
diff --git a/WMF Framework/WidgetController.swift b/WMF Framework/WidgetController.swift
index b1825198f45..64cb66011e9 100644
--- a/WMF Framework/WidgetController.swift	
+++ b/WMF Framework/WidgetController.swift	
@@ -5,7 +5,7 @@ public final class WidgetController {
 
     // MARK: Nested Types
 
-    public enum SupportedWidget: String {
+public enum SupportedWidget: String {
         case pictureOfTheDay = "org.wikipedia.widgets.potd"
         case onThisDay = "org.wikipedia.widgets.onThisDay"
 
diff --git a/Widgets/Widgets/OnThisDayView.swift b/Widgets/Widgets/OnThisDayView.swift
index ab2abb42b4f..8b02887d821 100644
--- a/Widgets/Widgets/OnThisDayView.swift
+++ b/Widgets/Widgets/OnThisDayView.swift
@@ -1,13 +1,17 @@
 import WidgetKit
 import SwiftUI
-//import WMF
+import WMF
 import UIKit
 
 // MARK: - Views
 
+let mainColor = Color(UIColor.blue50)
+let grayColor = Color(UIColor.base30)
+let silverColor = Color(UIColor.base70At55PercentAlpha)
+
 struct OnThisDayView: View {
     @Environment(\.widgetFamily) private var family
-    var entry: PictureOfTheDayProvider.Entry
+    var entry: OnThisDayProvider.Entry
 
     @ViewBuilder
     var body: some View {
@@ -15,134 +19,311 @@ struct OnThisDayView: View {
             switch family {
             case .systemLarge:
                 VStack(spacing: 0) {
-                    OnThisDayHeaderElement()
+                    OnThisDayHeaderElement(date: entry.date, minYear: entry.earliestYear, maxYear: entry.latestYear)
                     Spacer(minLength: 10)
-                    VStack(alignment: .leading, spacing: -10) {
-                        MainOnThisDayElement()
-                        ArticleRectangleElement()
-                        OnThisDayAdditionalEventsElement()
+                    VStack(alignment: .leading, spacing: 0) {
+                        MainOnThisDayElement(eventYear: entry.year, snippet: entry.snippet, widgetSize: family)
+                        if let article = entry.page {
+                            ArticleRectangleElement(article: article, image: entry.pageImage)
+                        }
+                        TimelineElementSpacer().layoutPriority(1)
+                        OnThisDayAdditionalEventsElement(otherEventsCount: entry.otherEventsCount)
                     }
                 }
-                    .padding()
-            case .systemSmall:
-                MainOnThisDayElement()
+                .padding(16)
             case .systemMedium:
-                VStack(alignment: .leading, spacing: -10) {
-                    MainOnThisDayElement()
-                    OnThisDayAdditionalEventsElement()
+                VStack(alignment: .leading, spacing: 0) {
+                    MainOnThisDayElement(eventYear: entry.year, snippet: entry.snippet, widgetSize: family)
+                    TimelineElementSpacer().layoutPriority(1)
+                    OnThisDayAdditionalEventsElement(otherEventsCount: entry.otherEventsCount)
+                }
+                .padding(EdgeInsets(top: 0, leading: 11, bottom: 16, trailing: 16))
+            case .systemSmall:
+                /// While the medium and large sizes give a higher `layoutPriority` to `TimelineElementSpacer`, there is intentionally none here. When giving it a priority, it negatively affected the timeline element for `MainOnThisDayElement`, causing it's large dot to appear higher than it should.
+                VStack(alignment: .leading, spacing: 0) {
+                    MainOnThisDayElement(eventYear: entry.year, snippet: entry.snippet, widgetSize: family)
+                    TimelineElementSpacer()
                 }
+                .padding(EdgeInsets(top: 0, leading: 11, bottom: 16, trailing: 16))
             @unknown default:
-                MainOnThisDayElement()
+                VStack(alignment: .leading, spacing: 0) {
+                    MainOnThisDayElement(eventYear: entry.year, snippet: entry.snippet, widgetSize: family)
+                    TimelineElementSpacer()
+                }
             }
         }
         .widgetURL(entry.contentURL)
     }
 }
 
+struct LargeYValuePreferenceKey: PreferenceKey {
+    typealias value = CGFloat
+    static var defaultValue: CGFloat = 20
+    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
+        value = nextValue()
+    }
+}
+
+struct SmallYValuePreferenceKey: PreferenceKey {
+    typealias value = CGFloat
+    static var defaultValue: CGFloat = 20
+    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
+        value = nextValue()
+    }
+}
+
 struct TimelineView<Content: View>: View {
     enum DotStyle {
         case large, small, none
     }
 
+    @SwiftUI.State private var circleYOffset: CGFloat = 0
     var dotStyle: DotStyle
     var isLineTopFaded: Bool
     var isLineBottomFaded: Bool
-    var mainView: Content
+    var mainView: Content // need to set this as state maybe?
 
     var body: some View {
+        let lineWidth: CGFloat = 1
         HStack {
-            TimelinePathElement()
-                .stroke(lineWidth: 3.0)
-                .foregroundColor(.green)
-                .frame(width: 10)
+            ZStack(alignment: .top) {
+                TimelinePathElement()
+                    .stroke(lineWidth: lineWidth)
+                switch dotStyle {
+                case .large: TimelineLargeCircleElement(lineWidth: lineWidth, circleYOffset: circleYOffset)
+                case .small: TimelineSmallCircleElement(lineWidth: lineWidth, circleYOffset: circleYOffset)
+                case .none: EmptyView()
+                }
+            }
+                .frame(width: TimelineLargeCircleElement.largeCircleHeight)
+                .foregroundColor(mainColor)
             mainView
         }
+        .onPreferenceChange(SmallYValuePreferenceKey.self, perform: { yOffset in
+            if dotStyle == .small {
+                self.circleYOffset = yOffset
+                print("TimelineViewSmall new size: \(yOffset) for dotStyle \(dotStyle)") // DON'T COMMIT THIS
+            }
+        })
+        .onPreferenceChange(LargeYValuePreferenceKey.self, perform: { yOffset in
+            if dotStyle == .large {
+                self.circleYOffset = yOffset
+                print("TimelineViewLarge new size: \(yOffset) for dotStyle \(dotStyle)") // DON'T COMMIT THIS
+            }
+        })
     }
 }
 
+/// This is extremely hacky. Once adding padding to views and/or a Spacer() view, the timeline portion of view doesn't take up the full vertical spacce that it should. After exploring numerous other options, I went with this choice - adding some arbitrary extra length to each end of the line. Someday when SwiftUI layout works better, we can remove the -15 and +20.
 struct TimelinePathElement: Shape {
     func path(in rect: CGRect) -> Path {
         var path = Path()
-        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
-        path.addLine(to: CGPoint(x: rect.midX, y: rect.maxY))
+        path.move(to: CGPoint(x: rect.midX, y: rect.minY - 15))
+        path.addLine(to: CGPoint(x: rect.midX, y: rect.maxY + 20))
         return path
     }
 }
 
+struct TimelineSmallCircleElement: View {
+    static let smallCircleHeight: CGFloat = 9.0
+    let lineWidth: CGFloat
+    let circleYOffset: CGFloat
+
+    var body: some View {
+        Circle()
+        .overlay(
+            Circle()
+           .stroke(mainColor, lineWidth: lineWidth)
+        ).foregroundColor(.white)
+            .frame(width: TimelineSmallCircleElement.smallCircleHeight, height: TimelineSmallCircleElement.smallCircleHeight)
+            .padding(EdgeInsets(top: circleYOffset, leading: 0, bottom: 0, trailing: 0))
+    }
+}
+
+struct TimelineLargeCircleElement: View {
+    static let largeCircleHeight: CGFloat = 17.0
+
+    let lineWidth: CGFloat
+    let circleYOffset: CGFloat
+
+    var body: some View {
+        GeometryReader { geometry in
+        Circle()
+            .stroke(mainColor, lineWidth: lineWidth)
+            .overlay(
+                Circle()
+                .overlay(
+                    Circle()
+                    .stroke(mainColor, lineWidth: lineWidth)
+                    .foregroundColor(mainColor)
+                )
+                    .frame(width: TimelineSmallCircleElement.smallCircleHeight, height: TimelineSmallCircleElement.smallCircleHeight)
+            )
+            .frame(width: geometry.size.width, height: geometry.size.width)
+            .padding(.top, circleYOffset)
+        }
+    }
+}
+
 struct OnThisDayHeaderElement: View {
+    let date: Date
+    let minYear: Int?
+    let maxYear: Int?
+
     var body: some View {
-        Text("On this day header")
+        Text(WMFLocalizedString("widget-onthisday-name", value: "On this day", comment: "Name of 'On this day' view in iOS widget gallery"))
+            .foregroundColor(grayColor)
             .font(.subheadline)
+            .bold()
             .multilineTextAlignment(.leading)
             .frame(maxWidth: .infinity, alignment: .leading)
-        Text("Date in larger text")
-            .font(.headline)
-            .multilineTextAlignment(.leading)
-            .frame(maxWidth: .infinity, alignment: .leading)
-        Text("Year range")
-            .font(.subheadline)
+        // TODO: Update next line to the language being used instead of nil
+        Text(DateFormatter.wmf_monthNameDayNumberGMTFormatter(for: nil).string(from: date))
+            .font(.title2)
+            .fontWeight(/*@START_MENU_TOKEN@*/.bold/*@END_MENU_TOKEN@*/)
             .multilineTextAlignment(.leading)
             .frame(maxWidth: .infinity, alignment: .leading)
+        if let minYear = minYear, let maxYear = maxYear {
+            Text(verbatim: "\(minYear) - \(maxYear)")
+                .foregroundColor(grayColor)
+                .font(.subheadline)
+                .bold()
+                .multilineTextAlignment(.leading)
+                .frame(maxWidth: .infinity, alignment: .leading)
+        }
     }
 }
 
-struct MainOnThisDayElement: View {
+struct TimelineElementSpacer: View {
     var body: some View {
-        TimelineView(dotStyle: .large, isLineTopFaded: true, isLineBottomFaded: false, mainView: DateEventElement())
+        TimelineView(dotStyle: .none, isLineTopFaded: false, isLineBottomFaded: false, mainView: Spacer())
     }
 }
 
-struct DateEventElement: View {
+struct MainOnThisDayElement: View {
+    let eventYearPadding: CGFloat = 16.0
+
+    var eventYear: Int?
+    var snippet: String?
+    var widgetSize: WidgetFamily
+
+    /// For unknown reasons, the layout of the `TimelineView` for a large widget is different from the rest. (A larger comment is above.) One side affect is that (as of iOS 14, beta 6) the large dot is not properly centered on the large widget. This `isLargeWidget` boolean allows us to manually correct for the error.
+
     var body: some View {
-        VStack {
-            Text("2003")
-                .frame(maxWidth: .infinity, alignment: .leading)
-            Text("14 years ago")
-                .frame(maxWidth: .infinity, alignment: .leading)
-            Text("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla p")
-                .lineLimit(3)
+        VStack(spacing: 0) {
+            if let eventYear = eventYear, let currentYear = Calendar.current.dateComponents([.year], from: Date()).year {
+                TimelineView(dotStyle: .large, isLineTopFaded: true, isLineBottomFaded: false, mainView:
+                        Text(verbatim: "\(eventYear)")
+                            .font(.subheadline)
+                            .foregroundColor(mainColor)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                            .overlay (
+                                GeometryReader { geometryProxy in
+                                  Color.clear
+                                    .preference(key: LargeYValuePreferenceKey.self, value: (widgetSize == .systemLarge ? 4 : 2) + startYOfCircle(viewHeight: geometryProxy.size.height, circleHeight: TimelineLargeCircleElement.largeCircleHeight))
+                                }
+                            )
+                            .padding(.top, eventYearPadding)
+                )
+                TimelineView(dotStyle: .none, isLineTopFaded: false, isLineBottomFaded: false, mainView:
+                        Text(String.localizedStringWithFormat(WMFLocalizedDateFormatStrings.yearsAgo(forWikiLanguage: nil), (currentYear-eventYear)))
+                            .font(.caption)
+                            .foregroundColor(grayColor)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                            .padding(.top, 3)
+                )
+            }
+            if let snippet = snippet {
+                TimelineView(dotStyle: .none, isLineTopFaded: false, isLineBottomFaded: false, mainView:
+                        Text(snippet)
+                            .font(.caption)
+                            .lineLimit(3)
+                                // this makes the top dot move :BIGMAD:
+//                            .lineLimit(widgetSize == .systemSmall ? nil : 3)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                            .padding(.top, 9)
+                            .fixedSize(horizontal: false, vertical: true)
+                )
+            }
         }
     }
 }
 
 struct ArticleRectangleElement: View {
+    var article: WMFFeedArticlePreview
+    let image: UIImage?
+
     var body: some View {
         TimelineView(dotStyle: .none, isLineTopFaded: false, isLineBottomFaded: false, mainView:
-            HStack {
+            HStack(spacing: 9) {
                 VStack {
-                    Text("Article Name")
+                    Text(article.displayTitle)
+                        .font(.caption)
                         .bold()
                         .frame(maxWidth: .infinity, alignment: .leading)
-                    Text("Short article description that gets cut off one line into ellipsis")
-                        .lineLimit(1)
-                        .frame(maxWidth: .infinity, alignment: .leading)
+                    if let description = article.descriptionOrSnippet {
+                        Text(description)
+                            .font(.caption)
+                            .lineLimit(1)
+                            .foregroundColor(grayColor)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                    }
+                }
+                if let image = image {
+                    Image(uiImage: image)
+                        .resizable()
+                        .scaledToFill()
+                        .frame(width: 36, height: 36, alignment: .center)
+                        .cornerRadius(2.0)
                 }
-                Image("W") // replace this w/ Image(uiImage: "blah") when it's dynamic
-                    .resizable()
-                    .frame(width: 40, height: 54, alignment: .center)
-                    .scaledToFill()
             }
-                .padding(5)
-                .background(RoundedRectangle(cornerRadius: 5.0).foregroundColor(.gray))
+                .padding(9)
+                .background(
+                    RoundedRectangle(cornerRadius: 2.0)
+                        .shadow(color: silverColor, radius: 4.0, x: 0, y: 2)
+                        .foregroundColor(.white)
+                )
+                .padding([.top, .bottom], 9)
         )
     }
 }
 
 struct OnThisDayAdditionalEventsElement: View {
+    let otherEventsCount: Int
+
     var body: some View {
-        TimelineView(dotStyle: .small, isLineTopFaded: true, isLineBottomFaded: false, mainView:
-            Button(action: {}) {
-                Text("45 more items if you click here in the next 20 seconds")
-                    .frame(maxWidth: .infinity, alignment: .leading)
-            })
+        if otherEventsCount > 0 {
+            TimelineView(dotStyle: .small, isLineTopFaded: true, isLineBottomFaded: false, mainView:
+//            Button(action: {}) {
+                    Text(String.localizedStringWithFormat(WMFLocalizedString("on-this-day-footer-with-event-count", value: "%1$d more historical events on this day", comment: "Footer for presenting user option to see longer list of 'On this day' articles. %1$@ will be substituted with the number of events"), otherEventsCount))
+                        .font(.footnote)
+                        .bold()
+                        .lineLimit(1)
+                        .foregroundColor(mainColor)
+                        .frame(maxWidth: .infinity, alignment: .topLeading)
+//                        .layoutPriority(1.5)
+//            }
+//            .frame(alignment: .top)
+                .overlay (
+                    GeometryReader { geometryProxy in
+                      Color.clear
+                        .preference(key: SmallYValuePreferenceKey.self, value: startYOfCircle(viewHeight: geometryProxy.size.height, circleHeight: TimelineSmallCircleElement.smallCircleHeight))
+                    }
+                )
+            )
+        }
     }
 }
 
+private func startYOfCircle(viewHeight: CGFloat, circleHeight: CGFloat) -> CGFloat {
+    return (viewHeight - circleHeight)/2
+}
+
 // MARK: - Preview
 
 struct OnThisDayDayWidget_Previews: PreviewProvider {
     static var previews: some View {
-        OnThisDayView(entry: PictureOfTheDayData.shared.placeholderEntry)
+        OnThisDayView(entry: OnThisDayData.shared.placeholderEntry)
             .previewContext(WidgetPreviewContext(family: .systemLarge))
     }
 }
diff --git a/Widgets/Widgets/OnThisDayWidget.swift b/Widgets/Widgets/OnThisDayWidget.swift
index acd43393478..1c6e255a5ff 100644
--- a/Widgets/Widgets/OnThisDayWidget.swift
+++ b/Widgets/Widgets/OnThisDayWidget.swift
@@ -8,7 +8,7 @@ struct OnThisDayWidget: Widget {
     private let kind: String = WidgetController.SupportedWidget.onThisDay.identifier
 
     public var body: some WidgetConfiguration {
-        StaticConfiguration(kind: kind, provider: PictureOfTheDayProvider(), content: { entry in
+        StaticConfiguration(kind: kind, provider: OnThisDayProvider(), content: { entry in
             OnThisDayView(entry: entry)
         })
         .configurationDisplayName(WMFLocalizedString("widget-onthisday-name", value: "On this day", comment: "Name of 'On this day' view in iOS widget gallery"))
@@ -16,3 +16,182 @@ struct OnThisDayWidget: Widget {
         .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
     }
 }
+
+// MARK: - TimelineProvider
+
+struct OnThisDayProvider: TimelineProvider {
+
+    // MARK: Nested Types
+
+    public typealias Entry = OnThisDayEntry
+
+    // MARK: Properties
+
+    private let dataStore = OnThisDayData.shared
+
+    // MARK: TimelineProvider
+
+    func placeholder(in: Context) -> OnThisDayEntry {
+        return dataStore.placeholderEntry
+    }
+
+    func getTimeline(in context: Context, completion: @escaping (Timeline<OnThisDayEntry>) -> Void) {
+        dataStore.fetchLatestAvailableOnThisDayEntry { entry in
+            let currentDate = Date()
+            let timeline = Timeline(entries: [entry], policy: .after(currentDate.dateAtMidnight() ?? currentDate))
+            completion(timeline)
+        }
+    }
+
+    func getSnapshot(in context: Context, completion: @escaping (OnThisDayEntry) -> Void) {
+        dataStore.fetchLatestAvailableOnThisDayEntry(usingCache: context.isPreview) { entry in
+            completion(entry)
+        }
+    }
+
+}
+
+/// A data source and operation helper for all On This Day of the day widget data
+final class OnThisDayData {
+
+    // MARK: Properties
+
+    static let shared = OnThisDayData()
+
+    private var imageInfoFetcher = MWKImageInfoFetcher()
+    private var dataStore: MWKDataStore {
+        MWKDataStore.shared()
+    }
+
+//    let sampleEntry = OnThisDayEntry(date: Date(), image: #imageLiteral(resourceName: "PictureOfTheYear_2019"), imageDescription: "Two bulls running while the jockey holds on to them in pacu jawi (from Minangkabau, \"bull race\"), a traditional bull race in Tanah Datar, West Sumatra, Indonesia. 2015, Final-45.")
+    let placeholderEntry = OnThisDayEntry(date: Date(), snippet: "Blah", year: 2018, page: nil, pageImage: nil, earliestYear: 2015, latestYear: 2019, contentURL: URL(string: "http://www.google.com")!, otherEventsCount: 5)
+
+    // MARK: Public
+
+    func fetchLatestAvailableOnThisDayEntry(usingCache: Bool = false, _ completion: @escaping (OnThisDayEntry) -> Void) {
+//        if usingCache {
+//            guard let contentGroup = dataStore.viewContext.newestGroup(of: .onThisDay), let imageContent = contentGroup.contentPreview as? WMFFeedOnThisDayEvent else {
+//                completion(sampleEntry)
+//                return
+//            }
+
+//            let contentDate = contentGroup.date
+//            let contentURL = contentGroup.url
+//            let imageThumbnailURL = imageContent.imageThumbURL
+//            let imageDescription = imageContent.imageDescription
+//
+//            if let cachedImage = ImageCacheController.shared?.memoryCachedImage(withURL: imageThumbnailURL) {
+//                let entry = PictureOfTheDayEntry(date: Date(), contentDate: contentDate, contentURL: contentURL, imageURL: imageThumbnailURL, image: cachedImage.staticImage, imageDescription: imageDescription)
+//                completion(entry)
+//            } else {
+//                completion(sampleEntry)
+//            }
+//            return
+//        }
+
+
+        let now = Date()
+        let components = Calendar.current.dateComponents([.month, .day], from: now)
+        guard let month = components.month, let day = components.day else {
+            completion(placeholderEntry)
+            return
+        }
+
+        let fetcher = WMFOnThisDayEventsFetcher()
+        let blah: WMFErrorHandler = { error in
+            //show error FIX ME HERE
+        }
+
+        let successCompletion: (([WMFFeedOnThisDayEvent]?) -> Void) = { events in
+            guard let events = events, let topEvent = self.highestScoredEvent(events: events)  else {
+                completion(self.placeholderEntry)
+                return
+            }
+
+            // CONTENT URL MIGHT BE WRONG HERE
+//            let allYears: [Int] = events.compactMap({ (event) in
+//                if let year = event.year {
+//                    return Int(exactly: year)
+//                }
+//                return nil
+//            })
+//
+//            let minYear = allYears.min()
+//            let maxYear = allYears.max()
+
+            /// This is in line with how we calcualte these for the explore feed. Was doing a `compactMap` to extract all years and then finding the min and max, but that is far less performant.
+            let minYear: Int?
+            let maxYear: Int?
+            if let firstYear = events.first?.year, let lastYear = events.last?.year {
+                maxYear = Int(exactly: firstYear)
+                minYear = Int(exactly: lastYear)
+            } else {
+                minYear = nil
+                maxYear = nil
+            }
+
+            let pageToPreview = self.bestArticleToDisplay(articles: topEvent.articlePreviews)
+
+            // REMOVE THIS FORCE UNWRPA ON NEXT ILNE
+            let topEventYear: Int? = topEvent.yearString != nil ? Int(exactly: topEvent.year!) : nil
+
+            let sendDataToWidget: ((UIImage?) -> Void) = { (image) in
+                let onThisDayEntry = OnThisDayEntry(date: now,
+                                                    snippet: topEvent.text ?? "",
+                                                    year: topEventYear,
+                                                    page: pageToPreview,
+                                                    pageImage: image,
+                                                    earliestYear: minYear,
+                                                    latestYear: maxYear,
+                                                    contentURL: topEvent.siteURL!,
+                                                    otherEventsCount: events.count-1)
+                completion(onThisDayEntry)
+            }
+
+            if let imageURL = pageToPreview?.thumbnailURL {
+                DispatchQueue.main.async {
+                    ImageCacheController.shared?.fetchImage(withURL: imageURL, failure: { _ in
+                        sendDataToWidget(nil)
+                    }, success: { fetchedImage in
+                        sendDataToWidget(fetchedImage.image.staticImage)
+                    })
+                }
+            } else {
+                sendDataToWidget(nil)
+            }
+        }
+
+        let siteURL = URL(string: "http://en.wikipedia.org/")! // update me!
+        fetcher.fetchOnThisDayEvents(for: siteURL, month: UInt(month), day: UInt(day), failure: blah, success: successCompletion)
+    }
+
+    private func highestScoredEvent(events: [WMFFeedOnThisDayEvent]) -> WMFFeedOnThisDayEvent? {
+        // TODO: This. And reuse code between here and existing code
+        return events.first
+    }
+
+    private func bestArticleToDisplay(articles: [WMFFeedArticlePreview]?) -> WMFFeedArticlePreview? {
+        return articles?.first
+    }
+}
+
+// MARK: - Model
+
+struct OnThisDayEntry: TimelineEntry {
+    let date: Date
+
+    let snippet: String
+    let year: Int?
+    let page: WMFFeedArticlePreview?
+    let pageImage: UIImage?
+    let earliestYear: Int?
+    let latestYear: Int?
+    let contentURL: URL
+    let otherEventsCount: Int
+}
+
+struct OnThisDayWidget_Previews: PreviewProvider {
+    static var previews: some View {
+        /*@START_MENU_TOKEN@*/Text("Hello, World!")/*@END_MENU_TOKEN@*/
+    }
+}
diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 5b4e31c9117..d9ff24677db 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -1531,7 +1531,7 @@
 		B0B0EC221C6999A9006F0D9C /* WMFSettingsMenuItem.m in Sources */ = {isa = PBXBuildFile; fileRef = B0B0EC211C6999A9006F0D9C /* WMFSettingsMenuItem.m */; };
 		B0B423471EF1FEE000D3DC4C /* WMFFeedOnThisDayEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = B0B423451EF1FEE000D3DC4C /* WMFFeedOnThisDayEvent.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		B0B423481EF1FEE000D3DC4C /* WMFFeedOnThisDayEvent.m in Sources */ = {isa = PBXBuildFile; fileRef = B0B423461EF1FEE000D3DC4C /* WMFFeedOnThisDayEvent.m */; };
-		B0B4234C1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.h in Headers */ = {isa = PBXBuildFile; fileRef = B0B4234A1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.h */; };
+		B0B4234C1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.h in Headers */ = {isa = PBXBuildFile; fileRef = B0B4234A1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		B0B4234D1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = B0B4234B1EF2055200D3DC4C /* WMFOnThisDayEventsFetcher.m */; };
 		B0B423501EF32D2700D3DC4C /* WMFOnThisDayContentSource.h in Headers */ = {isa = PBXBuildFile; fileRef = B0B4234E1EF32D2700D3DC4C /* WMFOnThisDayContentSource.h */; };
 		B0B423511EF32D2700D3DC4C /* WMFOnThisDayContentSource.m in Sources */ = {isa = PBXBuildFile; fileRef = B0B4234F1EF32D2700D3DC4C /* WMFOnThisDayContentSource.m */; };
diff --git a/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme b/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme
new file mode 100644
index 00000000000..38fa9df7610
--- /dev/null
+++ b/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "1200"
+   wasCreatedForAppExtension = "YES"
+   version = "2.0">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "00021DE024D48EFD00476F97"
+               BuildableName = "WidgetsExtension.appex"
+               BlueprintName = "WidgetsExtension"
+               ReferencedContainer = "container:Wikipedia.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "D4991434181D51DE00E6073C"
+               BuildableName = "Wikipedia.app"
+               BlueprintName = "Wikipedia"
+               ReferencedContainer = "container:Wikipedia.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = ""
+      selectedLauncherIdentifier = "Xcode.IDEFoundation.Launcher.PosixSpawn"
+      launchStyle = "0"
+      askForAppToLaunch = "Yes"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES"
+      launchAutomaticallySubstyle = "2">
+      <RemoteRunnable
+         runnableDebuggingMode = "2"
+         BundleIdentifier = "com.apple.springboard">
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "00021DE024D48EFD00476F97"
+            BuildableName = "WidgetsExtension.appex"
+            BlueprintName = "WidgetsExtension"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </RemoteRunnable>
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "D4991434181D51DE00E6073C"
+            BuildableName = "Wikipedia.app"
+            BlueprintName = "Wikipedia"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <EnvironmentVariables>
+         <EnvironmentVariable
+            key = "_XCWidgetKind"
+            value = "org.wikipedia.widgets.onThisDay"
+            isEnabled = "YES">
+         </EnvironmentVariable>
+         <EnvironmentVariable
+            key = "_XCWidgetDefaultView"
+            value = "timeline"
+            isEnabled = "NO">
+         </EnvironmentVariable>
+         <EnvironmentVariable
+            key = "_XCWidgetFamily"
+            value = "large"
+            isEnabled = "YES">
+         </EnvironmentVariable>
+      </EnvironmentVariables>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      launchAutomaticallySubstyle = "2">
+      <BuildableProductRunnable
+         runnableDebuggingMode = "0">
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "D4991434181D51DE00E6073C"
+            BuildableName = "Wikipedia.app"
+            BlueprintName = "Wikipedia"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Wikipedia/Code/HistoryViewController.swift b/Wikipedia/Code/HistoryViewController.swift
index 9d3cf36a760..6b07a30e6d9 100644
--- a/Wikipedia/Code/HistoryViewController.swift
+++ b/Wikipedia/Code/HistoryViewController.swift
@@ -19,7 +19,7 @@ class HistoryViewController: ArticleFetchedResultsViewController {
 
         emptyViewType = .noHistory
         
-        title = CommonStrings.historyTabTitle
+            title = CommonStrings.historyTabTitle
         
         deleteAllButtonText = WMFLocalizedString("history-clear-all", value: "Clear", comment: "Text of the button shown at the top of history which deletes all history {{Identical|Clear}}")
         deleteAllConfirmationText =  WMFLocalizedString("history-clear-confirmation-heading", value: "Are you sure you want to delete all your recent items?", comment: "Heading text of delete all confirmation dialog")
