diff --git a/lib/model/Product.dart b/lib/model/Product.dart
index 80e03cd08b..446e653d8b 100644
--- a/lib/model/Product.dart
+++ b/lib/model/Product.dart
@@ -296,6 +296,12 @@ class Product extends JsonObject {
   String? packaging;
   @JsonKey(name: 'packaging_tags', includeIfNull: false)
   List<String>? packagingTags;
+  @JsonKey(
+      name: 'packaging_text_in_languages',
+      fromJson: LanguageHelper.fromJsonStringMap,
+      toJson: LanguageHelper.toJsonStringMap,
+      includeIfNull: false)
+  Map<OpenFoodFactsLanguage, String>? packagingTextInLanguages;
 
   @JsonKey(name: 'misc', includeIfNull: false)
   List<String>? miscTags;
@@ -425,33 +431,28 @@ class Product extends JsonObject {
       // We store those values in a more structured maps like
       // [productNameInLanguages].
       if (key == ProductField.NAME_ALL_LANGUAGES.key) {
-        final langs = json[key];
-        if (langs is Map<String, dynamic>) {
+        final Map<OpenFoodFactsLanguage, String>? localized =
+            _getLocalizedStrings(json[key]);
+        if (localized != null) {
           result.productNameInLanguages ??= {};
-          for (final langValuePair in langs.entries) {
-            final lang = LanguageHelper.fromJson(langValuePair.key);
-            if (lang == OpenFoodFactsLanguage.UNDEFINED) {
-              continue;
-            }
-            final value = langValuePair.value;
-            result.productNameInLanguages![lang] = value.toString();
-          }
+          result.productNameInLanguages!.addAll(localized);
         }
       } else if (key == ProductField.INGREDIENTS_TEXT_ALL_LANGUAGES.key) {
-        final langs = json[key];
-        if (langs is Map<String, dynamic>) {
+        final Map<OpenFoodFactsLanguage, String>? localized =
+            _getLocalizedStrings(json[key]);
+        if (localized != null) {
           result.ingredientsTextInLanguages ??= {};
-          for (final langValuePair in langs.entries) {
-            final lang = LanguageHelper.fromJson(langValuePair.key);
-            if (lang == OpenFoodFactsLanguage.UNDEFINED) {
-              continue;
-            }
-            final value = langValuePair.value;
-            result.ingredientsTextInLanguages![lang] = value.toString();
-          }
+          result.ingredientsTextInLanguages!.addAll(localized);
+        }
+      } else if (key == ProductField.PACKAGING_TEXT_ALL_LANGUAGES.key) {
+        final Map<OpenFoodFactsLanguage, String>? localized =
+            _getLocalizedStrings(json[key]);
+        if (localized != null) {
+          result.packagingTextInLanguages ??= {};
+          result.packagingTextInLanguages!.addAll(localized);
         }
       } else if (key.startsWith(ProductField.NAME_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.NAME_IN_LANGUAGES.key);
         if (lang != OpenFoodFactsLanguage.UNDEFINED) {
           result.productNameInLanguages ??= {};
@@ -459,7 +460,7 @@ class Product extends JsonObject {
         }
       } else if (key
           .startsWith(ProductField.CATEGORIES_TAGS_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.CATEGORIES_TAGS_IN_LANGUAGES.key);
         final values = _jsonValueToList(json[key]);
         if (lang != OpenFoodFactsLanguage.UNDEFINED && values != null) {
@@ -468,7 +469,7 @@ class Product extends JsonObject {
         }
       } else if (key
           .startsWith(ProductField.INGREDIENTS_TAGS_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.INGREDIENTS_TAGS_IN_LANGUAGES.key);
         final values = _jsonValueToList(json[key]);
         if (lang != OpenFoodFactsLanguage.UNDEFINED && values != null) {
@@ -486,7 +487,7 @@ class Product extends JsonObject {
           result.imagesFreshnessInLanguages![lang] = values;
         }
       } else if (key.startsWith(ProductField.LABELS_TAGS_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.LABELS_TAGS_IN_LANGUAGES.key);
         final values = _jsonValueToList(json[key]);
         if (lang != OpenFoodFactsLanguage.UNDEFINED && values != null) {
@@ -494,7 +495,7 @@ class Product extends JsonObject {
           result.labelsTagsInLanguages![lang] = values;
         }
       } else if (key.startsWith(ProductField.COUNTRIES_TAGS_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.COUNTRIES_TAGS_IN_LANGUAGES.key);
         final values = _jsonValueToList(json[key]);
         if (lang != OpenFoodFactsLanguage.UNDEFINED && values != null) {
@@ -503,13 +504,39 @@ class Product extends JsonObject {
         }
       } else if (key
           .startsWith(ProductField.INGREDIENTS_TEXT_IN_LANGUAGES.key)) {
-        OpenFoodFactsLanguage lang =
+        final OpenFoodFactsLanguage lang =
             _langFrom(key, ProductField.INGREDIENTS_TEXT_IN_LANGUAGES.key);
         if (lang != OpenFoodFactsLanguage.UNDEFINED) {
           result.ingredientsTextInLanguages ??= {};
           result.ingredientsTextInLanguages![lang] = json[key];
         }
+      } else if (key.startsWith(ProductField.PACKAGING_TEXT_IN_LANGUAGES.key)) {
+        final OpenFoodFactsLanguage lang =
+            _langFrom(key, ProductField.PACKAGING_TEXT_IN_LANGUAGES.key);
+        if (lang != OpenFoodFactsLanguage.UNDEFINED) {
+          result.packagingTextInLanguages ??= {};
+          result.packagingTextInLanguages![lang] = json[key];
+        }
+      }
+    }
+    return result;
+  }
+
+  static Map<OpenFoodFactsLanguage, String>? _getLocalizedStrings(
+    final dynamic langs,
+  ) {
+    Map<OpenFoodFactsLanguage, String>? result;
+    if (!langs is Map<String, dynamic>) {
+      return result;
+    }
+    for (final langValuePair in langs.entries) {
+      final lang = LanguageHelper.fromJson(langValuePair.key);
+      if (lang == OpenFoodFactsLanguage.UNDEFINED) {
+        continue;
       }
+      final value = langValuePair.value;
+      result ??= <OpenFoodFactsLanguage, String>{};
+      result[lang] = value.toString();
     }
     return result;
   }
diff --git a/lib/model/Product.g.dart b/lib/model/Product.g.dart
index 959abf4913..29b032a24c 100644
--- a/lib/model/Product.g.dart
+++ b/lib/model/Product.g.dart
@@ -110,6 +110,8 @@ Product _$ProductFromJson(Map<String, dynamic> json) => Product(
               (k, e) => MapEntry($enumDecode(_$ImageFieldEnumMap, k), e as int),
             )),
       )
+      ..packagingTextInLanguages =
+          LanguageHelper.fromJsonStringMap(json['packaging_text_in_languages'])
       ..knowledgePanels =
           KnowledgePanels.fromJsonHelper(json['knowledge_panels'] as Map?)
       ..environmentInfoCard = json['environment_infocard'] as String?;
@@ -186,6 +188,8 @@ Map<String, dynamic> _$ProductToJson(Product instance) {
       LanguageHelper.toJsonStringsListMap(instance.labelsTagsInLanguages));
   writeNotNull('packaging', instance.packaging);
   writeNotNull('packaging_tags', instance.packagingTags);
+  writeNotNull('packaging_text_in_languages',
+      LanguageHelper.toJsonStringMap(instance.packagingTextInLanguages));
   writeNotNull('misc', instance.miscTags);
   writeNotNull('states_tags', instance.statesTags);
   writeNotNull('traces_tags', instance.tracesTags);
diff --git a/lib/utils/ProductFields.dart b/lib/utils/ProductFields.dart
index cf3b15a8a5..9c156a9204 100644
--- a/lib/utils/ProductFields.dart
+++ b/lib/utils/ProductFields.dart
@@ -49,6 +49,8 @@ enum ProductField {
   LABELS_TAGS_IN_LANGUAGES,
   PACKAGING,
   PACKAGING_TAGS,
+  PACKAGING_TEXT_IN_LANGUAGES,
+  PACKAGING_TEXT_ALL_LANGUAGES,
   MISC_TAGS,
   STATES_TAGS,
   TRACES_TAGS,
@@ -105,6 +107,8 @@ extension ProductFieldExtension on ProductField {
     ProductField.INGREDIENTS_TEXT: 'ingredients_text',
     ProductField.INGREDIENTS_TEXT_IN_LANGUAGES: 'ingredients_text_',
     ProductField.INGREDIENTS_TEXT_ALL_LANGUAGES: 'ingredients_text_languages',
+    ProductField.PACKAGING_TEXT_IN_LANGUAGES: 'packaging_text_',
+    ProductField.PACKAGING_TEXT_ALL_LANGUAGES: 'packaging_text_languages',
     ProductField.NUTRIMENT_ENERGY_UNIT: 'nutriment_energy_unit',
     ProductField.NUTRIMENT_DATA_PER: 'nutrition_data_per',
     ProductField.NUTRISCORE: 'nutrition_grade_fr',
@@ -149,6 +153,7 @@ List<String> convertFieldsToStrings(
     ProductField.NAME_IN_LANGUAGES,
     ProductField.COUNTRIES_TAGS_IN_LANGUAGES,
     ProductField.INGREDIENTS_TEXT_IN_LANGUAGES,
+    ProductField.PACKAGING_TEXT_IN_LANGUAGES,
     ProductField.INGREDIENTS_TAGS_IN_LANGUAGES,
     ProductField.IMAGES_FRESHNESS_IN_LANGUAGES,
   ];
diff --git a/lib/utils/ProductHelper.dart b/lib/utils/ProductHelper.dart
index 6b3a82398c..943c616c4b 100644
--- a/lib/utils/ProductHelper.dart
+++ b/lib/utils/ProductHelper.dart
@@ -61,6 +61,10 @@ class ProductHelper {
     product.ingredientsTextInLanguages![language] =
         source['ingredients_text_${language.code}'];
 
+    product.packagingTextInLanguages ??= {};
+    product.packagingTextInLanguages![language] =
+        source['packaging_text_${language.code}'];
+
     product.productNameInLanguages = {};
     product.productNameInLanguages![language] =
         source['product_name_${language.code}'];
diff --git a/test/api_getProduct_test.dart b/test/api_getProduct_test.dart
index 42c3d0ed9d..41dbdc3627 100644
--- a/test/api_getProduct_test.dart
+++ b/test/api_getProduct_test.dart
@@ -148,6 +148,31 @@ void main() {
       expect(result.product!.countries, 'United States');
     });
 
+    test('get packaging text in languages (Coca-Cola)', () async {
+      const String barcode = '5449000000996';
+      const List<OpenFoodFactsLanguage> languages = [
+        OpenFoodFactsLanguage.ENGLISH,
+        OpenFoodFactsLanguage.FRENCH,
+      ];
+
+      final ProductQueryConfiguration configurations =
+          ProductQueryConfiguration(
+        barcode,
+        languages: languages,
+        fields: [ProductField.PACKAGING_TEXT_IN_LANGUAGES],
+      );
+      final ProductResult result = await OpenFoodAPIClient.getProduct(
+        configurations,
+        user: TestConstants.TEST_USER,
+      );
+      expect(result.status, 1);
+      expect(result.product, isNotNull);
+      expect(result.product!.packagingTextInLanguages, isNotNull);
+      for (final OpenFoodFactsLanguage language in languages) {
+        expect(result.product!.packagingTextInLanguages![language], isNotNull);
+      }
+    });
+
     test('check alcohol data', () async {
       const String barcode = '3119780259625';
 
