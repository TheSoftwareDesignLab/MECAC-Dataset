diff --git a/lib/models/events/audio_completed/audio_completed_model.dart b/lib/models/events/audio_completed/audio_completed_model.dart
index d2cbae632..35d2a0618 100644
--- a/lib/models/events/audio_completed/audio_completed_model.dart
+++ b/lib/models/events/audio_completed/audio_completed_model.dart
@@ -7,6 +7,7 @@ abstract class AudioCompletedModel with _$AudioCompletedModel {
   const factory AudioCompletedModel({
     required String audioFileId,
     required String trackId,
+    required bool updateStats,
   }) = _AudioCompletedModel;
 
   factory AudioCompletedModel.fromJson(Map<String, Object?> json) =>
diff --git a/lib/models/pack/pack_model.dart b/lib/models/pack/pack_model.dart
index 803279185..870526337 100644
--- a/lib/models/pack/pack_model.dart
+++ b/lib/models/pack/pack_model.dart
@@ -2,7 +2,7 @@ import 'package:freezed_annotation/freezed_annotation.dart';
 part 'pack_model.freezed.dart';
 part 'pack_model.g.dart';
 
-@freezed
+@Freezed(makeCollectionsUnmodifiable: false)
 abstract class PackModel with _$PackModel {
   const factory PackModel({
     required String id,
@@ -17,7 +17,7 @@ abstract class PackModel with _$PackModel {
       _$PackModelFromJson(json);
 }
 
-@freezed
+@Freezed(makeCollectionsUnmodifiable: false)
 abstract class PackItemsModel with _$PackItemsModel {
   const factory PackItemsModel({
     required String type,
diff --git a/lib/providers/pack/pack_provider.dart b/lib/providers/pack/pack_provider.dart
index a1b8c79de..1c307ada1 100644
--- a/lib/providers/pack/pack_provider.dart
+++ b/lib/providers/pack/pack_provider.dart
@@ -1,15 +1,56 @@
+import 'package:Medito/constants/constants.dart';
 import 'package:Medito/models/models.dart';
+import 'package:Medito/providers/providers.dart';
 import 'package:Medito/repositories/repositories.dart';
 import 'package:riverpod_annotation/riverpod_annotation.dart';
 part 'pack_provider.g.dart';
 
 @riverpod
-Future<PackModel> packs(
-  ref, {
-  required String packId,
-}) {
-  final packRepository = ref.watch(packRepositoryProvider);
-  ref.keepAlive();
-
-  return packRepository.fetchPacks(packId);
+//ignore: prefer-match-file-name
+class Pack extends _$Pack {
+  @override
+  AsyncValue<PackModel> build({required String packId}) {
+    fetchPacks(packId: packId);
+
+    return AsyncLoading();
+  }
+
+  Future<void> fetchPacks({required String packId}) async {
+    final packRepository = ref.read(packRepositoryProvider);
+    state = const AsyncLoading();
+    state = await AsyncValue.guard(
+      () async => await packRepository.fetchPacks(packId),
+    );
+    ref.keepAlive();
+  }
+
+  Future<void> markComplete({
+    required String audioFileId,
+    required String trackId,
+  }) async {
+    var packs = state.value;
+    var prevState = state.value;
+    try {
+      if (packs != null) {
+        var selectedItemIndex =
+            packs.items.indexWhere((element) => element.id == audioFileId);
+        packs.items[selectedItemIndex] =
+            packs.items[selectedItemIndex].copyWith(isCompleted: true);
+        var audio = AudioCompletedModel(
+          audioFileId: audioFileId,
+          trackId: trackId,
+          updateStats: true,
+        );
+        var event = EventsModel(
+          name: EventTypes.audioCompleted,
+          payload: audio.toJson(),
+        );
+
+        state = AsyncData(packs);
+        await ref.read(eventsProvider(event: event.toJson()).future);
+      }
+    } catch (err) {
+      if (prevState != null) state = AsyncData(prevState);
+    }
+  }
 }
diff --git a/lib/root_page_view.dart b/lib/root_page_view.dart
index 6156b42b3..f818957b2 100644
--- a/lib/root_page_view.dart
+++ b/lib/root_page_view.dart
@@ -211,7 +211,7 @@ class _RootPageViewState extends ConsumerState<RootPageView> {
       );
       audioProvider.seekValueFromSlider(0);
       audioProvider.pause();
-      ref.invalidate(packsProvider);
+      ref.invalidate(packProvider);
       WidgetsBinding.instance.addPostFrameCallback((_) {
         ref.read(audioPlayPauseStateProvider.notifier).state =
             PLAY_PAUSE_AUDIO.PAUSE;
@@ -238,6 +238,7 @@ class _RootPageViewState extends ConsumerState<RootPageView> {
     var audio = AudioCompletedModel(
       audioFileId: audioFileId,
       trackId: trackId,
+      updateStats: true,
     );
     var event = EventsModel(
       name: EventTypes.audioCompleted,
diff --git a/lib/views/pack/pack_view.dart b/lib/views/pack/pack_view.dart
index ca43d8483..3333f3dff 100644
--- a/lib/views/pack/pack_view.dart
+++ b/lib/views/pack/pack_view.dart
@@ -1,5 +1,7 @@
 import 'dart:async';
 
+import 'package:Medito/views/pack/widgets/pack_dismissible_widget.dart';
+import 'package:Medito/views/pack/widgets/pack_item_widget.dart';
 import 'package:Medito/widgets/widgets.dart';
 import 'package:Medito/constants/constants.dart';
 import 'package:Medito/models/models.dart';
@@ -8,7 +10,6 @@ import 'package:Medito/utils/utils.dart';
 import 'package:Medito/providers/providers.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:flutter_svg/svg.dart';
 import 'package:go_router/go_router.dart';
 
 class PackView extends ConsumerStatefulWidget {
@@ -40,18 +41,16 @@ class _PackViewState extends ConsumerState<PackView>
   @override
   Widget build(BuildContext context) {
     super.build(context);
-    var packs = ref.watch(PacksProvider(packId: widget.id));
+    var packs = ref.watch(packProvider(packId: widget.id));
 
     return Scaffold(
       body: packs.when(
         skipLoadingOnRefresh: false,
         skipLoadingOnReload: false,
-        data: (data) => _buildScaffoldWithData(context, data, ref),
+        data: (data) => _buildScaffoldWithData(data, ref),
         error: (err, stack) => MeditoErrorWidget(
           message: err.toString(),
-          onTap: () => ref.refresh(
-            PacksProvider(packId: widget.id),
-          ),
+          onTap: () => ref.refresh(packProvider(packId: widget.id)),
           isLoading: packs.isLoading,
         ),
         loading: () => const FolderShimmerWidget(),
@@ -60,14 +59,11 @@ class _PackViewState extends ConsumerState<PackView>
   }
 
   RefreshIndicator _buildScaffoldWithData(
-    BuildContext context,
     PackModel pack,
     WidgetRef ref,
   ) {
     return RefreshIndicator(
-      onRefresh: () async {
-        return await ref.refresh(PacksProvider(packId: widget.id));
-      },
+      onRefresh: () async => ref.refresh(packProvider(packId: widget.id)),
       child: CollapsibleHeaderWidget(
         bgImage: pack.coverUrl,
         title: '${pack.title}',
@@ -79,12 +75,8 @@ class _PackViewState extends ConsumerState<PackView>
               (e) => GestureDetector(
                 onTap: () => _onListItemTap(e.id, e.type, e.path, ref.context),
                 child: _buildListTile(
-                  context,
-                  e.title,
-                  e.subtitle,
-                  e.type,
+                  e,
                   pack.items.last == e,
-                  e.isCompleted,
                 ),
               ),
             )
@@ -93,76 +85,24 @@ class _PackViewState extends ConsumerState<PackView>
     );
   }
 
-  Container _buildListTile(
-    BuildContext context,
-    String? title,
-    String? subtitle,
-    String type,
+  Widget _buildListTile(
+    PackItemsModel item,
     bool isLast,
-    bool? isCompletedTrack,
   ) {
-    var bodyLarge = Theme.of(context).primaryTextTheme.bodyLarge;
-    var hasSubtitle = subtitle.isNotNullAndNotEmpty();
-
-    return Container(
-      width: MediaQuery.of(context).size.width,
-      decoration: BoxDecoration(
-        border: isLast
-            ? null
-            : Border(
-                bottom: BorderSide(width: 0.9, color: ColorConstants.softGrey),
-              ),
-      ),
-      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 20),
-      child: Row(
-        mainAxisAlignment: MainAxisAlignment.spaceBetween,
-        crossAxisAlignment: CrossAxisAlignment.center,
-        children: [
-          Flexible(
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              mainAxisSize: MainAxisSize.min,
-              children: [
-                if (title.isNotNullAndNotEmpty())
-                  Text(
-                    title!,
-                    style: bodyLarge?.copyWith(
-                      color: ColorConstants.walterWhite,
-                      fontFamily: DmSans,
-                    ),
-                  ),
-                if (hasSubtitle)
-                  Flexible(
-                    child: Padding(
-                      padding: const EdgeInsets.only(top: 4),
-                      child: Text(
-                        subtitle!,
-                        style: bodyLarge?.copyWith(
-                          fontFamily: DmMono,
-                          color: ColorConstants.newGrey,
-                        ),
-                      ),
-                    ),
-                  ),
-              ],
-            ),
-          ),
-          _getIcon(type, isCompletedTrack: isCompletedTrack),
-        ],
-      ),
-    );
-  }
-
-  Widget _getIcon(String type, {bool? isCompletedTrack}) {
-    if (type == TypeConstants.LINK) {
-      return SvgPicture.asset(AssetConstants.icLink);
-    } else if (type == TypeConstants.TRACK &&
-        isCompletedTrack != null &&
-        isCompletedTrack) {
-      return Icon(Icons.check_circle_outline_rounded);
+    //ignore: prefer-conditional-expressions
+    if (item.type == TypeConstants.TRACK && item.isCompleted == false) {
+      return PackDismissibleWidget(
+        child: PackItemWidget(isLast: isLast, item: item),
+        onUpdateCb: () {
+          ref.read(packProvider(packId: widget.id).notifier).markComplete(
+                audioFileId: item.path.getIdFromPath(),
+                trackId: item.id,
+              );
+        },
+      );
+    } else {
+      return PackItemWidget(isLast: isLast, item: item);
     }
-
-    return SizedBox();
   }
 
   void _onListItemTap(
diff --git a/lib/views/pack/widgets/pack_dismissible_widget.dart b/lib/views/pack/widgets/pack_dismissible_widget.dart
new file mode 100644
index 000000000..5e358527d
--- /dev/null
+++ b/lib/views/pack/widgets/pack_dismissible_widget.dart
@@ -0,0 +1,44 @@
+import 'package:Medito/constants/constants.dart';
+import 'package:flutter/material.dart';
+
+class PackDismissibleWidget extends StatelessWidget {
+  const PackDismissibleWidget({
+    super.key,
+    required this.child,
+    this.onUpdateCb,
+  });
+  final Widget child;
+  final void Function()? onUpdateCb;
+  @override
+  Widget build(BuildContext context) {
+    return Dismissible(
+      key: UniqueKey(),
+      direction: DismissDirection.endToStart,
+      background: _getDismissibleBackgroundWidget(),
+      onDismissed: (details) {
+        if (onUpdateCb != null) {
+          onUpdateCb!();
+        }
+      },
+      child: child,
+    );
+  }
+
+  Widget _getDismissibleBackgroundWidget() => Container(
+        color: ColorConstants.moonlight,
+        child: Padding(
+          padding: const EdgeInsets.all(24.0),
+          child: Row(
+            mainAxisSize: MainAxisSize.max,
+            mainAxisAlignment: MainAxisAlignment.spaceBetween,
+            children: [
+              Spacer(),
+              Icon(
+                Icons.check,
+                color: ColorConstants.walterWhite,
+              ),
+            ],
+          ),
+        ),
+      );
+}
diff --git a/lib/views/pack/widgets/pack_item_widget.dart b/lib/views/pack/widgets/pack_item_widget.dart
new file mode 100644
index 000000000..ea699e9ab
--- /dev/null
+++ b/lib/views/pack/widgets/pack_item_widget.dart
@@ -0,0 +1,74 @@
+import 'package:Medito/constants/constants.dart';
+import 'package:Medito/models/models.dart';
+import 'package:Medito/utils/utils.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_svg/svg.dart';
+
+class PackItemWidget extends StatelessWidget {
+  const PackItemWidget({super.key, required this.item, required this.isLast});
+  final PackItemsModel item;
+  final bool isLast;
+  @override
+  Widget build(BuildContext context) {
+    var bodyLarge = Theme.of(context).primaryTextTheme.bodyLarge;
+    var hasSubtitle = item.subtitle.isNotNullAndNotEmpty();
+
+    return Container(
+      width: MediaQuery.of(context).size.width,
+      decoration: BoxDecoration(
+        border: isLast
+            ? null
+            : Border(
+                bottom: BorderSide(width: 0.9, color: ColorConstants.softGrey),
+              ),
+      ),
+      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 20),
+      child: Row(
+        mainAxisAlignment: MainAxisAlignment.spaceBetween,
+        crossAxisAlignment: CrossAxisAlignment.center,
+        children: [
+          Flexible(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              mainAxisSize: MainAxisSize.min,
+              children: [
+                if (item.title.isNotNullAndNotEmpty())
+                  Text(
+                    item.title,
+                    style: bodyLarge?.copyWith(
+                      color: ColorConstants.walterWhite,
+                      fontFamily: DmSans,
+                    ),
+                  ),
+                if (hasSubtitle)
+                  Flexible(
+                    child: Padding(
+                      padding: const EdgeInsets.only(top: 4),
+                      child: Text(
+                        item.subtitle,
+                        style: bodyLarge?.copyWith(
+                          fontFamily: DmMono,
+                          color: ColorConstants.newGrey,
+                        ),
+                      ),
+                    ),
+                  ),
+              ],
+            ),
+          ),
+          _getIcon(item.type, isCompletedTrack: item.isCompleted),
+        ],
+      ),
+    );
+  }
+
+  Widget _getIcon(String type, {bool? isCompletedTrack}) {
+    if (type == TypeConstants.LINK) {
+      return SvgPicture.asset(AssetConstants.icLink);
+    } else if (type == TypeConstants.TRACK && isCompletedTrack == true) {
+      return Icon(Icons.check_circle_outline_rounded);
+    }
+
+    return SizedBox();
+  }
+}
diff --git a/lib/widgets/errors/connectivity_error_widget.dart b/lib/widgets/errors/connectivity_error_widget.dart
index a3bbf90f0..b24fb0285 100644
--- a/lib/widgets/errors/connectivity_error_widget.dart
+++ b/lib/widgets/errors/connectivity_error_widget.dart
@@ -32,17 +32,15 @@ class _ConnectivityErrorComponentState
     var id = location.split('/').last;
     var isFolder = location.contains('folder');
     var isTrack = location.contains('track');
-
     if (isFolder && isTrack) {
       ref.read(tracksProvider(trackId: id));
     } else if (isFolder && !isTrack) {
-      ref.read(PacksProvider(packId: id));
+      ref.read(packProvider(packId: id));
     }
   }
 
   @override
   Widget build(BuildContext context) {
-
     return WillPopScope(
       onWillPop: () async => false,
       child: MeditoErrorWidget(
diff --git a/pubspec.yaml b/pubspec.yaml
index 808d5be03..41a8e4e0a 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -44,8 +44,8 @@ dependencies:
   sentry_flutter: ^7.9.0
   back_button_interceptor: ^6.0.2
   go_router: ^6.5.5
-  flutter_riverpod: ^2.1.3
-  riverpod_annotation: ^2.0.2
+  flutter_riverpod: ^2.4.4
+  riverpod_annotation: ^2.2.1
   freezed: ^2.3.2
   freezed_annotation: ^2.2.0
   json_annotation: ^4.7.0
diff --git a/test/pack/pack_provider_test.dart b/test/pack/pack_provider_test.dart
deleted file mode 100644
index 6e43b97fb..000000000
--- a/test/pack/pack_provider_test.dart
+++ /dev/null
@@ -1,110 +0,0 @@
-import 'package:Medito/models/models.dart';
-import 'package:Medito/repositories/repositories.dart';
-import 'package:Medito/providers/providers.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:flutter_test/flutter_test.dart';
-import 'package:mocktail/mocktail.dart';
-
-//ignore:prefer-match-file-name
-class MockPackRepository extends Mock implements PackRepositoryImpl {}
-
-class Listener<T> extends Mock {
-  void call(T? previous, T next);
-}
-
-void main() {
-  ProviderContainer makeProviderContainer(MockPackRepository repository) {
-    final container = ProviderContainer(
-      overrides: [
-        packRepositoryProvider.overrideWithValue(repository),
-      ],
-    );
-    addTearDown(container.dispose);
-
-    return container;
-  }
-
-  group('getPacks', () {
-    test(
-      'get packs using the pack repository',
-      () async {
-        //ARRANGE
-        final packResponseData = PackModel(
-          id: '28',
-          title: 'UCLA',
-          description:
-              'Guided tracks provided by [UCLA Mindful Awareness Research Center]',
-          coverUrl: 'Some test cover url',
-          isPublished: true,
-          items: [
-            PackItemsModel(
-              type: 'track',
-              id: '120',
-              title: 'Complete track',
-              subtitle: '19 min',
-              path: 'tracks/120',
-            ),
-          ],
-        );
-        final mockPackRepository = MockPackRepository();
-        when(() => mockPackRepository.fetchPacks('28'))
-            .thenAnswer((_) async => packResponseData);
-
-        //ACT
-        final container = makeProviderContainer(mockPackRepository);
-
-        //ASSERT
-        expect(
-          container.read(packsProvider(packId: '28')),
-          const AsyncValue<PackModel>.loading(),
-        );
-        await container.read(packsProvider(packId: '28').future);
-        expect(
-          container.read(packsProvider(packId: '28')).value,
-          isA<PackModel>()
-              .having((s) => s.id, 'id', '28')
-              .having((s) => s.title, 'title', 'UCLA')
-              .having(
-                (s) => s.description,
-                'description',
-                'Guided tracks provided by [UCLA Mindful Awareness Research Center]',
-              ),
-        );
-        verify(
-          () => mockPackRepository.fetchPacks('28'),
-        ).called(1);
-      },
-    );
-    test(
-      'return errors when pack repository throws',
-      () async {
-        final exception = Exception();
-        //ARRANGE
-        final mockPackRepository = MockPackRepository();
-        when(() => mockPackRepository.fetchPacks('28'))
-            .thenAnswer((_) async => throw (exception));
-
-        //ACT
-        final container = makeProviderContainer(mockPackRepository);
-
-        //ASSERT
-        expect(
-          container.read(packsProvider(packId: '28')),
-          const AsyncValue<PackModel>.loading(),
-        );
-        await expectLater(
-          container.read(packsProvider(packId: '28').future),
-          throwsA(isA<Exception>()),
-        );
-        expect(
-          container.read(packsProvider(packId: '28')),
-          isA<AsyncError<PackModel>>()
-              .having((e) => e.error, 'error', exception),
-        );
-        verify(
-          () => mockPackRepository.fetchPacks('28'),
-        ).called(1);
-      },
-    );
-  });
-}
