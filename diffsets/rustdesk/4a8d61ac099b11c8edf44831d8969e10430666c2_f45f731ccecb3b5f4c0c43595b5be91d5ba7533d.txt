diff --git a/libs/enigo/src/win/keycodes.rs b/libs/enigo/src/win/keycodes.rs
index ea35685c5d6..500582bf00b 100644
--- a/libs/enigo/src/win/keycodes.rs
+++ b/libs/enigo/src/win/keycodes.rs
@@ -1,3 +1,4 @@
+#![allow(dead_code)]
 // https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731
 //
 // JP/KR mapping https://github.com/TigerVNC/tigervnc/blob/1a008c1380305648ab50f1d99e73439747e9d61d/vncviewer/win32.c#L267
diff --git a/src/core_main.rs b/src/core_main.rs
index a3e11a49e81..d6c3bbc5973 100644
--- a/src/core_main.rs
+++ b/src/core_main.rs
@@ -1,3 +1,5 @@
+#[cfg(not(debug_assertions))]
+#[cfg(not(any(target_os = "android", target_os = "ios")))]
 use crate::platform::breakdown_callback;
 use hbb_common::log;
 #[cfg(not(debug_assertions))]
diff --git a/src/server/input_service.rs b/src/server/input_service.rs
index 5fb63a59706..c9a92e43261 100644
--- a/src/server/input_service.rs
+++ b/src/server/input_service.rs
@@ -1372,29 +1372,41 @@ fn simulate_win2win_hotkey(code: u32, down: bool) {
 }
 
 #[cfg(not(any(target_os = "windows", target_os = "linux")))]
-fn is_win_linux_meta_key(_evt: &KeyEvent) -> bool {
+fn skip_led_sync(_evt: &KeyEvent) -> bool {
     false
 }
 
 #[cfg(any(target_os = "windows", target_os = "linux"))]
-fn is_win_linux_meta_key(evt: &KeyEvent) -> bool {
-    match evt.mode.unwrap() {
-        KeyboardMode::Map | KeyboardMode::Translate => match &evt.union {
-            Some(key_event::Union::ControlKey(ck)) => {
-                return *ck == ControlKey::Meta.into();
-            }
-            Some(key_event::Union::Chr(code)) => {
-                let key = crate::keycode_to_rdev_key(*code);
-                return key == RdevKey::MetaLeft || key == RdevKey::MetaRight;
-            }
-            _ => {}
-        },
-        KeyboardMode::Legacy => match &evt.union {
-            Some(key_event::Union::ControlKey(ck)) => {
-                return *ck == ControlKey::Meta.into();
-            }
-            _ => {}
-        },
+fn skip_led_sync(evt: &KeyEvent) -> bool {
+    match (&evt.union, evt.mode.enum_value_or(KeyboardMode::Legacy)) {
+        (Some(key_event::Union::ControlKey(ck)), _) => {
+            let key = ck.enum_value_or(ControlKey::Unknown);
+            return [
+                ControlKey::Control,
+                ControlKey::Meta,
+                ControlKey::Shift,
+                ControlKey::Alt,
+                ControlKey::Tab,
+                ControlKey::Return,
+            ]
+            .contains(&key);
+        }
+        (Some(key_event::Union::Chr(code)), KeyboardMode::Map | KeyboardMode::Translate) => {
+            let key = crate::keycode_to_rdev_key(*code);
+            return [
+                RdevKey::ControlLeft,
+                RdevKey::ControlRight,
+                RdevKey::MetaLeft,
+                RdevKey::MetaRight,
+                RdevKey::ShiftRight,
+                RdevKey::ShiftRight,
+                RdevKey::Alt,
+                RdevKey::AltGr,
+                RdevKey::Tab,
+                RdevKey::Return,
+            ]
+            .contains(&key);
+        }
         _ => {}
     }
     false
@@ -1413,7 +1425,9 @@ pub fn handle_key_(evt: &KeyEvent) {
             // LockModesHandler should not be created when single meta is pressing and releasing.
             // Because the drop function may insert "CapsLock Click" and "NumLock Click", which breaks single meta click.
             // https://github.com/rustdesk/rustdesk/issues/3928#issuecomment-1496936687
-            if evt.down && !is_win_linux_meta_key(evt) {
+            // https://github.com/rustdesk/rustdesk/issues/3928#issuecomment-1500415822
+            // https://github.com/rustdesk/rustdesk/issues/3928#issuecomment-1500773473
+            if evt.down && !skip_led_sync(evt) {
                 Some(LockModesHandler::new(evt))
             } else {
                 None
