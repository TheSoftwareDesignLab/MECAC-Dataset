diff --git a/libs/enigo/src/lib.rs b/libs/enigo/src/lib.rs
index 10c5da4a7f7..893f5918c1e 100644
--- a/libs/enigo/src/lib.rs
+++ b/libs/enigo/src/lib.rs
@@ -418,8 +418,6 @@ pub enum Key {
     Layout(char),
     /// raw keycode eg 0x38
     Raw(u16),
-    /// VNC keysym
-    KeySym(u32),
 }
 
 /// Representing an interface and a set of keyboard functions every
diff --git a/libs/enigo/src/linux.rs b/libs/enigo/src/linux.rs
index be21a2c7066..24628c1f9a7 100644
--- a/libs/enigo/src/linux.rs
+++ b/libs/enigo/src/linux.rs
@@ -181,9 +181,6 @@ impl MouseControllable for Enigo {
     }
 }
 fn keysequence<'a>(key: Key) -> Cow<'a, str> {
-    if let Key::KeySym(sym) = key {
-        return Cow::Owned("".to_owned());
-    }
     if let Key::Layout(c) = key {
         return Cow::Owned(format!("U{:X}", c as u32));
     }
diff --git a/libs/enigo/src/macos/macos_impl.rs b/libs/enigo/src/macos/macos_impl.rs
index 93b78c6d86f..0ee038012da 100644
--- a/libs/enigo/src/macos/macos_impl.rs
+++ b/libs/enigo/src/macos/macos_impl.rs
@@ -426,7 +426,6 @@ impl Enigo {
 
             Key::Raw(raw_keycode) => raw_keycode,
             Key::Layout(c) => self.map_key_board(c),
-            Key::KeySym(sym) => 0 as _,
 
             Key::Super | Key::Command | Key::Windows | Key::Meta => kVK_Command,
             _ => 0,
diff --git a/libs/enigo/src/win/win_impl.rs b/libs/enigo/src/win/win_impl.rs
index 3f83dc9512d..3a6b6215f8b 100644
--- a/libs/enigo/src/win/win_impl.rs
+++ b/libs/enigo/src/win/win_impl.rs
@@ -340,7 +340,6 @@ impl Enigo {
             Key::Raw(raw_keycode) => raw_keycode,
             Key::Layout(c) => self.get_layoutdependent_keycode(c.to_string()),
             Key::Super | Key::Command | Key::Windows | Key::Meta => EVK_LWIN,
-            Key::KeySym(sym) => 0,
         }
     }
 
diff --git a/libs/hbb_common/protos/message.proto b/libs/hbb_common/protos/message.proto
index d436fe128e7..3d892877fce 100644
--- a/libs/hbb_common/protos/message.proto
+++ b/libs/hbb_common/protos/message.proto
@@ -173,7 +173,6 @@ message KeyEvent {
     uint32 chr = 4;
     uint32 unicode = 5;
     string seq = 6;
-    uint32 keysym = 7;
   }
   repeated ControlKey modifiers = 8;
 }
diff --git a/src/server/input_service.rs b/src/server/input_service.rs
index ef06f2348f3..ba34772a54d 100644
--- a/src/server/input_service.rs
+++ b/src/server/input_service.rs
@@ -40,8 +40,7 @@ struct Input {
     time: i64,
 }
 
-const KEY_CHAR_START: u64 = 0xFFFF;
-const KEY_SYM_START: u64 = 0xFFFFFFFF;
+const KEY_CHAR_START: i32 = 9999;
 
 #[derive(Clone, Default)]
 pub struct MouseCursorSub {
@@ -164,7 +163,7 @@ fn run_cursor(sp: MouseCursorService, state: &mut StateCursor) -> ResultType<()>
 
 lazy_static::lazy_static! {
     static ref ENIGO: Arc<Mutex<Enigo>> = Arc::new(Mutex::new(Enigo::new()));
-    static ref KEYS_DOWN: Arc<Mutex<HashMap<u64, Instant>>> = Default::default();
+    static ref KEYS_DOWN: Arc<Mutex<HashMap<i32, Instant>>> = Default::default();
     static ref LATEST_INPUT: Arc<Mutex<Input>> = Default::default();
 }
 static EXITING: AtomicBool = AtomicBool::new(false);
@@ -257,15 +256,13 @@ fn fix_key_down_timeout(force: bool) {
         if force || value.elapsed().as_millis() >= 3_000 {
             KEYS_DOWN.lock().unwrap().remove(&key);
             let key = if key < KEY_CHAR_START {
-                if let Some(key) = KEY_MAP.get(&(key as _)) {
+                if let Some(key) = KEY_MAP.get(&key) {
                     Some(*key)
                 } else {
                     None
                 }
-            } else if key < KEY_SYM_START {
-                Some(Key::Layout(((key - KEY_CHAR_START) as u8) as _))
             } else {
-                Some(Key::KeySym((key - KEY_SYM_START) as u32))
+                Some(Key::Layout(((key - KEY_CHAR_START) as u8) as _))
             };
             if let Some(key) = key {
                 let func = move || {
@@ -355,10 +352,7 @@ fn handle_mouse_(evt: &MouseEvent, conn: i32) {
                         modifier_sleep();
                         to_release.push(key);
                     } else {
-                        KEYS_DOWN
-                            .lock()
-                            .unwrap()
-                            .insert(ck.value() as _, Instant::now());
+                        KEYS_DOWN.lock().unwrap().insert(ck.value(), Instant::now());
                     }
                 }
             }
@@ -578,10 +572,7 @@ fn handle_key_(evt: &KeyEvent) {
                             modifier_sleep();
                             to_release.push(key);
                         } else {
-                            KEYS_DOWN
-                                .lock()
-                                .unwrap()
-                                .insert(ck.value() as _, Instant::now());
+                            KEYS_DOWN.lock().unwrap().insert(ck.value(), Instant::now());
                         }
                     }
                 }
@@ -615,13 +606,10 @@ fn handle_key_(evt: &KeyEvent) {
                 }
                 if evt.down {
                     allow_err!(en.key_down(key.clone()));
-                    KEYS_DOWN
-                        .lock()
-                        .unwrap()
-                        .insert(ck.value() as _, Instant::now());
+                    KEYS_DOWN.lock().unwrap().insert(ck.value(), Instant::now());
                 } else {
                     en.key_up(key.clone());
-                    KEYS_DOWN.lock().unwrap().remove(&(ck.value() as _));
+                    KEYS_DOWN.lock().unwrap().remove(&ck.value());
                 }
             } else if ck.value() == ControlKey::CtrlAltDel.value() {
                 // have to spawn new thread because send_sas is tokio_main, the caller can not be tokio_main.
@@ -639,28 +627,13 @@ fn handle_key_(evt: &KeyEvent) {
                 KEYS_DOWN
                     .lock()
                     .unwrap()
-                    .insert(chr as u64 + KEY_CHAR_START, Instant::now());
+                    .insert(chr as i32 + KEY_CHAR_START, Instant::now());
             } else {
                 en.key_up(Key::Layout(chr as u8 as _));
                 KEYS_DOWN
                     .lock()
                     .unwrap()
-                    .remove(&(chr as u64 + KEY_CHAR_START));
-            }
-        }
-        Some(key_event::Union::keysym(sym)) => {
-            if evt.down {
-                allow_err!(en.key_down(Key::KeySym(sym)));
-                KEYS_DOWN
-                    .lock()
-                    .unwrap()
-                    .insert(sym as u64 + KEY_SYM_START, Instant::now());
-            } else {
-                en.key_up(Key::KeySym(sym));
-                KEYS_DOWN
-                    .lock()
-                    .unwrap()
-                    .remove(&(sym as u64 + KEY_SYM_START));
+                    .remove(&(chr as i32 + KEY_CHAR_START));
             }
         }
         Some(key_event::Union::unicode(chr)) => {
