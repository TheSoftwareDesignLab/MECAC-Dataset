diff --git a/src/core_main.rs b/src/core_main.rs
index 3aa69f8f367..375b1dbc573 100644
--- a/src/core_main.rs
+++ b/src/core_main.rs
@@ -39,6 +39,7 @@ pub fn core_main() -> Option<Vec<String>> {
     let mut _is_run_as_system = false;
     let mut _is_quick_support = false;
     let mut _is_flutter_invoke_new_connection = false;
+    let mut no_server = false;
     let mut arg_exe = Default::default();
     for arg in std::env::args() {
         if i == 0 {
@@ -62,6 +63,8 @@ pub fn core_main() -> Option<Vec<String>> {
                 _is_run_as_system = true;
             } else if arg == "--quick_support" {
                 _is_quick_support = true;
+            } else if arg == "--no-server" {
+                no_server = true;
             } else {
                 args.push(arg);
             }
@@ -134,6 +137,7 @@ pub fn core_main() -> Option<Vec<String>> {
         }
     }
     hbb_common::init_log(false, &log_name);
+    log::info!("main start args: {:?}, env: {:?}", args, std::env::args());
 
     // linux uni (url) go here.
     #[cfg(all(target_os = "linux", feature = "flutter"))]
@@ -161,9 +165,8 @@ pub fn core_main() -> Option<Vec<String>> {
     #[cfg(all(feature = "flutter", feature = "plugin_framework"))]
     #[cfg(not(any(target_os = "android", target_os = "ios")))]
     init_plugins(&args);
-    log::info!("main start args:{:?}", args);
     if args.is_empty() || crate::common::is_empty_uni_link(&args[0]) {
-        std::thread::spawn(move || crate::start_server(false));
+        std::thread::spawn(move || crate::start_server(false, no_server));
     } else {
         #[cfg(windows)]
         {
@@ -279,11 +282,11 @@ pub fn core_main() -> Option<Vec<String>> {
             crate::privacy_mode::restore_reg_connectivity(true);
             #[cfg(any(target_os = "linux", target_os = "windows"))]
             {
-                crate::start_server(true);
+                crate::start_server(true, false);
             }
             #[cfg(target_os = "macos")]
             {
-                let handler = std::thread::spawn(move || crate::start_server(true));
+                let handler = std::thread::spawn(move || crate::start_server(true, false));
                 crate::tray::start_tray();
                 // prevent server exit when encountering errors from tray
                 hbb_common::allow_err!(handler.join());
diff --git a/src/ipc.rs b/src/ipc.rs
index 2b591d10711..9815fdb748b 100644
--- a/src/ipc.rs
+++ b/src/ipc.rs
@@ -401,10 +401,10 @@ async fn handle(data: Data, stream: &mut Connection) {
                     std::fs::remove_file(&Config::ipc_path("")).ok();
                     #[cfg(target_os = "linux")]
                     {
-                        // https://github.com/rustdesk/rustdesk/discussions/9254, slow on some machines
-                        hbb_common::sleep((crate::platform::SERVICE_INTERVAL * 2) as f32 / 1000.0 + 1.2)
+                        hbb_common::sleep((crate::platform::SERVICE_INTERVAL * 2) as f32 / 1000.0)
                             .await;
-                        crate::run_me::<&str>(vec![]).ok();
+                        // https://github.com/rustdesk/rustdesk/discussions/9254
+                        crate::run_me::<&str>(vec!["--no-server"]).ok();
                     }
                     #[cfg(target_os = "macos")]
                     {
diff --git a/src/main.rs b/src/main.rs
index bc41365e3fb..44ace8a76e5 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -102,7 +102,7 @@ fn main() {
         cli::connect_test(p, key, token);
     } else if let Some(p) = matches.value_of("server") {
         log::info!("id={}", hbb_common::config::Config::get_id());
-        crate::start_server(true);
+        crate::start_server(true, false);
     }
     common::global_clean();
 }
diff --git a/src/platform/linux.rs b/src/platform/linux.rs
index 90e2f52ca09..4bb666fb9c2 100644
--- a/src/platform/linux.rs
+++ b/src/platform/linux.rs
@@ -1378,6 +1378,7 @@ pub fn uninstall_service(show_new_window: bool, _: bool) -> bool {
         Config::set_option("stop-service".into(), "".into());
         return true;
     }
+    // systemctl stop will kill child processes, below may not be executed.
     if show_new_window {
         run_me_with(2);
     }
diff --git a/src/server.rs b/src/server.rs
index 547886a5c98..a973ba6aef9 100644
--- a/src/server.rs
+++ b/src/server.rs
@@ -456,16 +456,21 @@ pub async fn start_server(_is_server: bool) {
 /// * `is_server` - Whether the current client is definitely the server.
 /// If true, the server will be started.
 /// Otherwise, client will check if there's already a server and start one if not.
+/// * `no_server` - If `is_server` is false, whether to start a server if not found.
 #[cfg(not(any(target_os = "android", target_os = "ios")))]
 #[tokio::main]
-pub async fn start_server(is_server: bool) {
-    #[cfg(target_os = "linux")]
-    {
-        log::info!("DISPLAY={:?}", std::env::var("DISPLAY"));
-        log::info!("XAUTHORITY={:?}", std::env::var("XAUTHORITY"));
-    }
-    #[cfg(windows)]
-    hbb_common::platform::windows::start_cpu_performance_monitor();
+pub async fn start_server(is_server: bool, no_server: bool) {
+    use std::sync::Once;
+    static ONCE: Once = Once::new();
+    ONCE.call_once(|| {
+        #[cfg(target_os = "linux")]
+        {
+            log::info!("DISPLAY={:?}", std::env::var("DISPLAY"));
+            log::info!("XAUTHORITY={:?}", std::env::var("XAUTHORITY"));
+        }
+        #[cfg(windows)]
+        hbb_common::platform::windows::start_cpu_performance_monitor();
+    });
 
     if is_server {
         crate::common::set_server_running(true);
@@ -516,8 +521,14 @@ pub async fn start_server(is_server: bool) {
                 crate::ipc::client_get_hwcodec_config_thread(0);
             }
             Err(err) => {
-                log::info!("server not started (will try to start): {}", err);
-                std::thread::spawn(|| start_server(true));
+                log::info!("server not started: {err:?}, no_server: {no_server}");
+                if no_server {
+                    hbb_common::sleep(1.0).await;
+                    std::thread::spawn(|| start_server(false, true));
+                } else {
+                    log::info!("try start server");
+                    std::thread::spawn(|| start_server(true, false));
+                }
             }
         }
     }
