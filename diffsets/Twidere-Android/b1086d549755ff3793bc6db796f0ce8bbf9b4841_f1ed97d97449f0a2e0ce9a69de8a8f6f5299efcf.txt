diff --git a/twidere/build.gradle b/twidere/build.gradle
index 8ea5004808..49b3d6a7d6 100644
--- a/twidere/build.gradle
+++ b/twidere/build.gradle
@@ -115,8 +115,8 @@ dependencies {
     compile 'com.google.dagger:dagger:2.0.2'
     compile 'org.attoparser:attoparser:1.4.0.RELEASE'
     compile 'com.j256.simplemagic:simplemagic:1.6'
-    compile 'com.github.mariotaku.MediaViewerLibrary:base:0.9.2'
-    compile 'com.github.mariotaku.MediaViewerLibrary:subsample-image-view:0.9.2'
+    compile 'com.github.mariotaku.MediaViewerLibrary:base:0.9.2-SNAPSHOT'
+    compile 'com.github.mariotaku.MediaViewerLibrary:subsample-image-view:0.9.2-SNAPSHOT'
     googleCompile 'com.google.android.gms:play-services-maps:8.4.0'
 //    googleCompile 'com.google.maps.android:android-maps-utils:0.4'
     googleCompile('com.crashlytics.sdk.android:crashlytics:2.5.5@aar') { transitive = true }
diff --git a/twidere/src/main/java/org/mariotaku/twidere/activity/support/MediaViewerActivity.java b/twidere/src/main/java/org/mariotaku/twidere/activity/support/MediaViewerActivity.java
index d575d15715..7812402d30 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/activity/support/MediaViewerActivity.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/activity/support/MediaViewerActivity.java
@@ -16,20 +16,33 @@
 
 package org.mariotaku.twidere.activity.support;
 
+import android.content.Intent;
+import android.content.res.Configuration;
 import android.media.AudioManager;
 import android.media.MediaPlayer;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
+import android.support.annotation.CallSuper;
+import android.support.annotation.LayoutRes;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.app.ActivityCompat;
 import android.support.v4.app.Fragment;
+import android.support.v4.app.NavUtils;
+import android.support.v4.app.TaskStackBuilder;
 import android.support.v4.view.ViewPager;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.ActionBarDrawerToggle;
+import android.support.v7.app.AppCompatCallback;
+import android.support.v7.app.AppCompatDelegate;
+import android.support.v7.view.ActionMode;
+import android.support.v7.widget.Toolbar;
 import android.util.Pair;
 import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuInflater;
-import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageButton;
@@ -50,7 +63,6 @@
 import org.mariotaku.twidere.Constants;
 import org.mariotaku.twidere.R;
 import org.mariotaku.twidere.model.ParcelableMedia;
-import org.mariotaku.twidere.util.MenuUtils;
 import org.mariotaku.twidere.util.ThemeUtils;
 import org.mariotaku.twidere.util.Utils;
 import org.mariotaku.twidere.util.dagger.GeneralComponentHelper;
@@ -60,7 +72,8 @@
 import javax.inject.Inject;
 
 
-public final class MediaViewerActivity extends AbsMediaViewerActivity implements Constants {
+public final class MediaViewerActivity extends AbsMediaViewerActivity implements Constants,
+        AppCompatCallback, TaskStackBuilder.SupportParentable, ActionBarDrawerToggle.DelegateProvider {
 
     @Inject
     FileCache mFileCache;
@@ -71,8 +84,13 @@ public final class MediaViewerActivity extends AbsMediaViewerActivity implements
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        getDelegate().installViewFactory();
+        getDelegate().onCreate(savedInstanceState);
         GeneralComponentHelper.build(this).inject(this);
         super.onCreate(savedInstanceState);
+        ActionBar actionBar = getSupportActionBar();
+        assert actionBar != null;
+        actionBar.setDisplayHomeAsUpEnabled(true);
     }
 
     @Override
@@ -92,12 +110,19 @@ protected ViewPager findViewPager() {
 
     @Override
     public boolean isBarShowing() {
-        return false;
+        final ActionBar actionBar = getSupportActionBar();
+        return actionBar != null && actionBar.isShowing();
     }
 
     @Override
     public void setBarVisibility(boolean visible) {
-
+        ActionBar actionBar = getSupportActionBar();
+        if (actionBar == null) return;
+        if (visible) {
+            actionBar.show();
+        } else {
+            actionBar.hide();
+        }
     }
 
     @Override
@@ -259,7 +284,6 @@ public boolean onError(MediaPlayer mp, int what, int extra) {
             mVideoViewProgress.removeCallbacks(mVideoProgressRunnable);
             mVideoViewProgress.setVisibility(View.GONE);
             mMediaPlayerError = what;
-//            invalidateOptionsMenu();
             return true;
         }
 
@@ -277,7 +301,6 @@ public void onPrepared(MediaPlayer mp) {
                 mVideoViewProgress.post(mVideoProgressRunnable);
                 updatePlayerState();
                 mVideoControl.setVisibility(View.VISIBLE);
-//                invalidateOptionsMenu();
             }
         }
 
@@ -421,53 +444,6 @@ public View onCreateMediaView(LayoutInflater inflater, @Nullable ViewGroup conta
             return inflater.inflate(R.layout.layout_media_viewer_texture_video_view, container, false);
         }
 
-        @Override
-        public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-            inflater.inflate(R.menu.menu_media_viewer_video_page, menu);
-        }
-
-        @Override
-        public void onPrepareOptionsMenu(Menu menu) {
-            final boolean isLoading = getLoaderManager().hasRunningLoaders();
-            final boolean isDownloaded = hasDownloadedData();
-            MenuUtils.setMenuItemAvailability(menu, R.id.save, !isLoading && isDownloaded);
-            MenuUtils.setMenuItemAvailability(menu, R.id.share, !isLoading && isDownloaded);
-            MenuUtils.setMenuItemAvailability(menu, R.id.refresh, !isLoading && !isDownloaded);
-        }
-
-        @Override
-        public boolean onOptionsItemSelected(MenuItem item) {
-            switch (item.getItemId()) {
-                case R.id.save: {
-//                    requestAndSaveToStorage();
-                    return true;
-                }
-                case R.id.refresh: {
-                    startLoading();
-                    return true;
-                }
-                case R.id.share: {
-//                    shareMedia();
-                }
-            }
-            return super.onOptionsItemSelected(item);
-        }
-
-        @Override
-        public void onResume() {
-            super.onResume();
-        }
-
-        @Override
-        public void onDestroyView() {
-            super.onDestroyView();
-        }
-
-        @Override
-        public void onPause() {
-            super.onPause();
-        }
-
         private static class VideoPlayProgressRunnable implements Runnable {
 
             private final Handler mHandler;
@@ -499,4 +475,390 @@ public void run() {
             }
         }
     }
+
+    private AppCompatDelegate mDelegate;
+
+    @Override
+    protected void onPostCreate(@Nullable Bundle savedInstanceState) {
+        super.onPostCreate(savedInstanceState);
+        getDelegate().onPostCreate(savedInstanceState);
+    }
+
+    /**
+     * Support library version of {@link android.app.Activity#getActionBar}.
+     * <p/>
+     * <p>Retrieve a reference to this activity's ActionBar.
+     *
+     * @return The Activity's ActionBar, or null if it does not have one.
+     */
+    @Nullable
+    public ActionBar getSupportActionBar() {
+        return getDelegate().getSupportActionBar();
+    }
+
+    /**
+     * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link android.support.v7.app.ActionBar} for this
+     * Activity window.
+     * <p/>
+     * <p>When set to a non-null value the {@link #getActionBar()} method will return
+     * an {@link android.support.v7.app.ActionBar} object that can be used to control the given toolbar as if it were
+     * a traditional window decor action bar. The toolbar's menu will be populated with the
+     * Activity's options menu and the navigation button will be wired through the standard
+     * {@link android.R.id#home home} menu select action.</p>
+     * <p/>
+     * <p>In order to use a Toolbar within the Activity's window content the application
+     * must not request the window feature
+     * {@link android.view.Window#FEATURE_ACTION_BAR FEATURE_SUPPORT_ACTION_BAR}.</p>
+     *
+     * @param toolbar Toolbar to set as the Activity's action bar
+     */
+    public void setSupportActionBar(@Nullable Toolbar toolbar) {
+        getDelegate().setSupportActionBar(toolbar);
+    }
+
+    @NonNull
+    @Override
+    public MenuInflater getMenuInflater() {
+        return getDelegate().getMenuInflater();
+    }
+
+    @Override
+    public void setContentView(@LayoutRes int layoutResID) {
+        getDelegate().setContentView(layoutResID);
+    }
+
+    @Override
+    public void setContentView(View view) {
+        getDelegate().setContentView(view);
+    }
+
+    @Override
+    public void setContentView(View view, ViewGroup.LayoutParams params) {
+        getDelegate().setContentView(view, params);
+    }
+
+    @Override
+    public void addContentView(View view, ViewGroup.LayoutParams params) {
+        getDelegate().addContentView(view, params);
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        getDelegate().onConfigurationChanged(newConfig);
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        getDelegate().onStop();
+    }
+
+    @Override
+    protected void onPostResume() {
+        super.onPostResume();
+        getDelegate().onPostResume();
+    }
+
+    @Override
+    public final boolean onMenuItemSelected(int featureId, android.view.MenuItem item) {
+        if (super.onMenuItemSelected(featureId, item)) {
+            return true;
+        }
+
+        final ActionBar ab = getSupportActionBar();
+        if (item.getItemId() == android.R.id.home && ab != null &&
+                (ab.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
+            return onSupportNavigateUp();
+        }
+        return false;
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        getDelegate().onDestroy();
+    }
+
+    @Override
+    protected void onTitleChanged(CharSequence title, int color) {
+        super.onTitleChanged(title, color);
+        getDelegate().setTitle(title);
+    }
+
+    /**
+     * Enable extended support library window features.
+     * <p>
+     * This is a convenience for calling
+     * {@link android.view.Window#requestFeature getWindow().requestFeature()}.
+     * </p>
+     *
+     * @param featureId The desired feature as defined in
+     *                  {@link android.view.Window} or {@link android.support.v4.view.WindowCompat}.
+     * @return Returns true if the requested feature is supported and now enabled.
+     * @see android.app.Activity#requestWindowFeature
+     * @see android.view.Window#requestFeature
+     */
+    public boolean supportRequestWindowFeature(int featureId) {
+        return getDelegate().requestWindowFeature(featureId);
+    }
+
+    @Override
+    public void supportInvalidateOptionsMenu() {
+        getDelegate().invalidateOptionsMenu();
+    }
+
+    /**
+     * @hide
+     */
+    public void invalidateOptionsMenu() {
+        getDelegate().invalidateOptionsMenu();
+    }
+
+    /**
+     * Notifies the Activity that a support action mode has been started.
+     * Activity subclasses overriding this method should call the superclass implementation.
+     *
+     * @param mode The new action mode.
+     */
+    @CallSuper
+    public void onSupportActionModeStarted(ActionMode mode) {
+    }
+
+    /**
+     * Notifies the activity that a support action mode has finished.
+     * Activity subclasses overriding this method should call the superclass implementation.
+     *
+     * @param mode The action mode that just finished.
+     */
+    @CallSuper
+    public void onSupportActionModeFinished(ActionMode mode) {
+    }
+
+    /**
+     * Called when a support action mode is being started for this window. Gives the
+     * callback an opportunity to handle the action mode in its own unique and
+     * beautiful way. If this method returns null the system can choose a way
+     * to present the mode or choose not to start the mode at all.
+     *
+     * @param callback Callback to control the lifecycle of this action mode
+     * @return The ActionMode that was started, or null if the system should present it
+     */
+    @Nullable
+    @Override
+    public ActionMode onWindowStartingSupportActionMode(ActionMode.Callback callback) {
+        return null;
+    }
+
+    public ActionMode startSupportActionMode(ActionMode.Callback callback) {
+        return getDelegate().startSupportActionMode(callback);
+    }
+
+    /**
+     * @deprecated Progress bars are no longer provided in AppCompat.
+     */
+    @Deprecated
+    public void setSupportProgressBarVisibility(boolean visible) {
+    }
+
+    /**
+     * @deprecated Progress bars are no longer provided in AppCompat.
+     */
+    @Deprecated
+    public void setSupportProgressBarIndeterminateVisibility(boolean visible) {
+    }
+
+    /**
+     * @deprecated Progress bars are no longer provided in AppCompat.
+     */
+    @Deprecated
+    public void setSupportProgressBarIndeterminate(boolean indeterminate) {
+    }
+
+    /**
+     * @deprecated Progress bars are no longer provided in AppCompat.
+     */
+    @Deprecated
+    public void setSupportProgress(int progress) {
+    }
+
+    /**
+     * Support version of {@link #onCreateNavigateUpTaskStack(android.app.TaskStackBuilder)}.
+     * This method will be called on all platform versions.
+     * <p/>
+     * Define the synthetic task stack that will be generated during Up navigation from
+     * a different task.
+     * <p/>
+     * <p>The default implementation of this method adds the parent chain of this activity
+     * as specified in the manifest to the supplied {@link android.support.v4.app.TaskStackBuilder}. Applications
+     * may choose to override this method to construct the desired task stack in a different
+     * way.</p>
+     * <p/>
+     * <p>This method will be invoked by the default implementation of {@link #onNavigateUp()}
+     * if {@link #shouldUpRecreateTask(android.content.Intent)} returns true when supplied with the intent
+     * returned by {@link #getParentActivityIntent()}.</p>
+     * <p/>
+     * <p>Applications that wish to supply extra Intent parameters to the parent stack defined
+     * by the manifest should override
+     * {@link #onPrepareSupportNavigateUpTaskStack(android.support.v4.app.TaskStackBuilder)}.</p>
+     *
+     * @param builder An empty TaskStackBuilder - the application should add intents representing
+     *                the desired task stack
+     */
+    public void onCreateSupportNavigateUpTaskStack(TaskStackBuilder builder) {
+        builder.addParentStack(this);
+    }
+
+    /**
+     * Support version of {@link #onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder)}.
+     * This method will be called on all platform versions.
+     * <p/>
+     * Prepare the synthetic task stack that will be generated during Up navigation
+     * from a different task.
+     * <p/>
+     * <p>This method receives the {@link android.support.v4.app.TaskStackBuilder} with the constructed series of
+     * Intents as generated by {@link #onCreateSupportNavigateUpTaskStack(android.support.v4.app.TaskStackBuilder)}.
+     * If any extra data should be added to these intents before launching the new task,
+     * the application should override this method and add that data here.</p>
+     *
+     * @param builder A TaskStackBuilder that has been populated with Intents by
+     *                onCreateNavigateUpTaskStack.
+     */
+    public void onPrepareSupportNavigateUpTaskStack(TaskStackBuilder builder) {
+    }
+
+    /**
+     * This method is called whenever the user chooses to navigate Up within your application's
+     * activity hierarchy from the action bar.
+     * <p/>
+     * <p>If a parent was specified in the manifest for this activity or an activity-alias to it,
+     * default Up navigation will be handled automatically. See
+     * {@link #getSupportParentActivityIntent()} for how to specify the parent. If any activity
+     * along the parent chain requires extra Intent arguments, the Activity subclass
+     * should override the method {@link #onPrepareSupportNavigateUpTaskStack(android.support.v4.app.TaskStackBuilder)}
+     * to supply those arguments.</p>
+     * <p/>
+     * <p>See <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and
+     * Back Stack</a> from the developer guide and
+     * <a href="{@docRoot}design/patterns/navigation.html">Navigation</a> from the design guide
+     * for more information about navigating within your app.</p>
+     * <p/>
+     * <p>See the {@link android.support.v4.app.TaskStackBuilder} class and the Activity methods
+     * {@link #getSupportParentActivityIntent()}, {@link #supportShouldUpRecreateTask(android.content.Intent)}, and
+     * {@link #supportNavigateUpTo(android.content.Intent)} for help implementing custom Up navigation.</p>
+     *
+     * @return true if Up navigation completed successfully and this Activity was finished,
+     * false otherwise.
+     */
+    public boolean onSupportNavigateUp() {
+        Intent upIntent = getSupportParentActivityIntent();
+
+        if (upIntent != null) {
+            if (supportShouldUpRecreateTask(upIntent)) {
+                TaskStackBuilder b = TaskStackBuilder.create(this);
+                onCreateSupportNavigateUpTaskStack(b);
+                onPrepareSupportNavigateUpTaskStack(b);
+                b.startActivities();
+
+                try {
+                    ActivityCompat.finishAffinity(this);
+                } catch (IllegalStateException e) {
+                    // This can only happen on 4.1+, when we don't have a parent or a result set.
+                    // In that case we should just finish().
+                    finish();
+                }
+            } else {
+                // This activity is part of the application's task, so simply
+                // navigate up to the hierarchical parent activity.
+                supportNavigateUpTo(upIntent);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Obtain an {@link android.content.Intent} that will launch an explicit target activity
+     * specified by sourceActivity's {@link android.support.v4.app.NavUtils#PARENT_ACTIVITY} &lt;meta-data&gt;
+     * element in the application's manifest. If the device is running
+     * Jellybean or newer, the android:parentActivityName attribute will be preferred
+     * if it is present.
+     *
+     * @return a new Intent targeting the defined parent activity of sourceActivity
+     */
+    @Nullable
+    public Intent getSupportParentActivityIntent() {
+        return NavUtils.getParentActivityIntent(this);
+    }
+
+    /**
+     * Returns true if sourceActivity should recreate the task when navigating 'up'
+     * by using targetIntent.
+     * <p/>
+     * <p>If this method returns false the app can trivially call
+     * {@link #supportNavigateUpTo(android.content.Intent)} using the same parameters to correctly perform
+     * up navigation. If this method returns false, the app should synthesize a new task stack
+     * by using {@link android.support.v4.app.TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
+     *
+     * @param targetIntent An intent representing the target destination for up navigation
+     * @return true if navigating up should recreate a new task stack, false if the same task
+     * should be used for the destination
+     */
+    public boolean supportShouldUpRecreateTask(Intent targetIntent) {
+        return NavUtils.shouldUpRecreateTask(this, targetIntent);
+    }
+
+    /**
+     * Navigate from sourceActivity to the activity specified by upIntent, finishing sourceActivity
+     * in the process. upIntent will have the flag {@link android.content.Intent#FLAG_ACTIVITY_CLEAR_TOP} set
+     * by this method, along with any others required for proper up navigation as outlined
+     * in the Android Design Guide.
+     * <p/>
+     * <p>This method should be used when performing up navigation from within the same task
+     * as the destination. If up navigation should cross tasks in some cases, see
+     * {@link #supportShouldUpRecreateTask(android.content.Intent)}.</p>
+     *
+     * @param upIntent An intent representing the target destination for up navigation
+     */
+    public void supportNavigateUpTo(Intent upIntent) {
+        NavUtils.navigateUpTo(this, upIntent);
+    }
+
+    @Nullable
+    @Override
+    public ActionBarDrawerToggle.Delegate getDrawerToggleDelegate() {
+        return getDelegate().getDrawerToggleDelegate();
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * <p>Please note: AppCompat uses it's own feature id for the action bar:
+     * {@link AppCompatDelegate#FEATURE_SUPPORT_ACTION_BAR FEATURE_SUPPORT_ACTION_BAR}.</p>
+     */
+    @Override
+    public boolean onMenuOpened(int featureId, Menu menu) {
+        return super.onMenuOpened(featureId, menu);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * <p>Please note: AppCompat uses it's own feature id for the action bar:
+     * {@link AppCompatDelegate#FEATURE_SUPPORT_ACTION_BAR FEATURE_SUPPORT_ACTION_BAR}.</p>
+     */
+    @Override
+    public void onPanelClosed(int featureId, Menu menu) {
+        super.onPanelClosed(featureId, menu);
+    }
+
+    /**
+     * @return The {@link AppCompatDelegate} being used by this Activity.
+     */
+    public AppCompatDelegate getDelegate() {
+        if (mDelegate == null) {
+            mDelegate = AppCompatDelegate.create(this, this);
+        }
+        return mDelegate;
+    }
 }
diff --git a/twidere/src/main/java/org/mariotaku/twidere/util/Utils.java b/twidere/src/main/java/org/mariotaku/twidere/util/Utils.java
index 92fd965f70..84dd9d3ce7 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/util/Utils.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/util/Utils.java
@@ -1902,7 +1902,6 @@ public static void openMediaDirectly(final Context context, final long accountId
         openMediaDirectly(context, accountId, status, null, current, getPrimaryMedia(status), options);
     }
 
-    @NonNull
     public static ParcelableMedia[] getPrimaryMedia(ParcelableStatus status) {
         if (status.is_quote && ArrayUtils.isEmpty(status.media)) {
             return status.quoted_media;
diff --git a/twidere/src/main/res/xml/preferences_storage.xml b/twidere/src/main/res/xml/preferences_storage.xml
index b66d92f896..25904e4643 100644
--- a/twidere/src/main/res/xml/preferences_storage.xml
+++ b/twidere/src/main/res/xml/preferences_storage.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
     android:key="settings_storage"
     android:title="@string/storage">
@@ -15,7 +16,7 @@
             android:title="@string/database_item_limit"
             app:max="500"
             app:min="50"
-            app:step="10" />
+            app:step="10"/>
 
         <org.mariotaku.twidere.preference.SeekBarDialogPreference
             android:defaultValue="300"
@@ -23,21 +24,22 @@
             android:title="@string/cache_size_limit"
             app:max="500"
             app:min="100"
-            app:step="50" />
+            app:progressTextSuffix="MB"
+            app:step="50"/>
 
         <org.mariotaku.twidere.preference.ClearSearchHistoryPreference
             android:key="clear_search_history"
-            android:title="@string/clear_search_history" />
+            android:title="@string/clear_search_history"/>
 
         <org.mariotaku.twidere.preference.ClearCachePreference
             android:key="clear_cache"
             android:summary="@string/clear_cache_summary"
-            android:title="@string/clear_cache" />
+            android:title="@string/clear_cache"/>
 
         <org.mariotaku.twidere.preference.ClearDatabasesPreference
             android:key="clear_databases"
             android:summary="@string/clear_databases_summary"
-            android:title="@string/clear_databases" />
+            android:title="@string/clear_databases"/>
 
     </PreferenceCategory>
 
