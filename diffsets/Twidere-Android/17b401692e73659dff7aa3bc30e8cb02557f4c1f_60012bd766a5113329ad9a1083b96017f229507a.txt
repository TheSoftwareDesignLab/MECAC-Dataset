diff --git a/twidere/build.gradle b/twidere/build.gradle
index b674954c66..9b1c20ebb5 100644
--- a/twidere/build.gradle
+++ b/twidere/build.gradle
@@ -226,6 +226,7 @@ dependencies {
     implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.15'
     implementation 'com.sprylab.android.texturevideoview:texturevideoview:1.2.1'
     implementation 'com.squareup:pollexor:2.0.4'
+    implementation 'org.apache.commons:commons-text:1.8'
     implementation "org.apache.james:apache-mime4j-core:${libVersions['Mime4J']}"
     implementation "org.apache.james:apache-mime4j-storage:${libVersions['Mime4J']}"
     implementation "com.bluelinelabs:logansquare:${sharedVersions['LoganSquare']}"
diff --git a/twidere/src/main/java/org/apache/commons/text/translate/AggregateTranslator.java b/twidere/src/main/java/org/apache/commons/text/translate/AggregateTranslator.java
deleted file mode 100644
index 788f8c5e1a..0000000000
--- a/twidere/src/main/java/org/apache/commons/text/translate/AggregateTranslator.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.text.translate;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Executes a sequence of translators one after the other. Execution ends whenever
- * the first translator consumes codepoints from the input.
- *
- * @since 1.0
- */
-public class AggregateTranslator extends CharSequenceTranslator {
-
-    /**
-     * Translator list.
-     */
-    private final List<CharSequenceTranslator> translators = new ArrayList<>();
-
-    /**
-     * Specify the translators to be used at creation time.
-     *
-     * @param translators CharSequenceTranslator array to aggregate
-     */
-    public AggregateTranslator(final CharSequenceTranslator... translators) {
-        if (translators != null) {
-            for (CharSequenceTranslator translator : translators) {
-                if (translator != null) {
-                    this.translators.add(translator);
-                }
-            }
-        }
-    }
-
-    /**
-     * The first translator to consume codepoints from the input is the 'winner'.
-     * Execution stops with the number of consumed codepoints being returned.
-     * {@inheritDoc}
-     */
-    @Override
-    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
-        for (final CharSequenceTranslator translator : translators) {
-            final int consumed = translator.translate(input, index, out);
-            if (consumed != 0) {
-                return consumed;
-            }
-        }
-        return 0;
-    }
-
-}
diff --git a/twidere/src/main/java/org/apache/commons/text/translate/CharSequenceTranslator.java b/twidere/src/main/java/org/apache/commons/text/translate/CharSequenceTranslator.java
deleted file mode 100644
index de6fa2e65f..0000000000
--- a/twidere/src/main/java/org/apache/commons/text/translate/CharSequenceTranslator.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.text.translate;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.Locale;
-
-/**
- * An API for translating text.
- * Its core use is to escape and unescape text. Because escaping and unescaping
- * is completely contextual, the API does not present two separate signatures.
- *
- * @since 1.0
- */
-public abstract class CharSequenceTranslator {
-
-    /**
-     * Array containing the hexadecimal alphabet.
-     */
-    static final char[] HEX_DIGITS = new char[]{'0', '1', '2', '3',
-            '4', '5', '6', '7',
-            '8', '9', 'A', 'B',
-            'C', 'D', 'E', 'F'};
-
-    /**
-     * Translate a set of codepoints, represented by an int index into a CharSequence,
-     * into another set of codepoints. The number of codepoints consumed must be returned,
-     * and the only IOExceptions thrown must be from interacting with the Writer so that
-     * the top level API may reliably ignore StringWriter IOExceptions.
-     *
-     * @param input CharSequence that is being translated
-     * @param index int representing the current point of translation
-     * @param out   Writer to translate the text to
-     * @return int count of codepoints consumed
-     * @throws IOException if and only if the Writer produces an IOException
-     */
-    public abstract int translate(CharSequence input, int index, Writer out) throws IOException;
-
-    /**
-     * Helper for non-Writer usage.
-     *
-     * @param input CharSequence to be translated
-     * @return String output of translation
-     */
-    public final String translate(final CharSequence input) {
-        if (input == null) {
-            return null;
-        }
-        try {
-            final StringWriter writer = new StringWriter(input.length() * 2);
-            translate(input, writer);
-            return writer.toString();
-        } catch (final IOException ioe) {
-            // this should never ever happen while writing to a StringWriter
-            throw new RuntimeException(ioe);
-        }
-    }
-
-    /**
-     * Translate an input onto a Writer. This is intentionally final as its algorithm is
-     * tightly coupled with the abstract method of this class.
-     *
-     * @param input CharSequence that is being translated
-     * @param out   Writer to translate the text to
-     * @throws IOException if and only if the Writer produces an IOException
-     */
-    public final void translate(final CharSequence input, final Writer out) throws IOException {
-        if (out == null) throw new IllegalArgumentException("The Writer must not be null");
-        if (input == null) {
-            return;
-        }
-        int pos = 0;
-        final int len = input.length();
-        while (pos < len) {
-            final int consumed = translate(input, pos, out);
-            if (consumed == 0) {
-                // inlined implementation of Character.toChars(Character.codePointAt(input, pos))
-                // avoids allocating temp char arrays and duplicate checks
-                final char c1 = input.charAt(pos);
-                out.write(c1);
-                pos++;
-                if (Character.isHighSurrogate(c1) && pos < len) {
-                    final char c2 = input.charAt(pos);
-                    if (Character.isLowSurrogate(c2)) {
-                        out.write(c2);
-                        pos++;
-                    }
-                }
-                continue;
-            }
-            // contract with translators is that they have to understand codepoints
-            // and they just took care of a surrogate pair
-            for (int pt = 0; pt < consumed; pt++) {
-                pos += Character.charCount(Character.codePointAt(input, pos));
-            }
-        }
-    }
-
-    /**
-     * Helper method to create a merger of this translator with another set of
-     * translators. Useful in customizing the standard functionality.
-     *
-     * @param translators CharSequenceTranslator array of translators to merge with this one
-     * @return CharSequenceTranslator merging this translator with the others
-     */
-    public final CharSequenceTranslator with(final CharSequenceTranslator... translators) {
-        final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];
-        newArray[0] = this;
-        System.arraycopy(translators, 0, newArray, 1, translators.length);
-        return new AggregateTranslator(newArray);
-    }
-
-    /**
-     * <p>Returns an upper case hexadecimal <code>String</code> for the given
-     * character.</p>
-     *
-     * @param codepoint The codepoint to convert.
-     * @return An upper case hexadecimal <code>String</code>
-     */
-    public static String hex(final int codepoint) {
-        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);
-    }
-
-}
diff --git a/twidere/src/main/java/org/apache/commons/text/translate/CodePointTranslator.java b/twidere/src/main/java/org/apache/commons/text/translate/CodePointTranslator.java
deleted file mode 100644
index 71828be069..0000000000
--- a/twidere/src/main/java/org/apache/commons/text/translate/CodePointTranslator.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.text.translate;
-
-import java.io.IOException;
-import java.io.Writer;
-
-/**
- * Helper subclass to CharSequenceTranslator to allow for translations that
- * will replace up to one character at a time.
- *
- * @since 1.0
- */
-public abstract class CodePointTranslator extends CharSequenceTranslator {
-
-    /**
-     * Implementation of translate that maps onto the abstract translate(int, Writer) method.
-     * {@inheritDoc}
-     */
-    @Override
-    public final int translate(final CharSequence input, final int index, final Writer out) throws IOException {
-        final int codepoint = Character.codePointAt(input, index);
-        final boolean consumed = translate(codepoint, out);
-        return consumed ? 1 : 0;
-    }
-
-    /**
-     * Translate the specified codepoint into another.
-     *
-     * @param codepoint int character input to translate
-     * @param out Writer to optionally push the translated output to
-     * @return boolean as to whether translation occurred or not
-     * @throws IOException if and only if the Writer produces an IOException
-     */
-    public abstract boolean translate(int codepoint, Writer out) throws IOException;
-
-}
diff --git a/twidere/src/main/java/org/apache/commons/text/translate/LookupTranslator.java b/twidere/src/main/java/org/apache/commons/text/translate/LookupTranslator.java
deleted file mode 100644
index fc02ac3472..0000000000
--- a/twidere/src/main/java/org/apache/commons/text/translate/LookupTranslator.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.text.translate;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.security.InvalidParameterException;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-
-/**
- * Translates a value using a lookup table.
- *
- * @since 1.0
- */
-public class LookupTranslator extends CharSequenceTranslator {
-
-    /** The mapping to be used in translation. */
-    private final Map<String, String> lookupMap;
-    /** The first character of each key in the lookupMap. */
-    private final HashSet<Character> prefixSet;
-    /** The length of the shortest key in the lookupMap. */
-    private final int shortest;
-    /** The length of the longest key in the lookupMap. */
-    private final int longest;
-
-    /**
-     * Define the lookup table to be used in translation
-     *
-     * Note that, as of Lang 3.1 (the orgin of this code), the key to the lookup
-     * table is converted to a java.lang.String. This is because we need the key
-     * to support hashCode and equals(Object), allowing it to be the key for a
-     * HashMap. See LANG-882.
-     *
-     * @param lookupMap Map&lt;CharSequence, CharSequence&gt; table of translator
-     *                  mappings
-     */
-    public LookupTranslator(final Map<CharSequence, CharSequence> lookupMap) {
-        if (lookupMap == null) {
-            throw new InvalidParameterException("lookupMap cannot be null");
-        }
-        this.lookupMap = new HashMap<>();
-        this.prefixSet = new HashSet<>();
-        int currentShortest = Integer.MAX_VALUE;
-        int currentLongest = 0;
-
-        for (Map.Entry<CharSequence, CharSequence> pair : lookupMap.entrySet()) {
-            this.lookupMap.put(pair.getKey().toString(), pair.getValue().toString());
-            this.prefixSet.add(pair.getKey().charAt(0));
-            final int sz = pair.getKey().length();
-            if (sz < currentShortest) {
-                currentShortest = sz;
-            }
-            if (sz > currentLongest) {
-                currentLongest = sz;
-            }
-        }
-        this.shortest = currentShortest;
-        this.longest = currentLongest;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
-        // check if translation exists for the input at position index
-        if (prefixSet.contains(input.charAt(index))) {
-            int max = longest;
-            if (index + longest > input.length()) {
-                max = input.length() - index;
-            }
-            // implement greedy algorithm by trying maximum match first
-            for (int i = max; i >= shortest; i--) {
-                final CharSequence subSeq = input.subSequence(index, index + i);
-                final String result = lookupMap.get(subSeq.toString());
-
-                if (result != null) {
-                    out.write(result);
-                    return i;
-                }
-            }
-        }
-        return 0;
-    }
-}
diff --git a/twidere/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java b/twidere/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java
deleted file mode 100644
index 66704dd1a5..0000000000
--- a/twidere/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.text.translate;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.Arrays;
-import java.util.EnumSet;
-
-/**
- * Translate XML numeric entities of the form &amp;#[xX]?\d+;? to
- * the specific codepoint.
- *
- * Note that the semi-colon is optional.
- *
- * @since 1.0
- */
-public class NumericEntityUnescaper extends CharSequenceTranslator {
-
-    /** NumericEntityUnescaper option enum. */
-    public enum OPTION { semiColonRequired, semiColonOptional, errorIfNoSemiColon }
-
-    /** EnumSet of OPTIONS, given from the constructor. */
-    private final EnumSet<OPTION> options;
-
-    /**
-     * Create a UnicodeUnescaper.
-     *
-     * The constructor takes a list of options, only one type of which is currently
-     * available (whether to allow, error or ignore the semi-colon on the end of a
-     * numeric entity to being missing).
-     *
-     * For example, to support numeric entities without a ';':
-     *    new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional)
-     * and to throw an IllegalArgumentException when they're missing:
-     *    new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon)
-     *
-     * Note that the default behaviour is to ignore them.
-     *
-     * @param options to apply to this unescaper
-     */
-    public NumericEntityUnescaper(final OPTION... options) {
-        if (options.length > 0) {
-            this.options = EnumSet.copyOf(Arrays.asList(options));
-        } else {
-            this.options = EnumSet.of(OPTION.semiColonRequired);
-        }
-    }
-
-    /**
-     * Whether the passed in option is currently set.
-     *
-     * @param option to check state of
-     * @return whether the option is set
-     */
-    public boolean isSet(final OPTION option) {
-        return options != null && options.contains(option);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
-        final int seqEnd = input.length();
-        // Uses -2 to ensure there is something after the &#
-        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
-            int start = index + 2;
-            boolean isHex = false;
-
-            final char firstChar = input.charAt(start);
-            if (firstChar == 'x' || firstChar == 'X') {
-                start++;
-                isHex = true;
-
-                // Check there's more than just an x after the &#
-                if (start == seqEnd) {
-                    return 0;
-                }
-            }
-
-            int end = start;
-            // Note that this supports character codes without a ; on the end
-            while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9'
-                                    || input.charAt(end) >= 'a' && input.charAt(end) <= 'f'
-                                    || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {
-                end++;
-            }
-
-            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';
-
-            if (!semiNext) {
-                if (isSet(OPTION.semiColonRequired)) {
-                    return 0;
-                } else {
-                    if (isSet(OPTION.errorIfNoSemiColon)) {
-                        throw new IllegalArgumentException("Semi-colon required at end of numeric entity");
-                    }
-                }
-            }
-
-            int entityValue;
-            try {
-                if (isHex) {
-                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
-                } else {
-                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
-                }
-            } catch (final NumberFormatException nfe) {
-                return 0;
-            }
-
-            if (entityValue > 0xFFFF) {
-                final char[] chrs = Character.toChars(entityValue);
-                out.write(chrs[0]);
-                out.write(chrs[1]);
-            } else {
-                out.write(entityValue);
-            }
-
-            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
-        }
-        return 0;
-    }
-}
