diff --git a/twidere/src/.google.commit-id b/twidere/src/.google.commit-id
index 8598c1cc04..2239437ac6 100644
--- a/twidere/src/.google.commit-id
+++ b/twidere/src/.google.commit-id
@@ -1 +1 @@
-8d2f0fd149cce409a65c242b58fe90a0cb8da2ad
+434f952ffc8cd18127ad4f1343de3cd174285045
diff --git a/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.java b/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.java
deleted file mode 100644
index 34a84139d2..0000000000
--- a/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Twidere - Twitter client for Android
- *
- *  Copyright (C) 2012-2015 Mariotaku Lee <mariotaku.lee@gmail.com>
- *
- *  This program is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package org.mariotaku.twidere.view;
-
-import android.content.Context;
-import android.support.v4.view.MotionEventCompat;
-import android.support.v7.widget.RecyclerView;
-import android.util.AttributeSet;
-import android.util.TypedValue;
-import android.view.ContextMenu;
-import android.view.InputDevice;
-import android.view.MotionEvent;
-import android.view.View;
-
-import org.mariotaku.twidere.util.MouseScrollDirectionDecider;
-
-/**
- * Created by mariotaku on 15/3/30.
- */
-public class ExtendedRecyclerView extends RecyclerView {
-
-    private final MouseScrollDirectionDecider mouseScrollDirectionDecider;
-    // This value is used when handling generic motion events.
-    private float scrollFactor = Float.MIN_VALUE;
-    private ContextMenuInfo contextMenuInfo;
-
-    public ExtendedRecyclerView(Context context) {
-        this(context, null);
-    }
-
-    public ExtendedRecyclerView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-    }
-
-    public ExtendedRecyclerView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        mouseScrollDirectionDecider = new MouseScrollDirectionDecider(getScrollFactorBackport());
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        mouseScrollDirectionDecider.attach(this);
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        mouseScrollDirectionDecider.detach();
-        super.onDetachedFromWindow();
-    }
-
-    @Override
-    public boolean onGenericMotionEvent(MotionEvent event) {
-        final LayoutManager lm = getLayoutManager();
-        if (lm == null) {
-            return false;
-        }
-        if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
-            if (event.getAction() == MotionEventCompat.ACTION_SCROLL) {
-                final float vScroll, hScroll;
-                if (lm.canScrollVertically()) {
-                    vScroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
-                    if (!mouseScrollDirectionDecider.isVerticalAvailable()) {
-                        mouseScrollDirectionDecider.guessDirection(event);
-                    }
-                } else {
-                    vScroll = 0f;
-                }
-                if (lm.canScrollHorizontally()) {
-                    hScroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
-                    if (!mouseScrollDirectionDecider.isHorizontalAvailable()) {
-                        mouseScrollDirectionDecider.guessDirection(event);
-                    }
-                } else {
-                    hScroll = 0f;
-                }
-                if (vScroll != 0 || hScroll != 0) {
-                    final float scrollFactor = getScrollFactorBackport();
-                    float horizontalDirection = mouseScrollDirectionDecider.getHorizontalDirection();
-                    float verticalDirection = mouseScrollDirectionDecider.getVerticalDirection();
-                    final float hFactor = scrollFactor * (horizontalDirection != 0 ? horizontalDirection : -1);
-                    final float vFactor = scrollFactor * (verticalDirection != 0 ? verticalDirection : -1);
-                    scrollBy((int) (hScroll * hFactor), (int) (vScroll * vFactor));
-                }
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public int computeVerticalScrollRange() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeVerticalScrollRange();
-    }
-
-    @Override
-    public int computeHorizontalScrollRange() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeHorizontalScrollRange();
-    }
-
-    @Override
-    public int computeHorizontalScrollOffset() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeHorizontalScrollOffset();
-    }
-
-    @Override
-    public int computeHorizontalScrollExtent() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeHorizontalScrollExtent();
-    }
-
-    @Override
-    public int computeVerticalScrollOffset() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeVerticalScrollOffset();
-    }
-
-    @Override
-    public int computeVerticalScrollExtent() {
-        if (getLayoutManager() == null) return 0;
-        return super.computeVerticalScrollExtent();
-    }
-
-    @Override
-    protected ContextMenu.ContextMenuInfo getContextMenuInfo() {
-        return contextMenuInfo;
-    }
-
-    @Override
-    public boolean showContextMenuForChild(View originalView) {
-        if (originalView.getParent() != this) {
-            return false;
-        }
-        final int position = getChildLayoutPosition(originalView);
-        if (position == RecyclerView.NO_POSITION) return false;
-        contextMenuInfo = new ContextMenuInfo(getId(), position);
-        return super.showContextMenuForChild(originalView);
-    }
-
-    /**
-     * Ported from View.getVerticalScrollFactor.
-     */
-    private float getScrollFactorBackport() {
-        if (scrollFactor == Float.MIN_VALUE) {
-            TypedValue outValue = new TypedValue();
-            if (getContext().getTheme().resolveAttribute(
-                    android.R.attr.listPreferredItemHeight, outValue, true)) {
-                scrollFactor = outValue.getDimension(
-                        getContext().getResources().getDisplayMetrics());
-            } else {
-                return 0; //listPreferredItemHeight is not defined, no generic scrolling
-            }
-
-        }
-        return scrollFactor;
-    }
-
-    public static class ContextMenuInfo implements ContextMenu.ContextMenuInfo {
-        private final int recyclerViewId;
-        private final int position;
-
-        public ContextMenuInfo(int recyclerViewId, int position) {
-            this.recyclerViewId = recyclerViewId;
-            this.position = position;
-        }
-
-        public int getRecyclerViewId() {
-            return recyclerViewId;
-        }
-
-        public int getPosition() {
-            return position;
-        }
-    }
-
-}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.kt b/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.kt
new file mode 100644
index 0000000000..6e01b33a58
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/view/ExtendedRecyclerView.kt
@@ -0,0 +1,179 @@
+/*
+ * Twidere - Twitter client for Android
+ *
+ *  Copyright (C) 2012-2015 Mariotaku Lee <mariotaku.lee@gmail.com>
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.mariotaku.twidere.view
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.graphics.Rect
+import android.os.Build
+import android.support.v7.widget.RecyclerView
+import android.util.AttributeSet
+import android.util.TypedValue
+import android.view.*
+import org.mariotaku.twidere.R
+
+import org.mariotaku.twidere.util.MouseScrollDirectionDecider
+
+/**
+ * Created by mariotaku on 15/3/30.
+ */
+class ExtendedRecyclerView(context: Context, attrs: AttributeSet? = null) :
+        RecyclerView(context, attrs, 0) {
+
+    private val mouseScrollDirectionDecider: MouseScrollDirectionDecider
+    // This value is used when handling generic motion events.
+    private var scrollFactor = java.lang.Float.MIN_VALUE
+    private var contextMenuInfo: ContextMenuInfo? = null
+    private var usePaddingBackup: Boolean = false
+    private val paddingBackup = Rect()
+
+    init {
+        mouseScrollDirectionDecider = MouseScrollDirectionDecider(scrollFactorBackport)
+        val a = context.obtainStyledAttributes(attrs, R.styleable.IExtendedViewPadding)
+        usePaddingBackup = (0 until a.indexCount).any { a.hasValue(it) }
+        a.recycle()
+        paddingBackup.set(paddingLeft, paddingTop, paddingRight, paddingBottom)
+    }
+
+    override fun onAttachedToWindow() {
+        super.onAttachedToWindow()
+        mouseScrollDirectionDecider.attach(this)
+    }
+
+    override fun onDetachedFromWindow() {
+        mouseScrollDirectionDecider.detach()
+        super.onDetachedFromWindow()
+    }
+
+    override fun onGenericMotionEvent(event: MotionEvent): Boolean {
+        val lm = layoutManager ?: return false
+        if (event.source and InputDevice.SOURCE_CLASS_POINTER != 0) {
+            if (event.action == MotionEvent.ACTION_SCROLL) {
+                val vScroll: Float
+                val hScroll: Float
+                if (lm.canScrollVertically()) {
+                    vScroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL)
+                    if (!mouseScrollDirectionDecider.isVerticalAvailable) {
+                        mouseScrollDirectionDecider.guessDirection(event)
+                    }
+                } else {
+                    vScroll = 0f
+                }
+                if (lm.canScrollHorizontally()) {
+                    hScroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL)
+                    if (!mouseScrollDirectionDecider.isHorizontalAvailable) {
+                        mouseScrollDirectionDecider.guessDirection(event)
+                    }
+                } else {
+                    hScroll = 0f
+                }
+                if (vScroll != 0f || hScroll != 0f) {
+                    val scrollFactor = scrollFactorBackport
+                    val horizontalDirection = mouseScrollDirectionDecider.horizontalDirection
+                    val verticalDirection = mouseScrollDirectionDecider.verticalDirection
+                    val hFactor = scrollFactor * if (horizontalDirection != 0f) horizontalDirection else -1f
+                    val vFactor = scrollFactor * if (verticalDirection != 0f) verticalDirection else -1f
+                    scrollBy((hScroll * hFactor).toInt(), (vScroll * vFactor).toInt())
+                }
+            }
+        }
+        return false
+    }
+
+    override fun computeVerticalScrollRange(): Int {
+        if (layoutManager == null) return 0
+        return super.computeVerticalScrollRange()
+    }
+
+    override fun computeHorizontalScrollRange(): Int {
+        if (layoutManager == null) return 0
+        return super.computeHorizontalScrollRange()
+    }
+
+    override fun computeHorizontalScrollOffset(): Int {
+        if (layoutManager == null) return 0
+        return super.computeHorizontalScrollOffset()
+    }
+
+    override fun computeHorizontalScrollExtent(): Int {
+        if (layoutManager == null) return 0
+        return super.computeHorizontalScrollExtent()
+    }
+
+    override fun computeVerticalScrollOffset(): Int {
+        if (layoutManager == null) return 0
+        return super.computeVerticalScrollOffset()
+    }
+
+    override fun computeVerticalScrollExtent(): Int {
+        if (layoutManager == null) return 0
+        return super.computeVerticalScrollExtent()
+    }
+
+    override fun getContextMenuInfo(): ContextMenu.ContextMenuInfo? {
+        return contextMenuInfo
+    }
+
+    override fun showContextMenuForChild(originalView: View): Boolean {
+        if (originalView.parent !== this) {
+            return false
+        }
+        val position = getChildLayoutPosition(originalView)
+        if (position == RecyclerView.NO_POSITION) return false
+        contextMenuInfo = ContextMenuInfo(id, position)
+        return super.showContextMenuForChild(originalView)
+    }
+
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets {
+        if (fitsSystemWindows && usePaddingBackup) {
+            setPadding(paddingBackup.left + insets.systemWindowInsetLeft,
+                    paddingBackup.top + insets.systemWindowInsetTop,
+                    paddingBackup.right + insets.systemWindowInsetRight,
+                    paddingBackup.bottom + insets.systemWindowInsetBottom)
+            return insets.consumeSystemWindowInsets()
+        }
+        return super.onApplyWindowInsets(insets)
+    }
+
+    /**
+     * Ported from View.getVerticalScrollFactor.
+     */
+    private val scrollFactorBackport: Float
+            //listPreferredItemHeight is not defined, no generic scrolling
+        get() {
+            if (scrollFactor == java.lang.Float.MIN_VALUE) {
+                val outValue = TypedValue()
+                if (context.theme.resolveAttribute(
+                        android.R.attr.listPreferredItemHeight, outValue, true)) {
+                    scrollFactor = outValue.getDimension(
+                            context.resources.displayMetrics)
+                } else {
+                    return 0f
+                }
+
+            }
+            return scrollFactor
+        }
+
+    class ContextMenuInfo(val recyclerViewId: Int, val position: Int) : ContextMenu.ContextMenuInfo
+
+}
diff --git a/twidere/src/main/res/layout/activity_premium_dashboard.xml b/twidere/src/main/res/layout/activity_premium_dashboard.xml
index 387aacfab3..b18a396f3e 100644
--- a/twidere/src/main/res/layout/activity_premium_dashboard.xml
+++ b/twidere/src/main/res/layout/activity_premium_dashboard.xml
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.v7.widget.RecyclerView
-    android:id="@+id/recyclerView"
+<org.mariotaku.twidere.view.ExtendedRecyclerView
     xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/recyclerView"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:clipToPadding="false"
+    android:fitsSystemWindows="true"
     android:paddingBottom="@dimen/element_spacing_normal"
     android:paddingLeft="@dimen/activity_horizontal_margin"
     android:paddingRight="@dimen/activity_horizontal_margin"
