diff --git a/twidere/build.gradle b/twidere/build.gradle
index 0d69727007..d34ed1f077 100644
--- a/twidere/build.gradle
+++ b/twidere/build.gradle
@@ -21,8 +21,8 @@ android {
         applicationId "org.mariotaku.twidere"
         minSdkVersion 14
         targetSdkVersion 23
-        versionCode 149
-        versionName "3.0.5.1"
+        versionCode 150
+        versionName "3.0.5.2"
         multiDexEnabled true
 
         buildConfigField 'boolean', 'LEAK_CANARY_ENABLED', 'Boolean.parseBoolean("false")'
diff --git a/twidere/src/main/java/org/mariotaku/twidere/adapter/StaggeredGridParcelableStatusesAdapter.java b/twidere/src/main/java/org/mariotaku/twidere/adapter/StaggeredGridParcelableStatusesAdapter.java
index e5f38201bf..4ea143431f 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/adapter/StaggeredGridParcelableStatusesAdapter.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/adapter/StaggeredGridParcelableStatusesAdapter.java
@@ -32,7 +32,7 @@
 
 import org.mariotaku.twidere.R;
 import org.mariotaku.twidere.adapter.iface.IStatusesAdapter;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
 import org.mariotaku.twidere.model.ParcelableMedia;
 import org.mariotaku.twidere.model.ParcelableStatus;
 import org.mariotaku.twidere.model.util.ParcelableMediaUtils;
diff --git a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/AbsStatusesFragment.java b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/AbsStatusesFragment.java
index 19a0c66e46..fea7305658 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/AbsStatusesFragment.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/AbsStatusesFragment.java
@@ -47,7 +47,7 @@
 import org.mariotaku.twidere.adapter.iface.ILoadMoreSupportAdapter.IndicatorPosition;
 import org.mariotaku.twidere.adapter.iface.IStatusesAdapter.StatusAdapterListener;
 import org.mariotaku.twidere.annotation.ReadPositionTag;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
 import org.mariotaku.twidere.loader.iface.IExtendedLoader;
 import org.mariotaku.twidere.model.ParcelableMedia;
 import org.mariotaku.twidere.model.ParcelableStatus;
diff --git a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorActivitiesFragment.java b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorActivitiesFragment.java
index 47a550afe9..d3eb78c402 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorActivitiesFragment.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorActivitiesFragment.java
@@ -47,8 +47,7 @@
 import org.mariotaku.twidere.model.ParcelableActivity;
 import org.mariotaku.twidere.model.ParcelableActivityCursorIndices;
 import org.mariotaku.twidere.model.message.AccountChangedEvent;
-import org.mariotaku.twidere.model.message.FavoriteCreatedEvent;
-import org.mariotaku.twidere.model.message.FavoriteDestroyedEvent;
+import org.mariotaku.twidere.model.message.FavoriteTaskEvent;
 import org.mariotaku.twidere.model.message.GetActivitiesTaskEvent;
 import org.mariotaku.twidere.model.message.StatusDestroyedEvent;
 import org.mariotaku.twidere.model.message.StatusListChangedEvent;
@@ -275,11 +274,7 @@ public void notifyGetStatusesTaskChanged(GetActivitiesTaskEvent event) {
         }
 
         @Subscribe
-        public void notifyFavoriteCreated(FavoriteCreatedEvent event) {
-        }
-
-        @Subscribe
-        public void notifyFavoriteDestroyed(FavoriteDestroyedEvent event) {
+        public void notifyFavoriteTask(FavoriteTaskEvent event) {
         }
 
         @Subscribe
diff --git a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorStatusesFragment.java b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorStatusesFragment.java
index 8d5170ca81..63a1a419ed 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorStatusesFragment.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/CursorStatusesFragment.java
@@ -50,8 +50,7 @@
 import org.mariotaku.twidere.util.DataStoreUtils;
 import org.mariotaku.twidere.util.ErrorInfoStore;
 import org.mariotaku.twidere.model.message.AccountChangedEvent;
-import org.mariotaku.twidere.model.message.FavoriteCreatedEvent;
-import org.mariotaku.twidere.model.message.FavoriteDestroyedEvent;
+import org.mariotaku.twidere.model.message.FavoriteTaskEvent;
 import org.mariotaku.twidere.model.message.GetStatusesTaskEvent;
 import org.mariotaku.twidere.model.message.StatusDestroyedEvent;
 import org.mariotaku.twidere.model.message.StatusListChangedEvent;
@@ -136,12 +135,9 @@ public void notifyGetStatusesTaskChanged(GetStatusesTaskEvent event) {
         }
 
         @Subscribe
-        public void notifyFavoriteCreated(FavoriteCreatedEvent event) {
+        public void notifyFavoriteTask(FavoriteTaskEvent event) {
         }
 
-        @Subscribe
-        public void notifyFavoriteDestroyed(FavoriteDestroyedEvent event) {
-        }
 
         @Subscribe
         public void notifyStatusDestroyed(StatusDestroyedEvent event) {
diff --git a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/ParcelableStatusesFragment.java b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/ParcelableStatusesFragment.java
index bdc6cebf46..71a5d5a0f5 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/ParcelableStatusesFragment.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/ParcelableStatusesFragment.java
@@ -30,8 +30,7 @@
 import org.mariotaku.twidere.adapter.iface.ILoadMoreSupportAdapter.IndicatorPosition;
 import org.mariotaku.twidere.adapter.iface.IStatusesAdapter;
 import org.mariotaku.twidere.model.ParcelableStatus;
-import org.mariotaku.twidere.model.message.FavoriteCreatedEvent;
-import org.mariotaku.twidere.model.message.FavoriteDestroyedEvent;
+import org.mariotaku.twidere.model.message.FavoriteTaskEvent;
 import org.mariotaku.twidere.model.message.StatusDestroyedEvent;
 import org.mariotaku.twidere.model.message.StatusListChangedEvent;
 import org.mariotaku.twidere.model.message.StatusRetweetedEvent;
@@ -197,14 +196,12 @@ private void updateRetweetedStatuses(ParcelableStatus status) {
     protected class ParcelableStatusesBusCallback {
 
         @Subscribe
-        public void notifyFavoriteCreated(FavoriteCreatedEvent event) {
-            updateFavoritedStatus(event.status);
+        public void notifyFavoriteTask(FavoriteTaskEvent event) {
+            if (event.isSucceeded()) {
+                updateFavoritedStatus(event.getStatus());
+            }
         }
 
-        @Subscribe
-        public void notifyFavoriteDestroyed(FavoriteDestroyedEvent event) {
-            updateFavoritedStatus(event.status);
-        }
 
         @Subscribe
         public void notifyStatusDestroyed(StatusDestroyedEvent event) {
diff --git a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/StatusFragment.java b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/StatusFragment.java
index 49d6fc4292..be7149feac 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/fragment/support/StatusFragment.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/fragment/support/StatusFragment.java
@@ -110,8 +110,7 @@
 import org.mariotaku.twidere.model.ParcelableStatus;
 import org.mariotaku.twidere.model.ParcelableUser;
 import org.mariotaku.twidere.model.SingleResponse;
-import org.mariotaku.twidere.model.message.FavoriteCreatedEvent;
-import org.mariotaku.twidere.model.message.FavoriteDestroyedEvent;
+import org.mariotaku.twidere.model.message.FavoriteTaskEvent;
 import org.mariotaku.twidere.model.message.StatusListChangedEvent;
 import org.mariotaku.twidere.model.util.ParcelableMediaUtils;
 import org.mariotaku.twidere.provider.TwidereDataStore.Activities;
@@ -785,20 +784,21 @@ public void notifyStatusListChanged(StatusListChangedEvent event) {
     }
 
     @Subscribe
-    public void notifyFavoriteCreated(FavoriteCreatedEvent event) {
+    public void notifyFavoriteTask(FavoriteTaskEvent event) {
+        if (!event.isSucceeded()) return;
         final StatusAdapter adapter = getAdapter();
-        final ParcelableStatus status = adapter.findStatusById(event.status.account_id, event.status.id);
+        final ParcelableStatus status = adapter.findStatusById(event.getAccountId(), event.getStatusId());
         if (status != null) {
-            status.is_favorite = true;
-        }
-    }
-
-    @Subscribe
-    public void notifyFavoriteDestroyed(FavoriteDestroyedEvent event) {
-        final StatusAdapter adapter = getAdapter();
-        final ParcelableStatus status = adapter.findStatusById(event.status.account_id, event.status.id);
-        if (status != null) {
-            status.is_favorite = false;
+            switch (event.getAction()) {
+                case FavoriteTaskEvent.Action.CREATE: {
+                    status.is_favorite = true;
+                    break;
+                }
+                case FavoriteTaskEvent.Action.DESTROY: {
+                    status.is_favorite = false;
+                    break;
+                }
+            }
         }
     }
 
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/LikeAnimationDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/LikeAnimationDrawable.java
deleted file mode 100644
index c6c0b84ad9..0000000000
--- a/twidere/src/main/java/org/mariotaku/twidere/graphic/LikeAnimationDrawable.java
+++ /dev/null
@@ -1,857 +0,0 @@
-package org.mariotaku.twidere.graphic;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.animation.AnimatorSet;
-import android.animation.ArgbEvaluator;
-import android.animation.ObjectAnimator;
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.ColorFilter;
-import android.graphics.Paint;
-import android.graphics.PixelFormat;
-import android.graphics.PorterDuff;
-import android.graphics.Rect;
-import android.graphics.drawable.Animatable;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.IntDef;
-import android.support.v4.content.ContextCompat;
-import android.util.Property;
-import android.view.Gravity;
-import android.view.animation.AccelerateInterpolator;
-import android.view.animation.DecelerateInterpolator;
-
-import org.mariotaku.twidere.graphic.iface.DoNotWrapDrawable;
-
-import java.lang.ref.WeakReference;
-
-/**
- * Created by mariotaku on 15/11/4.
- */
-public class LikeAnimationDrawable extends Drawable implements Animatable, Drawable.Callback, DoNotWrapDrawable {
-
-    private static final Property<IconLayer, Float> ICON_SCALE = new Property<IconLayer, Float>(Float.class, "icon_scale") {
-        @Override
-        public void set(IconLayer object, Float value) {
-            object.setScale(value);
-        }
-
-        @Override
-        public boolean isReadOnly() {
-            return false;
-        }
-
-        @Override
-        public Float get(IconLayer object) {
-            return object.getScale();
-        }
-    };
-    private static final Property<Layer, Float> LAYER_PROGRESS = new Property<Layer, Float>(Float.class, "layer_progress") {
-        @Override
-        public void set(Layer object, Float value) {
-            object.setProgress(value);
-        }
-
-        @Override
-        public boolean isReadOnly() {
-            return false;
-        }
-
-        @Override
-        public Float get(Layer object) {
-            return object.getProgress();
-        }
-    };
-    private final int mDefaultColor, mLikeColor;
-    @Style
-    private final int mStyle;
-    private long mDuration = 500;
-
-    private AnimatorSet mCurrentAnimator;
-    private WeakReference<OnLikedListener> mListenerRef;
-
-    // Layers
-    private final AbsLayer mCircleLayer;
-    private final AbsLayer mParticleLayer;
-    private final IconLayer mIconLayer;
-
-    public LikeAnimationDrawable(final Context context, final int likeIcon, final int defaultColor,
-                                 final int likeColor, @Style final int style) {
-        mDefaultColor = defaultColor;
-        mLikeColor = likeColor;
-        mStyle = style;
-
-        mIconLayer = new IconLayer(ContextCompat.getDrawable(context, likeIcon));
-        mIconLayer.setColorFilter(defaultColor, PorterDuff.Mode.SRC_ATOP);
-        final Palette palette;
-        switch (style) {
-            case Style.FAVORITE: {
-                palette = new FavoritePalette();
-                mParticleLayer = new ShineLayer(mIconLayer.getIntrinsicWidth(),
-                        mIconLayer.getIntrinsicHeight(), palette);
-                break;
-            }
-            case Style.LIKE: {
-                palette = new LikePalette();
-                mParticleLayer = new ParticleLayer(mIconLayer.getIntrinsicWidth(),
-                        mIconLayer.getIntrinsicHeight(), palette);
-                break;
-            }
-            default: {
-                throw new IllegalArgumentException();
-            }
-        }
-        mParticleLayer.setProgress(-1);
-        mCircleLayer = new CircleLayer(mIconLayer.getIntrinsicWidth(), mIconLayer.getIntrinsicHeight(), palette);
-
-        mIconLayer.setCallback(this);
-        mParticleLayer.setCallback(this);
-        mCircleLayer.setCallback(this);
-    }
-
-    @Override
-    public void start() {
-        if (mCurrentAnimator != null) return;
-
-        final AnimatorSet animatorSet = new AnimatorSet();
-
-        final AbsLayer particleLayer = getParticleShineLayer();
-        final AbsLayer circleLayer = getCircleLayer();
-        final IconLayer iconLayer = mIconLayer;
-
-        switch (mStyle) {
-            case Style.LIKE: {
-                setupLikeAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
-                break;
-            }
-            case Style.FAVORITE: {
-                setupFavoriteAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
-                break;
-            }
-        }
-
-
-        animatorSet.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                resetState();
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {
-                mCurrentAnimator = null;
-            }
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                mCurrentAnimator = null;
-                if (mListenerRef == null) return;
-                final OnLikedListener listener = mListenerRef.get();
-                if (listener == null) return;
-                if (!listener.onLiked()) {
-                    resetState();
-                }
-            }
-
-            private void resetState() {
-                iconLayer.setColorFilter(mDefaultColor, PorterDuff.Mode.SRC_ATOP);
-                particleLayer.setProgress(-1);
-            }
-        });
-        animatorSet.start();
-        mCurrentAnimator = animatorSet;
-    }
-
-
-    private void setupFavoriteAnimation(final AnimatorSet animatorSet, final Layer particleLayer,
-                                        final Layer circleLayer, final IconLayer iconLayer) {
-        setupLikeAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
-    }
-
-    private void setupLikeAnimation(final AnimatorSet animatorSet, final Layer particleLayer,
-                                    final Layer circleLayer, final IconLayer iconLayer) {
-        final long scaleDownDuration = Math.round(1f / 24f * mDuration);
-        final long ovalExpandDuration = Math.round(4f / 24f * mDuration);
-        final long iconExpandOffset = Math.round(6f / 24f * mDuration);
-        final long iconExpandDuration = Math.round(8f / 24f * mDuration);
-        final long iconNormalDuration = Math.round(4f / 24f * mDuration);
-        final long particleExpandDuration = Math.round(12f / 24f * mDuration);
-        final long circleExplodeDuration = Math.round(5f / 24f * mDuration);
-
-        final ObjectAnimator iconScaleDown = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 1, 0);
-        iconScaleDown.setDuration(scaleDownDuration);
-        iconScaleDown.setInterpolator(new AccelerateInterpolator(2));
-        iconScaleDown.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                iconLayer.setColorFilter(mDefaultColor, PorterDuff.Mode.SRC_ATOP);
-            }
-
-        });
-
-        final ObjectAnimator ovalExpand = ObjectAnimator.ofFloat(circleLayer, LAYER_PROGRESS, 0, 0.5f);
-        ovalExpand.setDuration(ovalExpandDuration);
-
-
-        final ObjectAnimator iconExpand = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 0, 1.25f);
-        iconExpand.setDuration(iconExpandDuration);
-        iconExpand.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                iconLayer.setColorFilter(mLikeColor, PorterDuff.Mode.SRC_ATOP);
-            }
-
-        });
-
-        final ObjectAnimator particleExplode = ObjectAnimator.ofFloat(particleLayer, LAYER_PROGRESS, 0, 0.5f);
-        particleExplode.setDuration(iconExpandDuration);
-
-        final ObjectAnimator iconNormal = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 1.25f, 1);
-        iconNormal.setDuration(iconNormalDuration);
-        final ObjectAnimator circleExplode = ObjectAnimator.ofFloat(circleLayer, LAYER_PROGRESS, 0.5f, 0.95f, 0.95f, 1);
-        circleExplode.setDuration(circleExplodeDuration);
-        circleExplode.setInterpolator(new DecelerateInterpolator());
-
-
-        final ObjectAnimator particleFade = ObjectAnimator.ofFloat(particleLayer, LAYER_PROGRESS, 0.5f, 1);
-        particleFade.setDuration(particleExpandDuration);
-
-
-        animatorSet.play(iconScaleDown);
-        animatorSet.play(ovalExpand).after(iconScaleDown);
-        animatorSet.play(iconExpand).after(iconExpandOffset);
-        animatorSet.play(particleExplode).after(iconExpandOffset);
-        animatorSet.play(circleExplode).after(iconExpandOffset);
-
-        animatorSet.play(iconNormal).after(iconExpand);
-        animatorSet.play(particleFade).after(iconExpand);
-    }
-
-    private AbsLayer getCircleLayer() {
-        return mCircleLayer;
-    }
-
-    private AbsLayer getParticleShineLayer() {
-        return mParticleLayer;
-    }
-
-    @Override
-    public void stop() {
-        if (mCurrentAnimator == null) return;
-        mCurrentAnimator.cancel();
-    }
-
-
-    @Override
-    public boolean isRunning() {
-        return mCurrentAnimator != null && mCurrentAnimator.isRunning();
-    }
-
-    public long getDuration() {
-        return mDuration;
-    }
-
-    public void setDuration(long duration) {
-        mDuration = duration;
-    }
-
-    public void setOnLikedListener(OnLikedListener listener) {
-        mListenerRef = new WeakReference<>(listener);
-    }
-
-    @Override
-    public int getIntrinsicWidth() {
-        return mIconLayer.getIntrinsicWidth();
-    }
-
-    @Override
-    public int getIntrinsicHeight() {
-        return mIconLayer.getIntrinsicHeight();
-    }
-
-    @Override
-    public void draw(Canvas canvas) {
-        mCircleLayer.draw(canvas);
-        mParticleLayer.draw(canvas);
-        mIconLayer.draw(canvas);
-    }
-
-    @Override
-    public void setBounds(int left, int top, int right, int bottom) {
-        super.setBounds(left, top, right, bottom);
-        mCircleLayer.setBounds(left, top, right, bottom);
-        mParticleLayer.setBounds(left, top, right, bottom);
-        mIconLayer.setBounds(left, top, right, bottom);
-    }
-
-    @Override
-    public void setAlpha(int alpha) {
-        mIconLayer.setAlpha(alpha);
-    }
-
-    @Override
-    public void setColorFilter(ColorFilter colorFilter) {
-        mIconLayer.setColorFilter(colorFilter);
-    }
-
-    @Override
-    public int getOpacity() {
-        return PixelFormat.TRANSLUCENT;
-    }
-
-    @Override
-    public void invalidateDrawable(Drawable who) {
-        invalidateSelf();
-    }
-
-    @Override
-    public void scheduleDrawable(Drawable who, Runnable what, long when) {
-        scheduleSelf(what, when);
-    }
-
-    @Override
-    public void unscheduleDrawable(Drawable who, Runnable what) {
-        unscheduleSelf(what);
-    }
-
-    private interface Layer {
-
-        float getProgress();
-
-        void setProgress(float progress);
-    }
-
-    public interface OnLikedListener {
-        boolean onLiked();
-    }
-
-    public interface Palette {
-        int getParticleColor(int count, int index, float progress);
-
-        int getCircleColor(float progress);
-    }
-
-    @IntDef({Style.LIKE, Style.FAVORITE})
-    public @interface Style {
-        int LIKE = 1;
-        int FAVORITE = 2;
-    }
-
-    private static class ShineLayer extends AbsLayer {
-
-        private static final int PARTICLES_PIVOTS_COUNT = 5;
-
-        private final Paint mPaint;
-        private int mFullRadius;
-        private float mLineWidth;
-
-        public ShineLayer(final int intrinsicWidth, final int intrinsicHeight, final Palette palette) {
-            super(intrinsicWidth, intrinsicHeight, palette);
-            mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-            mPaint.setStrokeCap(Paint.Cap.ROUND);
-            setProgress(-1);
-        }
-
-        @Override
-        protected ConstantState createConstantState(final int intrinsicWidth,
-                                                    final int intrinsicHeight,
-                                                    final Palette palette) {
-            return new AbsLayerState() {
-                @Override
-                public Drawable newDrawable() {
-                    return new ShineLayer(intrinsicWidth, intrinsicHeight, palette);
-                }
-
-                @Override
-                public int getChangingConfigurations() {
-                    return ShineLayer.this.getChangingConfigurations();
-                }
-            };
-        }
-
-        @Override
-        public void draw(Canvas canvas) {
-            final float progress = getProgress();
-            if (progress < 0) return;
-            final int particleColor = palette.getParticleColor(0, 0, progress);
-            final Rect bounds = getBounds();
-            mPaint.setColor(particleColor);
-            mPaint.setStrokeWidth(mLineWidth);
-            final float[] startEnd = new float[2];
-            mPaint.setAlpha(0xFF);
-            if (progress < 0.25f) {
-                calcPhase1(startEnd, progress);
-            } else if (progress < 0.5f) {
-                calcPhase2(startEnd, progress);
-            } else if (progress < 0.75f) {
-                calcPhase3(startEnd, progress);
-            } else {
-                calcPhase4(startEnd, progress);
-                mPaint.setAlpha(Math.round(0xFF * (1 - (progress - 0.75f) * 4)));
-            }
-
-            for (int i = 0; i < PARTICLES_PIVOTS_COUNT; i++) {
-                final double degree = 360.0 / PARTICLES_PIVOTS_COUNT * i;
-                final double mainParticleAngle = Math.toRadians(degree + 18);
-                final float startX = (float) (bounds.centerX() + startEnd[0] * Math.cos(mainParticleAngle));
-                final float startY = (float) (bounds.centerY() + startEnd[0] * Math.sin(mainParticleAngle));
-                final float stopX = (float) (bounds.centerX() + startEnd[1] * Math.cos(mainParticleAngle));
-                final float stopY = (float) (bounds.centerY() + startEnd[1] * Math.sin(mainParticleAngle));
-                if (startEnd[1] - startEnd[0] <= 0) {
-                    canvas.drawPoint(startX, startY, mPaint);
-                } else {
-                    canvas.drawLine(startX, startY, stopX, stopY, mPaint);
-                }
-            }
-        }
-
-        private void calcPhase4(float[] startEnd, float progress) {
-            calcPhase3(startEnd, 0.75f);
-        }
-
-        private void calcPhase3(float[] startEnd, float progress) {
-            calcPhase2(startEnd, 0.5f);
-            final float length = (startEnd[1] - startEnd[0]) * (1 - (progress - 0.5f) * 4);
-            startEnd[0] = startEnd[1] - length;
-        }
-
-        private void calcPhase2(float[] startEnd, float progress) {
-            calcPhase1(startEnd, 0.25f);
-            final float length = startEnd[1] - startEnd[0];
-            final float initialStart = startEnd[0];
-            startEnd[0] = initialStart + mFullRadius / 3 * (progress - 0.25f) * 4;
-            startEnd[1] = startEnd[0] + length;
-        }
-
-        private void calcPhase1(float[] startEnd, float progress) {
-            // Start point: 1/4 of icon radius
-            startEnd[0] = mFullRadius / 3;
-            startEnd[1] = startEnd[0] + (mFullRadius / 4 * progress * 4);
-        }
-
-        @Override
-        protected void onBoundsChange(Rect bounds) {
-            super.onBoundsChange(bounds);
-            mFullRadius = Math.min(bounds.width(), bounds.height()) / 2;
-            mLineWidth = mFullRadius / 10f;
-        }
-
-    }
-
-    private static class ParticleLayer extends AbsLayer {
-
-        private static final int PARTICLES_PIVOTS_COUNT = 7;
-        private final Paint mPaint;
-        private float mFullRadius;
-        private float mParticleSize;
-
-        public ParticleLayer(final int intrinsicWidth, final int intrinsicHeight,
-                             final Palette palette) {
-            super(intrinsicWidth, intrinsicHeight, palette);
-
-            mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-            mPaint.setStyle(Paint.Style.FILL);
-            setProgress(-1);
-        }
-
-        @Override
-        protected ConstantState createConstantState(final int intrinsicWidth,
-                                                    final int intrinsicHeight,
-                                                    final Palette palette) {
-            return new AbsLayerState() {
-                @Override
-                public Drawable newDrawable() {
-                    return new ParticleLayer(intrinsicWidth, intrinsicHeight, palette);
-                }
-
-                @Override
-                public int getChangingConfigurations() {
-                    return ParticleLayer.this.getChangingConfigurations();
-                }
-            };
-        }
-
-        @Override
-        public void draw(final Canvas canvas) {
-            final float progress = getProgress();
-            if (progress < 0) return;
-            final Rect bounds = getBounds();
-            final float expandSpinProgress = Math.min(0.5f, progress);
-            final float currentRadius = mFullRadius + (mFullRadius * expandSpinProgress);
-            final float distance = mParticleSize + (mParticleSize * progress);
-            final float mainStrokeWidth, subStrokeWidth;
-            if (progress < 0.5) {
-                // Scale factor: [1, 0.5)
-                mainStrokeWidth = mParticleSize * (1 - progress);
-                // Scale factor: [1, 1.25)
-                subStrokeWidth = mParticleSize * (1 + progress / 2);
-            } else {
-                mainStrokeWidth = mParticleSize * (1 - progress);
-                subStrokeWidth = mParticleSize * 1.25f * (1 - (progress - 0.5f) * 2);
-            }
-
-            for (int i = 0; i < PARTICLES_PIVOTS_COUNT; i++) {
-                final double degree = 360.0 / PARTICLES_PIVOTS_COUNT * i;
-                final int color = palette.getParticleColor(PARTICLES_PIVOTS_COUNT, i, progress);
-
-                final double mainParticleAngle = Math.toRadians(degree - 115);
-                final float mainParticleX = (float) (bounds.centerX() + currentRadius * Math.cos(mainParticleAngle));
-                final float mainParticleY = (float) (bounds.centerY() + currentRadius * Math.sin(mainParticleAngle));
-
-                mPaint.setColor(color);
-                if (mainStrokeWidth > 0) {
-                    canvas.drawCircle(mainParticleX, mainParticleY, mainStrokeWidth / 2, mPaint);
-                }
-
-                final double particleAngle = Math.toRadians(90.0 * -expandSpinProgress + degree + 15);
-                final float subParticleX = (float) (mainParticleX + distance * Math.cos(particleAngle));
-                final float subParticleY = (float) (mainParticleY + distance * Math.sin(particleAngle));
-                mPaint.setAlpha(Math.round(255f * (1 - progress / 2f)));
-
-                if (subStrokeWidth > 0) {
-                    canvas.drawCircle(subParticleX, subParticleY, subStrokeWidth / 2, mPaint);
-                }
-            }
-
-        }
-
-        @Override
-        protected void onBoundsChange(Rect bounds) {
-            super.onBoundsChange(bounds);
-            mFullRadius = Math.min(bounds.width(), bounds.height()) / 2;
-            mParticleSize = mFullRadius / 4f;
-        }
-
-    }
-
-    private static class CircleLayer extends AbsLayer {
-        private final Paint mPaint;
-
-        private int mFullRadius;
-
-        public CircleLayer(final int intrinsicWidth, final int intrinsicHeight,
-                           final Palette palette) {
-            super(intrinsicWidth, intrinsicHeight, palette);
-            mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        }
-
-        @Override
-        protected ConstantState createConstantState(final int intrinsicWidth,
-                                                    final int intrinsicHeight,
-                                                    final Palette palette) {
-            return new AbsLayerState() {
-                @Override
-                public Drawable newDrawable() {
-                    return new CircleLayer(intrinsicWidth, intrinsicHeight, palette);
-                }
-
-                @Override
-                public int getChangingConfigurations() {
-                    return CircleLayer.this.getChangingConfigurations();
-                }
-            };
-        }
-
-        @Override
-        public void draw(final Canvas canvas) {
-            final float progress = getProgress();
-            final Rect bounds = getBounds();
-            final float radius;
-            if (progress < 0.5f) {
-                mPaint.setStyle(Paint.Style.FILL);
-                final float sizeProgress = Math.min(1, progress * 2);
-                radius = sizeProgress * mFullRadius;
-            } else {
-                mPaint.setStyle(Paint.Style.STROKE);
-                final float innerLeftRatio = 1 - (progress - 0.5f) * 2f;
-                final float strokeWidth = mFullRadius * innerLeftRatio;
-                mPaint.setStrokeWidth(strokeWidth);
-                radius = mFullRadius - strokeWidth / 2;
-                if (strokeWidth <= 0) return;
-            }
-            mPaint.setColor(palette.getCircleColor(progress));
-            canvas.drawCircle(bounds.centerX(), bounds.centerY(), radius, mPaint);
-        }
-
-        @Override
-        protected void onBoundsChange(Rect bounds) {
-            super.onBoundsChange(bounds);
-            mFullRadius = Math.min(bounds.width(), bounds.height()) / 2;
-        }
-
-    }
-
-    private static abstract class AbsLayer extends Drawable implements Layer {
-        protected final int intrinsicWidth;
-        protected final int intrinsicHeight;
-        protected final Palette palette;
-        private float mProgress;
-        private ConstantState mState;
-
-        public AbsLayer(final int intrinsicWidth, final int intrinsicHeight, final Palette palette) {
-            this.intrinsicWidth = intrinsicWidth;
-            this.intrinsicHeight = intrinsicHeight;
-            this.palette = palette;
-            mState = createConstantState(intrinsicWidth, intrinsicHeight, palette);
-        }
-
-        protected abstract ConstantState createConstantState(int intrinsicWidth, int intrinsicHeight, final Palette palette);
-
-        @Override
-        public void setAlpha(final int alpha) {
-
-        }
-
-        @Override
-        public final float getProgress() {
-            return mProgress;
-        }
-
-        @Override
-        public final void setProgress(float progress) {
-            mProgress = progress;
-            invalidateSelf();
-        }
-
-        @Override
-        public void setColorFilter(final ColorFilter colorFilter) {
-
-        }
-
-        @Override
-        public final int getIntrinsicHeight() {
-            return intrinsicHeight;
-        }
-
-        @Override
-        public final int getIntrinsicWidth() {
-            return intrinsicWidth;
-        }
-
-        @Override
-        public int getOpacity() {
-            return PixelFormat.TRANSLUCENT;
-        }
-
-        @Override
-        public ConstantState getConstantState() {
-            return mState;
-        }
-
-        static abstract class AbsLayerState extends ConstantState {
-
-        }
-    }
-
-    private static class FavoritePalette implements Palette {
-
-        private final ArgbEvaluator evaluator = new ArgbEvaluator();
-
-        @Override
-        public int getParticleColor(int count, int index, float progress) {
-            return (Integer) evaluator.evaluate(progress, 0xFFFF7020, 0xFFFD9050);
-        }
-
-        @Override
-        public int getCircleColor(float progress) {
-            return (Integer) evaluator.evaluate(progress, 0xFFFF9C00, 0xFFFFB024);
-        }
-    }
-
-    private static class LikePalette implements Palette {
-
-        private final ArgbEvaluator evaluator = new ArgbEvaluator();
-        private final float[] hsv = new float[3];
-
-        @Override
-        public int getParticleColor(int count, int index, float progress) {
-            final double degree = 360.0 / count * index;
-            hsv[0] = (float) degree;
-            hsv[1] = 0.4f;
-            hsv[2] = 1f;
-            return Color.HSVToColor(hsv);
-        }
-
-        @Override
-        public int getCircleColor(float progress) {
-            return (Integer) evaluator.evaluate(progress, 0xFFDE4689, 0xFFCD8FF5);
-        }
-    }
-
-    static class IconLayer extends Drawable implements Callback {
-        private final Drawable mDrawable;
-        private final Rect mTmpRect = new Rect();
-        private float mScale;
-        private boolean mMutated;
-        private ConstantState mState;
-
-        public IconLayer(Drawable drawable) {
-            if (drawable == null) throw new NullPointerException();
-            mState = new ScaleConstantState(drawable);
-            mDrawable = drawable;
-            drawable.setCallback(this);
-            setScale(1);
-        }
-
-        /**
-         * Returns the drawable scaled by this ScaleDrawable.
-         */
-        public Drawable getDrawable() {
-            return mDrawable;
-        }
-
-        // overrides from Drawable.Callback
-        @Override
-        public void invalidateDrawable(Drawable who) {
-            if (getCallback() != null) {
-                getCallback().invalidateDrawable(this);
-            }
-        }
-
-        @Override
-        public void scheduleDrawable(Drawable who, Runnable what, long when) {
-            if (getCallback() != null) {
-                getCallback().scheduleDrawable(this, what, when);
-            }
-        }
-
-        @Override
-        public void unscheduleDrawable(Drawable who, Runnable what) {
-            if (getCallback() != null) {
-                getCallback().unscheduleDrawable(this, what);
-            }
-        }
-
-        // overrides from Drawable
-        @Override
-        public void draw(Canvas canvas) {
-            if (mScale <= 0) return;
-            mDrawable.draw(canvas);
-        }
-
-        @Override
-        public int getChangingConfigurations() {
-            return super.getChangingConfigurations()
-                    | mDrawable.getChangingConfigurations();
-        }
-
-        @Override
-        public boolean getPadding(Rect padding) {
-            // XXX need to adjust padding!
-            return mDrawable.getPadding(padding);
-        }
-
-        @Override
-        public boolean setVisible(boolean visible, boolean restart) {
-            mDrawable.setVisible(visible, restart);
-            return super.setVisible(visible, restart);
-        }
-
-        @Override
-        public void setAlpha(int alpha) {
-            mDrawable.setAlpha(alpha);
-        }
-
-        @Override
-        public void setColorFilter(ColorFilter cf) {
-            mDrawable.setColorFilter(cf);
-        }
-
-        @Override
-        public int getOpacity() {
-            return mDrawable.getOpacity();
-        }
-
-        @Override
-        public boolean isStateful() {
-            return mDrawable.isStateful();
-        }
-
-        @Override
-        protected boolean onStateChange(int[] state) {
-            boolean changed = mDrawable.setState(state);
-            onBoundsChange(getBounds());
-            return changed;
-        }
-
-        @Override
-        protected boolean onLevelChange(int level) {
-            mDrawable.setLevel(level);
-            onBoundsChange(getBounds());
-            invalidateSelf();
-            return true;
-        }
-
-        @Override
-        protected void onBoundsChange(Rect bounds) {
-            updateBounds(bounds);
-        }
-
-        @Override
-        public int getIntrinsicWidth() {
-            return mDrawable.getIntrinsicWidth();
-        }
-
-        @Override
-        public int getIntrinsicHeight() {
-            return mDrawable.getIntrinsicHeight();
-        }
-
-        @Override
-        public Drawable mutate() {
-            if (!mMutated && super.mutate() == this) {
-                mDrawable.mutate();
-                mMutated = true;
-            }
-            return this;
-        }
-
-        public float getScale() {
-            return mScale;
-        }
-
-        public void setScale(float scale) {
-            mScale = scale;
-            updateBounds(getBounds());
-        }
-
-        @Override
-        public ConstantState getConstantState() {
-            return mState;
-        }
-
-
-        static class ScaleConstantState extends ConstantState {
-
-            private final Drawable mIcon;
-
-            public ScaleConstantState(Drawable icon) {
-                mIcon = icon;
-            }
-
-            @Override
-            public Drawable newDrawable() {
-                return new IconLayer(mIcon.mutate());
-            }
-
-            @Override
-            public int getChangingConfigurations() {
-                return mIcon.getChangingConfigurations();
-            }
-        }
-
-        private void updateBounds(Rect bounds) {
-            final Rect r = mTmpRect;
-            final int w = Math.round(mDrawable.getIntrinsicWidth() * mScale);
-            final int h = Math.round(mDrawable.getIntrinsicHeight() * mScale);
-            Gravity.apply(Gravity.CENTER, w, h, bounds, r);
-
-            if (w > 0 && h > 0) {
-                mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
-            }
-            invalidateSelf();
-        }
-
-    }
-}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/LikeAnimationDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/LikeAnimationDrawable.java
new file mode 100644
index 0000000000..b54c124a14
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/LikeAnimationDrawable.java
@@ -0,0 +1,386 @@
+package org.mariotaku.twidere.graphic.like;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ObjectAnimator;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.PixelFormat;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.IntDef;
+import android.support.v4.content.ContextCompat;
+import android.util.Property;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
+
+import org.mariotaku.twidere.graphic.iface.DoNotWrapDrawable;
+import org.mariotaku.twidere.graphic.like.layer.AnimationLayerDrawable;
+import org.mariotaku.twidere.graphic.like.layer.CircleLayerDrawable;
+import org.mariotaku.twidere.graphic.like.layer.IconLayerDrawable;
+import org.mariotaku.twidere.graphic.like.layer.Layer;
+import org.mariotaku.twidere.graphic.like.layer.ParticleLayerDrawable;
+import org.mariotaku.twidere.graphic.like.layer.ShineLayerDrawable;
+import org.mariotaku.twidere.graphic.like.palette.FavoritePalette;
+import org.mariotaku.twidere.graphic.like.palette.LikePalette;
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Created by mariotaku on 15/11/4.
+ */
+public class LikeAnimationDrawable extends Drawable implements Animatable, Drawable.Callback, DoNotWrapDrawable {
+
+    private static final Property<IconLayerDrawable, Float> ICON_SCALE = new Property<IconLayerDrawable, Float>(Float.class, "icon_scale") {
+        @Override
+        public void set(IconLayerDrawable object, Float value) {
+            object.setScale(value);
+        }
+
+        @Override
+        public boolean isReadOnly() {
+            return false;
+        }
+
+        @Override
+        public Float get(IconLayerDrawable object) {
+            return object.getScale();
+        }
+    };
+    private static final Property<Layer, Float> LAYER_PROGRESS = new Property<Layer, Float>(Float.class, "layer_progress") {
+        @Override
+        public void set(Layer object, Float value) {
+            object.setProgress(value);
+        }
+
+        @Override
+        public boolean isReadOnly() {
+            return false;
+        }
+
+        @Override
+        public Float get(Layer object) {
+            return object.getProgress();
+        }
+    };
+
+    private LikeAnimationState mState;
+    private boolean mMutated;
+
+    public LikeAnimationDrawable(final Context context, final int likeIcon, final int defaultColor,
+                                 final int likeColor, @Style final int style) {
+        mState = new LikeAnimationState(context, likeIcon, defaultColor, likeColor, style, this);
+    }
+
+
+    public LikeAnimationDrawable(LikeAnimationState state) {
+        mState = state;
+    }
+
+    @Override
+    public void start() {
+        if (mState.mCurrentAnimator != null) return;
+
+        final AnimatorSet animatorSet = new AnimatorSet();
+
+        final AnimationLayerDrawable particleLayer = mState.mParticleLayer;
+        final AnimationLayerDrawable circleLayer = mState.mCircleLayer;
+        final IconLayerDrawable iconLayer = mState.mIconLayer;
+
+        switch (mState.mStyle) {
+            case Style.LIKE: {
+                setupLikeAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
+                break;
+            }
+            case Style.FAVORITE: {
+                setupFavoriteAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
+                break;
+            }
+        }
+
+
+        animatorSet.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                resetState();
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                mState.mCurrentAnimator = null;
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                mState.mCurrentAnimator = null;
+                if (mState.mListenerRef == null) return;
+                final OnLikedListener listener = mState.mListenerRef.get();
+                if (listener == null) return;
+                if (!listener.onLiked()) {
+                    resetState();
+                }
+            }
+
+            private void resetState() {
+                iconLayer.setColorFilter(mState.mDefaultColor, PorterDuff.Mode.SRC_ATOP);
+                particleLayer.setProgress(-1);
+            }
+        });
+        animatorSet.start();
+        mState.mCurrentAnimator = animatorSet;
+    }
+
+    private void setupFavoriteAnimation(final AnimatorSet animatorSet, final Layer particleLayer,
+                                        final Layer circleLayer, final IconLayerDrawable iconLayer) {
+        setupLikeAnimation(animatorSet, particleLayer, circleLayer, iconLayer);
+    }
+
+    private void setupLikeAnimation(final AnimatorSet animatorSet, final Layer particleLayer,
+                                    final Layer circleLayer, final IconLayerDrawable iconLayer) {
+        final long duration = mState.mDuration;
+        final long scaleDownDuration = Math.round(1f / 24f * duration);
+        final long ovalExpandDuration = Math.round(4f / 24f * duration);
+        final long iconExpandOffset = Math.round(6f / 24f * duration);
+        final long iconExpandDuration = Math.round(8f / 24f * duration);
+        final long iconNormalDuration = Math.round(4f / 24f * duration);
+        final long particleExpandDuration = Math.round(12f / 24f * duration);
+        final long circleExplodeDuration = Math.round(5f / 24f * duration);
+
+        final ObjectAnimator iconScaleDown = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 1, 0);
+        iconScaleDown.setDuration(scaleDownDuration);
+        iconScaleDown.setInterpolator(new AccelerateInterpolator(2));
+        iconScaleDown.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                iconLayer.setColorFilter(mState.mDefaultColor, PorterDuff.Mode.SRC_ATOP);
+            }
+
+        });
+
+        final ObjectAnimator ovalExpand = ObjectAnimator.ofFloat(circleLayer, LAYER_PROGRESS, 0, 0.5f);
+        ovalExpand.setDuration(ovalExpandDuration);
+
+
+        final ObjectAnimator iconExpand = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 0, 1.25f);
+        iconExpand.setDuration(iconExpandDuration);
+        iconExpand.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                iconLayer.setColorFilter(mState.mLikeColor, PorterDuff.Mode.SRC_ATOP);
+            }
+
+        });
+
+        final ObjectAnimator particleExplode = ObjectAnimator.ofFloat(particleLayer, LAYER_PROGRESS, 0, 0.5f);
+        particleExplode.setDuration(iconExpandDuration);
+
+        final ObjectAnimator iconNormal = ObjectAnimator.ofFloat(iconLayer, ICON_SCALE, 1.25f, 1);
+        iconNormal.setDuration(iconNormalDuration);
+        final ObjectAnimator circleExplode = ObjectAnimator.ofFloat(circleLayer, LAYER_PROGRESS, 0.5f, 0.95f, 0.95f, 1);
+        circleExplode.setDuration(circleExplodeDuration);
+        circleExplode.setInterpolator(new DecelerateInterpolator());
+
+
+        final ObjectAnimator particleFade = ObjectAnimator.ofFloat(particleLayer, LAYER_PROGRESS, 0.5f, 1);
+        particleFade.setDuration(particleExpandDuration);
+
+
+        animatorSet.play(iconScaleDown);
+        animatorSet.play(ovalExpand).after(iconScaleDown);
+        animatorSet.play(iconExpand).after(iconExpandOffset);
+        animatorSet.play(particleExplode).after(iconExpandOffset);
+        animatorSet.play(circleExplode).after(iconExpandOffset);
+
+        animatorSet.play(iconNormal).after(iconExpand);
+        animatorSet.play(particleFade).after(iconExpand);
+    }
+
+    @Override
+    public void stop() {
+        if (mState.mCurrentAnimator == null) return;
+        mState.mCurrentAnimator.cancel();
+    }
+
+    @Override
+    public boolean isRunning() {
+        return mState.mCurrentAnimator != null && mState.mCurrentAnimator.isRunning();
+    }
+
+    public long getDuration() {
+        return mState.mDuration;
+    }
+
+    public void setDuration(long duration) {
+        mState.mDuration = duration;
+    }
+
+    public void setOnLikedListener(OnLikedListener listener) {
+        mState.mListenerRef = new WeakReference<>(listener);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mState.mIconLayer.getIntrinsicWidth();
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mState.mIconLayer.getIntrinsicHeight();
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        mState.mCircleLayer.draw(canvas);
+        mState.mParticleLayer.draw(canvas);
+        mState.mIconLayer.draw(canvas);
+    }
+
+    @Override
+    public void setBounds(int left, int top, int right, int bottom) {
+        super.setBounds(left, top, right, bottom);
+        mState.setBounds(left, top, right, bottom);
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mState.mIconLayer.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+        mState.mIconLayer.setColorFilter(colorFilter);
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    @Override
+    public void invalidateDrawable(Drawable who) {
+        invalidateSelf();
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        scheduleSelf(what, when);
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        unscheduleSelf(what);
+    }
+
+    @Override
+    public ConstantState getConstantState() {
+        return mState;
+    }
+
+    @Override
+    public Drawable mutate() {
+        if (!mMutated && super.mutate() == this) {
+            mState = new LikeAnimationState(mState, this);
+            mMutated = true;
+        }
+        return this;
+    }
+
+    public interface OnLikedListener {
+        boolean onLiked();
+    }
+
+    @IntDef({Style.LIKE, Style.FAVORITE})
+    public @interface Style {
+        int LIKE = 1;
+        int FAVORITE = 2;
+    }
+
+    static class LikeAnimationState extends ConstantState {
+
+        // Default values
+        private final int mDefaultColor;
+        private final int mLikeColor;
+        @Style
+        private final int mStyle;
+        // Layers
+        private final AnimationLayerDrawable mCircleLayer;
+        private final AnimationLayerDrawable mParticleLayer;
+        private final IconLayerDrawable mIconLayer;
+
+        private long mDuration = 500;
+
+        private AnimatorSet mCurrentAnimator;
+        private WeakReference<OnLikedListener> mListenerRef;
+
+        public LikeAnimationState(final Context context, final int likeIcon, final int defaultColor,
+                                  final int likeColor, @Style final int style, Callback callback) {
+            mDefaultColor = defaultColor;
+            mLikeColor = likeColor;
+            mStyle = style;
+
+            mIconLayer = new IconLayerDrawable(ContextCompat.getDrawable(context, likeIcon));
+            mIconLayer.setColorFilter(defaultColor, PorterDuff.Mode.SRC_ATOP);
+            final Palette palette;
+            switch (style) {
+                case Style.FAVORITE: {
+                    palette = new FavoritePalette();
+                    mParticleLayer = new ShineLayerDrawable(mIconLayer.getIntrinsicWidth(),
+                            mIconLayer.getIntrinsicHeight(), palette);
+                    break;
+                }
+                case Style.LIKE: {
+                    palette = new LikePalette();
+                    mParticleLayer = new ParticleLayerDrawable(mIconLayer.getIntrinsicWidth(),
+                            mIconLayer.getIntrinsicHeight(), palette);
+                    break;
+                }
+                default: {
+                    throw new IllegalArgumentException();
+                }
+            }
+            mParticleLayer.setProgress(-1);
+            mCircleLayer = new CircleLayerDrawable(mIconLayer.getIntrinsicWidth(), mIconLayer.getIntrinsicHeight(), palette);
+
+            mIconLayer.setCallback(callback);
+            mParticleLayer.setCallback(callback);
+            mCircleLayer.setCallback(callback);
+        }
+
+        public LikeAnimationState(LikeAnimationState state, LikeAnimationDrawable owner) {
+            mDefaultColor = state.mDefaultColor;
+            mLikeColor = state.mLikeColor;
+            mStyle = state.mStyle;
+            mCircleLayer = (AnimationLayerDrawable) clone(state.mCircleLayer, owner);
+            mParticleLayer = (AnimationLayerDrawable) clone(state.mParticleLayer, owner);
+            mIconLayer = (IconLayerDrawable) clone(state.mIconLayer, owner);
+        }
+
+        private Drawable clone(Drawable orig, LikeAnimationDrawable owner) {
+            final Drawable clone = orig.getConstantState().newDrawable();
+            clone.setCallback(owner);
+            clone.setBounds(orig.getBounds());
+            return clone;
+        }
+
+        public void setBounds(int left, int top, int right, int bottom) {
+            mCircleLayer.setBounds(left, top, right, bottom);
+            mParticleLayer.setBounds(left, top, right, bottom);
+            mIconLayer.setBounds(left, top, right, bottom);
+        }
+
+        @Override
+        public Drawable newDrawable() {
+            return new LikeAnimationDrawable(this);
+        }
+
+        @Override
+        public int getChangingConfigurations() {
+            return 0;
+        }
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/AnimationLayerDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/AnimationLayerDrawable.java
new file mode 100644
index 0000000000..2d2bacfe93
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/AnimationLayerDrawable.java
@@ -0,0 +1,75 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+import android.graphics.ColorFilter;
+import android.graphics.PixelFormat;
+import android.graphics.drawable.Drawable;
+
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+import org.mariotaku.twidere.graphic.like.state.AbsLayerState;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public abstract class AnimationLayerDrawable<S extends AbsLayerState> extends Drawable implements Layer {
+
+    protected S mState;
+    private boolean mMutated;
+
+    public AnimationLayerDrawable(final int intrinsicWidth, final int intrinsicHeight, final Palette palette) {
+        mState = createConstantState(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    protected abstract S createConstantState(int intrinsicWidth, int intrinsicHeight, final Palette palette);
+
+    @Override
+    public void setAlpha(final int alpha) {
+
+    }
+
+    @Override
+    public final float getProgress() {
+        return mState.getProgress();
+    }
+
+    @Override
+    public final void setProgress(float progress) {
+        mState.setProgress(progress);
+        invalidateSelf();
+    }
+
+    @Override
+    public void setColorFilter(final ColorFilter colorFilter) {
+
+    }
+
+    @Override
+    public final int getIntrinsicHeight() {
+        return mState.getIntrinsicHeight();
+    }
+
+    @Override
+    public final int getIntrinsicWidth() {
+        return mState.getIntrinsicWidth();
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    @Override
+    public ConstantState getConstantState() {
+        return mState;
+    }
+
+    @Override
+    public Drawable mutate() {
+        if (!mMutated && super.mutate() == this) {
+            mState = createConstantState(mState.getIntrinsicWidth(), mState.getIntrinsicHeight(),
+                    mState.getPalette());
+            mMutated = true;
+        }
+        return this;
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/CircleLayerDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/CircleLayerDrawable.java
new file mode 100644
index 0000000000..26d5e57c62
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/CircleLayerDrawable.java
@@ -0,0 +1,56 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+import org.mariotaku.twidere.graphic.like.state.CircleState;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class CircleLayerDrawable extends AnimationLayerDrawable<CircleState> {
+
+    public CircleLayerDrawable(final int intrinsicWidth, final int intrinsicHeight,
+                               final Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    protected CircleState createConstantState(final int intrinsicWidth,
+                                              final int intrinsicHeight,
+                                              final Palette palette) {
+        return new CircleState(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        final float progress = getProgress();
+        final Rect bounds = getBounds();
+        final float radius;
+        final Paint paint = mState.getPaint();
+        final int fullRadius = mState.getFullRadius();
+        if (progress < 0.5f) {
+            paint.setStyle(Paint.Style.FILL);
+            final float sizeProgress = Math.min(1, progress * 2);
+            radius = sizeProgress * fullRadius;
+        } else {
+            paint.setStyle(Paint.Style.STROKE);
+            final float innerLeftRatio = 1 - (progress - 0.5f) * 2f;
+            final float strokeWidth = fullRadius * innerLeftRatio;
+            paint.setStrokeWidth(strokeWidth);
+            radius = fullRadius - strokeWidth / 2;
+            if (strokeWidth <= 0) return;
+        }
+        paint.setColor(mState.getPalette().getCircleColor(progress));
+        canvas.drawCircle(bounds.centerX(), bounds.centerY(), radius, paint);
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        mState.setFullRadius(Math.min(bounds.width(), bounds.height()) / 2);
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/IconLayerDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/IconLayerDrawable.java
new file mode 100644
index 0000000000..49a55115c8
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/IconLayerDrawable.java
@@ -0,0 +1,195 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.view.Gravity;
+
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class IconLayerDrawable extends Drawable implements Drawable.Callback {
+    private final Drawable mDrawable;
+    private final Rect mTmpRect = new Rect();
+    private boolean mMutated;
+    private ScaleConstantState mState;
+
+    public IconLayerDrawable(Drawable drawable) {
+        if (drawable == null) throw new NullPointerException();
+        mState = new ScaleConstantState(drawable);
+        mDrawable = drawable;
+        drawable.setCallback(this);
+        setScale(1);
+    }
+
+    /**
+     * Returns the drawable scaled by this ScaleDrawable.
+     */
+    public Drawable getDrawable() {
+        return mDrawable;
+    }
+
+    // overrides from Drawable.Callback
+    @Override
+    public void invalidateDrawable(Drawable who) {
+        if (getCallback() != null) {
+            getCallback().invalidateDrawable(this);
+        }
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        if (getCallback() != null) {
+            getCallback().scheduleDrawable(this, what, when);
+        }
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        if (getCallback() != null) {
+            getCallback().unscheduleDrawable(this, what);
+        }
+    }
+
+    // overrides from Drawable
+    @Override
+    public void draw(Canvas canvas) {
+        if (mState.getScale() <= 0) return;
+        mDrawable.draw(canvas);
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+        return super.getChangingConfigurations()
+                | mDrawable.getChangingConfigurations();
+    }
+
+    @Override
+    public boolean getPadding(Rect padding) {
+        // XXX need to adjust padding!
+        return mDrawable.getPadding(padding);
+    }
+
+    @Override
+    public boolean setVisible(boolean visible, boolean restart) {
+        mDrawable.setVisible(visible, restart);
+        return super.setVisible(visible, restart);
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mDrawable.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mDrawable.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return mDrawable.getOpacity();
+    }
+
+    @Override
+    public boolean isStateful() {
+        return mDrawable.isStateful();
+    }
+
+    @Override
+    protected boolean onStateChange(int[] state) {
+        boolean changed = mDrawable.setState(state);
+        onBoundsChange(getBounds());
+        return changed;
+    }
+
+    @Override
+    protected boolean onLevelChange(int level) {
+        mDrawable.setLevel(level);
+        onBoundsChange(getBounds());
+        invalidateSelf();
+        return true;
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        updateBounds(bounds);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mDrawable.getIntrinsicWidth();
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mDrawable.getIntrinsicHeight();
+    }
+
+    @Override
+    public Drawable mutate() {
+        if (!mMutated && super.mutate() == this) {
+            mDrawable.mutate();
+            mMutated = true;
+        }
+        return this;
+    }
+
+    public float getScale() {
+        return mState.getScale();
+    }
+
+    public void setScale(float scale) {
+        mState.setScale(scale);
+        updateBounds(getBounds());
+    }
+
+    @Override
+    public ConstantState getConstantState() {
+        return mState;
+    }
+
+    static class ScaleConstantState extends ConstantState {
+
+        private final Drawable mIcon;
+        private float mScale;
+
+        public ScaleConstantState(Drawable icon) {
+            mIcon = icon;
+        }
+
+        @Override
+        public Drawable newDrawable() {
+            return new IconLayerDrawable(mIcon.mutate());
+        }
+
+        @Override
+        public int getChangingConfigurations() {
+            return mIcon.getChangingConfigurations();
+        }
+
+        public void setScale(float scale) {
+            mScale = scale;
+        }
+
+        public float getScale() {
+            return mScale;
+        }
+    }
+
+    private void updateBounds(Rect bounds) {
+        final Rect r = mTmpRect;
+        final int w = Math.round(mDrawable.getIntrinsicWidth() * mState.getScale());
+        final int h = Math.round(mDrawable.getIntrinsicHeight() * mState.getScale());
+        Gravity.apply(Gravity.CENTER, w, h, bounds, r);
+
+        if (w > 0 && h > 0) {
+            mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
+        }
+        invalidateSelf();
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/Layer.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/Layer.java
new file mode 100644
index 0000000000..9712474785
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/Layer.java
@@ -0,0 +1,11 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public interface Layer {
+
+    float getProgress();
+
+    void setProgress(float progress);
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ParticleLayerDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ParticleLayerDrawable.java
new file mode 100644
index 0000000000..e6ebed36c3
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ParticleLayerDrawable.java
@@ -0,0 +1,83 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+import org.mariotaku.twidere.graphic.like.state.ParticleLayerState;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class ParticleLayerDrawable extends AnimationLayerDrawable<ParticleLayerState> {
+
+    private static final int PARTICLES_PIVOTS_COUNT = 7;
+
+    public ParticleLayerDrawable(final int intrinsicWidth, final int intrinsicHeight,
+                                 final Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    protected ParticleLayerState createConstantState(final int intrinsicWidth,
+                                                     final int intrinsicHeight,
+                                                     final Palette palette) {
+        return new ParticleLayerState(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        final float progress = getProgress();
+        if (progress < 0) return;
+        final Rect bounds = getBounds();
+        final float expandSpinProgress = Math.min(0.5f, progress);
+        final float fullRadius = mState.getFullRadius();
+        final float currentRadius = fullRadius + (fullRadius * expandSpinProgress);
+        final float particleSize = mState.getParticleSize();
+        final float distance = particleSize + (particleSize * progress);
+        final float mainStrokeWidth, subStrokeWidth;
+        if (progress < 0.5) {
+            // Scale factor: [1, 0.5)
+            mainStrokeWidth = particleSize * (1 - progress);
+            // Scale factor: [1, 1.25)
+            subStrokeWidth = particleSize * (1 + progress / 2);
+        } else {
+            mainStrokeWidth = particleSize * (1 - progress);
+            subStrokeWidth = particleSize * 1.25f * (1 - (progress - 0.5f) * 2);
+        }
+
+        for (int i = 0; i < PARTICLES_PIVOTS_COUNT; i++) {
+            final double degree = 360.0 / PARTICLES_PIVOTS_COUNT * i;
+            final Palette palette = mState.getPalette();
+            final int color = palette.getParticleColor(PARTICLES_PIVOTS_COUNT, i, progress);
+
+            final double mainParticleAngle = Math.toRadians(degree - 115);
+            final float mainParticleX = (float) (bounds.centerX() + currentRadius * Math.cos(mainParticleAngle));
+            final float mainParticleY = (float) (bounds.centerY() + currentRadius * Math.sin(mainParticleAngle));
+
+            final Paint paint = mState.getPaint();
+            paint.setColor(color);
+            if (mainStrokeWidth > 0) {
+                canvas.drawCircle(mainParticleX, mainParticleY, mainStrokeWidth / 2, paint);
+            }
+
+            final double particleAngle = Math.toRadians(90.0 * -expandSpinProgress + degree + 15);
+            final float subParticleX = (float) (mainParticleX + distance * Math.cos(particleAngle));
+            final float subParticleY = (float) (mainParticleY + distance * Math.sin(particleAngle));
+            paint.setAlpha(Math.round(255f * (1 - progress / 2f)));
+
+            if (subStrokeWidth > 0) {
+                canvas.drawCircle(subParticleX, subParticleY, subStrokeWidth / 2, paint);
+            }
+        }
+
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        mState.setFullRadius(Math.min(bounds.width(), bounds.height()) / 2);
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ShineLayerDrawable.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ShineLayerDrawable.java
new file mode 100644
index 0000000000..1f1983642e
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/layer/ShineLayerDrawable.java
@@ -0,0 +1,98 @@
+package org.mariotaku.twidere.graphic.like.layer;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+import org.mariotaku.twidere.graphic.like.state.ShineLayerState;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class ShineLayerDrawable extends AnimationLayerDrawable<ShineLayerState> {
+
+    private static final int PARTICLES_PIVOTS_COUNT = 5;
+
+    public ShineLayerDrawable(final int intrinsicWidth, final int intrinsicHeight, final Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    protected ShineLayerState createConstantState(final int intrinsicWidth,
+                                                  final int intrinsicHeight,
+                                                  final Palette palette) {
+        return new ShineLayerState(intrinsicWidth, intrinsicHeight, palette);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        final float progress = getProgress();
+        if (progress < 0) return;
+        final Palette palette = mState.getPalette();
+        final int particleColor = palette.getParticleColor(0, 0, progress);
+        final Rect bounds = getBounds();
+        final Paint paint = mState.getPaint();
+        paint.setColor(particleColor);
+        paint.setStrokeWidth(mState.getLineWidth());
+        final float[] startEnd = new float[2];
+        paint.setAlpha(0xFF);
+        if (progress < 0.25f) {
+            calcPhase1(startEnd, progress);
+        } else if (progress < 0.5f) {
+            calcPhase2(startEnd, progress);
+        } else if (progress < 0.75f) {
+            calcPhase3(startEnd, progress);
+        } else {
+            calcPhase4(startEnd, progress);
+            paint.setAlpha(Math.round(0xFF * (1 - (progress - 0.75f) * 4)));
+        }
+
+        for (int i = 0; i < PARTICLES_PIVOTS_COUNT; i++) {
+            final double degree = 360.0 / PARTICLES_PIVOTS_COUNT * i;
+            final double mainParticleAngle = Math.toRadians(degree + 18);
+            final float startX = (float) (bounds.centerX() + startEnd[0] * Math.cos(mainParticleAngle));
+            final float startY = (float) (bounds.centerY() + startEnd[0] * Math.sin(mainParticleAngle));
+            final float stopX = (float) (bounds.centerX() + startEnd[1] * Math.cos(mainParticleAngle));
+            final float stopY = (float) (bounds.centerY() + startEnd[1] * Math.sin(mainParticleAngle));
+            if (startEnd[1] - startEnd[0] <= 0) {
+                canvas.drawPoint(startX, startY, paint);
+            } else {
+                canvas.drawLine(startX, startY, stopX, stopY, paint);
+            }
+        }
+    }
+
+    private void calcPhase4(float[] startEnd, float progress) {
+        calcPhase3(startEnd, 0.75f);
+    }
+
+    private void calcPhase3(float[] startEnd, float progress) {
+        calcPhase2(startEnd, 0.5f);
+        final float length = (startEnd[1] - startEnd[0]) * (1 - (progress - 0.5f) * 4);
+        startEnd[0] = startEnd[1] - length;
+    }
+
+    private void calcPhase2(float[] startEnd, float progress) {
+        calcPhase1(startEnd, 0.25f);
+        final float length = startEnd[1] - startEnd[0];
+        final float initialStart = startEnd[0];
+        startEnd[0] = initialStart + mState.getFullRadius() / 3 * (progress - 0.25f) * 4;
+        startEnd[1] = startEnd[0] + length;
+    }
+
+    private void calcPhase1(float[] startEnd, float progress) {
+        // Start point: 1/4 of icon radius
+        final int fullRadius = mState.getFullRadius();
+        startEnd[0] = fullRadius / 3;
+        startEnd[1] = startEnd[0] + (fullRadius / 4 * progress * 4);
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        final int fullRadius = Math.min(bounds.width(), bounds.height()) / 2;
+        mState.setFullRadius(fullRadius);
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/FavoritePalette.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/FavoritePalette.java
new file mode 100644
index 0000000000..bec2cdc751
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/FavoritePalette.java
@@ -0,0 +1,21 @@
+package org.mariotaku.twidere.graphic.like.palette;
+
+import android.animation.ArgbEvaluator;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public final class FavoritePalette implements Palette {
+
+    private final ArgbEvaluator evaluator = new ArgbEvaluator();
+
+    @Override
+    public int getParticleColor(int count, int index, float progress) {
+        return (Integer) evaluator.evaluate(progress, 0xFFFF7020, 0xFFFD9050);
+    }
+
+    @Override
+    public int getCircleColor(float progress) {
+        return (Integer) evaluator.evaluate(progress, 0xFFFF9C00, 0xFFFFB024);
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/LikePalette.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/LikePalette.java
new file mode 100644
index 0000000000..fd2d7aff3c
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/LikePalette.java
@@ -0,0 +1,27 @@
+package org.mariotaku.twidere.graphic.like.palette;
+
+import android.animation.ArgbEvaluator;
+import android.graphics.Color;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public final class LikePalette implements Palette {
+
+    private final ArgbEvaluator evaluator = new ArgbEvaluator();
+    private final float[] hsv = new float[3];
+
+    @Override
+    public int getParticleColor(int count, int index, float progress) {
+        final double degree = 360.0 / count * index;
+        hsv[0] = (float) degree;
+        hsv[1] = 0.4f;
+        hsv[2] = 1f;
+        return Color.HSVToColor(hsv);
+    }
+
+    @Override
+    public int getCircleColor(float progress) {
+        return (Integer) evaluator.evaluate(progress, 0xFFDE4689, 0xFFCD8FF5);
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/Palette.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/Palette.java
new file mode 100644
index 0000000000..b609be5e2c
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/palette/Palette.java
@@ -0,0 +1,10 @@
+package org.mariotaku.twidere.graphic.like.palette;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public interface Palette {
+    int getParticleColor(int count, int index, float progress);
+
+    int getCircleColor(float progress);
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/AbsLayerState.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/AbsLayerState.java
new file mode 100644
index 0000000000..e8a723cc0a
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/AbsLayerState.java
@@ -0,0 +1,42 @@
+package org.mariotaku.twidere.graphic.like.state;
+
+import android.graphics.drawable.Drawable;
+
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public abstract class AbsLayerState extends Drawable.ConstantState {
+    protected final int mIntrinsicWidth;
+    protected final int mIntrinsicHeight;
+    protected final Palette mPalette;
+
+    private float mProgress;
+
+    public AbsLayerState(int intrinsicWidth, int intrinsicHeight, Palette palette) {
+        this.mPalette = palette;
+        this.mIntrinsicHeight = intrinsicHeight;
+        this.mIntrinsicWidth = intrinsicWidth;
+    }
+
+    public final float getProgress() {
+        return mProgress;
+    }
+
+    public final void setProgress(float progress) {
+        mProgress = progress;
+    }
+
+    public final Palette getPalette() {
+        return mPalette;
+    }
+
+    public final int getIntrinsicWidth() {
+        return mIntrinsicWidth;
+    }
+
+    public final int getIntrinsicHeight() {
+        return mIntrinsicHeight;
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/CircleState.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/CircleState.java
new file mode 100644
index 0000000000..0e5f134e81
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/CircleState.java
@@ -0,0 +1,42 @@
+package org.mariotaku.twidere.graphic.like.state;
+
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.mariotaku.twidere.graphic.like.layer.CircleLayerDrawable;
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class CircleState extends AbsLayerState {
+    private final Paint mPaint;
+    private int mFullRadius;
+
+    public CircleState(int intrinsicWidth, int intrinsicHeight, Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    }
+
+    @Override
+    public Drawable newDrawable() {
+        return new CircleLayerDrawable(mIntrinsicWidth, mIntrinsicHeight, mPalette);
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+        return 0;
+    }
+
+    public void setFullRadius(int fullRadius) {
+        mFullRadius = fullRadius;
+    }
+
+    public Paint getPaint() {
+        return mPaint;
+    }
+
+    public int getFullRadius() {
+        return mFullRadius;
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ParticleLayerState.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ParticleLayerState.java
new file mode 100644
index 0000000000..a568dd43a9
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ParticleLayerState.java
@@ -0,0 +1,51 @@
+package org.mariotaku.twidere.graphic.like.state;
+
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.mariotaku.twidere.graphic.like.layer.ParticleLayerDrawable;
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class ParticleLayerState extends AbsLayerState {
+
+    private final Paint mPaint;
+    private float mFullRadius;
+    private float mParticleSize;
+
+    public ParticleLayerState(int intrinsicWidth, int intrinsicHeight, Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mPaint.setStyle(Paint.Style.FILL);
+        setProgress(-1);
+    }
+
+    @Override
+    public Drawable newDrawable() {
+        return new ParticleLayerDrawable(mIntrinsicWidth, mIntrinsicHeight, mPalette);
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+        return 0;
+    }
+
+    public float getFullRadius() {
+        return mFullRadius;
+    }
+
+    public float getParticleSize() {
+        return mParticleSize;
+    }
+
+    public Paint getPaint() {
+        return mPaint;
+    }
+
+    public void setFullRadius(int fullRadius) {
+        mFullRadius = fullRadius;
+        mParticleSize = fullRadius / 4f;
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ShineLayerState.java b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ShineLayerState.java
new file mode 100644
index 0000000000..efa5d260bb
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/graphic/like/state/ShineLayerState.java
@@ -0,0 +1,52 @@
+package org.mariotaku.twidere.graphic.like.state;
+
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.mariotaku.twidere.graphic.like.layer.ShineLayerDrawable;
+import org.mariotaku.twidere.graphic.like.palette.Palette;
+
+/**
+ * Created by mariotaku on 16/2/22.
+ */
+public class ShineLayerState extends AbsLayerState {
+
+    private final Paint mPaint;
+    private int mFullRadius;
+    private float mLineWidth;
+
+    public ShineLayerState(int intrinsicWidth, int intrinsicHeight, Palette palette) {
+        super(intrinsicWidth, intrinsicHeight, palette);
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mPaint.setStrokeCap(Paint.Cap.ROUND);
+        setProgress(-1);
+    }
+
+    public Paint getPaint() {
+        return mPaint;
+    }
+
+    @Override
+    public Drawable newDrawable() {
+        return new ShineLayerDrawable(mIntrinsicWidth, mIntrinsicHeight, mPalette);
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+        return 0;
+    }
+
+    public int getFullRadius() {
+        return mFullRadius;
+    }
+
+    public void setFullRadius(int fullRadius) {
+        mFullRadius = fullRadius;
+        mLineWidth = fullRadius / 10f;
+    }
+
+    public float getLineWidth() {
+        return mLineWidth;
+    }
+
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/menu/support/FavoriteItemProvider.java b/twidere/src/main/java/org/mariotaku/twidere/menu/support/FavoriteItemProvider.java
index c62b7cd07b..2da2e04f67 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/menu/support/FavoriteItemProvider.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/menu/support/FavoriteItemProvider.java
@@ -8,8 +8,8 @@
 import android.view.MenuItem;
 import android.view.View;
 
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable.Style;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable.Style;
 
 import java.lang.ref.WeakReference;
 
diff --git a/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteCreatedEvent.java b/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteCreatedEvent.java
deleted file mode 100644
index cbd78e4da6..0000000000
--- a/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteCreatedEvent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Twidere - Twitter client for Android
- *
- *  Copyright (C) 2012-2014 Mariotaku Lee <mariotaku.lee@gmail.com>
- *
- *  This program is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package org.mariotaku.twidere.model.message;
-
-import android.support.annotation.NonNull;
-
-import org.mariotaku.twidere.model.ParcelableStatus;
-
-/**
- * Created by mariotaku on 14/12/10.
- */
-public class FavoriteCreatedEvent {
-
-    @NonNull
-    public final ParcelableStatus status;
-
-    public FavoriteCreatedEvent(@NonNull ParcelableStatus status) {
-        this.status = status;
-    }
-}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteDestroyedEvent.java b/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteDestroyedEvent.java
deleted file mode 100644
index 03dc816643..0000000000
--- a/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteDestroyedEvent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Twidere - Twitter client for Android
- *
- *  Copyright (C) 2012-2014 Mariotaku Lee <mariotaku.lee@gmail.com>
- *
- *  This program is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package org.mariotaku.twidere.model.message;
-
-import android.support.annotation.NonNull;
-
-import org.mariotaku.twidere.model.ParcelableStatus;
-
-/**
- * Created by mariotaku on 14/12/10.
- */
-public class FavoriteDestroyedEvent {
-
-    @NonNull
-    public final ParcelableStatus status;
-
-    public FavoriteDestroyedEvent(@NonNull ParcelableStatus status) {
-        this.status = status;
-    }
-}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteTaskEvent.java b/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteTaskEvent.java
new file mode 100644
index 0000000000..133c42b36a
--- /dev/null
+++ b/twidere/src/main/java/org/mariotaku/twidere/model/message/FavoriteTaskEvent.java
@@ -0,0 +1,89 @@
+/*
+ * Twidere - Twitter client for Android
+ *
+ *  Copyright (C) 2012-2014 Mariotaku Lee <mariotaku.lee@gmail.com>
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.mariotaku.twidere.model.message;
+
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+
+import org.mariotaku.twidere.model.ParcelableStatus;
+
+/**
+ * Created by mariotaku on 14/12/10.
+ */
+public class FavoriteTaskEvent {
+
+    private int action;
+    private long accountId;
+    private long statusId;
+
+    @Nullable
+    private ParcelableStatus status;
+    private boolean finished;
+    private boolean succeeded;
+
+    public FavoriteTaskEvent(@Action final int action, final long accountId, final long statusId) {
+        this.action = action;
+        this.accountId = accountId;
+        this.statusId = statusId;
+    }
+
+    public int getAction() {
+        return action;
+    }
+
+    public long getAccountId() {
+        return accountId;
+    }
+
+    public long getStatusId() {
+        return statusId;
+    }
+
+    @Nullable
+    public ParcelableStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(ParcelableStatus status) {
+        this.status = status;
+    }
+
+    public boolean isFinished() {
+        return finished;
+    }
+
+    public void setFinished(boolean finished) {
+        this.finished = finished;
+    }
+
+    public boolean isSucceeded() {
+        return succeeded;
+    }
+
+    public void setSucceeded(boolean succeeded) {
+        this.succeeded = succeeded;
+    }
+
+    @IntDef({Action.CREATE, Action.DESTROY})
+    public @interface Action {
+        int CREATE = 1;
+        int DESTROY = 2;
+    }
+}
diff --git a/twidere/src/main/java/org/mariotaku/twidere/preference/CardPreviewPreference.java b/twidere/src/main/java/org/mariotaku/twidere/preference/CardPreviewPreference.java
index d3833807d7..0d3f350183 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/preference/CardPreviewPreference.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/preference/CardPreviewPreference.java
@@ -32,7 +32,7 @@
 import org.mariotaku.twidere.Constants;
 import org.mariotaku.twidere.R;
 import org.mariotaku.twidere.adapter.DummyStatusHolderAdapter;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
 import org.mariotaku.twidere.view.holder.StatusViewHolder;
 import org.mariotaku.twidere.view.holder.iface.IStatusViewHolder;
 
diff --git a/twidere/src/main/java/org/mariotaku/twidere/util/AsyncTwitterWrapper.java b/twidere/src/main/java/org/mariotaku/twidere/util/AsyncTwitterWrapper.java
index b1c06d54aa..b05c36de03 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/util/AsyncTwitterWrapper.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/util/AsyncTwitterWrapper.java
@@ -60,14 +60,12 @@
 import org.mariotaku.twidere.model.BaseRefreshTaskParam;
 import org.mariotaku.twidere.model.ListResponse;
 import org.mariotaku.twidere.model.ParcelableStatus;
-import org.mariotaku.twidere.model.ParcelableStatusUpdate;
 import org.mariotaku.twidere.model.ParcelableUser;
 import org.mariotaku.twidere.model.ParcelableUserList;
 import org.mariotaku.twidere.model.RefreshTaskParam;
 import org.mariotaku.twidere.model.Response;
 import org.mariotaku.twidere.model.SingleResponse;
-import org.mariotaku.twidere.model.message.FavoriteCreatedEvent;
-import org.mariotaku.twidere.model.message.FavoriteDestroyedEvent;
+import org.mariotaku.twidere.model.message.FavoriteTaskEvent;
 import org.mariotaku.twidere.model.message.FollowRequestTaskEvent;
 import org.mariotaku.twidere.model.message.FriendshipUpdatedEvent;
 import org.mariotaku.twidere.model.message.FriendshipUserUpdatedEvent;
@@ -884,28 +882,28 @@ protected void onPostExecute(final SingleResponse<ParcelableUser> result) {
 
     class CreateFavoriteTask extends ManagedAsyncTask<Object, Object, SingleResponse<ParcelableStatus>> {
 
-        private final long account_id, status_id;
+        private final long mAccountId, mStatusId;
 
-        public CreateFavoriteTask(final long account_id, final long status_id) {
+        public CreateFavoriteTask(final long account_id, final long mStatusId) {
             super(mContext);
-            this.account_id = account_id;
-            this.status_id = status_id;
+            this.mAccountId = account_id;
+            this.mStatusId = mStatusId;
         }
 
         @Override
         protected SingleResponse<ParcelableStatus> doInBackground(final Object... params) {
-            if (account_id < 0) return SingleResponse.getInstance();
-            final Twitter twitter = TwitterAPIFactory.getTwitterInstance(mContext, account_id, true);
+            if (mAccountId < 0) return SingleResponse.getInstance();
+            final Twitter twitter = TwitterAPIFactory.getTwitterInstance(mContext, mAccountId, true);
             if (twitter == null) return SingleResponse.getInstance();
             try {
-                final ParcelableStatus status = ParcelableStatusUtils.fromStatus(twitter.createFavorite(status_id), account_id, false);
+                final ParcelableStatus status = ParcelableStatusUtils.fromStatus(twitter.createFavorite(mStatusId), mAccountId, false);
                 Utils.setLastSeen(mContext, status.mentions, System.currentTimeMillis());
                 final ContentValues values = new ContentValues();
                 values.put(Statuses.IS_FAVORITE, true);
                 values.put(Statuses.FAVORITE_COUNT, status.favorite_count);
-                final Expression where = Expression.and(Expression.equals(Statuses.ACCOUNT_ID, account_id),
-                        Expression.or(Expression.equals(Statuses.STATUS_ID, status_id),
-                                Expression.equals(Statuses.RETWEET_ID, status_id)));
+                final Expression where = Expression.and(Expression.equals(Statuses.ACCOUNT_ID, mAccountId),
+                        Expression.or(Expression.equals(Statuses.STATUS_ID, mStatusId),
+                                Expression.equals(Statuses.RETWEET_ID, mStatusId)));
                 for (final Uri uri : TwidereDataStore.STATUSES_URIS) {
                     mResolver.update(uri, values, where.getSQL(), null);
                 }
@@ -921,27 +919,32 @@ protected SingleResponse<ParcelableStatus> doInBackground(final Object... params
         @Override
         protected void onPreExecute() {
             super.onPreExecute();
-            mCreatingFavoriteIds.put(account_id, status_id);
+            mCreatingFavoriteIds.put(mAccountId, mStatusId);
             bus.post(new StatusListChangedEvent());
         }
 
         @Override
         protected void onPostExecute(final SingleResponse<ParcelableStatus> result) {
-            mCreatingFavoriteIds.remove(account_id, status_id);
+            mCreatingFavoriteIds.remove(mAccountId, mStatusId);
+            final FavoriteTaskEvent taskEvent = new FavoriteTaskEvent(FavoriteTaskEvent.Action.CREATE,
+                    mAccountId, mStatusId);
+            taskEvent.setFinished(true);
             if (result.hasData()) {
                 final ParcelableStatus status = result.getData();
-
+                taskEvent.setStatus(status);
+                taskEvent.setSucceeded(true);
                 // BEGIN HotMobi
-                final TweetEvent event = TweetEvent.create(getContext(), status, TimelineType.OTHER);
-                event.setAction(TweetEvent.Action.FAVORITE);
-                HotMobiLogger.getInstance(getContext()).log(account_id, event);
+                final TweetEvent tweetEvent = TweetEvent.create(getContext(), status, TimelineType.OTHER);
+                tweetEvent.setAction(TweetEvent.Action.FAVORITE);
+                HotMobiLogger.getInstance(getContext()).log(mAccountId, tweetEvent);
                 // END HotMobi
-
-                bus.post(new FavoriteCreatedEvent(status));
-                Utils.showOkMessage(mContext, R.string.status_favorited, false);
+                Utils.showInfoMessage(mContext, R.string.status_favorited, false);
             } else {
+                taskEvent.setSucceeded(false);
                 Utils.showErrorMessage(mContext, R.string.action_favoriting, result.getException(), true);
             }
+            bus.post(taskEvent);
+            bus.post(new StatusListChangedEvent());
             super.onPostExecute(result);
         }
 
@@ -1530,29 +1533,29 @@ protected void onPostExecute(final SingleResponse<Void> result) {
 
     class DestroyFavoriteTask extends ManagedAsyncTask<Object, Object, SingleResponse<ParcelableStatus>> {
 
-        private final long account_id;
+        private final long mAccountId;
 
-        private final long status_id;
+        private final long mStatusId;
 
         public DestroyFavoriteTask(final long account_id, final long status_id) {
             super(mContext);
-            this.account_id = account_id;
-            this.status_id = status_id;
+            this.mAccountId = account_id;
+            this.mStatusId = status_id;
         }
 
         @Override
         protected SingleResponse<ParcelableStatus> doInBackground(final Object... params) {
-            if (account_id < 0) return SingleResponse.getInstance();
-            final Twitter twitter = TwitterAPIFactory.getTwitterInstance(mContext, account_id, true);
+            if (mAccountId < 0) return SingleResponse.getInstance();
+            final Twitter twitter = TwitterAPIFactory.getTwitterInstance(mContext, mAccountId, true);
             if (twitter != null) {
                 try {
-                    final ParcelableStatus status = ParcelableStatusUtils.fromStatus(twitter.destroyFavorite(status_id), account_id, false);
+                    final ParcelableStatus status = ParcelableStatusUtils.fromStatus(twitter.destroyFavorite(mStatusId), mAccountId, false);
                     final ContentValues values = new ContentValues();
                     values.put(Statuses.IS_FAVORITE, false);
                     values.put(Statuses.FAVORITE_COUNT, status.favorite_count - 1);
-                    final Expression where = Expression.and(Expression.equals(Statuses.ACCOUNT_ID, account_id),
-                            Expression.or(Expression.equals(Statuses.STATUS_ID, status_id),
-                                    Expression.equals(Statuses.RETWEET_ID, status_id)));
+                    final Expression where = Expression.and(Expression.equals(Statuses.ACCOUNT_ID, mAccountId),
+                            Expression.or(Expression.equals(Statuses.STATUS_ID, mStatusId),
+                                    Expression.equals(Statuses.RETWEET_ID, mStatusId)));
                     for (final Uri uri : TwidereDataStore.STATUSES_URIS) {
                         mResolver.update(uri, values, where.getSQL(), null);
                     }
@@ -1567,29 +1570,32 @@ protected SingleResponse<ParcelableStatus> doInBackground(final Object... params
         @Override
         protected void onPreExecute() {
             super.onPreExecute();
-            mDestroyingFavoriteIds.put(account_id, status_id);
-
-
+            mDestroyingFavoriteIds.put(mAccountId, mStatusId);
             bus.post(new StatusListChangedEvent());
         }
 
         @Override
         protected void onPostExecute(final SingleResponse<ParcelableStatus> result) {
-            mDestroyingFavoriteIds.remove(account_id, status_id);
+            mDestroyingFavoriteIds.remove(mAccountId, mStatusId);
+            final FavoriteTaskEvent taskEvent = new FavoriteTaskEvent(FavoriteTaskEvent.Action.DESTROY,
+                    mAccountId, mStatusId);
+            taskEvent.setFinished(true);
             if (result.hasData()) {
                 final ParcelableStatus status = result.getData();
+                taskEvent.setStatus(status);
+                taskEvent.setSucceeded(true);
                 // BEGIN HotMobi
-
-                final TweetEvent event = TweetEvent.create(getContext(), status, TimelineType.OTHER);
-                event.setAction(TweetEvent.Action.UNFAVORITE);
-                HotMobiLogger.getInstance(getContext()).log(account_id, event);
-
+                final TweetEvent tweetEvent = TweetEvent.create(getContext(), status, TimelineType.OTHER);
+                tweetEvent.setAction(TweetEvent.Action.UNFAVORITE);
+                HotMobiLogger.getInstance(getContext()).log(mAccountId, tweetEvent);
                 // END HotMobi
-                bus.post(new FavoriteDestroyedEvent(status));
                 Utils.showInfoMessage(mContext, R.string.status_unfavorited, false);
             } else {
+                taskEvent.setSucceeded(false);
                 Utils.showErrorMessage(mContext, R.string.action_unfavoriting, result.getException(), true);
             }
+            bus.post(taskEvent);
+            bus.post(new StatusListChangedEvent());
             super.onPostExecute(result);
         }
 
@@ -2147,8 +2153,6 @@ protected SingleResponse<ParcelableStatus> doInBackground(final Object... params
         protected void onPreExecute() {
             super.onPreExecute();
             mCreatingRetweetIds.put(accountId, statusId);
-
-
             bus.post(new StatusListChangedEvent());
         }
 
diff --git a/twidere/src/main/java/org/mariotaku/twidere/view/holder/StatusViewHolder.java b/twidere/src/main/java/org/mariotaku/twidere/view/holder/StatusViewHolder.java
index 50591b9b1c..acf081dc61 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/view/holder/StatusViewHolder.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/view/holder/StatusViewHolder.java
@@ -20,7 +20,7 @@
 import org.mariotaku.twidere.Constants;
 import org.mariotaku.twidere.R;
 import org.mariotaku.twidere.adapter.iface.IStatusesAdapter;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
 import org.mariotaku.twidere.model.ParcelableLocation;
 import org.mariotaku.twidere.model.ParcelableMedia;
 import org.mariotaku.twidere.model.ParcelableStatus;
diff --git a/twidere/src/main/java/org/mariotaku/twidere/view/holder/iface/IStatusViewHolder.java b/twidere/src/main/java/org/mariotaku/twidere/view/holder/iface/IStatusViewHolder.java
index 20aa7aeb74..09bd2fc866 100644
--- a/twidere/src/main/java/org/mariotaku/twidere/view/holder/iface/IStatusViewHolder.java
+++ b/twidere/src/main/java/org/mariotaku/twidere/view/holder/iface/IStatusViewHolder.java
@@ -26,7 +26,7 @@
 import android.widget.ImageView;
 
 import org.mariotaku.twidere.adapter.iface.ContentCardClickListener;
-import org.mariotaku.twidere.graphic.LikeAnimationDrawable;
+import org.mariotaku.twidere.graphic.like.LikeAnimationDrawable;
 import org.mariotaku.twidere.model.ParcelableMedia;
 import org.mariotaku.twidere.model.ParcelableStatus;
 import org.mariotaku.twidere.view.CardMediaContainer;
