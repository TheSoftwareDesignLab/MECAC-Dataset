diff --git a/web/apps/photos/src/components/TripLayout/TimelineLocation.tsx b/web/apps/photos/src/components/TripLayout/TimelineLocation.tsx
index 0ae47291a03..371a6605236 100644
--- a/web/apps/photos/src/components/TripLayout/TimelineLocation.tsx
+++ b/web/apps/photos/src/components/TripLayout/TimelineLocation.tsx
@@ -50,11 +50,11 @@ export const TimelineLocation = memo<TimelineLocationProps>(
         const diffTime = photoDateOnly.getTime() - firstDateOnly.getTime();
         const dayNumber = Math.floor(diffTime / (1000 * 60 * 60 * 24)) + 1;
 
-        // Show green for all covered locations (up to current position)
+        // Show green only for the active location
         const currentLocationIndex = Math.round(
             scrollProgress * Math.max(0, photoClusters.length - 1),
         );
-        const isCovered = index <= currentLocationIndex;
+        const isActive = index === currentLocationIndex;
 
         return (
             <LocationContainer
@@ -67,7 +67,7 @@ export const TimelineLocation = memo<TimelineLocationProps>(
                 }}
             >
                 <DotBackground />
-                <TimelineDot isReached={isCovered} />
+                <TimelineDot isReached={isActive} />
 
                 {isLeft ? (
                     <>
diff --git a/web/apps/photos/src/components/TripLayout/TripMap.tsx b/web/apps/photos/src/components/TripLayout/TripMap.tsx
index 0f31055f14a..095ac9c55ba 100644
--- a/web/apps/photos/src/components/TripLayout/TripMap.tsx
+++ b/web/apps/photos/src/components/TripLayout/TripMap.tsx
@@ -133,7 +133,7 @@ export const TripMap: React.FC<TripMapProps> = ({
 
                     {/* Draw super-clusters (clickable for zoom and gallery) */}
                     {superClusters.map((superCluster, index) => {
-                        // Show green for all covered locations (up to current position)
+                        // Show green only for active locations
                         let currentLocationIndex;
                         if (isTouchDevice) {
                             // Mobile: Slower progression - stay on each location longer
@@ -147,16 +147,15 @@ export const TripMap: React.FC<TripMapProps> = ({
                                     Math.max(0, photoClusters.length - 1),
                             );
                         }
-                        const isCovered = superCluster.clustersInvolved.some(
-                            (clusterIndex) =>
-                                clusterIndex <= currentLocationIndex,
+                        const isActive = superCluster.clustersInvolved.includes(
+                            currentLocationIndex,
                         );
 
                         const icon = createSuperClusterIcon(
                             superCluster.image, // Use representative photo (first photo of first cluster)
                             superCluster.clusterCount,
                             isTouchDevice ? 40 : 55,
-                            isCovered,
+                            isActive,
                         );
 
                         return icon ? (
@@ -198,7 +197,7 @@ export const TripMap: React.FC<TripMapProps> = ({
                                 originalCluster.length === cluster.length &&
                                 originalCluster[0]?.image === cluster[0]?.image,
                         );
-                        // Show green for all covered locations (up to current position)
+                        // Show green only for active locations
                         let currentLocationIndex;
                         if (isTouchDevice) {
                             // Mobile: Slower progression - stay on each location longer
@@ -212,15 +211,15 @@ export const TripMap: React.FC<TripMapProps> = ({
                                     Math.max(0, photoClusters.length - 1),
                             );
                         }
-                        const isCovered =
-                            originalClusterIndex <= currentLocationIndex;
+                        const isActive =
+                            originalClusterIndex === currentLocationIndex;
 
                         const icon = createIcon(
                             firstPhoto.image,
                             isTouchDevice ? 40 : 55,
                             "#ffffff",
                             cluster.length,
-                            isCovered,
+                            isActive,
                         );
 
                         return icon ? (
diff --git a/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts b/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
index ee8ec4f70cb..c549bf38779 100644
--- a/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
+++ b/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
@@ -38,6 +38,7 @@ export interface UseScrollHandlingParams {
         }[];
         clusterToSuperClusterMap: Map<number, number>;
     };
+    scrollProgress: number;
 }
 
 export const useScrollHandling = ({
@@ -55,6 +56,7 @@ export const useScrollHandling = ({
     setTargetZoom,
     previousSuperClusterStateRef,
     superClusterInfo,
+    scrollProgress,
 }: UseScrollHandlingParams) => {
     const isTouchDevice = useIsTouchscreen();
     // Update location positions callback
@@ -130,6 +132,8 @@ export const useScrollHandling = ({
                 setHasUserScrolled,
                 scrollTimelineToLocation: scrollToLocation,
                 isTouchDevice,
+                superClusterInfo,
+                scrollProgress,
             });
         },
         [
@@ -141,6 +145,8 @@ export const useScrollHandling = ({
             setHasUserScrolled,
             scrollToLocation,
             isTouchDevice,
+            superClusterInfo,
+            scrollProgress,
         ],
     );
 
diff --git a/web/apps/photos/src/components/TripLayout/index.tsx b/web/apps/photos/src/components/TripLayout/index.tsx
index c952655c979..d46a4d985ed 100644
--- a/web/apps/photos/src/components/TripLayout/index.tsx
+++ b/web/apps/photos/src/components/TripLayout/index.tsx
@@ -135,6 +135,16 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
             targetZoom: number | null;
             mapRef: import("leaflet").Map | null;
             scrollProgress: number;
+            superClusterInfo?: {
+                superClusters: {
+                    lat: number;
+                    lng: number;
+                    clusterCount: number;
+                    clustersInvolved: number[];
+                    image: string;
+                }[];
+                clusterToSuperClusterMap: Map<number, number>;
+            };
             setMapRef: (map: import("leaflet").Map | null) => void;
             setCurrentZoom: (zoom: number) => void;
             setTargetZoom: (zoom: number | null) => void;
@@ -306,6 +316,7 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
         setTargetZoom,
         previousSuperClusterStateRef,
         superClusterInfo,
+        scrollProgress,
     });
 
     // Only wait for client-side rendering (needed for maps), but show layout immediately
diff --git a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
index 104ece8e6da..7c843712027 100644
--- a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
+++ b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
@@ -465,6 +465,17 @@ export interface HandleMarkerClickParams {
     setHasUserScrolled: (scrolled: boolean) => void;
     scrollTimelineToLocation: (locationIndex: number) => void;
     isTouchDevice: boolean;
+    superClusterInfo?: {
+        superClusters: {
+            lat: number;
+            lng: number;
+            clusterCount: number;
+            clustersInvolved: number[];
+            image: string;
+        }[];
+        clusterToSuperClusterMap: Map<number, number>;
+    };
+    scrollProgress: number;
 }
 
 export const handleMarkerClick = ({
@@ -479,6 +490,8 @@ export const handleMarkerClick = ({
     setHasUserScrolled,
     scrollTimelineToLocation,
     isTouchDevice,
+    superClusterInfo,
+    scrollProgress,
 }: HandleMarkerClickParams) => {
     const targetProgress = clusterIndex / Math.max(1, photoClusters.length - 1);
 
@@ -490,20 +503,63 @@ export const handleMarkerClick = ({
     setScrollProgress(targetProgress);
     setHasUserScrolled(true);
 
-    // Position clicked location at 20% from right edge
-    const [positionedLat, positionedLng] = getLocationPosition(
-        clusterLat,
-        clusterLng,
-    );
+    // Calculate current active location index
+    let currentActiveLocationIndex = -1;
+    if (photoClusters.length > 0) {
+        if (isTouchDevice) {
+            currentActiveLocationIndex = Math.floor(
+                scrollProgress * (photoClusters.length - 0.5),
+            );
+        } else {
+            currentActiveLocationIndex = Math.round(
+                scrollProgress * Math.max(0, photoClusters.length - 1),
+            );
+        }
+    }
+
+    // Check if both current and target locations are in the same super cluster
+    let shouldJustPan = false;
+    if (superClusterInfo && currentActiveLocationIndex >= 0) {
+        const currentSuperClusterIndex =
+            superClusterInfo.clusterToSuperClusterMap.get(currentActiveLocationIndex);
+        const targetSuperClusterIndex =
+            superClusterInfo.clusterToSuperClusterMap.get(clusterIndex);
+
+        // If both locations are in super clusters and they're the same super cluster
+        shouldJustPan =
+            currentSuperClusterIndex !== undefined &&
+            targetSuperClusterIndex !== undefined &&
+            currentSuperClusterIndex === targetSuperClusterIndex;
+    }
 
     if (mapRef?.getContainer()) {
         try {
-            const targetZoom = isTouchDevice ? 8 : 10; // Touch device-aware zoom level
-            mapRef.flyTo([positionedLat, positionedLng], targetZoom, {
-                animate: true,
-                duration: 1.0,
-                easeLinearity: 0.3,
-            });
+            if (shouldJustPan) {
+                // Just pan to the location with zoom-aware positioning, keeping current zoom
+                const currentMapZoom = mapRef.getZoom();
+                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
+                    clusterLat,
+                    clusterLng,
+                    currentMapZoom,
+                );
+                mapRef.panTo([zoomAwareLat, zoomAwareLng], {
+                    animate: true,
+                    duration: 0.6,
+                    easeLinearity: 0.3,
+                });
+            } else {
+                // Normal behavior: fly to with zoom
+                const [positionedLat, positionedLng] = getLocationPosition(
+                    clusterLat,
+                    clusterLng,
+                );
+                const targetZoom = isTouchDevice ? 8 : 10;
+                mapRef.flyTo([positionedLat, positionedLng], targetZoom, {
+                    animate: true,
+                    duration: 1.0,
+                    easeLinearity: 0.3,
+                });
+            }
         } catch (error) {
             console.warn("Map operation failed:", error);
         }
