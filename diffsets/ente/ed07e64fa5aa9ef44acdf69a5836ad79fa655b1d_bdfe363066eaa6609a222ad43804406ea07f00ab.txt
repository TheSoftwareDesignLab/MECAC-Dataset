diff --git a/mobile/apps/locker/lib/ui/components/menu_section_description_widget.dart b/mobile/apps/locker/lib/ui/components/menu_section_description_widget.dart
new file mode 100644
index 00000000000..a932f572fa1
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/components/menu_section_description_widget.dart
@@ -0,0 +1,21 @@
+import "package:ente_ui/theme/ente_theme.dart";
+import 'package:flutter/material.dart';
+
+class MenuSectionDescriptionWidget extends StatelessWidget {
+  final String content;
+  const MenuSectionDescriptionWidget({required this.content, super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Padding(
+      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 6),
+      child: Text(
+        content,
+        textAlign: TextAlign.left,
+        style: getEnteTextTheme(context)
+            .mini
+            .copyWith(color: getEnteColorScheme(context).textMuted),
+      ),
+    );
+  }
+}
diff --git a/mobile/apps/locker/lib/ui/components/user_dialogs.dart b/mobile/apps/locker/lib/ui/components/user_dialogs.dart
new file mode 100644
index 00000000000..206a30fa704
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/components/user_dialogs.dart
@@ -0,0 +1,32 @@
+import "dart:async";
+
+import "package:ente_ui/components/buttons/button_widget.dart";
+import "package:ente_ui/components/buttons/models/button_type.dart";
+import "package:ente_ui/components/dialog_widget.dart";
+import "package:ente_utils/share_utils.dart";
+import "package:flutter/material.dart";
+import "package:locker/l10n/l10n.dart";
+Future<void> showInviteDialog(BuildContext context, String email) async {
+  await showDialogWidget(
+    context: context,
+    title: context.l10n.inviteToEnte,
+    icon: Icons.info_outline,
+    body: context.l10n.emailNoEnteAccount(email),
+    isDismissible: true,
+    buttons: [
+      ButtonWidget(
+        buttonType: ButtonType.neutral,
+        icon: Icons.adaptive.share,
+        labelText: context.l10n.sendInvite,
+        isInAlert: true,
+        onTap: () async {
+          unawaited(
+            shareText(
+              context.l10n.shareTextRecommendUsingEnte,
+            ),
+          );
+        },
+      ),
+    ],
+  );
+}
diff --git a/mobile/apps/locker/lib/ui/sharing/pickers/device_limit_picker_page.dart b/mobile/apps/locker/lib/ui/sharing/pickers/device_limit_picker_page.dart
new file mode 100644
index 00000000000..dff471cedb5
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/sharing/pickers/device_limit_picker_page.dart
@@ -0,0 +1,145 @@
+import "package:ente_ui/components/captioned_text_widget.dart";
+import "package:ente_ui/components/divider_widget.dart";
+import "package:ente_ui/components/menu_item_widget.dart";
+import "package:ente_ui/components/separators.dart";
+import "package:ente_ui/components/title_bar_title_widget.dart";
+import "package:ente_ui/components/title_bar_widget.dart";
+import "package:ente_ui/theme/ente_theme.dart";
+import "package:ente_ui/utils/dialog_util.dart";
+import 'package:flutter/material.dart';
+import "package:locker/core/constants.dart";
+import "package:locker/l10n/l10n.dart";
+import "package:locker/services/collections/collections_api_client.dart";
+import "package:locker/services/collections/models/collection.dart";
+
+class DeviceLimitPickerPage extends StatelessWidget {
+  final Collection collection;
+  const DeviceLimitPickerPage(this.collection, {super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Scaffold(
+      body: CustomScrollView(
+        primary: false,
+        slivers: <Widget>[
+          TitleBarWidget(
+            flexibleSpaceTitle: TitleBarTitleWidget(
+              title: context.l10n.linkDeviceLimit,
+            ),
+          ),
+          SliverList(
+            delegate: SliverChildBuilderDelegate(
+              (context, index) {
+                return Padding(
+                  padding: const EdgeInsets.symmetric(
+                    horizontal: 16,
+                    vertical: 20,
+                  ),
+                  child: Column(
+                    mainAxisSize: MainAxisSize.min,
+                    children: [
+                      ClipRRect(
+                        borderRadius:
+                            const BorderRadius.all(Radius.circular(8)),
+                        child: ItemsWidget(collection),
+                      ),
+                    ],
+                  ),
+                );
+              },
+              childCount: 1,
+            ),
+          ),
+          const SliverPadding(padding: EdgeInsets.symmetric(vertical: 12)),
+        ],
+      ),
+    );
+  }
+}
+
+class ItemsWidget extends StatefulWidget {
+  final Collection collection;
+  const ItemsWidget(this.collection, {super.key});
+
+  @override
+  State<ItemsWidget> createState() => _ItemsWidgetState();
+}
+
+class _ItemsWidgetState extends State<ItemsWidget> {
+  late int currentDeviceLimit;
+  late int initialDeviceLimit;
+  List<Widget> items = [];
+  bool isCustomLimit = false;
+  @override
+  void initState() {
+    currentDeviceLimit = widget.collection.publicURLs.first.deviceLimit;
+    initialDeviceLimit = currentDeviceLimit;
+    if (!publicLinkDeviceLimits.contains(currentDeviceLimit)) {
+      isCustomLimit = true;
+    }
+    super.initState();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    items.clear();
+    if (isCustomLimit) {
+      items.add(
+        _menuItemForPicker(initialDeviceLimit),
+      );
+    }
+    for (int deviceLimit in publicLinkDeviceLimits) {
+      items.add(
+        _menuItemForPicker(deviceLimit),
+      );
+    }
+    items = addSeparators(
+      items,
+      DividerWidget(
+        dividerType: DividerType.menuNoIcon,
+        bgColor: getEnteColorScheme(context).fillFaint,
+      ),
+    );
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      children: items,
+    );
+  }
+
+  Widget _menuItemForPicker(int deviceLimit) {
+    return MenuItemWidget(
+      key: ValueKey(deviceLimit),
+      menuItemColor: getEnteColorScheme(context).fillFaint,
+      captionedTextWidget: CaptionedTextWidget(
+        title: deviceLimit == 0 ? context.l10n.noDeviceLimit : "$deviceLimit",
+      ),
+      trailingIcon: currentDeviceLimit == deviceLimit ? Icons.check : null,
+      alignCaptionedTextToLeft: true,
+      isTopBorderRadiusRemoved: true,
+      isBottomBorderRadiusRemoved: true,
+      showOnlyLoadingState: true,
+      onTap: () async {
+        await _updateUrlSettings(context, {
+          'deviceLimit': deviceLimit,
+        }).then(
+          (value) => setState(() {
+            currentDeviceLimit = deviceLimit;
+          }),
+        );
+      },
+    );
+  }
+
+  Future<void> _updateUrlSettings(
+    BuildContext context,
+    Map<String, dynamic> prop,
+  ) async {
+    try {
+      await CollectionApiClient.instance
+          .updateShareUrl(widget.collection, prop);
+    } catch (e) {
+      await showGenericErrorDialog(context: context, error: e);
+      rethrow;
+    }
+  }
+}
diff --git a/mobile/apps/locker/lib/ui/sharing/pickers/link_expiry_picker_page.dart b/mobile/apps/locker/lib/ui/sharing/pickers/link_expiry_picker_page.dart
new file mode 100644
index 00000000000..4a85cbbd613
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/sharing/pickers/link_expiry_picker_page.dart
@@ -0,0 +1,168 @@
+import "package:ente_ui/components/captioned_text_widget.dart";
+import "package:ente_ui/components/divider_widget.dart";
+import "package:ente_ui/components/menu_item_widget.dart";
+import "package:ente_ui/components/separators.dart";
+import "package:ente_ui/components/title_bar_title_widget.dart";
+import "package:ente_ui/components/title_bar_widget.dart";
+import "package:ente_ui/theme/ente_theme.dart";
+import "package:ente_ui/utils/dialog_util.dart";
+import 'package:flutter/material.dart';
+import "package:locker/l10n/l10n.dart";
+import "package:locker/services/collections/collections_api_client.dart";
+import "package:locker/services/collections/models/collection.dart";
+import "package:locker/ui/viewer/date/date_time_picker.dart";
+import "package:tuple/tuple.dart";
+
+class LinkExpiryPickerPage extends StatelessWidget {
+  final Collection collection;
+  const LinkExpiryPickerPage(this.collection, {super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Scaffold(
+      body: CustomScrollView(
+        primary: false,
+        slivers: <Widget>[
+          TitleBarWidget(
+            flexibleSpaceTitle: TitleBarTitleWidget(
+              title: context.l10n.linkExpiry,
+            ),
+          ),
+          SliverList(
+            delegate: SliverChildBuilderDelegate(
+              (context, index) {
+                return Padding(
+                  padding: const EdgeInsets.symmetric(
+                    horizontal: 16,
+                    vertical: 20,
+                  ),
+                  child: Column(
+                    mainAxisSize: MainAxisSize.min,
+                    children: [
+                      ClipRRect(
+                        borderRadius:
+                            const BorderRadius.all(Radius.circular(8)),
+                        child: ItemsWidget(collection),
+                      ),
+                    ],
+                  ),
+                );
+              },
+              childCount: 1,
+            ),
+          ),
+          const SliverPadding(padding: EdgeInsets.symmetric(vertical: 12)),
+        ],
+      ),
+    );
+  }
+}
+
+class ItemsWidget extends StatefulWidget {
+  final Collection collection;
+  const ItemsWidget(this.collection, {super.key});
+
+  @override
+  State<ItemsWidget> createState() => _ItemsWidgetState();
+}
+
+class _ItemsWidgetState extends State<ItemsWidget> {
+  // index, title, milliseconds in future post which link should expire (when >0)
+  late final List<Tuple2<String, int>> _expiryOptions = [
+    Tuple2(context.l10n.never, 0),
+    Tuple2(context.l10n.after1Hour, const Duration(hours: 1).inMicroseconds),
+    Tuple2(context.l10n.after1Day, const Duration(days: 1).inMicroseconds),
+    Tuple2(context.l10n.after1Week, const Duration(days: 7).inMicroseconds),
+    // todo: make this time calculation perfect
+    Tuple2(context.l10n.after1Month, const Duration(days: 30).inMicroseconds),
+    Tuple2(context.l10n.after1Year, const Duration(days: 365).inMicroseconds),
+    Tuple2(context.l10n.custom, -1),
+  ];
+
+  @override
+  Widget build(BuildContext context) {
+    List<Widget> items = [];
+    for (Tuple2<String, int> expiryOpiton in _expiryOptions) {
+      items.add(
+        _menuItemForPicker(context, expiryOpiton),
+      );
+    }
+    items = addSeparators(
+      items,
+      DividerWidget(
+        dividerType: DividerType.menuNoIcon,
+        bgColor: getEnteColorScheme(context).fillFaint,
+      ),
+    );
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      children: items,
+    );
+  }
+
+  Widget _menuItemForPicker(
+    BuildContext context,
+    Tuple2<String, int> expiryOpiton,
+  ) {
+    return MenuItemWidget(
+      menuItemColor: getEnteColorScheme(context).fillFaint,
+      captionedTextWidget: CaptionedTextWidget(
+        title: expiryOpiton.item1,
+      ),
+      alignCaptionedTextToLeft: true,
+      isTopBorderRadiusRemoved: true,
+      isBottomBorderRadiusRemoved: true,
+      alwaysShowSuccessState: true,
+      surfaceExecutionStates: expiryOpiton.item2 == -1 ? false : true,
+      onTap: () async {
+        int newValidTill = -1;
+        final int expireAfterInMicroseconds = expiryOpiton.item2;
+        // need to manually select time
+        if (expireAfterInMicroseconds < 0) {
+          final now = DateTime.now();
+          final DateTime? picked = await showDatePickerSheet(
+            context,
+            initialDate: now,
+            minDate: now,
+          );
+          final timeInMicrosecondsFromEpoch = picked?.microsecondsSinceEpoch;
+          if (timeInMicrosecondsFromEpoch != null) {
+            newValidTill = timeInMicrosecondsFromEpoch;
+          }
+        } else if (expireAfterInMicroseconds == 0) {
+          // no expiry
+          newValidTill = 0;
+        } else {
+          newValidTill =
+              DateTime.now().microsecondsSinceEpoch + expireAfterInMicroseconds;
+        }
+        if (newValidTill >= 0) {
+          debugPrint(
+            "Setting expire date to  ${DateTime.fromMicrosecondsSinceEpoch(newValidTill)}",
+          );
+          await updateTime(newValidTill, context);
+        }
+      },
+    );
+  }
+
+  Future<void> updateTime(int newValidTill, BuildContext context) async {
+    await _updateUrlSettings(
+      context,
+      {'validTill': newValidTill},
+    );
+  }
+
+  Future<void> _updateUrlSettings(
+    BuildContext context,
+    Map<String, dynamic> prop,
+  ) async {
+    try {
+      await CollectionApiClient.instance
+          .updateShareUrl(widget.collection, prop);
+    } catch (e) {
+      await showGenericErrorDialog(context: context, error: e);
+      rethrow;
+    }
+  }
+}
diff --git a/mobile/apps/locker/lib/ui/sharing/user_avator_widget.dart b/mobile/apps/locker/lib/ui/sharing/user_avator_widget.dart
new file mode 100644
index 00000000000..c253904fe99
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/sharing/user_avator_widget.dart
@@ -0,0 +1,212 @@
+
+import "package:ente_ui/theme/colors.dart";
+import "package:ente_ui/theme/ente_theme.dart";
+import 'package:flutter/material.dart';
+import "package:locker/services/collections/models/user.dart";
+import "package:locker/services/configuration.dart";
+import 'package:tuple/tuple.dart';
+
+enum AvatarType { small, mini, tiny, extra }
+
+class UserAvatarWidget extends StatefulWidget {
+  final User user;
+  final AvatarType type;
+  final int currentUserID;
+  final bool thumbnailView;
+
+  const UserAvatarWidget(
+    this.user, {
+    super.key,
+    this.currentUserID = -1,
+    this.type = AvatarType.mini,
+    this.thumbnailView = false,
+  });
+
+  @override
+  State<UserAvatarWidget> createState() => _UserAvatarWidgetState();
+  static const strokeWidth = 1.0;
+}
+
+class _UserAvatarWidgetState extends State<UserAvatarWidget> {
+  @override
+  Widget build(BuildContext context) {
+    final double size = getAvatarSize(widget.type);
+    return Container(
+      padding: const EdgeInsets.all(0.5),
+      decoration: BoxDecoration(
+        shape: BoxShape.circle,
+        border: Border.all(
+          color: widget.thumbnailView
+              ? strokeMutedDark
+              : getEnteColorScheme(context).strokeMuted,
+          width: UserAvatarWidget.strokeWidth,
+          strokeAlign: BorderSide.strokeAlignOutside,
+        ),
+      ),
+      child: SizedBox(
+        height: size,
+        width: size,
+        child: _FirstLetterCircularAvatar(
+          user: widget.user,
+          currentUserID: widget.currentUserID,
+          thumbnailView: widget.thumbnailView,
+          type: widget.type,
+        ),
+      ),
+    );
+  }
+}
+
+class _FirstLetterCircularAvatar extends StatefulWidget {
+  final User user;
+  final int currentUserID;
+  final bool thumbnailView;
+  final AvatarType type;
+  const _FirstLetterCircularAvatar({
+    required this.user,
+    required this.currentUserID,
+    required this.thumbnailView,
+    required this.type,
+  });
+
+  @override
+  State<_FirstLetterCircularAvatar> createState() =>
+      _FirstLetterCircularAvatarState();
+}
+
+class _FirstLetterCircularAvatarState
+    extends State<_FirstLetterCircularAvatar> {
+  @override
+  Widget build(BuildContext context) {
+    final colorScheme = getEnteColorScheme(context);
+    final displayChar =
+        (widget.user.name == null || widget.user.name!.isEmpty)
+            ? ((widget.user.email.isEmpty)
+                ? " "
+                : widget.user.email.substring(0, 1))
+            : widget.user.name!.substring(0, 1);
+    Color decorationColor;
+    if ((widget.user.id != null && widget.user.id! < 0) ||
+        widget.user.email == Configuration.instance.getEmail()) {
+      decorationColor = Colors.black;
+    } else {
+      decorationColor = colorScheme.avatarColors[(widget.user.email.length)
+          .remainder(colorScheme.avatarColors.length)];
+    }
+
+    final avatarStyle = getAvatarStyle(context, widget.type);
+    final double size = avatarStyle.item1;
+    final TextStyle textStyle = avatarStyle.item2;
+    return Container(
+      padding: const EdgeInsets.all(0.5),
+      decoration: BoxDecoration(
+        shape: BoxShape.circle,
+        border: Border.all(
+          color: widget.thumbnailView
+              ? strokeMutedDark
+              : getEnteColorScheme(context).strokeMuted,
+          width: UserAvatarWidget.strokeWidth,
+          strokeAlign: BorderSide.strokeAlignOutside,
+        ),
+      ),
+      child: SizedBox(
+        height: size,
+        width: size,
+        child: CircleAvatar(
+          backgroundColor: decorationColor,
+          child: Text(
+            displayChar.toUpperCase(),
+            // fixed color
+            style: textStyle.copyWith(color: Colors.white),
+          ),
+        ),
+      ),
+    );
+  }
+
+  Tuple2<double, TextStyle> getAvatarStyle(
+    BuildContext context,
+    AvatarType type,
+  ) {
+    final enteTextTheme = getEnteTextTheme(context);
+    switch (type) {
+      case AvatarType.small:
+        return Tuple2(32.0, enteTextTheme.small);
+      case AvatarType.mini:
+        return Tuple2(24.0, enteTextTheme.mini);
+      case AvatarType.tiny:
+        return Tuple2(18.0, enteTextTheme.tiny);
+      case AvatarType.extra:
+        return Tuple2(18.0, enteTextTheme.tiny);
+    }
+  }
+}
+
+double getAvatarSize(
+  AvatarType type,
+) {
+  switch (type) {
+    case AvatarType.small:
+      return 32.0;
+    case AvatarType.mini:
+      return 24.0;
+    case AvatarType.tiny:
+      return 18.0;
+    case AvatarType.extra:
+      return 18.0;
+  }
+}
+
+class FirstLetterUserAvatar extends StatefulWidget {
+  final User user;
+  const FirstLetterUserAvatar(this.user, {super.key});
+
+  @override
+  State<FirstLetterUserAvatar> createState() => _FirstLetterUserAvatarState();
+}
+
+class _FirstLetterUserAvatarState extends State<FirstLetterUserAvatar> {
+  final currentUserEmail = Configuration.instance.getEmail();
+  late User user;
+
+  @override
+  void initState() {
+    super.initState();
+    user = widget.user;
+  }
+
+  @override
+  void didUpdateWidget(covariant FirstLetterUserAvatar oldWidget) {
+    super.didUpdateWidget(oldWidget);
+    if (oldWidget.user != widget.user) {
+      setState(() {
+        user = widget.user;
+      });
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final colorScheme = getEnteColorScheme(context);
+    final displayChar = (user.name == null || user.name!.isEmpty)
+        ? ((user.email.isEmpty) ? " " : user.email.substring(0, 1))
+        : user.name!.substring(0, 1);
+    Color decorationColor;
+    if ((widget.user.id != null && widget.user.id! < 0) ||
+        user.email == currentUserEmail) {
+      decorationColor = Colors.black;
+    } else {
+      decorationColor = colorScheme.avatarColors[
+          (user.email.length).remainder(colorScheme.avatarColors.length)];
+    }
+    return Container(
+      color: decorationColor,
+      child: Center(
+        child: Text(
+          displayChar.toUpperCase(),
+          style: getEnteTextTheme(context).small.copyWith(color: Colors.white),
+        ),
+      ),
+    );
+  }
+}
diff --git a/mobile/apps/locker/lib/ui/sharing/verify_identity_dialog.dart b/mobile/apps/locker/lib/ui/sharing/verify_identity_dialog.dart
new file mode 100644
index 00000000000..81b3c116740
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/sharing/verify_identity_dialog.dart
@@ -0,0 +1,208 @@
+import "dart:convert";
+
+import 'package:bip39/bip39.dart' as bip39;
+import "package:crypto/crypto.dart";
+import "package:dotted_border/dotted_border.dart";
+import "package:ente_accounts/services/user_service.dart";
+import "package:ente_ui/components/buttons/button_widget.dart";
+import "package:ente_ui/components/buttons/models/button_type.dart";
+import "package:ente_ui/components/loading_widget.dart";
+import "package:ente_ui/theme/ente_theme.dart";
+import "package:ente_utils/share_utils.dart";
+import "package:flutter/material.dart";
+import "package:flutter/services.dart";
+import "package:locker/l10n/l10n.dart";
+import "package:locker/services/configuration.dart";
+import "package:logging/logging.dart";
+
+class VerifyIdentifyDialog extends StatefulWidget {
+  // email id of the user who's verification ID is being displayed for
+  // verification
+  final String email;
+
+  // self is true when the user is viewing their own verification ID
+  final bool self;
+
+  VerifyIdentifyDialog({
+    super.key,
+    required this.self,
+    this.email = '',
+  }) {
+    if (!self && email.isEmpty) {
+      throw ArgumentError("email cannot be empty when self is false");
+    }
+  }
+
+  @override
+  State<VerifyIdentifyDialog> createState() => _VerifyIdentifyDialogState();
+}
+
+class _VerifyIdentifyDialogState extends State<VerifyIdentifyDialog> {
+  final bool doesUserExist = true;
+
+  @override
+  Widget build(BuildContext context) {
+    final textStyle = getEnteTextTheme(context);
+    final String subTitle = widget.self
+        ? context.l10n.thisIsYourVerificationId
+        : context.l10n.thisIsPersonVerificationId(widget.email);
+    final String bottomText = widget.self
+        ? context.l10n.someoneSharingAlbumsWithYouShouldSeeTheSameId
+        : context.l10n.howToViewShareeVerificationID;
+
+    final AlertDialog alert = AlertDialog(
+      title: Text(
+        widget.self
+            ? context.l10n.verificationId
+            : context.l10n.verifyEmailID(widget.email),
+      ),
+      content: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          FutureBuilder<String>(
+            future: _getPublicKey(),
+            builder: (context, snapshot) {
+              if (snapshot.hasData) {
+                final publicKey = snapshot.data!;
+                if (publicKey.isEmpty) {
+                  return Column(
+                    mainAxisSize: MainAxisSize.min,
+                    children: [
+                      Text(
+                        context.l10n.emailNoEnteAccount(widget.email),
+                      ),
+                      const SizedBox(height: 24),
+                      ButtonWidget(
+                        buttonType: ButtonType.neutral,
+                        icon: Icons.adaptive.share,
+                        labelText: context.l10n.sendInvite,
+                        isInAlert: true,
+                        onTap: () async {
+                          // ignore: unawaited_futures
+                          shareText(
+                            context.l10n.shareTextRecommendUsingEnte,
+                          );
+                        },
+                      ),
+                    ],
+                  );
+                } else {
+                  return Column(
+                    crossAxisAlignment: CrossAxisAlignment.start,
+                    children: [
+                      Text(
+                        subTitle,
+                        style: textStyle.bodyMuted,
+                      ),
+                      const SizedBox(height: 20),
+                      _verificationIDWidget(context, publicKey),
+                      const SizedBox(height: 16),
+                      Text(
+                        bottomText,
+                        style: textStyle.bodyMuted,
+                      ),
+                      const SizedBox(height: 24),
+                      ButtonWidget(
+                        buttonType: ButtonType.neutral,
+                        isInAlert: true,
+                        labelText:
+                            widget.self ? context.l10n.ok : context.l10n.done,
+                      ),
+                    ],
+                  );
+                }
+              } else if (snapshot.hasError) {
+                Logger("VerificationID")
+                    .severe("failed to end userID", snapshot.error);
+                return Text(
+                  context.l10n.somethingWentWrong,
+                  style: textStyle.bodyMuted,
+                );
+              } else {
+                return const SizedBox(
+                  height: 200,
+                  child: EnteLoadingWidget(),
+                );
+              }
+            },
+          ),
+        ],
+      ),
+    );
+    return alert;
+  }
+
+  Future<String> _getPublicKey() async {
+    if (widget.self) {
+      return Configuration.instance.getKeyAttributes()!.publicKey;
+    }
+    final String? userPublicKey =
+        await UserService.instance.getPublicKey(widget.email);
+    if (userPublicKey == null) {
+      // user not found
+      return "";
+    }
+    return userPublicKey;
+  }
+
+  Widget _verificationIDWidget(BuildContext context, String publicKey) {
+    final colorScheme = getEnteColorScheme(context);
+    final textStyle = getEnteTextTheme(context);
+    final String verificationID = _generateVerificationID(publicKey);
+    return DottedBorder(
+      options: RoundedRectDottedBorderOptions(
+        color: colorScheme.strokeMuted,
+        strokeWidth: 1,
+        dashPattern: const [12, 6],
+        radius: const Radius.circular(8),
+      ),
+      child: Column(
+        children: [
+          GestureDetector(
+            onTap: () async {
+              if (verificationID.isEmpty) {
+                return;
+              }
+              await Clipboard.setData(
+                ClipboardData(text: verificationID),
+              );
+              // ignore: unawaited_futures
+              shareText(
+                widget.self
+                    ? context.l10n.shareMyVerificationID(verificationID)
+                    : context.l10n
+                        .shareTextConfirmOthersVerificationID(verificationID),
+              );
+            },
+            child: Container(
+              decoration: BoxDecoration(
+                borderRadius: const BorderRadius.all(
+                  Radius.circular(2),
+                ),
+                color: colorScheme.backgroundElevated2,
+              ),
+              padding: const EdgeInsets.all(20),
+              width: double.infinity,
+              child: Text(
+                verificationID,
+                style: textStyle.bodyBold,
+              ),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  String _generateVerificationID(String publicKey) {
+    final inputBytes = base64.decode(publicKey);
+    final shaValue = sha256.convert(inputBytes);
+    return bip39.generateMnemonic(
+      strength: 256,
+      randomBytes: (int size) {
+        return Uint8List.fromList(shaValue.bytes);
+      },
+    );
+  }
+}
diff --git a/mobile/apps/locker/lib/ui/viewer/date/date_time_picker.dart b/mobile/apps/locker/lib/ui/viewer/date/date_time_picker.dart
new file mode 100644
index 00000000000..33a468675d2
--- /dev/null
+++ b/mobile/apps/locker/lib/ui/viewer/date/date_time_picker.dart
@@ -0,0 +1,227 @@
+import "package:ente_ui/theme/ente_theme.dart";
+import "package:flutter/cupertino.dart";
+import "package:flutter/material.dart";
+import "package:locker/l10n/l10n.dart";
+
+Future<DateTime?> showDatePickerSheet(
+  BuildContext context, {
+  required DateTime initialDate,
+  DateTime? maxDate,
+  DateTime? minDate,
+  bool startWithTime = false,
+}) async {
+  final colorScheme = getEnteColorScheme(context);
+  final sheet = Container(
+    decoration: BoxDecoration(
+      color: colorScheme.backgroundElevated,
+      borderRadius: const BorderRadius.only(
+        topLeft: Radius.circular(12),
+        topRight: Radius.circular(12),
+      ),
+    ),
+    child: Padding(
+      padding: const EdgeInsets.all(8.0),
+      child: DateTimePickerWidget(
+        (DateTime dateTime) {
+          Navigator.of(context).pop(dateTime);
+        },
+        () {
+          Navigator.of(context).pop(null);
+        },
+        initialDate,
+        minDateTime: minDate,
+        maxDateTime: maxDate,
+      ),
+    ),
+  );
+  final newDate = await showModalBottomSheet<DateTime?>(
+    context: context,
+    isScrollControlled: true,
+    builder: (context) => sheet,
+  );
+  return newDate;
+}
+
+class DateTimePickerWidget extends StatefulWidget {
+  final Function(DateTime) onDateTimeSelected;
+  final Function() onCancel;
+  final DateTime initialDateTime;
+  final DateTime? maxDateTime;
+  final DateTime? minDateTime;
+  final bool startWithTime;
+
+  const DateTimePickerWidget(
+    this.onDateTimeSelected,
+    this.onCancel,
+    this.initialDateTime, {
+    this.maxDateTime,
+    this.minDateTime,
+    this.startWithTime = false,
+    super.key,
+  });
+
+  @override
+  State<DateTimePickerWidget> createState() => _DateTimePickerWidgetState();
+}
+
+class _DateTimePickerWidgetState extends State<DateTimePickerWidget> {
+  late DateTime _selectedDateTime;
+  bool _showTimePicker = false;
+
+  @override
+  void initState() {
+    super.initState();
+    _showTimePicker = widget.startWithTime;
+    _selectedDateTime = widget.initialDateTime;
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final colorScheme = getEnteColorScheme(context);
+    return Container(
+      color: colorScheme.backgroundElevated,
+      child: Column(
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          // Header
+          Padding(
+            padding: const EdgeInsets.symmetric(vertical: 16),
+            child: Align(
+              alignment: Alignment.centerLeft,
+              child: Text(
+                _showTimePicker
+                    ? context.l10n.selectTime
+                    : context.l10n.selectDate,
+                style: TextStyle(
+                  color: colorScheme.textBase,
+                  fontSize: 16,
+                ),
+              ),
+            ),
+          ),
+
+          // Date/Time Picker
+          Container(
+            height: 220,
+            decoration: BoxDecoration(
+              color: colorScheme.backgroundElevated2,
+              borderRadius: BorderRadius.circular(12),
+            ),
+            child: CupertinoTheme(
+              data: CupertinoThemeData(
+                brightness: Brightness.dark,
+                textTheme: CupertinoTextThemeData(
+                  dateTimePickerTextStyle: TextStyle(
+                    color: colorScheme.textBase,
+                    fontSize: 22,
+                  ),
+                ),
+              ),
+              child: CupertinoDatePicker(
+                key: ValueKey(_showTimePicker),
+                mode: _showTimePicker
+                    ? CupertinoDatePickerMode.time
+                    : CupertinoDatePickerMode.date,
+                initialDateTime: _selectedDateTime,
+                minimumDate: widget.minDateTime ?? DateTime(1800),
+                maximumDate: widget.maxDateTime ?? DateTime(2200),
+                use24hFormat: MediaQuery.of(context).alwaysUse24HourFormat,
+                showDayOfWeek: true,
+                onDateTimeChanged: (DateTime newDateTime) {
+                  setState(() {
+                    if (_showTimePicker) {
+                      // Keep the date but update the time
+                      _selectedDateTime = DateTime(
+                        _selectedDateTime.year,
+                        _selectedDateTime.month,
+                        _selectedDateTime.day,
+                        newDateTime.hour,
+                        newDateTime.minute,
+                      );
+                    } else {
+                      // Keep the time but update the date
+                      _selectedDateTime = DateTime(
+                        newDateTime.year,
+                        newDateTime.month,
+                        newDateTime.day,
+                        _selectedDateTime.hour,
+                        _selectedDateTime.minute,
+                      );
+                    }
+
+                    // Ensure the selected date doesn't exceed maxDateTime or minDateTime
+                    if (widget.minDateTime != null &&
+                        _selectedDateTime.isBefore(widget.minDateTime!)) {
+                      _selectedDateTime = widget.minDateTime!;
+                    }
+                    if (widget.maxDateTime != null &&
+                        _selectedDateTime.isAfter(widget.maxDateTime!)) {
+                      _selectedDateTime = widget.maxDateTime!;
+                    }
+                  });
+                },
+              ),
+            ),
+          ),
+
+          // Buttons
+          Padding(
+            padding: const EdgeInsets.symmetric(vertical: 12.0),
+            child: Row(
+              mainAxisAlignment: MainAxisAlignment.spaceBetween,
+              children: [
+                // Cancel Button
+                CupertinoButton(
+                  padding: EdgeInsets.zero,
+                  child: Text(
+                    _showTimePicker
+                        ? context.l10n.previous
+                        : context.l10n.cancel,
+                    style: TextStyle(
+                      color: colorScheme.textBase,
+                      fontSize: 14,
+                    ),
+                  ),
+                  onPressed: () {
+                    if (_showTimePicker) {
+                      // Go back to date picker
+                      setState(() {
+                        _showTimePicker = false;
+                      });
+                    } else {
+                      widget.onCancel();
+                    }
+                  },
+                ),
+
+                // Next/Done Button
+                CupertinoButton(
+                  padding: EdgeInsets.zero,
+                  child: Text(
+                    _showTimePicker ? context.l10n.done : context.l10n.next,
+                    style: TextStyle(
+                      color: colorScheme.primary700,
+                      fontSize: 14,
+                      fontWeight: FontWeight.bold,
+                    ),
+                  ),
+                  onPressed: () {
+                    if (_showTimePicker) {
+                      // We're done, call the callback
+                      widget.onDateTimeSelected(_selectedDateTime);
+                    } else {
+                      // Move to time picker
+                      setState(() {
+                        _showTimePicker = true;
+                      });
+                    }
+                  },
+                ),
+              ],
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
