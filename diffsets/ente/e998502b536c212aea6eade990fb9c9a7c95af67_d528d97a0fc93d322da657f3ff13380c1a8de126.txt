diff --git a/mobile/lib/services/album_home_widget_service.dart b/mobile/lib/services/album_home_widget_service.dart
index 98b5f65554b..7f440cb9f92 100644
--- a/mobile/lib/services/album_home_widget_service.dart
+++ b/mobile/lib/services/album_home_widget_service.dart
@@ -1,5 +1,6 @@
 import 'dart:convert';
 
+import "package:collection/collection.dart";
 import 'package:crypto/crypto.dart';
 import 'package:flutter/material.dart';
 import 'package:fluttertoast/fluttertoast.dart';
@@ -26,7 +27,7 @@ class AlbumHomeWidgetService {
   static const String ANDROID_CLASS_NAME = "EnteAlbumsWidgetProvider";
   static const String IOS_CLASS_NAME = "EnteAlbumWidget";
   static const String ALBUMS_CHANGED_KEY = "albumsChanged.widget";
-  static const String GOT_ALL_KEY = "gotAllAlbums.widget";
+  static const String ALBUMS_STATUS_KEY = "albumsStatusKey.widget";
   static const String TOTAL_ALBUMS_KEY = "totalAlbums";
   static const int MAX_ALBUMS_LIMIT = 50;
 
@@ -106,7 +107,7 @@ class AlbumHomeWidgetService {
 
     _logger.info("Clearing AlbumsHomeWidget");
     await _setTotalAlbums(null);
-    await updateGotAll(true);
+    await updateAlbumsStatus(WidgetStatus.syncedEmpty);
     _hasSyncedAlbums = false;
     await _refreshWidget(message: "AlbumsHomeWidget cleared & updated");
   }
@@ -120,13 +121,15 @@ class AlbumHomeWidgetService {
     await _prefs.setBool(ALBUMS_CHANGED_KEY, value);
   }
 
-  bool checkGotAll() {
-    return _prefs.getBool(GOT_ALL_KEY) ?? false;
+  WidgetStatus getAlbumsStatus() {
+    return WidgetStatus.values.firstWhereOrNull(
+          (v) => v.index == (_prefs.getInt(ALBUMS_STATUS_KEY) ?? 0),
+        ) ??
+        WidgetStatus.notSynced;
   }
 
-  Future<void> updateGotAll(bool value) async {
-    _logger.info("Updating got all albums flag to $value");
-    await _prefs.setBool(GOT_ALL_KEY, value);
+  Future<void> updateAlbumsStatus(WidgetStatus value) async {
+    await _prefs.setInt(ALBUMS_STATUS_KEY, value.index);
   }
 
   Future<void> checkPendingAlbumsSync({bool addDelay = true}) async {
@@ -299,10 +302,15 @@ class AlbumHomeWidgetService {
     final lastHash = getAlbumsLastHash();
 
     if (currentHash == lastHash) {
-      final didGotAllValues = checkGotAll();
-      if (didGotAllValues) {
-        _logger.info("Albums already synced, no action needed");
-        return false;
+      final saveStatus = getAlbumsStatus();
+
+      switch (saveStatus) {
+        case WidgetStatus.syncedPartially:
+          return await countHomeWidgets() > 0;
+        case WidgetStatus.syncedEmpty:
+        case WidgetStatus.syncedAll:
+          return false;
+        default:
       }
     }
 
@@ -391,7 +399,7 @@ class AlbumHomeWidgetService {
     final bool isWidgetPresent = await countHomeWidgets() > 0;
     final limit = isWidgetPresent ? MAX_ALBUMS_LIMIT : 5;
 
-    await updateGotAll(false);
+    await updateAlbumsStatus(WidgetStatus.notSynced);
 
     for (final entry in albumsWithFiles.entries) {
       final albumId = entry.key;
@@ -421,10 +429,11 @@ class AlbumHomeWidgetService {
           await _setTotalAlbums(renderedCount);
 
           // Show update toast after first item is rendered
-          if (renderedCount == 1 && albumFiles.length > 1) {
+          if (renderedCount == 1) {
             await _refreshWidget(
               message: "First album fetched, updating widget",
             );
+            await updateAlbumsStatus(WidgetStatus.syncedPartially);
           }
 
           renderedCount++;
@@ -447,11 +456,14 @@ class AlbumHomeWidgetService {
     final hash = _calculateHash(selectedAlbumIds);
     await setAlbumsLastHash(hash);
 
-    await updateGotAll(isWidgetPresent);
     if (renderedCount == 0) {
       return;
     }
 
+    if (isWidgetPresent) {
+      await updateAlbumsStatus(WidgetStatus.syncedAll);
+    }
+
     await _refreshWidget(
       message: "Switched to next albums set, total: $renderedCount",
     );
diff --git a/mobile/lib/services/home_widget_service.dart b/mobile/lib/services/home_widget_service.dart
index 29256d2d206..aac3853aad7 100644
--- a/mobile/lib/services/home_widget_service.dart
+++ b/mobile/lib/services/home_widget_service.dart
@@ -16,6 +16,13 @@ import 'package:photos/services/smart_memories_service.dart';
 import 'package:photos/utils/thumbnail_util.dart';
 import 'package:shared_preferences/shared_preferences.dart';
 
+enum WidgetStatus {
+  notSynced,
+  syncedPartially,
+  syncedEmpty,
+  syncedAll,
+}
+
 /// Service to manage home screen widgets across the application
 /// Handles widget initialization, updates, and interaction with platform-specific widget APIs
 class HomeWidgetService {
diff --git a/mobile/lib/services/memory_home_widget_service.dart b/mobile/lib/services/memory_home_widget_service.dart
index 8076f75cf78..14e6af46635 100644
--- a/mobile/lib/services/memory_home_widget_service.dart
+++ b/mobile/lib/services/memory_home_widget_service.dart
@@ -1,3 +1,4 @@
+import "package:collection/collection.dart";
 import 'package:flutter/material.dart';
 import 'package:fluttertoast/fluttertoast.dart';
 import 'package:logging/logging.dart';
@@ -18,6 +19,7 @@ class MemoryHomeWidgetService {
       "selectedOnThisDayMemoriesHW";
   static const String ANDROID_CLASS_NAME = "EnteMemoryWidgetProvider";
   static const String IOS_CLASS_NAME = "EnteMemoryWidget";
+  static const String MEMORY_STATUS_KEY = "memoryStatusKey.widget";
   static const String MEMORY_CHANGED_KEY = "memoryChanged.widget";
   static const String TOTAL_MEMORIES_KEY = "totalMemories";
   static const int MAX_MEMORIES_LIMIT = 50;
@@ -100,6 +102,7 @@ class MemoryHomeWidgetService {
     _logger.info("Clearing MemoryHomeWidget");
     await _setTotalMemories(null);
     _hasSyncedMemory = false;
+    await updateMemoriesStatus(WidgetStatus.syncedEmpty);
     await _refreshWidget(message: "MemoryHomeWidget cleared & updated");
   }
 
@@ -108,6 +111,17 @@ class MemoryHomeWidgetService {
     await _prefs.setBool(MEMORY_CHANGED_KEY, value);
   }
 
+  WidgetStatus getMemoriesStatus() {
+    return WidgetStatus.values.firstWhereOrNull(
+          (v) => v.index == (_prefs.getInt(MEMORY_STATUS_KEY) ?? 0),
+        ) ??
+        WidgetStatus.notSynced;
+  }
+
+  Future<void> updateMemoriesStatus(WidgetStatus value) async {
+    await _prefs.setInt(MEMORY_STATUS_KEY, value.index);
+  }
+
   Future<void> checkPendingMemorySync({bool addDelay = true}) async {
     if (addDelay) {
       await Future.delayed(const Duration(seconds: 5));
@@ -205,9 +219,16 @@ class MemoryHomeWidgetService {
       return true;
     }
 
-    // Check if we should force fetch new memories
-    final cachedMemories = await _getMemoriesForWidget();
-    return isWidgetEmpty && cachedMemories.isNotEmpty;
+    final memoriesStatus = getMemoriesStatus();
+    switch (memoriesStatus) {
+      case WidgetStatus.notSynced:
+        return true;
+      case WidgetStatus.syncedPartially:
+        return await countHomeWidgets() > 0;
+      case WidgetStatus.syncedEmpty:
+      case WidgetStatus.syncedAll:
+        return false;
+    }
   }
 
   Future<List<SmartMemory>> _getMemoriesForWidget() async {
@@ -286,6 +307,8 @@ class MemoryHomeWidgetService {
     final bool isWidgetPresent = await countHomeWidgets() > 0;
     final limit = isWidgetPresent ? MAX_MEMORIES_LIMIT : 5;
 
+    await updateMemoriesStatus(WidgetStatus.notSynced);
+
     for (final entry in memoriesWithFiles.entries) {
       final memoryTitle = entry.key;
       final memoryFiles = entry.value;
@@ -311,6 +334,7 @@ class MemoryHomeWidgetService {
             await _refreshWidget(
               message: "First memory fetched, updating widget",
             );
+            await updateMemoriesStatus(WidgetStatus.syncedPartially);
           }
 
           renderedCount++;
@@ -334,6 +358,10 @@ class MemoryHomeWidgetService {
       return;
     }
 
+    if (isWidgetPresent) {
+      await updateMemoriesStatus(WidgetStatus.syncedAll);
+    }
+
     await _refreshWidget(
       message: "Switched to next memory set, total: $renderedCount",
     );
diff --git a/mobile/lib/services/people_home_widget_service.dart b/mobile/lib/services/people_home_widget_service.dart
index e65c53304a5..5150ca02181 100644
--- a/mobile/lib/services/people_home_widget_service.dart
+++ b/mobile/lib/services/people_home_widget_service.dart
@@ -1,3 +1,4 @@
+import "package:collection/collection.dart";
 import 'package:flutter/material.dart';
 import 'package:fluttertoast/fluttertoast.dart';
 import 'package:logging/logging.dart';
@@ -22,6 +23,7 @@ class PeopleHomeWidgetService {
   static const String SELECTED_PEOPLE_KEY = "selectedPeopleHW";
   static const String ANDROID_CLASS_NAME = "EntePeopleWidgetProvider";
   static const String IOS_CLASS_NAME = "EntePeopleWidget";
+  static const String PEOPLE_STATUS_KEY = "peopleStatusKey.widget";
   static const String PEOPLE_CHANGED_KEY = "peopleChanged.widget";
   static const String TOTAL_PEOPLE_KEY = "totalPeople";
   static const int MAX_PEOPLE_LIMIT = 50;
@@ -107,9 +109,21 @@ class PeopleHomeWidgetService {
     _logger.info("Clearing PeopleHomeWidget");
     await _setTotalPeople(null);
     _hasSyncedPeople = false;
+    await updatePeopleStatus(WidgetStatus.syncedEmpty);
     await _refreshWidget(message: "PeopleHomeWidget cleared & updated");
   }
 
+  WidgetStatus getPeopleStatus() {
+    return WidgetStatus.values.firstWhereOrNull(
+          (v) => v.index == (_prefs.getInt(PEOPLE_STATUS_KEY) ?? 0),
+        ) ??
+        WidgetStatus.notSynced;
+  }
+
+  Future<void> updatePeopleStatus(WidgetStatus value) async {
+    await _prefs.setInt(PEOPLE_STATUS_KEY, value.index);
+  }
+
   Future<void> updatePeopleChanged(bool value) async {
     _logger.info("Updating people changed flag to $value");
     await _prefs.setBool(PEOPLE_CHANGED_KEY, value);
@@ -253,7 +267,20 @@ class PeopleHomeWidgetService {
 
   Future<bool> _shouldForceFetchPeople(bool isPeopleEmpty) async {
     final peopleChanged = _prefs.getBool(PEOPLE_CHANGED_KEY);
-    return peopleChanged ?? true;
+    if (peopleChanged ?? true) {
+      return true;
+    }
+
+    final peopleStatus = getPeopleStatus();
+    switch (peopleStatus) {
+      case WidgetStatus.notSynced:
+        return true;
+      case WidgetStatus.syncedPartially:
+        return await countHomeWidgets() > 0;
+      case WidgetStatus.syncedEmpty:
+      case WidgetStatus.syncedAll:
+        return false;
+    }
   }
 
   Future<List<String>> _getEffectiveSelectedPeopleIds() async {
@@ -351,6 +378,7 @@ class PeopleHomeWidgetService {
 
     final bool isWidgetPresent = await countHomeWidgets() > 0;
     final limit = isWidgetPresent ? MAX_PEOPLE_LIMIT : 5;
+    await updatePeopleStatus(WidgetStatus.notSynced);
 
     for (final entry in peopleWithFiles.entries) {
       final personId = entry.key;
@@ -383,6 +411,7 @@ class PeopleHomeWidgetService {
             await _refreshWidget(
               message: "First person fetched, updating widget",
             );
+            await updatePeopleStatus(WidgetStatus.syncedPartially);
           }
 
           renderedCount++;
@@ -404,6 +433,10 @@ class PeopleHomeWidgetService {
       return;
     }
 
+    if (isWidgetPresent) {
+      await updatePeopleStatus(WidgetStatus.syncedAll);
+    }
+
     await _refreshWidget(
       message: "Switched to next people set, total: $renderedCount",
     );
