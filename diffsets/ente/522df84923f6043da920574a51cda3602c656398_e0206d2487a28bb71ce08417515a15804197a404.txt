diff --git a/mobile/apps/auth/lib/models/code.dart b/mobile/apps/auth/lib/models/code.dart
index 452ae4e3f34..2d939c467ea 100644
--- a/mobile/apps/auth/lib/models/code.dart
+++ b/mobile/apps/auth/lib/models/code.dart
@@ -33,6 +33,12 @@ class Code {
   final Object? err;
   bool get hasError => err != null;
 
+  /// Stable identifier for UI state (selection, animations, etc.).
+  /// Prefer generatedID since it is unique per stored code; fall back to rawData
+  /// when the code has not been persisted yet.
+  String get selectionKey =>
+      generatedID != null ? generatedID!.toString() : rawData;
+
   String get issuerAccount =>
       account.isNotEmpty ? '$issuer ($account)' : issuer;
 
diff --git a/mobile/apps/auth/lib/services/deduplication_service.dart b/mobile/apps/auth/lib/services/deduplication_service.dart
index 5ca4b044d72..0e22b58776e 100644
--- a/mobile/apps/auth/lib/services/deduplication_service.dart
+++ b/mobile/apps/auth/lib/services/deduplication_service.dart
@@ -23,26 +23,39 @@ class DeduplicationService {
   Future<List<DuplicateCodes>> _getDuplicateCodes() async {
     final codes = await CodeStore.instance.getAllCodes();
     final List<DuplicateCodes> duplicateCodes = [];
-    Map<String, List<Code>> uniqueCodes = {};
+    final Map<String, List<Code>> groupedCodes = {};
 
     for (final code in codes) {
       if (code.hasError || code.isTrashed) continue;
 
-      final uniqueKey = "${code.secret}_${code.issuer}_${code.account}";
+      final uniqueKey = _buildDuplicateKey(code);
 
-      if (uniqueCodes.containsKey(uniqueKey)) {
-        uniqueCodes[uniqueKey]!.add(code);
+      if (groupedCodes.containsKey(uniqueKey)) {
+        groupedCodes[uniqueKey]!.add(code);
       } else {
-        uniqueCodes[uniqueKey] = [code];
+        groupedCodes[uniqueKey] = [code];
       }
     }
-    for (final key in uniqueCodes.keys) {
-      if (uniqueCodes[key]!.length > 1) {
-        duplicateCodes.add(DuplicateCodes(key, uniqueCodes[key]!));
+    for (final entry in groupedCodes.entries) {
+      if (entry.value.length > 1) {
+        duplicateCodes.add(DuplicateCodes(entry.key, entry.value));
       }
     }
     return duplicateCodes;
   }
+
+  String _buildDuplicateKey(Code code) {
+    final normalizedIssuer = code.issuer.trim().toLowerCase();
+    final normalizedSecret = code.secret.trim();
+    return [
+      normalizedSecret,
+      normalizedIssuer,
+      code.type.name,
+      code.algorithm.name,
+      code.digits.toString(),
+      code.period.toString(),
+    ].join("_");
+  }
 }
 
 class DuplicateCodes {
diff --git a/mobile/apps/auth/lib/ui/code_widget.dart b/mobile/apps/auth/lib/ui/code_widget.dart
index 1a19b280a93..dae5e1c04a7 100644
--- a/mobile/apps/auth/lib/ui/code_widget.dart
+++ b/mobile/apps/auth/lib/ui/code_widget.dart
@@ -36,6 +36,14 @@ class CodeWidget extends StatefulWidget {
   final bool isCompactMode;
   final CodeSortKey? sortKey;
   final bool isReordering;
+  final bool enableDesktopContextActions;
+  final List<Code> Function()? selectedCodesBuilder;
+  final Future<void> Function()? onMultiPinToggle;
+  final Future<void> Function()? onMultiUnpin;
+  final Future<void> Function()? onMultiAddTag;
+  final Future<void> Function()? onMultiTrash;
+  final Future<void> Function()? onMultiRestore;
+  final Future<void> Function()? onMultiDeleteForever;
 
   const CodeWidget(
     this.code, {
@@ -43,6 +51,14 @@ class CodeWidget extends StatefulWidget {
     required this.isCompactMode,
     this.sortKey,
     this.isReordering = false,
+    this.enableDesktopContextActions = false,
+    this.selectedCodesBuilder,
+    this.onMultiPinToggle,
+    this.onMultiUnpin,
+    this.onMultiAddTag,
+    this.onMultiTrash,
+    this.onMultiRestore,
+    this.onMultiDeleteForever,
   });
 
   @override
@@ -220,7 +236,8 @@ class _CodeWidgetState extends State<CodeWidget> {
       return ValueListenableBuilder<Set<String>>(
         valueListenable: CodeDisplayStore.instance.selectedCodeIds,
         builder: (context, selectedIds, child) {
-          final isSelected = selectedIds.contains(widget.code.secret);
+          final isSelected =
+              selectedIds.contains(widget.code.selectionKey);
 
           return Stack(
             children: [
@@ -247,7 +264,7 @@ class _CodeWidgetState extends State<CodeWidget> {
                       onTap: () {
                         final store = CodeDisplayStore.instance;
                         if (store.isSelectionModeActive.value) {
-                          store.toggleSelection(widget.code.secret);
+                          store.toggleSelection(widget.code.selectionKey);
                         } else {
                           _copyCurrentOTPToClipboard();
                         }
@@ -263,7 +280,7 @@ class _CodeWidgetState extends State<CodeWidget> {
                           ? null
                           : () {
                               CodeDisplayStore.instance.toggleSelection(
-                                widget.code.secret,
+                                widget.code.selectionKey,
                               );
                             },
                       child: getCardContents(l10n, isSelected: isSelected),
@@ -303,64 +320,23 @@ class _CodeWidgetState extends State<CodeWidget> {
       child: Builder(
         builder: (context) {
           if (PlatformUtil.isDesktop()) {
-            return ContextMenuRegion(
-              contextMenu: ContextMenu(
-                entries: <ContextMenuEntry>[
-                  if (!widget.code.isTrashed &&
-                      widget.code.type.isTOTPCompatible)
-                    MenuItem(
-                      label: context.l10n.share,
-                      icon: Icons.adaptive.share_outlined,
-                      onSelected: () => _onSharePressed(null),
-                    ),
-                  if (!widget.code.isTrashed)
-                    MenuItem(
-                      label: context.l10n.qr,
-                      icon: Icons.qr_code_2_outlined,
-                      onSelected: () => _onShowQrPressed(null),
-                    ),
-                  if (widget.code.note.isNotEmpty)
-                    MenuItem(
-                      label: context.l10n.notes,
-                      icon: Icons.notes_outlined,
-                      onSelected: () => _onShowNotesPressed(null),
-                    ),
-                  if (!widget.code.isTrashed && !ignorePin)
-                    MenuItem(
-                      label:
-                          widget.code.isPinned ? l10n.unpinText : l10n.pinText,
-                      icon: widget.code.isPinned
-                          ? Icons.push_pin
-                          : Icons.push_pin_outlined,
-                      onSelected: () => _onPinPressed(null),
-                    ),
-                  if (!widget.code.isTrashed)
-                    MenuItem(
-                      label: l10n.edit,
-                      icon: Icons.edit,
-                      onSelected: () => _onEditPressed(null),
-                    )
-                  else
-                    MenuItem(
-                      label: l10n.restore,
-                      icon: Icons.restore_outlined,
-                      onSelected: () => _onRestoreClicked(null),
-                    ),
-                  const MenuDivider(),
-                  MenuItem(
-                    label: widget.code.isTrashed ? l10n.delete : l10n.trash,
-                    value: l10n.delete,
-                    icon: widget.code.isTrashed
-                        ? Icons.delete_forever
-                        : Icons.delete,
-                    onSelected: () => widget.code.isTrashed
-                        ? _onDeletePressed(null)
-                        : _onTrashPressed(null),
+            return ValueListenableBuilder<Set<String>>(
+              valueListenable: CodeDisplayStore.instance.selectedCodeIds,
+              builder: (context, selectedIds, _) {
+                final menuEntries = _buildContextMenuEntries(
+                  context,
+                  l10n,
+                  selectedIds,
+                );
+
+                return ContextMenuRegion(
+                  contextMenu: ContextMenu(
+                    entries: menuEntries,
+                    padding: const EdgeInsets.all(8.0),
                   ),
-                ],
-                padding: const EdgeInsets.all(8.0),
-              ),
-              child: clippedCard(l10n),
+                  child: clippedCard(l10n),
+                );
+              },
             );
           }
 
@@ -451,7 +427,6 @@ class _CodeWidgetState extends State<CodeWidget> {
     final double indicatorSize = isCompactMode ? 16 : 20;
     const double indicatorPadding = 4;
     final double indicatorSlotWidth = indicatorSize + indicatorPadding;
-    const double accountTranslate = 0;
     final TextStyle? issuerStyle = isCompactMode
         ? Theme.of(context).textTheme.bodyMedium
         : Theme.of(context).textTheme.titleLarge;
@@ -494,8 +469,9 @@ class _CodeWidgetState extends State<CodeWidget> {
                                   key: const ValueKey('selected-indicator'),
                                   alignment: Alignment.centerLeft,
                                   child: Padding(
-                                    padding: EdgeInsets.only(
-                                        right: indicatorPadding),
+                                    padding: const EdgeInsets.only(
+                                      right: indicatorPadding,
+                                    ),
                                     child: SizedBox(
                                       width: indicatorSize,
                                       height: indicatorSize,
@@ -568,6 +544,216 @@ class _CodeWidgetState extends State<CodeWidget> {
     );
   }
 
+  List<ContextMenuEntry> _buildContextMenuEntries(
+    BuildContext context,
+    AppLocalizations l10n,
+    Set<String> selectedIds,
+  ) {
+    if (!widget.enableDesktopContextActions) {
+      return _buildSingleSelectionMenu(l10n);
+    }
+
+    final multiEntries =
+        _buildMultiSelectionContextMenu(l10n, selectedIds);
+    if (multiEntries != null) {
+      return multiEntries;
+    }
+
+    return _buildSingleSelectionMenu(l10n);
+  }
+
+  List<ContextMenuEntry> _buildSingleSelectionMenu(AppLocalizations l10n) {
+    final entries = <ContextMenuEntry>[];
+
+    if (!widget.code.isTrashed && widget.code.type.isTOTPCompatible) {
+      entries.add(
+        MenuItem(
+          label: l10n.share,
+          icon: Icons.adaptive.share_outlined,
+          onSelected: () => _onSharePressed(null),
+        ),
+      );
+    }
+
+    if (!widget.code.isTrashed) {
+      entries.add(
+        MenuItem(
+          label: l10n.qr,
+          icon: Icons.qr_code_2_outlined,
+          onSelected: () => _onShowQrPressed(null),
+        ),
+      );
+      entries.add(
+        MenuItem(
+          label: l10n.addTag,
+          icon: Icons.local_offer_outlined,
+          onSelected: () {
+            CodeDisplayStore.instance.selectedCodeIds.value =
+                {widget.code.selectionKey};
+            widget.onMultiAddTag?.call();
+          },
+        ),
+      );
+    }
+
+    if (widget.code.note.isNotEmpty) {
+      entries.add(
+        MenuItem(
+          label: l10n.notes,
+          icon: Icons.notes_outlined,
+          onSelected: () => _onShowNotesPressed(null),
+        ),
+      );
+    }
+
+    if (!widget.code.isTrashed && !ignorePin) {
+      entries.add(
+        MenuItem(
+          label: widget.code.isPinned ? l10n.unpinText : l10n.pinText,
+          icon: widget.code.isPinned
+              ? Icons.push_pin
+              : Icons.push_pin_outlined,
+          onSelected: () => _onPinPressed(null),
+        ),
+      );
+    }
+
+    if (!widget.code.isTrashed) {
+      entries.add(
+        MenuItem(
+          label: l10n.edit,
+          icon: Icons.edit,
+          onSelected: () => _onEditPressed(null),
+        ),
+      );
+    } else {
+      entries.add(
+        MenuItem(
+          label: l10n.restore,
+          icon: Icons.restore_outlined,
+          onSelected: () => _onRestoreClicked(null),
+        ),
+      );
+    }
+
+    entries.add(const MenuDivider());
+    entries.add(
+      MenuItem(
+        label: widget.code.isTrashed ? l10n.delete : l10n.trash,
+        value: l10n.delete,
+        icon: widget.code.isTrashed ? Icons.delete_forever : Icons.delete,
+        onSelected: () => widget.code.isTrashed
+            ? _onDeletePressed(null)
+            : _onTrashPressed(null),
+      ),
+    );
+
+    return entries;
+  }
+
+  List<ContextMenuEntry>? _buildMultiSelectionContextMenu(
+    AppLocalizations l10n,
+    Set<String> selectedIds,
+  ) {
+    if (selectedIds.length <= 1 ||
+        !selectedIds.contains(widget.code.selectionKey)) {
+      return null;
+    }
+
+    final selectedCodes = widget.selectedCodesBuilder?.call() ?? const <Code>[];
+    if (selectedCodes.isEmpty) {
+      return null;
+    }
+
+    final entries = <ContextMenuEntry>[];
+    final bool allTrashed = selectedCodes.every((code) => code.isTrashed);
+
+    if (allTrashed) {
+      if (widget.onMultiRestore != null) {
+        entries.add(
+          MenuItem(
+            label: l10n.restore,
+            icon: Icons.restore_outlined,
+            onSelected: () => _invokeMultiAction(widget.onMultiRestore),
+          ),
+        );
+      }
+      if (widget.onMultiDeleteForever != null) {
+        entries.add(
+          MenuItem(
+            label: l10n.delete,
+            icon: Icons.delete_forever,
+            onSelected: () =>
+                _invokeMultiAction(widget.onMultiDeleteForever),
+          ),
+        );
+      }
+      return entries.isEmpty ? null : entries;
+    }
+
+    final bool allPinned = selectedCodes.every((code) => code.isPinned);
+    final bool anyPinned = selectedCodes.any((code) => code.isPinned);
+    final bool isMixedPinned = anyPinned && !allPinned;
+
+    if (isMixedPinned) {
+      if (widget.onMultiPinToggle != null) {
+        entries.add(
+          MenuItem(
+            label: l10n.pinText,
+            icon: Icons.push_pin_outlined,
+            onSelected: () => _invokeMultiAction(widget.onMultiPinToggle),
+          ),
+        );
+      }
+      if (widget.onMultiUnpin != null) {
+        entries.add(
+          MenuItem(
+            label: l10n.unpinText,
+            icon: Icons.push_pin,
+            onSelected: () => _invokeMultiAction(widget.onMultiUnpin),
+          ),
+        );
+      }
+    } else {
+      if (widget.onMultiPinToggle != null) {
+        entries.add(
+          MenuItem(
+            label: allPinned ? l10n.unpinText : l10n.pinText,
+            icon: allPinned ? Icons.push_pin : Icons.push_pin_outlined,
+            onSelected: () => _invokeMultiAction(widget.onMultiPinToggle),
+          ),
+        );
+      }
+    }
+
+    if (widget.onMultiAddTag != null) {
+      entries.add(
+        MenuItem(
+          label: l10n.addTag,
+          icon: Icons.local_offer_outlined,
+          onSelected: () => _invokeMultiAction(widget.onMultiAddTag),
+        ),
+      );
+    }
+
+    if (widget.onMultiTrash != null) {
+      entries.add(
+        MenuItem(
+          label: l10n.trash,
+          icon: Icons.delete_outline,
+          onSelected: () => _invokeMultiAction(widget.onMultiTrash),
+        ),
+      );
+    }
+
+    return entries.isEmpty ? null : entries;
+  }
+
+  void _invokeMultiAction(Future<void> Function()? action) {
+    if (action == null) return;
+    unawaited(action());
+  }
+
   Widget _getIcon() {
     final String iconData;
     if (widget.code.display.isCustomIcon) {
diff --git a/mobile/apps/auth/lib/ui/home_page.dart b/mobile/apps/auth/lib/ui/home_page.dart
index 692641330fa..c7733d5e4ad 100644
--- a/mobile/apps/auth/lib/ui/home_page.dart
+++ b/mobile/apps/auth/lib/ui/home_page.dart
@@ -96,6 +96,7 @@ class _HomePageState extends State<HomePage> {
   bool hasTrashedCodes = false;
   bool hasNonTrashedCodes = false;
   bool isCompactMode = false;
+  int _currentGridColumns = 1;
 
   late CodeSortKey _codeSortKey;
   final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
@@ -130,7 +131,9 @@ class _HomePageState extends State<HomePage> {
 
   void _onAddTagPressed() {
   final selectedIds = _codeDisplayStore.selectedCodeIds.value;
-  final selectedCodes = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+  final selectedCodes =
+      _allCodes?.where((c) => selectedIds.contains(c.selectionKey)).toList() ??
+          [];
 
   if (selectedCodes.isEmpty) return;
 
@@ -152,7 +155,10 @@ Future<void> _onRestoreSelectedPressed() async {
   FocusScope.of(context).requestFocus();
 
   try {
-    final codesToRestore = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+    final codesToRestore = _allCodes
+            ?.where((c) => selectedIds.contains(c.selectionKey))
+            .toList() ??
+        [];
     for (final code in codesToRestore) {
       final updatedCode = code.copyWith(display: code.display.copyWith(trashed: false));
       unawaited(CodeStore.instance.addCode(updatedCode));
@@ -188,7 +194,10 @@ Future<void> _onDeleteForeverPressed() async {
     isCritical: true,
     firstButtonOnTap: () async {
       try {
-        final codesToDelete = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+        final codesToDelete = _allCodes
+                ?.where((c) => selectedIds.contains(c.selectionKey))
+                .toList() ??
+            [];
         for (final code in codesToDelete) {
           await CodeStore.instance.removeCode(code);
         }
@@ -239,11 +248,31 @@ Widget _buildTrashSelectActions() {
   );
 }
 
+  List<Code> _selectedCodesForContextMenu() {
+  final selectedIds = _codeDisplayStore.selectedCodeIds.value;
+  if (selectedIds.isEmpty) return const <Code>[];
+
+  return _allCodes
+          ?.where((code) => selectedIds.contains(code.selectionKey))
+          .toList() ??
+      const <Code>[];
+}
+
+  int _calculateGridColumnCount(BuildContext context) {
+  final double width = MediaQuery.sizeOf(context).width;
+  final double tileWidth = isCompactMode ? 320 : 400;
+  final int computedCount = width ~/ tileWidth;
+  return computedCount <= 0 ? 1 : computedCount;
+}
+
   Future<void> _onPinSelectedPressed() async {
   final selectedIds = _codeDisplayStore.selectedCodeIds.value;
   if (selectedIds.isEmpty) return;
 
-  final codesToUpdate = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+  final codesToUpdate = _allCodes
+          ?.where((c) => selectedIds.contains(c.selectionKey))
+          .toList() ??
+      [];
   if (codesToUpdate.isEmpty) return;
 
   // Determine the state of the current selection (pinned/unpinned)
@@ -287,7 +316,10 @@ Widget _buildTrashSelectActions() {
   final selectedIds = _codeDisplayStore.selectedCodeIds.value;
   if (selectedIds.isEmpty) return;
 
-  final codesToUpdate = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+  final codesToUpdate = _allCodes
+          ?.where((c) => selectedIds.contains(c.selectionKey))
+          .toList() ??
+      [];
   if (codesToUpdate.isEmpty) return;
 
   int unpinnedCount = 0;
@@ -330,7 +362,8 @@ Widget _buildTrashSelectActions() {
 
     body: ((){
       if (selectedIds.length == 1){
-        final code = _allCodes!.firstWhere((c) => c.secret == selectedIds.first);
+        final code = _allCodes!
+            .firstWhere((c) => c.selectionKey == selectedIds.first);
         final issuerAccount = code.account.isNotEmpty ? '${code.issuer} (${code.account})' : code.issuer;
         return l10n.trashCodeMessage(issuerAccount);
       } 
@@ -343,7 +376,10 @@ Widget _buildTrashSelectActions() {
     isCritical: true, 
     firstButtonOnTap: () async {
       try {
-        final codesToTrash = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+        final codesToTrash = _allCodes
+                ?.where((c) => selectedIds.contains(c.selectionKey))
+                .toList() ??
+            [];
 
         for (final code in codesToTrash) {
           final updatedCode = code.copyWith(
@@ -491,7 +527,10 @@ Widget _buildSingleSelectActions(Code code) {
               valueListenable: _codeDisplayStore.selectedCodeIds,
               builder: (context, selectedIds, child) {
                 if (selectedIds.isEmpty) return const Expanded(child: SizedBox.shrink());
-                final selectedCodes = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+                final selectedCodes = _allCodes
+                        ?.where((c) => selectedIds.contains(c.selectionKey))
+                        .toList() ??
+                    [];
                 if (selectedCodes.isEmpty) return const Expanded(child: SizedBox.shrink());
                 final bool allArePinned = selectedCodes.every((code) => code.isPinned);
                 
@@ -548,7 +587,10 @@ Widget _buildMultiSelectActions(Set<String> selectedIds) {
       builder: (context, selectedIds, child) {
         if (selectedIds.isEmpty) return const SizedBox.shrink();
 
-        final selectedCodes = _allCodes?.where((c) => selectedIds.contains(c.secret)).toList() ?? [];
+        final selectedCodes = _allCodes
+                ?.where((c) => selectedIds.contains(c.selectionKey))
+                .toList() ??
+            [];
         if (selectedCodes.isEmpty) return const SizedBox.shrink();
 
         final bool allArePinned = selectedCodes.every((code) => code.isPinned);
@@ -693,7 +735,7 @@ Widget _buildActionButtons() {
       final Widget actionWidget;
       if (selectedIds.length == 1) {
         final selectedCode = _allCodes?.firstWhereOrNull(
-          (c) => c.secret == selectedIds.first,
+          (c) => c.selectionKey == selectedIds.first,
         );
         if (selectedCode == null) return const SizedBox.shrink();
         actionWidget = _buildSingleSelectActions(selectedCode);
@@ -750,7 +792,9 @@ Widget _buildActionButtons() {
           width: 1,
         ),
       ),
-      shadowColor: isDarkMode ? Colors.black.withOpacity(0.7) : Colors.grey.withOpacity(0.5),
+      shadowColor: isDarkMode
+          ? Colors.black.withValues(alpha: 0.7)
+          : Colors.grey.withValues(alpha: 0.5),
       elevation: 4,
       color: isDarkMode
           ? colorScheme.fillFaint
@@ -773,7 +817,9 @@ Widget _buildActionButtons() {
                     child: InkWell(
                       onTap: () {
                         final allVisibleCodeIds =
-                            _filteredCodes.map((c) => c.secret).toSet();
+                            _filteredCodes
+                                .map((c) => c.selectionKey)
+                                .toSet();
                         _codeDisplayStore.selectedCodeIds.value = allVisibleCodeIds;
                       },
                       child: Padding(
@@ -805,7 +851,9 @@ Widget _buildActionButtons() {
                           return const SizedBox.shrink();
                         }
                         final selectedCodes = _allCodes
-                                ?.where((c) => selectedIds.contains(c.secret))
+                                ?.where(
+                                  (c) => selectedIds.contains(c.selectionKey),
+                                )
                                 .toList() ??
                             [];
                         final codesToShow = selectedCodes.take(3).toList();
@@ -1198,6 +1246,10 @@ Widget build(BuildContext context) {
   return ValueListenableBuilder<bool>(
     valueListenable: _codeDisplayStore.isSelectionModeActive,
     builder: (context, isSelecting, child) {
+      final bool isDesktop = PlatformUtil.isDesktop();
+      final appBar = isDesktop && isSelecting && _currentGridColumns > 1
+          ? _buildDesktopSelectionAppBar(l10n)
+          : _buildStandardAppBar(l10n, isDesktop);
       return PopScope(
         canPop: false,
         onPopInvokedWithResult: (_, result) async {
@@ -1231,81 +1283,11 @@ Widget build(BuildContext context) {
             },
           ),
           ),
-          bottomNavigationBar: isSelecting ? _buildSelectionActionBar() : null,
+          bottomNavigationBar: isSelecting && (!isDesktop || _currentGridColumns <= 1)
+              ? _buildSelectionActionBar()
+              : null,
           resizeToAvoidBottomInset: false,
-          appBar: AppBar(
-            backgroundColor: Theme.of(context).scaffoldBackgroundColor,
-            surfaceTintColor: Colors.transparent,
-            title: !_showSearchBox
-                ? const Text('Ente Auth', style: brandStyleMedium)
-                : TextField(
-                    autocorrect: false,
-                    enableSuggestions: false,
-                    autofocus: _autoFocusSearch,
-                    controller: _textController,
-                    onChanged: (val) {
-                      _searchText = val;
-                      _applyFilteringAndRefresh();
-                    },
-                    decoration: InputDecoration(
-                      hintText: l10n.searchHint,
-                      border: InputBorder.none,
-                      focusedBorder: InputBorder.none,
-                    ),
-                    focusNode: searchBoxFocusNode,
-                  ),
-            centerTitle: PlatformUtil.isDesktop() ? false : true,
-            actions: <Widget>[
-              Padding(
-                padding: const EdgeInsets.all(8.0),
-                child: SortCodeMenuWidget(
-                  currentKey: PreferenceService.instance.codeSortKey(),
-                  onSelected: (newOrder) async {
-                    await PreferenceService.instance.setCodeSortKey(newOrder);
-                    if (newOrder == CodeSortKey.manual &&
-                        newOrder == _codeSortKey) {
-                      await navigateToReorderPage(_allCodes!);
-                    }
-                    setState(() {
-                      _codeSortKey = newOrder;
-                    });
-                    if (mounted) {
-                      _applyFilteringAndRefresh();
-                    }
-                  },
-                ),
-              ),
-              if (PlatformUtil.isDesktop())
-                IconButton(
-                  icon: const Icon(Icons.lock),
-                  tooltip: l10n.appLock,
-                  padding: const EdgeInsets.all(8.0),
-                  onPressed: () async {
-                    await navigateToLockScreen();
-                  },
-                ),
-              IconButton(
-                icon: _showSearchBox
-                    ? const Icon(Icons.clear)
-                    : const Icon(Icons.search),
-                tooltip: l10n.search,
-                padding: const EdgeInsets.all(8.0),
-                onPressed: () {
-                  setState(() {
-                    _showSearchBox = !_showSearchBox;
-                    if (!_showSearchBox) {
-                      _textController.clear();
-                      _searchText = "";
-                    } else {
-                      _searchText = _textController.text;
-                      searchBoxFocusNode.requestFocus();
-                    }
-                    _applyFilteringAndRefresh();
-                  });
-                },
-              ),
-            ],
-          ),
+          appBar: appBar,
           floatingActionButton: isSelecting
               ? null
               : (!_hasLoaded ||
@@ -1319,13 +1301,151 @@ Widget build(BuildContext context) {
   );
 }
 
+PreferredSizeWidget _buildStandardAppBar(
+  AppLocalizations l10n,
+  bool isDesktop,
+) {
+  return AppBar(
+    backgroundColor: Theme.of(context).scaffoldBackgroundColor,
+    surfaceTintColor: Colors.transparent,
+    title: !_showSearchBox
+        ? const Text('Ente Auth', style: brandStyleMedium)
+        : TextField(
+            autocorrect: false,
+            enableSuggestions: false,
+            autofocus: _autoFocusSearch,
+            controller: _textController,
+            onChanged: (val) {
+              _searchText = val;
+              _applyFilteringAndRefresh();
+            },
+            decoration: InputDecoration(
+              hintText: l10n.searchHint,
+              border: InputBorder.none,
+              focusedBorder: InputBorder.none,
+            ),
+            focusNode: searchBoxFocusNode,
+          ),
+    centerTitle: isDesktop ? false : true,
+    actions: <Widget>[
+      Padding(
+        padding: const EdgeInsets.all(8.0),
+        child: SortCodeMenuWidget(
+          currentKey: PreferenceService.instance.codeSortKey(),
+          onSelected: (newOrder) async {
+            await PreferenceService.instance.setCodeSortKey(newOrder);
+            if (newOrder == CodeSortKey.manual && newOrder == _codeSortKey) {
+              await navigateToReorderPage(_allCodes!);
+            }
+            setState(() {
+              _codeSortKey = newOrder;
+            });
+            if (mounted) {
+              _applyFilteringAndRefresh();
+            }
+          },
+        ),
+      ),
+      if (isDesktop)
+        IconButton(
+          icon: const Icon(Icons.lock),
+          tooltip: l10n.appLock,
+          padding: const EdgeInsets.all(8.0),
+          onPressed: () async {
+            await navigateToLockScreen();
+          },
+        ),
+      IconButton(
+        icon:
+            _showSearchBox ? const Icon(Icons.clear) : const Icon(Icons.search),
+        tooltip: l10n.search,
+        padding: const EdgeInsets.all(8.0),
+        onPressed: () {
+          setState(() {
+            _showSearchBox = !_showSearchBox;
+            if (!_showSearchBox) {
+              _textController.clear();
+              _searchText = "";
+            } else {
+              _searchText = _textController.text;
+              searchBoxFocusNode.requestFocus();
+            }
+            _applyFilteringAndRefresh();
+          });
+        },
+      ),
+    ],
+  );
+}
+
+PreferredSizeWidget _buildDesktopSelectionAppBar(
+  AppLocalizations l10n,
+) {
+  final visibleIds = _filteredCodes.map((c) => c.selectionKey).toSet();
+  return PreferredSize(
+    preferredSize: const Size.fromHeight(kToolbarHeight),
+    child: ValueListenableBuilder<Set<String>>(
+      valueListenable: _codeDisplayStore.selectedCodeIds,
+      builder: (context, selectedIds, _) {
+        final bool allVisibleSelected =
+            visibleIds.isNotEmpty && selectedIds.containsAll(visibleIds);
+        return AppBar(
+          backgroundColor: Theme.of(context).scaffoldBackgroundColor,
+          surfaceTintColor: Colors.transparent,
+          leadingWidth: 220,
+          leading: Padding(
+            padding: const EdgeInsets.only(left: 8.0),
+            child: Row(
+              mainAxisSize: MainAxisSize.min,
+              children: [
+                IconButton(
+                  icon: const Icon(Icons.close),
+                  tooltip: l10n.cancel,
+                  onPressed: () => _codeDisplayStore.clearSelection(),
+                ),
+                const SizedBox(width: 8),
+                Text(
+                  '${selectedIds.length} ${l10n.selected}',
+                  style: Theme.of(context)
+                      .textTheme
+                      .titleMedium
+                      ?.copyWith(fontWeight: FontWeight.w600),
+                ),
+              ],
+            ),
+          ),
+          title: _buildDesktopActionRow(context),
+          centerTitle: true,
+          actions: [
+            _buildSelectAllChip(
+              context: context,
+              enabled: !allVisibleSelected,
+              onPressed: allVisibleSelected
+                  ? null
+                  : () {
+                      final newSelection = Set<String>.from(visibleIds);
+                      _codeDisplayStore.selectedCodeIds.value = newSelection;
+                      _codeDisplayStore.isSelectionModeActive.value =
+                          newSelection.isNotEmpty;
+                    },
+            ),
+            const SizedBox(width: 12),
+          ],
+        );
+      },
+    ),
+  );
+}
+
   Widget _getBody() {
     final l10n = context.l10n;
-    if (_hasLoaded) {
-      if (_filteredCodes.isEmpty && _searchText.isEmpty) {
-        return HomeEmptyStateWidget(
-          onScanTap: _redirectToScannerPage,
-          onManuallySetupTap: _redirectToManualEntryPage,
+  final crossAxisCount = _calculateGridColumnCount(context);
+  _currentGridColumns = crossAxisCount;
+  if (_hasLoaded) {
+    if (_filteredCodes.isEmpty && _searchText.isEmpty) {
+      return HomeEmptyStateWidget(
+        onScanTap: _redirectToScannerPage,
+        onManuallySetupTap: _redirectToManualEntryPage,
         );
       } else {
         final anyCodeHasError =
@@ -1410,9 +1530,7 @@ Widget build(BuildContext context) {
               ),
             Expanded(
               child: AlignedGridView.count(
-                crossAxisCount: (MediaQuery.sizeOf(context).width ~/ 400)
-                    .clamp(1, double.infinity)
-                    .toInt(),
+                crossAxisCount: crossAxisCount,
                 physics: const AlwaysScrollableScrollPhysics(),
                 padding: const EdgeInsets.only(bottom: 80),
                 itemBuilder: ((context, index) {
@@ -1436,6 +1554,14 @@ Widget build(BuildContext context) {
                       code,
                       isCompactMode: isCompactMode,
                       sortKey: _codeSortKey,
+                      enableDesktopContextActions: PlatformUtil.isDesktop(),
+                      selectedCodesBuilder: _selectedCodesForContextMenu,
+                      onMultiPinToggle: _onPinSelectedPressed,
+                      onMultiUnpin: _onUnpinSelectedPressed,
+                      onMultiAddTag: () async => _onAddTagPressed(),
+                      onMultiTrash: _onTrashSelectedPressed,
+                      onMultiRestore: _onRestoreSelectedPressed,
+                      onMultiDeleteForever: _onDeleteForeverPressed,
                     ),
                   );
                 }),
@@ -1446,21 +1572,19 @@ Widget build(BuildContext context) {
         );
         if (!PreferenceService.instance.hasShownCoachMark()) {
           return Stack(
+            fit: StackFit.expand,
             children: [
-              list,
+              Positioned.fill(child: list),
               const CoachMarkWidget(),
             ],
           );
         } else if (_showSearchBox) {
-          return Column(
+          final searchContent = Column(
             children: [
               Expanded(
                 child: _filteredCodes.isNotEmpty
                     ? AlignedGridView.count(
-                        crossAxisCount:
-                            (MediaQuery.sizeOf(context).width ~/ 400)
-                                .clamp(1, double.infinity)
-                                .toInt(),
+                        crossAxisCount: crossAxisCount,
                         padding: const EdgeInsets.only(bottom: 80),
                         itemBuilder: ((context, index) {
                           final codeState = _filteredCodes[index];
@@ -1469,6 +1593,15 @@ Widget build(BuildContext context) {
                             codeState,
                             isCompactMode: isCompactMode,
                             sortKey: _codeSortKey,
+                            enableDesktopContextActions:
+                                PlatformUtil.isDesktop(),
+                            selectedCodesBuilder: _selectedCodesForContextMenu,
+                            onMultiPinToggle: _onPinSelectedPressed,
+                            onMultiUnpin: _onUnpinSelectedPressed,
+                            onMultiAddTag: () async => _onAddTagPressed(),
+                            onMultiTrash: _onTrashSelectedPressed,
+                            onMultiRestore: _onRestoreSelectedPressed,
+                            onMultiDeleteForever: _onDeleteForeverPressed,
                           );
                         }),
                         itemCount: _filteredCodes.length,
@@ -1477,6 +1610,7 @@ Widget build(BuildContext context) {
               ),
             ],
           );
+          return searchContent;
         } else {
           return list;
         }
@@ -1557,6 +1691,170 @@ Widget build(BuildContext context) {
     _applyFilteringAndRefresh();
   }
 
+  Widget _buildDesktopActionRow(BuildContext context) {
+    final selectedCodes = _selectedCodesForContextMenu();
+    if (selectedCodes.isEmpty) {
+      return const SizedBox.shrink();
+    }
+
+    final bool allTrashed = selectedCodes.every((code) => code.isTrashed);
+    final bool allPinned = selectedCodes.every((code) => code.isPinned);
+    final bool anyPinned = selectedCodes.any((code) => code.isPinned);
+    final bool isMixedPinned = anyPinned && !allPinned;
+    final bool singleSelection = selectedCodes.length == 1;
+    final Code? singleCode = singleSelection ? selectedCodes.first : null;
+
+    final List<Widget> actionButtons = [];
+
+  void addButton(String tooltip, IconData icon, VoidCallback? onPressed, {Widget? iconWidget}) {
+      if (actionButtons.isNotEmpty) {
+        actionButtons.add(const SizedBox(width: 12));
+      }
+      actionButtons.add(
+        _buildSelectionIconButton(
+          context: context,
+          tooltip: tooltip,
+          icon: icon,
+          iconWidget: iconWidget,
+          onPressed: onPressed,
+        ),
+      );
+    }
+
+    if (!allTrashed) {
+      if (isMixedPinned) {
+        addButton(context.l10n.pinText, Icons.push_pin, () => _onPinSelectedPressed());
+        addButton(
+          context.l10n.unpinText,
+          Icons.push_pin,
+          () => _onUnpinSelectedPressed(),
+          iconWidget: _buildUnpinIcon(context),
+        );
+      } else if (allPinned) {
+        addButton(
+          context.l10n.unpinText,
+          Icons.push_pin,
+          () => _onUnpinSelectedPressed(),
+          iconWidget: _buildUnpinIcon(context),
+        );
+      } else {
+        addButton(context.l10n.pinText, Icons.push_pin, () => _onPinSelectedPressed());
+      }
+
+      addButton(context.l10n.addTag, Icons.local_offer_outlined, _onAddTagPressed);
+      addButton(context.l10n.trash, Icons.delete_outline, () => _onTrashSelectedPressed());
+
+      if (singleCode != null) {
+        addButton(context.l10n.share, Icons.adaptive.share_outlined, () => _onSharePressed(singleCode));
+        addButton(context.l10n.qr, Icons.qr_code_2_outlined, () => _onShowQrPressed(singleCode));
+        addButton(context.l10n.edit, Icons.edit_outlined, () => _onEditPressed(singleCode));
+      }
+    } else {
+      addButton(context.l10n.restore, Icons.restore_outlined, () => _onRestoreSelectedPressed());
+      addButton(context.l10n.delete, Icons.delete_forever_outlined, () => _onDeleteForeverPressed());
+    }
+
+    return Row(
+      mainAxisSize: MainAxisSize.min,
+      children: actionButtons,
+    );
+  }
+
+  Widget _buildSelectionIconButton({
+    required BuildContext context,
+    required String tooltip,
+    required IconData icon,
+    Widget? iconWidget,
+    required VoidCallback? onPressed,
+  }) {
+    final colorScheme = getEnteColorScheme(context);
+    final bool enabled = onPressed != null;
+    final Color iconColor = enabled
+        ? colorScheme.textBase
+        : colorScheme.textMuted.withValues(alpha: 0.5);
+    final Color backgroundColor = enabled
+        ? colorScheme.fillFaint
+        : colorScheme.fillFaint.withValues(alpha: 0.6);
+    return Tooltip(
+      message: tooltip,
+      waitDuration: const Duration(milliseconds: 300),
+      child: Material(
+        color: Colors.transparent,
+        child: InkWell(
+          customBorder: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
+          onTap: onPressed,
+          child: Container(
+            decoration: BoxDecoration(
+              color: backgroundColor,
+              borderRadius: BorderRadius.circular(10),
+            ),
+            padding: const EdgeInsets.all(8),
+            child: iconWidget ?? Icon(icon, size: 24, color: iconColor),
+          ),
+        ),
+      ),
+    );
+  }
+
+  Widget _buildUnpinIcon(BuildContext context) {
+    final colorScheme = getEnteColorScheme(context);
+    return Stack(
+      alignment: Alignment.center,
+      children: [
+        Icon(Icons.push_pin_outlined, size: 24, color: colorScheme.textBase),
+        Transform.rotate(
+          angle: 0.785398, // 45 degrees in radians
+          child: Container(
+            width: 18,
+            height: 2,
+            color: colorScheme.textBase,
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildSelectAllChip({
+    required BuildContext context,
+    required bool enabled,
+    required VoidCallback? onPressed,
+  }) {
+    final colorScheme = getEnteColorScheme(context);
+    final textColor = enabled
+        ? colorScheme.textBase
+        : colorScheme.textMuted.withValues(alpha: 0.6);
+    return Material(
+      shape: StadiumBorder(
+        side: BorderSide(
+          color: colorScheme.strokeMuted.withValues(alpha: 0.5),
+        ),
+      ),
+      clipBehavior: Clip.antiAlias,
+      color: colorScheme.backgroundElevated2,
+      child: InkWell(
+        onTap: enabled ? onPressed : null,
+        child: Padding(
+          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
+          child: Row(
+            mainAxisSize: MainAxisSize.min,
+            children: [
+              Text(
+                context.l10n.selectAll,
+                style: TextStyle(fontSize: 12, color: textColor),
+              ),
+              const SizedBox(width: 6),
+              Icon(
+                Icons.done_all,
+                size: 18,
+                color: textColor,
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+
   Widget _getFab() {
     if (PlatformUtil.isDesktop()) {
       return FloatingActionButton(
