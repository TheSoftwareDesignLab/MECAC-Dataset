diff --git a/desktop/src/main/services/ffmpeg.ts b/desktop/src/main/services/ffmpeg.ts
index c49ac670092..5547cf83419 100644
--- a/desktop/src/main/services/ffmpeg.ts
+++ b/desktop/src/main/services/ffmpeg.ts
@@ -9,22 +9,22 @@ const inputPathPlaceholder = "INPUT";
 const outputPathPlaceholder = "OUTPUT";
 
 /**
- * Run a ffmpeg command
+ * Run a FFmpeg command
  *
- * [Note: ffmpeg in Electron]
+ * [Note: FFmpeg in Electron]
  *
- * There is a wasm build of ffmpeg, but that is currently 10-20 times slower
+ * There is a wasm build of FFmpeg, but that is currently 10-20 times slower
  * that the native build. That is slow enough to be unusable for our purposes.
  * https://ffmpegwasm.netlify.app/docs/performance
  *
- * So the alternative is to bundle a ffmpeg binary with our app. e.g.
+ * So the alternative is to bundle a FFmpeg executable binary with our app. e.g.
  *
  *     yarn add fluent-ffmpeg ffmpeg-static ffprobe-static
  *
  * (we only use ffmpeg-static, the rest are mentioned for completeness' sake).
  *
- * Interestingly, Electron already bundles an ffmpeg library (it comes from the
- * ffmpeg fork maintained by Chromium).
+ * Interestingly, Electron already bundles an binary FFmpeg library (it comes
+ * from the ffmpeg fork maintained by Chromium).
  * https://chromium.googlesource.com/chromium/third_party/ffmpeg
  * https://stackoverflow.com/questions/53963672/what-version-of-ffmpeg-is-bundled-inside-electron
  *
@@ -96,7 +96,7 @@ const substitutePlaceholders = (
 /**
  * Return the path to the `ffmpeg` binary.
  *
- * At runtime, the ffmpeg binary is present in a path like (macOS example):
+ * At runtime, the FFmpeg binary is present in a path like (macOS example):
  * `ente.app/Contents/Resources/app.asar.unpacked/node_modules/ffmpeg-static/ffmpeg`
  */
 const ffmpegBinaryPath = () => {
diff --git a/web/apps/photos/src/services/ffmpeg.ts b/web/apps/photos/src/services/ffmpeg.ts
index 9f6cec0b6d5..b407d9f4c62 100644
--- a/web/apps/photos/src/services/ffmpeg.ts
+++ b/web/apps/photos/src/services/ffmpeg.ts
@@ -1,4 +1,4 @@
-import { ElectronFile } from "@/next/types/file";
+import { ElectronFile, type DesktopFilePath } from "@/next/types/file";
 import { ComlinkWorker } from "@/next/worker/comlink-worker";
 import { validateAndGetCreationUnixTimeInMicroSeconds } from "@ente/shared/time";
 import { Remote } from "comlink";
@@ -11,38 +11,42 @@ import { NULL_LOCATION } from "constants/upload";
 import { ParsedExtractedMetadata } from "types/upload";
 import { type DedicatedFFmpegWorker } from "worker/ffmpeg.worker";
 
-/** Called during upload */
-export async function generateVideoThumbnail(
-    fileOrPath: File | ElectronFile | string,
-): Promise<File | ElectronFile> {
-    let seekTime = 1;
-    while (seekTime >= 0) {
-        try {
-            return await ffmpegExec(
-                [
-                    ffmpegPathPlaceholder,
-                    "-i",
-                    inputPathPlaceholder,
-                    "-ss",
-                    `00:00:0${seekTime}`,
-                    "-vframes",
-                    "1",
-                    "-vf",
-                    "scale=-1:720",
-                    outputPathPlaceholder,
-                ],
-                /* TODO(MR): ElectronFile changes */
-                fileOrPath as File | ElectronFile,
-                "thumb.jpeg",
-            );
-        } catch (e) {
-            if (seekTime === 0) {
-                throw e;
-            }
-        }
-        seekTime--;
+/**
+ * Generate a thumbnail of the given video using FFmpeg.
+ *
+ * This function is called during upload, when we need to generate thumbnails
+ * for the new files that the user is adding.
+ *
+ * @param fileOrPath The input video file or a path to it.
+ * @returns JPEG data for the generated thumbnail.
+ */
+export const generateVideoThumbnail = async (
+    fileOrPath: File | DesktopFilePath,
+): Promise<Uint8Array> => {
+    const thumbnailAtTime = (seekTime: number) =>
+        ffmpegExec(
+            [
+                ffmpegPathPlaceholder,
+                "-i",
+                inputPathPlaceholder,
+                "-ss",
+                `00:00:0${seekTime}`,
+                "-vframes",
+                "1",
+                "-vf",
+                "scale=-1:720",
+                outputPathPlaceholder,
+            ],
+            fileOrPath,
+            "thumb.jpeg",
+        );
+
+    try {
+        return await thumbnailAtTime(1);
+    } catch (e) {
+        return await thumbnailAtTime(0);
     }
-}
+};
 
 /** Called during upload */
 export async function extractVideoMetadata(file: File | ElectronFile) {
@@ -50,7 +54,7 @@ export async function extractVideoMetadata(file: File | ElectronFile) {
     // -c [short for codex] copy[(stream_specifier)[ffmpeg.org/ffmpeg.html#Stream-specifiers]] => copies all the stream without re-encoding
     // -map_metadata [http://ffmpeg.org/ffmpeg.html#Advanced-options search for map_metadata] => copies all stream metadata to the out
     // -f ffmetadata [https://ffmpeg.org/ffmpeg-formats.html#Metadata-1] => dump metadata from media files into a simple UTF-8-encoded INI-like text file
-    const metadata = await ffmpegExec(
+    const metadata = await ffmpegExec2(
         [
             ffmpegPathPlaceholder,
             "-i",
@@ -137,7 +141,7 @@ function parseCreationTime(creationTime: string) {
 
 /** Called when viewing a file */
 export async function convertToMP4(file: File) {
-    return await ffmpegExec(
+    return await ffmpegExec2(
         [
             ffmpegPathPlaceholder,
             "-i",
@@ -153,16 +157,34 @@ export async function convertToMP4(file: File) {
 }
 
 /**
- * Run the given ffmpeg command.
+ * Run the given FFmpeg command.
  *
- * If we're running in the context of our desktop app, use the ffmpeg binary we
+ * If we're running in the context of our desktop app, use the FFmpeg binary we
  * bundle with our desktop app to run the command. Otherwise fallback to using
- * the wasm ffmpeg we link to from our web app in a web worker.
+ * the wasm FFmpeg we link to from our web app in a web worker.
  *
- * As a rough ballpark, the native ffmpeg integration in the desktop app is
- * 10-20x faster than the wasm one currently. See: [Note: ffmpeg in Electron].
+ * As a rough ballpark, the native FFmpeg integration in the desktop app is
+ * 10-20x faster than the wasm one currently. See: [Note: FFmpeg in Electron].
  */
 const ffmpegExec = async (
+    command: string[],
+    fileOrPath: File | DesktopFilePath,
+    outputFileName: string,
+    timeoutMs: number = 0,
+): Promise<Uint8Array> => {
+    if (fileOrPath instanceof File) {
+        return workerFactory
+            .lazy()
+            .then((worker) =>
+                worker.exec(command, fileOrPath, outputFileName, timeoutMs),
+            );
+    } else {
+        const { path, electron } = fileOrPath;
+        return electron.ffmpegExec(command, path, outputFileName, timeoutMs);
+    }
+};
+
+const ffmpegExec2 = async (
     command: string[],
     inputFile: File | ElectronFile,
     outputFileName: string,
@@ -179,7 +201,7 @@ const ffmpegExec = async (
         // );
     } else {
         return workerFactory
-            .instance()
+            .lazy()
             .then((worker) =>
                 worker.execute(
                     command,
@@ -193,14 +215,11 @@ const ffmpegExec = async (
 
 /** Lazily create a singleton instance of our worker */
 class WorkerFactory {
-    private _instance: Promise<Remote<DedicatedFFmpegWorker>>;
-
-    async instance() {
-        if (!this._instance) {
-            const comlinkWorker = createComlinkWorker();
-            this._instance = comlinkWorker.remote;
-        }
-        return this._instance;
+    private instance: Promise<Remote<DedicatedFFmpegWorker>>;
+
+    async lazy() {
+        if (!this.instance) this.instance = createComlinkWorker().remote;
+        return this.instance;
     }
 }
 
diff --git a/web/apps/photos/src/worker/ffmpeg.worker.ts b/web/apps/photos/src/worker/ffmpeg.worker.ts
index 4d1c1e88bd7..cd608f6bc47 100644
--- a/web/apps/photos/src/worker/ffmpeg.worker.ts
+++ b/web/apps/photos/src/worker/ffmpeg.worker.ts
@@ -10,11 +10,10 @@ import {
     outputPathPlaceholder,
 } from "constants/ffmpeg";
 import { FFmpeg, createFFmpeg } from "ffmpeg-wasm";
-import { getUint8ArrayView } from "services/readerService";
 
 export class DedicatedFFmpegWorker {
     private ffmpeg: FFmpeg;
-    private ffmpegTaskQueue = new QueueProcessor<File>();
+    private ffmpegTaskQueue = new QueueProcessor<Uint8Array>();
 
     constructor() {
         this.ffmpeg = createFFmpeg({
@@ -24,24 +23,24 @@ export class DedicatedFFmpegWorker {
     }
 
     /**
-     * Execute a ffmpeg {@link command}.
+     * Execute a FFmpeg {@link command}.
      *
      * This is a sibling of {@link ffmpegExec} in ipc.ts exposed by the desktop
-     * app. See [Note: ffmpeg in Electron].
+     * app. See [Note: FFmpeg in Electron].
      */
-    async execute(
+    async exec(
         command: string[],
         inputFile: File,
         outputFileName: string,
-        timeoutMS,
-    ) {
+        timeoutMs,
+    ): Promise<Uint8Array> {
         if (!this.ffmpeg.isLoaded()) await this.ffmpeg.load();
 
-        const exec = () =>
+        const go = () =>
             ffmpegExec(this.ffmpeg, command, inputFile, outputFileName);
 
         const request = this.ffmpegTaskQueue.queueUpRequest(() =>
-            timeoutMS ? withTimeout<File>(exec(), timeoutMS) : exec(),
+            timeoutMs ? withTimeout(go(), timeoutMs) : go(),
         );
 
         return await request.promise;
@@ -71,16 +70,13 @@ const ffmpegExec = async (
         ffmpeg.FS(
             "writeFile",
             tempInputFilePath,
-            await getUint8ArrayView(inputFile),
+            new Uint8Array(await inputFile.arrayBuffer()),
         );
 
-        log.info(`Running ffmpeg (wasm) command ${cmd}`);
+        log.info(`Running FFmpeg (wasm) command ${cmd}`);
         await ffmpeg.run(...cmd);
 
-        return new File(
-            [ffmpeg.FS("readFile", tempOutputFilePath)],
-            outputFileName,
-        );
+        return ffmpeg.FS("readFile", tempOutputFilePath);
     } finally {
         try {
             ffmpeg.FS("unlink", tempInputFilePath);
diff --git a/web/packages/next/blob-cache.ts b/web/packages/next/blob-cache.ts
index 8789a507863..0e092fed61d 100644
--- a/web/packages/next/blob-cache.ts
+++ b/web/packages/next/blob-cache.ts
@@ -113,6 +113,10 @@ export const openCache = async (
  *
  *     await blob.arrayBuffer()
  *
+ * To convert from a Blob to Uint8Array, chain the two steps
+ *
+ *     new Uint8Array(await blob.arrayBuffer())
+ *
  * To convert from an ArrayBuffer or Uint8Array to Blob
  *
  *     new Blob([arrayBuffer, andOrAnyArray, andOrstring])
