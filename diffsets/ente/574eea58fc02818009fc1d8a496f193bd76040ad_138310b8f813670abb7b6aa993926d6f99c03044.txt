diff --git a/mobile/ios/EnteAlbumWidget/EnteAlbumWidget.swift b/mobile/ios/EnteAlbumWidget/EnteAlbumWidget.swift
index 82e1aed7503..3eb5cf6ed2f 100644
--- a/mobile/ios/EnteAlbumWidget/EnteAlbumWidget.swift
+++ b/mobile/ios/EnteAlbumWidget/EnteAlbumWidget.swift
@@ -50,9 +50,9 @@ struct Provider: TimelineProvider {
                     byAdding: .minute, value: minutes * offset, to: currentDate
                 )!
                 let imageData =
-                    data?.string(forKey: "album_widget_" + String(randomInt))
+                    data?.string(forKey: "albums_widget_" + String(randomInt))
                 let dictionary = data?.dictionary(
-                    forKey: "album_widget_" + String(randomInt) + "_data")
+                    forKey: "albums_widget_" + String(randomInt) + "_data")
                 let generatedId = dictionary?["generatedId"] as? Int
                 let subTitle = dictionary?["subText"] as? String
                 let title = dictionary?["title"] as? String
@@ -177,9 +177,9 @@ struct EnteAlbumWidgetEntryView: View {
                                 alignment: .bottomLeading
                             )
                     }
-                } else if let data = Data(
+                } else if let imgData = Data(
                     base64Encoded: defaultBase64Image),
-                    let uiImage = UIImage(data: data)
+                    let uiImage = UIImage(data: imgData)
                 {
                     VStack(spacing: 8) {
                         Spacer()
diff --git a/mobile/lib/core/constants.dart b/mobile/lib/core/constants.dart
index 9067d14b148..02cc6f60e78 100644
--- a/mobile/lib/core/constants.dart
+++ b/mobile/lib/core/constants.dart
@@ -71,7 +71,9 @@ const kSearchSectionLimit = 9;
 
 const maxPickAssetLimit = 50;
 
-const iOSGroupID = "group.io.ente.frame.EnteMemoryWidget";
+const iOSGroupIDMemory = "group.io.ente.frame.EnteMemoryWidget";
+const iOSGroupIDAlbum = "group.io.ente.frame.EntePeopleWidget";
+const iOSGroupIDPeople = "group.io.ente.frame.EnteAlbumWidget";
 
 const blackThumbnailBase64 = '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEB'
     'AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQ'
diff --git a/mobile/lib/services/album_home_widget_service.dart b/mobile/lib/services/album_home_widget_service.dart
index ccc2a1b90fe..d26cbbb39ff 100644
--- a/mobile/lib/services/album_home_widget_service.dart
+++ b/mobile/lib/services/album_home_widget_service.dart
@@ -1,13 +1,22 @@
+import "dart:convert";
+
+import "package:crypto/crypto.dart";
 import "package:flutter/material.dart";
 import "package:fluttertoast/fluttertoast.dart";
 import "package:logging/logging.dart";
+import "package:photos/core/constants.dart";
 import "package:photos/db/files_db.dart";
+import "package:photos/models/collection/collection.dart";
+import "package:photos/models/collection/collection_items.dart";
 import "package:photos/models/file/file.dart";
 import "package:photos/service_locator.dart";
 import "package:photos/services/collections_service.dart";
 import "package:photos/services/favorites_service.dart";
 import "package:photos/services/home_widget_service.dart";
 import "package:photos/services/sync/local_sync_service.dart";
+import "package:photos/ui/viewer/file/file_widget.dart";
+import "package:photos/ui/viewer/gallery/collection_page.dart";
+import "package:photos/utils/navigation_util.dart";
 import "package:shared_preferences/shared_preferences.dart";
 import "package:synchronized/synchronized.dart";
 
@@ -17,8 +26,9 @@ class AlbumHomeWidgetService {
   AlbumHomeWidgetService._privateConstructor();
 
   static const _selectedAlbumsHWKey = "selectedAlbumsHW";
+  static const _albumsLastHashKey = "albumsLastHash";
   static const _androidClass = "EnteAlbumsWidgetProvider";
-  static const _iOSClass = "EnteAlbumsWidget";
+  static const _iOSClass = "EnteAlbumWidget";
 
   static final AlbumHomeWidgetService instance =
       AlbumHomeWidgetService._privateConstructor();
@@ -40,6 +50,16 @@ class AlbumHomeWidgetService {
     await updateAlbumsChanged(false);
   }
 
+  String? getAlbumsLastHash() {
+    final albumsLastHash = _prefs.getString(_albumsLastHashKey);
+
+    return albumsLastHash;
+  }
+
+  Future<void> setAlbumsLastHash(String hash) async {
+    await _prefs.setString(_albumsLastHashKey, hash);
+  }
+
   List<int>? getSelectedAlbums() {
     final selectedAlbums = _prefs.getStringList(_selectedAlbumsHWKey);
 
@@ -86,14 +106,7 @@ class AlbumHomeWidgetService {
     }
 
     final selectedAlbums = getSelectedAlbums();
-    final albums = [];
-    for (final selectedAlbum in selectedAlbums ?? []) {
-      final collection =
-          CollectionsService.instance.getCollectionByID(selectedAlbum);
-      if (collection != null) {
-        albums.add(collection);
-      }
-    }
+    final albums = getAlbums(selectedAlbums ?? []);
 
     if ((selectedAlbums?.isNotEmpty ?? false) && albums.isEmpty) {
       _logger.warning("selected albums not found");
@@ -111,6 +124,7 @@ class AlbumHomeWidgetService {
     }
 
     await _albumsForceRefreshLock.synchronized(() async {
+      HomeWidgetService.instance.setAppGroupID(iOSGroupIDAlbum);
       final result = await hasAnyBlockers();
       if (result) {
         return;
@@ -151,6 +165,7 @@ class AlbumHomeWidgetService {
   }
 
   Future<bool> _checkIfTotalEmpty() async {
+    HomeWidgetService.instance.setAppGroupID(iOSGroupIDAlbum);
     final total = await _getTotal();
     return total == 0 || total == null;
   }
@@ -159,12 +174,21 @@ class AlbumHomeWidgetService {
     final albumsChanged = _prefs.getBool(albumsChangedKey);
     if (albumsChanged == true) return true;
 
-    // TODO: Get Album data i.e. List of Ente Files
-    final cachedAlbum = []; // await albumsCacheService.getCachedAlbum();
+    final selectedAlbums = await getSelectedAlbumsIDs();
+    if (selectedAlbums.isEmpty) {
+      _logger.warning("No selected albums");
+      return false;
+    }
+
+    final hash = getHash(selectedAlbums);
+    final lastHash = getAlbumsLastHash();
+
+    if (hash == lastHash) {
+      _logger.warning("No changes detected");
+      return false;
+    }
 
-    final forceFetchNewAlbum =
-        isTotalEmpty && (cachedAlbum.isNotEmpty ?? false);
-    return forceFetchNewAlbum;
+    return true;
   }
 
   Future<void> checkPendingAlbumsSync() async {
@@ -177,21 +201,14 @@ class AlbumHomeWidgetService {
       _logger.info(">>> Albums already synced");
       return;
     }
-    await HomeWidgetService.instance.initHomeWidget();
+    await initAlbumsHW(forceFetchNewAlbum);
   }
 
   Future<Map<String, Iterable<EnteFile>>> _getAlbum() async {
-    var selectedAlbums = getSelectedAlbums();
-    if (selectedAlbums == null || selectedAlbums.isEmpty) {
-      final favoriteId =
-          await FavoritesService.instance.getFavoriteCollectionID();
-      if (favoriteId != null) {
-        selectedAlbums = [favoriteId];
-      }
-    }
+    final selectedAlbums = await getSelectedAlbumsIDs();
 
     final albums = <String, List<EnteFile>>{};
-    for (final selectedAlbum in selectedAlbums ?? []) {
+    for (final selectedAlbum in selectedAlbums) {
       final collection =
           CollectionsService.instance.getCollectionByID(selectedAlbum);
       if (collection != null) {
@@ -218,7 +235,7 @@ class AlbumHomeWidgetService {
     );
     if (flagService.internalUser) {
       await Fluttertoast.showToast(
-        msg: "[i] ${text ?? "AlbumsHomeWidget updated"}",
+        msg: "[i][al] ${text ?? "AlbumsHomeWidget updated"}",
         toastLength: Toast.LENGTH_SHORT,
         gravity: ToastGravity.BOTTOM,
         timeInSecForIosWeb: 1,
@@ -230,15 +247,56 @@ class AlbumHomeWidgetService {
     _logger.info(">>> Home Widget updated, type: ${text ?? "normal"}");
   }
 
+  String getHash(List<int> selectedAlbums) {
+    final albums = <Collection>{};
+    String currentDates = "";
+    for (final selectedAlbum in selectedAlbums) {
+      final collection =
+          CollectionsService.instance.getCollectionByID(selectedAlbum);
+      if (collection != null) {
+        albums.add(collection);
+        currentDates += "${collection.updationTime.toString()}_";
+      }
+    }
+
+    final hash =
+        md5.convert(utf8.encode(currentDates)).toString().substring(0, 10);
+    return hash;
+  }
+
+  List<Collection> getAlbums(List<int> selectedAlbums) {
+    final albums = <Collection>[];
+    for (final selectedAlbum in selectedAlbums) {
+      final collection =
+          CollectionsService.instance.getCollectionByID(selectedAlbum);
+      if (collection != null) {
+        albums.add(collection);
+      }
+    }
+
+    return albums;
+  }
+
+  Future<List<int>> getSelectedAlbumsIDs() async {
+    final selectedAlbums = getSelectedAlbums();
+    if (selectedAlbums == null || selectedAlbums.isEmpty) {
+      final favoriteId =
+          await FavoritesService.instance.getFavoriteCollectionID();
+      if (favoriteId != null) {
+        return [favoriteId];
+      }
+    }
+    return selectedAlbums ?? [];
+  }
+
   Future<void> albumsChanged() async {
-    // TODO: Get Albums and checks if size is changed
-    final cachedAlbum = []; // await albumsCacheService.getCachedAlbum();
-    final currentTotal = cachedAlbum.length ?? 0;
+    final lastHash = getAlbumsLastHash();
 
-    final int total = await _getTotal() ?? 0;
+    final selectedAlbums = await getSelectedAlbumsIDs();
+    final hash = getHash(selectedAlbums);
 
-    if (total == currentTotal && total == 0) {
-      _logger.info(">>> Album not changed, doing nothing");
+    if (selectedAlbums.isEmpty || hash == lastHash) {
+      _logger.info(">>> No changes detected");
       return;
     }
 
@@ -248,11 +306,12 @@ class AlbumHomeWidgetService {
   }
 
   Future<int?> _getTotal() async {
-    return HomeWidgetService.instance.getData<int>(totalAlbums);
+    return HomeWidgetService.instance
+        .getData<int>(totalAlbums, iOSGroupIDAlbum);
   }
 
-  Future<void> _setTotal(int? total) async =>
-      await HomeWidgetService.instance.setData(totalAlbums, total);
+  Future<void> _setTotal(int? total) async => await HomeWidgetService.instance
+      .setData(totalAlbums, total, iOSGroupIDAlbum);
 
   Future<void> _lockAndLoadAlbum() async {
     final files = await _getAlbum();
@@ -271,7 +330,7 @@ class AlbumHomeWidgetService {
     for (final i in files.entries) {
       for (final file in i.value) {
         final value = await HomeWidgetService.instance
-            .renderFile(file, "albums_widget_$index", i.key)
+            .renderFile(file, "albums_widget_$index", i.key, iOSGroupIDAlbum)
             .catchError(
           (e, sT) {
             _logger.severe("Error rendering widget", e, sT);
@@ -284,13 +343,13 @@ class AlbumHomeWidgetService {
           if (result) {
             return;
           }
-          await _setTotal(index);
           if (index == 1) {
             await _updateWidget(
               text: "First albums fetched. updating widget",
             );
           }
           index++;
+          await _setTotal(index);
 
           if (index >= 50) {
             _logger.warning(">>> Max albums limit reached");
@@ -304,6 +363,11 @@ class AlbumHomeWidgetService {
       }
     }
 
+    final selectedAlbums = await getSelectedAlbumsIDs();
+
+    final hash = getHash(selectedAlbums);
+    await setAlbumsLastHash(hash);
+
     if (index == 0) {
       return;
     }
@@ -313,10 +377,39 @@ class AlbumHomeWidgetService {
     );
   }
 
-  Future<void> onLaunchFromWidget(int generatedId, BuildContext context) async {
+  Future<void> onLaunchFromWidget(
+    int generatedId,
+    int collectionID,
+    BuildContext context,
+  ) async {
     _hasSyncedAlbums = true;
     await _albumsSync();
 
-    // TODO: Open albums page for this album
+    final c = CollectionsService.instance.getCollectionByID(collectionID);
+    if (c == null) {
+      _logger.warning("onLaunchFromWidget: collection is null");
+      return;
+    }
+
+    final thumbnail = await CollectionsService.instance.getCover(c);
+    await routeToPage(
+      context,
+      CollectionPage(
+        CollectionWithThumbnail(c, thumbnail),
+      ),
+    );
+    final file = await FilesDB.instance.getFile(generatedId);
+    if (file == null) {
+      _logger.warning("onLaunchFromWidget: file is null");
+      return;
+    }
+    // open generated id file preview
+    await routeToPage(
+      context,
+      FileWidget(
+        file,
+        tagPrefix: "albumwidget",
+      ),
+    );
   }
 }
diff --git a/mobile/lib/services/home_widget_service.dart b/mobile/lib/services/home_widget_service.dart
index 7934a2df35e..478e461846f 100644
--- a/mobile/lib/services/home_widget_service.dart
+++ b/mobile/lib/services/home_widget_service.dart
@@ -15,6 +15,7 @@ import "package:photos/services/people_home_widget_service.dart";
 import "package:photos/services/smart_memories_service.dart";
 import "package:photos/utils/thumbnail_util.dart";
 import "package:shared_preferences/shared_preferences.dart";
+import "package:synchronized/synchronized.dart";
 
 class HomeWidgetService {
   final Logger _logger = Logger((HomeWidgetService).toString());
@@ -23,9 +24,9 @@ class HomeWidgetService {
 
   static final HomeWidgetService instance =
       HomeWidgetService._privateConstructor();
+  final _groupIDLock = Lock();
 
   init(SharedPreferences prefs) {
-    setAppGroupID(iOSGroupID);
     MemoryHomeWidgetService.instance.init(prefs);
     PeopleHomeWidgetService.instance.init(prefs);
     AlbumHomeWidgetService.instance.init(prefs);
@@ -53,20 +54,29 @@ class HomeWidgetService {
     );
   }
 
-  Future<T?> getData<T>(String key) async =>
-      await hw.HomeWidget.getWidgetData<T>(key);
+  Future<T?> getData<T>(String key, String iOSGroupID) async {
+    return await _groupIDLock.synchronized(() {
+      setAppGroupID(iOSGroupID);
+      return hw.HomeWidget.getWidgetData<T>(key);
+    });
+  }
 
-  Future<bool?> setData<T>(String key, T? data) async =>
-      await hw.HomeWidget.saveWidgetData<T>(key, data);
+  Future<bool?> setData<T>(String key, T? data, String iOSGroupID) async {
+    return await _groupIDLock.synchronized(() {
+      setAppGroupID(iOSGroupID);
+      return hw.HomeWidget.saveWidgetData<T>(key, data);
+    });
+  }
 
   Future<Size?> renderFile(
     EnteFile randomFile,
     String key,
     String title,
+    String iOSGroupID,
   ) async {
     const size = 512.0;
 
-    final result = await _captureFile(randomFile, key, title);
+    final result = await _captureFile(randomFile, key, title, iOSGroupID);
     if (!result) {
       _logger.warning("can't capture file ${randomFile.displayName}");
       return null;
@@ -87,6 +97,7 @@ class HomeWidgetService {
     EnteFile ogFile,
     String key,
     String title,
+    String iOSGroupID,
   ) async {
     try {
       final thumbnail = await getThumbnail(ogFile);
@@ -110,7 +121,7 @@ class HomeWidgetService {
       }
       await file.writeAsBytes(thumbnail!);
 
-      await setData(key, path);
+      await setData(key, path, iOSGroupID);
 
       final subText = await SmartMemoriesService.getDateFormattedLocale(
         creationTime: ogFile.creationTime!,
@@ -140,10 +151,12 @@ class HomeWidgetService {
   }
 
   Future<void> clearWidget(bool autoLogout) async {
-    if (autoLogout) {
-      setAppGroupID(iOSGroupID);
-    }
+    setAppGroupID(iOSGroupIDMemory);
     await MemoryHomeWidgetService.instance.clearWidget();
+    setAppGroupID(iOSGroupIDAlbum);
+    await AlbumHomeWidgetService.instance.clearWidget();
+    setAppGroupID(iOSGroupIDPeople);
+    await PeopleHomeWidgetService.instance.clearWidget();
   }
 
   Future<void> onLaunchFromWidget(Uri? uri, BuildContext context) async {
@@ -173,8 +186,15 @@ class HomeWidgetService {
       );
     } else if (uri.scheme == "albumwidget") {
       _logger.info("onLaunchFromWidget: redirecting to album widget");
+      final collectionID =
+          int.tryParse(uri.queryParameters["collectionID"] ?? "");
+      if (collectionID == null) {
+        _logger.warning("onLaunchFromWidget: collectionID is null");
+        return;
+      }
       await AlbumHomeWidgetService.instance.onLaunchFromWidget(
         generatedId,
+        collectionID,
         context,
       );
     } else {
diff --git a/mobile/lib/services/memory_home_widget_service.dart b/mobile/lib/services/memory_home_widget_service.dart
index 5d4720527b9..60868dcafaf 100644
--- a/mobile/lib/services/memory_home_widget_service.dart
+++ b/mobile/lib/services/memory_home_widget_service.dart
@@ -1,7 +1,9 @@
 import "package:flutter/material.dart";
 import "package:fluttertoast/fluttertoast.dart";
 import "package:logging/logging.dart";
+import "package:photos/core/constants.dart";
 import "package:photos/models/file/file.dart";
+import "package:photos/models/memories/smart_memory.dart";
 import "package:photos/service_locator.dart";
 import "package:photos/services/home_widget_service.dart";
 import "package:photos/services/sync/local_sync_service.dart";
@@ -164,10 +166,9 @@ class MemoryHomeWidgetService {
     final memoryChanged = _prefs.getBool(memoryChangedKey);
     if (memoryChanged == true) return true;
 
-    final cachedMemories = await memoriesCacheService.getCachedMemories();
+    final cachedMemories = await _getMemoriesForWidget();
 
-    final forceFetchNewMemories =
-        isTotalEmpty && (cachedMemories?.isNotEmpty ?? false);
+    final forceFetchNewMemories = isTotalEmpty && cachedMemories.isNotEmpty;
     return forceFetchNewMemories;
   }
 
@@ -184,7 +185,7 @@ class MemoryHomeWidgetService {
     await HomeWidgetService.instance.initHomeWidget();
   }
 
-  Future<Map<String, Iterable<EnteFile>>> _getMemories() async {
+  Future<List<SmartMemory>> _getMemoriesForWidget() async {
     final lastYearValue = await getSelectedLastYearMemories();
     final mlValue = await getSelectedMLMemories();
     final onThisDayValue = await getSelectedOnThisDayMemories();
@@ -196,6 +197,12 @@ class MemoryHomeWidgetService {
       smart: mlValue ?? isMLEnabled,
     );
 
+    return memories;
+  }
+
+  Future<Map<String, Iterable<EnteFile>>> _getMemories() async {
+    final memories = await _getMemoriesForWidget();
+
     if (memories.isEmpty) {
       return {};
     }
@@ -245,11 +252,12 @@ class MemoryHomeWidgetService {
   }
 
   Future<int?> _getTotal() async {
-    return HomeWidgetService.instance.getData<int>(totalMemories);
+    return HomeWidgetService.instance
+        .getData<int>(totalMemories, iOSGroupIDMemory);
   }
 
-  Future<void> _setTotal(int? total) async =>
-      await HomeWidgetService.instance.setData(totalMemories, total);
+  Future<void> _setTotal(int? total) async => await HomeWidgetService.instance
+      .setData(totalMemories, total, iOSGroupIDMemory);
 
   Future<void> _lockAndLoadMemories() async {
     final files = await _getMemories();
@@ -268,7 +276,12 @@ class MemoryHomeWidgetService {
     for (final i in files.entries) {
       for (final file in i.value) {
         final value = await HomeWidgetService.instance
-            .renderFile(file, "memory_widget_$index", i.key)
+            .renderFile(
+          file,
+          "memory_widget_$index",
+          i.key,
+          iOSGroupIDMemory,
+        )
             .catchError(
           (e, sT) {
             _logger.severe("Error rendering widget", e, sT);
@@ -281,13 +294,13 @@ class MemoryHomeWidgetService {
           if (result) {
             return;
           }
-          await _setTotal(index);
           if (index == 1) {
             await _updateWidget(
               text: "First memory fetched. updating widget",
             );
           }
           index++;
+          await _setTotal(index);
 
           if (index >= 50) {
             _logger.warning(">>> Max memory limit reached");
diff --git a/mobile/lib/services/people_home_widget_service.dart b/mobile/lib/services/people_home_widget_service.dart
index 98c4115ac4d..ab675aafecf 100644
--- a/mobile/lib/services/people_home_widget_service.dart
+++ b/mobile/lib/services/people_home_widget_service.dart
@@ -1,6 +1,7 @@
 import "package:flutter/material.dart";
 import "package:fluttertoast/fluttertoast.dart";
 import "package:logging/logging.dart";
+import "package:photos/core/constants.dart";
 import "package:photos/models/file/file.dart";
 import "package:photos/service_locator.dart";
 import "package:photos/services/home_widget_service.dart";
@@ -170,7 +171,7 @@ class PeopleHomeWidgetService {
   }
 
   Future<Map<String, Iterable<EnteFile>>> _getPeople() async {
-    // TODO: Get People data i.e. List of Ente Files
+    final peopleIds = getSelectedPeople();
     final people = []; // await peopleCacheService.getPeople();
     if (people.isEmpty) {
       return {};
@@ -222,11 +223,12 @@ class PeopleHomeWidgetService {
   }
 
   Future<int?> _getTotal() async {
-    return HomeWidgetService.instance.getData<int>(totalPeople);
+    return HomeWidgetService.instance
+        .getData<int>(totalPeople, iOSGroupIDPeople);
   }
 
-  Future<void> _setTotal(int? total) async =>
-      await HomeWidgetService.instance.setData(totalPeople, total);
+  Future<void> _setTotal(int? total) async => await HomeWidgetService.instance
+      .setData(totalPeople, total, iOSGroupIDPeople);
 
   Future<void> _lockAndLoadPeople() async {
     final files = await _getPeople();
@@ -245,7 +247,12 @@ class PeopleHomeWidgetService {
     for (final i in files.entries) {
       for (final file in i.value) {
         final value = await HomeWidgetService.instance
-            .renderFile(file, "people_widget_$index", i.key)
+            .renderFile(
+          file,
+          "people_widget_$index",
+          i.key,
+          iOSGroupIDPeople,
+        )
             .catchError(
           (e, sT) {
             _logger.severe("Error rendering widget", e, sT);
diff --git a/mobile/lib/ui/settings/widgets/albums_widget_settings.dart b/mobile/lib/ui/settings/widgets/albums_widget_settings.dart
index e68d3f754cd..121267207c4 100644
--- a/mobile/lib/ui/settings/widgets/albums_widget_settings.dart
+++ b/mobile/lib/ui/settings/widgets/albums_widget_settings.dart
@@ -104,9 +104,9 @@ class _AlbumsWidgetSettingsState extends State<AlbumsWidgetSettings> {
                             _albums.map((e) => e.id.toString()).toList();
                         await AlbumHomeWidgetService.instance
                             .setSelectedAlbums(albums);
-                        // TODO: Run sync
-                        // await AlbumHomeWidgetService.instance.updateWidget();
                         Navigator.pop(context);
+                        await AlbumHomeWidgetService.instance
+                            .checkPendingAlbumsSync();
                       }
                     : null,
                 isDisabled: _albums.isEmpty,
