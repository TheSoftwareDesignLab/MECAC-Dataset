diff --git a/mobile/apps/auth/lib/l10n/arb/app_en.arb b/mobile/apps/auth/lib/l10n/arb/app_en.arb
index 57d2aeb53d8..d57415ff0a3 100644
--- a/mobile/apps/auth/lib/l10n/arb/app_en.arb
+++ b/mobile/apps/auth/lib/l10n/arb/app_en.arb
@@ -552,5 +552,38 @@
   "done": "Done",
   "addNew": "Add new",
   "selected": "selected",
-  "moveMultipleToTrashMessage": "Are you sure you want to move {count} item(s) to the trash?"
+  "moveMultipleToTrashMessage": "Are you sure you want to move {count} item(s) to the trash?",
+  "nSelected": "{count, plural, =1{1 selected} other{{count} selected}}",
+  "@nSelected": {
+    "description": "Text to indicate number of items selected",
+    "placeholders": {
+      "count": {
+        "description": "Number of items selected",
+        "type": "int",
+        "example": "5"
+      }
+    }
+  },
+  "pinnedCount": "{count, plural, =1{Pinned 1 item} other{Pinned {count} items}}",
+  "@pinnedCount": {
+    "description": "Text to show number of items pinned",
+    "placeholders": {
+      "count": {
+        "description": "Number of items pinned",
+        "type": "int",
+        "example": "3"
+      }
+    }
+  },
+  "unpinnedCount": "{count, plural, =1{Unpinned 1 item} other{Unpinned {count} items}}",
+  "@unpinnedCount": {
+    "description": "Text to show number of items unpinned",
+    "placeholders": {
+      "count": {
+        "description": "Number of items unpinned",
+        "type": "int",
+        "example": "2"
+      }
+    }
+  }
 }
\ No newline at end of file
diff --git a/mobile/apps/auth/lib/models/code.dart b/mobile/apps/auth/lib/models/code.dart
index 2d939c467ea..df3a5a9854a 100644
--- a/mobile/apps/auth/lib/models/code.dart
+++ b/mobile/apps/auth/lib/models/code.dart
@@ -33,11 +33,19 @@ class Code {
   final Object? err;
   bool get hasError => err != null;
 
-  /// Stable identifier for UI state (selection, animations, etc.).
-  /// Prefer generatedID since it is unique per stored code; fall back to rawData
-  /// when the code has not been persisted yet.
-  String get selectionKey =>
-      generatedID != null ? generatedID!.toString() : rawData;
+  /// Stable identifier for UI selection state and other transient UI features.
+  ///
+  /// This key ensures selection consistency across sync operations and local changes:
+  /// - Uses [generatedID] when available (after code is persisted to database)
+  /// - Falls back to [rawData] for unpersisted codes (before first save)
+  ///
+  /// The fallback strategy ensures that:
+  /// 1. Selections survive the transition from local-only to synced codes
+  /// 2. Each persisted code has a unique, stable identifier
+  /// 3. UI state reconciliation can map old keys to new keys during sync
+  ///
+  /// See [CodeDisplayStore.reconcileSelections] for selection state management.
+  String get selectionKey => generatedID?.toString() ?? rawData;
 
   String get issuerAccount =>
       account.isNotEmpty ? '$issuer ($account)' : issuer;
diff --git a/mobile/apps/auth/lib/store/code_display_store.dart b/mobile/apps/auth/lib/store/code_display_store.dart
index 944cd86686a..035ba70db0f 100644
--- a/mobile/apps/auth/lib/store/code_display_store.dart
+++ b/mobile/apps/auth/lib/store/code_display_store.dart
@@ -38,47 +38,67 @@ class CodeDisplayStore {
     isSelectionModeActive.value = false;
   }
 
-  /// Reconcile current selections with the provided list of codes.
-  /// This keeps the selection state consistent when codes receive a
-  /// generatedID during sync or are removed locally.
+  /// Reconciles current selections with the provided list of codes.
+  ///
+  /// This ensures selection state remains valid when:
+  /// - Codes transition from local to synced (rawData → generatedID)
+  /// - Codes are deleted or removed from the list
+  /// - Codes are marked with errors and become invalid for selection
+  ///
+  /// **How it works:**
+  /// 1. Builds a set of valid selection keys from non-error codes
+  /// 2. Creates a remapping table for old keys (rawData, old generatedID) → new keys
+  /// 3. Updates current selection by keeping valid keys and remapping changed keys
+  /// 4. Removes selections for codes that no longer exist or have errors
+  ///
+  /// **Performance:** O(n + m) where n = number of codes, m = number of selected items
+  ///
+  /// **Example scenario:**
+  /// ```dart
+  /// // User selects code with rawData="abc123" (not yet synced)
+  /// selectedCodeIds = {"abc123"}
+  ///
+  /// // After sync, code gets generatedID=42
+  /// // reconcileSelections maps "abc123" → "42"
+  /// selectedCodeIds = {"42"}  // Selection preserved!
+  /// ```
   void reconcileSelections(Iterable<Code> codes) {
     final currentSelection = selectedCodeIds.value;
     if (currentSelection.isEmpty) {
       return;
     }
 
-    final Set<String> validSelectionKeys = <String>{};
-    final Map<String, String> fallbackSelectionKeys = <String, String>{};
+    // Build lookup structures in a single pass - O(n)
+    final validKeys = <String>{};
+    final keyRemapping = <String, String>{};
 
     for (final code in codes) {
       if (code.hasError) {
         continue;
       }
+
       final key = code.selectionKey;
-      validSelectionKeys.add(key);
-      fallbackSelectionKeys[code.rawData] = key;
+      validKeys.add(key);
+
+      // Map old keys to current key to handle transitions
+      keyRemapping[code.rawData] = key;
       final generatedID = code.generatedID;
       if (generatedID != null) {
-        fallbackSelectionKeys[generatedID.toString()] = key;
+        keyRemapping[generatedID.toString()] = key;
       }
     }
 
-    bool hasChanges = false;
-    final Set<String> updatedSelection = <String>{};
-
-    for (final selectedKey in currentSelection) {
-      if (validSelectionKeys.contains(selectedKey)) {
-        updatedSelection.add(selectedKey);
-        continue;
-      }
-      final remappedKey = fallbackSelectionKeys[selectedKey];
-      if (remappedKey != null) {
-        updatedSelection.add(remappedKey);
-      }
-      hasChanges = true;
-    }
+    // Update selection in one pass - O(m)
+    final updatedSelection = currentSelection
+        .map(
+          (oldKey) =>
+              validKeys.contains(oldKey) ? oldKey : keyRemapping[oldKey],
+        )
+        .whereType<String>()
+        .toSet();
 
-    if (hasChanges) {
+    // Only update if selection changed
+    if (updatedSelection != currentSelection) {
       selectedCodeIds.value = updatedSelection;
       isSelectionModeActive.value = updatedSelection.isNotEmpty;
     }
diff --git a/mobile/apps/auth/lib/ui/code_widget.dart b/mobile/apps/auth/lib/ui/code_widget.dart
index 91d9dbadb83..35ac5cf9e55 100644
--- a/mobile/apps/auth/lib/ui/code_widget.dart
+++ b/mobile/apps/auth/lib/ui/code_widget.dart
@@ -561,7 +561,22 @@ class _CodeWidgetState extends State<CodeWidget> {
   List<ContextMenuEntry> _buildSingleSelectionMenu(AppLocalizations l10n) {
     final entries = <ContextMenuEntry>[];
 
-    if (!widget.code.isTrashed && widget.code.type.isTOTPCompatible) {
+    _addNonTrashedMenuItems(entries, l10n);
+    _addEditOrRestoreMenuItem(entries, l10n);
+    entries.add(const MenuDivider());
+    _addDeleteOrTrashMenuItem(entries, l10n);
+
+    return entries;
+  }
+
+  /// Adds menu items for non-trashed codes (share, QR, tag, notes, pin).
+  void _addNonTrashedMenuItems(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+  ) {
+    if (widget.code.isTrashed) return;
+
+    if (widget.code.type.isTOTPCompatible) {
       entries.add(
         MenuItem(
           label: l10n.share,
@@ -571,27 +586,26 @@ class _CodeWidgetState extends State<CodeWidget> {
       );
     }
 
-    if (!widget.code.isTrashed) {
-      entries.add(
-        MenuItem(
-          label: l10n.qr,
-          icon: Icons.qr_code_2_outlined,
-          onSelected: () => _onShowQrPressed(null),
-        ),
-      );
-      entries.add(
-        MenuItem(
-          label: l10n.addTag,
-          icon: Icons.local_offer_outlined,
-          onSelected: () {
-            CodeDisplayStore.instance.selectedCodeIds.value = {
-              widget.code.selectionKey,
-            };
-            _triggerMultiAction(MultiSelectAction.addTag);
-          },
-        ),
-      );
-    }
+    entries.add(
+      MenuItem(
+        label: l10n.qr,
+        icon: Icons.qr_code_2_outlined,
+        onSelected: () => _onShowQrPressed(null),
+      ),
+    );
+
+    entries.add(
+      MenuItem(
+        label: l10n.addTag,
+        icon: Icons.local_offer_outlined,
+        onSelected: () {
+          CodeDisplayStore.instance.selectedCodeIds.value = {
+            widget.code.selectionKey,
+          };
+          _triggerMultiAction(MultiSelectAction.addTag);
+        },
+      ),
+    );
 
     if (widget.code.note.isNotEmpty) {
       entries.add(
@@ -603,7 +617,7 @@ class _CodeWidgetState extends State<CodeWidget> {
       );
     }
 
-    if (!widget.code.isTrashed && !ignorePin) {
+    if (!ignorePin) {
       entries.add(
         MenuItem(
           label: widget.code.isPinned ? l10n.unpinText : l10n.pinText,
@@ -612,7 +626,13 @@ class _CodeWidgetState extends State<CodeWidget> {
         ),
       );
     }
+  }
 
+  /// Adds edit menu item for non-trashed codes or restore for trashed codes.
+  void _addEditOrRestoreMenuItem(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+  ) {
     if (!widget.code.isTrashed) {
       entries.add(
         MenuItem(
@@ -630,8 +650,13 @@ class _CodeWidgetState extends State<CodeWidget> {
         ),
       );
     }
+  }
 
-    entries.add(const MenuDivider());
+  /// Adds delete (forever) or trash menu item based on code state.
+  void _addDeleteOrTrashMenuItem(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+  ) {
     entries.add(
       MenuItem(
         label: widget.code.isTrashed ? l10n.delete : l10n.trash,
@@ -642,8 +667,6 @@ class _CodeWidgetState extends State<CodeWidget> {
             : _onTrashPressed(null),
       ),
     );
-
-    return entries;
   }
 
   List<ContextMenuEntry>? _buildMultiSelectionContextMenu(
@@ -664,29 +687,49 @@ class _CodeWidgetState extends State<CodeWidget> {
     final bool allTrashed = selectedCodes.every((code) => code.isTrashed);
 
     if (allTrashed) {
-      entries.add(
-        MenuItem(
-          label: l10n.restore,
-          icon: Icons.restore_outlined,
-          onSelected: () => _triggerMultiAction(MultiSelectAction.restore),
-        ),
-      );
-      entries.add(
-        MenuItem(
-          label: l10n.delete,
-          icon: Icons.delete_forever,
-          onSelected: () =>
-              _triggerMultiAction(MultiSelectAction.deleteForever),
-        ),
-      );
+      _addTrashedMultiSelectMenuItems(entries, l10n);
       return entries.isEmpty ? null : entries;
     }
 
+    _addPinMenuItems(entries, l10n, selectedCodes);
+    _addTagAndTrashMenuItems(entries, l10n);
+
+    return entries.isEmpty ? null : entries;
+  }
+
+  /// Adds menu items for multi-selected trashed codes (restore, delete).
+  void _addTrashedMultiSelectMenuItems(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+  ) {
+    entries.add(
+      MenuItem(
+        label: l10n.restore,
+        icon: Icons.restore_outlined,
+        onSelected: () => _triggerMultiAction(MultiSelectAction.restore),
+      ),
+    );
+    entries.add(
+      MenuItem(
+        label: l10n.delete,
+        icon: Icons.delete_forever,
+        onSelected: () => _triggerMultiAction(MultiSelectAction.deleteForever),
+      ),
+    );
+  }
+
+  /// Adds pin/unpin menu items based on selection pin state.
+  void _addPinMenuItems(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+    List<Code> selectedCodes,
+  ) {
     final bool allPinned = selectedCodes.every((code) => code.isPinned);
     final bool anyPinned = selectedCodes.any((code) => code.isPinned);
     final bool isMixedPinned = anyPinned && !allPinned;
 
     if (isMixedPinned) {
+      // Show both pin and unpin options for mixed state
       entries.add(
         MenuItem(
           label: l10n.pinText,
@@ -702,6 +745,7 @@ class _CodeWidgetState extends State<CodeWidget> {
         ),
       );
     } else {
+      // Show single toggle option for uniform state
       entries.add(
         MenuItem(
           label: allPinned ? l10n.unpinText : l10n.pinText,
@@ -710,7 +754,13 @@ class _CodeWidgetState extends State<CodeWidget> {
         ),
       );
     }
+  }
 
+  /// Adds tag and trash menu items for multi-selection.
+  void _addTagAndTrashMenuItems(
+    List<ContextMenuEntry> entries,
+    AppLocalizations l10n,
+  ) {
     entries.add(
       MenuItem(
         label: l10n.addTag,
@@ -726,8 +776,6 @@ class _CodeWidgetState extends State<CodeWidget> {
         onSelected: () => _triggerMultiAction(MultiSelectAction.trash),
       ),
     );
-
-    return entries.isEmpty ? null : entries;
   }
 
   void _triggerMultiAction(MultiSelectAction action) {
diff --git a/mobile/apps/auth/lib/ui/home_page.dart b/mobile/apps/auth/lib/ui/home_page.dart
index 1f03d125942..71eca71df07 100644
--- a/mobile/apps/auth/lib/ui/home_page.dart
+++ b/mobile/apps/auth/lib/ui/home_page.dart
@@ -297,7 +297,7 @@ class _HomePageState extends State<HomePage> {
           context.l10n.unpinnedCodeMessage(codesToUpdate.first.issuer),
         );
       } else {
-        showToast(context, 'Unpinned ${codesToUpdate.length} item(s)');
+        showToast(context, context.l10n.unpinnedCount(codesToUpdate.length));
       }
     } else {
       int pinnedCount = 0;
@@ -315,7 +315,7 @@ class _HomePageState extends State<HomePage> {
         final pinnedCode = codesToUpdate.firstWhere((c) => !c.isPinned);
         showToast(context, context.l10n.pinnedCodeMessage(pinnedCode.issuer));
       } else if (pinnedCount > 0) {
-        showToast(context, 'Pinned $pinnedCount item(s)');
+        showToast(context, context.l10n.pinnedCount(pinnedCount));
       }
     }
 
@@ -347,7 +347,7 @@ class _HomePageState extends State<HomePage> {
       final unpinnedCode = codesToUpdate.firstWhere((c) => c.isPinned);
       showToast(context, context.l10n.unpinnedCodeMessage(unpinnedCode.issuer));
     } else if (unpinnedCount > 0) {
-      showToast(context, 'Unpinned $unpinnedCount item(s)');
+      showToast(context, context.l10n.unpinnedCount(unpinnedCount));
     }
 
     _codeDisplayStore.clearSelection();
@@ -946,7 +946,7 @@ class _HomePageState extends State<HomePage> {
                                 mainAxisSize: MainAxisSize.min,
                                 children: [
                                   Text(
-                                    '${selectedIds.length} selected',
+                                    context.l10n.nSelected(selectedIds.length),
                                     style: const TextStyle(fontSize: 11),
                                   ),
                                   const SizedBox(width: 6),
