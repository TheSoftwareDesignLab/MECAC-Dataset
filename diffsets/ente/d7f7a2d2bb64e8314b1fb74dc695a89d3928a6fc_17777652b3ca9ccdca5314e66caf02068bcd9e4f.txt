diff --git a/mobile/apps/photos/lib/core/errors.dart b/mobile/apps/photos/lib/core/errors.dart
index d5482e3750c..a50a3dad702 100644
--- a/mobile/apps/photos/lib/core/errors.dart
+++ b/mobile/apps/photos/lib/core/errors.dart
@@ -114,3 +114,11 @@ class DuplicateUploadURLError extends Error {
       "First used at: $firstUsedAt, Duplicate attempt at: $duplicateUsedAt. "
       "This indicates a race condition in parallel uploads.";
 }
+
+class EncSizeMismatchError implements Exception {
+  final String message;
+  EncSizeMismatchError(this.message);
+
+  @override
+  String toString() => "EncSizeMismatchError: $message";
+}
diff --git a/mobile/apps/photos/lib/utils/file_uploader.dart b/mobile/apps/photos/lib/utils/file_uploader.dart
index 0c95bbcb514..77fb9007a31 100644
--- a/mobile/apps/photos/lib/utils/file_uploader.dart
+++ b/mobile/apps/photos/lib/utils/file_uploader.dart
@@ -662,6 +662,7 @@ class FileUploader {
                 collectionID,
               )
             : null;
+    final sourceLength = await mediaUploadData.sourceFile!.length();
     final bool hasExistingMultiPart = existingMultipartEncFileName != null;
     final tempDirectory = Configuration.instance.getTempDirectory();
     final String uniqueID =
@@ -766,6 +767,12 @@ class FileUploader {
         thumbnailData = mediaUploadData.thumbnail;
       }
       encFileSize = await encryptedFile.length();
+      if (!CryptoUtil.validateStreamEncryptionSizes(
+        sourceLength,
+        encFileSize,
+      )) {
+        throw EncSizeMismatchError("source $sourceLength, enc $encFileSize");
+      }
 
       final EncryptionResult encryptedThumbnailData =
           await CryptoUtil.encryptChaCha(
diff --git a/mobile/apps/photos/plugins/ente_crypto/lib/src/crypto.dart b/mobile/apps/photos/plugins/ente_crypto/lib/src/crypto.dart
index 4e513845c2e..cfd5b6756ba 100644
--- a/mobile/apps/photos/plugins/ente_crypto/lib/src/crypto.dart
+++ b/mobile/apps/photos/plugins/ente_crypto/lib/src/crypto.dart
@@ -620,4 +620,28 @@ class CryptoUtil {
       taskName: "fileHash",
     );
   }
+
+  /// Validates that the plaintext and ciphertext sizes match for streaming encryption.
+  /// Returns true if the sizes are valid for chunked ChaCha20-Poly1305 encryption.
+  ///
+  /// Each chunk adds 17 bytes (Sodium.cryptoSecretstreamXchacha20poly1305Abytes) overhead.
+  /// For a 4MB chunk size, the encrypted size is 4MB + 17 bytes per chunk.
+  static bool validateStreamEncryptionSizes(int plainTextSize, int cipherTextSize) {
+    if (plainTextSize <= 0 || cipherTextSize <= 0) {
+      return false;
+    }
+
+    final int chunkOverhead = Sodium.cryptoSecretstreamXchacha20poly1305Abytes;
+
+    // Calculate expected ciphertext size
+    final int fullChunks = plainTextSize ~/ encryptionChunkSize;
+    final int lastChunkSize = plainTextSize % encryptionChunkSize;
+
+    int expectedCipherTextSize = fullChunks * (encryptionChunkSize + chunkOverhead);
+    if (lastChunkSize > 0) {
+      expectedCipherTextSize += lastChunkSize + chunkOverhead;
+    }
+
+    return expectedCipherTextSize == cipherTextSize;
+  }
 }
