diff --git a/src/services/machineLearning/mlWorkManager.ts b/src/services/machineLearning/mlWorkManager.ts
index 0d7de2cc7a1..3bcccf4fbc9 100644
--- a/src/services/machineLearning/mlWorkManager.ts
+++ b/src/services/machineLearning/mlWorkManager.ts
@@ -8,6 +8,7 @@ import {
     MLSyncConfig,
 } from 'types/machineLearning';
 import { getToken } from 'utils/common/key';
+import { migrateFaceInterfaceUpdate } from 'utils/machineLearning/migrations';
 import { getDedicatedMLWorker } from 'utils/machineLearning/worker';
 import { logError } from 'utils/sentry';
 import { getData, LS_KEYS } from 'utils/storage/localStorage';
@@ -42,6 +43,7 @@ class MLWorkManager {
         try {
             const user = getData(LS_KEYS.USER);
             if (user?.token) {
+                await migrateFaceInterfaceUpdate();
                 this.startSyncJob();
             }
         } catch (e) {
diff --git a/src/utils/machineLearning/migrations.ts b/src/utils/machineLearning/migrations.ts
index d601443ab0b..a72e454b8e9 100644
--- a/src/utils/machineLearning/migrations.ts
+++ b/src/utils/machineLearning/migrations.ts
@@ -63,3 +63,73 @@ export async function migrateFaceCropsToCache() {
     }
     console.timeEnd('migrateFaceCropsToCache');
 }
+
+export async function migrateFaceInterfaceUpdate() {
+    console.time('migrateFaceInterfaceUpdate');
+    console.log('migrateFaceInterfaceUpdate started');
+
+    const faceSchemaVersion = await mlIDbStorage.getIndexVersion('faceSchema');
+    if (faceSchemaVersion) {
+        console.log('not running migrateFaceInterfaceUpdate');
+        return;
+    }
+
+    const allFiles = await mlIDbStorage.getAllFiles();
+
+    const updatedFiles = allFiles.map((file) => {
+        const updatedFaces = file.faces?.map((f) => {
+            const updatedFace = {
+                id: f['faceId'],
+                fileId: f.fileId,
+
+                detection: {
+                    box: f['box'],
+                    landmarks: f['landmarks'],
+                    probability: f['probability'],
+                },
+                crop: f['faceCrop'],
+                alignment: {
+                    affineMatrix: f['affineMatrix'],
+                    center: f['center'],
+                    rotation: f['rotation'],
+                    size: f['size'],
+                },
+                embedding: Float32Array.from(f.embedding),
+
+                personId: f.personId,
+            } as Face;
+            if (!updatedFace.id) {
+                updatedFace.id = getFaceId(updatedFace, file.imageDimentions);
+            }
+            return updatedFace;
+        });
+        const updated: MlFileData = {
+            fileId: file.fileId,
+
+            faceDetectionMethod: file['detectionMethod'],
+            faceCropMethod: {
+                value: 'ArcFace',
+                version: 1,
+            },
+            faceAlignmentMethod: file['alignmentMethod'],
+            faceEmbeddingMethod: file['embeddingMethod'],
+
+            faces: updatedFaces,
+
+            imageDimentions: file.imageDimentions,
+            imageSource: file.imageSource,
+            errorCount: file.errorCount,
+            lastErrorMessage: file.lastErrorMessage,
+            mlVersion: file.mlVersion,
+        };
+
+        return updated;
+    });
+
+    console.log('migrateFaceInterfaceUpdate updating: ', updatedFiles.length);
+    await mlIDbStorage.putAllFilesInTx(updatedFiles);
+
+    await mlIDbStorage.incrementIndexVersion('faceSchema');
+    console.log('migrateFaceInterfaceUpdate done');
+    console.timeEnd('migrateFaceInterfaceUpdate');
+}
diff --git a/src/utils/storage/mlIDbStorage.ts b/src/utils/storage/mlIDbStorage.ts
index a11c01c2cda..bdac7a3d4b2 100644
--- a/src/utils/storage/mlIDbStorage.ts
+++ b/src/utils/storage/mlIDbStorage.ts
@@ -64,19 +64,19 @@ class MLIDbStorage {
         return deleteDB('mldata');
     }
 
-    public async getAllFileIds1() {
+    public async getAllFileIds() {
         const db = await this.db;
         return db.getAllKeys('files');
     }
 
-    public async putAllFiles1(mlFiles: Array<MlFileData>) {
+    public async putAllFilesInTx(mlFiles: Array<MlFileData>) {
         const db = await this.db;
         const tx = db.transaction('files', 'readwrite');
         await Promise.all(mlFiles.map((mlFile) => tx.store.put(mlFile)));
         await tx.done;
     }
 
-    public async removeAllFiles1(fileIds: Array<number>) {
+    public async removeAllFilesInTx(fileIds: Array<number>) {
         const db = await this.db;
         const tx = db.transaction('files', 'readwrite');
 
