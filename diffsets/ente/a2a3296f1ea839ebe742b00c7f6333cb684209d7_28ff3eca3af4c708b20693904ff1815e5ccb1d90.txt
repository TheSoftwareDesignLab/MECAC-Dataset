diff --git a/mobile/apps/photos/lib/services/wrapped/candidate_builders.dart b/mobile/apps/photos/lib/services/wrapped/candidate_builders.dart
index 871cceb0ed3..c6b1e4c09cc 100644
--- a/mobile/apps/photos/lib/services/wrapped/candidate_builders.dart
+++ b/mobile/apps/photos/lib/services/wrapped/candidate_builders.dart
@@ -46,9 +46,9 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
     final List<WrappedCard> cards = <WrappedCard>[];
     cards.add(_buildTotalsCard(snapshot));
 
-    final WrappedCard? velocityCard = _buildVelocityCard(snapshot);
-    if (velocityCard != null) {
-      cards.add(velocityCard);
+    final WrappedCard? rhythmCard = _buildRhythmCard(snapshot);
+    if (rhythmCard != null) {
+      cards.add(rhythmCard);
     }
 
     final WrappedCard? busiestDayCard = _buildBusiestDayCard(snapshot);
@@ -56,48 +56,56 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
       cards.add(busiestDayCard);
     }
 
-    final WrappedCard? streakCard = _buildLongestStreakCard(snapshot);
-    if (streakCard != null) {
-      cards.add(streakCard);
-    }
-
-    final WrappedCard? gapCard = _buildLongestGapCard(snapshot);
-    if (gapCard != null) {
-      cards.add(gapCard);
-    }
+    cards.addAll(_buildHeatmapCards(snapshot));
 
     return cards;
   }
 
   WrappedCard _buildTotalsCard(_StatsSnapshot snapshot) {
     final NumberFormat numberFormat = NumberFormat.decimalPattern();
+    final DateFormat fullDateFormat = DateFormat("MMMM d");
+
     final int stillPhotoCount =
         math.max(snapshot.photoCount - snapshot.livePhotoCount, 0);
-    final List<String> detailParts = <String>[];
+    final List<String> detailChips = <String>[];
     if (stillPhotoCount > 0) {
-      detailParts
-          .add("${numberFormat.format(stillPhotoCount)} ${stillPhotoCount == 1 ? 'photo' : 'photos'}");
+      detailChips.add(
+        "${numberFormat.format(stillPhotoCount)} ${stillPhotoCount == 1 ? 'photo' : 'photos'}",
+      );
     }
     if (snapshot.livePhotoCount > 0) {
-      detailParts.add(
+      detailChips.add(
         "${numberFormat.format(snapshot.livePhotoCount)} live ${snapshot.livePhotoCount == 1 ? 'photo' : 'photos'}",
       );
     }
     if (snapshot.videoCount > 0) {
-      detailParts
-          .add("${numberFormat.format(snapshot.videoCount)} ${snapshot.videoCount == 1 ? 'video' : 'videos'}");
-    }
-    if (snapshot.otherCount > 0) {
-      detailParts.add(
-        "${numberFormat.format(snapshot.otherCount)} other ${snapshot.otherCount == 1 ? 'item' : 'items'}",
+      detailChips.add(
+        "${numberFormat.format(snapshot.videoCount)} ${snapshot.videoCount == 1 ? 'video' : 'videos'}",
       );
     }
     if (snapshot.storageBytes > 0) {
-      detailParts.add("${formatBytes(snapshot.storageBytes, 1)} captured");
+      detailChips.add("${formatBytes(snapshot.storageBytes, 1)} captured");
     }
 
     final String title =
-        "You captured ${numberFormat.format(snapshot.totalCount)} moments";
+        "You bottled ${numberFormat.format(snapshot.totalCount)} memories";
+    final String subtitle = snapshot.videoCount > 0
+        ? "That’s ${numberFormat.format(snapshot.photoCount)} photos and "
+            "${numberFormat.format(snapshot.videoCount)} videos ready to relive."
+        : "That’s ${numberFormat.format(snapshot.photoCount)} photos you kept close this year.";
+
+    final List<int> heroIds = _collectUniqueIds(
+      <List<int>>[
+        snapshot.firstCaptureUploadedIDs,
+        snapshot.busiestDayMediaUploadedIDs,
+        snapshot.lastCaptureUploadedIDs,
+      ],
+    );
+
+    final String? firstCaptureLine = snapshot.firstCaptureDay != null
+        ? "First frame: ${fullDateFormat.format(snapshot.firstCaptureDay!)}"
+        : null;
+
     final Map<String, Object?> meta = <String, Object?>{
       "year": snapshot.year,
       "totalCount": snapshot.totalCount,
@@ -111,17 +119,21 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
           : "0 bytes",
       "daysWithCaptures": snapshot.daysWithCaptures,
       "elapsedDays": snapshot.elapsedDays,
+      "detailChips": detailChips,
+      if (firstCaptureLine != null) "firstCaptureLine": firstCaptureLine,
+      "displayDurationMillis": 9000,
     };
 
     return WrappedCard(
       type: WrappedCardType.statsTotals,
       title: title,
-      subtitle: detailParts.isEmpty ? null : detailParts.join(" · "),
+      subtitle: subtitle,
+      media: heroIds.map(MediaRef.new).toList(growable: false),
       meta: meta,
     );
   }
 
-  WrappedCard? _buildVelocityCard(_StatsSnapshot snapshot) {
+  WrappedCard? _buildRhythmCard(_StatsSnapshot snapshot) {
     if (snapshot.elapsedDays <= 0) {
       return null;
     }
@@ -151,6 +163,22 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
       );
     }
 
+    final List<String> chips = <String>[
+      "${numberFormat.format(snapshot.daysWithCaptures)} active days",
+      if (snapshot.longestStreakDays >= 3)
+        "Longest streak: ${numberFormat.format(snapshot.longestStreakDays)} days",
+      if (snapshot.longestGapDays >= 2)
+        "Longest breather: ${numberFormat.format(snapshot.longestGapDays)} days",
+    ];
+
+    final List<int> rhythmIds = _collectUniqueIds(
+      <List<int>>[
+        snapshot.streakStartUploadedIDs,
+        snapshot.busiestMonthHighlightUploadedIDs,
+        snapshot.breakReturnUploadedIDs,
+      ],
+    );
+
     final Map<String, Object?> meta = <String, Object?>{
       "year": snapshot.year,
       "averagePerDay": snapshot.averagePerDay,
@@ -165,12 +193,24 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
           entry.key.toString(): entry.value,
       },
       "dailyCounts": snapshot.dailyCounts,
+      "detailChips": chips,
+      if (snapshot.longestStreakStart != null)
+        "longestStreakStart": snapshot.longestStreakStart!.toIso8601String(),
+      if (snapshot.longestStreakEnd != null)
+        "longestStreakEnd": snapshot.longestStreakEnd!.toIso8601String(),
+      "longestStreakDays": snapshot.longestStreakDays,
+      "longestGapDays": snapshot.longestGapDays,
+      if (snapshot.longestGapStart != null)
+        "longestGapStart": snapshot.longestGapStart!.toIso8601String(),
+      if (snapshot.longestGapEnd != null)
+        "longestGapEnd": snapshot.longestGapEnd!.toIso8601String(),
     };
 
     return WrappedCard(
       type: WrappedCardType.statsVelocity,
       title: title,
       subtitle: subtitleParts.join(" · "),
+      media: rhythmIds.map(MediaRef.new).toList(growable: false),
       meta: meta,
     );
   }
@@ -186,7 +226,7 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
     final DateTime day = snapshot.busiestDay!;
 
     final List<MediaRef> mediaRefs = snapshot.busiestDayMediaUploadedIDs
-        .take(4)
+        .take(6)
         .map(MediaRef.new)
         .toList(growable: false);
 
@@ -194,79 +234,72 @@ class StatsCandidateBuilder extends WrappedCandidateBuilder {
       "date": day.toIso8601String(),
       "weekday": weekdayFormat.format(day),
       "count": snapshot.busiestDayCount,
+      "detailChips": <String>[
+        "${numberFormat.format(snapshot.busiestDayCount)} memories in 24 hours",
+        weekdayFormat.format(day),
+      ],
       if (mediaRefs.isNotEmpty)
         "uploadedFileIDs": snapshot.busiestDayMediaUploadedIDs,
     };
 
     return WrappedCard(
       type: WrappedCardType.busiestDay,
-      title: "${longDateFormat.format(day)} was your biggest day",
+      title: "${longDateFormat.format(day)} went off",
       subtitle:
-          "${numberFormat.format(snapshot.busiestDayCount)} memories captured",
+          "${numberFormat.format(snapshot.busiestDayCount)} memories captured in a single day.",
       media: mediaRefs,
       meta: meta,
     );
   }
 
-  WrappedCard? _buildLongestStreakCard(_StatsSnapshot snapshot) {
-    if (snapshot.longestStreakDays < 2 ||
-        snapshot.longestStreakStart == null ||
-        snapshot.longestStreakEnd == null) {
-      return null;
+  List<WrappedCard> _buildHeatmapCards(_StatsSnapshot snapshot) {
+    if (snapshot.heatmapRows.isEmpty) {
+      return const <WrappedCard>[];
     }
 
-    final NumberFormat numberFormat = NumberFormat.decimalPattern();
-    final DateFormat shortFormat = DateFormat("MMM d");
-    final DateFormat longFormat = DateFormat("MMM d, yyyy");
-
-    final DateTime start = snapshot.longestStreakStart!;
-    final DateTime end = snapshot.longestStreakEnd!;
-    final bool singleDay = start.isAtSameMomentAs(end);
-
-    final String subtitle = singleDay
-        ? longFormat.format(start)
-        : "${start.year == end.year ? shortFormat.format(start) : longFormat.format(start)} – ${longFormat.format(end)}";
-
-    return WrappedCard(
-      type: WrappedCardType.longestStreak,
-      title:
-          "Longest streak: ${numberFormat.format(snapshot.longestStreakDays)} days",
-      subtitle: subtitle,
-      meta: <String, Object?>{
-        "length": snapshot.longestStreakDays,
-        "start": start.toIso8601String(),
-        "end": end.toIso8601String(),
-      },
-    );
-  }
-
-  WrappedCard? _buildLongestGapCard(_StatsSnapshot snapshot) {
-    if (snapshot.longestGapDays <= 0 ||
-        snapshot.longestGapStart == null ||
-        snapshot.longestGapEnd == null) {
-      return null;
+    final List<Map<String, Object?>> quarterBlocks =
+        _QuarterHeatmapData.fromSnapshot(snapshot);
+    if (quarterBlocks.isEmpty) {
+      return const <WrappedCard>[];
     }
 
     final NumberFormat numberFormat = NumberFormat.decimalPattern();
-    final DateFormat longFormat = DateFormat("MMM d, yyyy");
-    final DateTime start = snapshot.longestGapStart!;
-    final DateTime end = snapshot.longestGapEnd!;
+    final Map<String, Object?> meta = <String, Object?>{
+      "weekdayLabels": snapshot.heatmapWeekdayLabels,
+      "quarters": quarterBlocks,
+      "maxCount": snapshot.heatmapMaxCount,
+      "detailChips": <String>[
+        if (snapshot.busiestMonthName != null)
+          "Peak month: ${snapshot.busiestMonthName}",
+        "${numberFormat.format(snapshot.totalCount)} captures this year",
+      ],
+    };
 
-    final String subtitle = start.isAtSameMomentAs(end)
-        ? longFormat.format(start)
-        : "${longFormat.format(start)} – ${longFormat.format(end)}";
+    return <WrappedCard>[
+      WrappedCard(
+        type: WrappedCardType.statsHeatmap,
+        title: "Seasons of snapshots",
+        subtitle: "Your year, one quarter at a time.",
+        meta: meta,
+      ),
+    ];
+  }
 
-    return WrappedCard(
-      type: WrappedCardType.longestGap,
-      title:
-          "Longest break: ${numberFormat.format(snapshot.longestGapDays)} days",
-      subtitle: subtitle,
-      meta: <String, Object?>{
-        "length": snapshot.longestGapDays,
-        "start": start.toIso8601String(),
-        "end": end.toIso8601String(),
-      },
-    );
+  List<int> _collectUniqueIds(List<List<int>> sources) {
+    final Set<int> seen = <int>{};
+    final List<int> result = <int>[];
+    for (final List<int> source in sources) {
+      for (final int id in source) {
+        if (id <= 0) continue;
+        if (seen.add(id)) {
+          result.add(id);
+        }
+        if (result.length >= 6) {
+          return result;
+        }
+      }
+    }
+    return result;
   }
 }
 
@@ -358,15 +391,31 @@ class _StatsSnapshot {
     required this.averagePerActiveDay,
     required this.busiestMonth,
     required this.busiestMonthCount,
+    required this.busiestMonthName,
     required this.busiestDay,
     required this.busiestDayCount,
     required this.busiestDayMediaUploadedIDs,
     required this.longestStreakDays,
     required this.longestStreakStart,
     required this.longestStreakEnd,
+    required this.streakStartUploadedIDs,
     required this.longestGapDays,
     required this.longestGapStart,
     required this.longestGapEnd,
+    required this.breakReturnUploadedIDs,
+    required this.firstCaptureDay,
+    required this.firstCaptureUploadedIDs,
+    required this.lastCaptureDay,
+    required this.lastCaptureUploadedIDs,
+    required this.busiestMonthHighlightUploadedIDs,
+    required this.periodEndDay,
+    required this.heatmapStart,
+    required this.heatmapEnd,
+    required this.heatmapRows,
+    required this.heatmapWeekLabels,
+    required this.heatmapWeekdayLabels,
+    required this.heatmapWeekStartDates,
+    required this.heatmapMaxCount,
   });
 
   final int year;
@@ -384,20 +433,37 @@ class _StatsSnapshot {
   final double averagePerActiveDay;
   final int? busiestMonth;
   final int busiestMonthCount;
+  final String? busiestMonthName;
   final DateTime? busiestDay;
   final int busiestDayCount;
   final List<int> busiestDayMediaUploadedIDs;
   final int longestStreakDays;
   final DateTime? longestStreakStart;
   final DateTime? longestStreakEnd;
+  final List<int> streakStartUploadedIDs;
   final int longestGapDays;
   final DateTime? longestGapStart;
   final DateTime? longestGapEnd;
+  final List<int> breakReturnUploadedIDs;
+  final DateTime? firstCaptureDay;
+  final List<int> firstCaptureUploadedIDs;
+  final DateTime? lastCaptureDay;
+  final List<int> lastCaptureUploadedIDs;
+  final List<int> busiestMonthHighlightUploadedIDs;
+  final DateTime periodEndDay;
+  final DateTime heatmapStart;
+  final DateTime heatmapEnd;
+  final List<List<int>> heatmapRows;
+  final List<String> heatmapWeekLabels;
+  final List<String> heatmapWeekdayLabels;
+  final List<DateTime> heatmapWeekStartDates;
+  final int heatmapMaxCount;
 
   static _StatsSnapshot fromContext(WrappedEngineContext context) {
     final int year = context.year;
     final DateTime startOfYear = DateTime(year, 1, 1);
     final DateTime periodEndDay = _resolvePeriodEndDay(context.now, year);
+    final DateFormat monthNameFormat = DateFormat("MMMM");
     final Map<int, int> monthCounts = <int, int>{
       for (int month = 1; month <= 12; month += 1) month: 0,
     };
@@ -453,9 +519,9 @@ class _StatsSnapshot {
       }
     }
 
-    final List<_DayAggregate> sortedAggregates =
-        dayAggregates.values.toList(growable: false)
-          ..sort((a, b) => a.day.compareTo(b.day));
+    final List<_DayAggregate> sortedAggregates = dayAggregates.values
+        .toList(growable: false)
+      ..sort((a, b) => a.day.compareTo(b.day));
 
     final int daysWithCaptures = sortedAggregates.length;
     final Map<String, int> dailyCounts = <String, int>{
@@ -463,14 +529,27 @@ class _StatsSnapshot {
         aggregate.day.toIso8601String(): aggregate.count,
     };
 
+    final DateTime? firstCaptureDay =
+        sortedAggregates.isEmpty ? null : sortedAggregates.first.day;
+    final List<int> firstCaptureUploadedIDs = firstCaptureDay == null
+        ? const <int>[]
+        : List<int>.unmodifiable(sortedAggregates.first.uploadedFileIDs);
+    final DateTime? lastCaptureDay =
+        sortedAggregates.isEmpty ? null : sortedAggregates.last.day;
+    final List<int> lastCaptureUploadedIDs = lastCaptureDay == null
+        ? const <int>[]
+        : List<int>.unmodifiable(sortedAggregates.last.uploadedFileIDs);
+
     int? busiestMonth;
     int busiestMonthCount = 0;
+    String? busiestMonthName;
     monthCounts.forEach((int month, int count) {
       if (count > busiestMonthCount ||
           (count == busiestMonthCount &&
               (busiestMonth == null || month < busiestMonth!))) {
         busiestMonth = month;
         busiestMonthCount = count;
+        busiestMonthName = monthNameFormat.format(DateTime(year, month, 1));
       }
     });
 
@@ -484,15 +563,46 @@ class _StatsSnapshot {
       }
     }
 
+    final List<int> busiestMonthHighlightUploadedIDs;
+    if (busiestMonth == null) {
+      busiestMonthHighlightUploadedIDs = const <int>[];
+    } else {
+      _DayAggregate? bestInMonth;
+      for (final _DayAggregate aggregate in sortedAggregates) {
+        if (aggregate.day.month != busiestMonth) {
+          continue;
+        }
+        if (bestInMonth == null ||
+            aggregate.count > bestInMonth.count ||
+            (aggregate.count == bestInMonth.count &&
+                aggregate.day.isBefore(bestInMonth.day))) {
+          bestInMonth = aggregate;
+        }
+      }
+      busiestMonthHighlightUploadedIDs = bestInMonth == null
+          ? const <int>[]
+          : List<int>.unmodifiable(bestInMonth.uploadedFileIDs);
+    }
+
     final _StreakResult streakResult =
         _calculateLongestStreak(sortedAggregates);
     final _GapResult gapResult =
         _calculateLongestGap(sortedAggregates, startOfYear, periodEndDay);
 
+    final List<int> streakStartUploadedIDs =
+        _uploadedIDsForDay(dayAggregates, streakResult.start);
+
+    List<int> breakReturnUploadedIDs = const <int>[];
+    if (gapResult.length > 0 && gapResult.end != null) {
+      final DateTime resumeDay = gapResult.end!.add(const Duration(days: 1));
+      if (resumeDay.year == year) {
+        breakReturnUploadedIDs = _uploadedIDsForDay(dayAggregates, resumeDay);
+      }
+    }
+
     int rawElapsedDays = periodEndDay.difference(startOfYear).inDays;
     if (rawElapsedDays < 0) rawElapsedDays = 0;
-    final int elapsedDays =
-        math.max(1, math.min(rawElapsedDays + 1, 366));
+    final int elapsedDays = math.max(1, math.min(rawElapsedDays + 1, 366));
 
     final double averagePerDay =
         elapsedDays > 0 ? totalCount / elapsedDays : 0.0;
@@ -501,10 +611,70 @@ class _StatsSnapshot {
 
     final DateTime? busiestDay = busiestDayAggregate?.day;
     final int busiestDayCount = busiestDayAggregate?.count ?? 0;
-    final List<int> busiestDayMediaUploadedIDs =
-        busiestDayAggregate == null || busiestDayAggregate.uploadedFileIDs.isEmpty
-            ? const <int>[]
-            : List<int>.unmodifiable(busiestDayAggregate.uploadedFileIDs);
+    final List<int> busiestDayMediaUploadedIDs = busiestDayAggregate == null ||
+            busiestDayAggregate.uploadedFileIDs.isEmpty
+        ? const <int>[]
+        : List<int>.unmodifiable(busiestDayAggregate.uploadedFileIDs);
+
+    final DateTime heatmapStart = _alignToMonday(DateTime(year, 1, 1));
+    final DateTime heatmapEnd = _alignToSunday(DateTime(year, 12, 31));
+    final int heatmapDayCount = heatmapEnd.difference(heatmapStart).inDays + 1;
+    final int heatmapWeekCount = heatmapDayCount ~/ 7;
+    final List<List<int>> heatmapRows = List<List<int>>.generate(
+      heatmapWeekCount,
+      (_) => List<int>.filled(7, 0),
+      growable: false,
+    );
+    final List<DateTime> heatmapWeekStartDates =
+        List<DateTime>.filled(heatmapWeekCount, heatmapStart);
+    int heatmapMaxCount = 0;
+    DateTime weekCursor = heatmapStart;
+    for (int weekIndex = 0; weekIndex < heatmapWeekCount; weekIndex += 1) {
+      heatmapWeekStartDates[weekIndex] = weekCursor;
+      for (int dayOffset = 0; dayOffset < 7; dayOffset += 1) {
+        final DateTime day = weekCursor.add(Duration(days: dayOffset));
+        final int count = dailyCounts[day.toIso8601String()] ?? 0;
+        heatmapRows[weekIndex][dayOffset] = count;
+        if (count > heatmapMaxCount) {
+          heatmapMaxCount = count;
+        }
+      }
+      weekCursor = weekCursor.add(const Duration(days: 7));
+    }
+
+    final DateFormat monthAbbrevFormat = DateFormat("MMM");
+    final List<String> heatmapWeekLabels =
+        List<String>.filled(heatmapWeekCount, "", growable: false);
+    int? lastLabeledMonth;
+    for (int row = 0; row < heatmapWeekCount; row += 1) {
+      final DateTime weekStart = heatmapWeekStartDates[row];
+      final DateTime weekEnd = weekStart.add(const Duration(days: 6));
+      final int representativeMonth = weekEnd.month;
+      if (row == 0 || representativeMonth != lastLabeledMonth) {
+        heatmapWeekLabels[row] = monthAbbrevFormat.format(weekEnd);
+        lastLabeledMonth = representativeMonth;
+      }
+    }
+
+    const List<String> heatmapWeekdayLabels = <String>[
+      "M",
+      "T",
+      "W",
+      "T",
+      "F",
+      "S",
+      "S",
+    ];
+
+    final List<List<int>> normalizedHeatmapRows = heatmapRows
+        .map((List<int> row) => List<int>.unmodifiable(row))
+        .toList(growable: false);
+    final List<String> normalizedWeekLabels =
+        List<String>.unmodifiable(heatmapWeekLabels);
+    final List<String> normalizedWeekdayLabels =
+        List<String>.unmodifiable(heatmapWeekdayLabels);
+    final List<DateTime> normalizedWeekStartDates =
+        List<DateTime>.unmodifiable(heatmapWeekStartDates);
 
     return _StatsSnapshot(
       year: year,
@@ -522,15 +692,31 @@ class _StatsSnapshot {
       averagePerActiveDay: averagePerActiveDay,
       busiestMonth: busiestMonth,
       busiestMonthCount: busiestMonthCount,
+      busiestMonthName: busiestMonthName,
       busiestDay: busiestDay,
       busiestDayCount: busiestDayCount,
       busiestDayMediaUploadedIDs: busiestDayMediaUploadedIDs,
       longestStreakDays: streakResult.length,
       longestStreakStart: streakResult.start,
       longestStreakEnd: streakResult.end,
+      streakStartUploadedIDs: streakStartUploadedIDs,
       longestGapDays: gapResult.length,
       longestGapStart: gapResult.start,
       longestGapEnd: gapResult.end,
+      breakReturnUploadedIDs: breakReturnUploadedIDs,
+      firstCaptureDay: firstCaptureDay,
+      firstCaptureUploadedIDs: firstCaptureUploadedIDs,
+      lastCaptureDay: lastCaptureDay,
+      lastCaptureUploadedIDs: lastCaptureUploadedIDs,
+      busiestMonthHighlightUploadedIDs: busiestMonthHighlightUploadedIDs,
+      periodEndDay: periodEndDay,
+      heatmapStart: heatmapStart,
+      heatmapEnd: heatmapEnd,
+      heatmapRows: normalizedHeatmapRows,
+      heatmapWeekLabels: normalizedWeekLabels,
+      heatmapWeekdayLabels: normalizedWeekdayLabels,
+      heatmapWeekStartDates: normalizedWeekStartDates,
+      heatmapMaxCount: heatmapMaxCount,
     );
   }
 }
@@ -543,6 +729,124 @@ class _DayAggregate {
   final List<int> uploadedFileIDs = <int>[];
 }
 
+class _QuarterHeatmapData {
+  static List<Map<String, Object?>> fromSnapshot(_StatsSnapshot snapshot) {
+    if (snapshot.heatmapRows.isEmpty) {
+      return const <Map<String, Object?>>[];
+    }
+    final DateFormat monthFormat = DateFormat("MMM");
+    final DateTime lastVisibleDay =
+        snapshot.periodEndDay.isBefore(snapshot.heatmapEnd)
+            ? snapshot.periodEndDay
+            : snapshot.heatmapEnd;
+    final List<List<List<int>>> quarterWeeks =
+        List<List<List<int>>>.generate(4, (_) => <List<int>>[]);
+    final List<List<DateTime>> quarterWeekDates =
+        List<List<DateTime>>.generate(4, (_) => <DateTime>[]);
+
+    for (int index = 0;
+        index < snapshot.heatmapRows.length &&
+            index < snapshot.heatmapWeekStartDates.length;
+        index += 1) {
+      final DateTime weekStart = snapshot.heatmapWeekStartDates[index];
+      if (weekStart.isAfter(lastVisibleDay)) {
+        continue;
+      }
+      final int quarterIndex = ((weekStart.month - 1) ~/ 3).clamp(0, 3);
+      final List<int> counts = snapshot.heatmapRows[index];
+      final List<int> sanitized = List<int>.filled(7, 0);
+      for (int dayOffset = 0; dayOffset < 7; dayOffset += 1) {
+        final DateTime day = weekStart.add(Duration(days: dayOffset));
+        if (day.isAfter(lastVisibleDay)) {
+          sanitized[dayOffset] = -1;
+        } else {
+          sanitized[dayOffset] =
+              dayOffset < counts.length ? counts[dayOffset] : 0;
+        }
+      }
+      quarterWeeks[quarterIndex].add(sanitized);
+      quarterWeekDates[quarterIndex].add(weekStart);
+    }
+
+    final List<Map<String, Object?>> blocks = <Map<String, Object?>>[];
+    for (int quarter = 0; quarter < quarterWeeks.length; quarter += 1) {
+      final List<List<int>> weeks = quarterWeeks[quarter];
+      if (weeks.isEmpty) {
+        continue;
+      }
+      final List<List<int>> grid = _transposeWeeks(weeks);
+      final List<String> columnLabels =
+          _buildColumnLabels(quarterWeekDates[quarter], monthFormat);
+      blocks.add(<String, Object?>{
+        "label": _quarterLabel(quarter),
+        "grid": grid
+            .map((List<int> row) => List<int>.unmodifiable(row))
+            .toList(growable: false),
+        "columnLabels": columnLabels,
+      });
+    }
+    return blocks;
+  }
+
+  static List<List<int>> _transposeWeeks(List<List<int>> weeks) {
+    if (weeks.isEmpty) {
+      return List<List<int>>.generate(
+        7,
+        (_) => const <int>[],
+        growable: false,
+      );
+    }
+    final int columnCount = weeks.length;
+    final int rowCount = weeks.first.length;
+    return List<List<int>>.generate(
+      rowCount,
+      (int dayIndex) => List<int>.generate(
+        columnCount,
+        (int columnIndex) => weeks[columnIndex][dayIndex],
+        growable: false,
+      ),
+      growable: false,
+    );
+  }
+
+  static List<String> _buildColumnLabels(
+    List<DateTime> weekStarts,
+    DateFormat monthFormat,
+  ) {
+    final List<String> labels = <String>[];
+    int? lastMonth;
+    for (final DateTime start in weekStarts) {
+      final int month = start.month;
+      final bool isNewMonth = labels.isEmpty || month != lastMonth;
+      final bool isQuarterStart = start.day <= 7;
+      if (isNewMonth && isQuarterStart) {
+        final String monthLabel = monthFormat.format(start);
+        final String singleChar =
+            monthLabel.isEmpty ? "" : monthLabel.substring(0, 1);
+        labels.add(singleChar.toUpperCase());
+        lastMonth = month;
+      } else {
+        labels.add("");
+      }
+    }
+    return List<String>.unmodifiable(labels);
+  }
+
+  static String _quarterLabel(int index) {
+    switch (index) {
+      case 0:
+        return "Jan – Mar";
+      case 1:
+        return "Apr – Jun";
+      case 2:
+        return "Jul – Sep";
+      case 3:
+      default:
+        return "Oct – Dec";
+    }
+  }
+}
+
 class _StreakResult {
   const _StreakResult({
     required this.length,
@@ -661,6 +965,22 @@ _GapResult _calculateLongestGap(
   return _GapResult(length: longest, start: gapStart, end: gapEnd);
 }
 
+List<int> _uploadedIDsForDay(
+  Map<int, _DayAggregate> aggregates,
+  DateTime? day,
+) {
+  if (day == null) {
+    return const <int>[];
+  }
+  final DateTime normalized = DateTime(day.year, day.month, day.day);
+  final _DayAggregate? aggregate =
+      aggregates[normalized.microsecondsSinceEpoch];
+  if (aggregate == null || aggregate.uploadedFileIDs.isEmpty) {
+    return const <int>[];
+  }
+  return List<int>.unmodifiable(aggregate.uploadedFileIDs);
+}
+
 DateTime _resolvePeriodEndDay(DateTime now, int year) {
   if (now.year < year) {
     return DateTime(year, 12, 31);
@@ -670,3 +990,23 @@ DateTime _resolvePeriodEndDay(DateTime now, int year) {
   }
   return DateTime(year, now.month, now.day);
 }
+
+DateTime _alignToMonday(DateTime date) {
+  int delta = date.weekday - DateTime.monday;
+  if (delta < 0) {
+    delta += 7;
+  }
+  return DateTime(date.year, date.month, date.day).subtract(
+    Duration(days: delta),
+  );
+}
+
+DateTime _alignToSunday(DateTime date) {
+  int delta = DateTime.sunday - date.weekday;
+  if (delta < 0) {
+    delta += 7;
+  }
+  return DateTime(date.year, date.month, date.day).add(
+    Duration(days: delta),
+  );
+}
diff --git a/mobile/apps/photos/lib/services/wrapped/models.dart b/mobile/apps/photos/lib/services/wrapped/models.dart
index 2eee2c68eb9..0e6eb8c0851 100644
--- a/mobile/apps/photos/lib/services/wrapped/models.dart
+++ b/mobile/apps/photos/lib/services/wrapped/models.dart
@@ -126,6 +126,7 @@ class MediaRef {
 enum WrappedCardType {
   statsTotals,
   statsVelocity,
+  statsHeatmap,
   busiestDay,
   longestStreak,
   longestGap,
diff --git a/mobile/apps/photos/lib/ui/wrapped/wrapped_viewer_page.dart b/mobile/apps/photos/lib/ui/wrapped/wrapped_viewer_page.dart
index 94c983a3cf4..180fe1bc192 100644
--- a/mobile/apps/photos/lib/ui/wrapped/wrapped_viewer_page.dart
+++ b/mobile/apps/photos/lib/ui/wrapped/wrapped_viewer_page.dart
@@ -1,10 +1,13 @@
 import "dart:async";
+import "dart:math" as math;
 import "dart:typed_data";
 import "dart:ui" as ui;
 
 import "package:flutter/material.dart";
 import "package:flutter/rendering.dart";
 import "package:logging/logging.dart";
+import "package:photos/db/files_db.dart";
+import "package:photos/models/file/file.dart";
 import "package:photos/service_locator.dart";
 import "package:photos/services/wrapped/models.dart";
 import "package:photos/services/wrapped/wrapped_service.dart";
@@ -12,6 +15,7 @@ import "package:photos/theme/colors.dart";
 import "package:photos/theme/ente_theme.dart";
 import "package:photos/theme/text_style.dart";
 import "package:photos/ui/notification/toast.dart";
+import "package:photos/ui/viewer/file/thumbnail_widget.dart";
 import "package:photos/utils/share_util.dart";
 import "package:share_plus/share_plus.dart";
 
@@ -426,77 +430,124 @@ class _StoryCard extends StatelessWidget {
           borderRadius: BorderRadius.circular(24),
           child: Padding(
             padding: const EdgeInsets.fromLTRB(24, 28, 24, 32),
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                _CardHeader(
-                  label: _labelForCardType(card.type),
-                  colorScheme: colorScheme,
-                  textTheme: textTheme,
-                ),
-                const SizedBox(height: 16),
-                Expanded(
-                  child: _StoryCardBody(
-                    card: card,
-                    colorScheme: colorScheme,
-                    textTheme: textTheme,
-                  ),
-                ),
-              ],
+            child: _CardContent(
+              card: card,
+              colorScheme: colorScheme,
+              textTheme: textTheme,
             ),
           ),
         ),
       ),
     );
   }
+}
 
-  String _labelForCardType(WrappedCardType type) {
-    switch (type) {
+class _CardContent extends StatelessWidget {
+  const _CardContent({
+    required this.card,
+    required this.colorScheme,
+    required this.textTheme,
+  });
+
+  final WrappedCard card;
+  final EnteColorScheme colorScheme;
+  final EnteTextTheme textTheme;
+
+  @override
+  Widget build(BuildContext context) {
+    switch (card.type) {
       case WrappedCardType.statsTotals:
-        return "Totals";
+        return _TotalsCardContent(
+          card: card,
+          colorScheme: colorScheme,
+          textTheme: textTheme,
+        );
       case WrappedCardType.statsVelocity:
-        return "Rhythm";
+        return _RhythmCardContent(
+          card: card,
+          colorScheme: colorScheme,
+          textTheme: textTheme,
+        );
       case WrappedCardType.busiestDay:
-        return "Biggest day";
-      case WrappedCardType.longestStreak:
-        return "Streak";
-      case WrappedCardType.longestGap:
-        return "Break";
+        return _BusiestDayCardContent(
+          card: card,
+          colorScheme: colorScheme,
+          textTheme: textTheme,
+        );
+      case WrappedCardType.statsHeatmap:
+        return _HeatmapCardContent(
+          card: card,
+          colorScheme: colorScheme,
+          textTheme: textTheme,
+        );
       default:
-        return "Stats";
+        return _GenericCardContent(
+          card: card,
+          textTheme: textTheme,
+        );
     }
   }
 }
 
-class _CardHeader extends StatelessWidget {
-  const _CardHeader({
-    required this.label,
+class _TotalsCardContent extends StatelessWidget {
+  const _TotalsCardContent({
+    required this.card,
     required this.colorScheme,
     required this.textTheme,
   });
 
-  final String label;
+  final WrappedCard card;
   final EnteColorScheme colorScheme;
   final EnteTextTheme textTheme;
 
   @override
   Widget build(BuildContext context) {
-    return Container(
-      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
-      decoration: BoxDecoration(
-        color: colorScheme.fillFaint,
-        borderRadius: BorderRadius.circular(12),
-      ),
-      child: Text(
-        label,
-        style: textTheme.tinyMuted,
-      ),
+    final List<String> chips = _stringListFromMeta(card.meta, "detailChips");
+    final String? firstCaptureLine = card.meta["firstCaptureLine"] as String?;
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        _HeroMediaCollage(
+          media: card.media,
+          colorScheme: colorScheme,
+        ),
+        const SizedBox(height: 24),
+        Text(
+          card.title,
+          style: textTheme.h2Bold,
+        ),
+        if (card.subtitle != null && card.subtitle!.isNotEmpty)
+          Padding(
+            padding: const EdgeInsets.only(top: 12),
+            child: Text(
+              card.subtitle!,
+              style: textTheme.bodyMuted,
+            ),
+          ),
+        if (chips.isNotEmpty) ...[
+          const SizedBox(height: 20),
+          _DetailChips(
+            chips: chips,
+            colorScheme: colorScheme,
+            textTheme: textTheme,
+          ),
+        ],
+        if (firstCaptureLine != null) ...[
+          const SizedBox(height: 16),
+          Text(
+            firstCaptureLine,
+            style: textTheme.smallMuted,
+          ),
+        ],
+        const Spacer(),
+      ],
     );
   }
 }
 
-class _StoryCardBody extends StatelessWidget {
-  const _StoryCardBody({
+class _RhythmCardContent extends StatelessWidget {
+  const _RhythmCardContent({
     required this.card,
     required this.colorScheme,
     required this.textTheme,
@@ -508,6 +559,8 @@ class _StoryCardBody extends StatelessWidget {
 
   @override
   Widget build(BuildContext context) {
+    final List<String> chips = _stringListFromMeta(card.meta, "detailChips");
+
     return Column(
       crossAxisAlignment: CrossAxisAlignment.start,
       children: [
@@ -523,19 +576,78 @@ class _StoryCardBody extends StatelessWidget {
               style: textTheme.bodyMuted,
             ),
           ),
-        const SizedBox(height: 24),
-        _StoryMediaStrip(
-          card: card,
+        if (chips.isNotEmpty) ...[
+          const SizedBox(height: 18),
+          _DetailChips(
+            chips: chips,
+            colorScheme: colorScheme,
+            textTheme: textTheme,
+          ),
+        ],
+        if (card.media.isNotEmpty) ...[
+          const SizedBox(height: 22),
+          _MediaRow(
+            media: card.media.take(3).toList(growable: false),
+            colorScheme: colorScheme,
+          ),
+        ],
+        const Spacer(),
+      ],
+    );
+  }
+}
+
+class _BusiestDayCardContent extends StatelessWidget {
+  const _BusiestDayCardContent({
+    required this.card,
+    required this.colorScheme,
+    required this.textTheme,
+  });
+
+  final WrappedCard card;
+  final EnteColorScheme colorScheme;
+  final EnteTextTheme textTheme;
+
+  @override
+  Widget build(BuildContext context) {
+    final List<String> chips = _stringListFromMeta(card.meta, "detailChips");
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          card.title,
+          style: textTheme.h2Bold,
+        ),
+        if (card.subtitle != null && card.subtitle!.isNotEmpty)
+          Padding(
+            padding: const EdgeInsets.only(top: 12),
+            child: Text(
+              card.subtitle!,
+              style: textTheme.bodyMuted,
+            ),
+          ),
+        if (chips.isNotEmpty) ...[
+          const SizedBox(height: 18),
+          _DetailChips(
+            chips: chips,
+            colorScheme: colorScheme,
+            textTheme: textTheme,
+          ),
+        ],
+        const SizedBox(height: 22),
+        _MediaGrid(
+          media: card.media.take(6).toList(growable: false),
           colorScheme: colorScheme,
-          textTheme: textTheme,
         ),
+        const Spacer(),
       ],
     );
   }
 }
 
-class _StoryMediaStrip extends StatelessWidget {
-  const _StoryMediaStrip({
+class _HeatmapCardContent extends StatelessWidget {
+  const _HeatmapCardContent({
     required this.card,
     required this.colorScheme,
     required this.textTheme,
@@ -547,32 +659,698 @@ class _StoryMediaStrip extends StatelessWidget {
 
   @override
   Widget build(BuildContext context) {
-    if (card.media.isEmpty) {
+    final List<String> chips = _stringListFromMeta(card.meta, "detailChips");
+    final List<dynamic> rawQuarters =
+        card.meta["quarters"] as List<dynamic>? ?? const <dynamic>[];
+    final List<_QuarterBlock> quarters = rawQuarters
+        .map(
+          (dynamic entry) => _QuarterBlock.fromJson(
+            (entry as Map).cast<String, Object?>(),
+          ),
+        )
+        .where((_QuarterBlock block) => block.grid.isNotEmpty)
+        .toList(growable: false);
+    final List<String> weekdayLabels =
+        (card.meta["weekdayLabels"] as List<dynamic>? ?? const <dynamic>[])
+            .whereType<String>()
+            .toList(growable: false);
+    final int maxCount = (card.meta["maxCount"] as num?)?.toInt() ?? 0;
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          card.title,
+          style: textTheme.h2Bold,
+        ),
+        if (card.subtitle != null && card.subtitle!.isNotEmpty)
+          Padding(
+            padding: const EdgeInsets.only(top: 12),
+            child: Text(
+              card.subtitle!,
+              style: textTheme.bodyMuted,
+            ),
+          ),
+        const SizedBox(height: 18),
+        if (quarters.isEmpty)
+          _MediaPlaceholder(
+            height: 180,
+            colorScheme: colorScheme,
+          )
+        else
+          LayoutBuilder(
+            builder: (BuildContext context, BoxConstraints constraints) {
+              final double maxWidth = constraints.maxWidth;
+              final int columns =
+                  quarters.length <= 1 ? 1 : (maxWidth >= 280 ? 2 : 1);
+              final double spacing = columns > 1 ? 18 : 0;
+              final double itemWidth = columns > 1
+                  ? (maxWidth - ((columns - 1) * spacing)) / columns
+                  : maxWidth;
+              final int maxColumnCount = quarters
+                  .map(
+                    (_QuarterBlock block) =>
+                        block.grid.isNotEmpty ? block.grid.first.length : 0,
+                  )
+                  .fold(0, math.max);
+              const double labelColumnWidth = 20;
+              const double cellSpacing = 1.5;
+              const double fallbackCellSize = 6;
+              const double maxCellWidth = 18;
+              const double maxCellHeight = 12;
+
+              double computeCellWidth(double availableWidth) {
+                if (maxColumnCount <= 0) {
+                  return fallbackCellSize;
+                }
+                final double usable = math.max(
+                  0,
+                  availableWidth -
+                      cellSpacing * math.max(0, maxColumnCount - 1),
+                );
+                final double raw = usable / math.max(1, maxColumnCount);
+                return raw.clamp(fallbackCellSize, maxCellWidth);
+              }
+
+              final double cellWidthWithLabels =
+                  computeCellWidth(itemWidth - labelColumnWidth);
+              final double cellWidthWithoutLabels = computeCellWidth(itemWidth);
+              final double cellWidth =
+                  math.min(cellWidthWithLabels, cellWidthWithoutLabels);
+              final double cellHeight = math.min(
+                maxCellHeight,
+                cellWidth.clamp(fallbackCellSize, maxCellHeight),
+              );
+              return Wrap(
+                spacing: spacing,
+                runSpacing: 18,
+                children: <Widget>[
+                  for (final (int index, _QuarterBlock block)
+                      in quarters.indexed)
+                    SizedBox(
+                      width: itemWidth,
+                      child: _QuarterHeatmap(
+                        block: block,
+                        weekdayLabels: weekdayLabels,
+                        maxCount: maxCount,
+                        colorScheme: colorScheme,
+                        textTheme: textTheme,
+                        showDayLabels: columns == 1 || index % columns == 0,
+                        maxColumns: maxColumnCount,
+                        cellWidth: cellWidth,
+                        cellHeight: cellHeight,
+                        cellSpacing: cellSpacing,
+                        labelColumnWidth: labelColumnWidth,
+                      ),
+                    ),
+                ],
+              );
+            },
+          ),
+        if (chips.isNotEmpty) ...[
+          const SizedBox(height: 20),
+          _DetailChips(
+            chips: chips,
+            colorScheme: colorScheme,
+            textTheme: textTheme,
+          ),
+        ],
+        const Spacer(),
+      ],
+    );
+  }
+}
+
+class _GenericCardContent extends StatelessWidget {
+  const _GenericCardContent({
+    required this.card,
+    required this.textTheme,
+  });
+
+  final WrappedCard card;
+  final EnteTextTheme textTheme;
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          card.title,
+          style: textTheme.h2Bold,
+        ),
+        if (card.subtitle != null && card.subtitle!.isNotEmpty)
+          Padding(
+            padding: const EdgeInsets.only(top: 12),
+            child: Text(
+              card.subtitle!,
+              style: textTheme.bodyMuted,
+            ),
+          ),
+        const Spacer(),
+      ],
+    );
+  }
+}
+
+class _QuarterBlock {
+  _QuarterBlock({
+    required this.label,
+    required this.grid,
+    required this.columnLabels,
+  });
+
+  final String label;
+  final List<List<int>> grid;
+  final List<String> columnLabels;
+
+  static _QuarterBlock fromJson(Map<String, Object?> json) {
+    final List<List<int>> grid =
+        (json["grid"] as List<dynamic>? ?? const <dynamic>[])
+            .map(
+              (dynamic row) => (row as List<dynamic>)
+                  .map((dynamic value) => (value as num).toInt())
+                  .toList(growable: false),
+            )
+            .toList(growable: false);
+    final List<String> columnLabels =
+        (json["columnLabels"] as List<dynamic>? ?? const <dynamic>[])
+            .whereType<String>()
+            .toList(growable: false);
+    return _QuarterBlock(
+      label: json["label"] as String? ?? "",
+      grid: grid,
+      columnLabels: columnLabels,
+    );
+  }
+}
+
+class _QuarterHeatmap extends StatelessWidget {
+  const _QuarterHeatmap({
+    required this.block,
+    required this.weekdayLabels,
+    required this.maxCount,
+    required this.colorScheme,
+    required this.textTheme,
+    required this.showDayLabels,
+    required this.maxColumns,
+    required this.cellWidth,
+    required this.cellHeight,
+    required this.cellSpacing,
+    required this.labelColumnWidth,
+  });
+
+  final _QuarterBlock block;
+  final List<String> weekdayLabels;
+  final int maxCount;
+  final EnteColorScheme colorScheme;
+  final EnteTextTheme textTheme;
+  final bool showDayLabels;
+  final int maxColumns;
+  final double cellWidth;
+  final double cellHeight;
+  final double cellSpacing;
+  final double labelColumnWidth;
+
+  @override
+  Widget build(BuildContext context) {
+    final int columnCount = block.grid.isEmpty ? 0 : block.grid.first.length;
+    if (columnCount == 0 || maxColumns <= 0) {
+      return _MediaPlaceholder(
+        height: 120,
+        colorScheme: colorScheme,
+      );
+    }
+
+    final TextStyle axisStyle =
+        textTheme.tinyMuted.copyWith(fontSize: 8.5, height: 1.15);
+    final List<String> headerLabels = List<String>.generate(
+      maxColumns,
+      (int index) =>
+          index < block.columnLabels.length ? block.columnLabels[index] : "",
+    );
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          block.label,
+          style: textTheme.smallBold,
+        ),
+        const SizedBox(height: 6),
+        Row(
+          children: [
+            if (showDayLabels) SizedBox(width: labelColumnWidth),
+            for (int columnIndex = 0;
+                columnIndex < headerLabels.length;
+                columnIndex += 1) ...[
+              SizedBox(
+                width: cellWidth,
+                child: Text(
+                  headerLabels[columnIndex],
+                  style: axisStyle,
+                  textAlign: TextAlign.center,
+                  softWrap: false,
+                  overflow: TextOverflow.fade,
+                ),
+              ),
+              SizedBox(
+                width: columnIndex == headerLabels.length - 1 ? 0 : cellSpacing,
+              ),
+            ],
+          ],
+        ),
+        const SizedBox(height: 4),
+        Column(
+          children: List<Widget>.generate(weekdayLabels.length, (int dayIndex) {
+            final List<int> row = block.grid.length > dayIndex
+                ? block.grid[dayIndex]
+                : const <int>[];
+            final String dayLabel =
+                dayIndex < weekdayLabels.length ? weekdayLabels[dayIndex] : "";
+            return Padding(
+              padding: EdgeInsets.only(
+                bottom: dayIndex == weekdayLabels.length - 1 ? 0 : cellSpacing,
+              ),
+              child: Row(
+                children: [
+                  if (showDayLabels)
+                    SizedBox(
+                      width: labelColumnWidth,
+                      child: Text(
+                        dayLabel,
+                        style: axisStyle,
+                      ),
+                    ),
+                  for (int columnIndex = 0;
+                      columnIndex < maxColumns;
+                      columnIndex += 1) ...[
+                    _HeatmapCell(
+                      value: columnIndex < row.length ? row[columnIndex] : -1,
+                      width: cellWidth,
+                      height: cellHeight,
+                      colorScheme: colorScheme,
+                      maxCount: maxCount,
+                    ),
+                    SizedBox(
+                      width: columnIndex == maxColumns - 1 ? 0 : cellSpacing,
+                    ),
+                  ],
+                ],
+              ),
+            );
+          }),
+        ),
+      ],
+    );
+  }
+}
+
+class _HeatmapCell extends StatelessWidget {
+  const _HeatmapCell({
+    required this.value,
+    required this.width,
+    required this.height,
+    required this.colorScheme,
+    required this.maxCount,
+  });
+
+  final int value;
+  final double width;
+  final double height;
+  final EnteColorScheme colorScheme;
+  final int maxCount;
+
+  @override
+  Widget build(BuildContext context) {
+    if (value < 0) {
+      return SizedBox(width: width, height: height);
+    }
+    return Container(
+      width: width,
+      height: height,
+      decoration: BoxDecoration(
+        color: _heatmapColorForValue(value, maxCount, colorScheme),
+        borderRadius: BorderRadius.circular(3),
+      ),
+    );
+  }
+}
+
+class _DetailChips extends StatelessWidget {
+  const _DetailChips({
+    required this.chips,
+    required this.colorScheme,
+    required this.textTheme,
+  });
+
+  final List<String> chips;
+  final EnteColorScheme colorScheme;
+  final EnteTextTheme textTheme;
+
+  @override
+  Widget build(BuildContext context) {
+    if (chips.isEmpty) {
       return const SizedBox.shrink();
     }
     return Wrap(
-      spacing: 12,
-      runSpacing: 12,
-      children: card.media.take(6).map((MediaRef ref) {
-        return Container(
-          width: 64,
-          height: 64,
-          alignment: Alignment.center,
-          decoration: BoxDecoration(
-            color: colorScheme.primary400.withValues(alpha: 0.16),
-            borderRadius: BorderRadius.circular(14),
-          ),
-          child: Text(
-            "#${ref.uploadedFileID}",
-            style: textTheme.tinyMuted,
-            textAlign: TextAlign.center,
+      spacing: 10,
+      runSpacing: 8,
+      children: chips
+          .map(
+            (String chip) => Container(
+              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+              decoration: BoxDecoration(
+                color: colorScheme.fillFaint,
+                borderRadius: BorderRadius.circular(14),
+              ),
+              child: Text(
+                chip,
+                style: textTheme.smallMuted,
+              ),
+            ),
+          )
+          .toList(growable: false),
+    );
+  }
+}
+
+class _HeroMediaCollage extends StatelessWidget {
+  const _HeroMediaCollage({
+    required this.media,
+    required this.colorScheme,
+  });
+
+  final List<MediaRef> media;
+  final EnteColorScheme colorScheme;
+
+  @override
+  Widget build(BuildContext context) {
+    if (media.isEmpty) {
+      return _MediaPlaceholder(
+        height: 220,
+        colorScheme: colorScheme,
+        borderRadius: 24,
+      );
+    }
+
+    final List<MediaRef> trimmed = media.take(3).toList(growable: false);
+    final MediaRef primary = trimmed.first;
+    final List<MediaRef> side = trimmed.skip(1).toList(growable: false);
+
+    return SizedBox(
+      height: 220,
+      child: Row(
+        children: [
+          Expanded(
+            flex: 2,
+            child: _MediaTile(
+              mediaRef: primary,
+              borderRadius: 24,
+              aspectRatio: 3 / 4,
+            ),
           ),
+          if (side.isNotEmpty) ...[
+            const SizedBox(width: 12),
+            Expanded(
+              child: Column(
+                children: List<Widget>.generate(
+                  2,
+                  (int index) {
+                    final MediaRef? ref =
+                        index < side.length ? side[index] : null;
+                    return Expanded(
+                      child: Padding(
+                        padding: EdgeInsets.only(
+                          bottom: index == 0 ? 12 : 0,
+                        ),
+                        child: ref != null
+                            ? _MediaTile(
+                                mediaRef: ref,
+                                borderRadius: 20,
+                              )
+                            : _MediaPlaceholder(
+                                colorScheme: colorScheme,
+                                borderRadius: 20,
+                              ),
+                      ),
+                    );
+                  },
+                ),
+              ),
+            ),
+          ],
+        ],
+      ),
+    );
+  }
+}
+
+class _MediaRow extends StatelessWidget {
+  const _MediaRow({
+    required this.media,
+    required this.colorScheme,
+  });
+
+  final List<MediaRef> media;
+  final EnteColorScheme colorScheme;
+
+  @override
+  Widget build(BuildContext context) {
+    return SizedBox(
+      height: 96,
+      child: Row(
+        children: [
+          for (final (int index, MediaRef ref) in media.indexed) ...[
+            Expanded(
+              child: Padding(
+                padding:
+                    EdgeInsets.only(right: index == media.length - 1 ? 0 : 12),
+                child: _MediaTile(
+                  mediaRef: ref,
+                  borderRadius: 18,
+                ),
+              ),
+            ),
+          ],
+          if (media.isEmpty)
+            Expanded(
+              child: _MediaPlaceholder(
+                colorScheme: colorScheme,
+                borderRadius: 18,
+              ),
+            ),
+        ],
+      ),
+    );
+  }
+}
+
+class _MediaGrid extends StatelessWidget {
+  const _MediaGrid({
+    required this.media,
+    required this.colorScheme,
+  });
+
+  final List<MediaRef> media;
+  final EnteColorScheme colorScheme;
+
+  @override
+  Widget build(BuildContext context) {
+    if (media.isEmpty) {
+      return _MediaPlaceholder(
+        height: 200,
+        colorScheme: colorScheme,
+      );
+    }
+    return AspectRatio(
+      aspectRatio: 2 / 3,
+      child: Column(
+        children: List<Widget>.generate(3, (int row) {
+          return Expanded(
+            child: Row(
+              children: List<Widget>.generate(2, (int column) {
+                final int index = row * 2 + column;
+                final MediaRef? ref =
+                    index < media.length ? media[index] : null;
+                return Expanded(
+                  child: Padding(
+                    padding: EdgeInsets.only(
+                      right: column == 1 ? 0 : 10,
+                      bottom: row == 2 ? 0 : 10,
+                    ),
+                    child: ref != null
+                        ? _MediaTile(
+                            mediaRef: ref,
+                            borderRadius: 16,
+                          )
+                        : _MediaPlaceholder(
+                            colorScheme: colorScheme,
+                            borderRadius: 16,
+                          ),
+                  ),
+                );
+              }),
+            ),
+          );
+        }),
+      ),
+    );
+  }
+}
+
+class _MediaTile extends StatelessWidget {
+  const _MediaTile({
+    required this.mediaRef,
+    required this.borderRadius,
+    this.aspectRatio,
+  });
+
+  final MediaRef mediaRef;
+  final double borderRadius;
+  final double? aspectRatio;
+
+  @override
+  Widget build(BuildContext context) {
+    Widget content = ClipRRect(
+      borderRadius: BorderRadius.circular(borderRadius),
+      child: SizedBox.expand(
+        child: _MediaThumb(
+          ref: mediaRef,
+        ),
+      ),
+    );
+    if (aspectRatio != null) {
+      content = AspectRatio(
+        aspectRatio: aspectRatio!,
+        child: content,
+      );
+    }
+    return content;
+  }
+}
+
+class _MediaPlaceholder extends StatelessWidget {
+  const _MediaPlaceholder({
+    required this.colorScheme,
+    this.height,
+    this.borderRadius = 20,
+  });
+
+  final EnteColorScheme colorScheme;
+  final double? height;
+  final double borderRadius;
+
+  @override
+  Widget build(BuildContext context) {
+    final Widget child = Container(
+      decoration: BoxDecoration(
+        color: colorScheme.primary400.withValues(alpha: 0.12),
+        borderRadius: BorderRadius.circular(borderRadius),
+      ),
+    );
+    if (height != null) {
+      return SizedBox(
+        height: height,
+        child: child,
+      );
+    }
+    return child;
+  }
+}
+
+class _MediaThumb extends StatefulWidget {
+  const _MediaThumb({required this.ref});
+
+  final MediaRef ref;
+
+  @override
+  State<_MediaThumb> createState() => _MediaThumbState();
+}
+
+class _MediaThumbState extends State<_MediaThumb> {
+  late Future<EnteFile?> _fileFuture;
+
+  @override
+  void initState() {
+    super.initState();
+    _fileFuture = FilesDB.instance.getAnyUploadedFile(
+      widget.ref.uploadedFileID,
+    );
+  }
+
+  @override
+  void didUpdateWidget(covariant _MediaThumb oldWidget) {
+    super.didUpdateWidget(oldWidget);
+    if (oldWidget.ref.uploadedFileID != widget.ref.uploadedFileID) {
+      _fileFuture = FilesDB.instance.getAnyUploadedFile(
+        widget.ref.uploadedFileID,
+      );
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final colorScheme = getEnteColorScheme(context);
+    return FutureBuilder<EnteFile?>(
+      future: _fileFuture,
+      builder: (BuildContext context, AsyncSnapshot<EnteFile?> snapshot) {
+        if (snapshot.connectionState != ConnectionState.done) {
+          return Container(
+            color: colorScheme.fillFaint,
+          );
+        }
+        final EnteFile? file = snapshot.data;
+        if (file == null) {
+          return Container(
+            color: colorScheme.fillFaint,
+          );
+        }
+        return ThumbnailWidget(
+          file,
+          fit: BoxFit.cover,
+          rawThumbnail: true,
+          shouldShowSyncStatus: false,
+          shouldShowArchiveStatus: false,
+          shouldShowPinIcon: false,
+          shouldShowOwnerAvatar: false,
+          shouldShowFavoriteIcon: false,
+          shouldShowVideoDuration: false,
+          shouldShowVideoOverlayIcon: false,
         );
-      }).toList(),
+      },
     );
   }
 }
 
+Color _heatmapColorForValue(
+  int value,
+  int maxValue,
+  EnteColorScheme scheme,
+) {
+  if (value <= 0 || maxValue <= 0) {
+    return scheme.fillFaint;
+  }
+  final double t = (value / maxValue).clamp(0.0, 1.0);
+  return Color.lerp(
+        scheme.primary400.withValues(alpha: 0.25),
+        scheme.primary500,
+        t,
+      ) ??
+      scheme.primary500;
+}
+
+List<String> _stringListFromMeta(
+  Map<String, Object?> meta,
+  String key,
+) {
+  final Object? raw = meta[key];
+  if (raw is List) {
+    return raw.whereType<String>().toList(growable: false);
+  }
+  return const <String>[];
+}
+
 class _StoryProgressBar extends StatelessWidget {
   const _StoryProgressBar({
     required this.progressValues,
