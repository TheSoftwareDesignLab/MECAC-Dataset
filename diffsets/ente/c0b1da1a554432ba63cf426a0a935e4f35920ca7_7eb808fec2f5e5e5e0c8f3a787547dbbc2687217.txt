diff --git a/web/apps/photos/src/components/TripLayout/TripMap.tsx b/web/apps/photos/src/components/TripLayout/TripMap.tsx
index 085c876d555..fb3399f870f 100644
--- a/web/apps/photos/src/components/TripLayout/TripMap.tsx
+++ b/web/apps/photos/src/components/TripLayout/TripMap.tsx
@@ -60,13 +60,30 @@ export const TripMap: React.FC<TripMapProps> = ({
 }) => {
     const isTouchDevice = useIsTouchscreen();
 
-    // Calculate super-clusters based on screen collisions
+    // Calculate current active location index based on scroll progress (same logic as in scrollUtils)
+    let currentActiveLocationIndex = -1;
+    if (photoClusters.length > 0) {
+        if (isTouchDevice) {
+            // Mobile: Slower progression - stay on each location longer
+            currentActiveLocationIndex = Math.floor(
+                scrollProgress * (photoClusters.length - 0.5),
+            );
+        } else {
+            // Desktop: Use original logic
+            currentActiveLocationIndex = Math.round(
+                scrollProgress * Math.max(0, photoClusters.length - 1),
+            );
+        }
+    }
+
+    // Calculate super-clusters based on screen collisions, excluding the active cluster
     const { superClusters, visibleClusters } = detectScreenCollisions(
         photoClusters,
         currentZoom,
         targetZoom,
         mapRef,
         optimalZoom,
+        currentActiveLocationIndex >= 0 ? currentActiveLocationIndex : undefined,
     );
 
     return (
diff --git a/web/apps/photos/src/components/TripLayout/index.tsx b/web/apps/photos/src/components/TripLayout/index.tsx
index 5df360c4743..4676f43671f 100644
--- a/web/apps/photos/src/components/TripLayout/index.tsx
+++ b/web/apps/photos/src/components/TripLayout/index.tsx
@@ -183,6 +183,7 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
                             null,
                             null,
                             optimalZoomLevel,
+                            undefined, // No active cluster during initial calculation
                         );
 
                         // Create a map of cluster index to super cluster index
diff --git a/web/apps/photos/src/components/TripLayout/mapHelpers.ts b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
index 7839efd3b22..dc5edf3ad3e 100644
--- a/web/apps/photos/src/components/TripLayout/mapHelpers.ts
+++ b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
@@ -346,6 +346,7 @@ export const detectScreenCollisions = (
     targetZoom: number | null,
     mapRef: import("leaflet").Map | null,
     optimalZoom: number,
+    activeClusterIndex?: number, // Currently active cluster should not be grouped into super clusters
 ) => {
     // Use target zoom if we're in the middle of a zoom animation, otherwise use optimal zoom
     const effectiveZoom =
@@ -399,7 +400,11 @@ export const detectScreenCollisions = (
         });
 
         // If we found overlapping clusters, create a super-cluster
-        if (overlappingClusters.length > 1) {
+        // But only if none of the involved clusters is the currently active cluster
+        const involvesActiveCluster = activeClusterIndex !== undefined &&
+            overlappingClusters.includes(activeClusterIndex);
+
+        if (overlappingClusters.length > 1 && !involvesActiveCluster) {
             hiddenClusterIndices.add(i); // Hide the original cluster too
 
             // Calculate center position of all overlapping clusters
@@ -430,6 +435,12 @@ export const detectScreenCollisions = (
                 clustersInvolved: overlappingClusters,
                 image: representativePhoto.image,
             });
+        } else if (involvesActiveCluster) {
+            // If active cluster is involved, unhide all overlapping clusters
+            // so they remain visible as individual clusters
+            overlappingClusters.forEach((idx) => {
+                hiddenClusterIndices.delete(idx);
+            });
         }
     });
 
@@ -464,17 +475,20 @@ export const getMapCenter = (
 
     // Position first location at 20% from right edge (80% from left)
     // At zoom level 10, each pixel represents approximately 152.87 meters
-    // Timeline takes up 50% of screen width, so visible map area is 50%
+    // On mobile, timeline is at bottom so full width is available; on desktop, timeline takes up 50% of screen width
     // We want the first location to be at 20% from right of the visible map area
     // This means shifting map center left so marker appears more to the right
 
-    const timelineWidthRatio = 0.5; // Timeline takes up 50% of screen
+    const isMobile = typeof window !== "undefined" && window.innerWidth <= 768;
+    const timelineWidthRatio = isMobile ? 0.0 : 0.5; // Mobile: full width, Desktop: timeline takes up 50% of screen
 
     // At zoom 10, approximately 0.35 degrees per 1000px at equator
     // For positioning, we need to shift the longitude to place marker at desired position
     const degreesPerPixelAtZoom10 = 0.35 / 1000; // rough approximation
-    const pixelsToShiftFor20Percent =
-        (window.innerWidth || 1400) * timelineWidthRatio * 3.0; // 300% of visible map width to shift map left
+    const basePixelsToShift = (window.innerWidth || 1400) * (1 - timelineWidthRatio);
+    const pixelsToShiftFor20Percent = isMobile
+        ? basePixelsToShift * 0.6 // Mobile: less aggressive positioning (60% instead of 300%)
+        : basePixelsToShift * 3.0; // Desktop: 300% of visible map width to shift map left
     const lngShift = pixelsToShiftFor20Percent * degreesPerPixelAtZoom10;
 
     const adjustedLng = firstLng - lngShift;
@@ -488,12 +502,18 @@ export const getLocationPosition = (
     lng: number,
 ): [number, number] => {
     // Position location at 20% from right edge (80% from left) of visible map area
-    const timelineWidthRatio = 0.5; // Timeline takes up 50% of screen
+    // On mobile, the timeline is at the bottom, not the side, so full width is available for map
+    const isMobile = typeof window !== "undefined" && window.innerWidth <= 768;
+    const timelineWidthRatio = isMobile ? 0.0 : 0.5; // Mobile: full width, Desktop: timeline takes up 50% of screen
     const degreesPerPixelAtZoom10 = 0.35 / 1000; // rough approximation at zoom 10
+
     // Calculate shift to position marker at 20% from right edge of visible map
     // Need to shift map center left so the marker appears more to the right
-    const pixelsToShiftFor20Percent =
-        (window.innerWidth || 1400) * timelineWidthRatio * 3.0; // 300% of visible map width to shift map left
+    // On mobile, use less aggressive positioning since we have full width
+    const basePixelsToShift = (window.innerWidth || 1400) * (1 - timelineWidthRatio);
+    const pixelsToShiftFor20Percent = isMobile
+        ? basePixelsToShift * 0.6 // Mobile: less aggressive positioning (60% instead of 300%)
+        : basePixelsToShift * 3.0; // Desktop: 300% of visible map width to shift map left
     const lngShift = pixelsToShiftFor20Percent * degreesPerPixelAtZoom10;
 
     return [lat, lng - lngShift];
@@ -506,7 +526,9 @@ export const getLocationPositionAtZoom = (
     zoom: number,
 ): [number, number] => {
     // Position location at 20% from right edge (80% from left) of visible map area
-    const timelineWidthRatio = 0.5; // Timeline takes up 50% of screen
+    // On mobile, the timeline is at the bottom, not the side, so full width is available for map
+    const isMobile = typeof window !== "undefined" && window.innerWidth <= 768;
+    const timelineWidthRatio = isMobile ? 0.0 : 0.5; // Mobile: full width, Desktop: timeline takes up 50% of screen
 
     // Scale the positioning offset based on zoom level
     // At higher zoom levels, we need less offset since we're more zoomed in
@@ -515,8 +537,11 @@ export const getLocationPositionAtZoom = (
     const degreesPerPixelAtCurrentZoom = baseDegreesPerPixelAtZoom10 * zoomScaleFactor;
 
     // Calculate shift to position marker at 20% from right edge of visible map
-    const pixelsToShiftFor20Percent =
-        (window.innerWidth || 1400) * timelineWidthRatio * 3.0; // 300% of visible map width to shift map left
+    // On mobile, use less aggressive positioning since we have full width
+    const basePixelsToShift = (window.innerWidth || 1400) * (1 - timelineWidthRatio);
+    const pixelsToShiftFor20Percent = isMobile
+        ? basePixelsToShift * 0.6 // Mobile: less aggressive positioning (60% instead of 300%)
+        : basePixelsToShift * 3.0; // Desktop: 300% of visible map width to shift map left
     const lngShift = pixelsToShiftFor20Percent * degreesPerPixelAtCurrentZoom;
 
     return [lat, lng - lngShift];
diff --git a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
index 9e3d5f1d3b9..b5a58525b3d 100644
--- a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
+++ b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
@@ -188,7 +188,7 @@ export const handleTimelineScroll = ({
             // Handle super cluster zoom logic - check distant locations first!
             if (isInSuperCluster && !wasInSuperCluster && isDistantLocation) {
                 // Entering super cluster from distant location - full zoom out → pan → zoom in
-                const superClusterZoom = isTouchDevice ? 12 : 14;
+                const superClusterZoom = isTouchDevice ? 15 : 14; // Higher zoom on mobile to break apart clusters
                 const intermediateZoom = isTouchDevice ? 2 : 4; // Extreme zoom out for distant locations
                 const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
                     targetCluster.lat,
@@ -214,7 +214,7 @@ export const handleTimelineScroll = ({
                 }, 1600);
             } else if (isInSuperCluster && !wasInSuperCluster) {
                 // Entering super cluster from nearby location - direct zoom in
-                const superClusterZoom = isTouchDevice ? 12 : 14;
+                const superClusterZoom = isTouchDevice ? 15 : 14; // Higher zoom on mobile to break apart clusters
                 const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
                     targetCluster.lat,
                     targetCluster.lng,
@@ -276,7 +276,7 @@ export const handleTimelineScroll = ({
                 if (isDistantLocation) {
                     // Distant location from super cluster: full zoom out → pan → zoom in
                     // Since we're in the isInSuperCluster block, destination is always a super cluster
-                    const finalZoom = isTouchDevice ? 12 : 14;
+                    const finalZoom = isTouchDevice ? 15 : 14; // Higher zoom on mobile to break apart clusters
                     const intermediateZoom = isTouchDevice ? 2 : 4; // Extreme zoom out for distant locations
                     const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
                         targetCluster.lat,
@@ -302,7 +302,7 @@ export const handleTimelineScroll = ({
                     }, 1600);
                 } else if (isDifferentSuperCluster) {
                     // Different super cluster (not distant): moderate zoom out → pan → zoom in
-                    const superClusterZoom = isTouchDevice ? 12 : 14;
+                    const superClusterZoom = isTouchDevice ? 15 : 14; // Higher zoom on mobile to break apart clusters
                     const intermediateZoom = isTouchDevice ? 8 : 10; // Moderate zoom out for nearby super clusters
                     const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
                         targetCluster.lat,
