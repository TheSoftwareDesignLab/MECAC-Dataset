diff --git a/web/apps/photos/src/components/TripLayout/hooks/useLocationFetching.ts b/web/apps/photos/src/components/TripLayout/hooks/useLocationFetching.ts
index 12eec94412e..5c3bb189b34 100644
--- a/web/apps/photos/src/components/TripLayout/hooks/useLocationFetching.ts
+++ b/web/apps/photos/src/components/TripLayout/hooks/useLocationFetching.ts
@@ -22,9 +22,20 @@ export const useLocationFetching = ({
     setIsLoadingLocations,
 }: UseLocationFetchingParams) => {
     const processedPhotoIdsRef = useRef<Set<number>>(new Set());
+    const lastFetchedClustersRef = useRef<string>("");
 
     // Fetch location names for clusters
     useEffect(() => {
+        // Create a stable key for current clusters to prevent duplicate fetches
+        const clustersKey = photoClusters
+            .map(cluster => cluster.map(p => p.fileId).join(','))
+            .join('|');
+
+        // Skip if we already fetched for these exact clusters
+        if (clustersKey === lastFetchedClustersRef.current) {
+            return;
+        }
+
         const fetchNames = async () => {
             if (photoClusters.length === 0) return;
 
@@ -33,11 +44,6 @@ export const useLocationFetching = ({
                 photoClusters.flat().map((photo) => photo.fileId),
             );
 
-            // Check if we have new photos that haven't been processed
-            const hasNewPhotos = Array.from(currentPhotoIds).some(
-                (id) => !processedPhotoIdsRef.current.has(id),
-            );
-
             // Check if any photos need location fetching
             const needsFetching = photoClusters.some((cluster) =>
                 cluster.some(
@@ -45,12 +51,13 @@ export const useLocationFetching = ({
                 ),
             );
 
-            if (!hasNewPhotos && !needsFetching) {
+            if (!needsFetching) {
                 setIsLoadingLocations(false);
                 return;
             }
 
             setIsLoadingLocations(true);
+            lastFetchedClustersRef.current = clustersKey;
 
             try {
                 const { updatedPhotos } = await fetchLocationNames({
diff --git a/web/apps/photos/src/components/TripLayout/utils/dataProcessing.ts b/web/apps/photos/src/components/TripLayout/utils/dataProcessing.ts
index c9ab63aeff4..dd4a0d3f2cf 100644
--- a/web/apps/photos/src/components/TripLayout/utils/dataProcessing.ts
+++ b/web/apps/photos/src/components/TripLayout/utils/dataProcessing.ts
@@ -85,8 +85,9 @@ export const fetchLocationNames = async ({
         return { updatedPhotos };
     }
 
-    for (const cluster of photoClusters) {
-        if (cluster.length === 0) continue;
+    // Create all geocoding promises at once for parallel execution
+    const geocodingPromises = photoClusters.map(async (cluster) => {
+        if (cluster.length === 0) return null;
 
         const avgLat =
             cluster.reduce((sum, p) => sum + p.lat, 0) / cluster.length;
@@ -95,21 +96,32 @@ export const fetchLocationNames = async ({
 
         try {
             const locationInfo = await getLocationName(avgLat, avgLng);
-
-            cluster.forEach((photo) => {
-                updatedPhotos.set(photo.fileId, {
-                    name: locationInfo.place,
-                    country: locationInfo.country,
-                });
-                locationDataRef.current.set(photo.fileId, {
-                    name: locationInfo.place,
-                    country: locationInfo.country,
-                });
-            });
+            return { cluster, locationInfo };
         } catch {
-            // Silently ignore processing errors for individual files
+            // Return null on error, will be filtered out
+            return null;
         }
-    }
+    });
+
+    // Execute all geocoding requests in parallel
+    const results = await Promise.all(geocodingPromises);
+
+    // Process results and update maps
+    results.forEach((result) => {
+        if (!result) return; // Skip failed requests
+
+        const { cluster, locationInfo } = result;
+        cluster.forEach((photo) => {
+            updatedPhotos.set(photo.fileId, {
+                name: locationInfo.place,
+                country: locationInfo.country,
+            });
+            locationDataRef.current.set(photo.fileId, {
+                name: locationInfo.place,
+                country: locationInfo.country,
+            });
+        });
+    });
 
     return { updatedPhotos };
 };
