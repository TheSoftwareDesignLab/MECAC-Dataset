diff --git a/lib/services/collections_service.dart b/lib/services/collections_service.dart
index 5ddc8137711..b1bc575d319 100644
--- a/lib/services/collections_service.dart
+++ b/lib/services/collections_service.dart
@@ -30,11 +30,13 @@ import "package:photos/models/collection_items.dart";
 import 'package:photos/models/file.dart';
 import "package:photos/models/metadata/collection_magic.dart";
 import 'package:photos/services/app_lifecycle_service.dart';
+import "package:photos/services/favorites_service.dart";
 import 'package:photos/services/file_magic_service.dart';
 import 'package:photos/services/local_sync_service.dart';
 import 'package:photos/services/remote_sync_service.dart';
 import 'package:photos/utils/crypto_util.dart';
 import 'package:photos/utils/file_download_util.dart';
+import "package:photos/utils/local_settings.dart";
 import 'package:shared_preferences/shared_preferences.dart';
 
 class CollectionsService {
@@ -341,6 +343,57 @@ class CollectionsService {
     return SharedCollections(outgoing, incoming, quickLinks);
   }
 
+  Future<List<Collection>> getCollectionForOnEnteSection() async {
+    final AlbumSortKey sortKey = LocalSettings.instance.albumSortKey();
+    final List<Collection> collections =
+    CollectionsService.instance.getCollectionsForUI();
+    final bool hasFavorites = FavoritesService.instance.hasFavorites();
+    late Map<int, int> collectionIDToNewestPhotoTime;
+    if (sortKey == AlbumSortKey.newestPhoto) {
+      collectionIDToNewestPhotoTime =
+      await CollectionsService.instance.getCollectionIDToNewestFileTime();
+    }
+    collections.sort(
+          (first, second) {
+        if (sortKey == AlbumSortKey.albumName) {
+          return compareAsciiLowerCaseNatural(
+            first.displayName,
+            second.displayName,
+          );
+        } else if (sortKey == AlbumSortKey.newestPhoto) {
+          return (collectionIDToNewestPhotoTime[second.id] ?? -1 * intMaxValue)
+              .compareTo(
+            collectionIDToNewestPhotoTime[first.id] ?? -1 * intMaxValue,
+          );
+        } else {
+          return second.updationTime.compareTo(first.updationTime);
+        }
+      },
+    );
+    final List<Collection> favorites = [];
+    final List<Collection> pinned = [];
+    final List<Collection> rest = [];
+    for (final collection in collections) {
+      if (collection.type == CollectionType.uncategorized ||
+          collection.isSharedFilesCollection() ||
+          collection.isHidden()) {
+        continue;
+      }
+      if (collection.type == CollectionType.favorites) {
+        // Hide fav collection if it's empty
+        if (hasFavorites) {
+          favorites.add(collection);
+        }
+      } else if (collection.isPinned) {
+        pinned.add(collection);
+      } else {
+        rest.add(collection);
+      }
+    }
+
+    return favorites + pinned + rest;
+  }
+
   User getFileOwner(int userID, int? collectionID) {
     if (_cachedUserIdToUser.containsKey(userID)) {
       return _cachedUserIdToUser[userID]!;
diff --git a/lib/ui/collections/collection_list_page.dart b/lib/ui/collections/collection_list_page.dart
index a0686fee0b8..f194dfb3e67 100644
--- a/lib/ui/collections/collection_list_page.dart
+++ b/lib/ui/collections/collection_list_page.dart
@@ -45,9 +45,8 @@ class _CollectionListPageState extends State<CollectionListPage> {
     collections = widget.collections;
     _collectionUpdatesSubscription =
         Bus.instance.on<CollectionUpdatedEvent>().listen((event) async {
-          refreshCollections();
-          });
-
+      refreshCollections();
+    });
   }
 
   @override
@@ -85,18 +84,21 @@ class _CollectionListPageState extends State<CollectionListPage> {
   }
 
   Future<void> refreshCollections() async {
-    if(widget.sectionType == UISectionType.incomingCollections || widget.sectionType == UISectionType.outgoingCollections) {
-      final SharedCollections sharedCollections = CollectionsService.instance
-          .getSharedCollections();
+    if (widget.sectionType == UISectionType.incomingCollections ||
+        widget.sectionType == UISectionType.outgoingCollections) {
+      final SharedCollections sharedCollections =
+          CollectionsService.instance.getSharedCollections();
       if (widget.sectionType == UISectionType.incomingCollections) {
-         collections = sharedCollections.incoming;
+        collections = sharedCollections.incoming;
       } else {
         collections = sharedCollections.outgoing;
       }
+    } else if (widget.sectionType == UISectionType.homeCollections) {
+      collections =
+          await CollectionsService.instance.getCollectionForOnEnteSection();
+    }
+    if (mounted) {
+      setState(() {});
     }
-     // todo: fetch user_collections
-    setState(() {
-
-    });
   }
 }
diff --git a/lib/ui/tabs/user_collections_tab.dart b/lib/ui/tabs/user_collections_tab.dart
index 2ba04175f31..74a87bb628e 100644
--- a/lib/ui/tabs/user_collections_tab.dart
+++ b/lib/ui/tabs/user_collections_tab.dart
@@ -74,7 +74,7 @@ class _UserCollectionsTabState extends State<UserCollectionsTab>
     super.build(context);
     _logger.info("Building, trigger: $_loadReason");
     return FutureBuilder<List<Collection>>(
-      future: _getCollections(),
+      future: CollectionsService.instance.getCollectionForOnEnteSection(),
       builder: (context, snapshot) {
         if (snapshot.hasData) {
           return _getCollectionsGalleryWidget(snapshot.data!);
@@ -87,56 +87,6 @@ class _UserCollectionsTabState extends State<UserCollectionsTab>
     );
   }
 
-  Future<List<Collection>> _getCollections() async {
-    final List<Collection> collections =
-        CollectionsService.instance.getCollectionsForUI();
-    final bool hasFavorites = FavoritesService.instance.hasFavorites();
-    late Map<int, int> collectionIDToNewestPhotoTime;
-    if (sortKey == AlbumSortKey.newestPhoto) {
-      collectionIDToNewestPhotoTime =
-          await CollectionsService.instance.getCollectionIDToNewestFileTime();
-    }
-    collections.sort(
-      (first, second) {
-        if (sortKey == AlbumSortKey.albumName) {
-          return compareAsciiLowerCaseNatural(
-            first.displayName,
-            second.displayName,
-          );
-        } else if (sortKey == AlbumSortKey.newestPhoto) {
-          return (collectionIDToNewestPhotoTime[second.id] ?? -1 * intMaxValue)
-              .compareTo(
-            collectionIDToNewestPhotoTime[first.id] ?? -1 * intMaxValue,
-          );
-        } else {
-          return second.updationTime.compareTo(first.updationTime);
-        }
-      },
-    );
-    final List<Collection> favorites = [];
-    final List<Collection> pinned = [];
-    final List<Collection> rest = [];
-    for (final collection in collections) {
-      if (collection.type == CollectionType.uncategorized ||
-          collection.isSharedFilesCollection() ||
-          collection.isHidden()) {
-        continue;
-      }
-      if (collection.type == CollectionType.favorites) {
-        // Hide fav collection if it's empty
-        if (hasFavorites) {
-          favorites.add(collection);
-        }
-      } else if (collection.isPinned) {
-        pinned.add(collection);
-      } else {
-        rest.add(collection);
-      }
-    }
-
-    return favorites + pinned + rest;
-  }
-
   Widget _getCollectionsGalleryWidget(List<Collection> collections) {
     final TextStyle trashAndHiddenTextStyle =
         Theme.of(context).textTheme.titleMedium!.copyWith(
@@ -294,7 +244,6 @@ class _UserCollectionsTabState extends State<UserCollectionsTab>
               );
               if (selectedValue != null) {
                 sortKey = AlbumSortKey.values[selectedValue];
-                ;
                 await LocalSettings.instance.setAlbumSortKey(sortKey!);
                 setState(() {});
               }
