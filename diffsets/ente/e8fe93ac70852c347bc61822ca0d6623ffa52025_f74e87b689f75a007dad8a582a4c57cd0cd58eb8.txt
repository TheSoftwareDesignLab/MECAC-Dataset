diff --git a/mobile/apps/photos/lib/ui/viewer/actions/file_selection_overlay_bar.dart b/mobile/apps/photos/lib/ui/viewer/actions/file_selection_overlay_bar.dart
index 8b1127c3f87..c2dd5ffe0c9 100644
--- a/mobile/apps/photos/lib/ui/viewer/actions/file_selection_overlay_bar.dart
+++ b/mobile/apps/photos/lib/ui/viewer/actions/file_selection_overlay_bar.dart
@@ -12,6 +12,7 @@ import 'package:photos/models/selected_files.dart';
 import "package:photos/theme/effects.dart";
 import "package:photos/theme/ente_theme.dart";
 import 'package:photos/ui/components/bottom_action_bar/bottom_action_bar_widget.dart';
+import "package:photos/ui/viewer/gallery/state/boundary_reporter_mixin.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_files_inherited_widget.dart";
 import "package:photos/ui/viewer/gallery/state/inherited_search_filter_data.dart";
 import "package:photos/ui/viewer/gallery/state/search_filter_data_provider.dart";
@@ -41,7 +42,8 @@ class FileSelectionOverlayBar extends StatefulWidget {
       _FileSelectionOverlayBarState();
 }
 
-class _FileSelectionOverlayBarState extends State<FileSelectionOverlayBar> {
+class _FileSelectionOverlayBarState extends State<FileSelectionOverlayBar>
+    with BoundaryReporter {
   final ValueNotifier<bool> _hasSelectedFilesNotifier = ValueNotifier(false);
   late GalleryType _galleryType;
   SearchFilterDataProvider? _searchFilterDataProvider;
@@ -52,6 +54,13 @@ class _FileSelectionOverlayBarState extends State<FileSelectionOverlayBar> {
     super.initState();
     _galleryType = widget.galleryType;
     widget.selectedFiles.addListener(_selectedFilesListener);
+
+    // Report boundary when selection changes
+    widget.selectedFiles.addListener(() {
+      if (widget.selectedFiles.files.isNotEmpty) {
+        reportBoundary(BoundaryPosition.bottom);
+      }
+    });
   }
 
   @override
@@ -117,7 +126,7 @@ class _FileSelectionOverlayBarState extends State<FileSelectionOverlayBar> {
     return ValueListenableBuilder(
       valueListenable: _hasSelectedFilesNotifier,
       builder: (context, value, child) {
-        return AnimatedCrossFade(
+        final crossFade = AnimatedCrossFade(
           firstCurve: Curves.easeInOutExpo,
           secondCurve: Curves.easeInOutExpo,
           sizeCurve: Curves.easeInOutExpo,
@@ -158,6 +167,14 @@ class _FileSelectionOverlayBarState extends State<FileSelectionOverlayBar> {
           ),
           secondChild: const SizedBox(width: double.infinity),
         );
+
+        // Only wrap with boundary widget when there are selected files
+        return _hasSelectedFilesNotifier.value
+            ? boundaryWidget(
+                position: BoundaryPosition.bottom,
+                child: crossFade,
+              )
+            : crossFade;
       },
     );
   }
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/collection_page.dart b/mobile/apps/photos/lib/ui/viewer/gallery/collection_page.dart
index ed97a5b9734..0ac1aecf164 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/collection_page.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/collection_page.dart
@@ -21,6 +21,7 @@ import 'package:photos/ui/viewer/gallery/empty_state.dart';
 import 'package:photos/ui/viewer/gallery/gallery.dart';
 import "package:photos/ui/viewer/gallery/gallery_app_bar_widget.dart";
 import "package:photos/ui/viewer/gallery/hierarchical_search_gallery.dart";
+import "package:photos/ui/viewer/gallery/state/gallery_boundaries_provider.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_files_inherited_widget.dart";
 import "package:photos/ui/viewer/gallery/state/inherited_search_filter_data.dart";
 import "package:photos/ui/viewer/gallery/state/search_filter_data_provider.dart";
@@ -115,6 +116,11 @@ class CollectionPage extends StatelessWidget {
           : const SizedBox(height: 212),
     );
 
+    // Create boundary notifiers
+    final topBoundaryNotifier = ValueNotifier<double?>(null);
+    final bottomBoundaryNotifier = ValueNotifier<double?>(null);
+    final scrollControllerNotifier = ValueNotifier<ScrollController?>(null);
+
     return GalleryFilesState(
       child: InheritedSearchFilterDataWrapper(
         searchFilterDataProvider: SearchFilterDataProvider(
@@ -124,54 +130,59 @@ class CollectionPage extends StatelessWidget {
             occurrence: kMostRelevantFilter,
           ),
         ),
-        child: Scaffold(
-          appBar: PreferredSize(
-            preferredSize: const Size.fromHeight(90.0),
-            child: GalleryAppBarWidget(
-              galleryType,
-              c.collection.displayName,
-              _selectedFiles,
-              collection: c.collection,
-              isFromCollectPhotos: isFromCollectPhotos,
+        child: GalleryBoundariesProvider(
+          topBoundaryNotifier: topBoundaryNotifier,
+          bottomBoundaryNotifier: bottomBoundaryNotifier,
+          scrollControllerNotifier: scrollControllerNotifier,
+          child: Scaffold(
+            appBar: PreferredSize(
+              preferredSize: const Size.fromHeight(90.0),
+              child: GalleryAppBarWidget(
+                galleryType,
+                c.collection.displayName,
+                _selectedFiles,
+                collection: c.collection,
+                isFromCollectPhotos: isFromCollectPhotos,
+              ),
             ),
-          ),
-          bottomNavigationBar: isFromCollectPhotos
-              ? CollectPhotosBottomButtons(
-                  c.collection,
-                  selectedFiles: _selectedFiles,
-                )
-              : null,
-          body: SelectionState(
-            selectedFiles: _selectedFiles,
-            child: Stack(
-              alignment: Alignment.bottomCenter,
-              children: [
-                Builder(
-                  builder: (context) {
-                    return ValueListenableBuilder(
-                      valueListenable: InheritedSearchFilterData.of(context)
-                          .searchFilterDataProvider!
-                          .isSearchingNotifier,
-                      builder: (context, value, _) {
-                        return value
-                            ? HierarchicalSearchGallery(
-                                tagPrefix: tagPrefix,
-                                selectedFiles: _selectedFiles,
-                              )
-                            : gallery;
-                      },
-                    );
-                  },
-                ),
-                SmartAlbumsStatusWidget(
-                  collection: c.collection,
-                ),
-                FileSelectionOverlayBar(
-                  galleryType,
-                  _selectedFiles,
-                  collection: c.collection,
-                ),
-              ],
+            bottomNavigationBar: isFromCollectPhotos
+                ? CollectPhotosBottomButtons(
+                    c.collection,
+                    selectedFiles: _selectedFiles,
+                  )
+                : null,
+            body: SelectionState(
+              selectedFiles: _selectedFiles,
+              child: Stack(
+                alignment: Alignment.bottomCenter,
+                children: [
+                  Builder(
+                    builder: (context) {
+                      return ValueListenableBuilder(
+                        valueListenable: InheritedSearchFilterData.of(context)
+                            .searchFilterDataProvider!
+                            .isSearchingNotifier,
+                        builder: (context, value, _) {
+                          return value
+                              ? HierarchicalSearchGallery(
+                                  tagPrefix: tagPrefix,
+                                  selectedFiles: _selectedFiles,
+                                )
+                              : gallery;
+                        },
+                      );
+                    },
+                  ),
+                  SmartAlbumsStatusWidget(
+                    collection: c.collection,
+                  ),
+                  FileSelectionOverlayBar(
+                    galleryType,
+                    _selectedFiles,
+                    collection: c.collection,
+                  ),
+                ],
+              ),
             ),
           ),
         ),
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart b/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
index 8329a99bdc4..7504d4feb4a 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
@@ -27,6 +27,7 @@ import "package:photos/ui/viewer/gallery/component/group/type.dart";
 import "package:photos/ui/viewer/gallery/component/sectioned_sliver_list.dart";
 import 'package:photos/ui/viewer/gallery/empty_state.dart';
 import "package:photos/ui/viewer/gallery/scrollbar/custom_scroll_bar.dart";
+import "package:photos/ui/viewer/gallery/state/gallery_boundaries_provider.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_context_state.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_files_inherited_widget.dart";
 import "package:photos/ui/viewer/gallery/state/inherited_search_filter_data.dart";
@@ -528,6 +529,9 @@ class GalleryState extends State<Gallery> {
 
   @override
   void dispose() {
+    // Clear scroll controller reference
+    GalleryBoundariesProvider.of(context)?.setScrollController(null);
+
     _reloadEventSubscription?.cancel();
     _tabDoubleTapEvent?.cancel();
     for (final subscription in _forceReloadEventSubscriptions) {
@@ -547,6 +551,14 @@ class GalleryState extends State<Gallery> {
   @override
   Widget build(BuildContext context) {
     _logger.info("Building Gallery  ${widget.tagPrefix}");
+
+    // Share scroll controller with boundaries provider after build
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      if (mounted) {
+        GalleryBoundariesProvider.of(context)
+            ?.setScrollController(_scrollController);
+      }
+    });
     final widthAvailable = MediaQuery.sizeOf(context).width;
 
     if (groupHeaderExtent == null) {
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/gallery_app_bar_widget.dart b/mobile/apps/photos/lib/ui/viewer/gallery/gallery_app_bar_widget.dart
index 1afd17ba8a6..fe22a22c4d8 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/gallery_app_bar_widget.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/gallery_app_bar_widget.dart
@@ -54,6 +54,7 @@ import 'package:photos/ui/tools/free_space_page.dart';
 import "package:photos/ui/viewer/file/detail_page.dart";
 import "package:photos/ui/viewer/gallery/hooks/add_photos_sheet.dart";
 import 'package:photos/ui/viewer/gallery/hooks/pick_cover_photo.dart';
+import "package:photos/ui/viewer/gallery/state/boundary_reporter_mixin.dart";
 import "package:photos/ui/viewer/gallery/state/inherited_search_filter_data.dart";
 import "package:photos/ui/viewer/hierarchicial_search/applied_filters_for_appbar.dart";
 import "package:photos/ui/viewer/hierarchicial_search/recommended_filters_for_appbar.dart";
@@ -114,7 +115,8 @@ enum AlbumPopupAction {
   galleryGuestView,
 }
 
-class _GalleryAppBarWidgetState extends State<GalleryAppBarWidget> {
+class _GalleryAppBarWidgetState extends State<GalleryAppBarWidget>
+    with BoundaryReporter {
   final _logger = Logger("GalleryAppBar");
   late StreamSubscription _userAuthEventSubscription;
   late StreamSubscription<CollectionMetaEvent> _collectionMetaEventSubscription;
@@ -147,6 +149,11 @@ class _GalleryAppBarWidgetState extends State<GalleryAppBarWidget> {
         )
         .listen(stateRefresh);
 
+    // Report boundary after initial build
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      reportBoundary(BoundaryPosition.top);
+    });
+
     _appBarTitle = widget.title;
     galleryType = widget.type;
   }
@@ -171,7 +178,7 @@ class _GalleryAppBarWidgetState extends State<GalleryAppBarWidget> {
     final isHierarchicalSearchable =
         inheritedSearchFilterData?.isHierarchicalSearchable ?? false;
 
-    return galleryType == GalleryType.homepage
+    final appBar = galleryType == GalleryType.homepage
         ? const SizedBox.shrink()
         : isHierarchicalSearchable
             ? ValueListenableBuilder(
@@ -220,6 +227,14 @@ class _GalleryAppBarWidgetState extends State<GalleryAppBarWidget> {
                 ),
                 actions: _getDefaultActions(context),
               );
+
+    // Wrap with boundary widget only if not homepage
+    return galleryType == GalleryType.homepage
+        ? appBar
+        : boundaryWidget(
+            position: BoundaryPosition.top,
+            child: appBar,
+          );
   }
 
   Future<dynamic> _renameAlbum(BuildContext context) async {
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/state/boundary_reporter_mixin.dart b/mobile/apps/photos/lib/ui/viewer/gallery/state/boundary_reporter_mixin.dart
new file mode 100644
index 00000000000..3607f265419
--- /dev/null
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/state/boundary_reporter_mixin.dart
@@ -0,0 +1,64 @@
+import 'dart:async';
+
+import 'package:flutter/material.dart';
+import 'package:photos/ui/viewer/gallery/state/gallery_boundaries_provider.dart';
+
+enum BoundaryPosition { top, bottom }
+
+/// Mixin for widgets that act as boundaries for auto-scroll
+/// Reports their position to GalleryBoundariesProvider with debouncing
+mixin BoundaryReporter<T extends StatefulWidget> on State<T> {
+  final _boundaryKey = GlobalKey();
+  Timer? _boundaryUpdateTimer;
+
+  /// Report this widget's boundary to the provider
+  /// Call this in initState, didUpdateWidget, and when size might change
+  void reportBoundary(BoundaryPosition position) {
+    // Debounce updates to avoid excessive recalculation
+    _boundaryUpdateTimer?.cancel();
+    _boundaryUpdateTimer = Timer(const Duration(milliseconds: 100), () {
+      if (!mounted) return;
+
+      final renderBox =
+          _boundaryKey.currentContext?.findRenderObject() as RenderBox?;
+      if (renderBox != null && renderBox.hasSize) {
+        final offset = renderBox.localToGlobal(Offset.zero);
+        final boundary = position == BoundaryPosition.top
+            ? offset.dy + renderBox.size.height // Bottom edge of top widget
+            : offset.dy; // Top edge of bottom widget
+
+        final provider = GalleryBoundariesProvider.of(context);
+        if (provider != null) {
+          if (position == BoundaryPosition.top) {
+            provider.setTopBoundary(boundary);
+          } else {
+            provider.setBottomBoundary(boundary);
+          }
+        }
+      }
+    });
+  }
+
+  /// Widget that should have its boundary tracked
+  /// Wrap your widget content with this
+  Widget boundaryWidget({
+    required Widget child,
+    required BoundaryPosition position,
+  }) {
+    // Report boundary after frame is rendered
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      reportBoundary(position);
+    });
+
+    return Container(
+      key: _boundaryKey,
+      child: child,
+    );
+  }
+
+  @override
+  void dispose() {
+    _boundaryUpdateTimer?.cancel();
+    super.dispose();
+  }
+}
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_boundaries_provider.dart b/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_boundaries_provider.dart
new file mode 100644
index 00000000000..f603f035dff
--- /dev/null
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_boundaries_provider.dart
@@ -0,0 +1,56 @@
+import 'package:flutter/material.dart';
+
+/// InheritedWidget to share gallery boundaries and scroll controller
+/// between Gallery and its surrounding widgets for auto-scroll functionality
+class GalleryBoundariesProvider extends InheritedWidget {
+  /// Bottom edge position of the top fixed widget (e.g., AppBar)
+  final ValueNotifier<double?> topBoundaryNotifier;
+
+  /// Top edge position of the bottom fixed widget (e.g., FileSelectionOverlayBar)
+  final ValueNotifier<double?> bottomBoundaryNotifier;
+
+  /// Reference to Gallery's ScrollController
+  /// Using ValueNotifier to maintain immutability
+  final ValueNotifier<ScrollController?> scrollControllerNotifier;
+
+  const GalleryBoundariesProvider({
+    super.key,
+    required super.child,
+    required this.topBoundaryNotifier,
+    required this.bottomBoundaryNotifier,
+    required this.scrollControllerNotifier,
+  });
+
+  /// Set the scroll controller from Gallery widget
+  void setScrollController(ScrollController? controller) {
+    scrollControllerNotifier.value = controller;
+  }
+
+  /// Set the top boundary position
+  void setTopBoundary(double? boundary) {
+    topBoundaryNotifier.value = boundary;
+  }
+
+  /// Set the bottom boundary position
+  void setBottomBoundary(double? boundary) {
+    bottomBoundaryNotifier.value = boundary;
+  }
+
+  static GalleryBoundariesProvider? of(BuildContext context) {
+    return context
+        .dependOnInheritedWidgetOfExactType<GalleryBoundariesProvider>();
+  }
+
+  @override
+  bool updateShouldNotify(GalleryBoundariesProvider oldWidget) {
+    return scrollControllerNotifier != oldWidget.scrollControllerNotifier ||
+        topBoundaryNotifier != oldWidget.topBoundaryNotifier ||
+        bottomBoundaryNotifier != oldWidget.bottomBoundaryNotifier;
+  }
+
+  void dispose() {
+    topBoundaryNotifier.dispose();
+    bottomBoundaryNotifier.dispose();
+    scrollControllerNotifier.dispose();
+  }
+}
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/swipe_selection_wrapper.dart b/mobile/apps/photos/lib/ui/viewer/gallery/swipe_selection_wrapper.dart
index 8f98bf124a3..a72f5dc7ce2 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/swipe_selection_wrapper.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/swipe_selection_wrapper.dart
@@ -1,5 +1,9 @@
+import 'dart:async';
+import 'dart:math' as math;
+
 import 'package:flutter/material.dart';
 import 'package:photos/models/selected_files.dart';
+import 'package:photos/ui/viewer/gallery/state/gallery_boundaries_provider.dart';
 import 'package:photos/ui/viewer/gallery/state/gallery_swipe_helper.dart';
 import 'package:photos/ui/viewer/gallery/swipe_to_select_helper.dart';
 
@@ -30,6 +34,17 @@ class SwipeSelectionWrapper extends StatefulWidget {
 class _SwipeSelectionWrapperState extends State<SwipeSelectionWrapper> {
   bool? _initialMovementWasHorizontal;
 
+  // Auto-scroll related fields
+  Timer? _autoScrollTimer;
+  double _currentPointerY = 0;
+
+  // Auto-scroll constants
+  static const double _baseScrollSpeed = 2.0; // Base speed in pixels per frame
+  static const double _maxScrollSpeed = 15.0; // Maximum speed cap
+  static const double _scrollIntervalMs = 8.33; // ~120fps in milliseconds
+  static const double _exponentialFactor =
+      0.015; // Controls speed increase rate
+
   @override
   Widget build(BuildContext context) {
     // If swipe selection is not enabled, just return the child wrapped in GallerySwipeHelper
@@ -46,11 +61,13 @@ class _SwipeSelectionWrapperState extends State<SwipeSelectionWrapper> {
       helper: widget.swipeHelper,
       swipeActiveNotifier: widget.swipeActiveNotifier,
       child: Listener(
-        onPointerDown: (_) {
+        onPointerDown: (event) {
+          _currentPointerY = event.position.dy;
           // Reset initial movement tracking for new gesture
           _initialMovementWasHorizontal = null;
         },
         onPointerMove: (event) {
+          _currentPointerY = event.position.dy;
           // Handle case where pointer is dragged after first selection in gallery
           if (widget.selectedFiles != null &&
               widget.selectedFiles!.files.length == 1 &&
@@ -84,14 +101,21 @@ class _SwipeSelectionWrapperState extends State<SwipeSelectionWrapper> {
               widget.swipeActiveNotifier.value = true;
             }
           }
+
+          // Check for auto-scroll if swipe is active
+          if (widget.swipeActiveNotifier.value) {
+            _checkAndHandleAutoScroll();
+          }
         },
         onPointerUp: (_) {
+          _stopAutoScroll();
           // End swipe selection when pointer is released
           widget.swipeHelper?.endSelection();
           widget.swipeActiveNotifier.value = false;
           _initialMovementWasHorizontal = null;
         },
         onPointerCancel: (_) {
+          _stopAutoScroll();
           // Also end selection on cancel
           widget.swipeHelper?.endSelection();
           widget.swipeActiveNotifier.value = false;
@@ -101,4 +125,100 @@ class _SwipeSelectionWrapperState extends State<SwipeSelectionWrapper> {
       ),
     );
   }
+
+  /// Calculate exponential scroll speed based on distance from boundary
+  double _calculateScrollSpeed(double distanceFromBoundary) {
+    // Exponential formula: speed = base * e^(factor * distance)
+    final speed =
+        _baseScrollSpeed * math.exp(_exponentialFactor * distanceFromBoundary);
+    return math.min(speed, _maxScrollSpeed);
+  }
+
+  /// Check if pointer is outside boundaries and start/stop auto-scroll
+  void _checkAndHandleAutoScroll() {
+    final provider = GalleryBoundariesProvider.of(context);
+    if (provider == null) return;
+
+    final topBoundary = provider.topBoundaryNotifier.value;
+    final bottomBoundary = provider.bottomBoundaryNotifier.value;
+    final scrollController = provider.scrollControllerNotifier.value;
+
+    if (scrollController == null || !scrollController.hasClients) return;
+
+    // Validate boundaries don't overlap (viewport too small)
+    if (topBoundary != null &&
+        bottomBoundary != null &&
+        topBoundary >= bottomBoundary) {
+      _stopAutoScroll();
+      throw Exception(
+        'Invalid boundaries: top boundary ($topBoundary) >= bottom boundary ($bottomBoundary). '
+        'Viewport is too small for auto-scroll.',
+      );
+    }
+
+    // Determine if we need to scroll and in which direction
+    if (topBoundary != null && _currentPointerY < topBoundary) {
+      // Pointer is above top boundary - scroll up
+      final distance = topBoundary - _currentPointerY;
+      _startAutoScroll(scrollController, -1, distance);
+    } else if (bottomBoundary != null && _currentPointerY > bottomBoundary) {
+      // Pointer is below bottom boundary - scroll down
+      final distance = _currentPointerY - bottomBoundary;
+      _startAutoScroll(scrollController, 1, distance);
+    } else {
+      // Pointer is within boundaries - stop scrolling
+      _stopAutoScroll();
+    }
+  }
+
+  /// Start auto-scrolling in the specified direction
+  void _startAutoScroll(
+    ScrollController controller,
+    int direction,
+    double distance,
+  ) {
+    // Cancel existing timer if any
+    _stopAutoScroll();
+
+    final scrollSpeed = _calculateScrollSpeed(distance);
+
+    // Start periodic timer for smooth scrolling at 120fps
+    _autoScrollTimer = Timer.periodic(
+      Duration(microseconds: (_scrollIntervalMs * 1000).toInt()),
+      (_) {
+        if (!mounted || !controller.hasClients) {
+          _stopAutoScroll();
+          return;
+        }
+
+        // Calculate new scroll position
+        final currentOffset = controller.offset;
+        final scrollDelta = scrollSpeed * direction;
+        final newOffset = currentOffset + scrollDelta;
+
+        // Clamp to scroll bounds
+        final clampedOffset = newOffset.clamp(
+          controller.position.minScrollExtent,
+          controller.position.maxScrollExtent,
+        );
+
+        // Use jumpTo for immediate positioning (smoother than animateTo for continuous scroll)
+        if (clampedOffset != currentOffset) {
+          controller.jumpTo(clampedOffset);
+        }
+      },
+    );
+  }
+
+  /// Stop auto-scrolling
+  void _stopAutoScroll() {
+    _autoScrollTimer?.cancel();
+    _autoScrollTimer = null;
+  }
+
+  @override
+  void dispose() {
+    _stopAutoScroll();
+    super.dispose();
+  }
 }
