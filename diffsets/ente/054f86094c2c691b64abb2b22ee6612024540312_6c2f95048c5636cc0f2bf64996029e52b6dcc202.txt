diff --git a/web/apps/embed/.env b/web/apps/embed/.env
new file mode 100644
index 00000000000..6999c1f005f
--- /dev/null
+++ b/web/apps/embed/.env
@@ -0,0 +1,6 @@
+# Embed app configuration
+# This is a simplified version of the photos app for embedding
+
+# The following environment variables will be set by our next config
+# NEXT_PUBLIC_ENTE_WIP_L10N=''
+# NEXT_PUBLIC_ENTE_WIP_CL=''
\ No newline at end of file
diff --git a/web/apps/embed/eslint.config.mjs b/web/apps/embed/eslint.config.mjs
new file mode 100644
index 00000000000..3fb4491a255
--- /dev/null
+++ b/web/apps/embed/eslint.config.mjs
@@ -0,0 +1 @@
+export { default } from "ente-build-config/eslint.config.base.mjs";
diff --git a/web/apps/embed/next.config.js b/web/apps/embed/next.config.js
new file mode 100644
index 00000000000..5a52794ab2a
--- /dev/null
+++ b/web/apps/embed/next.config.js
@@ -0,0 +1 @@
+module.exports = require("ente-base/next.config.base.js");
diff --git a/web/apps/embed/package.json b/web/apps/embed/package.json
new file mode 100644
index 00000000000..5a07cc2a96f
--- /dev/null
+++ b/web/apps/embed/package.json
@@ -0,0 +1,23 @@
+{
+    "name": "embed",
+    "version": "0.0.0",
+    "private": true,
+    "dependencies": {
+        "ente-base": "*",
+        "ente-gallery": "*",
+        "ente-media": "*",
+        "ente-new": "*",
+        "memoize-one": "^6.0.0",
+        "react": "^19.1.0",
+        "react-dom": "^19.1.0",
+        "react-virtualized-auto-sizer": "^1.0.26",
+        "react-window": "^1.8.11"
+    },
+    "devDependencies": {
+        "@types/node": "^22.15.32",
+        "@types/react": "^19.1.8",
+        "@types/react-dom": "^19.1.6",
+        "@types/react-window": "^1.8.8",
+        "ente-build-config": "*"
+    }
+}
diff --git a/web/apps/embed/src/components/EmbedFileList.tsx b/web/apps/embed/src/components/EmbedFileList.tsx
new file mode 100644
index 00000000000..af9130e27c1
--- /dev/null
+++ b/web/apps/embed/src/components/EmbedFileList.tsx
@@ -0,0 +1,173 @@
+import PlayCircleOutlineOutlinedIcon from "@mui/icons-material/PlayCircleOutlineOutlined";
+import { Box, styled } from "@mui/material";
+import { downloadManager } from "ente-gallery/services/download";
+import type { EnteFile } from "ente-media/file";
+import { fileDurationString } from "ente-media/file-metadata";
+import { FileType } from "ente-media/file-type";
+import {
+    LoadingThumbnail,
+    StaticThumbnail,
+} from "ente-new/photos/components/PlaceholderThumbnails";
+import { TileBottomTextOverlay } from "ente-new/photos/components/Tiles";
+import React, { memo, useCallback, useMemo, useState } from "react";
+
+export interface EmbedFileListAnnotatedFile {
+    file: EnteFile;
+    timelineDateString: string;
+}
+
+export interface EmbedFileListProps {
+    width: number;
+    height: number;
+    annotatedFiles: EmbedFileListAnnotatedFile[];
+    onItemClick: (index: number) => void;
+}
+
+const THUMBNAIL_SIZE = 200;
+const THUMBNAIL_GAP = 4;
+
+export const EmbedFileList: React.FC<EmbedFileListProps> = memo(
+    ({ width, height, annotatedFiles, onItemClick }) => {
+        const columns = Math.floor(width / (THUMBNAIL_SIZE + THUMBNAIL_GAP));
+        const actualThumbnailSize =
+            (width - (columns - 1) * THUMBNAIL_GAP) / columns;
+
+        return (
+            <Container style={{ width, height }}>
+                <Grid columns={columns} gap={THUMBNAIL_GAP}>
+                    {annotatedFiles.map((annotatedFile, index) => (
+                        <EmbedFileTile
+                            key={`${annotatedFile.file.id}-${index}`}
+                            file={annotatedFile.file}
+                            size={actualThumbnailSize}
+                            onClick={() => onItemClick(index)}
+                        />
+                    ))}
+                </Grid>
+            </Container>
+        );
+    },
+);
+
+EmbedFileList.displayName = "EmbedFileList";
+
+interface EmbedFileTileProps {
+    file: EnteFile;
+    size: number;
+    onClick: () => void;
+}
+
+const EmbedFileTile: React.FC<EmbedFileTileProps> = memo(
+    ({ file, size, onClick }) => {
+        const [thumbnailSrc, setThumbnailSrc] = useState<string>();
+        const [isLoading, setIsLoading] = useState(true);
+
+        const isVideoFile = useMemo(
+            () => file.metadata.fileType === FileType.video,
+            [file.metadata.fileType],
+        );
+
+        const loadThumbnail = useCallback(async () => {
+            try {
+                setIsLoading(true);
+                const thumbnailData = await downloadManager.thumbnailData(file);
+                if (thumbnailData) {
+                    const blob = new Blob([thumbnailData]);
+                    const url = URL.createObjectURL(blob);
+                    setThumbnailSrc(url);
+                }
+            } catch (error) {
+                console.error("Failed to load thumbnail:", error);
+            } finally {
+                setIsLoading(false);
+            }
+        }, [file]);
+
+        React.useEffect(() => {
+            void loadThumbnail();
+
+            return () => {
+                if (thumbnailSrc) {
+                    URL.revokeObjectURL(thumbnailSrc);
+                }
+            };
+        }, [loadThumbnail, thumbnailSrc]);
+
+        const content = useMemo(() => {
+            if (isLoading) {
+                return <LoadingThumbnail />;
+            }
+
+            if (!thumbnailSrc) {
+                return <StaticThumbnail fileType={file.metadata.fileType} />;
+            }
+
+            return (
+                <ThumbnailImage
+                    src={thumbnailSrc}
+                    alt=""
+                    style={{ width: size, height: size }}
+                />
+            );
+        }, [isLoading, thumbnailSrc, size]);
+
+        return (
+            <TileContainer
+                style={{ width: size, height: size }}
+                onClick={onClick}
+            >
+                {content}
+                {isVideoFile && (
+                    <VideoOverlay>
+                        <PlayCircleOutlineOutlinedIcon />
+                        <TileBottomTextOverlay>
+                            {fileDurationString(file)}
+                        </TileBottomTextOverlay>
+                    </VideoOverlay>
+                )}
+            </TileContainer>
+        );
+    },
+);
+
+EmbedFileTile.displayName = "EmbedFileTile";
+
+const Container = styled("div")({ overflow: "auto", padding: THUMBNAIL_GAP });
+
+const Grid = styled("div")<{ columns: number; gap: number }>(
+    ({ columns, gap }) => ({
+        display: "grid",
+        gridTemplateColumns: `repeat(${columns}, 1fr)`,
+        gap: `${gap}px`,
+    }),
+);
+
+const TileContainer = styled("div")({
+    position: "relative",
+    cursor: "pointer",
+    borderRadius: "4px",
+    overflow: "hidden",
+    transition: "transform 0.2s ease",
+    "&:hover": { transform: "scale(1.02)" },
+});
+
+const ThumbnailImage = styled("img")({
+    objectFit: "cover",
+    borderRadius: "4px",
+});
+
+const VideoOverlay = styled(Box)({
+    position: "absolute",
+    top: 0,
+    left: 0,
+    right: 0,
+    bottom: 0,
+    display: "flex",
+    alignItems: "center",
+    justifyContent: "center",
+    color: "white",
+    "& svg": {
+        fontSize: "2rem",
+        filter: "drop-shadow(0 1px 3px rgba(0,0,0,0.5))",
+    },
+});
diff --git a/web/apps/embed/src/components/EmbedFileListWithViewer.tsx b/web/apps/embed/src/components/EmbedFileListWithViewer.tsx
new file mode 100644
index 00000000000..0d22adc6c8d
--- /dev/null
+++ b/web/apps/embed/src/components/EmbedFileListWithViewer.tsx
@@ -0,0 +1,75 @@
+import { styled } from "@mui/material";
+import { isSameDay } from "ente-base/date";
+import { formattedDate } from "ente-base/i18n-date";
+import type { EnteFile } from "ente-media/file";
+import { fileCreationTime } from "ente-media/file-metadata";
+import { t } from "i18next";
+import { useCallback, useMemo, useState } from "react";
+import AutoSizer from "react-virtualized-auto-sizer";
+import {
+    EmbedFileList,
+    type EmbedFileListAnnotatedFile,
+} from "./EmbedFileList";
+import { EmbedFileViewer } from "./EmbedFileViewer";
+
+export interface EmbedFileListWithViewerProps {
+    files: EnteFile[];
+    onRemotePull?: () => Promise<void>; // Optional for embed
+}
+
+export const EmbedFileListWithViewer: React.FC<
+    EmbedFileListWithViewerProps
+> = ({ files }) => {
+    const [openFileViewer, setOpenFileViewer] = useState(false);
+    const [currentIndex, setCurrentIndex] = useState(0);
+
+    const annotatedFiles = useMemo(
+        (): EmbedFileListAnnotatedFile[] =>
+            files.map((file) => ({
+                file,
+                timelineDateString: fileTimelineDateString(file),
+            })),
+        [files],
+    );
+
+    const handleThumbnailClick = useCallback((index: number) => {
+        setCurrentIndex(index);
+        setOpenFileViewer(true);
+    }, []);
+
+    const handleCloseFileViewer = useCallback(() => {
+        setOpenFileViewer(false);
+    }, []);
+
+    return (
+        <Container>
+            <AutoSizer>
+                {({ height, width }) => (
+                    <EmbedFileList
+                        width={width}
+                        height={height}
+                        annotatedFiles={annotatedFiles}
+                        onItemClick={handleThumbnailClick}
+                    />
+                )}
+            </AutoSizer>
+            <EmbedFileViewer
+                open={openFileViewer}
+                onClose={handleCloseFileViewer}
+                initialIndex={currentIndex}
+                files={files}
+            />
+        </Container>
+    );
+};
+
+const Container = styled("div")({ flex: 1, width: "100%" });
+
+const fileTimelineDateString = (file: EnteFile) => {
+    const date = new Date(fileCreationTime(file) / 1000);
+    return isSameDay(date, new Date())
+        ? t("today")
+        : isSameDay(date, new Date(Date.now() - 24 * 60 * 60 * 1000))
+          ? t("yesterday")
+          : formattedDate(date);
+};
diff --git a/web/apps/embed/src/components/EmbedFileViewer.tsx b/web/apps/embed/src/components/EmbedFileViewer.tsx
new file mode 100644
index 00000000000..eb535dedef6
--- /dev/null
+++ b/web/apps/embed/src/components/EmbedFileViewer.tsx
@@ -0,0 +1,318 @@
+import ArrowBackIosIcon from "@mui/icons-material/ArrowBackIos";
+import ArrowForwardIosIcon from "@mui/icons-material/ArrowForwardIos";
+import CloseIcon from "@mui/icons-material/Close";
+import FullscreenIcon from "@mui/icons-material/Fullscreen";
+import FullscreenExitIcon from "@mui/icons-material/FullscreenExit";
+import { Dialog, IconButton, styled } from "@mui/material";
+import type { EnteFile } from "ente-media/file";
+import { FileType } from "ente-media/file-type";
+import React, { useCallback, useEffect, useMemo, useState } from "react";
+
+export interface EmbedFileViewerProps {
+    open: boolean;
+    onClose: () => void;
+    initialIndex: number;
+    files: EnteFile[];
+}
+
+export const EmbedFileViewer: React.FC<EmbedFileViewerProps> = ({
+    open,
+    onClose,
+    initialIndex,
+    files,
+}) => {
+    const [currentIndex, setCurrentIndex] = useState(initialIndex);
+    const [isFullscreen, setIsFullscreen] = useState(false);
+
+    const currentFile = useMemo(
+        () => files[currentIndex],
+        [files, currentIndex],
+    );
+
+    // Update currentIndex when initialIndex changes (and dialog is open)
+    useEffect(() => {
+        if (open) {
+            setCurrentIndex(initialIndex);
+        }
+    }, [open, initialIndex]);
+
+    const navigateToNext = useCallback(() => {
+        if (currentIndex < files.length - 1) {
+            setCurrentIndex(currentIndex + 1);
+        }
+    }, [currentIndex, files.length]);
+
+    const navigateToPrevious = useCallback(() => {
+        if (currentIndex > 0) {
+            setCurrentIndex(currentIndex - 1);
+        }
+    }, [currentIndex]);
+
+    const toggleFullscreen = useCallback(() => {
+        setIsFullscreen(!isFullscreen);
+    }, [isFullscreen]);
+
+    const handleKeyDown = useCallback(
+        (event: KeyboardEvent) => {
+            if (!open) return;
+
+            switch (event.key) {
+                case "ArrowRight":
+                    navigateToNext();
+                    break;
+                case "ArrowLeft":
+                    navigateToPrevious();
+                    break;
+                case "Escape":
+                    if (isFullscreen) {
+                        setIsFullscreen(false);
+                    } else {
+                        onClose();
+                    }
+                    break;
+                case "f":
+                case "F":
+                    toggleFullscreen();
+                    break;
+            }
+        },
+        [
+            open,
+            navigateToNext,
+            navigateToPrevious,
+            onClose,
+            isFullscreen,
+            toggleFullscreen,
+        ],
+    );
+
+    useEffect(() => {
+        document.addEventListener("keydown", handleKeyDown);
+        return () => document.removeEventListener("keydown", handleKeyDown);
+    }, [handleKeyDown]);
+
+    if (!currentFile) {
+        return null;
+    }
+
+    return (
+        <EmbedViewerDialog
+            open={open}
+            onClose={onClose}
+            fullScreen
+            isFullscreen={isFullscreen}
+        >
+            {!isFullscreen && (
+                <Controls>
+                    <TopControls>
+                        <IconButton onClick={onClose} color="inherit">
+                            <CloseIcon />
+                        </IconButton>
+                    </TopControls>
+                    <BottomControls>
+                        <IconButton
+                            onClick={navigateToPrevious}
+                            disabled={currentIndex === 0}
+                            color="inherit"
+                        >
+                            <ArrowBackIosIcon />
+                        </IconButton>
+                        <IconButton onClick={toggleFullscreen} color="inherit">
+                            <FullscreenIcon />
+                        </IconButton>
+                        <IconButton
+                            onClick={navigateToNext}
+                            disabled={currentIndex === files.length - 1}
+                            color="inherit"
+                        >
+                            <ArrowForwardIosIcon />
+                        </IconButton>
+                    </BottomControls>
+                </Controls>
+            )}
+
+            {isFullscreen && (
+                <FullscreenControls>
+                    <IconButton onClick={toggleFullscreen} color="inherit">
+                        <FullscreenExitIcon />
+                    </IconButton>
+                </FullscreenControls>
+            )}
+
+            <MediaContainer>
+                <EmbedMediaRenderer
+                    file={currentFile}
+                    isFullscreen={isFullscreen}
+                />
+            </MediaContainer>
+        </EmbedViewerDialog>
+    );
+};
+
+interface EmbedMediaRendererProps {
+    file: EnteFile;
+    isFullscreen: boolean;
+}
+
+const EmbedMediaRenderer: React.FC<EmbedMediaRendererProps> = ({
+    file,
+    isFullscreen,
+}) => {
+    const [mediaSrc, setMediaSrc] = useState<string>();
+    const [isLoading, setIsLoading] = useState(true);
+
+    useEffect(() => {
+        const loadMedia = async () => {
+            try {
+                setIsLoading(true);
+                // For embed, we'll use thumbnail for now - in a production version,
+                // you might want to load the full resolution file
+                const { downloadManager } = await import(
+                    "ente-gallery/services/download"
+                );
+                const thumbnailData = await downloadManager.thumbnailData(file);
+                if (!thumbnailData) throw new Error("No thumbnail data");
+                const media = new Blob([thumbnailData]);
+                const url = URL.createObjectURL(media);
+                setMediaSrc(url);
+            } catch (error) {
+                console.error("Failed to load media:", error);
+            } finally {
+                setIsLoading(false);
+            }
+        };
+
+        void loadMedia();
+
+        return () => {
+            if (mediaSrc) {
+                URL.revokeObjectURL(mediaSrc);
+            }
+        };
+    }, [file, mediaSrc]);
+
+    if (isLoading) {
+        return <MediaPlaceholder>Loading...</MediaPlaceholder>;
+    }
+
+    if (!mediaSrc) {
+        return <MediaPlaceholder>Failed to load media</MediaPlaceholder>;
+    }
+
+    const isVideo = file.metadata.fileType === FileType.video;
+
+    return isVideo ? (
+        <MediaVideo src={mediaSrc} controls isFullscreen={isFullscreen} />
+    ) : (
+        <MediaImage src={mediaSrc} alt="" isFullscreen={isFullscreen} />
+    );
+};
+
+const EmbedViewerDialog = styled(Dialog)<{ isFullscreen: boolean }>(
+    ({ theme, isFullscreen }) => ({
+        "& .MuiDialog-paper": {
+            backgroundColor: theme.palette.background.default,
+            backgroundImage: "none",
+            margin: 0,
+            maxWidth: "none",
+            maxHeight: "none",
+            width: "100%",
+            height: "100%",
+            borderRadius: 0,
+        },
+        "& .MuiBackdrop-root": {
+            backgroundColor: isFullscreen
+                ? "rgba(0, 0, 0, 1)"
+                : "rgba(0, 0, 0, 0.8)",
+        },
+    }),
+);
+
+const Controls = styled("div")({
+    position: "absolute",
+    top: 0,
+    left: 0,
+    right: 0,
+    bottom: 0,
+    pointerEvents: "none",
+    zIndex: 1,
+});
+
+const TopControls = styled("div")({
+    position: "absolute",
+    top: 0,
+    right: 0,
+    padding: "16px",
+    pointerEvents: "auto",
+    "& button": {
+        backgroundColor: "rgba(0, 0, 0, 0.5)",
+        color: "white",
+        "&:hover": { backgroundColor: "rgba(0, 0, 0, 0.7)" },
+    },
+});
+
+const BottomControls = styled("div")({
+    position: "absolute",
+    bottom: 0,
+    left: "50%",
+    transform: "translateX(-50%)",
+    padding: "16px",
+    display: "flex",
+    gap: "8px",
+    pointerEvents: "auto",
+    "& button": {
+        backgroundColor: "rgba(0, 0, 0, 0.5)",
+        color: "white",
+        "&:hover": { backgroundColor: "rgba(0, 0, 0, 0.7)" },
+        "&:disabled": {
+            backgroundColor: "rgba(0, 0, 0, 0.3)",
+            color: "rgba(255, 255, 255, 0.5)",
+        },
+    },
+});
+
+const FullscreenControls = styled("div")({
+    position: "absolute",
+    top: "16px",
+    right: "16px",
+    zIndex: 2,
+    pointerEvents: "auto",
+    "& button": {
+        backgroundColor: "rgba(0, 0, 0, 0.5)",
+        color: "white",
+        "&:hover": { backgroundColor: "rgba(0, 0, 0, 0.7)" },
+    },
+});
+
+const MediaContainer = styled("div")({
+    display: "flex",
+    alignItems: "center",
+    justifyContent: "center",
+    width: "100%",
+    height: "100%",
+});
+
+const MediaPlaceholder = styled("div")({
+    display: "flex",
+    alignItems: "center",
+    justifyContent: "center",
+    color: "white",
+    fontSize: "1.2rem",
+});
+
+const MediaImage = styled("img")<{ isFullscreen: boolean }>(
+    ({ isFullscreen }) => ({
+        maxWidth: "100%",
+        maxHeight: "100%",
+        objectFit: "contain",
+        ...(isFullscreen && { width: "100vw", height: "100vh" }),
+    }),
+);
+
+const MediaVideo = styled("video")<{ isFullscreen: boolean }>(
+    ({ isFullscreen }) => ({
+        maxWidth: "100%",
+        maxHeight: "100%",
+        ...(isFullscreen && { width: "100vw", height: "100vh" }),
+    }),
+);
diff --git a/web/apps/embed/src/components/EmbedPasswordForm.tsx b/web/apps/embed/src/components/EmbedPasswordForm.tsx
new file mode 100644
index 00000000000..1fbf301b89c
--- /dev/null
+++ b/web/apps/embed/src/components/EmbedPasswordForm.tsx
@@ -0,0 +1,51 @@
+import { Stack, Typography } from "@mui/material";
+import {
+    AccountsPageContents,
+    AccountsPageTitle,
+} from "ente-accounts/components/layouts/centered-paper";
+import {
+    SingleInputForm,
+    type SingleInputFormProps,
+} from "ente-base/components/SingleInputForm";
+import { t } from "i18next";
+
+interface EmbedPasswordFormProps {
+    onSubmit: (password: string) => Promise<void>;
+}
+
+export const EmbedPasswordForm: React.FC<EmbedPasswordFormProps> = ({
+    onSubmit,
+}) => {
+    const handleSubmit: SingleInputFormProps["onSubmit"] = async (
+        password,
+        setFieldError,
+    ) => {
+        try {
+            await onSubmit(password);
+        } catch (e) {
+            if (e instanceof Error) {
+                setFieldError(e.message);
+            } else {
+                setFieldError(t("generic_error"));
+            }
+        }
+    };
+
+    return (
+        <AccountsPageContents>
+            <AccountsPageTitle>{t("password")}</AccountsPageTitle>
+            <Stack>
+                <Typography variant="small" sx={{ color: "text.muted", mb: 2 }}>
+                    {t("link_password_description")}
+                </Typography>
+                <SingleInputForm
+                    inputType="password"
+                    label={t("password")}
+                    submitButtonColor="primary"
+                    submitButtonTitle={t("unlock")}
+                    onSubmit={handleSubmit}
+                />
+            </Stack>
+        </AccountsPageContents>
+    );
+};
diff --git a/web/apps/embed/src/pages/_app.tsx b/web/apps/embed/src/pages/_app.tsx
new file mode 100644
index 00000000000..fd0c3edce1e
--- /dev/null
+++ b/web/apps/embed/src/pages/_app.tsx
@@ -0,0 +1,79 @@
+import "@fontsource-variable/inter";
+import { CssBaseline } from "@mui/material";
+import { ThemeProvider } from "@mui/material/styles";
+import { CustomHeadPhotosOrAlbums } from "ente-base/components/Head";
+import {
+    useIsRouteChangeInProgress,
+    useSetupI18n,
+    useSetupLogs,
+} from "ente-base/components/utils/hooks-app";
+import { photosTheme } from "ente-base/components/utils/theme";
+import { BaseContext, deriveBaseContext } from "ente-base/context";
+import { logStartupBanner } from "ente-base/log-web";
+import { ThemedLoadingBar } from "ente-new/photos/components/ThemedLoadingBar";
+import { useLoadingBar } from "ente-new/photos/components/utils/use-loading-bar";
+import { PhotosAppContext } from "ente-new/photos/types/context";
+import type { AppProps } from "next/app";
+import { useCallback, useEffect, useMemo } from "react";
+
+export default function App({ Component, pageProps }: AppProps) {
+    useSetupLogs();
+    useSetupI18n();
+
+    useEffect(() => {
+        void logStartupBanner();
+    }, []);
+
+    // Simplified - no complex dialogs needed for embed
+    const isRouteChangeInProgress = useIsRouteChangeInProgress();
+
+    const { showLoadingBar, hideLoadingBar } = useLoadingBar();
+
+    // Show loading bar on route changes
+    useEffect(() => {
+        if (isRouteChangeInProgress) {
+            showLoadingBar();
+        } else {
+            hideLoadingBar();
+        }
+    }, [isRouteChangeInProgress, showLoadingBar, hideLoadingBar]);
+
+    const showMiniDialog = useCallback(() => {
+        // Simplified for embed - no complex dialogs needed
+    }, []);
+
+    const logout = useCallback(() => {
+        // No logout functionality needed for embed
+    }, []);
+
+    const baseContext = useMemo(
+        () => deriveBaseContext({ logout, showMiniDialog }),
+        [logout, showMiniDialog],
+    );
+
+    const photosAppContextValue = useMemo(
+        () => ({
+            showLoadingBar,
+            hideLoadingBar,
+            showNotification: () => {}, // No notifications in embed
+            watchFolderView: false,
+            setWatchFolderView: () => {}, // No watch folder in embed
+        }),
+        [showLoadingBar, hideLoadingBar],
+    );
+
+    return (
+        <>
+            <CustomHeadPhotosOrAlbums title="Ente Photos" />
+            <ThemeProvider theme={photosTheme}>
+                <CssBaseline enableColorScheme />
+                <BaseContext.Provider value={baseContext}>
+                    <PhotosAppContext.Provider value={photosAppContextValue}>
+                        <Component {...pageProps} />
+                        <ThemedLoadingBar ref={{ current: null }} />
+                    </PhotosAppContext.Provider>
+                </BaseContext.Provider>
+            </ThemeProvider>
+        </>
+    );
+}
diff --git a/web/apps/embed/src/pages/index.tsx b/web/apps/embed/src/pages/index.tsx
new file mode 100644
index 00000000000..401f4fdc40c
--- /dev/null
+++ b/web/apps/embed/src/pages/index.tsx
@@ -0,0 +1,252 @@
+import { styled } from "@mui/material";
+import Typography from "@mui/material/Typography";
+import {
+    CenteredFill,
+    Stack100vhCenter,
+} from "ente-base/components/containers";
+import { LoadingIndicator } from "ente-base/components/loaders";
+import { useBaseContext } from "ente-base/context";
+import {
+    isHTTP401Error,
+    isHTTPErrorWithStatus,
+    type PublicAlbumsCredentials,
+} from "ente-base/http";
+import log from "ente-base/log";
+import { downloadManager } from "ente-gallery/services/download";
+import { extractCollectionKeyFromShareURL } from "ente-gallery/services/share";
+import { sortFiles } from "ente-gallery/utils/file";
+import type { Collection } from "ente-media/collection";
+import { type EnteFile } from "ente-media/file";
+import {
+    removePublicCollectionByKey,
+    savedPublicCollectionAccessTokenJWT,
+    savedPublicCollectionByKey,
+    savedPublicCollectionFiles,
+    savePublicCollectionAccessTokenJWT,
+} from "ente-new/albums/services/public-albums-fdb";
+import {
+    pullCollection,
+    pullPublicCollectionFiles,
+    removePublicCollectionFileData,
+    verifyPublicAlbumPassword,
+} from "ente-new/albums/services/public-collection";
+import { usePhotosAppContext } from "ente-new/photos/types/context";
+import { t } from "i18next";
+import { useCallback, useEffect, useRef, useState } from "react";
+import { EmbedFileListWithViewer } from "../components/EmbedFileListWithViewer";
+import { EmbedPasswordForm } from "../components/EmbedPasswordForm";
+
+export default function EmbedGallery() {
+    const { onGenericError } = useBaseContext();
+    const { showLoadingBar, hideLoadingBar } = usePhotosAppContext();
+
+    const [publicCollection, setPublicCollection] = useState<
+        Collection | undefined
+    >(undefined);
+    const [publicFiles, setPublicFiles] = useState<EnteFile[] | undefined>(
+        undefined,
+    );
+    const [errorMessage, setErrorMessage] = useState<string>("");
+    const [loading, setLoading] = useState(true);
+    const [isPasswordProtected, setIsPasswordProtected] = useState(false);
+
+    const credentials = useRef<PublicAlbumsCredentials | undefined>(undefined);
+    const collectionKey = useRef<string | undefined>(undefined);
+
+    useEffect(() => {
+        const currentURL = new URL(window.location.href);
+
+        const main = async () => {
+            let redirectingToWebsite = false;
+            try {
+                const t = currentURL.searchParams.get("t");
+                const ck = await extractCollectionKeyFromShareURL(currentURL);
+                if (!t && !ck) {
+                    window.location.href = "https://ente.io";
+                    redirectingToWebsite = true;
+                }
+                if (!t || !ck) {
+                    return;
+                }
+
+                collectionKey.current = ck;
+                const collection = await savedPublicCollectionByKey(ck);
+                const accessToken = t;
+                let accessTokenJWT: string | undefined;
+
+                if (collection) {
+                    setPublicCollection(collection);
+                    setIsPasswordProtected(
+                        !!collection.publicURLs[0]?.passwordEnabled,
+                    );
+                    setPublicFiles(
+                        sortFilesForCollection(
+                            await savedPublicCollectionFiles(accessToken),
+                            collection,
+                        ),
+                    );
+                    accessTokenJWT =
+                        await savedPublicCollectionAccessTokenJWT(accessToken);
+                }
+
+                credentials.current = { accessToken, accessTokenJWT };
+                downloadManager.setPublicAlbumsCredentials(credentials.current);
+
+                await publicAlbumsRemotePull();
+            } finally {
+                if (!redirectingToWebsite) {
+                    setLoading(false);
+                }
+            }
+        };
+        main();
+    }, []);
+
+    const publicAlbumsRemotePull = useCallback(async () => {
+        const accessToken = credentials.current!.accessToken;
+        showLoadingBar();
+        setLoading(true);
+        try {
+            const { collection } = await pullCollection(
+                accessToken,
+                collectionKey.current!,
+            );
+
+            setPublicCollection(collection);
+            const isPasswordProtected =
+                !!collection.publicURLs[0]?.passwordEnabled;
+            setIsPasswordProtected(isPasswordProtected);
+            setErrorMessage("");
+
+            if (!isPasswordProtected && credentials.current?.accessTokenJWT) {
+                credentials.current.accessTokenJWT = undefined;
+                downloadManager.setPublicAlbumsCredentials(credentials.current);
+            }
+
+            if (isPasswordProtected && !credentials.current?.accessTokenJWT) {
+                await removePublicCollectionFileData(accessToken);
+            } else {
+                try {
+                    await pullPublicCollectionFiles(
+                        credentials.current!,
+                        collection,
+                        (files) =>
+                            setPublicFiles(
+                                sortFilesForCollection(files, collection),
+                            ),
+                    );
+                } catch (e) {
+                    if (isHTTP401Error(e)) {
+                        credentials.current!.accessTokenJWT = undefined;
+                        downloadManager.setPublicAlbumsCredentials(
+                            credentials.current,
+                        );
+                    } else {
+                        throw e;
+                    }
+                }
+            }
+        } catch (e) {
+            if (
+                isHTTPErrorWithStatus(e, 401) ||
+                isHTTPErrorWithStatus(e, 410) ||
+                isHTTPErrorWithStatus(e, 429)
+            ) {
+                setErrorMessage(
+                    isHTTPErrorWithStatus(e, 429)
+                        ? t("link_request_limit_exceeded")
+                        : t("link_expired_message"),
+                );
+                await removePublicCollectionFileData(accessToken);
+                await removePublicCollectionByKey(collectionKey.current!);
+                setPublicCollection(undefined);
+                setPublicFiles(undefined);
+            } else {
+                log.error("Public album remote pull failed", e);
+                onGenericError(e);
+            }
+        } finally {
+            hideLoadingBar();
+            setLoading(false);
+        }
+    }, [showLoadingBar, hideLoadingBar, onGenericError]);
+
+    const handleSubmitPassword = async (password: string) => {
+        try {
+            const accessToken = credentials.current!.accessToken;
+            const accessTokenJWT = await verifyPublicAlbumPassword(
+                publicCollection!.publicURLs[0]!,
+                password,
+                accessToken,
+            );
+            credentials.current!.accessTokenJWT = accessTokenJWT;
+            downloadManager.setPublicAlbumsCredentials(credentials.current);
+            await savePublicCollectionAccessTokenJWT(
+                accessToken,
+                accessTokenJWT,
+            );
+        } catch (e) {
+            log.error("Failed to verify password", e);
+            if (isHTTP401Error(e)) {
+                throw new Error(t("incorrect_password"));
+            }
+            throw e;
+        }
+
+        await publicAlbumsRemotePull();
+    };
+
+    if (loading && (!publicFiles || !credentials.current)) {
+        return (
+            <EmbedContainer>
+                <CenteredFill>
+                    <LoadingIndicator />
+                </CenteredFill>
+            </EmbedContainer>
+        );
+    } else if (errorMessage) {
+        return (
+            <EmbedContainer>
+                <Stack100vhCenter>
+                    <Typography sx={{ color: "critical.main" }}>
+                        {errorMessage}
+                    </Typography>
+                </Stack100vhCenter>
+            </EmbedContainer>
+        );
+    } else if (isPasswordProtected && !credentials.current?.accessTokenJWT) {
+        return (
+            <EmbedContainer>
+                <EmbedPasswordForm onSubmit={handleSubmitPassword} />
+            </EmbedContainer>
+        );
+    } else if (!publicFiles || !credentials.current) {
+        return (
+            <EmbedContainer>
+                <Stack100vhCenter>
+                    <Typography>{t("not_found")}</Typography>
+                </Stack100vhCenter>
+            </EmbedContainer>
+        );
+    }
+
+    return (
+        <EmbedContainer>
+            <EmbedFileListWithViewer
+                files={publicFiles}
+                onRemotePull={publicAlbumsRemotePull}
+            />
+        </EmbedContainer>
+    );
+}
+
+const sortFilesForCollection = (files: EnteFile[], collection?: Collection) =>
+    sortFiles(files, collection?.pubMagicMetadata?.data.asc ?? false);
+
+const EmbedContainer = styled("div")({
+    width: "100%",
+    height: "100vh",
+    overflow: "hidden",
+    display: "flex",
+    flexDirection: "column",
+});
diff --git a/web/apps/embed/tsconfig.json b/web/apps/embed/tsconfig.json
new file mode 100644
index 00000000000..6360403f00f
--- /dev/null
+++ b/web/apps/embed/tsconfig.json
@@ -0,0 +1,16 @@
+{
+    "extends": "ente-build-config/tsconfig-next.json",
+    "compilerOptions": {
+        /* Set the base directory from which to resolve bare module names. */
+        "baseUrl": "./src"
+    },
+    "include": [
+        "next-env.d.ts",
+        "**/*.ts",
+        "**/*.tsx",
+        "**/*.js",
+        "../../packages/base/components/utils/mui-theme.d.ts",
+        "../../packages/base/global-electron.d.ts"
+    ],
+    "exclude": ["node_modules", "out", ".next", ".next-desktop"]
+}
diff --git a/web/package.json b/web/package.json
index 54d327a93f9..c0605207b5f 100644
--- a/web/package.json
+++ b/web/package.json
@@ -11,6 +11,7 @@
         "build:accounts": "yarn workspace accounts next build",
         "build:auth": "yarn workspace auth next build",
         "build:cast": "yarn workspace cast next build",
+        "build:embed": "yarn workspace embed next build",
         "build:locker": "yarn workspace locker next build",
         "build:payments": "yarn workspace payments build",
         "build:photos": "yarn workspace photos next build",
@@ -19,6 +20,7 @@
         "dev:albums": "yarn workspace photos next dev -p 3002",
         "dev:auth": "yarn workspace auth next dev -p 3003",
         "dev:cast": "yarn workspace cast next dev -p 3004",
+        "dev:embed": "yarn workspace embed next dev -p 3006",
         "dev:locker": "yarn workspace locker next dev -p 3005",
         "dev:payments": "yarn workspace payments dev",
         "dev:photos": "yarn workspace photos next dev -p 3000",
