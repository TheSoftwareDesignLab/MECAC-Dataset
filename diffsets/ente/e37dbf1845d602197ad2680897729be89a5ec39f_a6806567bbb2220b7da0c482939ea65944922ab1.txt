diff --git a/web/apps/photos/src/components/TripLayout/TripMap.tsx b/web/apps/photos/src/components/TripLayout/TripMap.tsx
index 0defbf28288..1782b8a1d63 100644
--- a/web/apps/photos/src/components/TripLayout/TripMap.tsx
+++ b/web/apps/photos/src/components/TripLayout/TripMap.tsx
@@ -2,12 +2,7 @@ import { Box, styled, useMediaQuery, useTheme } from "@mui/material";
 import { useEffect, useState } from "react";
 
 import { MapEvents } from "./MapEvents";
-import {
-    createIcon,
-    createSuperClusterIcon,
-    detectScreenCollisions,
-    getMapCenter,
-} from "./mapHelpers";
+import { createIcon, getMapCenter } from "./mapHelpers";
 import type { JourneyPoint } from "./types";
 
 interface MapComponentsType {
@@ -21,20 +16,7 @@ interface TripMapProps {
     photoClusters: JourneyPoint[][];
     hasPhotoData: boolean;
     optimalZoom: number;
-    currentZoom: number;
-    targetZoom: number | null;
-    mapRef: import("leaflet").Map | null;
     scrollProgress: number;
-    superClusterInfo?: {
-        superClusters: {
-            lat: number;
-            lng: number;
-            clusterCount: number;
-            clustersInvolved: number[];
-            image: string;
-        }[];
-        clusterToSuperClusterMap: Map<number, number>;
-    };
     setMapRef: (map: import("leaflet").Map | null) => void;
     setCurrentZoom: (zoom: number) => void;
     setTargetZoom: (zoom: number | null) => void;
@@ -50,11 +32,7 @@ export const TripMap: React.FC<TripMapProps> = ({
     photoClusters,
     hasPhotoData,
     optimalZoom,
-    currentZoom,
-    targetZoom,
-    mapRef,
     scrollProgress,
-    superClusterInfo,
     setMapRef,
     setCurrentZoom,
     setTargetZoom,
@@ -97,15 +75,10 @@ export const TripMap: React.FC<TripMapProps> = ({
         }
     }
 
-    // Calculate super-clusters based on screen collisions
-    const { superClusters, visibleClustersWithIndices } =
-        detectScreenCollisions(
-            photoClusters,
-            currentZoom,
-            targetZoom,
-            mapRef,
-            optimalZoom,
-        );
+    // Super clusters disabled - show all clusters individually
+    const visibleClustersWithIndices = photoClusters.map(
+        (cluster, originalIndex) => ({ cluster, originalIndex }),
+    );
 
     // Return loading state if map components haven't loaded yet
     if (!mapComponents) {
@@ -118,11 +91,7 @@ export const TripMap: React.FC<TripMapProps> = ({
         <MapContainerWrapper hasPhotoData={hasPhotoData}>
             {hasPhotoData ? (
                 <MapContainer
-                    center={getMapCenter(
-                        photoClusters,
-                        journeyData,
-                        superClusterInfo,
-                    )}
+                    center={getMapCenter(photoClusters, journeyData)}
                     zoom={
                         isMobileOrTablet
                             ? Math.max(1, optimalZoom - 2)
@@ -151,60 +120,7 @@ export const TripMap: React.FC<TripMapProps> = ({
                         keepBuffer={isMobileOrTablet ? 3 : 1}
                     />
 
-                    {/* Draw super-clusters (clickable for zoom and gallery) */}
-                    {superClusters.map((superCluster, index) => {
-                        // Show green only for active locations
-                        const isActive = superCluster.clustersInvolved.includes(
-                            currentActiveLocationIndex,
-                        );
-
-                        const icon = createSuperClusterIcon(
-                            superCluster.image, // Use representative photo (first photo of first cluster)
-                            superCluster.clusterCount,
-                            isMobileOrTablet ? 40 : 55,
-                            isActive,
-                        );
-
-                        return icon ? (
-                            <Marker
-                                key={`super-cluster-${index}`}
-                                position={[superCluster.lat, superCluster.lng]}
-                                icon={icon}
-                                eventHandlers={{
-                                    click: () => {
-                                        const firstClusterIndex =
-                                            superCluster.clustersInvolved[0];
-                                        if (firstClusterIndex !== undefined) {
-                                            // Get the actual first cluster's coordinates
-                                            const firstCluster =
-                                                photoClusters[
-                                                    firstClusterIndex
-                                                ];
-                                            if (firstCluster) {
-                                                const avgLat =
-                                                    firstCluster.reduce(
-                                                        (sum, p) => sum + p.lat,
-                                                        0,
-                                                    ) / firstCluster.length;
-                                                const avgLng =
-                                                    firstCluster.reduce(
-                                                        (sum, p) => sum + p.lng,
-                                                        0,
-                                                    ) / firstCluster.length;
-                                                onMarkerClick(
-                                                    firstClusterIndex,
-                                                    avgLat,
-                                                    avgLng,
-                                                );
-                                            }
-                                        }
-                                    },
-                                }}
-                            />
-                        ) : null;
-                    })}
-
-                    {/* Draw visible regular clusters */}
+                    {/* Draw visible clusters */}
                     {visibleClustersWithIndices.map((item, index) => {
                         const { cluster, originalIndex } = item;
                         const firstPhoto = cluster[0];
@@ -235,6 +151,7 @@ export const TripMap: React.FC<TripMapProps> = ({
                                 key={`cluster-${index}`}
                                 position={[avgLat, avgLng]}
                                 icon={icon}
+                                zIndexOffset={isActive ? 1000 : 0}
                                 eventHandlers={{
                                     click: () => {
                                         // Calculate cluster center
diff --git a/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts b/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
index 7803c8d8afa..2b1cdff5b04 100644
--- a/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
+++ b/web/apps/photos/src/components/TripLayout/hooks/useScrollHandling.ts
@@ -23,21 +23,6 @@ export interface UseScrollHandlingParams {
     setHasUserScrolled: (scrolled: boolean) => void;
     setScrollProgress: (progress: number) => void;
     setTargetZoom: (zoom: number | null) => void;
-    previousSuperClusterStateRef: React.RefObject<{
-        isInSuperCluster: boolean;
-        superClusterIndex: number | null;
-    }>;
-    superClusterInfo: {
-        superClusters: {
-            lat: number;
-            lng: number;
-            clusterCount: number;
-            clustersInvolved: number[];
-            image: string;
-        }[];
-        clusterToSuperClusterMap: Map<number, number>;
-    };
-    scrollProgress: number;
     isMobileOrTablet: boolean;
 }
 
@@ -54,9 +39,6 @@ export const useScrollHandling = ({
     setHasUserScrolled,
     setScrollProgress,
     setTargetZoom,
-    previousSuperClusterStateRef,
-    superClusterInfo,
-    scrollProgress,
     isMobileOrTablet,
 }: UseScrollHandlingParams) => {
     // Update location positions callback
@@ -80,8 +62,6 @@ export const useScrollHandling = ({
             previousActiveLocationRef,
             isMobileOrTablet,
             setTargetZoom,
-            previousSuperClusterStateRef,
-            superClusterInfo,
         });
     }, [
         timelineRef,
@@ -94,8 +74,6 @@ export const useScrollHandling = ({
         previousActiveLocationRef,
         isMobileOrTablet,
         setTargetZoom,
-        previousSuperClusterStateRef,
-        superClusterInfo,
     ]);
 
     // Throttled scroll handler
@@ -133,10 +111,7 @@ export const useScrollHandling = ({
                 setHasUserScrolled,
                 scrollTimelineToLocation: scrollToLocation,
                 isMobileOrTablet,
-                superClusterInfo,
-                scrollProgress,
                 setTargetZoom,
-                previousSuperClusterStateRef,
                 previousActiveLocationRef,
             });
         },
@@ -149,10 +124,7 @@ export const useScrollHandling = ({
             setHasUserScrolled,
             scrollToLocation,
             isMobileOrTablet,
-            superClusterInfo,
-            scrollProgress,
             setTargetZoom,
-            previousSuperClusterStateRef,
             previousActiveLocationRef,
         ],
     );
diff --git a/web/apps/photos/src/components/TripLayout/index.tsx b/web/apps/photos/src/components/TripLayout/index.tsx
index 181aa66ecdb..bcd01f3ef6b 100644
--- a/web/apps/photos/src/components/TripLayout/index.tsx
+++ b/web/apps/photos/src/components/TripLayout/index.tsx
@@ -108,10 +108,6 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
     >(new Map()); // Track location data to prevent resets
     const filesCountRef = useRef<number>(0); // Track files count to detect real changes
     const previousActiveLocationRef = useRef<number>(-1); // Track previous active location for discrete panning
-    const previousSuperClusterStateRef = useRef<{
-        isInSuperCluster: boolean;
-        superClusterIndex: number | null;
-    }>({ isInSuperCluster: false, superClusterIndex: null }); // Track previous super cluster state for zoom logic
 
     const [photoClusters, setPhotoClusters] = useState<JourneyPoint[][]>([]);
     const [optimalZoom, setOptimalZoom] = useState(7);
@@ -166,11 +162,7 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
             // Load mapHelpers and calculate clusters if we have data
             if (journeyData.length > 0) {
                 void import("./mapHelpers").then(
-                    ({
-                        clusterPhotosByProximity,
-                        calculateOptimalZoom,
-                        detectScreenCollisions,
-                    }) => {
+                    ({ clusterPhotosByProximity, calculateOptimalZoom }) => {
                         const clusters = clusterPhotosByProximity(journeyData);
 
                         // Sort clusters by their earliest timestamp to maintain chronological order
@@ -190,47 +182,13 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
 
                         const optimalZoomLevel = calculateOptimalZoom();
 
-                        // Calculate super clusters at optimal zoom level once
-                        const { superClusters } = detectScreenCollisions(
-                            sortedClusters,
-                            optimalZoomLevel,
-                            null,
-                            null,
-                            optimalZoomLevel,
-                        );
-
-                        // Create a map of cluster index to super cluster index
-                        const clusterToSuperClusterMap = new Map<
-                            number,
-                            number
-                        >();
-                        superClusters.forEach(
-                            (superCluster, superClusterIndex) => {
-                                superCluster.clustersInvolved.forEach(
-                                    (clusterIndex) => {
-                                        clusterToSuperClusterMap.set(
-                                            clusterIndex,
-                                            superClusterIndex,
-                                        );
-                                    },
-                                );
-                            },
-                        );
-
                         setPhotoClusters(sortedClusters);
+                        setOptimalZoom(optimalZoomLevel);
 
-                        // Check if first location is in a super cluster and adjust initial zoom (desktop only)
-                        const firstLocationInSuperCluster =
-                            clusterToSuperClusterMap.has(0);
-                        const initialZoom =
-                            firstLocationInSuperCluster && !isMobileOrTablet
-                                ? 14 // Super cluster zoom level (desktop only)
-                                : optimalZoomLevel;
-
-                        setOptimalZoom(initialZoom);
+                        // Super clusters disabled for all devices
                         setSuperClusterInfo({
-                            superClusters,
-                            clusterToSuperClusterMap,
+                            superClusters: [],
+                            clusterToSuperClusterMap: new Map(),
                         });
                     },
                 );
@@ -316,9 +274,6 @@ export const TripLayout: React.FC<TripLayoutProps> = ({
         },
         setScrollProgress,
         setTargetZoom,
-        previousSuperClusterStateRef,
-        superClusterInfo,
-        scrollProgress,
     });
 
     // Only wait for client-side rendering (needed for maps), but show layout immediately
diff --git a/web/apps/photos/src/components/TripLayout/mapHelpers.ts b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
index 0c3b1e5b2ba..17cb6c39a0c 100644
--- a/web/apps/photos/src/components/TripLayout/mapHelpers.ts
+++ b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
@@ -510,16 +510,6 @@ export const detectScreenCollisions = (
 export const getMapCenter = (
     photoClusters: JourneyPoint[][],
     journeyData: JourneyPoint[],
-    superClusterInfo?: {
-        superClusters: {
-            lat: number;
-            lng: number;
-            clusterCount: number;
-            clustersInvolved: number[];
-            image: string;
-        }[];
-        clusterToSuperClusterMap: Map<number, number>;
-    },
 ): [number, number] => {
     // If no clusters yet, check journey data
     if (photoClusters.length === 0) {
@@ -537,21 +527,6 @@ export const getMapCenter = (
     const firstLng =
         firstCluster.reduce((sum, p) => sum + p.lng, 0) / firstCluster.length;
 
-    // Check if first location is in a super cluster - apply positioning for super cluster zoom level
-    const firstLocationInSuperCluster =
-        superClusterInfo?.clusterToSuperClusterMap.has(0);
-    if (firstLocationInSuperCluster) {
-        // For super cluster first location, apply positioning calculated for super cluster zoom level
-        const isMobile = isMobileDevice();
-        const superClusterZoom = isMobile ? 15 : 14;
-        const [positionedLat, positionedLng] = getLocationPositionAtZoom(
-            firstLat,
-            firstLng,
-            superClusterZoom,
-        );
-        return [positionedLat, positionedLng];
-    }
-
     // Position first location at 20% from right edge (80% from left)
     // At zoom level 10, each pixel represents approximately 152.87 meters
     // On mobile, timeline is at bottom so full width is available; on desktop, timeline takes up 50% of screen width
diff --git a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
index 5da3e7cbf4e..2f31dff511e 100644
--- a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
+++ b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
@@ -1,10 +1,6 @@
 import { startTransition } from "react";
 
-import {
-    calculateDistance,
-    getLocationPosition,
-    getLocationPositionAtZoom,
-} from "../mapHelpers";
+import { calculateDistance, getLocationPosition } from "../mapHelpers";
 import type { JourneyPoint } from "../types";
 
 export interface PositionInfo {
@@ -47,20 +43,6 @@ export interface HandleTimelineScrollParams {
     previousActiveLocationRef: React.RefObject<number>;
     isMobileOrTablet: boolean;
     setTargetZoom: (zoom: number | null) => void;
-    previousSuperClusterStateRef: React.RefObject<{
-        isInSuperCluster: boolean;
-        superClusterIndex: number | null;
-    }>;
-    superClusterInfo: {
-        superClusters: {
-            lat: number;
-            lng: number;
-            clusterCount: number;
-            clustersInvolved: number[];
-            image: string;
-        }[];
-        clusterToSuperClusterMap: Map<number, number>;
-    };
 }
 
 export const handleTimelineScroll = ({
@@ -74,8 +56,6 @@ export const handleTimelineScroll = ({
     previousActiveLocationRef,
     isMobileOrTablet,
     setTargetZoom,
-    previousSuperClusterStateRef,
-    superClusterInfo,
 }: HandleTimelineScrollParams) => {
     if (
         !timelineRef.current ||
@@ -159,7 +139,6 @@ export const handleTimelineScroll = ({
 
         // Check if this is a distant location (>500km from previous)
         let isDistantLocation = false;
-        const isFirstLocationEver = previousActiveLocationIndex === -1;
         if (
             previousActiveLocationIndex !== -1 &&
             previousActiveLocationIndex !== currentActiveLocationIndex
@@ -178,249 +157,9 @@ export const handleTimelineScroll = ({
 
         const targetZoom = isMobileOrTablet ? 8 : 10; // Touch device-aware zoom level
 
-        // Get super cluster info for both source and destination
-        // On mobile, disable super cluster zoom behavior
-        const currentSuperClusterIndex = !isMobileOrTablet
-            ? (superClusterInfo.clusterToSuperClusterMap.get(
-                  currentActiveLocationIndex,
-              ) ?? -1)
-            : -1;
-        const isInSuperCluster = currentSuperClusterIndex !== -1;
-
-        // Get the super cluster index of where we're coming FROM (not the stored state)
-        // On mobile, disable super cluster zoom behavior
-        const fromSuperClusterIndex =
-            previousActiveLocationIndex >= 0 && !isMobileOrTablet
-                ? (superClusterInfo.clusterToSuperClusterMap.get(
-                      previousActiveLocationIndex,
-                  ) ?? -1)
-                : -1;
-
-        // Check if we're moving between clusters in the SAME super cluster
-        const isSameSuperCluster =
-            isInSuperCluster &&
-            fromSuperClusterIndex !== -1 &&
-            currentSuperClusterIndex === fromSuperClusterIndex;
-
-        // Check previous super cluster state (for other transition logic)
-        const previousState = previousSuperClusterStateRef.current;
-        const wasInSuperCluster = previousState.isInSuperCluster;
-        const previousSuperClusterIndex = previousState.superClusterIndex;
-
         try {
-            // Handle super cluster zoom logic - check distant locations first!
-            if (isInSuperCluster && !wasInSuperCluster && isFirstLocationEver) {
-                // First location ever and it's in a super cluster - directly zoom to super cluster level
-                const superClusterZoom = isMobileOrTablet ? 15 : 14; // Higher zoom on mobile to break apart clusters
-                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
-                    targetCluster.lat,
-                    targetCluster.lng,
-                    superClusterZoom,
-                );
-                setTargetZoom(superClusterZoom);
-                mapRef.setView([zoomAwareLat, zoomAwareLng], superClusterZoom);
-            } else if (
-                isInSuperCluster &&
-                !wasInSuperCluster &&
-                isDistantLocation
-            ) {
-                // Entering super cluster from distant location - full zoom out → pan → zoom in
-                const superClusterZoom = isMobileOrTablet ? 15 : 14; // Higher zoom on mobile to break apart clusters
-                const intermediateZoom = isMobileOrTablet ? 2 : 4; // Extreme zoom out for distant locations
-                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
-                    targetCluster.lat,
-                    targetCluster.lng,
-                    superClusterZoom,
-                );
-
-                // Use event listener for smoother animation chaining with pause
-                const onZoomEnd = () => {
-                    mapRef.off("zoomend", onZoomEnd);
-                    // Small pause to let user see the zoomed out view
-                    setTimeout(() => {
-                        setTargetZoom(superClusterZoom);
-                        mapRef.flyTo(
-                            [zoomAwareLat, zoomAwareLng],
-                            superClusterZoom,
-                            {
-                                animate: true,
-                                duration: 1.2,
-                                easeLinearity: 0.2,
-                            },
-                        );
-                    }, 150);
-                };
-
-                mapRef.once("zoomend", onZoomEnd);
-                setTargetZoom(intermediateZoom);
-                mapRef.flyTo([zoomAwareLat, zoomAwareLng], intermediateZoom, {
-                    animate: true,
-                    duration: 1.2,
-                    easeLinearity: 0.2,
-                });
-            } else if (isInSuperCluster && !wasInSuperCluster) {
-                // Entering super cluster from nearby location - direct zoom in
-                const superClusterZoom = isMobileOrTablet ? 15 : 14; // Higher zoom on mobile to break apart clusters
-                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
-                    targetCluster.lat,
-                    targetCluster.lng,
-                    superClusterZoom,
-                );
-                setTargetZoom(superClusterZoom);
-                mapRef.flyTo([zoomAwareLat, zoomAwareLng], superClusterZoom, {
-                    animate: true,
-                    duration: 1.2,
-                    easeLinearity: 0.3,
-                });
-            } else if (!isInSuperCluster && wasInSuperCluster) {
-                // Leaving super cluster - check if distant location
-                if (isDistantLocation) {
-                    // Distant location: full zoom out → pan → zoom in
-                    const intermediateZoom = isMobileOrTablet ? 2 : 4;
-
-                    // Use event listener for smoother animation chaining with pause
-                    const onZoomEnd = () => {
-                        mapRef.off("zoomend", onZoomEnd);
-                        // Small pause to let user see the zoomed out view
-                        setTimeout(() => {
-                            setTargetZoom(targetZoom);
-                            mapRef.flyTo(
-                                [positionedLat, positionedLng],
-                                targetZoom,
-                                {
-                                    animate: true,
-                                    duration: 1.2,
-                                    easeLinearity: 0.2,
-                                },
-                            );
-                        }, 150);
-                    };
-
-                    mapRef.once("zoomend", onZoomEnd);
-                    setTargetZoom(intermediateZoom);
-                    mapRef.flyTo(
-                        [positionedLat, positionedLng],
-                        intermediateZoom,
-                        { animate: true, duration: 1.2, easeLinearity: 0.2 },
-                    );
-                } else {
-                    // Nearby location: direct zoom out to normal view
-                    setTargetZoom(targetZoom);
-                    mapRef.flyTo([positionedLat, positionedLng], targetZoom, {
-                        animate: true,
-                        duration: 1.2,
-                        easeLinearity: 0.3,
-                    });
-                }
-            } else if (isSameSuperCluster) {
-                // Moving within same super cluster - pan to zoom-aware positioned location, keep zoom
-                const currentMapZoom = mapRef.getZoom();
-                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
-                    targetCluster.lat,
-                    targetCluster.lng,
-                    currentMapZoom,
-                );
-                mapRef.panTo([zoomAwareLat, zoomAwareLng], {
-                    animate: true,
-                    duration: 0.6,
-                    easeLinearity: 0.3,
-                });
-            } else if (isInSuperCluster) {
-                // In super cluster but different from previous - treat as distant location
-                // Check if we're switching between different super clusters
-                const isDifferentSuperCluster =
-                    wasInSuperCluster &&
-                    currentSuperClusterIndex !== previousSuperClusterIndex;
-
-                if (isDistantLocation) {
-                    // Distant location from super cluster: full zoom out → pan → zoom in
-                    // Since we're in the isInSuperCluster block, destination is always a super cluster
-                    const finalZoom = isMobileOrTablet ? 15 : 14; // Higher zoom on mobile to break apart clusters
-                    const intermediateZoom = isMobileOrTablet ? 2 : 4; // Extreme zoom out for distant locations
-                    const [zoomAwareLat, zoomAwareLng] =
-                        getLocationPositionAtZoom(
-                            targetCluster.lat,
-                            targetCluster.lng,
-                            finalZoom,
-                        );
-
-                    // Use event listener for smoother animation chaining with pause
-                    const onZoomEnd = () => {
-                        mapRef.off("zoomend", onZoomEnd);
-                        // Small pause to let user see the zoomed out view
-                        setTimeout(() => {
-                            setTargetZoom(finalZoom);
-                            mapRef.flyTo(
-                                [zoomAwareLat, zoomAwareLng],
-                                finalZoom,
-                                {
-                                    animate: true,
-                                    duration: 1.2,
-                                    easeLinearity: 0.2,
-                                },
-                            );
-                        }, 150);
-                    };
-
-                    mapRef.once("zoomend", onZoomEnd);
-                    setTargetZoom(intermediateZoom);
-                    mapRef.flyTo(
-                        [zoomAwareLat, zoomAwareLng],
-                        intermediateZoom,
-                        { animate: true, duration: 1.2, easeLinearity: 0.2 },
-                    );
-                } else if (isDifferentSuperCluster) {
-                    // Different super cluster (not distant): moderate zoom out → pan → zoom in
-                    const superClusterZoom = isMobileOrTablet ? 15 : 14; // Higher zoom on mobile to break apart clusters
-                    const intermediateZoom = isMobileOrTablet ? 8 : 10; // Moderate zoom out for nearby super clusters
-                    const [zoomAwareLat, zoomAwareLng] =
-                        getLocationPositionAtZoom(
-                            targetCluster.lat,
-                            targetCluster.lng,
-                            superClusterZoom,
-                        );
-
-                    // Use event listener for smoother animation chaining with pause
-                    const onZoomEnd = () => {
-                        mapRef.off("zoomend", onZoomEnd);
-                        // Small pause to let user see the zoomed out view
-                        setTimeout(() => {
-                            setTargetZoom(superClusterZoom);
-                            mapRef.flyTo(
-                                [zoomAwareLat, zoomAwareLng],
-                                superClusterZoom,
-                                {
-                                    animate: true,
-                                    duration: 0.8,
-                                    easeLinearity: 0.2,
-                                },
-                            );
-                        }, 100);
-                    };
-
-                    mapRef.once("zoomend", onZoomEnd);
-                    setTargetZoom(intermediateZoom);
-                    mapRef.flyTo(
-                        [zoomAwareLat, zoomAwareLng],
-                        intermediateZoom,
-                        { animate: true, duration: 0.8, easeLinearity: 0.2 },
-                    );
-                } else {
-                    // Same super cluster, different location - just pan with zoom-aware positioning
-                    const currentMapZoom = mapRef.getZoom();
-                    const [zoomAwareLat, zoomAwareLng] =
-                        getLocationPositionAtZoom(
-                            targetCluster.lat,
-                            targetCluster.lng,
-                            currentMapZoom,
-                        );
-                    mapRef.panTo([zoomAwareLat, zoomAwareLng], {
-                        animate: true,
-                        duration: 0.6,
-                        easeLinearity: 0.3,
-                    });
-                }
-            } else if (isDistantLocation) {
+            // Super cluster logic disabled - simple zoom transitions
+            if (isDistantLocation) {
                 // For distant locations not in super cluster: zoom out → pan → zoom in
                 const intermediateZoom = isMobileOrTablet ? 2 : 4;
 
@@ -466,12 +205,6 @@ export const handleTimelineScroll = ({
                     });
                 }
             }
-
-            // Update super cluster state
-            previousSuperClusterStateRef.current = {
-                isInSuperCluster,
-                superClusterIndex: currentSuperClusterIndex,
-            };
         } catch (error) {
             console.warn("Map operation failed:", error);
         }
@@ -541,22 +274,7 @@ export interface HandleMarkerClickParams {
     setHasUserScrolled: (scrolled: boolean) => void;
     scrollTimelineToLocation: (locationIndex: number) => void;
     isMobileOrTablet: boolean;
-    superClusterInfo?: {
-        superClusters: {
-            lat: number;
-            lng: number;
-            clusterCount: number;
-            clustersInvolved: number[];
-            image: string;
-        }[];
-        clusterToSuperClusterMap: Map<number, number>;
-    };
-    scrollProgress: number;
     setTargetZoom: (zoom: number | null) => void;
-    previousSuperClusterStateRef: React.RefObject<{
-        isInSuperCluster: boolean;
-        superClusterIndex: number | null;
-    }>;
     previousActiveLocationRef: React.RefObject<number>;
 }
 
@@ -572,10 +290,7 @@ export const handleMarkerClick = ({
     setHasUserScrolled,
     scrollTimelineToLocation,
     isMobileOrTablet,
-    superClusterInfo,
-    scrollProgress,
     setTargetZoom,
-    previousSuperClusterStateRef,
     previousActiveLocationRef,
 }: HandleMarkerClickParams) => {
     const targetProgress = clusterIndex / Math.max(1, photoClusters.length - 1);
@@ -591,137 +306,29 @@ export const handleMarkerClick = ({
     // Update the previous active location to the target cluster
     previousActiveLocationRef.current = clusterIndex;
 
-    // Calculate current active location index
-    let currentActiveLocationIndex = -1;
-    if (photoClusters.length > 0) {
-        if (isMobileOrTablet) {
-            currentActiveLocationIndex = Math.floor(
-                scrollProgress * (photoClusters.length - 0.5),
-            );
-        } else {
-            currentActiveLocationIndex = Math.round(
-                scrollProgress * Math.max(0, photoClusters.length - 1),
-            );
-        }
-    }
-
-    // Check if both current and target locations are in the same super cluster
-    // On mobile, disable super cluster zoom behavior
-    let shouldJustPan = false;
-    if (
-        superClusterInfo &&
-        currentActiveLocationIndex >= 0 &&
-        !isMobileOrTablet
-    ) {
-        const currentSuperClusterIndex =
-            superClusterInfo.clusterToSuperClusterMap.get(
-                currentActiveLocationIndex,
-            );
-        const targetSuperClusterIndex =
-            superClusterInfo.clusterToSuperClusterMap.get(clusterIndex);
-
-        // If both locations are in super clusters and they're the same super cluster
-        shouldJustPan =
-            currentSuperClusterIndex !== undefined &&
-            targetSuperClusterIndex !== undefined &&
-            currentSuperClusterIndex === targetSuperClusterIndex;
-    }
-
     if (mapRef?.getContainer()) {
         try {
-            if (shouldJustPan) {
-                // Just pan to the location with zoom-aware positioning, keeping current zoom
-                const currentMapZoom = mapRef.getZoom();
-                const [zoomAwareLat, zoomAwareLng] = getLocationPositionAtZoom(
-                    clusterLat,
-                    clusterLng,
-                    currentMapZoom,
-                );
-                mapRef.panTo([zoomAwareLat, zoomAwareLng], {
-                    animate: true,
-                    duration: 0.6,
-                    easeLinearity: 0.3,
-                });
+            // Super cluster logic disabled - simple fly to target with standard zoom
+            const [positionedLat, positionedLng] = getLocationPosition(
+                clusterLat,
+                clusterLng,
+            );
+            const targetZoomLevel = isMobileOrTablet ? 8 : 10;
+            // Set target zoom before animation
+            setTargetZoom(targetZoomLevel);
+
+            // Clear target zoom after animation completes
+            const onMoveEnd = () => {
+                mapRef.off("moveend", onMoveEnd);
+                setTargetZoom(null);
+            };
+            mapRef.once("moveend", onMoveEnd);
 
-                // Update state to maintain super cluster info
-                const targetSuperClusterIndex =
-                    superClusterInfo?.clusterToSuperClusterMap.get(
-                        clusterIndex,
-                    );
-                previousSuperClusterStateRef.current = {
-                    isInSuperCluster: true,
-                    superClusterIndex: targetSuperClusterIndex ?? null,
-                };
-            } else {
-                // Check if the target cluster is part of a super cluster
-                // On mobile, disable super cluster zoom behavior
-                const targetSuperClusterIndex = !isMobileOrTablet
-                    ? superClusterInfo?.clusterToSuperClusterMap.get(
-                          clusterIndex,
-                      )
-                    : undefined;
-                const isInSuperCluster = targetSuperClusterIndex !== undefined;
-
-                if (isInSuperCluster) {
-                    // Zoom to super cluster level to break it apart
-                    const superClusterZoom = isMobileOrTablet ? 15 : 14;
-                    const [zoomAwareLat, zoomAwareLng] =
-                        getLocationPositionAtZoom(
-                            clusterLat,
-                            clusterLng,
-                            superClusterZoom,
-                        );
-                    // Set target zoom before animation so clusters separate during zoom
-                    setTargetZoom(superClusterZoom);
-
-                    // Clear target zoom after animation completes
-                    const onMoveEnd = () => {
-                        mapRef.off("moveend", onMoveEnd);
-                        setTargetZoom(null);
-                    };
-                    mapRef.once("moveend", onMoveEnd);
-
-                    mapRef.flyTo(
-                        [zoomAwareLat, zoomAwareLng],
-                        superClusterZoom,
-                        { animate: true, duration: 1.0, easeLinearity: 0.3 },
-                    );
-
-                    // Update super cluster state for proper scroll behavior
-                    previousSuperClusterStateRef.current = {
-                        isInSuperCluster: true,
-                        superClusterIndex: targetSuperClusterIndex,
-                    };
-                } else {
-                    // Normal behavior: fly to with standard zoom
-                    const [positionedLat, positionedLng] = getLocationPosition(
-                        clusterLat,
-                        clusterLng,
-                    );
-                    const targetZoomLevel = isMobileOrTablet ? 8 : 10;
-                    // Set target zoom before animation
-                    setTargetZoom(targetZoomLevel);
-
-                    // Clear target zoom after animation completes
-                    const onMoveEnd = () => {
-                        mapRef.off("moveend", onMoveEnd);
-                        setTargetZoom(null);
-                    };
-                    mapRef.once("moveend", onMoveEnd);
-
-                    mapRef.flyTo(
-                        [positionedLat, positionedLng],
-                        targetZoomLevel,
-                        { animate: true, duration: 1.0, easeLinearity: 0.3 },
-                    );
-
-                    // Update super cluster state
-                    previousSuperClusterStateRef.current = {
-                        isInSuperCluster: false,
-                        superClusterIndex: null,
-                    };
-                }
-            }
+            mapRef.flyTo([positionedLat, positionedLng], targetZoomLevel, {
+                animate: true,
+                duration: 1.0,
+                easeLinearity: 0.3,
+            });
         } catch (error) {
             console.warn("Map operation failed:", error);
         }
