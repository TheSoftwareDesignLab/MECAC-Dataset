diff --git a/src/components/pages/sharedAlbum/CollectionInfo.tsx b/src/components/pages/sharedAlbum/CollectionInfo.tsx
new file mode 100644
index 00000000000..86fb3d630a0
--- /dev/null
+++ b/src/components/pages/sharedAlbum/CollectionInfo.tsx
@@ -0,0 +1,20 @@
+import React from 'react';
+import styled from 'styled-components';
+import { Collection } from 'types/collection';
+
+interface Iprops {
+    collection: Collection;
+}
+
+const Info = styled.h4`
+    padding: 5px 24px;
+    margin: 20px;
+    border-bottom: 2px solid #5a5858;
+`;
+
+export function CollectionInfo(props: Iprops) {
+    if (!props.collection) {
+        return <></>;
+    }
+    return <Info>{props.collection.name}</Info>;
+}
diff --git a/src/components/pages/sharedAlbum/OpenInEnte.tsx b/src/components/pages/sharedAlbum/OpenInEnte.tsx
new file mode 100644
index 00000000000..b1aae474606
--- /dev/null
+++ b/src/components/pages/sharedAlbum/OpenInEnte.tsx
@@ -0,0 +1,26 @@
+import React from 'react';
+import { Button } from 'react-bootstrap';
+import styled from 'styled-components';
+
+const Wrapper = styled.div`
+    position: fixed;
+    display: flex;
+    align-items: center;
+    justify-content: center;
+    top: 0;
+    z-index: 100;
+    min-height: 64px;
+    right: 32px;
+    transition: opacity 1s ease;
+    cursor: pointer;
+`;
+
+function OpenInEnte({ redirect }) {
+    return (
+        <Wrapper onClick={redirect}>
+            <Button variant="outline-success">Open in ente</Button>
+        </Wrapper>
+    );
+}
+
+export default OpenInEnte;
diff --git a/src/components/sharedAlbum/OpenInEnte.tsx b/src/components/sharedAlbum/OpenInEnte.tsx
deleted file mode 100644
index e19d6b683b3..00000000000
--- a/src/components/sharedAlbum/OpenInEnte.tsx
+++ /dev/null
@@ -1,4 +0,0 @@
-import React from 'react';
-export function OpenInEnte() {
-    return <></>;
-}
diff --git a/src/pages/shared-album/index.tsx b/src/pages/shared-album/index.tsx
index d7d53c2de9d..8951de8a462 100644
--- a/src/pages/shared-album/index.tsx
+++ b/src/pages/shared-album/index.tsx
@@ -1,9 +1,25 @@
 import { ALL_SECTION } from 'constants/collection';
 import PhotoFrame from 'components/PhotoFrame';
-import React, { createContext, useEffect, useState } from 'react';
-import { getSharedCollectionFiles } from 'services/sharedCollectionService';
-import { SharedAlbumContextType } from 'types/sharedAlbum';
-import { OpenInEnte } from 'components/sharedAlbum/OpenInEnte';
+import React, {
+    createContext,
+    useContext,
+    useEffect,
+    useRef,
+    useState,
+} from 'react';
+import { SharedAlbumContextType } from 'types/publicCollection';
+import {
+    getLocalPublicCollection,
+    getLocalPublicFiles,
+    getPublicCollection,
+    syncPublicFiles,
+} from 'services/publicCollectionService';
+import { Collection } from 'types/collection';
+import { EnteFile } from 'types/file';
+import { mergeMetadata, sortFiles } from 'utils/file';
+import { AppContext } from 'pages/_app';
+import OpenInEnte from 'components/pages/sharedAlbum/OpenInEnte';
+import { CollectionInfo } from 'components/pages/sharedAlbum/CollectionInfo';
 
 export const defaultSharedAlbumContext: SharedAlbumContextType = {
     token: null,
@@ -14,44 +30,69 @@ export const SharedAlbumContext = createContext<SharedAlbumContextType>(
     defaultSharedAlbumContext
 );
 
-export default function sharedAlbum() {
-    const [token, setToken] = useState<string>(null);
-    const [collectionKey, setCollectionKey] = useState(null);
-    const [files, setFiles] = useState([]);
-    //  todo add shared-collection info access using access token api
-    // const [collections, setCollections] = useState<Collection[]>([]);
+export default function PublicCollectionGallery() {
+    const token = useRef<string>(null);
+    const collectionKey = useRef<string>(null);
+    const [publicFiles, setPublicFiles] = useState<EnteFile[]>(null);
+    const [publicCollection, setPublicCollection] = useState<Collection>(null);
+    const appContext = useContext(AppContext);
 
     useEffect(() => {
-        const urlParams = new URLSearchParams(window.location.search);
-        const token = urlParams.get('accessToken');
-        const collectionKey = decodeURIComponent(
-            urlParams.get('collectionKey')
-        );
-        setToken(token);
-        setCollectionKey(collectionKey);
-        syncWithRemote(token, collectionKey);
+        const main = async () => {
+            const urlParams = new URLSearchParams(window.location.search);
+            const eToken = urlParams.get('accessToken');
+            const eCollectionKey = decodeURIComponent(
+                urlParams.get('collectionKey')
+            );
+            token.current = eToken;
+            collectionKey.current = eCollectionKey;
+            const localCollection = await getLocalPublicCollection(
+                eCollectionKey
+            );
+            if (localCollection) {
+                setPublicCollection(localCollection);
+                const localPublicFiles = sortFiles(
+                    mergeMetadata(
+                        await getLocalPublicFiles(`${localCollection.id}`)
+                    )
+                );
+                setPublicFiles(localPublicFiles);
+                syncWithRemote(localCollection);
+            } else {
+                syncWithRemote();
+            }
+            appContext.showNavBar(true);
+        };
+        main();
     }, []);
 
-    const syncWithRemote = async (t?: string, c?: string) => {
-        const files = await getSharedCollectionFiles(
-            t ?? token,
-            c ?? collectionKey,
-            setFiles
-        );
-        setFiles(files);
+    const syncWithRemote = async (collection?: Collection) => {
+        if (!collection) {
+            collection = await getPublicCollection(
+                token.current,
+                collectionKey.current
+            );
+        }
+        await syncPublicFiles(token.current, collection, setPublicFiles);
     };
 
+    if (!publicFiles) {
+        return <div />;
+    }
     return (
         <SharedAlbumContext.Provider
             value={{
                 ...defaultSharedAlbumContext,
-                token,
+                token: token.current,
                 accessedThroughSharedURL: true,
             }}>
-            <OpenInEnte />
+            <OpenInEnte redirect={() => null} />
+
+            <CollectionInfo collection={publicCollection} />
+
             <PhotoFrame
-                files={files}
-                setFiles={setFiles}
+                files={publicFiles}
+                setFiles={setPublicFiles}
                 syncWithRemote={syncWithRemote}
                 favItemIds={null}
                 setSelected={() => null}
diff --git a/src/services/publicCollectionService.ts b/src/services/publicCollectionService.ts
new file mode 100644
index 00000000000..01293cf2fed
--- /dev/null
+++ b/src/services/publicCollectionService.ts
@@ -0,0 +1,241 @@
+import { getEndpoint } from 'utils/common/apiUtil';
+import localForage from 'utils/storage/localForage';
+import { Collection } from 'types/collection';
+import HTTPService from './HTTPService';
+import { logError } from 'utils/sentry';
+import { decryptFile, mergeMetadata, sortFiles } from 'utils/file';
+import { EnteFile } from 'types/file';
+import { LocalSavedPublicCollectionFiles } from 'types/publicCollection';
+import CryptoWorker from 'utils/crypto';
+
+const ENDPOINT = getEndpoint();
+const PUBLIC_COLLECTION_FILES_TABLE = 'public-collection-files';
+const PUBLIC_COLLECTIONS_TABLE = 'public-collections';
+
+const getCollectionUID = (collection: Collection) => `${collection.id}`;
+
+export const getLocalPublicFiles = async (collectionUID: string) => {
+    const localSavedPublicCollectionFiles = (
+        (await localForage.getItem<LocalSavedPublicCollectionFiles[]>(
+            PUBLIC_COLLECTION_FILES_TABLE
+        )) ?? []
+    ).find(
+        (localSavedPublicCollectionFiles) =>
+            localSavedPublicCollectionFiles.collectionUID === collectionUID
+    ) || { collectionKey: null, files: [] as EnteFile[] };
+    return localSavedPublicCollectionFiles.files;
+};
+export const savePublicCollectionFiles = async (
+    collectionUID: string,
+    files: EnteFile[]
+) => {
+    const publicCollectionFiles =
+        (await localForage.getItem<LocalSavedPublicCollectionFiles[]>(
+            PUBLIC_COLLECTION_FILES_TABLE
+        )) ?? [];
+    await localForage.setItem(PUBLIC_COLLECTION_FILES_TABLE, [
+        ...publicCollectionFiles,
+        { collectionUID, files },
+    ]);
+};
+
+export const getLocalPublicCollection = async (collectionKey: string) => {
+    const publicCollection =
+        (
+            (await localForage.getItem<Collection[]>(
+                PUBLIC_COLLECTIONS_TABLE
+            )) ?? []
+        ).find(
+            (localSavedPublicCollection) =>
+                localSavedPublicCollection.key === collectionKey
+        ) || null;
+    return publicCollection;
+};
+
+export const savePublicCollection = async (collection: Collection) => {
+    const publicCollections =
+        (await localForage.getItem<Collection[]>(PUBLIC_COLLECTIONS_TABLE)) ??
+        [];
+    await localForage.setItem(PUBLIC_COLLECTIONS_TABLE, [
+        ...publicCollections,
+        collection,
+    ]);
+};
+
+const getPublicCollectionLastSyncTime = async (collectionUID: string) =>
+    (await localForage.getItem<number>(`${collectionUID}-time`)) ?? 0;
+
+const setPublicCollectionLastSyncTime = async (
+    collectionUID: string,
+    time: number
+) => await localForage.setItem(collectionUID, time);
+
+export const syncPublicFiles = async (
+    token: string,
+    collection: Collection,
+    setPublicFiles: (files: EnteFile[]) => void
+) => {
+    try {
+        let files: EnteFile[] = [];
+        const localFiles = await getLocalPublicFiles(
+            getCollectionUID(collection)
+        );
+        files.push(...localFiles);
+        try {
+            if (!token) {
+                return files;
+            }
+            const lastSyncTime = await getPublicCollectionLastSyncTime(
+                getCollectionUID(collection)
+            );
+            if (collection.updationTime === lastSyncTime) {
+                return files;
+            }
+            const fetchedFiles = await getPublicFiles(
+                token,
+                collection,
+                lastSyncTime,
+                files,
+                setPublicFiles
+            );
+
+            files.push(...fetchedFiles);
+            const latestVersionFiles = new Map<string, EnteFile>();
+            files.forEach((file) => {
+                const uid = `${file.collectionID}-${file.id}`;
+                if (
+                    !latestVersionFiles.has(uid) ||
+                    latestVersionFiles.get(uid).updationTime < file.updationTime
+                ) {
+                    latestVersionFiles.set(uid, file);
+                }
+            });
+            files = [];
+            // eslint-disable-next-line @typescript-eslint/no-unused-vars
+            for (const [_, file] of latestVersionFiles) {
+                if (file.isDeleted) {
+                    continue;
+                }
+                files.push(file);
+            }
+            await savePublicCollectionFiles(
+                getCollectionUID(collection),
+                files
+            );
+            await setPublicCollectionLastSyncTime(
+                getCollectionUID(collection),
+                collection.updationTime
+            );
+            setPublicFiles([...sortFiles(mergeMetadata(files))]);
+        } catch (e) {
+            logError(e, 'failed to sync shared collection files');
+        }
+        return [...sortFiles(mergeMetadata(files))];
+    } catch (e) {
+        logError(e, 'failed to get local  or sync shared collection files');
+        return [];
+    }
+};
+
+const getPublicFiles = async (
+    token: string,
+    collection: Collection,
+    sinceTime: number,
+    files: EnteFile[],
+    setPublicFiles: (files: EnteFile[]) => void
+): Promise<EnteFile[]> => {
+    try {
+        const decryptedFiles: EnteFile[] = [];
+        let time = sinceTime;
+        let resp;
+        do {
+            if (!token) {
+                break;
+            }
+            resp = await HTTPService.get(
+                `${ENDPOINT}/public-collection/diff`,
+                {
+                    sinceTime: time,
+                },
+                {
+                    'X-Auth-Access-Token': token,
+                }
+            );
+            decryptedFiles.push(
+                ...(await Promise.all(
+                    resp.data.diff.map(async (file: EnteFile) => {
+                        if (!file.isDeleted) {
+                            file = await decryptFile(file, collection.key);
+                        }
+                        return file;
+                    }) as Promise<EnteFile>[]
+                ))
+            );
+
+            if (resp.data.diff.length) {
+                time = resp.data.diff.slice(-1)[0].updationTime;
+            }
+            setPublicFiles(
+                sortFiles(
+                    mergeMetadata(
+                        [...(files || []), ...decryptedFiles].filter(
+                            (item) => !item.isDeleted
+                        )
+                    )
+                )
+            );
+        } while (resp.data.hasMore);
+        return decryptedFiles;
+    } catch (e) {
+        logError(e, 'Get public  files failed');
+        throw e;
+    }
+};
+
+export const getPublicCollection = async (
+    token: string,
+    collectionKey: string
+): Promise<Collection> => {
+    try {
+        if (!token) {
+            return;
+        }
+        const resp = await HTTPService.get(
+            `${ENDPOINT}/public-collection/info`,
+            null,
+            { 'X-Auth-Access-Token': token }
+        );
+        const fetchedCollection = resp.data?.collection;
+        const collectionName = await decryptCollectionName(
+            fetchedCollection,
+            collectionKey
+        );
+        const collection = {
+            ...fetchedCollection,
+            name: collectionName,
+            key: collectionKey,
+        };
+        await savePublicCollection(collection);
+        return collection;
+    } catch (e) {
+        logError(e, 'failed to get public collection', {
+            collectionKey,
+            token,
+        });
+    }
+};
+
+const decryptCollectionName = async (
+    collection: Collection,
+    collectionKey: string
+) => {
+    const worker = await new CryptoWorker();
+
+    return (collection.name =
+        collection.name ||
+        (await worker.decryptToUTF8(
+            collection.encryptedName,
+            collection.nameDecryptionNonce,
+            collectionKey
+        )));
+};
diff --git a/src/services/sharedCollectionService.ts b/src/services/sharedCollectionService.ts
deleted file mode 100644
index 9131a197c10..00000000000
--- a/src/services/sharedCollectionService.ts
+++ /dev/null
@@ -1,59 +0,0 @@
-import { EnteFile } from 'types/file';
-import { getEndpoint } from 'utils/common/apiUtil';
-import { decryptFile, sortFiles, mergeMetadata } from 'utils/file';
-import { logError } from 'utils/sentry';
-import HTTPService from './HTTPService';
-
-const ENDPOINT = getEndpoint();
-
-export const getSharedCollectionFiles = async (
-    token: string,
-    collectionKey: string,
-    setFiles: (files: EnteFile[]) => void
-) => {
-    try {
-        if (!token || !collectionKey) {
-            throw Error('token or collectionKey missing');
-        }
-        const decryptedFiles: EnteFile[] = [];
-        let time = 0;
-        let resp;
-        do {
-            resp = await HTTPService.get(
-                `${ENDPOINT}/public-collection/diff`,
-                {
-                    sinceTime: time,
-                },
-                {
-                    'X-Auth-Access-Token': token,
-                }
-            );
-
-            decryptedFiles.push(
-                ...(await Promise.all(
-                    resp.data.diff.map(async (file: EnteFile) => {
-                        if (!file.isDeleted) {
-                            file = await decryptFile(file, collectionKey);
-                        }
-                        return file;
-                    }) as Promise<EnteFile>[]
-                ))
-            );
-
-            if (resp.data.diff.length) {
-                time = resp.data.diff.slice(-1)[0].updationTime;
-            }
-            setFiles(
-                sortFiles(
-                    mergeMetadata(
-                        decryptedFiles.filter((item) => !item.isDeleted)
-                    )
-                )
-            );
-        } while (resp.data.hasMore);
-        return decryptedFiles;
-    } catch (e) {
-        logError(e, 'Get files failed');
-    }
-    return [];
-};
diff --git a/src/types/publicCollection/index.ts b/src/types/publicCollection/index.ts
new file mode 100644
index 00000000000..8d0c3e8efe8
--- /dev/null
+++ b/src/types/publicCollection/index.ts
@@ -0,0 +1,11 @@
+import { EnteFile } from 'types/file';
+
+export interface SharedAlbumContextType {
+    token: string;
+    accessedThroughSharedURL: boolean;
+}
+
+export interface LocalSavedPublicCollectionFiles {
+    collectionUID: string;
+    files: EnteFile[];
+}
diff --git a/src/types/sharedAlbum/index.ts b/src/types/sharedAlbum/index.ts
deleted file mode 100644
index 9ad15f3588b..00000000000
--- a/src/types/sharedAlbum/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type SharedAlbumContextType = {
-    token: string;
-    accessedThroughSharedURL: boolean;
-};
