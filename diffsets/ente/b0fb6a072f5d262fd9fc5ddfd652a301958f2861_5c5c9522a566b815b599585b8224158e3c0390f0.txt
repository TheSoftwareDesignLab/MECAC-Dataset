diff --git a/mobile/apps/photos/lib/ui/common/touch_cross_detector.dart b/mobile/apps/photos/lib/ui/common/touch_cross_detector.dart
new file mode 100644
index 00000000000..ecc14904ee9
--- /dev/null
+++ b/mobile/apps/photos/lib/ui/common/touch_cross_detector.dart
@@ -0,0 +1,234 @@
+import 'package:flutter/gestures.dart';
+import 'package:flutter/rendering.dart';
+import 'package:flutter/widgets.dart';
+
+/// A widget that detects when a touch pointer crosses its boundaries during a drag.
+///
+/// This widget solves the problem where on touch platforms, only the widget that
+/// receives the initial touch gets subsequent drag events. TouchCrossDetector uses
+/// a global listener to track all pointer movements and performs hit testing to
+/// determine when pointers enter or exit widget boundaries.
+///
+/// Note: onEnter, onHover and onPointerDown callbacks are not only triggered
+/// when the pointer is dragged into the widget, but also when the pointer
+/// is initially pressed down within the widget's bounds. Same applies for onExit
+/// when the pointer is released within the widget's bounds.
+
+class TouchCrossDetector extends SingleChildRenderObjectWidget {
+  const TouchCrossDetector({
+    super.key,
+    this.onEnter,
+    this.onExit,
+    this.onHover,
+    this.onPointerDown,
+    required Widget super.child,
+  });
+
+  final void Function(PointerEnterEvent)? onEnter;
+  final void Function(PointerExitEvent)? onExit;
+  final void Function(PointerHoverEvent)? onHover;
+  final void Function(PointerDownEvent)? onPointerDown;
+
+  static bool isPointerActive(int pointer) {
+    return _TouchCrossRenderTracker.instance.isPointerActive(pointer);
+  }
+
+  @override
+  RenderTouchCrossDetector createRenderObject(BuildContext context) {
+    return RenderTouchCrossDetector(
+      onEnter: onEnter,
+      onExit: onExit,
+      onHover: onHover,
+      onPointerDown: onPointerDown,
+    );
+  }
+
+  @override
+  void updateRenderObject(
+    BuildContext context,
+    RenderTouchCrossDetector renderObject,
+  ) {
+    renderObject
+      ..onEnter = onEnter
+      ..onExit = onExit
+      ..onHover = onHover
+      ..onPointerDown = onPointerDown;
+  }
+}
+
+class RenderTouchCrossDetector extends RenderProxyBox {
+  RenderTouchCrossDetector({
+    void Function(PointerEnterEvent)? onEnter,
+    void Function(PointerExitEvent)? onExit,
+    void Function(PointerHoverEvent)? onHover,
+    void Function(PointerDownEvent)? onPointerDown,
+    RenderBox? child,
+  })  : _onEnter = onEnter,
+        _onExit = onExit,
+        _onHover = onHover,
+        _onPointerDown = onPointerDown,
+        super(child);
+
+  void Function(PointerEnterEvent)? _onEnter;
+  set onEnter(void Function(PointerEnterEvent)? value) {
+    if (_onEnter != value) {
+      _onEnter = value;
+    }
+  }
+
+  void Function(PointerExitEvent)? _onExit;
+  set onExit(void Function(PointerExitEvent)? value) {
+    if (_onExit != value) {
+      _onExit = value;
+    }
+  }
+
+  void Function(PointerHoverEvent)? _onHover;
+  set onHover(void Function(PointerHoverEvent)? value) {
+    if (_onHover != value) {
+      _onHover = value;
+    }
+  }
+
+  void Function(PointerDownEvent)? _onPointerDown;
+  set onPointerDown(void Function(PointerDownEvent)? value) {
+    if (_onPointerDown != value) {
+      _onPointerDown = value;
+    }
+  }
+
+  final Set<int> _activePointers = <int>{};
+
+  @override
+  void attach(PipelineOwner owner) {
+    super.attach(owner);
+    _TouchCrossRenderTracker.instance.register(this);
+  }
+
+  @override
+  void detach() {
+    _TouchCrossRenderTracker.instance.unregister(this);
+    super.detach();
+  }
+
+  void handlePointerDown(PointerDownEvent event) {
+    if (!attached) return;
+    final bool isInside = size.contains(globalToLocal(event.position));
+    if (isInside) {
+      _activePointers.add(event.pointer);
+      _onPointerDown?.call(event);
+      // Also trigger enter event for initial touch
+      _onEnter?.call(
+        PointerEnterEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    }
+  }
+
+  void handlePointerUpdate(PointerEvent event) {
+    if (!attached) return;
+    final bool isInside = size.contains(globalToLocal(event.position));
+    final bool wasInside = _activePointers.contains(event.pointer);
+    if (isInside && !wasInside) {
+      _activePointers.add(event.pointer);
+      _onEnter?.call(
+        PointerEnterEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    } else if (!isInside && wasInside) {
+      _activePointers.remove(event.pointer);
+      _onExit?.call(
+        PointerExitEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    } else if (isInside && wasInside) {
+      _onHover?.call(
+        PointerHoverEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    }
+  }
+
+  void handlePointerUp(PointerUpEvent event) {
+    if (_activePointers.contains(event.pointer)) {
+      _activePointers.remove(event.pointer);
+      _onExit?.call(
+        PointerExitEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    }
+  }
+
+  void handlePointerCancel(PointerCancelEvent event) {
+    if (_activePointers.contains(event.pointer)) {
+      _activePointers.remove(event.pointer);
+      _onExit?.call(
+        PointerExitEvent(
+          position: event.position,
+          timeStamp: event.timeStamp,
+          pointer: event.pointer,
+        ),
+      );
+    }
+  }
+}
+
+/// Global tracker for RenderObject-based implementation
+class _TouchCrossRenderTracker {
+  _TouchCrossRenderTracker._() {
+    GestureBinding.instance.pointerRouter.addGlobalRoute(_handlePointerEvent);
+  }
+  static final _TouchCrossRenderTracker instance = _TouchCrossRenderTracker._();
+  final Set<RenderTouchCrossDetector> _trackedRenderObjects =
+      <RenderTouchCrossDetector>{};
+  final Set<int> _activePointers = <int>{};
+
+  bool isPointerActive(int pointer) => _activePointers.contains(pointer);
+  void register(RenderTouchCrossDetector renderObject) {
+    _trackedRenderObjects.add(renderObject);
+  }
+
+  void unregister(RenderTouchCrossDetector renderObject) {
+    _trackedRenderObjects.remove(renderObject);
+  }
+
+  void _handlePointerEvent(PointerEvent event) {
+    if (event is PointerDownEvent) {
+      _activePointers.add(event.pointer);
+      // Handle pointer down to initialize swipe selection
+      for (final renderObject in _trackedRenderObjects) {
+        renderObject.handlePointerDown(event);
+      }
+    } else if (event is PointerUpEvent || event is PointerCancelEvent) {
+      _activePointers.remove(event.pointer);
+      for (final renderObject in _trackedRenderObjects) {
+        if (event is PointerUpEvent) {
+          renderObject.handlePointerUp(event);
+        } else if (event is PointerCancelEvent) {
+          // Also handle cancel events to ensure cleanup
+          renderObject.handlePointerCancel(event);
+        }
+      }
+    } else if (event is PointerMoveEvent &&
+        _activePointers.contains(event.pointer)) {
+      for (final renderObject in _trackedRenderObjects) {
+        renderObject.handlePointerUpdate(event);
+      }
+    }
+  }
+}
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/component/gallery_file_widget.dart b/mobile/apps/photos/lib/ui/viewer/gallery/component/gallery_file_widget.dart
index 97f8ace2b86..724bdbcd7dc 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/component/gallery_file_widget.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/component/gallery_file_widget.dart
@@ -1,3 +1,5 @@
+import "dart:async";
+
 import "package:flutter/material.dart";
 import "package:flutter/services.dart";
 import "package:media_extension/media_extension.dart";
@@ -7,10 +9,12 @@ import 'package:photos/models/file/file.dart';
 import "package:photos/models/selected_files.dart";
 import "package:photos/services/app_lifecycle_service.dart";
 import "package:photos/theme/ente_theme.dart";
+import "package:photos/ui/common/touch_cross_detector.dart";
 import "package:photos/ui/viewer/file/detail_page.dart";
 import "package:photos/ui/viewer/file/thumbnail_widget.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_context_state.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_files_inherited_widget.dart";
+import "package:photos/ui/viewer/gallery/state/gallery_swipe_helper.dart";
 import "package:photos/utils/file_util.dart";
 import "package:photos/utils/navigation_util.dart";
 
@@ -45,6 +49,10 @@ class _GalleryFileWidgetState extends State<GalleryFileWidget> {
     _isFileSelected =
         widget.selectedFiles?.isFileSelected(widget.file) ?? false;
     widget.selectedFiles?.addListener(_selectedFilesListener);
+    // Timer.periodic(const Duration(seconds: 2), (_) {
+    //   final len = GallerySwipeHelper.of(context)?.allFiles.length;
+    //   print("--------- len: $len");
+    // });
   }
 
   @override
@@ -55,6 +63,7 @@ class _GalleryFileWidgetState extends State<GalleryFileWidget> {
 
   @override
   Widget build(BuildContext context) {
+    final swipeHelper = GallerySwipeHelper.of(context);
     Color selectionColor = Colors.white;
     if (_isFileSelected &&
         widget.file.isUploaded &&
@@ -76,72 +85,87 @@ class _GalleryFileWidgetState extends State<GalleryFileWidget> {
       shouldShowOwnerAvatar: !_isFileSelected,
       shouldShowVideoDuration: true,
     );
-    return GestureDetector(
-      onTap: () {
-        widget.limitSelectionToOne
-            ? _onTapWithSelectionLimit(widget.file)
-            : _onTapNoSelectionLimit(context, widget.file);
+    return TouchCrossDetector(
+      onPointerDown: (event) {
+        if (swipeHelper != null && widget.selectedFiles != null) {
+          swipeHelper.startSelection(widget.file);
+        }
       },
-      onLongPress: () {
-        widget.limitSelectionToOne
-            ? _onLongPressWithSelectionLimit(context, widget.file)
-            : _onLongPressNoSelectionLimit(context, widget.file);
+      onEnter: (event) {
+        if (swipeHelper?.isActive ?? false) {
+          swipeHelper!.updateSelection(widget.file);
+        }
       },
-      child: _isFileSelected
-          ? Stack(
-              clipBehavior: Clip.none,
-              children: [
-                ClipRRect(
-                  key: ValueKey(heroTag),
-                  borderRadius: borderRadius,
-                  child: Hero(
-                    tag: heroTag,
-                    flightShuttleBuilder: (
-                      flightContext,
-                      animation,
-                      flightDirection,
-                      fromHeroContext,
-                      toHeroContext,
-                    ) =>
-                        thumbnailWidget,
-                    transitionOnUserGestures: true,
-                    child: thumbnailWidget,
-                  ),
-                ),
-                Container(
-                  decoration: const BoxDecoration(
-                    color: Color.fromARGB(102, 0, 0, 0),
+      onExit: (event) {
+        // Handle exit if needed
+      },
+      child: GestureDetector(
+        onTap: () {
+          widget.limitSelectionToOne
+              ? _onTapWithSelectionLimit(widget.file)
+              : _onTapNoSelectionLimit(context, widget.file);
+        },
+        onLongPress: () {
+          widget.limitSelectionToOne
+              ? _onLongPressWithSelectionLimit(context, widget.file)
+              : _onLongPressNoSelectionLimit(context, widget.file);
+        },
+        child: _isFileSelected
+            ? Stack(
+                clipBehavior: Clip.none,
+                children: [
+                  ClipRRect(
+                    key: ValueKey(heroTag),
                     borderRadius: borderRadius,
+                    child: Hero(
+                      tag: heroTag,
+                      flightShuttleBuilder: (
+                        flightContext,
+                        animation,
+                        flightDirection,
+                        fromHeroContext,
+                        toHeroContext,
+                      ) =>
+                          thumbnailWidget,
+                      transitionOnUserGestures: true,
+                      child: thumbnailWidget,
+                    ),
                   ),
-                ),
-                Positioned(
-                  right: 4,
-                  top: 4,
-                  child: Icon(
-                    Icons.check_circle_rounded,
-                    size: 20,
-                    color: selectionColor, //same for both themes
+                  Container(
+                    decoration: const BoxDecoration(
+                      color: Color.fromARGB(102, 0, 0, 0),
+                      borderRadius: borderRadius,
+                    ),
+                  ),
+                  Positioned(
+                    right: 4,
+                    top: 4,
+                    child: Icon(
+                      Icons.check_circle_rounded,
+                      size: 20,
+                      color: selectionColor, //same for both themes
+                    ),
                   ),
+                ],
+              )
+            : ClipRRect(
+                key: ValueKey(heroTag),
+                borderRadius: borderRadius,
+                child: Hero(
+                  tag: heroTag,
+                  flightShuttleBuilder: (
+                    flightContext,
+                    animation,
+                    flightDirection,
+                    fromHeroContext,
+                    toHeroContext,
+                  ) =>
+                      thumbnailWidget,
+                  transitionOnUserGestures: true,
+                  child: thumbnailWidget,
                 ),
-              ],
-            )
-          : ClipRRect(
-              key: ValueKey(heroTag),
-              borderRadius: borderRadius,
-              child: Hero(
-                tag: heroTag,
-                flightShuttleBuilder: (
-                  flightContext,
-                  animation,
-                  flightDirection,
-                  fromHeroContext,
-                  toHeroContext,
-                ) =>
-                    thumbnailWidget,
-                transitionOnUserGestures: true,
-                child: thumbnailWidget,
               ),
-            ),
+      ),
     );
   }
 
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart b/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
index bb537972ba2..004b832d239 100644
--- a/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/gallery.dart
@@ -28,7 +28,9 @@ import 'package:photos/ui/viewer/gallery/empty_state.dart';
 import "package:photos/ui/viewer/gallery/scrollbar/custom_scroll_bar.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_context_state.dart";
 import "package:photos/ui/viewer/gallery/state/gallery_files_inherited_widget.dart";
+import "package:photos/ui/viewer/gallery/state/gallery_swipe_helper.dart";
 import "package:photos/ui/viewer/gallery/state/inherited_search_filter_data.dart";
+import "package:photos/ui/viewer/gallery/swipe_to_select_helper.dart";
 import "package:photos/utils/hierarchical_search_util.dart";
 import "package:photos/utils/misc_util.dart";
 import "package:photos/utils/standalone/date_time.dart";
@@ -144,6 +146,7 @@ class GalleryState extends State<Gallery> {
   late GroupType _groupType;
   final scrollbarBottomPaddingNotifier = ValueNotifier<double>(0);
   late GalleryGroups galleryGroups;
+  SwipeToSelectHelper? _swipeHelper;
 
   @override
   void initState() {
@@ -194,6 +197,7 @@ class GalleryState extends State<Gallery> {
           }
           if (!hasTriggeredSetState && mounted) {
             _updateGalleryGroups();
+            _updateSwipeHelper();
           }
         });
       });
@@ -361,6 +365,7 @@ class GalleryState extends State<Gallery> {
     final hasReloaded = _onFilesLoaded(files);
     if (!hasReloaded && mounted) {
       _updateGalleryGroups();
+      _updateSwipeHelper();
     }
   }
 
@@ -454,6 +459,15 @@ class GalleryState extends State<Gallery> {
     return false;
   }
 
+  void _updateSwipeHelper() {
+    if (widget.selectedFiles != null && _allGalleryFiles.isNotEmpty) {
+      _swipeHelper ??= SwipeToSelectHelper(
+        allFiles: _allGalleryFiles,
+        selectedFiles: widget.selectedFiles!,
+      );
+    }
+  }
+
   Future<FileLoadResult> _loadFiles({int? limit}) async {
     _logger.info("Loading ${limit ?? "all"} files");
     try {
@@ -556,89 +570,103 @@ class GalleryState extends State<Gallery> {
     if (!_hasLoadedFiles) {
       return widget.loadingWidget;
     }
-    return GalleryContextState(
-      sortOrderAsc: _sortOrderAsc,
-      inSelectionMode: widget.inSelectionMode,
-      type: _groupType,
-      child: _allGalleryFiles.isEmpty
-          ? Column(
-              mainAxisAlignment: MainAxisAlignment.spaceBetween,
-              children: [
-                if (widget.addHeaderOrFooterEmptyState)
-                  widget.header ?? const SizedBox.shrink(),
-                Expanded(child: widget.emptyState),
-                if (widget.addHeaderOrFooterEmptyState)
-                  widget.footer ?? const SizedBox.shrink(),
-              ],
-            )
-          : CustomScrollBar(
-              scrollController: _scrollController,
-              galleryGroups: galleryGroups,
-              inUseNotifier: scrollBarInUseNotifier,
-              heighOfViewport: MediaQuery.sizeOf(context).height,
-              topPadding: widget.disableVerticalPaddingForScrollbar
-                  ? 0.0
-                  : groupHeaderExtent!,
-              bottomPadding: widget.disableVerticalPaddingForScrollbar
-                  ? ValueNotifier(0.0)
-                  : scrollbarBottomPaddingNotifier,
-              child: NotificationListener<SizeChangedLayoutNotification>(
-                onNotification: (notification) {
-                  final renderBox = _headerKey.currentContext
-                      ?.findRenderObject() as RenderBox?;
-                  if (renderBox != null) {
-                    _headerHeightNotifier.value = renderBox.size.height;
-                  } else {
-                    _logger.info(
-                      "Header render box is null, cannot get height",
-                    );
-                  }
-
-                  return true;
-                },
-                child: Stack(
-                  clipBehavior: Clip.none,
+    return GallerySwipeHelper(
+      helper: _swipeHelper,
+      child: Listener(
+        onPointerUp: (_) {
+          // End swipe selection when pointer is released
+          _swipeHelper?.endSelection();
+        },
+        onPointerCancel: (_) {
+          // Also end selection on cancel
+          _swipeHelper?.endSelection();
+        },
+        child: GalleryContextState(
+          sortOrderAsc: _sortOrderAsc,
+          inSelectionMode: widget.inSelectionMode,
+          type: _groupType,
+          child: _allGalleryFiles.isEmpty
+              ? Column(
+                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                   children: [
-                    CustomScrollView(
-                      physics: widget.disableScroll
-                          ? const NeverScrollableScrollPhysics()
-                          : const ExponentialBouncingScrollPhysics(),
-                      controller: _scrollController,
-                      slivers: [
-                        SliverToBoxAdapter(
-                          child: SizeChangedLayoutNotifier(
-                            child: SizedBox(
-                              key: _headerKey,
-                              child: widget.header ?? const SizedBox.shrink(),
+                    if (widget.addHeaderOrFooterEmptyState)
+                      widget.header ?? const SizedBox.shrink(),
+                    Expanded(child: widget.emptyState),
+                    if (widget.addHeaderOrFooterEmptyState)
+                      widget.footer ?? const SizedBox.shrink(),
+                  ],
+                )
+              : CustomScrollBar(
+                  scrollController: _scrollController,
+                  galleryGroups: galleryGroups,
+                  inUseNotifier: scrollBarInUseNotifier,
+                  heighOfViewport: MediaQuery.sizeOf(context).height,
+                  topPadding: widget.disableVerticalPaddingForScrollbar
+                      ? 0.0
+                      : groupHeaderExtent!,
+                  bottomPadding: widget.disableVerticalPaddingForScrollbar
+                      ? ValueNotifier(0.0)
+                      : scrollbarBottomPaddingNotifier,
+                  child: NotificationListener<SizeChangedLayoutNotification>(
+                    onNotification: (notification) {
+                      final renderBox = _headerKey.currentContext
+                          ?.findRenderObject() as RenderBox?;
+                      if (renderBox != null) {
+                        _headerHeightNotifier.value = renderBox.size.height;
+                      } else {
+                        _logger.info(
+                          "Header render box is null, cannot get height",
+                        );
+                      }
+
+                      return true;
+                    },
+                    child: Stack(
+                      clipBehavior: Clip.none,
+                      children: [
+                        CustomScrollView(
+                          physics: widget.disableScroll
+                              ? const NeverScrollableScrollPhysics()
+                              : const ExponentialBouncingScrollPhysics(),
+                          controller: _scrollController,
+                          slivers: [
+                            SliverToBoxAdapter(
+                              child: SizeChangedLayoutNotifier(
+                                child: SizedBox(
+                                  key: _headerKey,
+                                  child:
+                                      widget.header ?? const SizedBox.shrink(),
+                                ),
+                              ),
                             ),
-                          ),
-                        ),
-                        SectionedListSliver(
-                          sectionLayouts: galleryGroups.groupLayouts,
-                        ),
-                        SliverToBoxAdapter(
-                          child: widget.footer,
+                            SectionedListSliver(
+                              sectionLayouts: galleryGroups.groupLayouts,
+                            ),
+                            SliverToBoxAdapter(
+                              child: widget.footer,
+                            ),
+                          ],
                         ),
+                        galleryGroups.groupType.showGroupHeader() &&
+                                !widget.disablePinnedGroupHeader
+                            ? PinnedGroupHeader(
+                                scrollController: _scrollController,
+                                galleryGroups: galleryGroups,
+                                headerHeightNotifier: _headerHeightNotifier,
+                                selectedFiles: widget.selectedFiles,
+                                showSelectAll: widget.showSelectAll &&
+                                    !widget.limitSelectionToOne,
+                                scrollbarInUseNotifier: scrollBarInUseNotifier,
+                                showGallerySettingsCTA:
+                                    widget.showGallerySettingsCTA,
+                              )
+                            : const SizedBox.shrink(),
                       ],
                     ),
-                    galleryGroups.groupType.showGroupHeader() &&
-                            !widget.disablePinnedGroupHeader
-                        ? PinnedGroupHeader(
-                            scrollController: _scrollController,
-                            galleryGroups: galleryGroups,
-                            headerHeightNotifier: _headerHeightNotifier,
-                            selectedFiles: widget.selectedFiles,
-                            showSelectAll: widget.showSelectAll &&
-                                !widget.limitSelectionToOne,
-                            scrollbarInUseNotifier: scrollBarInUseNotifier,
-                            showGallerySettingsCTA:
-                                widget.showGallerySettingsCTA,
-                          )
-                        : const SizedBox.shrink(),
-                  ],
+                  ),
                 ),
-              ),
-            ),
+        ),
+      ),
     );
   }
 }
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_swipe_helper.dart b/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_swipe_helper.dart
new file mode 100644
index 00000000000..225dea00e20
--- /dev/null
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/state/gallery_swipe_helper.dart
@@ -0,0 +1,29 @@
+import 'package:flutter/widgets.dart';
+import 'package:photos/ui/viewer/gallery/swipe_to_select_helper.dart';
+
+/// InheritedWidget to provide SwipeToSelectHelper to descendant widgets.
+///
+/// This allows GalleryFileWidget instances to access the swipe helper
+/// without passing it through multiple widget constructors.
+class GallerySwipeHelper extends InheritedWidget {
+  final SwipeToSelectHelper? helper;
+
+  const GallerySwipeHelper({
+    super.key,
+    this.helper,
+    required super.child,
+  });
+
+  /// Get the SwipeToSelectHelper from the nearest ancestor GallerySwipeHelper.
+  static SwipeToSelectHelper? of(BuildContext context) {
+    final widget =
+        context.dependOnInheritedWidgetOfExactType<GallerySwipeHelper>();
+    return widget?.helper;
+  }
+
+  @override
+  bool updateShouldNotify(GallerySwipeHelper oldWidget) {
+    // Only notify if the helper instance changes
+    return helper != oldWidget.helper;
+  }
+}
diff --git a/mobile/apps/photos/lib/ui/viewer/gallery/swipe_to_select_helper.dart b/mobile/apps/photos/lib/ui/viewer/gallery/swipe_to_select_helper.dart
new file mode 100644
index 00000000000..62d6e2e7a65
--- /dev/null
+++ b/mobile/apps/photos/lib/ui/viewer/gallery/swipe_to_select_helper.dart
@@ -0,0 +1,139 @@
+import 'dart:math';
+
+import 'package:photos/models/file/file.dart';
+import 'package:photos/models/selected_files.dart';
+
+/// Helper class to manage swipe-to-select gesture logic.
+///
+/// This class implements an efficient range selection algorithm that:
+/// - Maintains a continuous selection from anchor to current position
+/// - Only modifies the delta between previous and current position
+/// - Supports bidirectional dragging
+/// - Has two modes: adding (from unselected) or removing (from selected)
+class SwipeToSelectHelper {
+  final List<EnteFile> allFiles;
+  final SelectedFiles selectedFiles;
+
+  SwipeToSelectHelper({
+    required this.allFiles,
+    required this.selectedFiles,
+  });
+
+  int? _fromIndex; // Anchor point (where swipe started)
+  int? _lastToIndex; // Previous position during drag
+  bool? _selecting; // true = adding, false = removing
+
+  /// Whether a swipe gesture is currently active
+  bool get isActive => _fromIndex != null;
+
+  /// Start a selection gesture at the given file
+  void startSelection(EnteFile file) {
+    final index = allFiles.indexOf(file);
+    if (index == -1) return;
+
+    _fromIndex = index;
+    _lastToIndex = index;
+    // Determine mode based on initial file's selection state
+    _selecting = !selectedFiles.isFileSelected(file);
+  }
+
+  /// Update selection as the pointer moves to a new file
+  void updateSelection(EnteFile file) {
+    if (_fromIndex == null) return;
+
+    final toIndex = allFiles.indexOf(file);
+    if (toIndex == -1 || toIndex == _lastToIndex) return;
+
+    _toggleSelectionToIndex(toIndex);
+    _lastToIndex = toIndex;
+  }
+
+  /// End the selection gesture
+  void endSelection() {
+    _fromIndex = null;
+    _lastToIndex = null;
+    _selecting = null;
+  }
+
+  /// Core algorithm that efficiently updates selection ranges
+  void _toggleSelectionToIndex(int toIndex) {
+    if (_fromIndex == null || _lastToIndex == null || _selecting == null) {
+      return;
+    }
+
+    final fromIndex = _fromIndex!;
+    final lastToIndex = _lastToIndex!;
+    final selecting = _selecting!;
+
+    // Helper function to get range of files
+    Set<EnteFile> getRange(int start, int end) {
+      if (start < end && start >= 0 && end <= allFiles.length) {
+        return allFiles.getRange(start, end).toSet();
+      }
+      return {};
+    }
+
+    if (selecting) {
+      // Adding mode: maintain continuous selection from fromIndex to toIndex
+      if (toIndex <= fromIndex) {
+        // Moving left of starting point
+        if (toIndex < lastToIndex) {
+          // Extending leftward
+          final itemsToAdd = getRange(toIndex, min(fromIndex, lastToIndex));
+          if (itemsToAdd.isNotEmpty) {
+            selectedFiles.selectAll(itemsToAdd);
+          }
+          // Remove items to the right of start if we were previously there
+          if (fromIndex < lastToIndex) {
+            final itemsToRemove = getRange(fromIndex + 1, lastToIndex + 1);
+            if (itemsToRemove.isNotEmpty) {
+              selectedFiles.unSelectAll(itemsToRemove);
+            }
+          }
+        } else if (lastToIndex < toIndex) {
+          // Contracting from left
+          final itemsToRemove = getRange(lastToIndex, toIndex);
+          if (itemsToRemove.isNotEmpty) {
+            selectedFiles.unSelectAll(itemsToRemove);
+          }
+        }
+      } else if (fromIndex < toIndex) {
+        // Moving right of starting point
+        if (lastToIndex < toIndex) {
+          // Extending rightward
+          final itemsToAdd = getRange(max(fromIndex, lastToIndex), toIndex + 1);
+          if (itemsToAdd.isNotEmpty) {
+            selectedFiles.selectAll(itemsToAdd);
+          }
+          // Remove items to the left of start if we were previously there
+          if (lastToIndex < fromIndex) {
+            final itemsToRemove = getRange(lastToIndex, fromIndex);
+            if (itemsToRemove.isNotEmpty) {
+              selectedFiles.unSelectAll(itemsToRemove);
+            }
+          }
+        } else if (toIndex < lastToIndex) {
+          // Contracting from right
+          final itemsToRemove = getRange(toIndex + 1, lastToIndex + 1);
+          if (itemsToRemove.isNotEmpty) {
+            selectedFiles.unSelectAll(itemsToRemove);
+          }
+        }
+      }
+    } else {
+      // Removing mode: remove the range from fromIndex to toIndex
+      final itemsToRemove = getRange(
+        min(fromIndex, toIndex),
+        max(fromIndex, toIndex) + 1,
+      );
+      if (itemsToRemove.isNotEmpty) {
+        selectedFiles.unSelectAll(itemsToRemove);
+      }
+    }
+  }
+
+  /// Reset the helper (e.g., when gallery files change)
+  void reset() {
+    endSelection();
+  }
+}
