diff --git a/mobile/lib/services/album_home_widget_service.dart b/mobile/lib/services/album_home_widget_service.dart
index 13a5d6fa803..1f09aa1e7dc 100644
--- a/mobile/lib/services/album_home_widget_service.dart
+++ b/mobile/lib/services/album_home_widget_service.dart
@@ -19,7 +19,6 @@ import "package:photos/ui/viewer/file/detail_page.dart";
 import 'package:photos/ui/viewer/gallery/collection_page.dart';
 import 'package:photos/utils/navigation_util.dart';
 import 'package:shared_preferences/shared_preferences.dart';
-import 'package:synchronized/synchronized.dart';
 
 class AlbumHomeWidgetService {
   // Constants
@@ -40,8 +39,6 @@ class AlbumHomeWidgetService {
   // Properties
   final Logger _logger = Logger((AlbumHomeWidgetService).toString());
   late final SharedPreferences _prefs;
-  final _albumsForceRefreshLock = Lock();
-  bool _hasSyncedAlbums = false;
 
   // Initialization
   void init(SharedPreferences prefs) {
@@ -49,29 +46,20 @@ class AlbumHomeWidgetService {
   }
 
   // Public methods
-  Future<void> initAlbumHomeWidget(bool? forceFetchNewAlbums) async {
-    if (await _hasAnyBlockers()) {
-      await clearWidget();
-      return;
-    }
-
-    await _albumsForceRefreshLock.synchronized(() async {
+  Future<void> initAlbumHomeWidget() async {
+    await HomeWidgetService.instance.computeLock.synchronized(() async {
       if (await _hasAnyBlockers()) {
         await clearWidget();
         return;
       }
 
-      final isWidgetEmpty = await _isWidgetEmpty();
-      forceFetchNewAlbums ??= await _shouldForceFetchAlbums(isWidgetEmpty);
-
-      _logger.warning(
-        "Initializing albums widget: forceFetch: $forceFetchNewAlbums, isEmpty: $isWidgetEmpty",
-      );
+      final bool forceFetchNewAlbums = await _shouldUpdateWidgetCache();
 
-      if (forceFetchNewAlbums!) {
-        await _forceAlbumsUpdate();
-      } else if (!isWidgetEmpty) {
-        await _syncExistingAlbums();
+      if (forceFetchNewAlbums) {
+        await _loadAndRenderAlbums();
+        await updateAlbumsChanged(false);
+      } else {
+        await _refreshAlbumsWidget();
       }
     });
   }
@@ -101,21 +89,19 @@ class AlbumHomeWidgetService {
   }
 
   Future<void> clearWidget() async {
-    if (await _isWidgetEmpty()) {
+    if (getAlbumsStatus() == WidgetStatus.syncedEmpty) {
       _logger.info("Widget already empty, nothing to clear");
       return;
     }
 
     _logger.info("Clearing AlbumsHomeWidget");
-    await _setTotalAlbums(null);
     await updateAlbumsStatus(WidgetStatus.syncedEmpty);
-    _hasSyncedAlbums = false;
     await setAlbumsLastHash("");
     await _refreshWidget(message: "AlbumsHomeWidget cleared & updated");
   }
 
-  bool getAlbumsChanged() {
-    return _prefs.getBool(ALBUMS_CHANGED_KEY) ?? false;
+  bool? getAlbumsChanged() {
+    return _prefs.getBool(ALBUMS_CHANGED_KEY);
   }
 
   Future<void> updateAlbumsChanged(bool value) async {
@@ -139,15 +125,14 @@ class AlbumHomeWidgetService {
       await Future.delayed(const Duration(seconds: 5));
     }
 
-    final isWidgetEmpty = await _isWidgetEmpty();
-    final shouldForceFetch = await _shouldForceFetchAlbums(isWidgetEmpty);
+    final shouldForceFetch = await _shouldUpdateWidgetCache();
 
-    if (_hasSyncedAlbums && !shouldForceFetch) {
+    if (!shouldForceFetch) {
       _logger.info("Albums already synced, no action needed");
       return;
     }
 
-    await initAlbumHomeWidget(shouldForceFetch);
+    await initAlbumHomeWidget();
   }
 
   Future<void> albumsChanged() async {
@@ -162,7 +147,7 @@ class AlbumHomeWidgetService {
 
     _logger.info("Albums changed, updating widget");
     await updateAlbumsChanged(true);
-    await initAlbumHomeWidget(true);
+    await initAlbumHomeWidget();
   }
 
   List<Collection> getAlbumsByIds(List<int> albumIds) {
@@ -200,8 +185,7 @@ class AlbumHomeWidgetService {
     int collectionId,
     BuildContext context,
   ) async {
-    _hasSyncedAlbums = true;
-    await _syncExistingAlbums();
+    await _refreshAlbumsWidget();
 
     final collection =
         CollectionsService.instance.getCollectionByID(collectionId);
@@ -265,30 +249,15 @@ class AlbumHomeWidgetService {
     return false;
   }
 
-  Future<void> _forceAlbumsUpdate() async {
-    await _loadAndRenderAlbums();
-    await updateAlbumsChanged(false);
-  }
-
-  Future<void> _syncExistingAlbums() async {
-    final homeWidgetCount = await countHomeWidgets();
-    if (homeWidgetCount == 0) {
-      _logger.warning("No active home widgets found");
-      return;
-    }
-
+  Future<void> _refreshAlbumsWidget() async {
+    // only refresh if widget was synced without issues
+    if (getAlbumsStatus() == WidgetStatus.syncedAll) return;
     await _refreshWidget(message: "Refreshing from existing album set");
   }
 
-  Future<bool> _isWidgetEmpty() async {
-    final totalAlbums = await _getTotalAlbums();
-    return totalAlbums == 0 || totalAlbums == null;
-  }
-
-  Future<bool> _shouldForceFetchAlbums(bool isWidgetEmpty) async {
+  Future<bool> _shouldUpdateWidgetCache() async {
     // Check if albums changed flag is set
-    final albumsChanged = _prefs.getBool(ALBUMS_CHANGED_KEY);
-    if (albumsChanged == true) {
+    if (getAlbumsChanged() == true) {
       return true;
     }
 
@@ -334,14 +303,6 @@ class AlbumHomeWidgetService {
     return selectedAlbumIds ?? [];
   }
 
-  Future<int?> _getTotalAlbums() async {
-    return HomeWidgetService.instance.getData<int>(TOTAL_ALBUMS_KEY);
-  }
-
-  Future<void> _setTotalAlbums(int? total) async {
-    await HomeWidgetService.instance.setData(TOTAL_ALBUMS_KEY, total);
-  }
-
   Future<void> _refreshWidget({String? message}) async {
     await HomeWidgetService.instance.updateWidget(
       androidClass: ANDROID_CLASS_NAME,
@@ -396,9 +357,6 @@ class AlbumHomeWidgetService {
       return;
     }
 
-    final currentTotal = await _getTotalAlbums();
-    _logger.info("Current total albums in widget: $currentTotal");
-
     final bool isWidgetPresent = await countHomeWidgets() > 0;
 
     final limit = isWidgetPresent ? MAX_ALBUMS_LIMIT : 5;
@@ -444,8 +402,6 @@ class AlbumHomeWidgetService {
           return;
         }
 
-        await _setTotalAlbums(renderedCount);
-
         // Show update toast after first item is rendered
         if (renderedCount == 1) {
           await _refreshWidget(
diff --git a/mobile/lib/services/home_widget_service.dart b/mobile/lib/services/home_widget_service.dart
index 681d393ffd4..a5a8a0519c8 100644
--- a/mobile/lib/services/home_widget_service.dart
+++ b/mobile/lib/services/home_widget_service.dart
@@ -53,7 +53,7 @@ class HomeWidgetService {
   HomeWidgetService._privateConstructor();
 
   final Logger _logger = Logger((HomeWidgetService).toString());
-  final widgetComputationLock = Lock();
+  final computeLock = Lock();
 
   void init(SharedPreferences prefs) {
     setAppGroupID(iOSGroupIDMemory);
@@ -72,8 +72,8 @@ class HomeWidgetService {
 
   Future<void> initHomeWidget() async {
     await MemoryHomeWidgetService.instance.initMemoryHomeWidget();
-    await PeopleHomeWidgetService.instance.initPeopleHomeWidget(null);
-    await AlbumHomeWidgetService.instance.initAlbumHomeWidget(null);
+    await PeopleHomeWidgetService.instance.initPeopleHomeWidget();
+    await AlbumHomeWidgetService.instance.initAlbumHomeWidget();
   }
 
   Future<bool?> updateWidget({
diff --git a/mobile/lib/services/memory_home_widget_service.dart b/mobile/lib/services/memory_home_widget_service.dart
index 33c92ac253b..108162f1860 100644
--- a/mobile/lib/services/memory_home_widget_service.dart
+++ b/mobile/lib/services/memory_home_widget_service.dart
@@ -65,8 +65,7 @@ class MemoryHomeWidgetService {
 
   // Public methods
   Future<void> initMemoryHomeWidget() async {
-    await HomeWidgetService.instance.widgetComputationLock
-        .synchronized(() async {
+    await HomeWidgetService.instance.computeLock.synchronized(() async {
       if (await _hasAnyBlockers()) {
         await clearWidget();
         return;
@@ -314,7 +313,7 @@ class MemoryHomeWidgetService {
           return;
         }
 
-        // Show update toast after first item is rendered\
+        // Show update toast after first item is rendered
         if (renderedCount == 1) {
           await _refreshWidget(
             message: "First memory fetched, updating widget",
diff --git a/mobile/lib/services/people_home_widget_service.dart b/mobile/lib/services/people_home_widget_service.dart
index b4fe922dc6c..5fbe28f7cfb 100644
--- a/mobile/lib/services/people_home_widget_service.dart
+++ b/mobile/lib/services/people_home_widget_service.dart
@@ -39,9 +39,7 @@ class PeopleHomeWidgetService {
   // Properties
   final Logger _logger = Logger((PeopleHomeWidgetService).toString());
   late final SharedPreferences _prefs;
-  final _peopleForceRefreshLock = Lock();
-  final _lock2 = Lock();
-  bool _hasSyncedPeople = false;
+  final peopleChangedLock = Lock();
 
   // Initialization
   void init(SharedPreferences prefs) {
@@ -86,43 +84,32 @@ class PeopleHomeWidgetService {
     );
   }
 
-  Future<void> initPeopleHomeWidget(bool? forceFetchNewPeople) async {
-    if (await _hasAnyBlockers()) {
-      await clearWidget();
-      return;
-    }
-
-    await _peopleForceRefreshLock.synchronized(() async {
+  Future<void> initPeopleHomeWidget() async {
+    await HomeWidgetService.instance.computeLock.synchronized(() async {
       if (await _hasAnyBlockers()) {
+        await clearWidget();
         return;
       }
 
-      final isPeopleEmpty = await _isWidgetEmpty();
-      forceFetchNewPeople ??= await _shouldForceFetchPeople(isPeopleEmpty);
+      final bool forceFetchNewPeople = await _shouldUpdateWidgetCache();
 
-      _logger.warning(
-        "Initializing people widget: forceFetch: $forceFetchNewPeople, isPeopleEmpty: $isPeopleEmpty",
-      );
-
-      if (forceFetchNewPeople!) {
-        await _forcePeopleUpdate();
-      } else if (!isPeopleEmpty) {
-        await _syncExistingPeople();
+      if (forceFetchNewPeople) {
+        await _loadAndRenderPeople();
+        await updatePeopleChanged(false);
+      } else {
+        await _refreshPeopleWidget();
       }
     });
   }
 
   Future<void> clearWidget() async {
-    if (await _isWidgetEmpty()) {
+    if (getPeopleStatus() == WidgetStatus.syncedEmpty) {
       _logger.info("Widget already empty, nothing to clear");
       return;
     }
 
-    _logger.info("Clearing PeopleHomeWidget");
-    await _setTotalPeople(null);
-    _hasSyncedPeople = false;
-    await updatePeopleStatus(WidgetStatus.syncedEmpty);
     await setPeopleLastHash("");
+    await updatePeopleStatus(WidgetStatus.syncedEmpty);
     await _refreshWidget(message: "PeopleHomeWidget cleared & updated");
   }
 
@@ -133,6 +120,10 @@ class PeopleHomeWidgetService {
         WidgetStatus.notSynced;
   }
 
+  bool getPeopleChanged() {
+    return _prefs.getBool(PEOPLE_CHANGED_KEY) ?? false;
+  }
+
   Future<void> updatePeopleStatus(WidgetStatus value) async {
     await _prefs.setInt(PEOPLE_STATUS_KEY, value.index);
   }
@@ -142,24 +133,20 @@ class PeopleHomeWidgetService {
     await _prefs.setBool(PEOPLE_CHANGED_KEY, value);
   }
 
-  Future<void> checkPendingPeopleSync({bool addDelay = true}) async {
-    if (addDelay) {
-      await Future.delayed(const Duration(seconds: 5));
-    }
-
-    final isPeopleEmpty = await _isWidgetEmpty();
-    final needsForceFetch = await _shouldForceFetchPeople(isPeopleEmpty);
-
-    if (_hasSyncedPeople && !needsForceFetch) {
-      _logger.info("People already synced, no action needed");
+  Future<void> checkPendingPeopleSync() async {
+    if (await _hasAnyBlockers()) {
+      _logger.warning("Widget update blocked by existing conditions");
+      await clearWidget();
       return;
     }
 
-    await initPeopleHomeWidget(needsForceFetch);
+    if (await _shouldUpdateWidgetCache()) {
+      await initPeopleHomeWidget();
+    }
   }
 
   Future<void> checkPeopleChanged() async {
-    final havePeopleChanged = await _lock2.synchronized(() async {
+    final havePeopleChanged = await peopleChangedLock.synchronized(() async {
       final peopleIds = await _getEffectiveSelectedPeopleIds();
       final currentHash = await _calculateHash(peopleIds);
       final lastHash = getPeopleLastHash();
@@ -174,7 +161,7 @@ class PeopleHomeWidgetService {
       _logger.info("No changes detected in people, skipping update");
       return;
     }
-    await initPeopleHomeWidget(true);
+    await initPeopleHomeWidget();
   }
 
   Future<void> onLaunchFromWidget(
@@ -182,8 +169,7 @@ class PeopleHomeWidgetService {
     String personId,
     BuildContext context,
   ) async {
-    _hasSyncedPeople = true;
-    await _syncExistingPeople();
+    await _refreshPeopleWidget();
 
     final file = await FilesDB.instance.getFile(fileId);
     if (file == null) {
@@ -226,12 +212,6 @@ class PeopleHomeWidgetService {
     );
   }
 
-  // Private methods
-  Future<void> _forcePeopleUpdate() async {
-    await _loadAndRenderPeople();
-    await updatePeopleChanged(false);
-  }
-
   Future<String> _calculateHash(List<String> peopleIds) async {
     return await entityService.getHashForIds(peopleIds);
   }
@@ -269,44 +249,32 @@ class PeopleHomeWidgetService {
     return false;
   }
 
-  Future<void> _syncExistingPeople() async {
-    final homeWidgetCount = await countHomeWidgets();
-    if (homeWidgetCount == 0) {
-      _logger.warning("No active home widgets found");
-      return;
-    }
-
+  Future<void> _refreshPeopleWidget() async {
+    // only refresh if widget was synced without issues
+    if (getPeopleStatus() == WidgetStatus.syncedAll) return;
     await _refreshWidget(message: "Refreshing from existing people set");
   }
 
-  Future<bool> _isWidgetEmpty() async {
-    final totalPeople = await _getTotalPeople();
-    return totalPeople == 0 || totalPeople == null;
-  }
-
-  Future<bool> _shouldForceFetchPeople(bool isPeopleEmpty) async {
-    final peopleChanged = _prefs.getBool(PEOPLE_CHANGED_KEY);
-    if (peopleChanged ?? true) {
+  Future<bool> _shouldUpdateWidgetCache() async {
+    // Update widget cache when people were changed
+    if (getPeopleChanged() == true) {
       return true;
     }
 
+    // update widget cache if
+    // - people not synced
+    // - people synced partially but now home widget is present
     final peopleStatus = getPeopleStatus();
-    switch (peopleStatus) {
-      case WidgetStatus.notSynced:
-        return true;
-      case WidgetStatus.syncedPartially:
-        return await countHomeWidgets() > 0;
-      case WidgetStatus.syncedEmpty:
-      case WidgetStatus.syncedAll:
-        return false;
-    }
+    return peopleStatus == WidgetStatus.notSynced ||
+        peopleStatus == WidgetStatus.syncedPartially &&
+            await countHomeWidgets() > 0;
   }
 
   Future<List<String>> _getEffectiveSelectedPeopleIds() async {
     var peopleIds = getSelectedPeople();
 
+    // Select first two named people by default
     if (peopleIds == null || peopleIds.isEmpty) {
-      // Search Filter with face and pick top two faces
       final searchFilter = await SectionType.face.getData(null).then(
             (value) => (value as List<GenericSearchResult>).where(
               (element) => (element.params[kPersonParamID] as String?) != null,
@@ -371,16 +339,9 @@ class PeopleHomeWidgetService {
     _logger.info("Home Widget updated: ${message ?? "standard update"}");
   }
 
-  Future<int?> _getTotalPeople() async {
-    return HomeWidgetService.instance.getData<int>(TOTAL_PEOPLE_KEY);
-  }
-
-  Future<void> _setTotalPeople(int? total) async {
-    await HomeWidgetService.instance.setData(TOTAL_PEOPLE_KEY, total);
-  }
-
   Future<void> _loadAndRenderPeople() async {
     final peopleIds = await _getEffectiveSelectedPeopleIds();
+    // TODO: Add logic to directly get random people files from database
     final peopleWithFiles = await _getPeople();
 
     if (peopleWithFiles.isEmpty) {
@@ -389,11 +350,7 @@ class PeopleHomeWidgetService {
       return;
     }
 
-    final currentTotal = await _getTotalPeople();
-    _logger.info("Current total people in widget: $currentTotal");
-
     final bool isWidgetPresent = await countHomeWidgets() > 0;
-
     final limit = isWidgetPresent ? MAX_PEOPLE_LIMIT : 5;
     final maxAttempts = limit * 10;
 
@@ -436,8 +393,6 @@ class PeopleHomeWidgetService {
           return;
         }
 
-        await _setTotalPeople(renderedCount);
-
         // Show update toast after first item is rendered
         if (renderedCount == 1) {
           await _refreshWidget(
