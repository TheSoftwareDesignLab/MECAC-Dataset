diff --git a/web/apps/photos/src/components/TripLayout/TripMap.tsx b/web/apps/photos/src/components/TripLayout/TripMap.tsx
index 095ac9c55ba..e6308bf624f 100644
--- a/web/apps/photos/src/components/TripLayout/TripMap.tsx
+++ b/web/apps/photos/src/components/TripLayout/TripMap.tsx
@@ -88,7 +88,7 @@ export const TripMap: React.FC<TripMapProps> = ({
     }
 
     // Calculate super-clusters based on screen collisions, excluding the active cluster
-    const { superClusters, visibleClusters } = detectScreenCollisions(
+    const { superClusters, visibleClustersWithIndices } = detectScreenCollisions(
         photoClusters,
         currentZoom,
         targetZoom,
@@ -181,7 +181,8 @@ export const TripMap: React.FC<TripMapProps> = ({
                     })}
 
                     {/* Draw visible regular clusters */}
-                    {visibleClusters.map((cluster, index) => {
+                    {visibleClustersWithIndices.map((item, index) => {
+                        const { cluster, originalIndex } = item;
                         const firstPhoto = cluster[0];
                         if (!firstPhoto) return null;
                         const avgLat =
@@ -191,12 +192,8 @@ export const TripMap: React.FC<TripMapProps> = ({
                             cluster.reduce((sum, p) => sum + p.lng, 0) /
                             cluster.length;
 
-                        // Find the original cluster index
-                        const originalClusterIndex = photoClusters.findIndex(
-                            (originalCluster) =>
-                                originalCluster.length === cluster.length &&
-                                originalCluster[0]?.image === cluster[0]?.image,
-                        );
+                        // Use the preserved original index
+                        const originalClusterIndex = originalIndex;
                         // Show green only for active locations
                         let currentLocationIndex;
                         if (isTouchDevice) {
diff --git a/web/apps/photos/src/components/TripLayout/mapHelpers.ts b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
index 916b3091d02..626c50ab34f 100644
--- a/web/apps/photos/src/components/TripLayout/mapHelpers.ts
+++ b/web/apps/photos/src/components/TripLayout/mapHelpers.ts
@@ -494,12 +494,12 @@ export const detectScreenCollisions = (
         }
     });
 
-    // Return visible clusters (those not hidden by super-clusters)
-    const visibleClusters = clusters.filter(
-        (_, idx) => !hiddenClusterIndices.has(idx),
-    );
+    // Return visible clusters with their original indices preserved
+    const visibleClustersWithIndices = clusters
+        .map((cluster, originalIndex) => ({ cluster, originalIndex }))
+        .filter((item) => !hiddenClusterIndices.has(item.originalIndex));
 
-    return { superClusters, visibleClusters };
+    return { superClusters, visibleClustersWithIndices };
 };
 
 // Calculate map center with first location positioned at 20% from right edge
diff --git a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
index 7c843712027..043cfc3ae18 100644
--- a/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
+++ b/web/apps/photos/src/components/TripLayout/utils/scrollUtils.ts
@@ -443,8 +443,24 @@ export const scrollTimelineToLocation = ({
     const clientHeight = timelineContainer.clientHeight;
     const maxScrollableDistance = scrollHeight - clientHeight;
 
-    const targetProgress =
-        locationIndex / Math.max(1, photoClusters.length - 1);
+    // Check if we're on a touch device
+    const isTouchDevice = typeof window !== "undefined" &&
+        ('ontouchstart' in window || navigator.maxTouchPoints > 0);
+
+    // Calculate target progress using the same formula as scroll progress calculation
+    let targetProgress;
+    if (isTouchDevice) {
+        // Mobile: Use inverse of the slower progression formula
+        // If active index = Math.floor(progress * (length - 0.5))
+        // Then progress = (index + 0.5) / (length - 0.5) for accurate inverse
+        targetProgress = (locationIndex + 0.5) / Math.max(1, photoClusters.length - 0.5);
+    } else {
+        // Desktop: Use original formula
+        targetProgress = locationIndex / Math.max(1, photoClusters.length - 1);
+    }
+
+    // Clamp progress to valid range
+    targetProgress = Math.min(1, Math.max(0, targetProgress));
     const targetScrollTop = targetProgress * maxScrollableDistance;
 
     timelineContainer.scrollTo({
