diff --git a/lib/src/model/puzzle/puzzle_storm.dart b/lib/src/model/puzzle/puzzle_storm.dart
index d81da3c4d8..ee972c4bbb 100644
--- a/lib/src/model/puzzle/puzzle_storm.dart
+++ b/lib/src/model/puzzle/puzzle_storm.dart
@@ -16,7 +16,7 @@ class StormCtrl extends _$StormCtrl {
   int _currentPuzzleIndex = 0;
   int _moves = 0;
   int _errors = 0;
-  List<(LitePuzzle, bool)> _history = [];
+  final List<(LitePuzzle, bool)> _history = [];
   Timer? _firstMoveTimer;
 
   static const malus = Duration(seconds: 10);
@@ -37,6 +37,7 @@ class StormCtrl extends _$StormCtrl {
       moves: 0,
       clock: StormClock(),
       combo: StormCombo(),
+      stats: null,
     );
     _currentPuzzleIndex += 1;
     _firstMoveTimer =
@@ -45,9 +46,9 @@ class StormCtrl extends _$StormCtrl {
   }
 
   Future<void> onUserMove(Move move) async {
-    _addMove(move);
     state.clock.start();
     final expected = state.expectedMove;
+    _addMove(move);
     _moves += 1;
     if (state.position.isGameOver || move == expected) {
       state.combo.inc();
@@ -57,22 +58,40 @@ class StormCtrl extends _$StormCtrl {
       }
       if (state.position.isGameOver || state.isOver) {
         _pushToHistory(true);
+        if (!_nextPuzzle()) {
+          end();
+          return;
+        }
         await Future<void>.delayed(const Duration(milliseconds: 200));
         await _loadNextPuzzle();
         return;
       }
+      if (!_nextPuzzle()) {
+        end();
+        return;
+      }
       await Future<void>.delayed(const Duration(milliseconds: 500));
       _addMove(state.expectedMove!);
     } else {
       _errors += 1;
       state.combo.reset();
       state.clock.subtractTime(malus);
+      if (!_nextPuzzle()) {
+        end();
+        return;
+      }
       _pushToHistory(false);
       await Future<void>.delayed(const Duration(milliseconds: 200));
+
       await _loadNextPuzzle();
     }
   }
 
+  void end() {
+    state.clock.reset();
+    state = state.copyWith(stats: _getStats());
+  }
+
   Future<void> _loadNextPuzzle() async {
     state = state.copyWith(
       puzzle: puzzles[_currentPuzzleIndex],
@@ -92,9 +111,28 @@ class StormCtrl extends _$StormCtrl {
     );
   }
 
+  StormRunStats _getStats() {
+    final wins = _history.where((e) => e.$2 == true);
+    return StormRunStats(
+      moves: _moves,
+      errors: _errors,
+      score: wins.length,
+      comboBest: state.combo.best,
+      time: state.clock.endAt!,
+      highest: wins.map((e) => e.$1.rating).reduce(
+            (maxRating, rating) => rating > maxRating ? rating : maxRating,
+          ),
+      history: _history,
+    );
+  }
+
   void _pushToHistory(bool result) {
     _history.add((state.puzzle, result));
   }
+
+  bool _nextPuzzle() {
+    return _currentPuzzleIndex < puzzles.length;
+  }
 }
 
 @freezed
@@ -108,6 +146,7 @@ class StormCtrlState with _$StormCtrlState {
     required int moves,
     required StormClock clock,
     required StormCombo combo,
+    required StormRunStats? stats,
   }) = _StormCtrlState;
 
   Move? get expectedMove => Move.fromUci(puzzle.solution[moveIndex + 1]);
@@ -120,6 +159,19 @@ class StormCtrlState with _$StormCtrlState {
   IMap<String, ISet<String>> get validMoves => algebraicLegalMoves(position);
 }
 
+@freezed
+class StormRunStats with _$StormRunStats {
+  const factory StormRunStats({
+    required int moves,
+    required int errors,
+    required int score,
+    required int comboBest,
+    required Duration time,
+    required int highest,
+    required List<(LitePuzzle, bool)> history,
+  }) = _StormRunStats;
+}
+
 class StormCombo {
   int current = 0;
   int best = 0;
@@ -144,19 +196,19 @@ class StormCombo {
     return lvl >= 0 ? lvl - 1 : levels.length - 1;
   }
 
-  int percent() {
+  double percent() {
     final lvl = level();
     final lastLevel = levels[levels.length - 1];
     if (lvl >= levels.length - 1) {
       final range = lastLevel[0] - levels[levels.length - 2][0];
-      return ((((current - lastLevel[0]) / range) * 100) % 100).toInt();
+      return (((current - lastLevel[0]) / range) * 100) % 100;
     }
     final bounds = [levels[lvl][0], levels[lvl + 1][0]];
-    return (((current - bounds[0]) / (bounds[1] - bounds[0])) * 100).floor();
+    return ((current - bounds[0]) / (bounds[1] - bounds[0])) * 100;
   }
 
   Duration? bonus() {
-    if (percent() == 0) {
+    if (percent().floor() == 0) {
       final lvl = level();
       if (lvl > 0) {
         return Duration(seconds: levels[lvl][1]);
@@ -168,16 +220,18 @@ class StormCombo {
 
 class StormClock {
   Timer? _timer;
-  final StreamController<Duration> _timeStreamController =
-      StreamController<Duration>.broadcast();
+  final StreamController<(Duration, int?)> _timeStreamController =
+      StreamController<(Duration, int?)>.broadcast();
   Duration _currentDuration = const Duration(minutes: 3);
+  DateTime? startAt;
+  Duration? endAt;
   bool isActive = false;
 
-  Stream<Duration> get timeStream => _timeStreamController.stream;
+  Stream<(Duration, int?)> get timeStream => _timeStreamController.stream;
 
   void addTime(Duration duration) {
     _currentDuration += duration;
-    _timeStreamController.add(_currentDuration);
+    _timeStreamController.add((_currentDuration, duration.inSeconds));
   }
 
   void subtractTime(Duration duration) {
@@ -185,33 +239,36 @@ class StormClock {
     if (_currentDuration.isNegative) {
       _currentDuration = Duration.zero;
     }
-    _timeStreamController.add(_currentDuration);
+    _timeStreamController.add((_currentDuration, -duration.inSeconds));
   }
 
   void start() {
     if (_timer == null || !_timer!.isActive) {
       isActive = true;
+      startAt = DateTime.now();
+      endAt = null;
       _timer = Timer.periodic(const Duration(seconds: 1), (_) {
         if (_currentDuration.inSeconds > 0) {
           _currentDuration -= const Duration(seconds: 1);
-          _timeStreamController.add(_currentDuration);
+          _timeStreamController.add((_currentDuration, null));
         } else {
-          _timer!.cancel();
+          reset();
         }
       });
     }
   }
 
-  void reset() {
-    _timer?.cancel();
-    _currentDuration = const Duration(minutes: 3);
-    _timeStreamController.add(_currentDuration);
-    isActive = false;
-  }
+  bool flag() => _currentDuration.inSeconds == 0;
 
-  void stop() {
-    _timer?.cancel();
-    isActive = false;
+  void reset() {
+    if (isActive) {
+      _timer?.cancel();
+      _currentDuration = const Duration(minutes: 3);
+      _timeStreamController.add((_currentDuration, null));
+      endAt = DateTime.now().difference(startAt!);
+      isActive = false;
+      startAt = null;
+    }
   }
 
   Duration get timeLeft => _currentDuration;
diff --git a/lib/src/ui/puzzle/puzzle_storm.dart b/lib/src/ui/puzzle/puzzle_storm.dart
index 195444ad35..410281808b 100644
--- a/lib/src/ui/puzzle/puzzle_storm.dart
+++ b/lib/src/ui/puzzle/puzzle_storm.dart
@@ -10,6 +10,7 @@ import 'package:lichess_mobile/src/model/puzzle/puzzle_repository.dart';
 import 'package:lichess_mobile/src/model/puzzle/puzzle_storm.dart';
 import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
+import 'package:lichess_mobile/src/widgets/adaptive_dialog.dart';
 import 'package:lichess_mobile/src/widgets/feedback.dart';
 import 'package:lichess_mobile/src/utils/chessground_compat.dart';
 import "package:lichess_mobile/src/utils/l10n_context.dart";
@@ -82,6 +83,7 @@ class _Load extends ConsumerWidget {
 }
 
 class _Body extends ConsumerWidget {
+  static const levels = [0, 3, 5, 6, 7, 10];
   const _Body({required this.data});
   final PuzzleStormResponse data;
 
@@ -91,7 +93,7 @@ class _Body extends ConsumerWidget {
         ref.watch(boardPreferencesProvider.select((p) => p.pieceSet));
     final stormCtrlProvier = StormCtrlProvider(data.puzzles);
     final puzzleState = ref.watch(stormCtrlProvier);
-    return Column(
+    final content = Column(
       children: [
         Expanded(
           child: Center(
@@ -102,7 +104,8 @@ class _Body extends ConsumerWidget {
                       .read(stormCtrlProvier.notifier)
                       .onUserMove(Move.fromUci(move.uci)!),
                   orientation: puzzleState.pov.cg,
-                  interactableSide: puzzleState.position.isGameOver
+                  interactableSide: puzzleState.clock.endAt != null ||
+                          puzzleState.position.isGameOver
                       ? cg.InteractableSide.none
                       : puzzleState.pov == Side.white
                           ? cg.InteractableSide.white
@@ -118,13 +121,99 @@ class _Body extends ConsumerWidget {
                   pov: puzzleState.pov,
                   clock: puzzleState.clock,
                 ),
-                bottomTable: const SizedBox.shrink(),
+                bottomTable: AnimatedContainer(
+                  duration: const Duration(milliseconds: 500),
+                  child: Column(
+                    crossAxisAlignment: CrossAxisAlignment.stretch,
+                    children: [
+                      SizedBox(
+                        height: 30,
+                        child: LinearProgressIndicator(
+                          value: puzzleState.combo.percent() / 100,
+                          valueColor: const AlwaysStoppedAnimation<Color>(
+                            Colors.blue,
+                          ),
+                        ),
+                      ),
+                      const SizedBox(height: 8),
+                      Row(
+                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
+                        children: [
+                          for (int level in levels)
+                            _buildLevelIndicator(
+                              level,
+                              puzzleState.combo.level(),
+                            )
+                        ],
+                      )
+                    ],
+                  ),
+                ),
               ),
             ),
           ),
         ),
       ],
     );
+
+    return !puzzleState.clock.isActive
+        ? content
+        : WillPopScope(
+            child: content,
+            onWillPop: () async {
+              final result = await showAdaptiveDialog<bool>(
+                context: context,
+                builder: (context) => YesNoDialog(
+                  title: const Text('Are you sure?'),
+                  content: const Text(
+                    'Do you want to end this run?',
+                  ),
+                  onYes: () {
+                    ref.read(stormCtrlProvier.notifier).end();
+                    return Navigator.of(context).pop(true);
+                  },
+                  onNo: () => Navigator.of(context).pop(false),
+                ),
+              );
+              return result ?? false;
+            },
+          );
+  }
+
+  Widget _buildProgressbar(int lvl, double percent) {
+    return AnimatedContainer(
+      duration: const Duration(milliseconds: 500),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.stretch,
+        children: [
+          SizedBox(
+            height: 30,
+            child: LinearProgressIndicator(
+              value: percent / 100,
+              valueColor: const AlwaysStoppedAnimation<Color>(Colors.blue),
+            ),
+          ),
+          const SizedBox(height: 8),
+          Row(
+            mainAxisAlignment: MainAxisAlignment.spaceBetween,
+            children: [
+              for (int level in levels) _buildLevelIndicator(level, lvl)
+            ],
+          )
+        ],
+      ),
+    );
+  }
+
+  Widget _buildLevelIndicator(int level, int currentLvl) {
+    final isCurrentLevel = level <= currentLvl;
+    return Text(
+      level.toString(),
+      style: TextStyle(
+        color: isCurrentLevel ? Colors.blue : Colors.grey,
+        fontWeight: isCurrentLevel ? FontWeight.bold : FontWeight.normal,
+      ),
+    );
   }
 }
 
@@ -159,14 +248,14 @@ class _TopBar extends StatelessWidget {
                   : context.l10n.puzzleFindTheBestMoveForBlack,
             ),
           ),
-          StreamBuilder<Duration>(
+          StreamBuilder<(Duration, int?)>(
             stream: clock.timeStream,
             builder: (context, snapshot) {
-              final time = snapshot.data ?? const Duration(minutes: 3);
+              final data = snapshot.data ?? const (Duration(minutes: 3), null);
               final minutes =
-                  time.inMinutes.remainder(60).toString().padLeft(2, '0');
+                  data.$1.inMinutes.remainder(60).toString().padLeft(2, '0');
               final seconds =
-                  time.inSeconds.remainder(60).toString().padLeft(2, '0');
+                  data.$1.inSeconds.remainder(60).toString().padLeft(2, '0');
               return Text('$minutes:$seconds');
             },
           ),
