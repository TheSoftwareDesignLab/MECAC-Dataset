diff --git a/lib/src/model/engine/evaluation_mixin.dart b/lib/src/model/engine/evaluation_mixin.dart
index cd81ff0c5e..da58f32643 100644
--- a/lib/src/model/engine/evaluation_mixin.dart
+++ b/lib/src/model/engine/evaluation_mixin.dart
@@ -29,7 +29,7 @@ const kRequestEvalDebounceDelay = Duration(milliseconds: 250);
 /// when the cloud evaluation is available. The delay is thus increased to ensure that the socket
 /// 'evalGet/evalHit' round trip gets a chance to complete before starting the local engine, even
 /// with reasonably high network latency.
-const kStartLocalEngineDebounceDelay = Duration(milliseconds: 800);
+const kStartLocalEngineDebounceDelay = Duration(milliseconds: 600);
 
 /// Interface for Notifiers's State that uses [EngineEvaluationMixin].
 abstract class EvaluationMixinState {
diff --git a/lib/src/view/engine/engine_depth.dart b/lib/src/view/engine/engine_depth.dart
index b6badb6a44..90613f9419 100644
--- a/lib/src/view/engine/engine_depth.dart
+++ b/lib/src/view/engine/engine_depth.dart
@@ -3,12 +3,12 @@ import 'dart:math' as math;
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:flutter_spinkit/flutter_spinkit.dart';
 import 'package:lichess_mobile/src/model/common/eval.dart';
 import 'package:lichess_mobile/src/model/engine/engine.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
-import 'package:lichess_mobile/src/widgets/feedback.dart';
 import 'package:lichess_mobile/src/widgets/list.dart';
 import 'package:popover/popover.dart';
 
@@ -19,26 +19,30 @@ class EngineDepth extends ConsumerWidget {
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final (engineName: _, eval: localEval, state: engineState) = ref.watch(
+    final (engineName: engineName, eval: localEval, state: engineState) = ref.watch(
       engineEvaluationProvider,
     );
     final eval = pickBestClientEval(localEval: localEval, savedEval: savedEval);
 
-    const cloudSize = 30.0;
-    const microChipSize = 28.0;
-    const cloudIconAlignment = AlignmentDirectional(0.0, 0.20);
-    final cloudIcon = Icon(
-      Icons.cloud,
-      size: cloudSize,
-      color: ColorScheme.of(context).secondary.withValues(alpha: 0.7),
+    final loadingIndicator = SpinKitFadingFour(
+      color: ColorScheme.of(context).onSecondary.withValues(alpha: 0.7),
+      size: 10,
     );
+
+    const microChipSize = 28.0;
     final iconTextStyle = TextStyle(
       color: ColorScheme.of(context).onSecondary,
       fontFeatures: const [FontFeature.tabularFigures()],
-      fontSize: 12,
+      fontSize: 11,
     );
 
-    return AppBarTextButton(
+    return AppBarIconButton(
+      semanticsLabel: switch (eval) {
+        LocalEval(:final depth) => '$engineName, ${context.l10n.depthX('$depth')}',
+        CloudEval(:final depth) =>
+          '${context.l10n.cloudAnalysis}, ${context.l10n.depthX('$depth')}',
+        _ => context.l10n.loadingEngine,
+      },
       onPressed:
           eval != null
               ? () {
@@ -73,45 +77,39 @@ class EngineDepth extends ConsumerWidget {
                 );
               }
               : null,
-      child: switch (eval) {
-        LocalEval(:final depth) => RepaintBoundary(
+      icon: Badge(
+        offset: const Offset(4, -7),
+        backgroundColor: ColorScheme.of(context).tertiaryContainer,
+        textColor: ColorScheme.of(context).onTertiaryContainer,
+        label: eval is CloudEval ? const Text('CLOUD') : null,
+        textStyle: const TextStyle(fontSize: 8),
+        isLabelVisible: eval is CloudEval,
+        child: AnimatedOpacity(
+          opacity: engineState == EngineState.computing ? 1.0 : 0.7,
+          duration: const Duration(milliseconds: 150),
           child: Stack(
+            alignment: Alignment.center,
             children: [
               CustomPaint(
                 size: const Size(microChipSize, microChipSize),
-                painter: MicroChipPainter(
-                  ColorScheme.of(
-                    context,
-                  ).secondary.withValues(alpha: engineState == EngineState.computing ? 1.0 : 0.7),
-                ),
+                painter: MicroChipPainter(ColorScheme.of(context).secondary),
               ),
               SizedBox(
                 width: microChipSize,
                 height: microChipSize,
-                child: Center(child: Text('${math.min(99, depth)}', style: iconTextStyle)),
+                child: RepaintBoundary(
+                  child: Center(
+                    child:
+                        eval?.depth != null
+                            ? Text('${math.min(99, eval!.depth)}', style: iconTextStyle)
+                            : loadingIndicator,
+                  ),
+                ),
               ),
             ],
           ),
         ),
-        CloudEval(:final depth) => Stack(
-          children: [
-            cloudIcon,
-            SizedBox(
-              width: cloudSize,
-              height: cloudSize,
-              child: Align(
-                alignment: cloudIconAlignment,
-                child: Text('${math.min(99, depth)}', style: iconTextStyle),
-              ),
-            ),
-          ],
-        ),
-        null => const SizedBox(
-          width: microChipSize,
-          height: microChipSize,
-          child: Center(child: threeBounceLoadingIndicator),
-        ),
-      },
+      ),
     );
   }
 }
@@ -132,6 +130,7 @@ class MicroChipPainter extends CustomPainter {
         Paint()
           ..color = color
           ..style = PaintingStyle.fill;
+
     final strokePaint =
         Paint()
           ..color = color
diff --git a/lib/src/view/engine/engine_gauge.dart b/lib/src/view/engine/engine_gauge.dart
index acd4595412..5956ab7f43 100644
--- a/lib/src/view/engine/engine_gauge.dart
+++ b/lib/src/view/engine/engine_gauge.dart
@@ -78,9 +78,17 @@ class _EvalGauge extends StatefulWidget {
   final Eval? eval;
   final Side orientation;
 
-  double get whiteWinningChances => eval?.winningChances(Side.white) ?? 0.0;
-  double get animationValue =>
-      (((whiteWinningChances + 1) * 0.5).abs() * 100).roundToDouble() / 100;
+  double? get whiteWinningChances => eval?.winningChances(Side.white);
+  double? get animationValue =>
+      position.outcome != null
+          ? position.outcome!.winner == null
+              ? 0.5
+              : position.outcome!.winner == Side.white
+              ? 1.0
+              : 0.0
+          : whiteWinningChances != null
+          ? (((whiteWinningChances! + 1) * 0.5).abs() * 100).roundToDouble() / 100
+          : null;
 
   @override
   State<_EvalGauge> createState() => _EvalGaugeState();
@@ -89,10 +97,17 @@ class _EvalGauge extends StatefulWidget {
 class _EvalGaugeState extends State<_EvalGauge> {
   double fromValue = 0.5;
 
+  Eval? oldEval;
+
+  double get toValue => widget.animationValue ?? fromValue;
+
   @override
   void didUpdateWidget(_EvalGauge oldWidget) {
     super.didUpdateWidget(oldWidget);
-    fromValue = oldWidget.animationValue;
+    fromValue = oldWidget.animationValue ?? fromValue;
+    if (oldWidget.eval != null) {
+      oldEval = oldWidget.eval;
+    }
   }
 
   @override
@@ -108,16 +123,7 @@ class _EvalGaugeState extends State<_EvalGauge> {
                 : widget.position.isCheckmate
                 ? context.l10n.checkmate
                 : context.l10n.variantEnding
-            : widget.eval?.evalString;
-
-    final toValue =
-        widget.position.outcome != null
-            ? widget.position.outcome!.winner == null
-                ? 0.5
-                : widget.position.outcome!.winner == Side.white
-                ? 1.0
-                : 0.0
-            : widget.animationValue;
+            : widget.eval?.evalString ?? oldEval?.evalString;
 
     return TweenAnimationBuilder<double>(
       tween: Tween<double>(begin: fromValue, end: toValue),
diff --git a/lib/src/view/engine/engine_lines.dart b/lib/src/view/engine/engine_lines.dart
index 27ad685ceb..f9b92d1625 100644
--- a/lib/src/view/engine/engine_lines.dart
+++ b/lib/src/view/engine/engine_lines.dart
@@ -7,10 +7,11 @@ import 'package:lichess_mobile/src/model/account/account_preferences.dart';
 import 'package:lichess_mobile/src/model/common/eval.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_preferences.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
+import 'package:lichess_mobile/src/styles/styles.dart';
 import 'package:lichess_mobile/src/view/engine/engine_gauge.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
 
-class EngineLines extends ConsumerWidget {
+class EngineLines extends ConsumerStatefulWidget {
   const EngineLines({required this.onTapMove, required this.savedEval, required this.isGameOver});
 
   final void Function(NormalMove move) onTapMove;
@@ -18,22 +19,39 @@ class EngineLines extends ConsumerWidget {
   final bool isGameOver;
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
+  ConsumerState<EngineLines> createState() => _EngineLinesState();
+}
+
+class _EngineLinesState extends ConsumerState<EngineLines> {
+  ClientEval? lastEval;
+
+  @override
+  Widget build(BuildContext context) {
     final numEvalLines = ref.watch(
       engineEvaluationPreferencesProvider.select((p) => p.numEvalLines),
     );
     final localEval = ref.watch(engineEvaluationProvider).eval;
-    final eval = pickBestClientEval(localEval: localEval, savedEval: savedEval);
+    final eval = pickBestClientEval(localEval: localEval, savedEval: widget.savedEval);
+    // save the last eval to display when the current eval is not yet available to avoid flickering
+    if (eval != null) lastEval = eval;
 
     final emptyLines = List.filled(numEvalLines, const Engineline.empty());
 
+    final evalOrLastEval = eval ?? lastEval;
+
     final content =
-        isGameOver
+        widget.isGameOver
             ? emptyLines
-            : (eval != null
-                ? eval.pvs
+            : (evalOrLastEval != null
+                ? evalOrLastEval.pvs
                     .take(numEvalLines)
-                    .map((pv) => Engineline(onTapMove, eval.position, pv))
+                    .map(
+                      (pv) => Engineline(
+                        eval != null ? widget.onTapMove : null,
+                        evalOrLastEval.position,
+                        pv,
+                      ),
+                    )
                     .toList()
                 : emptyLines);
 
@@ -124,6 +142,7 @@ class Engineline extends ConsumerWidget {
                   softWrap: false,
                   style: TextStyle(
                     fontFamily: pieceNotation == PieceNotation.symbol ? 'ChessFont' : null,
+                    color: textShade(context, onTapMove == null ? 0.8 : 1.0),
                   ),
                   overflow: TextOverflow.ellipsis,
                 ),
diff --git a/test/view/engine/engine_depth_test.dart b/test/view/engine/engine_depth_test.dart
index 0a883c3cce..01882666c7 100644
--- a/test/view/engine/engine_depth_test.dart
+++ b/test/view/engine/engine_depth_test.dart
@@ -8,23 +8,9 @@ import 'package:lichess_mobile/src/view/engine/engine_depth.dart';
 
 import 'test_engine_app.dart';
 
-/// Checks if the cloud eval is displayed in the EngineDepth widget by looking for the cloud icon
+/// Checks if the cloud eval label is displayed in the EngineDepth widget
 bool isCloudEvalDisplayed() {
-  return find
-      .descendant(of: find.byType(EngineDepth), matching: find.byIcon(Icons.cloud))
-      .evaluate()
-      .isNotEmpty;
-}
-
-/// Checks if the local engine eval is displayed in the EngineDepth widget by looking for the microchip icon
-bool isLocalEngineEvalDisplayed() {
-  TestAsyncUtils.guardSync();
-  return find
-      .descendant(of: find.byType(EngineDepth), matching: find.byType(CustomPaint))
-      .evaluate()
-      .map((w) => w.widget as CustomPaint)
-      .where((w) => w.painter is MicroChipPainter)
-      .isNotEmpty;
+  return find.widgetWithText(EngineDepth, 'CLOUD').evaluate().isNotEmpty;
 }
 
 void main() {
@@ -43,12 +29,12 @@ void main() {
   // This test group is for the case where the local engine is delayed (which is the case for the
   // first 20 plies of the game)
   group('Local engine is delayed', () {
-    testWidgets('displays a cloud icon if cloud eval is available', (tester) async {
+    testWidgets('displays a CLOUD label if cloud eval is available', (tester) async {
       await makeEngineTestApp(tester);
 
       // displays loading indicator
       expect(
-        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitFadingFour)),
         findsOne,
       );
       await tester.pump(kRequestEvalDebounceDelay);
@@ -59,32 +45,29 @@ void main() {
       await tester.pump(kStartLocalEngineDebounceDelay + kEngineEvalEmissionThrottleDelay);
       // Local engine has not even started
       expect(find.widgetWithText(EngineDepth, '36'), findsOne);
-      expect(isLocalEngineEvalDisplayed(), isFalse);
     });
 
-    testWidgets('Displays a microchip for local engine if cloud eval is not available', (
-      tester,
-    ) async {
+    testWidgets('Starts local engine if cloud eval is not available', (tester) async {
       await makeEngineTestApp(tester, isCloudEvalEnabled: false);
       expect(find.byType(EngineDepth), findsOne);
       // displays loading indicator
       expect(
-        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitFadingFour)),
         findsOne,
       );
 
       await tester.pump(kRequestEvalDebounceDelay);
       // cloud eval is not available, so it still displays loading indicator
       expect(
-        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitFadingFour)),
         findsOne,
       );
-      // local engine eval still not available
-      expect(isLocalEngineEvalDisplayed(), isFalse);
+      expect(isCloudEvalDisplayed(), isFalse);
 
       // Now wait for local engine
-      await tester.pump(kStartLocalEngineDebounceDelay + kEngineEvalEmissionThrottleDelay);
-      expect(isLocalEngineEvalDisplayed(), isTrue);
+      await tester.pump(kStartLocalEngineDebounceDelay);
+      expect(find.widgetWithText(EngineDepth, '15'), findsOne);
+      await tester.pump(kEngineEvalEmissionThrottleDelay);
       expect(find.widgetWithText(EngineDepth, '16'), findsOne);
     });
 
@@ -98,7 +81,6 @@ void main() {
 
       // Wait for local engine eval
       await tester.pump(kStartLocalEngineDebounceDelay);
-      expect(isLocalEngineEvalDisplayed(), isTrue);
       expect(find.widgetWithText(EngineDepth, '15'), findsOne);
 
       // cloud eval will be available 300ms after the local engine eval
@@ -117,7 +99,6 @@ void main() {
 
       // Wait for local engine eval
       await tester.pump(kStartLocalEngineDebounceDelay);
-      expect(isLocalEngineEvalDisplayed(), isTrue);
       expect(find.widgetWithText(EngineDepth, '15'), findsOne);
 
       // Cloud eval will be available 100ms after the first local engine eval emission
@@ -145,7 +126,7 @@ void main() {
 
       // engine not yet started, so it still displays loading indicator
       expect(
-        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitFadingFour)),
         findsOne,
       );
 
