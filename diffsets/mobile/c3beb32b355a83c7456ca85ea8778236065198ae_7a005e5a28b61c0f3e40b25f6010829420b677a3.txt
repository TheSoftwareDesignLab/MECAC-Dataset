diff --git a/lib/src/model/puzzle/puzzle_providers.dart b/lib/src/model/puzzle/puzzle_providers.dart
index 8d2130b3a6..79f432297d 100644
--- a/lib/src/model/puzzle/puzzle_providers.dart
+++ b/lib/src/model/puzzle/puzzle_providers.dart
@@ -84,17 +84,17 @@ class PuzzleHistory extends _$PuzzleHistory {
   StreamSubscription<PuzzleAndResult>? _streamSub;
 
   @override
-  Future<PuzzleHistoryState> build(int max, DateTime before) {
+  Future<PuzzleHistoryState> build() {
     ref.cacheFor(const Duration(seconds: 30));
     ref.onDispose(() => _streamSub?.cancel());
 
-    final stream = connectStream();
+    final stream = connectStream(10, DateTime.now());
 
     return stream.first
         .then((value) => PuzzleHistoryState(historyList: [value]));
   }
 
-  Stream<PuzzleAndResult> connectStream() {
+  Stream<PuzzleAndResult> connectStream(int max, DateTime before) {
     final repo = ref.watch(puzzleRepositoryProvider);
     final stream = repo.puzzleActivity(max, before);
 
@@ -113,6 +113,11 @@ class PuzzleHistory extends _$PuzzleHistory {
 
     return stream;
   }
+
+  Future<void> getNext() async {
+    await _streamSub?.cancel();
+    connectStream(50, state.requireValue.historyList.last.date);
+  }
 }
 
 @freezed
diff --git a/lib/src/ui/puzzle/puzzle_history_screen.dart b/lib/src/ui/puzzle/puzzle_history_screen.dart
index bbae1fd032..19c4a9d9b7 100644
--- a/lib/src/ui/puzzle/puzzle_history_screen.dart
+++ b/lib/src/ui/puzzle/puzzle_history_screen.dart
@@ -19,7 +19,7 @@ import 'package:lichess_mobile/src/utils/l10n_context.dart';
 class PuzzleHistoryWidget extends ConsumerWidget {
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final state = ref.watch(puzzleHistoryProvider(10, DateTime.now()));
+    final state = ref.watch(puzzleHistoryProvider);
 
     return state.when(
       data: (data) {
@@ -52,7 +52,7 @@ class PuzzleHistoryWidget extends ConsumerWidget {
                     final (fen, turn, _) = e.puzzle.preview();
                     return SizedBox(
                       width: boardWidth,
-                      height: boardWidth + 30,
+                      height: boardWidth + 33,
                       child: BoardPreview(
                         orientation: turn.cg,
                         fen: fen,
@@ -131,8 +131,102 @@ class _Body extends ConsumerStatefulWidget {
 }
 
 class _BodyState extends ConsumerState<_Body> {
+  late ScrollController _scrollController;
+  late List<PuzzleAndResult> _historyList;
+  bool _isLoading = false;
+
+  @override
+  void initState() {
+    super.initState();
+    _historyList = [...widget.historyList];
+    _scrollController = ScrollController();
+    _scrollController.addListener(_scrollListener);
+  }
+
+  @override
+  void dispose() {
+    _scrollController.removeListener(_scrollListener);
+    _scrollController.dispose();
+    super.dispose();
+  }
+
+  void _scrollListener() {
+    if (_scrollController.position.pixels ==
+        _scrollController.position.maxScrollExtent) {
+      _loadMore();
+    }
+  }
+
+  Future<void> _loadMore() async {
+    if (_isLoading) return;
+    _isLoading = true;
+    try {
+      await ref.read(puzzleHistoryProvider.notifier).getNext();
+      final newState = ref.read(puzzleHistoryProvider);
+      if (newState.hasValue) {
+        _historyList.addAll(newState.requireValue.historyList);
+      }
+    } catch (e) {
+      // Handle error
+      print('Error loading more puzzles: $e');
+    } finally {
+      _isLoading = false;
+    }
+  }
+
   @override
   Widget build(BuildContext context) {
-    return const SizedBox.shrink();
+    final crossAxisCount =
+        MediaQuery.of(context).size.width > kTabletThreshold ? 4 : 2;
+    final boardWidth = MediaQuery.of(context).size.width / crossAxisCount;
+
+    return ListView.builder(
+      controller: _scrollController,
+      itemCount: _isLoading
+          ? (_historyList.length + 1) ~/ crossAxisCount
+          : _historyList.length ~/ crossAxisCount,
+      itemBuilder: (context, index) {
+        if (index >= _historyList.length) {
+          return const CircularProgressIndicator();
+        } else {
+          return Row(
+            children: _historyList
+                .getRange(
+              index,
+              min(index + crossAxisCount, _historyList.length),
+            )
+                .map(
+              (e) {
+                final (fen, turn, _) = e.puzzle.preview();
+                return SizedBox(
+                  width: boardWidth,
+                  height: boardWidth + 33,
+                  child: BoardPreview(
+                    orientation: turn.cg,
+                    fen: fen,
+                    footer: Padding(
+                      padding: const EdgeInsets.only(top: 8),
+                      child: Row(
+                        children: [
+                          ColoredBox(
+                            color:
+                                e.win ? LichessColors.good : LichessColors.red,
+                            child: Icon(
+                              color: Colors.white,
+                              (e.win) ? Icons.done : Icons.close,
+                            ),
+                          ),
+                          Text(e.puzzle.rating.toString()),
+                        ],
+                      ),
+                    ),
+                  ),
+                );
+              },
+            ).toList(),
+          );
+        }
+      },
+    );
   }
 }
