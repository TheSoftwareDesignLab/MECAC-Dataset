diff --git a/lib/src/model/broadcast/broadcast.dart b/lib/src/model/broadcast/broadcast.dart
index c24629bcd6..5935f3ae44 100644
--- a/lib/src/model/broadcast/broadcast.dart
+++ b/lib/src/model/broadcast/broadcast.dart
@@ -82,22 +82,23 @@ class BroadcastRound with _$BroadcastRound {
   }) = _BroadcastRound;
 }
 
-typedef BroadcastRoundGames = IMap<BroadcastGameId, BroadcastGameSnapshot>;
+typedef BroadcastRoundGames = IMap<BroadcastGameId, BroadcastGame>;
 
 @freezed
-class BroadcastGameSnapshot with _$BroadcastGameSnapshot {
-  const BroadcastGameSnapshot._();
+class BroadcastGame with _$BroadcastGame {
+  const BroadcastGame._();
 
-  const factory BroadcastGameSnapshot({
+  const factory BroadcastGame({
     required BroadcastGameId id,
     required IMap<Side, BroadcastPlayer> players,
     required String fen,
     required Move? lastMove,
     required String? status,
+    required String? pgn,
 
     /// The amount of time that the player whose turn it is has been thinking since his last move
     required Duration? thinkTime,
-  }) = _BroadcastGameSnapshot;
+  }) = _BroadcastGame;
 }
 
 @freezed
diff --git a/lib/src/model/broadcast/broadcast_game_controller.dart b/lib/src/model/broadcast/broadcast_game_controller.dart
deleted file mode 100644
index 031f56337e..0000000000
--- a/lib/src/model/broadcast/broadcast_game_controller.dart
+++ /dev/null
@@ -1,111 +0,0 @@
-import 'dart:async';
-
-import 'package:dartchess/dartchess.dart';
-import 'package:deep_pick/deep_pick.dart';
-import 'package:lichess_mobile/src/model/broadcast/broadcast_providers.dart';
-import 'package:lichess_mobile/src/model/broadcast/broadcast_round_controller.dart';
-import 'package:lichess_mobile/src/model/common/id.dart';
-import 'package:lichess_mobile/src/model/common/node.dart';
-import 'package:lichess_mobile/src/model/common/socket.dart';
-import 'package:lichess_mobile/src/utils/json.dart';
-import 'package:riverpod_annotation/riverpod_annotation.dart';
-
-part 'broadcast_game_controller.g.dart';
-
-@riverpod
-class BroadcastGameController extends _$BroadcastGameController {
-  static Uri broadcastSocketUri(BroadcastRoundId broadcastRoundId) =>
-      Uri(path: 'study/$broadcastRoundId/socket/v6');
-
-  StreamSubscription<SocketEvent>? _subscription;
-
-  late SocketClient _socketClient;
-
-  @override
-  Future<String> build({
-    required BroadcastRoundId broadcastRoundId,
-    required BroadcastGameId broadcastGameId,
-  }) async {
-    _socketClient = ref
-        .watch(socketPoolProvider)
-        .open(BroadcastRoundController.broadcastSocketUri(broadcastRoundId));
-
-    _subscription = _socketClient.stream.listen(_handleSocketEvent);
-
-    ref.onDispose(() {
-      _subscription?.cancel();
-    });
-
-    final pgn = await ref.watch(
-      broadcastGameProvider(
-        roundId: broadcastRoundId,
-        gameId: broadcastGameId,
-      ).future,
-    );
-
-    return pgn;
-  }
-
-  void _handleSocketEvent(SocketEvent event) {
-    if (!state.hasValue) return;
-
-    switch (event.topic) {
-      // Sent when a node is recevied from the broadcast
-      case 'addNode':
-        _handleAddNodeEvent(event);
-      // Sent when a pgn tag changes
-      case 'setTags':
-        _handleSetTagsEvent(event);
-    }
-  }
-
-  void _handleAddNodeEvent(SocketEvent event) {
-    final gameId =
-        pick(event.data, 'p', 'chapterId').asBroadcastGameIdOrThrow();
-
-    // We check that the event we received is for the game we are currently watching
-    if (gameId != broadcastGameId) return;
-
-    // The path of the last and current move of the broadcasted game
-    // Its value is "!" if the path is identical to one of the node that was received
-    final currentPath = pick(event.data, 'relayPath').asUciPathOrThrow();
-
-    // We check that the event we received is for the last move of the game
-    if (currentPath.value != '!') return;
-
-    // The path for the node that was received
-    final path = pick(event.data, 'p', 'path').asUciPathOrThrow();
-    final nodeId = pick(event.data, 'n', 'id').asUciCharPairOrThrow();
-
-    print(state.requireValue);
-
-    print(path + nodeId);
-
-    final newPgn = (Root.fromPgnGame(PgnGame.parsePgn(state.requireValue))
-          ..promoteAt(path + nodeId, toMainline: true))
-        .makePgn();
-
-    print(newPgn);
-
-    state = AsyncData(newPgn);
-  }
-
-  void _handleSetTagsEvent(SocketEvent event) {
-    final gameId = pick(event.data, 'chapterId').asBroadcastGameIdOrThrow();
-
-    // We check that the event we received is for the game we are currently watching
-    if (gameId != broadcastGameId) return;
-
-    final headers = pick(event.data, 'tags').asMapOrThrow<String, String>();
-
-    final pgnGame = PgnGame.parsePgn(state.requireValue);
-
-    final newPgnGame = PgnGame(
-      headers: headers,
-      moves: pgnGame.moves,
-      comments: pgnGame.comments,
-    );
-
-    state = AsyncData(newPgnGame.makePgn());
-  }
-}
diff --git a/lib/src/model/broadcast/broadcast_repository.dart b/lib/src/model/broadcast/broadcast_repository.dart
index 8ab68b7a1d..c870ed1071 100644
--- a/lib/src/model/broadcast/broadcast_repository.dart
+++ b/lib/src/model/broadcast/broadcast_repository.dart
@@ -148,12 +148,12 @@ BroadcastRoundGames _gamesFromPick(
 ) =>
     IMap.fromEntries(pick('games').asListOrThrow(gameFromPick));
 
-MapEntry<BroadcastGameId, BroadcastGameSnapshot> gameFromPick(
+MapEntry<BroadcastGameId, BroadcastGame> gameFromPick(
   RequiredPick pick,
 ) =>
     MapEntry(
       pick('id').asBroadcastGameIdOrThrow(),
-      BroadcastGameSnapshot(
+      BroadcastGame(
         id: pick('id').asBroadcastGameIdOrThrow(),
         players: IMap({
           Side.white: _playerFromPick(pick('players', 0).required()),
@@ -164,6 +164,7 @@ MapEntry<BroadcastGameId, BroadcastGameSnapshot> gameFromPick(
         lastMove: pick('lastMove').asUciMoveOrNull(),
         status: pick('status').asStringOrNull(),
         thinkTime: pick('thinkTime').asDurationFromSecondsOrNull(),
+        pgn: null,
       ),
     );
 
diff --git a/lib/src/model/broadcast/broadcast_round_controller.dart b/lib/src/model/broadcast/broadcast_round_controller.dart
index 6d112b4818..2c458b69c0 100644
--- a/lib/src/model/broadcast/broadcast_round_controller.dart
+++ b/lib/src/model/broadcast/broadcast_round_controller.dart
@@ -41,6 +41,23 @@ class BroadcastRoundController extends _$BroadcastRoundController {
     return games;
   }
 
+  Future<void> setPgn(BroadcastGameId gameId) async {
+    final pgn = await ref.watch(
+      broadcastGameProvider(
+        roundId: broadcastRoundId,
+        gameId: gameId,
+      ).future,
+    );
+    state = AsyncData(
+      state.requireValue.update(
+        gameId,
+        (broadcastGame) => broadcastGame.copyWith(
+          pgn: pgn,
+        ),
+      ),
+    );
+  }
+
   void _handleSocketEvent(SocketEvent event) {
     if (!state.hasValue) return;
 
@@ -54,6 +71,9 @@ class BroadcastRoundController extends _$BroadcastRoundController {
       // Sent when clocks are updated from the broadcast
       case 'clock':
         _handleClockEvent(event);
+      // Sent when a pgn tag changes
+      case 'setTags':
+        _handleSetTagsEvent(event);
     }
   }
 
@@ -75,15 +95,15 @@ class BroadcastRoundController extends _$BroadcastRoundController {
     state = AsyncData(
       state.requireValue.update(
         broadcastGameId,
-        (broadcastGameSnapshot) => broadcastGameSnapshot.copyWith(
+        (broadcastGame) => broadcastGame.copyWith(
           players: IMap(
             {
-              playingSide: broadcastGameSnapshot.players[playingSide]!.copyWith(
+              playingSide: broadcastGame.players[playingSide]!.copyWith(
                 clock: pick(event.data, 'n', 'clock')
                     .asDurationFromCentiSecondsOrNull(),
               ),
               playingSide.opposite:
-                  broadcastGameSnapshot.players[playingSide.opposite]!,
+                  broadcastGame.players[playingSide.opposite]!,
             },
           ),
           fen: fen,
@@ -109,13 +129,13 @@ class BroadcastRoundController extends _$BroadcastRoundController {
     state = AsyncData(
       state.requireValue.update(
         broadcastGameId,
-        (broadcastGameSnapshot) => broadcastGameSnapshot.copyWith(
+        (broadcastsGame) => broadcastsGame.copyWith(
           players: IMap(
             {
-              Side.white: broadcastGameSnapshot.players[Side.white]!.copyWith(
+              Side.white: broadcastsGame.players[Side.white]!.copyWith(
                 clock: whiteClock,
               ),
-              Side.black: broadcastGameSnapshot.players[Side.black]!.copyWith(
+              Side.black: broadcastsGame.players[Side.black]!.copyWith(
                 clock: blackClock,
               ),
             },
@@ -124,4 +144,55 @@ class BroadcastRoundController extends _$BroadcastRoundController {
       ),
     );
   }
+
+  void _handleSetTagsEvent(SocketEvent event) {
+    final gameId = pick(event.data, 'chapterId').asBroadcastGameIdOrThrow();
+
+    if (state.requireValue[gameId]?.pgn == null) return;
+
+    final headers = pick(event.data, 'tags').asMapOrThrow<String, String>();
+
+    final pgnGame = PgnGame.parsePgn(state.requireValue[gameId]!.pgn!);
+
+    final newPgnGame = PgnGame(
+      headers: headers,
+      moves: pgnGame.moves,
+      comments: pgnGame.comments,
+    );
+
+    state = AsyncData(
+      state.requireValue.update(
+        gameId,
+        (broadcastsGame) => broadcastsGame.copyWith(
+          pgn: newPgnGame.makePgn(),
+        ),
+      ),
+    );
+  }
 }
+
+
+// void _handleAddNodeEvent(SocketEvent event) {
+//   final gameId =
+//       pick(event.data, 'p', 'chapterId').asBroadcastGameIdOrThrow();
+
+//   // We check that the event we received is for the game we are currently watching
+//   if (gameId != broadcastGameId) return;
+
+//   // The path of the last and current move of the broadcasted game
+//   // Its value is "!" if the path is identical to one of the node that was received
+//   final currentPath = pick(event.data, 'relayPath').asUciPathOrThrow();
+
+//   // We check that the event we received is for the last move of the game
+//   if (currentPath.value != '!') return;
+
+//   // The path for the node that was received
+//   final path = pick(event.data, 'p', 'path').asUciPathOrThrow();
+//   final nodeId = pick(event.data, 'n', 'id').asUciCharPairOrThrow();
+
+//   final newPgn = (Root.fromPgnGame(PgnGame.parsePgn(state.requireValue))
+//         ..promoteAt(path + nodeId, toMainline: true))
+//       .makePgn();
+
+//   state = AsyncData(newPgn);
+// }
diff --git a/lib/src/view/analysis/analysis_screen.dart b/lib/src/view/analysis/analysis_screen.dart
index 6f7dc14779..e2e51c0e5a 100644
--- a/lib/src/view/analysis/analysis_screen.dart
+++ b/lib/src/view/analysis/analysis_screen.dart
@@ -16,8 +16,10 @@ import 'package:lichess_mobile/src/model/auth/auth_session.dart';
 import 'package:lichess_mobile/src/model/common/chess.dart';
 import 'package:lichess_mobile/src/model/common/eval.dart';
 import 'package:lichess_mobile/src/model/common/http.dart';
+import 'package:lichess_mobile/src/model/common/id.dart';
 import 'package:lichess_mobile/src/model/engine/engine.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
+import 'package:lichess_mobile/src/model/game/game_repository_providers.dart';
 import 'package:lichess_mobile/src/model/game/game_share_service.dart';
 import 'package:lichess_mobile/src/model/settings/brightness.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
@@ -43,75 +45,79 @@ import 'analysis_board.dart';
 import 'analysis_settings.dart';
 import 'tree_view.dart';
 
-typedef OptionsAndPgn = ({AnalysisOptions options, String pgn});
-
-class AnalysisLoadingScreen extends ConsumerWidget {
-  const AnalysisLoadingScreen({
-    required this.pgnAndOptionsProvider,
+class AnalysisScreen extends StatelessWidget {
+  const AnalysisScreen({
+    required this.options,
+    required this.pgnOrId,
     this.title,
   });
 
-  /// The async provider that returns analysis options and pgn.
-  final ProviderListenable<AsyncValue<OptionsAndPgn>> pgnAndOptionsProvider;
+  /// The analysis options.
+  final AnalysisOptions options;
+
+  /// The PGN or game ID to load.
+  final String pgnOrId;
+
+  final String? title;
 
+  @override
+  Widget build(BuildContext context) {
+    return pgnOrId.length == 8 && GameId(pgnOrId).isValid
+        ? _LoadGame(GameId(pgnOrId), options, title)
+        : _LoadedAnalysisScreen(
+            options: options,
+            pgn: pgnOrId,
+            title: title,
+          );
+  }
+}
+
+class _LoadGame extends ConsumerWidget {
+  const _LoadGame(this.gameId, this.options, this.title);
+
+  final AnalysisOptions options;
+  final GameId gameId;
   final String? title;
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final pgnAndOptions = ref.watch(pgnAndOptionsProvider);
-
-    Widget buildPlatformScreen({required Widget child}) =>
-        switch (Theme.of(context).platform) {
-          TargetPlatform.android => _androidBuilder(context, child),
-          TargetPlatform.iOS => _iosBuilder(context, child),
-          _ => throw UnimplementedError(
-              'Unexpected platform ${Theme.of(context).platform}',
-            )
-        };
-
-    return pgnAndOptions.when(
-      data: (pgnAndOptions) => AnalysisScreen(
-        pgn: pgnAndOptions.pgn,
-        options: pgnAndOptions.options,
-        title: title,
-      ),
-      loading: () => buildPlatformScreen(
-          child: const Center(child: CircularProgressIndicator.adaptive())),
-      error: (error, _) => buildPlatformScreen(
-        child: Center(
+    final gameAsync = ref.watch(archivedGameProvider(id: gameId));
+
+    return gameAsync.when(
+      data: (game) {
+        final serverAnalysis =
+            game.white.analysis != null && game.black.analysis != null
+                ? (white: game.white.analysis!, black: game.black.analysis!)
+                : null;
+        return _LoadedAnalysisScreen(
+          options: options.copyWith(
+            id: game.id,
+            opening: game.meta.opening,
+            division: game.meta.division,
+            serverAnalysis: serverAnalysis,
+          ),
+          pgn: game.makePgn(),
+          title: title,
+        );
+      },
+      loading: () => const Center(child: CircularProgressIndicator.adaptive()),
+      error: (error, _) {
+        return Center(
           child: Text('Cannot load game analysis: $error'),
-        ),
-      ),
+        );
+      },
     );
   }
-
-  Widget _androidBuilder(BuildContext context, Widget child) => Scaffold(
-        appBar: AppBar(
-          title: Text(title ?? context.l10n.analysis),
-        ),
-        body: child,
-      );
-
-  Widget _iosBuilder(BuildContext context, Widget child) =>
-      CupertinoPageScaffold(
-        navigationBar: CupertinoNavigationBar(
-          middle: Text(title ?? context.l10n.analysis),
-        ),
-        child: child,
-      );
 }
 
-class AnalysisScreen extends ConsumerWidget {
-  const AnalysisScreen({
+class _LoadedAnalysisScreen extends ConsumerWidget {
+  const _LoadedAnalysisScreen({
     required this.options,
     required this.pgn,
     this.title,
   });
 
-  /// The analysis options.
   final AnalysisOptions options;
-
-  /// The PGN or game ID to load.
   final String pgn;
 
   final String? title;
diff --git a/lib/src/view/board_editor/board_editor_screen.dart b/lib/src/view/board_editor/board_editor_screen.dart
index 577e3fcaaa..7d62fada35 100644
--- a/lib/src/view/board_editor/board_editor_screen.dart
+++ b/lib/src/view/board_editor/board_editor_screen.dart
@@ -364,7 +364,7 @@ class _BottomBar extends ConsumerWidget {
                             context,
                             rootNavigator: true,
                             builder: (context) => AnalysisScreen(
-                              pgn: editorState.pgn!,
+                              pgnOrId: editorState.pgn!,
                               options: AnalysisOptions(
                                 isLocalEvaluationAllowed: true,
                                 variant: Variant.fromPosition,
diff --git a/lib/src/view/broadcast/broadcast_boards_tab.dart b/lib/src/view/broadcast/broadcast_boards_tab.dart
index 8bf9ca78bd..7fe3036305 100644
--- a/lib/src/view/broadcast/broadcast_boards_tab.dart
+++ b/lib/src/view/broadcast/broadcast_boards_tab.dart
@@ -15,8 +15,7 @@ import 'package:lichess_mobile/src/utils/duration.dart';
 import 'package:lichess_mobile/src/utils/lichess_assets.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
-import 'package:lichess_mobile/src/view/analysis/analysis_screen.dart';
-import 'package:lichess_mobile/src/view/broadcast/broadcast_boards_tab_provider.dart';
+import 'package:lichess_mobile/src/view/broadcast/broadcast_game_screen.dart';
 import 'package:lichess_mobile/src/widgets/board_thumbnail.dart';
 import 'package:lichess_mobile/src/widgets/evaluation_bar.dart';
 import 'package:lichess_mobile/src/widgets/shimmer.dart';
@@ -30,8 +29,13 @@ const _kPlayerWidgetPadding = EdgeInsets.symmetric(vertical: 5.0);
 /// A tab that displays the live games of a broadcast round.
 class BroadcastBoardsTab extends ConsumerWidget {
   final BroadcastRoundId roundId;
+  final String title;
 
-  const BroadcastBoardsTab({super.key, required this.roundId});
+  const BroadcastBoardsTab({
+    super.key,
+    required this.roundId,
+    required this.title,
+  });
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
@@ -48,11 +52,15 @@ class BroadcastBoardsTab extends ConsumerWidget {
             : BroadcastPreview(
                 games: games.values.toIList(),
                 roundId: roundId,
+                title: title,
               ),
         loading: () => const Shimmer(
           child: ShimmerLoading(
             isLoading: true,
-            child: BroadcastPreview(roundId: BroadcastRoundId('')),
+            child: BroadcastPreview(
+              roundId: BroadcastRoundId(''),
+              title: '',
+            ),
           ),
         ),
         error: (error, stackTrace) => Center(
@@ -65,9 +73,15 @@ class BroadcastBoardsTab extends ConsumerWidget {
 
 class BroadcastPreview extends ConsumerWidget {
   final BroadcastRoundId roundId;
-  final IList<BroadcastGameSnapshot>? games;
+  final IList<BroadcastGame>? games;
+  final String title;
 
-  const BroadcastPreview({super.key, required this.roundId, this.games});
+  const BroadcastPreview({
+    super.key,
+    required this.roundId,
+    this.games,
+    required this.title,
+  });
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
@@ -118,13 +132,15 @@ class BroadcastPreview extends ConsumerWidget {
 
         return BoardThumbnail(
           onTap: () {
+            ref
+                .read(BroadcastRoundControllerProvider(roundId).notifier)
+                .setPgn(game.id);
             pushPlatformRoute(
               context,
-              builder: (context) => AnalysisLoadingScreen(
-                pgnAndOptionsProvider: broadcastGameAnalysisProvider(
-                  roundId: roundId,
-                  gameId: game.id,
-                ),
+              builder: (context) => BroadcastGameScreen(
+                roundId: roundId,
+                gameId: game.id,
+                title: title,
               ),
             );
           },
diff --git a/lib/src/view/broadcast/broadcast_boards_tab_provider.dart b/lib/src/view/broadcast/broadcast_boards_tab_provider.dart
deleted file mode 100644
index 9522226197..0000000000
--- a/lib/src/view/broadcast/broadcast_boards_tab_provider.dart
+++ /dev/null
@@ -1,33 +0,0 @@
-import 'package:dartchess/dartchess.dart';
-import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
-import 'package:lichess_mobile/src/model/broadcast/broadcast_game_controller.dart';
-import 'package:lichess_mobile/src/model/common/chess.dart';
-import 'package:lichess_mobile/src/model/common/id.dart';
-import 'package:lichess_mobile/src/view/analysis/analysis_screen.dart';
-import 'package:riverpod_annotation/riverpod_annotation.dart';
-
-part 'broadcast_boards_tab_provider.g.dart';
-
-@riverpod
-Future<OptionsAndPgn> broadcastGameAnalysis(
-  BroadcastGameAnalysisRef ref, {
-  required BroadcastRoundId roundId,
-  required BroadcastGameId gameId,
-}) async {
-  final pgn = await ref.watch(
-    broadcastGameControllerProvider(
-      broadcastRoundId: roundId,
-      broadcastGameId: gameId,
-    ).future,
-  );
-
-  return (
-    options: const AnalysisOptions(
-      id: StringId('standalone_analysis'),
-      isLocalEvaluationAllowed: true,
-      orientation: Side.white,
-      variant: Variant.standard,
-    ),
-    pgn: pgn,
-  );
-}
diff --git a/lib/src/view/broadcast/broadcast_game_screen.dart b/lib/src/view/broadcast/broadcast_game_screen.dart
new file mode 100644
index 0000000000..f5e3ee5355
--- /dev/null
+++ b/lib/src/view/broadcast/broadcast_game_screen.dart
@@ -0,0 +1,1509 @@
+import 'dart:async';
+import 'dart:math' as math;
+
+import 'package:collection/collection.dart';
+import 'package:dartchess/dartchess.dart';
+import 'package:fast_immutable_collections/fast_immutable_collections.dart';
+import 'package:fl_chart/fl_chart.dart';
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:flutter_svg/svg.dart';
+import 'package:lichess_mobile/src/constants.dart';
+import 'package:lichess_mobile/src/model/account/account_preferences.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_preferences.dart';
+import 'package:lichess_mobile/src/model/analysis/server_analysis_service.dart';
+import 'package:lichess_mobile/src/model/auth/auth_session.dart';
+import 'package:lichess_mobile/src/model/broadcast/broadcast.dart';
+import 'package:lichess_mobile/src/model/broadcast/broadcast_round_controller.dart';
+import 'package:lichess_mobile/src/model/common/chess.dart';
+import 'package:lichess_mobile/src/model/common/eval.dart';
+import 'package:lichess_mobile/src/model/common/http.dart';
+import 'package:lichess_mobile/src/model/common/id.dart';
+import 'package:lichess_mobile/src/model/engine/engine.dart';
+import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
+import 'package:lichess_mobile/src/model/game/game_share_service.dart';
+import 'package:lichess_mobile/src/model/settings/brightness.dart';
+import 'package:lichess_mobile/src/styles/lichess_icons.dart';
+import 'package:lichess_mobile/src/styles/styles.dart';
+import 'package:lichess_mobile/src/utils/duration.dart';
+import 'package:lichess_mobile/src/utils/l10n_context.dart';
+import 'package:lichess_mobile/src/utils/lichess_assets.dart';
+import 'package:lichess_mobile/src/utils/navigation.dart';
+import 'package:lichess_mobile/src/utils/screen.dart';
+import 'package:lichess_mobile/src/utils/share.dart';
+import 'package:lichess_mobile/src/utils/string.dart';
+import 'package:lichess_mobile/src/view/analysis/analysis_board.dart';
+import 'package:lichess_mobile/src/view/analysis/analysis_settings.dart';
+import 'package:lichess_mobile/src/view/analysis/analysis_share_screen.dart';
+import 'package:lichess_mobile/src/view/analysis/tree_view.dart';
+import 'package:lichess_mobile/src/view/engine/engine_gauge.dart';
+import 'package:lichess_mobile/src/view/opening_explorer/opening_explorer_screen.dart';
+import 'package:lichess_mobile/src/widgets/adaptive_action_sheet.dart';
+import 'package:lichess_mobile/src/widgets/adaptive_bottom_sheet.dart';
+import 'package:lichess_mobile/src/widgets/bottom_bar_button.dart';
+import 'package:lichess_mobile/src/widgets/buttons.dart';
+import 'package:lichess_mobile/src/widgets/feedback.dart';
+import 'package:lichess_mobile/src/widgets/list.dart';
+import 'package:lichess_mobile/src/widgets/platform.dart';
+import 'package:popover/popover.dart';
+
+const _options = AnalysisOptions(
+  id: StringId('standalone_analysis'),
+  isLocalEvaluationAllowed: true,
+  orientation: Side.white,
+  variant: Variant.standard,
+);
+
+class BroadcastGameScreen extends ConsumerWidget {
+  final BroadcastRoundId roundId;
+  final BroadcastGameId gameId;
+  final String title;
+
+  const BroadcastGameScreen({
+    required this.roundId,
+    required this.gameId,
+    required this.title,
+  });
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    return ConsumerPlatformWidget(
+      androidBuilder: _androidBuilder,
+      iosBuilder: _iosBuilder,
+      ref: ref,
+    );
+  }
+
+  Widget _androidBuilder(BuildContext context, WidgetRef ref) {
+    final game = ref.watch(
+      broadcastRoundControllerProvider(
+        roundId,
+      ).select((games) => games.value?[gameId]),
+    );
+    final pgn = game?.pgn;
+
+    return Scaffold(
+      resizeToAvoidBottomInset: false,
+      appBar: AppBar(
+        title: Text(title),
+        actions: [
+          if (pgn != null)
+            _EngineDepth(
+              analysisControllerProvider(pgn, _options),
+            ),
+          AppBarIconButton(
+            onPressed: () => (pgn != null)
+                ? showAdaptiveBottomSheet<void>(
+                    context: context,
+                    isScrollControlled: true,
+                    showDragHandle: true,
+                    isDismissible: true,
+                    builder: (_) => AnalysisSettings(pgn, _options),
+                  )
+                : null,
+            semanticsLabel: context.l10n.settingsSettings,
+            icon: const Icon(Icons.settings),
+          ),
+        ],
+      ),
+      body: (pgn != null)
+          ? _Body(game: game!, options: _options)
+          : const Center(child: CircularProgressIndicator.adaptive()),
+    );
+  }
+
+  Widget _iosBuilder(BuildContext context, WidgetRef ref) {
+    final game = ref.watch(
+      broadcastRoundControllerProvider(
+        roundId,
+      ).select((games) => games.value?[gameId]),
+    );
+    final pgn = game?.pgn;
+
+    return CupertinoPageScaffold(
+      resizeToAvoidBottomInset: false,
+      navigationBar: CupertinoNavigationBar(
+        backgroundColor: Styles.cupertinoScaffoldColor.resolveFrom(context),
+        border: null,
+        padding: Styles.cupertinoAppBarTrailingWidgetPadding,
+        middle: Text(title),
+        trailing: Row(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            if (pgn != null)
+              _EngineDepth(
+                analysisControllerProvider(pgn, _options),
+              ),
+            AppBarIconButton(
+              onPressed: () => (pgn != null)
+                  ? showAdaptiveBottomSheet<void>(
+                      context: context,
+                      isScrollControlled: true,
+                      showDragHandle: true,
+                      isDismissible: true,
+                      builder: (_) => AnalysisSettings(pgn, _options),
+                    )
+                  : null,
+              semanticsLabel: context.l10n.settingsSettings,
+              icon: const Icon(Icons.settings),
+            ),
+          ],
+        ),
+      ),
+      child: (pgn != null)
+          ? _Body(game: game!, options: _options)
+          : const Center(child: CircularProgressIndicator.adaptive()),
+    );
+  }
+}
+
+class _Body extends ConsumerWidget {
+  const _Body({required this.game, required this.options});
+
+  final BroadcastGame game;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(game.pgn!, options);
+    final showEvaluationGauge = ref.watch(
+      analysisPreferencesProvider.select((value) => value.showEvaluationGauge),
+    );
+
+    final isEngineAvailable = ref.watch(
+      ctrlProvider.select(
+        (value) => value.isEngineAvailable,
+      ),
+    );
+
+    final hasEval =
+        ref.watch(ctrlProvider.select((value) => value.hasAvailableEval));
+
+    final showAnalysisSummary = ref.watch(
+      ctrlProvider.select((value) => value.displayMode == DisplayMode.summary),
+    );
+
+    final pov = ref.watch(ctrlProvider.select((value) => value.pov));
+
+    return Column(
+      children: [
+        Expanded(
+          child: SafeArea(
+            bottom: false,
+            child: LayoutBuilder(
+              builder: (context, constraints) {
+                final aspectRatio = constraints.biggest.aspectRatio;
+                final defaultBoardSize = constraints.biggest.shortestSide;
+                final isTablet = isTabletOrLarger(context);
+                final remainingHeight =
+                    constraints.maxHeight - defaultBoardSize;
+                final isSmallScreen =
+                    remainingHeight < kSmallRemainingHeightLeftBoardThreshold;
+                final boardSize = isTablet || isSmallScreen
+                    ? defaultBoardSize - kTabletBoardTableSidePadding * 2
+                    : defaultBoardSize;
+
+                return aspectRatio > 1
+                    ? Row(
+                        mainAxisSize: MainAxisSize.max,
+                        children: [
+                          Padding(
+                            padding: const EdgeInsets.only(
+                              left: kTabletBoardTableSidePadding,
+                              top: kTabletBoardTableSidePadding,
+                              bottom: kTabletBoardTableSidePadding,
+                            ),
+                            child: Row(
+                              children: [
+                                _AnalysisBoardPlayersAndClocks(
+                                  game,
+                                  pov,
+                                  boardSize,
+                                  isTablet: isTablet,
+                                ),
+                                if (hasEval && showEvaluationGauge) ...[
+                                  const SizedBox(width: 4.0),
+                                  _EngineGaugeVertical(ctrlProvider),
+                                ],
+                              ],
+                            ),
+                          ),
+                          Flexible(
+                            fit: FlexFit.loose,
+                            child: Column(
+                              mainAxisAlignment: MainAxisAlignment.start,
+                              children: [
+                                if (isEngineAvailable)
+                                  _EngineLines(
+                                    ctrlProvider,
+                                    isLandscape: true,
+                                  ),
+                                Expanded(
+                                  child: PlatformCard(
+                                    margin: const EdgeInsets.all(
+                                      kTabletBoardTableSidePadding,
+                                    ),
+                                    semanticContainer: false,
+                                    child: showAnalysisSummary
+                                        ? ServerAnalysisSummary(
+                                            game.pgn!,
+                                            options,
+                                          )
+                                        : AnalysisTreeView(
+                                            game.pgn!,
+                                            options,
+                                            Orientation.landscape,
+                                          ),
+                                  ),
+                                ),
+                              ],
+                            ),
+                          ),
+                        ],
+                      )
+                    : Column(
+                        mainAxisAlignment: MainAxisAlignment.center,
+                        mainAxisSize: MainAxisSize.max,
+                        crossAxisAlignment: CrossAxisAlignment.center,
+                        children: [
+                          _ColumnTopTable(ctrlProvider),
+                          if (isTablet)
+                            Padding(
+                              padding: const EdgeInsets.all(
+                                kTabletBoardTableSidePadding,
+                              ),
+                              child: _AnalysisBoardPlayersAndClocks(
+                                game,
+                                pov,
+                                boardSize,
+                                isTablet: isTablet,
+                              ),
+                            )
+                          else
+                            _AnalysisBoardPlayersAndClocks(
+                              game,
+                              pov,
+                              boardSize,
+                              isTablet: isTablet,
+                            ),
+                          if (showAnalysisSummary)
+                            Expanded(
+                              child: ServerAnalysisSummary(game.pgn!, options),
+                            )
+                          else
+                            Expanded(
+                              child: AnalysisTreeView(
+                                game.pgn!,
+                                options,
+                                Orientation.portrait,
+                              ),
+                            ),
+                        ],
+                      );
+              },
+            ),
+          ),
+        ),
+        _BottomBar(pgn: game.pgn!, options: options),
+      ],
+    );
+  }
+}
+
+enum _PlayerWidgetSide { bottom, top }
+
+class _AnalysisBoardPlayersAndClocks extends StatelessWidget {
+  final BroadcastGame game;
+  final Side pov;
+  final double boardSize;
+  final bool isTablet;
+
+  const _AnalysisBoardPlayersAndClocks(
+    this.game,
+    this.pov,
+    this.boardSize, {
+    required this.isTablet,
+  });
+
+  @override
+  Widget build(BuildContext context) {
+    final playingSide = Setup.parseFen(game.fen).turn;
+
+    return Column(
+      children: [
+        _PlayerWidget(
+          width: boardSize,
+          player: game.players[pov.opposite]!,
+          gameStatus: game.status,
+          thinkTime: game.thinkTime,
+          pov: pov.opposite,
+          playingSide: playingSide,
+          side: _PlayerWidgetSide.top,
+        ),
+        AnalysisBoard(
+          game.pgn!,
+          _options,
+          boardSize,
+          isTablet: isTablet,
+        ),
+        _PlayerWidget(
+          width: boardSize,
+          player: game.players[pov]!,
+          gameStatus: game.status,
+          thinkTime: game.thinkTime,
+          pov: pov,
+          playingSide: playingSide,
+          side: _PlayerWidgetSide.bottom,
+        ),
+      ],
+    );
+  }
+}
+
+class _PlayerWidget extends StatelessWidget {
+  const _PlayerWidget({
+    required this.width,
+    required this.player,
+    required this.gameStatus,
+    required this.thinkTime,
+    required this.pov,
+    required this.playingSide,
+    required this.side,
+  });
+
+  final BroadcastPlayer player;
+  final String? gameStatus;
+  final Duration? thinkTime;
+  final Side pov;
+  final Side playingSide;
+  final double width;
+  final _PlayerWidgetSide side;
+
+  @override
+  Widget build(BuildContext context) {
+    return SizedBox(
+      width: width,
+      child: Card(
+        margin: EdgeInsets.zero,
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.only(
+            topLeft: Radius.circular(side == _PlayerWidgetSide.top ? 8 : 0),
+            topRight: Radius.circular(side == _PlayerWidgetSide.top ? 8 : 0),
+            bottomLeft:
+                Radius.circular(side == _PlayerWidgetSide.bottom ? 8 : 0),
+            bottomRight:
+                Radius.circular(side == _PlayerWidgetSide.bottom ? 8 : 0),
+          ),
+        ),
+        child: Padding(
+          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
+          child: Row(
+            mainAxisAlignment: MainAxisAlignment.spaceBetween,
+            children: [
+              Expanded(
+                child: Row(
+                  children: [
+                    if (gameStatus != null && gameStatus != '*') ...[
+                      Text(
+                        (gameStatus == '½-½')
+                            ? '½'
+                            : (gameStatus == '1-0')
+                                ? pov == Side.white
+                                    ? '1'
+                                    : '0'
+                                : pov == Side.black
+                                    ? '1'
+                                    : '0',
+                        style: const TextStyle()
+                            .copyWith(fontWeight: FontWeight.bold),
+                      ),
+                      const SizedBox(width: 15),
+                    ],
+                    if (player.federation != null) ...[
+                      Consumer(
+                        builder: (context, widgetRef, _) {
+                          return SvgPicture.network(
+                            lichessFideFedSrc(player.federation!),
+                            height: 12,
+                            httpClient: widgetRef.read(defaultClientProvider),
+                          );
+                        },
+                      ),
+                    ],
+                    const SizedBox(width: 5),
+                    if (player.title != null) ...[
+                      Text(
+                        player.title!,
+                        style: const TextStyle().copyWith(
+                          color: context.lichessColors.brag,
+                          fontWeight: FontWeight.bold,
+                        ),
+                      ),
+                      const SizedBox(width: 5),
+                    ],
+                    Text(
+                      player.name,
+                      style: const TextStyle().copyWith(
+                        fontWeight: FontWeight.bold,
+                      ),
+                    ),
+                    const SizedBox(width: 5),
+                    Text(player.rating.toString(), style: const TextStyle()),
+                  ],
+                ),
+              ),
+              if (player.clock != null)
+                (pov == playingSide)
+                    ? _Clock(
+                        clock: player.clock! - (thinkTime ?? Duration.zero),
+                      )
+                    : Text(
+                        player.clock!.toHoursMinutesSeconds(),
+                        style: const TextStyle(
+                          fontFeatures: [FontFeature.tabularFigures()],
+                        ),
+                      ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class _Clock extends StatefulWidget {
+  const _Clock({required this.clock});
+
+  final Duration clock;
+
+  @override
+  _ClockState createState() => _ClockState();
+}
+
+class _ClockState extends State<_Clock> {
+  Timer? _timer;
+  late Duration _clock;
+
+  @override
+  void initState() {
+    super.initState();
+    _clock = widget.clock;
+    if (_clock.inSeconds <= 0) {
+      _clock = Duration.zero;
+      return;
+    }
+    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
+      setState(() {
+        _clock = _clock - const Duration(seconds: 1);
+      });
+      if (_clock.inSeconds == 0) {
+        timer.cancel();
+        return;
+      }
+    });
+  }
+
+  @override
+  void dispose() {
+    _timer?.cancel();
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Text(
+      _clock.toHoursMinutesSeconds(),
+      style: TextStyle(
+        color: Colors.orange[900],
+        fontFeatures: const [FontFeature.tabularFigures()],
+      ),
+    );
+  }
+}
+
+class _EngineGaugeVertical extends ConsumerWidget {
+  const _EngineGaugeVertical(this.ctrlProvider);
+
+  final AnalysisControllerProvider ctrlProvider;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final analysisState = ref.watch(ctrlProvider);
+
+    return Container(
+      clipBehavior: Clip.hardEdge,
+      decoration: BoxDecoration(
+        borderRadius: BorderRadius.circular(4.0),
+      ),
+      child: EngineGauge(
+        displayMode: EngineGaugeDisplayMode.vertical,
+        params: analysisState.engineGaugeParams,
+      ),
+    );
+  }
+}
+
+class _ColumnTopTable extends ConsumerWidget {
+  const _ColumnTopTable(this.ctrlProvider);
+
+  final AnalysisControllerProvider ctrlProvider;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final analysisState = ref.watch(ctrlProvider);
+    final showEvaluationGauge = ref.watch(
+      analysisPreferencesProvider.select((p) => p.showEvaluationGauge),
+    );
+
+    return analysisState.hasAvailableEval
+        ? Column(
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              if (showEvaluationGauge)
+                EngineGauge(
+                  displayMode: EngineGaugeDisplayMode.horizontal,
+                  params: analysisState.engineGaugeParams,
+                ),
+              if (analysisState.isEngineAvailable)
+                _EngineLines(ctrlProvider, isLandscape: false),
+            ],
+          )
+        : kEmptyWidget;
+  }
+}
+
+class _EngineLines extends ConsumerWidget {
+  const _EngineLines(this.ctrlProvider, {required this.isLandscape});
+  final AnalysisControllerProvider ctrlProvider;
+  final bool isLandscape;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final analysisState = ref.watch(ctrlProvider);
+    final numEvalLines = ref.watch(
+      analysisPreferencesProvider.select(
+        (p) => p.numEvalLines,
+      ),
+    );
+    final engineEval = ref.watch(engineEvaluationProvider).eval;
+    final eval = engineEval ?? analysisState.currentNode.eval;
+
+    final emptyLines = List.filled(
+      numEvalLines,
+      _Engineline.empty(ctrlProvider),
+    );
+
+    final content = !analysisState.position.isGameOver
+        ? (eval != null
+            ? eval.pvs
+                .take(numEvalLines)
+                .map(
+                  (pv) => _Engineline(ctrlProvider, eval.position, pv),
+                )
+                .toList()
+            : emptyLines)
+        : emptyLines;
+
+    if (content.length < numEvalLines) {
+      final padding = List.filled(
+        numEvalLines - content.length,
+        _Engineline.empty(ctrlProvider),
+      );
+      content.addAll(padding);
+    }
+
+    return Padding(
+      padding: EdgeInsets.symmetric(
+        vertical: isLandscape ? kTabletBoardTableSidePadding : 0.0,
+        horizontal: isLandscape ? kTabletBoardTableSidePadding : 0.0,
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        mainAxisAlignment: MainAxisAlignment.start,
+        children: content,
+      ),
+    );
+  }
+}
+
+class _Engineline extends ConsumerWidget {
+  const _Engineline(
+    this.ctrlProvider,
+    this.fromPosition,
+    this.pvData,
+  );
+
+  const _Engineline.empty(this.ctrlProvider)
+      : pvData = const PvData(moves: IListConst([])),
+        fromPosition = Chess.initial;
+
+  final AnalysisControllerProvider ctrlProvider;
+  final Position fromPosition;
+  final PvData pvData;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    if (pvData.moves.isEmpty) {
+      return const SizedBox(
+        height: kEvalGaugeSize,
+        child: SizedBox.shrink(),
+      );
+    }
+
+    final pieceNotation = ref.watch(pieceNotationProvider).maybeWhen(
+          data: (value) => value,
+          orElse: () => defaultAccountPreferences.pieceNotation,
+        );
+
+    final lineBuffer = StringBuffer();
+    int ply = fromPosition.ply + 1;
+    pvData.sanMoves(fromPosition).forEachIndexed((i, s) {
+      lineBuffer.write(
+        ply.isOdd
+            ? '${(ply / 2).ceil()}. $s '
+            : i == 0
+                ? '${(ply / 2).ceil()}... $s '
+                : '$s ',
+      );
+      ply += 1;
+    });
+
+    final brightness = ref.watch(currentBrightnessProvider);
+
+    final evalString = pvData.evalString;
+    return AdaptiveInkWell(
+      onTap: () => ref
+          .read(ctrlProvider.notifier)
+          .onUserMove(Move.parse(pvData.moves[0])!),
+      child: SizedBox(
+        height: kEvalGaugeSize,
+        child: Padding(
+          padding: const EdgeInsets.all(2.0),
+          child: Row(
+            mainAxisAlignment: MainAxisAlignment.start,
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.center,
+            children: [
+              Container(
+                decoration: BoxDecoration(
+                  color: pvData.winningSide == Side.black
+                      ? EngineGauge.backgroundColor(context, brightness)
+                      : EngineGauge.valueColor(context, brightness),
+                  borderRadius: BorderRadius.circular(4.0),
+                ),
+                padding: const EdgeInsets.symmetric(
+                  horizontal: 4.0,
+                  vertical: 2.0,
+                ),
+                child: Text(
+                  evalString,
+                  style: TextStyle(
+                    color: pvData.winningSide == Side.black
+                        ? Colors.white
+                        : Colors.black,
+                    fontSize: kEvalGaugeFontSize,
+                    fontWeight: FontWeight.w600,
+                  ),
+                ),
+              ),
+              const SizedBox(width: 8.0),
+              Expanded(
+                child: Text(
+                  lineBuffer.toString(),
+                  maxLines: 1,
+                  softWrap: false,
+                  style: TextStyle(
+                    fontFamily: pieceNotation == PieceNotation.symbol
+                        ? 'ChessFont'
+                        : null,
+                  ),
+                  overflow: TextOverflow.ellipsis,
+                ),
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class _BottomBar extends ConsumerWidget {
+  const _BottomBar({
+    required this.pgn,
+    required this.options,
+  });
+
+  final String pgn;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final canGoBack =
+        ref.watch(ctrlProvider.select((value) => value.canGoBack));
+    final canGoNext =
+        ref.watch(ctrlProvider.select((value) => value.canGoNext));
+    final displayMode =
+        ref.watch(ctrlProvider.select((value) => value.displayMode));
+    final canShowGameSummary =
+        ref.watch(ctrlProvider.select((value) => value.canShowGameSummary));
+
+    return Container(
+      color: Theme.of(context).platform == TargetPlatform.iOS
+          ? CupertinoTheme.of(context).barBackgroundColor
+          : Theme.of(context).bottomAppBarTheme.color,
+      child: SafeArea(
+        top: false,
+        child: SizedBox(
+          height: kBottomBarHeight,
+          child: Row(
+            mainAxisAlignment: MainAxisAlignment.spaceAround,
+            children: [
+              Expanded(
+                child: BottomBarButton(
+                  label: context.l10n.menu,
+                  onTap: () {
+                    _showAnalysisMenu(context, ref);
+                  },
+                  icon: Icons.menu,
+                ),
+              ),
+              if (canShowGameSummary)
+                Expanded(
+                  child: BottomBarButton(
+                    label: displayMode == DisplayMode.summary
+                        ? 'Moves'
+                        : 'Summary',
+                    onTap: () {
+                      ref.read(ctrlProvider.notifier).toggleDisplayMode();
+                    },
+                    icon: displayMode == DisplayMode.summary
+                        ? LichessIcons.flow_cascade
+                        : Icons.area_chart,
+                  ),
+                ),
+              Expanded(
+                child: BottomBarButton(
+                  label: context.l10n.openingExplorer,
+                  onTap: () => pushPlatformRoute(
+                    context,
+                    builder: (_) => OpeningExplorerScreen(
+                      pgn: pgn,
+                      options: options,
+                    ),
+                  ),
+                  icon: Icons.explore,
+                ),
+              ),
+              Expanded(
+                child: RepeatButton(
+                  onLongPress: canGoBack ? () => _moveBackward(ref) : null,
+                  child: BottomBarButton(
+                    key: const ValueKey('goto-previous'),
+                    onTap: canGoBack ? () => _moveBackward(ref) : null,
+                    label: 'Previous',
+                    icon: CupertinoIcons.chevron_back,
+                    showTooltip: false,
+                  ),
+                ),
+              ),
+              Expanded(
+                child: RepeatButton(
+                  onLongPress: canGoNext ? () => _moveForward(ref) : null,
+                  child: BottomBarButton(
+                    key: const ValueKey('goto-next'),
+                    icon: CupertinoIcons.chevron_forward,
+                    label: context.l10n.next,
+                    onTap: canGoNext ? () => _moveForward(ref) : null,
+                    showTooltip: false,
+                  ),
+                ),
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+
+  void _moveForward(WidgetRef ref) =>
+      ref.read(analysisControllerProvider(pgn, options).notifier).userNext();
+  void _moveBackward(WidgetRef ref) => ref
+      .read(analysisControllerProvider(pgn, options).notifier)
+      .userPrevious();
+
+  Future<void> _showAnalysisMenu(BuildContext context, WidgetRef ref) {
+    return showAdaptiveActionSheet(
+      context: context,
+      actions: [
+        BottomSheetAction(
+          makeLabel: (context) => Text(context.l10n.flipBoard),
+          onPressed: (context) {
+            ref
+                .read(analysisControllerProvider(pgn, options).notifier)
+                .toggleBoard();
+          },
+        ),
+        BottomSheetAction(
+          makeLabel: (context) => Text(context.l10n.mobileShareGamePGN),
+          onPressed: (_) {
+            pushPlatformRoute(
+              context,
+              title: context.l10n.studyShareAndExport,
+              builder: (_) => AnalysisShareScreen(pgn: pgn, options: options),
+            );
+          },
+        ),
+        BottomSheetAction(
+          makeLabel: (context) => Text(context.l10n.mobileSharePositionAsFEN),
+          onPressed: (_) {
+            launchShareDialog(
+              context,
+              text: ref
+                  .read(analysisControllerProvider(pgn, options))
+                  .position
+                  .fen,
+            );
+          },
+        ),
+        if (options.gameAnyId != null)
+          BottomSheetAction(
+            makeLabel: (context) =>
+                Text(context.l10n.screenshotCurrentPosition),
+            onPressed: (_) async {
+              final gameId = options.gameAnyId!.gameId;
+              final state = ref.read(analysisControllerProvider(pgn, options));
+              try {
+                final image =
+                    await ref.read(gameShareServiceProvider).screenshotPosition(
+                          gameId,
+                          options.orientation,
+                          state.position.fen,
+                          state.lastMove,
+                        );
+                if (context.mounted) {
+                  launchShareDialog(
+                    context,
+                    files: [image],
+                    subject: context.l10n.puzzleFromGameLink(
+                      lichessUri('/$gameId').toString(),
+                    ),
+                  );
+                }
+              } catch (e) {
+                if (context.mounted) {
+                  showPlatformSnackbar(
+                    context,
+                    'Failed to get GIF',
+                    type: SnackBarType.error,
+                  );
+                }
+              }
+            },
+          ),
+      ],
+    );
+  }
+}
+
+class _EngineDepth extends ConsumerWidget {
+  const _EngineDepth(this.ctrlProvider);
+
+  final AnalysisControllerProvider ctrlProvider;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final isEngineAvailable = ref.watch(
+      ctrlProvider.select(
+        (value) => value.isEngineAvailable,
+      ),
+    );
+    final currentNode = ref.watch(
+      ctrlProvider.select((value) => value.currentNode),
+    );
+    final depth = ref.watch(
+          engineEvaluationProvider.select((value) => value.eval?.depth),
+        ) ??
+        currentNode.eval?.depth;
+
+    return isEngineAvailable && depth != null
+        ? AppBarTextButton(
+            onPressed: () {
+              showPopover(
+                context: context,
+                bodyBuilder: (context) {
+                  return _StockfishInfo(currentNode);
+                },
+                direction: PopoverDirection.top,
+                width: 240,
+                backgroundColor:
+                    Theme.of(context).platform == TargetPlatform.android
+                        ? Theme.of(context).dialogBackgroundColor
+                        : CupertinoDynamicColor.resolve(
+                            CupertinoColors.tertiarySystemBackground,
+                            context,
+                          ),
+                transitionDuration: Duration.zero,
+                popoverTransitionBuilder: (_, child) => child,
+              );
+            },
+            child: RepaintBoundary(
+              child: Container(
+                width: 20.0,
+                height: 20.0,
+                padding: const EdgeInsets.all(2.0),
+                decoration: BoxDecoration(
+                  color: Theme.of(context).platform == TargetPlatform.android
+                      ? Theme.of(context).colorScheme.secondary
+                      : CupertinoTheme.of(context).primaryColor,
+                  borderRadius: BorderRadius.circular(4.0),
+                ),
+                child: FittedBox(
+                  fit: BoxFit.contain,
+                  child: Text(
+                    '${math.min(99, depth)}',
+                    style: TextStyle(
+                      color: Theme.of(context).platform ==
+                              TargetPlatform.android
+                          ? Theme.of(context).colorScheme.onSecondary
+                          : CupertinoTheme.of(context).primaryContrastingColor,
+                      fontFeatures: const [
+                        FontFeature.tabularFigures(),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+            ),
+          )
+        : const SizedBox.shrink();
+  }
+}
+
+class _StockfishInfo extends ConsumerWidget {
+  const _StockfishInfo(this.currentNode);
+
+  final AnalysisCurrentNode currentNode;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final (engineName: engineName, eval: eval, state: engineState) =
+        ref.watch(engineEvaluationProvider);
+
+    final currentEval = eval ?? currentNode.eval;
+
+    final knps = engineState == EngineState.computing
+        ? ', ${eval?.knps.round()}kn/s'
+        : '';
+    final depth = currentEval?.depth ?? 0;
+    final maxDepth = math.max(depth, kMaxEngineDepth);
+
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      children: [
+        PlatformListTile(
+          leading: Image.asset(
+            'assets/images/stockfish/icon.png',
+            width: 44,
+            height: 44,
+          ),
+          title: Text(engineName),
+          subtitle: Text(
+            context.l10n.depthX(
+              '$depth/$maxDepth$knps',
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+}
+
+class ServerAnalysisSummary extends ConsumerWidget {
+  const ServerAnalysisSummary(this.pgn, this.options);
+
+  final String pgn;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final playersAnalysis =
+        ref.watch(ctrlProvider.select((value) => value.playersAnalysis));
+    final pgnHeaders =
+        ref.watch(ctrlProvider.select((value) => value.pgnHeaders));
+    final currentGameAnalysis = ref.watch(currentAnalysisProvider);
+
+    return playersAnalysis != null
+        ? ListView(
+            children: [
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Padding(
+                  padding: EdgeInsets.only(top: 16.0),
+                  child: WaitingForServerAnalysis(),
+                ),
+              AcplChart(pgn, options),
+              Center(
+                child: SizedBox(
+                  width: math.min(MediaQuery.sizeOf(context).width, 500),
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                    child: Table(
+                      defaultVerticalAlignment:
+                          TableCellVerticalAlignment.middle,
+                      columnWidths: const {
+                        0: FlexColumnWidth(1),
+                        1: FlexColumnWidth(1),
+                        2: FlexColumnWidth(1),
+                      },
+                      children: [
+                        TableRow(
+                          decoration: const BoxDecoration(
+                            border: Border(
+                              bottom: BorderSide(color: Colors.grey),
+                            ),
+                          ),
+                          children: [
+                            _SummaryPlayerName(Side.white, pgnHeaders),
+                            Center(
+                              child: Text(
+                                pgnHeaders.get('Result') ?? '',
+                                style: const TextStyle(
+                                  fontWeight: FontWeight.bold,
+                                ),
+                              ),
+                            ),
+                            _SummaryPlayerName(Side.black, pgnHeaders),
+                          ],
+                        ),
+                        if (playersAnalysis.white.accuracy != null &&
+                            playersAnalysis.black.accuracy != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                '${playersAnalysis.white.accuracy}%',
+                              ),
+                              Center(
+                                heightFactor: 1.8,
+                                child: Text(
+                                  context.l10n.accuracy,
+                                  softWrap: true,
+                                ),
+                              ),
+                              _SummaryNumber(
+                                '${playersAnalysis.black.accuracy}%',
+                              ),
+                            ],
+                          ),
+                        for (final item in [
+                          (
+                            playersAnalysis.white.inaccuracies.toString(),
+                            context.l10n
+                                .nbInaccuracies(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.inaccuracies.toString()
+                          ),
+                          (
+                            playersAnalysis.white.mistakes.toString(),
+                            context.l10n
+                                .nbMistakes(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.mistakes.toString()
+                          ),
+                          (
+                            playersAnalysis.white.blunders.toString(),
+                            context.l10n
+                                .nbBlunders(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.blunders.toString()
+                          ),
+                        ])
+                          TableRow(
+                            children: [
+                              _SummaryNumber(item.$1),
+                              Center(
+                                heightFactor: 1.2,
+                                child: Text(
+                                  item.$2,
+                                  softWrap: true,
+                                ),
+                              ),
+                              _SummaryNumber(item.$3),
+                            ],
+                          ),
+                        if (playersAnalysis.white.acpl != null &&
+                            playersAnalysis.black.acpl != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                playersAnalysis.white.acpl.toString(),
+                              ),
+                              Center(
+                                heightFactor: 1.5,
+                                child: Text(
+                                  context.l10n.averageCentipawnLoss,
+                                  softWrap: true,
+                                  textAlign: TextAlign.center,
+                                ),
+                              ),
+                              _SummaryNumber(
+                                playersAnalysis.black.acpl.toString(),
+                              ),
+                            ],
+                          ),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+            ],
+          )
+        : Column(
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              const Spacer(),
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Center(
+                  child: Padding(
+                    padding: EdgeInsets.symmetric(vertical: 16.0),
+                    child: WaitingForServerAnalysis(),
+                  ),
+                )
+              else
+                Center(
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(vertical: 16.0),
+                    child: Builder(
+                      builder: (context) {
+                        Future<void>? pendingRequest;
+                        return StatefulBuilder(
+                          builder: (context, setState) {
+                            return FutureBuilder<void>(
+                              future: pendingRequest,
+                              builder: (context, snapshot) {
+                                return SecondaryButton(
+                                  semanticsLabel:
+                                      context.l10n.requestAComputerAnalysis,
+                                  onPressed: ref.watch(authSessionProvider) ==
+                                          null
+                                      ? () {
+                                          showPlatformSnackbar(
+                                            context,
+                                            context
+                                                .l10n.youNeedAnAccountToDoThat,
+                                          );
+                                        }
+                                      : snapshot.connectionState ==
+                                              ConnectionState.waiting
+                                          ? null
+                                          : () {
+                                              setState(() {
+                                                pendingRequest = ref
+                                                    .read(ctrlProvider.notifier)
+                                                    .requestServerAnalysis()
+                                                    .catchError((Object e) {
+                                                  if (context.mounted) {
+                                                    showPlatformSnackbar(
+                                                      context,
+                                                      e.toString(),
+                                                      type: SnackBarType.error,
+                                                    );
+                                                  }
+                                                });
+                                              });
+                                            },
+                                  child: Text(
+                                    context.l10n.requestAComputerAnalysis,
+                                  ),
+                                );
+                              },
+                            );
+                          },
+                        );
+                      },
+                    ),
+                  ),
+                ),
+              const Spacer(),
+            ],
+          );
+  }
+}
+
+class WaitingForServerAnalysis extends StatelessWidget {
+  const WaitingForServerAnalysis({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.center,
+      mainAxisSize: MainAxisSize.max,
+      children: [
+        Image.asset(
+          'assets/images/stockfish/icon.png',
+          width: 30,
+          height: 30,
+        ),
+        const SizedBox(width: 8.0),
+        Text(context.l10n.waitingForAnalysis),
+        const SizedBox(width: 8.0),
+        const CircularProgressIndicator.adaptive(),
+      ],
+    );
+  }
+}
+
+class _SummaryNumber extends StatelessWidget {
+  const _SummaryNumber(this.data);
+  final String data;
+
+  @override
+  Widget build(BuildContext context) {
+    return Center(
+      child: Text(
+        data,
+        softWrap: true,
+      ),
+    );
+  }
+}
+
+class _SummaryPlayerName extends StatelessWidget {
+  const _SummaryPlayerName(this.side, this.pgnHeaders);
+  final Side side;
+  final IMap<String, String> pgnHeaders;
+
+  @override
+  Widget build(BuildContext context) {
+    final playerTitle = side == Side.white
+        ? pgnHeaders.get('WhiteTitle')
+        : pgnHeaders.get('BlackTitle');
+    final playerName = side == Side.white
+        ? pgnHeaders.get('White') ?? context.l10n.white
+        : pgnHeaders.get('Black') ?? context.l10n.black;
+
+    final brightness = Theme.of(context).brightness;
+
+    return TableCell(
+      verticalAlignment: TableCellVerticalAlignment.top,
+      child: Center(
+        child: Padding(
+          padding: const EdgeInsets.only(bottom: 5),
+          child: Column(
+            children: [
+              Icon(
+                side == Side.white
+                    ? brightness == Brightness.light
+                        ? CupertinoIcons.circle
+                        : CupertinoIcons.circle_filled
+                    : brightness == Brightness.light
+                        ? CupertinoIcons.circle_filled
+                        : CupertinoIcons.circle,
+                size: 14,
+              ),
+              Text(
+                '${playerTitle != null ? '$playerTitle ' : ''}$playerName',
+                style: const TextStyle(
+                  fontWeight: FontWeight.bold,
+                ),
+                textAlign: TextAlign.center,
+                softWrap: true,
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class AcplChart extends ConsumerWidget {
+  const AcplChart(this.pgn, this.options);
+
+  final String pgn;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final mainLineColor = Theme.of(context).colorScheme.secondary;
+    // yes it looks like below/above are inverted in fl_chart
+    final brightness = Theme.of(context).brightness;
+    final white = Theme.of(context).colorScheme.surfaceContainerHighest;
+    final black = Theme.of(context).colorScheme.outline;
+    // yes it looks like below/above are inverted in fl_chart
+    final belowLineColor = brightness == Brightness.light ? white : black;
+    final aboveLineColor = brightness == Brightness.light ? black : white;
+
+    VerticalLine phaseVerticalBar(double x, String label) => VerticalLine(
+          x: x,
+          color: const Color(0xFF707070),
+          strokeWidth: 0.5,
+          label: VerticalLineLabel(
+            style: TextStyle(
+              fontSize: 10,
+              color: Theme.of(context)
+                  .textTheme
+                  .labelMedium
+                  ?.color
+                  ?.withOpacity(0.3),
+            ),
+            labelResolver: (line) => label,
+            padding: const EdgeInsets.only(right: 1),
+            alignment: Alignment.topRight,
+            direction: LabelDirection.vertical,
+            show: true,
+          ),
+        );
+
+    final data = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.acplChartData),
+    );
+
+    final rootPly = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.root.position.ply),
+    );
+
+    final currentNode = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.currentNode),
+    );
+
+    final isOnMainline = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.isOnMainline),
+    );
+
+    if (data == null) {
+      return const SizedBox.shrink();
+    }
+
+    final spots = data
+        .mapIndexed(
+          (i, e) => FlSpot(i.toDouble(), e.winningChances(Side.white)),
+        )
+        .toList(growable: false);
+
+    final divisionLines = <VerticalLine>[];
+
+    if (options.division?.middlegame != null) {
+      if (options.division!.middlegame! > 0) {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.opening));
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.middlegame! - 1,
+            context.l10n.middlegame,
+          ),
+        );
+      } else {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.middlegame));
+      }
+    }
+
+    if (options.division?.endgame != null) {
+      if (options.division!.endgame! > 0) {
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.endgame! - 1,
+            context.l10n.endgame,
+          ),
+        );
+      } else {
+        divisionLines.add(
+          phaseVerticalBar(
+            0.0,
+            context.l10n.endgame,
+          ),
+        );
+      }
+    }
+    return Center(
+      child: AspectRatio(
+        aspectRatio: 2.5,
+        child: Padding(
+          padding: const EdgeInsets.all(16.0),
+          child: LineChart(
+            LineChartData(
+              lineTouchData: LineTouchData(
+                enabled: false,
+                touchCallback:
+                    (FlTouchEvent event, LineTouchResponse? touchResponse) {
+                  if (event is FlTapDownEvent ||
+                      event is FlPanUpdateEvent ||
+                      event is FlLongPressMoveUpdate) {
+                    final touchX = event.localPosition!.dx;
+                    final chartWidth = context.size!.width -
+                        32; // Insets on both sides of the chart of 16
+                    final minX = spots.first.x;
+                    final maxX = spots.last.x;
+                    final touchXDataValue =
+                        minX + (touchX / chartWidth) * (maxX - minX);
+                    final closestSpot = spots.reduce(
+                      (a, b) => (a.x - touchXDataValue).abs() <
+                              (b.x - touchXDataValue).abs()
+                          ? a
+                          : b,
+                    );
+                    final closestNodeIndex = closestSpot.x.round();
+                    ref
+                        .read(analysisControllerProvider(pgn, options).notifier)
+                        .jumpToNthNodeOnMainline(closestNodeIndex);
+                  }
+                },
+              ),
+              minY: -1.0,
+              maxY: 1.0,
+              lineBarsData: [
+                LineChartBarData(
+                  spots: spots,
+                  isCurved: false,
+                  barWidth: 1,
+                  color: mainLineColor.withOpacity(0.7),
+                  aboveBarData: BarAreaData(
+                    show: true,
+                    color: aboveLineColor,
+                    applyCutOffY: true,
+                  ),
+                  belowBarData: BarAreaData(
+                    show: true,
+                    color: belowLineColor,
+                    applyCutOffY: true,
+                  ),
+                  dotData: const FlDotData(
+                    show: false,
+                  ),
+                ),
+              ],
+              extraLinesData: ExtraLinesData(
+                verticalLines: [
+                  if (isOnMainline)
+                    VerticalLine(
+                      x: (currentNode.position.ply - 1 - rootPly).toDouble(),
+                      color: mainLineColor,
+                      strokeWidth: 1.0,
+                    ),
+                  ...divisionLines,
+                ],
+              ),
+              gridData: const FlGridData(show: false),
+              borderData: FlBorderData(show: false),
+              titlesData: const FlTitlesData(show: false),
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/view/broadcast/broadcast_screen.dart b/lib/src/view/broadcast/broadcast_screen.dart
index a3fcb102e4..979cdc737d 100644
--- a/lib/src/view/broadcast/broadcast_screen.dart
+++ b/lib/src/view/broadcast/broadcast_screen.dart
@@ -95,7 +95,10 @@ class _AndroidScreenState extends State<_AndroidScreen>
         controller: _tabController,
         children: <Widget>[
           BroadcastOverviewTab(tournamentId: _selectedTournamentId),
-          BroadcastBoardsTab(roundId: _selectedRoundId),
+          BroadcastBoardsTab(
+            roundId: _selectedRoundId,
+            title: widget.broadcast.title,
+          ),
         ],
       ),
       bottomNavigationBar: BottomAppBar(
@@ -175,7 +178,10 @@ class _CupertinoScreenState extends State<_CupertinoScreen> {
           Expanded(
             child: _selectedSegment == _ViewMode.overview
                 ? BroadcastOverviewTab(tournamentId: _selectedTournamentId)
-                : BroadcastBoardsTab(roundId: _selectedRoundId),
+                : BroadcastBoardsTab(
+                    roundId: _selectedRoundId,
+                    title: widget.broadcast.title,
+                  ),
           ),
           _IOSTournamentAndRoundSelector(
             tournamentId: _selectedTournamentId,
diff --git a/lib/src/view/correspondence/offline_correspondence_game_screen.dart b/lib/src/view/correspondence/offline_correspondence_game_screen.dart
index 71da4ce456..426ff94aac 100644
--- a/lib/src/view/correspondence/offline_correspondence_game_screen.dart
+++ b/lib/src/view/correspondence/offline_correspondence_game_screen.dart
@@ -286,7 +286,7 @@ class _BodyState extends ConsumerState<_Body> {
                         pushPlatformRoute(
                           context,
                           builder: (_) => AnalysisScreen(
-                            pgn: game.makePgn(),
+                            pgnOrId: game.makePgn(),
                             options: AnalysisOptions(
                               isLocalEvaluationAllowed: false,
                               variant: game.variant,
diff --git a/lib/src/view/game/archived_game_screen.dart b/lib/src/view/game/archived_game_screen.dart
index c8bdfc8699..a6493d7d5c 100644
--- a/lib/src/view/game/archived_game_screen.dart
+++ b/lib/src/view/game/archived_game_screen.dart
@@ -294,7 +294,7 @@ class _BottomBar extends ConsumerWidget {
                             context,
                             builder: (context) => AnalysisScreen(
                               title: context.l10n.gameAnalysis,
-                              pgn: game.makePgn(),
+                              pgnOrId: game.makePgn(),
                               options: AnalysisOptions(
                                 isLocalEvaluationAllowed: true,
                                 variant: gameData.variant,
diff --git a/lib/src/view/game/game_body.dart b/lib/src/view/game/game_body.dart
index 97e8af92ad..322c7e0528 100644
--- a/lib/src/view/game/game_body.dart
+++ b/lib/src/view/game/game_body.dart
@@ -550,7 +550,7 @@ class _GameBottomBar extends ConsumerWidget {
                   pushPlatformRoute(
                     context,
                     builder: (_) => AnalysisScreen(
-                      pgn: gameState.analysisPgn,
+                      pgnOrId: gameState.analysisPgn,
                       options: gameState.analysisOptions,
                       title: context.l10n.gameAnalysis,
                     ),
@@ -700,7 +700,7 @@ class _GameBottomBar extends ConsumerWidget {
               pushPlatformRoute(
                 context,
                 builder: (_) => AnalysisScreen(
-                  pgn: gameState.analysisPgn,
+                  pgnOrId: gameState.analysisPgn,
                   options: gameState.analysisOptions.copyWith(
                     isLocalEvaluationAllowed: false,
                   ),
diff --git a/lib/src/view/game/game_list_tile.dart b/lib/src/view/game/game_list_tile.dart
index 3a4e9b9799..89dffb101b 100644
--- a/lib/src/view/game/game_list_tile.dart
+++ b/lib/src/view/game/game_list_tile.dart
@@ -3,6 +3,7 @@ import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:intl/intl.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
 import 'package:lichess_mobile/src/model/common/http.dart';
 import 'package:lichess_mobile/src/model/common/id.dart';
 import 'package:lichess_mobile/src/model/game/archived_game.dart';
@@ -10,13 +11,11 @@ import 'package:lichess_mobile/src/model/game/game_share_service.dart';
 import 'package:lichess_mobile/src/model/game/game_status.dart';
 import 'package:lichess_mobile/src/styles/lichess_colors.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
-import 'package:lichess_mobile/src/utils/current_locale.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/share.dart';
 import 'package:lichess_mobile/src/view/analysis/analysis_screen.dart';
 import 'package:lichess_mobile/src/view/game/archived_game_screen.dart';
-import 'package:lichess_mobile/src/view/game/game_list_tile_providers.dart';
 import 'package:lichess_mobile/src/view/game/game_screen.dart';
 import 'package:lichess_mobile/src/view/game/status_l10n.dart';
 import 'package:lichess_mobile/src/widgets/adaptive_bottom_sheet.dart';
@@ -26,6 +25,8 @@ import 'package:lichess_mobile/src/widgets/list.dart';
 import 'package:lichess_mobile/src/widgets/user_full_name.dart';
 import 'package:timeago/timeago.dart' as timeago;
 
+final _dateFormatter = DateFormat.yMMMd(Intl.getCurrentLocale()).add_Hm();
+
 /// A list tile that shows game info.
 class GameListTile extends StatelessWidget {
   const GameListTile({
@@ -109,8 +110,6 @@ class _ContextMenu extends ConsumerWidget {
     final orientation = mySide;
 
     final customColors = Theme.of(context).extension<CustomColors>();
-    final dateFormatter =
-        ref.withLocale((locale) => DateFormat.yMMMd(locale).add_Hm());
 
     return DraggableScrollableSheet(
       initialChildSize: .7,
@@ -179,7 +178,7 @@ class _ContextMenu extends ConsumerWidget {
                                         ),
                                       ),
                                       Text(
-                                        dateFormatter.format(game.lastMoveAt),
+                                        _dateFormatter.format(game.lastMoveAt),
                                         style: TextStyle(
                                           color: textShade(
                                             context,
@@ -239,12 +238,15 @@ class _ContextMenu extends ConsumerWidget {
                     ? () {
                         pushPlatformRoute(
                           context,
-                          builder: (context) => AnalysisLoadingScreen(
-                            pgnAndOptionsProvider: archivedGameAnalysisProvider(
-                              id: game.id,
+                          builder: (context) => AnalysisScreen(
+                            title: context.l10n.gameAnalysis,
+                            pgnOrId: game.id.value,
+                            options: AnalysisOptions(
+                              isLocalEvaluationAllowed: true,
+                              variant: game.variant,
                               orientation: orientation,
+                              id: game.id,
                             ),
-                            title: context.l10n.gameAnalysis,
                           ),
                         );
                       }
diff --git a/lib/src/view/game/game_list_tile_providers.dart b/lib/src/view/game/game_list_tile_providers.dart
deleted file mode 100644
index 517931c002..0000000000
--- a/lib/src/view/game/game_list_tile_providers.dart
+++ /dev/null
@@ -1,34 +0,0 @@
-import 'package:dartchess/dartchess.dart';
-import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
-import 'package:lichess_mobile/src/model/common/id.dart';
-import 'package:lichess_mobile/src/model/game/game_repository_providers.dart';
-import 'package:lichess_mobile/src/view/analysis/analysis_screen.dart';
-import 'package:riverpod_annotation/riverpod_annotation.dart';
-
-part 'game_list_tile_providers.g.dart';
-
-@riverpod
-Future<OptionsAndPgn> archivedGameAnalysis(
-  ArchivedGameAnalysisRef ref, {
-  required GameId id,
-  required Side orientation,
-}) async {
-  final game = await ref.watch(archivedGameProvider(id: id).future);
-  final serverAnalysis =
-      game.white.analysis != null && game.black.analysis != null
-          ? (white: game.white.analysis!, black: game.black.analysis!)
-          : null;
-
-  return (
-    options: AnalysisOptions(
-      id: game.id,
-      isLocalEvaluationAllowed: true,
-      orientation: orientation,
-      variant: game.meta.variant,
-      opening: game.meta.opening,
-      division: game.meta.division,
-      serverAnalysis: serverAnalysis,
-    ),
-    pgn: game.makePgn(),
-  );
-}
diff --git a/lib/src/view/game/game_result_dialog.dart b/lib/src/view/game/game_result_dialog.dart
index d219a18dc2..4c3dd5da43 100644
--- a/lib/src/view/game/game_result_dialog.dart
+++ b/lib/src/view/game/game_result_dialog.dart
@@ -211,7 +211,7 @@ class _GameEndDialogState extends ConsumerState<GameResultDialog> {
               pushPlatformRoute(
                 context,
                 builder: (_) => AnalysisScreen(
-                  pgn: gameState.analysisPgn,
+                  pgnOrId: gameState.analysisPgn,
                   options: gameState.analysisOptions,
                   title: context.l10n.gameAnalysis,
                 ),
diff --git a/lib/src/view/puzzle/puzzle_history_screen.dart b/lib/src/view/puzzle/puzzle_history_screen.dart
index 2f6af5037f..be900aaea4 100644
--- a/lib/src/view/puzzle/puzzle_history_screen.dart
+++ b/lib/src/view/puzzle/puzzle_history_screen.dart
@@ -10,7 +10,6 @@ import 'package:lichess_mobile/src/model/puzzle/puzzle_activity.dart';
 import 'package:lichess_mobile/src/model/puzzle/puzzle_angle.dart';
 import 'package:lichess_mobile/src/model/puzzle/puzzle_theme.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
-import 'package:lichess_mobile/src/utils/current_locale.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
@@ -20,6 +19,8 @@ import 'package:lichess_mobile/src/widgets/feedback.dart';
 import 'package:lichess_mobile/src/widgets/platform.dart';
 import 'package:timeago/timeago.dart' as timeago;
 
+final _dateFormatter = DateFormat.yMMMd(Intl.getCurrentLocale());
+
 class PuzzleHistoryScreen extends StatelessWidget {
   @override
   Widget build(BuildContext context) {
@@ -127,7 +128,6 @@ class _BodyState extends ConsumerState<_Body> {
   @override
   Widget build(BuildContext context) {
     final historyState = ref.watch(puzzleActivityProvider);
-    final dateFormatter = ref.withLocale((locale) => DateFormat.yMMMd(locale));
 
     return historyState.when(
       data: (state) {
@@ -182,7 +182,7 @@ class _BodyState extends ConsumerState<_Body> {
               );
             } else if (element is DateTime) {
               final title = DateTime.now().difference(element).inDays >= 15
-                  ? dateFormatter.format(element)
+                  ? _dateFormatter.format(element)
                   : timeago.format(element);
               return Padding(
                 padding: const EdgeInsets.only(left: _kPuzzlePadding)
diff --git a/lib/src/view/puzzle/puzzle_screen.dart b/lib/src/view/puzzle/puzzle_screen.dart
index ce3a5188e6..c92902c0d5 100644
--- a/lib/src/view/puzzle/puzzle_screen.dart
+++ b/lib/src/view/puzzle/puzzle_screen.dart
@@ -536,7 +536,7 @@ class _BottomBar extends ConsumerWidget {
               context,
               builder: (context) => AnalysisScreen(
                 title: context.l10n.analysis,
-                pgn: ref.read(ctrlProvider.notifier).makePgn(),
+                pgnOrId: ref.read(ctrlProvider.notifier).makePgn(),
                 options: AnalysisOptions(
                   isLocalEvaluationAllowed: true,
                   variant: Variant.standard,
diff --git a/lib/src/view/puzzle/streak_screen.dart b/lib/src/view/puzzle/streak_screen.dart
index e053991e29..cbf343815c 100644
--- a/lib/src/view/puzzle/streak_screen.dart
+++ b/lib/src/view/puzzle/streak_screen.dart
@@ -319,7 +319,7 @@ class _BottomBar extends ConsumerWidget {
                         context,
                         builder: (context) => AnalysisScreen(
                           title: context.l10n.analysis,
-                          pgn: ref.read(ctrlProvider.notifier).makePgn(),
+                          pgnOrId: ref.read(ctrlProvider.notifier).makePgn(),
                           options: AnalysisOptions(
                             isLocalEvaluationAllowed: true,
                             variant: Variant.standard,
diff --git a/lib/src/view/tools/load_position_screen.dart b/lib/src/view/tools/load_position_screen.dart
index 75375b90b5..58e8a8e203 100644
--- a/lib/src/view/tools/load_position_screen.dart
+++ b/lib/src/view/tools/load_position_screen.dart
@@ -104,7 +104,7 @@ class _BodyState extends State<_Body> {
                             context,
                             rootNavigator: true,
                             builder: (context) => AnalysisScreen(
-                              pgn: parsedInput!.pgn,
+                              pgnOrId: parsedInput!.pgn,
                               options: parsedInput!.options,
                             ),
                           )
diff --git a/lib/src/view/tools/tools_tab_screen.dart b/lib/src/view/tools/tools_tab_screen.dart
index 3ce37fc2ea..97a6562c6f 100644
--- a/lib/src/view/tools/tools_tab_screen.dart
+++ b/lib/src/view/tools/tools_tab_screen.dart
@@ -123,7 +123,7 @@ class _Body extends StatelessWidget {
                 context,
                 rootNavigator: true,
                 builder: (context) => const AnalysisScreen(
-                  pgn: '',
+                  pgnOrId: '',
                   options: AnalysisOptions(
                     isLocalEvaluationAllowed: true,
                     variant: Variant.standard,
diff --git a/test/view/analysis/analysis_screen_test.dart b/test/view/analysis/analysis_screen_test.dart
index c59047353a..45cc239ca9 100644
--- a/test/view/analysis/analysis_screen_test.dart
+++ b/test/view/analysis/analysis_screen_test.dart
@@ -32,7 +32,7 @@ void main() {
       final app = await buildTestApp(
         tester,
         home: AnalysisScreen(
-          pgn: sanMoves,
+          pgnOrId: sanMoves,
           options: AnalysisOptions(
             isLocalEvaluationAllowed: false,
             variant: Variant.standard,
@@ -59,7 +59,7 @@ void main() {
       final app = await buildTestApp(
         tester,
         home: AnalysisScreen(
-          pgn: sanMoves,
+          pgnOrId: sanMoves,
           options: AnalysisOptions(
             isLocalEvaluationAllowed: false,
             variant: Variant.standard,
