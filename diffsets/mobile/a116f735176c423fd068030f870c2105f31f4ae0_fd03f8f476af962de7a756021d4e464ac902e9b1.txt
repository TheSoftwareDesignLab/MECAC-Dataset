diff --git a/lib/src/model/analysis/analysis_preferences.dart b/lib/src/model/analysis/analysis_preferences.dart
index 8e1e380284..4cfc0e1daa 100644
--- a/lib/src/model/analysis/analysis_preferences.dart
+++ b/lib/src/model/analysis/analysis_preferences.dart
@@ -56,14 +56,6 @@ class AnalysisPreferences extends _$AnalysisPreferences {
     );
   }
 
-  Future<void> toggleOpeningExplorer() {
-    return _save(
-      state.copyWith(
-        showOpeningExplorer: !state.showOpeningExplorer,
-      ),
-    );
-  }
-
   Future<void> toggleShowBestMoveArrow() {
     return _save(
       state.copyWith(
@@ -110,7 +102,6 @@ class AnalysisPrefState with _$AnalysisPrefState {
     required bool showBestMoveArrow,
     required bool showAnnotations,
     required bool showPgnComments,
-    required bool showOpeningExplorer,
     @Assert('numEvalLines >= 1 && numEvalLines <= 3') required int numEvalLines,
     @Assert('numEngineCores >= 1 && numEngineCores <= maxEngineCores')
     required int numEngineCores,
@@ -122,7 +113,6 @@ class AnalysisPrefState with _$AnalysisPrefState {
     showBestMoveArrow: true,
     showAnnotations: true,
     showPgnComments: true,
-    showOpeningExplorer: false,
     numEvalLines: 2,
     numEngineCores: defaultEngineCores,
   );
diff --git a/lib/src/view/analysis/analysis_board.dart b/lib/src/view/analysis/analysis_board.dart
new file mode 100644
index 0000000000..c7592d6dbe
--- /dev/null
+++ b/lib/src/view/analysis/analysis_board.dart
@@ -0,0 +1,199 @@
+import 'dart:math' as math;
+import 'dart:ui';
+
+import 'package:chessground/chessground.dart' as cg;
+import 'package:collection/collection.dart';
+import 'package:dartchess/dartchess.dart';
+import 'package:fast_immutable_collections/fast_immutable_collections.dart';
+import 'package:flutter/widgets.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:lichess_mobile/src/constants.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_preferences.dart';
+import 'package:lichess_mobile/src/model/common/chess.dart';
+import 'package:lichess_mobile/src/model/common/eval.dart';
+import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
+import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
+import 'package:lichess_mobile/src/utils/chessground_compat.dart';
+import 'package:lichess_mobile/src/view/analysis/annotations.dart';
+
+class AnalysisBoard extends ConsumerStatefulWidget {
+  final String pgn;
+
+  final AnalysisOptions options;
+  final double boardSize;
+  final bool isTablet;
+  const AnalysisBoard(
+    this.pgn,
+    this.options,
+    this.boardSize, {
+    required this.isTablet,
+  });
+
+  @override
+  ConsumerState<AnalysisBoard> createState() => _BoardState();
+}
+
+class _BoardState extends ConsumerState<AnalysisBoard> {
+  ISet<cg.Shape> userShapes = ISet();
+
+  @override
+  Widget build(BuildContext context) {
+    final ctrlProvider = analysisControllerProvider(widget.pgn, widget.options);
+    final analysisState = ref.watch(ctrlProvider);
+    final boardPrefs = ref.watch(boardPreferencesProvider);
+    final showBestMoveArrow = ref.watch(
+      analysisPreferencesProvider.select(
+        (value) => value.showBestMoveArrow,
+      ),
+    );
+    final showAnnotationsOnBoard = ref.watch(
+      analysisPreferencesProvider.select((value) => value.showAnnotations),
+    );
+
+    final evalBestMoves = ref.watch(
+      engineEvaluationProvider.select((s) => s.eval?.bestMoves),
+    );
+
+    final currentNode = analysisState.currentNode;
+    final annotation = makeAnnotation(currentNode.nags);
+
+    final bestMoves = evalBestMoves ?? currentNode.eval?.bestMoves;
+
+    final sanMove = currentNode.sanMove;
+
+    final ISet<cg.Shape> bestMoveShapes = showBestMoveArrow &&
+            analysisState.isEngineAvailable &&
+            bestMoves != null
+        ? _computeBestMoveShapes(bestMoves)
+        : ISet();
+
+    return cg.Board(
+      size: widget.boardSize,
+      onMove: (move, {isDrop, isPremove}) =>
+          ref.read(ctrlProvider.notifier).onUserMove(Move.fromUci(move.uci)!),
+      data: cg.BoardData(
+        orientation: analysisState.pov.cg,
+        interactableSide: analysisState.position.isGameOver
+            ? cg.InteractableSide.none
+            : analysisState.position.turn == Side.white
+                ? cg.InteractableSide.white
+                : cg.InteractableSide.black,
+        fen: analysisState.position.fen,
+        isCheck: boardPrefs.boardHighlights && analysisState.position.isCheck,
+        lastMove: analysisState.lastMove?.cg,
+        sideToMove: analysisState.position.turn.cg,
+        validMoves: analysisState.validMoves,
+        shapes: userShapes.union(bestMoveShapes),
+        annotations:
+            showAnnotationsOnBoard && sanMove != null && annotation != null
+                ? altCastles.containsKey(sanMove.move.uci)
+                    ? IMap({
+                        Move.fromUci(altCastles[sanMove.move.uci]!)!.cg.to:
+                            annotation,
+                      })
+                    : IMap({sanMove.move.cg.to: annotation})
+                : null,
+      ),
+      settings: cg.BoardSettings(
+        pieceAssets: boardPrefs.pieceSet.assets,
+        colorScheme: boardPrefs.boardTheme.colors,
+        showValidMoves: boardPrefs.showLegalMoves,
+        showLastMove: boardPrefs.boardHighlights,
+        enableCoordinates: boardPrefs.coordinates,
+        animationDuration: boardPrefs.pieceAnimationDuration,
+        borderRadius: widget.isTablet
+            ? const BorderRadius.all(Radius.circular(4.0))
+            : BorderRadius.zero,
+        boxShadow: widget.isTablet ? boardShadows : const <BoxShadow>[],
+        drawShape: cg.DrawShapeOptions(
+          enable: true,
+          onCompleteShape: _onCompleteShape,
+          onClearShapes: _onClearShapes,
+        ),
+        pieceShiftMethod: boardPrefs.pieceShiftMethod,
+      ),
+    );
+  }
+
+  ISet<cg.Shape> _computeBestMoveShapes(IList<MoveWithWinningChances> moves) {
+    // Scale down all moves with index > 0 based on how much worse their winning chances are compared to the best move
+    // (assume moves are ordered by their winning chances, so index==0 is the best move)
+    double scaleArrowAgainstBestMove(int index) {
+      const minScale = 0.15;
+      const maxScale = 1.0;
+      const winningDiffScaleFactor = 2.5;
+
+      final bestMove = moves[0];
+      final winningDiffComparedToBestMove =
+          bestMove.winningChances - moves[index].winningChances;
+      // Force minimum scale if the best move is significantly better than this move
+      if (winningDiffComparedToBestMove > 0.3) {
+        return minScale;
+      }
+      return clampDouble(
+        math.max(
+          minScale,
+          maxScale - winningDiffScaleFactor * winningDiffComparedToBestMove,
+        ),
+        0,
+        1,
+      );
+    }
+
+    return ISet(
+      moves.mapIndexed(
+        (i, m) {
+          final move = m.move;
+          // Same colors as in the Web UI with a slightly different opacity
+          // The best move has a different color than the other moves
+          final color = Color((i == 0) ? 0x66003088 : 0x664A4A4A);
+          switch (move) {
+            case NormalMove(from: _, to: _, promotion: final promRole):
+              return [
+                cg.Arrow(
+                  color: color,
+                  orig: move.cg.from,
+                  dest: move.cg.to,
+                  scale: scaleArrowAgainstBestMove(i),
+                ),
+                if (promRole != null)
+                  cg.PieceShape(
+                    color: color,
+                    orig: move.cg.to,
+                    role: promRole.cg,
+                  ),
+              ];
+            case DropMove(role: final role, to: _):
+              return [
+                cg.PieceShape(
+                  color: color,
+                  orig: move.cg.to,
+                  role: role.cg,
+                ),
+              ];
+          }
+        },
+      ).expand((e) => e),
+    );
+  }
+
+  void _onClearShapes() {
+    setState(() {
+      userShapes = ISet();
+    });
+  }
+
+  void _onCompleteShape(cg.Shape shape) {
+    if (userShapes.any((element) => element == shape)) {
+      setState(() {
+        userShapes = userShapes.remove(shape);
+      });
+      return;
+    } else {
+      setState(() {
+        userShapes = userShapes.add(shape);
+      });
+    }
+  }
+}
diff --git a/lib/src/view/analysis/analysis_screen.dart b/lib/src/view/analysis/analysis_screen.dart
index cbcad01889..ac5fde5e11 100644
--- a/lib/src/view/analysis/analysis_screen.dart
+++ b/lib/src/view/analysis/analysis_screen.dart
@@ -1,7 +1,5 @@
 import 'dart:math' as math;
-import 'dart:ui';
 
-import 'package:chessground/chessground.dart' as cg;
 import 'package:collection/collection.dart';
 import 'package:dartchess/dartchess.dart';
 import 'package:fast_immutable_collections/fast_immutable_collections.dart';
@@ -9,12 +7,10 @@ import 'package:fl_chart/fl_chart.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:intl/intl.dart';
 import 'package:lichess_mobile/src/constants.dart';
 import 'package:lichess_mobile/src/model/account/account_preferences.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_preferences.dart';
-import 'package:lichess_mobile/src/model/analysis/opening_explorer_repository.dart';
 import 'package:lichess_mobile/src/model/analysis/server_analysis_service.dart';
 import 'package:lichess_mobile/src/model/auth/auth_session.dart';
 import 'package:lichess_mobile/src/model/common/chess.dart';
@@ -25,11 +21,9 @@ import 'package:lichess_mobile/src/model/engine/engine.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
 import 'package:lichess_mobile/src/model/game/game_repository_providers.dart';
 import 'package:lichess_mobile/src/model/game/game_share_service.dart';
-import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
 import 'package:lichess_mobile/src/model/settings/brightness.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
-import 'package:lichess_mobile/src/utils/chessground_compat.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
@@ -45,18 +39,192 @@ import 'package:lichess_mobile/src/widgets/platform.dart';
 import 'package:popover/popover.dart';
 
 import '../../utils/share.dart';
+import 'analysis_board.dart';
 import 'analysis_settings.dart';
 import 'analysis_share_screen.dart';
-import 'annotations.dart';
 import 'tree_view.dart';
 
-class AnalysisScreen extends StatelessWidget {
-  const AnalysisScreen({
-    required this.options,
-    required this.pgnOrId,
-    this.title,
-  });
+class AcplChart extends ConsumerWidget {
+  final String pgn;
+
+  final AnalysisOptions options;
+  const AcplChart(this.pgn, this.options);
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final mainLineColor = Theme.of(context).colorScheme.secondary;
+    // yes it looks like below/above are inverted in fl_chart
+    final brightness = Theme.of(context).brightness;
+    final white = Theme.of(context).colorScheme.surfaceContainerHighest;
+    final black = Theme.of(context).colorScheme.outline;
+    // yes it looks like below/above are inverted in fl_chart
+    final belowLineColor = brightness == Brightness.light ? white : black;
+    final aboveLineColor = brightness == Brightness.light ? black : white;
+
+    VerticalLine phaseVerticalBar(double x, String label) => VerticalLine(
+          x: x,
+          color: const Color(0xFF707070),
+          strokeWidth: 0.5,
+          label: VerticalLineLabel(
+            style: TextStyle(
+              fontSize: 10,
+              color: Theme.of(context)
+                  .textTheme
+                  .labelMedium
+                  ?.color
+                  ?.withOpacity(0.3),
+            ),
+            labelResolver: (line) => label,
+            padding: const EdgeInsets.only(right: 1),
+            alignment: Alignment.topRight,
+            direction: LabelDirection.vertical,
+            show: true,
+          ),
+        );
+
+    final data = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.acplChartData),
+    );
+
+    final rootPly = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.root.position.ply),
+    );
+
+    final currentNode = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.currentNode),
+    );
+
+    final isOnMainline = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.isOnMainline),
+    );
+
+    if (data == null) {
+      return const SizedBox.shrink();
+    }
+
+    final spots = data
+        .mapIndexed(
+          (i, e) => FlSpot(i.toDouble(), e.winningChances(Side.white)),
+        )
+        .toList(growable: false);
+
+    final divisionLines = <VerticalLine>[];
+
+    if (options.division?.middlegame != null) {
+      if (options.division!.middlegame! > 0) {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.opening));
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.middlegame! - 1,
+            context.l10n.middlegame,
+          ),
+        );
+      } else {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.middlegame));
+      }
+    }
+
+    if (options.division?.endgame != null) {
+      if (options.division!.endgame! > 0) {
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.endgame! - 1,
+            context.l10n.endgame,
+          ),
+        );
+      } else {
+        divisionLines.add(
+          phaseVerticalBar(
+            0.0,
+            context.l10n.endgame,
+          ),
+        );
+      }
+    }
+    return Center(
+      child: AspectRatio(
+        aspectRatio: 2.5,
+        child: Padding(
+          padding: const EdgeInsets.all(16.0),
+          child: LineChart(
+            LineChartData(
+              lineTouchData: LineTouchData(
+                enabled: false,
+                touchCallback:
+                    (FlTouchEvent event, LineTouchResponse? touchResponse) {
+                  if (event is FlTapDownEvent ||
+                      event is FlPanUpdateEvent ||
+                      event is FlLongPressMoveUpdate) {
+                    final touchX = event.localPosition!.dx;
+                    final chartWidth = context.size!.width -
+                        32; // Insets on both sides of the chart of 16
+                    final minX = spots.first.x;
+                    final maxX = spots.last.x;
+                    final touchXDataValue =
+                        minX + (touchX / chartWidth) * (maxX - minX);
+                    final closestSpot = spots.reduce(
+                      (a, b) => (a.x - touchXDataValue).abs() <
+                              (b.x - touchXDataValue).abs()
+                          ? a
+                          : b,
+                    );
+                    final closestNodeIndex = closestSpot.x.round();
+                    ref
+                        .read(analysisControllerProvider(pgn, options).notifier)
+                        .jumpToNthNodeOnMainline(closestNodeIndex);
+                  }
+                },
+              ),
+              minY: -1.0,
+              maxY: 1.0,
+              lineBarsData: [
+                LineChartBarData(
+                  spots: spots,
+                  isCurved: false,
+                  barWidth: 1,
+                  color: mainLineColor.withOpacity(0.7),
+                  aboveBarData: BarAreaData(
+                    show: true,
+                    color: aboveLineColor,
+                    applyCutOffY: true,
+                  ),
+                  belowBarData: BarAreaData(
+                    show: true,
+                    color: belowLineColor,
+                    applyCutOffY: true,
+                  ),
+                  dotData: const FlDotData(
+                    show: false,
+                  ),
+                ),
+              ],
+              extraLinesData: ExtraLinesData(
+                verticalLines: [
+                  if (isOnMainline)
+                    VerticalLine(
+                      x: (currentNode.position.ply - 1 - rootPly).toDouble(),
+                      color: mainLineColor,
+                      strokeWidth: 1.0,
+                    ),
+                  ...divisionLines,
+                ],
+              ),
+              gridData: const FlGridData(show: false),
+              borderData: FlBorderData(show: false),
+              titlesData: const FlTitlesData(show: false),
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
 
+class AnalysisScreen extends StatelessWidget {
   /// The analysis options.
   final AnalysisOptions options;
 
@@ -65,6 +233,12 @@ class AnalysisScreen extends StatelessWidget {
 
   final String? title;
 
+  const AnalysisScreen({
+    required this.options,
+    required this.pgnOrId,
+    this.title,
+  });
+
   @override
   Widget build(BuildContext context) {
     return pgnOrId.length == 8 && GameId(pgnOrId).isValid
@@ -77,870 +251,397 @@ class AnalysisScreen extends StatelessWidget {
   }
 }
 
-class _LoadGame extends ConsumerWidget {
-  const _LoadGame(this.gameId, this.options, this.title);
-
-  final AnalysisOptions options;
-  final GameId gameId;
-  final String? title;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final gameAsync = ref.watch(archivedGameProvider(id: gameId));
-
-    return gameAsync.when(
-      data: (game) {
-        final serverAnalysis =
-            game.white.analysis != null && game.black.analysis != null
-                ? (white: game.white.analysis!, black: game.black.analysis!)
-                : null;
-        return _LoadedAnalysisScreen(
-          options: options.copyWith(
-            id: game.id,
-            opening: game.meta.opening,
-            division: game.meta.division,
-            serverAnalysis: serverAnalysis,
-          ),
-          pgn: game.makePgn(),
-          title: title,
-        );
-      },
-      loading: () => const Center(child: CircularProgressIndicator.adaptive()),
-      error: (error, _) {
-        return Center(
-          child: Text('Cannot load game analysis: $error'),
-        );
-      },
-    );
-  }
-}
-
-class _LoadedAnalysisScreen extends ConsumerWidget {
-  const _LoadedAnalysisScreen({
-    required this.options,
-    required this.pgn,
-    this.title,
-  });
-
-  final AnalysisOptions options;
+class ServerAnalysisSummary extends ConsumerWidget {
   final String pgn;
 
-  final String? title;
+  final AnalysisOptions options;
+  const ServerAnalysisSummary(this.pgn, this.options);
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    return ConsumerPlatformWidget(
-      androidBuilder: _androidBuilder,
-      iosBuilder: _iosBuilder,
-      ref: ref,
-    );
-  }
-
-  Widget _androidBuilder(BuildContext context, WidgetRef ref) {
     final ctrlProvider = analysisControllerProvider(pgn, options);
+    final playersAnalysis =
+        ref.watch(ctrlProvider.select((value) => value.playersAnalysis));
+    final pgnHeaders =
+        ref.watch(ctrlProvider.select((value) => value.pgnHeaders));
+    final currentGameAnalysis = ref.watch(currentAnalysisProvider);
 
-    return Scaffold(
-      resizeToAvoidBottomInset: false,
-      appBar: AppBar(
-        title: _Title(options: options, title: title),
-        actions: [
-          _EngineDepth(ctrlProvider),
-          AppBarIconButton(
-            onPressed: () => showAdaptiveBottomSheet<void>(
-              context: context,
-              isScrollControlled: true,
-              showDragHandle: true,
-              isDismissible: true,
-              builder: (_) => AnalysisSettings(pgn, options),
-            ),
-            semanticsLabel: context.l10n.settingsSettings,
-            icon: const Icon(Icons.settings),
-          ),
-        ],
-      ),
-      body: _Body(pgn: pgn, options: options),
-    );
-  }
-
-  Widget _iosBuilder(BuildContext context, WidgetRef ref) {
-    final ctrlProvider = analysisControllerProvider(pgn, options);
-
-    return CupertinoPageScaffold(
-      resizeToAvoidBottomInset: false,
-      navigationBar: CupertinoNavigationBar(
-        backgroundColor: Styles.cupertinoScaffoldColor.resolveFrom(context),
-        border: null,
-        padding: Styles.cupertinoAppBarTrailingWidgetPadding,
-        middle: _Title(options: options, title: title),
-        trailing: Row(
-          mainAxisSize: MainAxisSize.min,
-          children: [
-            _EngineDepth(ctrlProvider),
-            AppBarIconButton(
-              onPressed: () => showAdaptiveBottomSheet<void>(
-                context: context,
-                isScrollControlled: true,
-                showDragHandle: true,
-                isDismissible: true,
-                builder: (_) => AnalysisSettings(pgn, options),
-              ),
-              semanticsLabel: context.l10n.settingsSettings,
-              icon: const Icon(Icons.settings),
-            ),
-          ],
-        ),
-      ),
-      child: _Body(pgn: pgn, options: options),
-    );
-  }
-}
-
-class _Title extends StatelessWidget {
-  const _Title({
-    required this.options,
-    this.title,
-  });
-  final AnalysisOptions options;
-  final String? title;
-
-  @override
-  Widget build(BuildContext context) {
-    return title != null
-        ? Text(title!)
-        : Row(
-            mainAxisSize: MainAxisSize.min,
+    return playersAnalysis != null
+        ? ListView(
             children: [
-              if (options.variant != Variant.standard) ...[
-                Icon(options.variant.icon),
-                const SizedBox(width: 5.0),
-              ],
-              Text(context.l10n.analysis),
-            ],
-          );
-  }
-}
-
-class _Body extends ConsumerWidget {
-  const _Body({required this.pgn, required this.options});
-
-  final String pgn;
-  final AnalysisOptions options;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final ctrlProvider = analysisControllerProvider(pgn, options);
-    final showEvaluationGauge = ref.watch(
-      analysisPreferencesProvider.select((value) => value.showEvaluationGauge),
-    );
-    final showOpeningExplorer = ref.watch(
-      analysisPreferencesProvider.select((value) => value.showOpeningExplorer),
-    );
-
-    final isEngineAvailable = ref.watch(
-      ctrlProvider.select(
-        (value) => value.isEngineAvailable,
-      ),
-    );
-
-    final hasEval =
-        ref.watch(ctrlProvider.select((value) => value.hasAvailableEval));
-
-    final showAnalysisSummary = ref.watch(
-      ctrlProvider.select((value) => value.displayMode == DisplayMode.summary),
-    );
-
-    final position = ref.watch(ctrlProvider.select((value) => value.position));
-
-    return Column(
-      children: [
-        Expanded(
-          child: SafeArea(
-            bottom: false,
-            child: LayoutBuilder(
-              builder: (context, constraints) {
-                final aspectRatio = constraints.biggest.aspectRatio;
-                final defaultBoardSize = constraints.biggest.shortestSide;
-                final isTablet = isTabletOrLarger(context);
-                final remainingHeight =
-                    constraints.maxHeight - defaultBoardSize;
-                final isSmallScreen =
-                    remainingHeight < kSmallRemainingHeightLeftBoardThreshold;
-                final boardSize = isTablet || isSmallScreen
-                    ? defaultBoardSize - kTabletBoardTableSidePadding * 2
-                    : defaultBoardSize;
-
-                return aspectRatio > 1
-                    ? Row(
-                        mainAxisSize: MainAxisSize.max,
-                        children: [
-                          Padding(
-                            padding: const EdgeInsets.only(
-                              left: kTabletBoardTableSidePadding,
-                              top: kTabletBoardTableSidePadding,
-                              bottom: kTabletBoardTableSidePadding,
-                            ),
-                            child: Row(
-                              children: [
-                                _Board(
-                                  pgn,
-                                  options,
-                                  boardSize,
-                                  isTablet: isTablet,
-                                ),
-                                if (hasEval && showEvaluationGauge) ...[
-                                  const SizedBox(width: 4.0),
-                                  _EngineGaugeVertical(ctrlProvider),
-                                ],
-                              ],
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Padding(
+                  padding: EdgeInsets.only(top: 16.0),
+                  child: WaitingForServerAnalysis(),
+                ),
+              AcplChart(pgn, options),
+              Center(
+                child: SizedBox(
+                  width: math.min(MediaQuery.sizeOf(context).width, 500),
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                    child: Table(
+                      defaultVerticalAlignment:
+                          TableCellVerticalAlignment.middle,
+                      columnWidths: const {
+                        0: FlexColumnWidth(1),
+                        1: FlexColumnWidth(1),
+                        2: FlexColumnWidth(1),
+                      },
+                      children: [
+                        TableRow(
+                          decoration: const BoxDecoration(
+                            border: Border(
+                              bottom: BorderSide(color: Colors.grey),
                             ),
                           ),
-                          Flexible(
-                            fit: FlexFit.loose,
-                            child: Column(
-                              mainAxisAlignment: MainAxisAlignment.start,
-                              children: [
-                                if (isEngineAvailable)
-                                  _EngineLines(
-                                    ctrlProvider,
-                                    isLandscape: true,
-                                  ),
-                                Expanded(
-                                  child: PlatformCard(
-                                    margin: const EdgeInsets.all(
-                                      kTabletBoardTableSidePadding,
-                                    ),
-                                    semanticContainer: false,
-                                    child: showAnalysisSummary
-                                        ? ServerAnalysisSummary(pgn, options)
-                                        : AnalysisTreeView(
-                                            pgn,
-                                            options,
-                                            Orientation.landscape,
-                                          ),
-                                  ),
+                          children: [
+                            _SummaryPlayerName(Side.white, pgnHeaders),
+                            Center(
+                              child: Text(
+                                pgnHeaders.get('Result') ?? '',
+                                style: const TextStyle(
+                                  fontWeight: FontWeight.bold,
                                 ),
-                              ],
+                              ),
                             ),
-                          ),
-                        ],
-                      )
-                    : Column(
-                        mainAxisAlignment: MainAxisAlignment.center,
-                        mainAxisSize: MainAxisSize.max,
-                        crossAxisAlignment: CrossAxisAlignment.center,
-                        children: [
-                          _ColumnTopTable(ctrlProvider),
-                          if (isTablet)
-                            Padding(
-                              padding: const EdgeInsets.all(
-                                kTabletBoardTableSidePadding,
+                            _SummaryPlayerName(Side.black, pgnHeaders),
+                          ],
+                        ),
+                        if (playersAnalysis.white.accuracy != null &&
+                            playersAnalysis.black.accuracy != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                '${playersAnalysis.white.accuracy}%',
                               ),
-                              child: _Board(
-                                pgn,
-                                options,
-                                boardSize,
-                                isTablet: isTablet,
+                              Center(
+                                heightFactor: 1.8,
+                                child: Text(
+                                  context.l10n.accuracy,
+                                  softWrap: true,
+                                ),
                               ),
-                            )
-                          else
-                            _Board(pgn, options, boardSize, isTablet: isTablet),
-                          if (showAnalysisSummary)
-                            Expanded(child: ServerAnalysisSummary(pgn, options))
-                          else
-                            Expanded(
-                              child: AnalysisTreeView(
-                                pgn,
-                                options,
-                                Orientation.portrait,
+                              _SummaryNumber(
+                                '${playersAnalysis.black.accuracy}%',
                               ),
-                            ),
-                          if (showOpeningExplorer)
-                            _OpeningExplorer(
-                              position: position,
-                              ctrlProvider: ctrlProvider,
-                            ),
-                        ],
-                      );
-              },
-            ),
-          ),
-        ),
-        _BottomBar(pgn: pgn, options: options),
-      ],
-    );
-  }
-}
-
-class _OpeningExplorer extends ConsumerWidget {
-  const _OpeningExplorer({
-    required this.position,
-    required this.ctrlProvider,
-  });
-
-  final Position position;
-  final AnalysisControllerProvider ctrlProvider;
-
-  String formatNum(int num) => NumberFormat.decimalPatternDigits().format(num);
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    if (position.fullmoves > 24) {
-      return const Expanded(
-        child: Column(
-          mainAxisAlignment: MainAxisAlignment.center,
-          children: [
-            Text('Max depth reached'),
-          ],
-        ),
-      );
-    }
-
-    final masterDatabaseAsync =
-        ref.watch(masterDatabaseProvider(fen: position.fen));
-
-    return masterDatabaseAsync.when(
-      data: (masterDatabase) {
-        return masterDatabase.moves.isEmpty
-            ? const Expanded(
-                child: Column(
-                  mainAxisAlignment: MainAxisAlignment.center,
-                  children: [
-                    Text('No game found'),
-                  ],
-                ),
-              )
-            : Expanded(
-                child: Container(
-                  width: MediaQuery.of(context).size.width,
-                  padding: const EdgeInsets.symmetric(
-                    vertical: 8.0,
-                    horizontal: 16.0,
-                  ),
-                  child: SingleChildScrollView(
-                    scrollDirection: Axis.vertical,
-                    child: DataTable(
-                      showCheckboxColumn: false,
-                      columnSpacing: 5,
-                      horizontalMargin: 0,
-                      columns: const [
-                        DataColumn(label: Text('Move')),
-                        DataColumn(label: Text('Games')),
-                        DataColumn(label: Text('White / Draw / Black')),
-                      ],
-                      rows: [
-                        ...masterDatabase.moves.map(
-                          (move) => DataRow(
-                            onSelectChanged: (_) => ref
-                                .read(ctrlProvider.notifier)
-                                .onUserMove(Move.fromUci(move.uci)!),
-                            cells: [
-                              DataCell(Text(move.san)),
-                              DataCell(
-                                Text(
-                                  '${((move.games / masterDatabase.games) * 100).round()}% / ${formatNum(move.games)}',
+                            ],
+                          ),
+                        for (final item in [
+                          (
+                            playersAnalysis.white.inaccuracies.toString(),
+                            context.l10n
+                                .nbInaccuracies(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.inaccuracies.toString()
+                          ),
+                          (
+                            playersAnalysis.white.mistakes.toString(),
+                            context.l10n
+                                .nbMistakes(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.mistakes.toString()
+                          ),
+                          (
+                            playersAnalysis.white.blunders.toString(),
+                            context.l10n
+                                .nbBlunders(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.blunders.toString()
+                          ),
+                        ])
+                          TableRow(
+                            children: [
+                              _SummaryNumber(item.$1),
+                              Center(
+                                heightFactor: 1.2,
+                                child: Text(
+                                  item.$2,
+                                  softWrap: true,
                                 ),
                               ),
-                              DataCell(
-                                _WinPercentageChart(
-                                  white: move.white,
-                                  draws: move.draws,
-                                  black: move.black,
+                              _SummaryNumber(item.$3),
+                            ],
+                          ),
+                        if (playersAnalysis.white.acpl != null &&
+                            playersAnalysis.black.acpl != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                playersAnalysis.white.acpl.toString(),
+                              ),
+                              Center(
+                                heightFactor: 1.5,
+                                child: Text(
+                                  context.l10n.averageCentipawnLoss,
+                                  softWrap: true,
+                                  textAlign: TextAlign.center,
                                 ),
                               ),
+                              _SummaryNumber(
+                                playersAnalysis.black.acpl.toString(),
+                              ),
                             ],
                           ),
-                        ),
-                        DataRow(
-                          cells: [
-                            const DataCell(Icon(Icons.functions)),
-                            DataCell(
-                              Text(
-                                '100% / ${formatNum(masterDatabase.games)}',
-                              ),
-                            ),
-                            DataCell(
-                              _WinPercentageChart(
-                                white: masterDatabase.white,
-                                draws: masterDatabase.draws,
-                                black: masterDatabase.black,
-                              ),
-                            ),
-                          ],
-                        ),
                       ],
                     ),
                   ),
                 ),
-              );
-      },
-      loading: () => const Center(
-        child: CircularProgressIndicator(),
-      ),
-      error: (error, stackTrace) => Center(
-        child: Text(error.toString()),
-      ),
-    );
-  }
-}
-
-class _WinPercentageChart extends StatelessWidget {
-  const _WinPercentageChart({
-    required this.white,
-    required this.draws,
-    required this.black,
-  });
-
-  final int white;
-  final int draws;
-  final int black;
-
-  @override
-  Widget build(BuildContext context) {
-    int percentGames(int games) =>
-        ((games / (white + draws + black)) * 100).round();
-
-    final percentWhite = percentGames(white);
-    final percentDraws = percentGames(draws);
-    final percentBlack = percentGames(black);
-
-    return Row(
-      children: [
-        if (percentWhite != 0)
-          Expanded(
-            child: ColoredBox(
-              color: Colors.white,
-              child: Text(
-                percentWhite < 5 ? '' : '$percentWhite%',
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.black),
-              ),
-            ),
-          ),
-        if (percentDraws != 0)
-          Expanded(
-            child: ColoredBox(
-              color: Colors.grey,
-              child: Text(
-                percentDraws < 5 ? '' : '$percentDraws%',
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.white),
-              ),
-            ),
-          ),
-        if (percentBlack != 0)
-          Expanded(
-            child: ColoredBox(
-              color: Colors.black,
-              child: Text(
-                percentBlack < 5 ? '' : '$percentBlack%',
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.white),
               ),
-            ),
-          ),
-      ],
-    );
-  }
-}
-
-class _Board extends ConsumerStatefulWidget {
-  const _Board(
-    this.pgn,
-    this.options,
-    this.boardSize, {
-    required this.isTablet,
-  });
-
-  final String pgn;
-  final AnalysisOptions options;
-  final double boardSize;
-  final bool isTablet;
-
-  @override
-  ConsumerState<_Board> createState() => _BoardState();
-}
-
-class _BoardState extends ConsumerState<_Board> {
-  ISet<cg.Shape> userShapes = ISet();
-
-  ISet<cg.Shape> _computeBestMoveShapes(IList<MoveWithWinningChances> moves) {
-    // Scale down all moves with index > 0 based on how much worse their winning chances are compared to the best move
-    // (assume moves are ordered by their winning chances, so index==0 is the best move)
-    double scaleArrowAgainstBestMove(int index) {
-      const minScale = 0.15;
-      const maxScale = 1.0;
-      const winningDiffScaleFactor = 2.5;
-
-      final bestMove = moves[0];
-      final winningDiffComparedToBestMove =
-          bestMove.winningChances - moves[index].winningChances;
-      // Force minimum scale if the best move is significantly better than this move
-      if (winningDiffComparedToBestMove > 0.3) {
-        return minScale;
-      }
-      return clampDouble(
-        math.max(
-          minScale,
-          maxScale - winningDiffScaleFactor * winningDiffComparedToBestMove,
-        ),
-        0,
-        1,
-      );
-    }
-
-    return ISet(
-      moves.mapIndexed(
-        (i, m) {
-          final move = m.move;
-          // Same colors as in the Web UI with a slightly different opacity
-          // The best move has a different color than the other moves
-          final color = Color((i == 0) ? 0x66003088 : 0x664A4A4A);
-          switch (move) {
-            case NormalMove(from: _, to: _, promotion: final promRole):
-              return [
-                cg.Arrow(
-                  color: color,
-                  orig: move.cg.from,
-                  dest: move.cg.to,
-                  scale: scaleArrowAgainstBestMove(i),
-                ),
-                if (promRole != null)
-                  cg.PieceShape(
-                    color: color,
-                    orig: move.cg.to,
-                    role: promRole.cg,
-                  ),
-              ];
-            case DropMove(role: final role, to: _):
-              return [
-                cg.PieceShape(
-                  color: color,
-                  orig: move.cg.to,
-                  role: role.cg,
-                ),
-              ];
-          }
-        },
-      ).expand((e) => e),
-    );
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final ctrlProvider = analysisControllerProvider(widget.pgn, widget.options);
-    final analysisState = ref.watch(ctrlProvider);
-    final boardPrefs = ref.watch(boardPreferencesProvider);
-    final showBestMoveArrow = ref.watch(
-      analysisPreferencesProvider.select(
-        (value) => value.showBestMoveArrow,
-      ),
-    );
-    final showAnnotationsOnBoard = ref.watch(
-      analysisPreferencesProvider.select((value) => value.showAnnotations),
-    );
-
-    final evalBestMoves = ref.watch(
-      engineEvaluationProvider.select((s) => s.eval?.bestMoves),
-    );
-
-    final currentNode = analysisState.currentNode;
-    final annotation = makeAnnotation(currentNode.nags);
-
-    final bestMoves = evalBestMoves ?? currentNode.eval?.bestMoves;
-
-    final sanMove = currentNode.sanMove;
-
-    final ISet<cg.Shape> bestMoveShapes = showBestMoveArrow &&
-            analysisState.isEngineAvailable &&
-            bestMoves != null
-        ? _computeBestMoveShapes(bestMoves)
-        : ISet();
-
-    return cg.Board(
-      size: widget.boardSize,
-      onMove: (move, {isDrop, isPremove}) =>
-          ref.read(ctrlProvider.notifier).onUserMove(Move.fromUci(move.uci)!),
-      data: cg.BoardData(
-        orientation: analysisState.pov.cg,
-        interactableSide: analysisState.position.isGameOver
-            ? cg.InteractableSide.none
-            : analysisState.position.turn == Side.white
-                ? cg.InteractableSide.white
-                : cg.InteractableSide.black,
-        fen: analysisState.position.fen,
-        isCheck: boardPrefs.boardHighlights && analysisState.position.isCheck,
-        lastMove: analysisState.lastMove?.cg,
-        sideToMove: analysisState.position.turn.cg,
-        validMoves: analysisState.validMoves,
-        shapes: userShapes.union(bestMoveShapes),
-        annotations:
-            showAnnotationsOnBoard && sanMove != null && annotation != null
-                ? altCastles.containsKey(sanMove.move.uci)
-                    ? IMap({
-                        Move.fromUci(altCastles[sanMove.move.uci]!)!.cg.to:
-                            annotation,
-                      })
-                    : IMap({sanMove.move.cg.to: annotation})
-                : null,
-      ),
-      settings: cg.BoardSettings(
-        pieceAssets: boardPrefs.pieceSet.assets,
-        colorScheme: boardPrefs.boardTheme.colors,
-        showValidMoves: boardPrefs.showLegalMoves,
-        showLastMove: boardPrefs.boardHighlights,
-        enableCoordinates: boardPrefs.coordinates,
-        animationDuration: boardPrefs.pieceAnimationDuration,
-        borderRadius: widget.isTablet
-            ? const BorderRadius.all(Radius.circular(4.0))
-            : BorderRadius.zero,
-        boxShadow: widget.isTablet ? boardShadows : const <BoxShadow>[],
-        drawShape: cg.DrawShapeOptions(
-          enable: true,
-          onCompleteShape: _onCompleteShape,
-          onClearShapes: _onClearShapes,
-        ),
-        pieceShiftMethod: boardPrefs.pieceShiftMethod,
-      ),
-    );
-  }
-
-  void _onCompleteShape(cg.Shape shape) {
-    if (userShapes.any((element) => element == shape)) {
-      setState(() {
-        userShapes = userShapes.remove(shape);
-      });
-      return;
-    } else {
-      setState(() {
-        userShapes = userShapes.add(shape);
-      });
-    }
-  }
-
-  void _onClearShapes() {
-    setState(() {
-      userShapes = ISet();
-    });
-  }
-}
-
-class _EngineGaugeVertical extends ConsumerWidget {
-  const _EngineGaugeVertical(this.ctrlProvider);
-
-  final AnalysisControllerProvider ctrlProvider;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final analysisState = ref.watch(ctrlProvider);
-
-    return Container(
-      clipBehavior: Clip.hardEdge,
-      decoration: BoxDecoration(
-        borderRadius: BorderRadius.circular(4.0),
-      ),
-      child: EngineGauge(
-        displayMode: EngineGaugeDisplayMode.vertical,
-        params: analysisState.engineGaugeParams,
-      ),
-    );
-  }
-}
-
-class _ColumnTopTable extends ConsumerWidget {
-  const _ColumnTopTable(this.ctrlProvider);
-
-  final AnalysisControllerProvider ctrlProvider;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final analysisState = ref.watch(ctrlProvider);
-    final showEvaluationGauge = ref.watch(
-      analysisPreferencesProvider.select((p) => p.showEvaluationGauge),
-    );
-
-    return analysisState.hasAvailableEval
-        ? Column(
+            ],
+          )
+        : Column(
             mainAxisSize: MainAxisSize.min,
             crossAxisAlignment: CrossAxisAlignment.start,
             children: [
-              if (showEvaluationGauge)
-                EngineGauge(
-                  displayMode: EngineGaugeDisplayMode.horizontal,
-                  params: analysisState.engineGaugeParams,
+              const Spacer(),
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Center(
+                  child: Padding(
+                    padding: EdgeInsets.symmetric(vertical: 16.0),
+                    child: WaitingForServerAnalysis(),
+                  ),
+                )
+              else
+                Center(
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(vertical: 16.0),
+                    child: Builder(
+                      builder: (context) {
+                        Future<void>? pendingRequest;
+                        return StatefulBuilder(
+                          builder: (context, setState) {
+                            return FutureBuilder<void>(
+                              future: pendingRequest,
+                              builder: (context, snapshot) {
+                                return SecondaryButton(
+                                  semanticsLabel:
+                                      context.l10n.requestAComputerAnalysis,
+                                  onPressed: ref.watch(authSessionProvider) ==
+                                          null
+                                      ? () {
+                                          showPlatformSnackbar(
+                                            context,
+                                            context
+                                                .l10n.youNeedAnAccountToDoThat,
+                                          );
+                                        }
+                                      : snapshot.connectionState ==
+                                              ConnectionState.waiting
+                                          ? null
+                                          : () {
+                                              setState(() {
+                                                pendingRequest = ref
+                                                    .read(ctrlProvider.notifier)
+                                                    .requestServerAnalysis()
+                                                    .catchError((Object e) {
+                                                  if (context.mounted) {
+                                                    showPlatformSnackbar(
+                                                      context,
+                                                      e.toString(),
+                                                      type: SnackBarType.error,
+                                                    );
+                                                  }
+                                                });
+                                              });
+                                            },
+                                  child: Text(
+                                    context.l10n.requestAComputerAnalysis,
+                                  ),
+                                );
+                              },
+                            );
+                          },
+                        );
+                      },
+                    ),
+                  ),
                 ),
-              if (analysisState.isEngineAvailable)
-                _EngineLines(ctrlProvider, isLandscape: false),
+              const Spacer(),
             ],
-          )
-        : kEmptyWidget;
+          );
   }
 }
-
-class _EngineLines extends ConsumerWidget {
-  const _EngineLines(this.ctrlProvider, {required this.isLandscape});
-  final AnalysisControllerProvider ctrlProvider;
-  final bool isLandscape;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final analysisState = ref.watch(ctrlProvider);
-    final numEvalLines = ref.watch(
-      analysisPreferencesProvider.select(
-        (p) => p.numEvalLines,
-      ),
-    );
-    final engineEval = ref.watch(engineEvaluationProvider).eval;
-    final eval = engineEval ?? analysisState.currentNode.eval;
-
-    final emptyLines = List.filled(
-      numEvalLines,
-      _Engineline.empty(ctrlProvider),
-    );
-
-    final content = !analysisState.position.isGameOver
-        ? (eval != null
-            ? eval.pvs
-                .take(numEvalLines)
-                .map(
-                  (pv) => _Engineline(ctrlProvider, eval.position, pv),
-                )
-                .toList()
-            : emptyLines)
-        : emptyLines;
-
-    if (content.length < numEvalLines) {
-      final padding = List.filled(
-        numEvalLines - content.length,
-        _Engineline.empty(ctrlProvider),
-      );
-      content.addAll(padding);
-    }
-
-    return Padding(
-      padding: EdgeInsets.symmetric(
-        vertical: isLandscape ? kTabletBoardTableSidePadding : 0.0,
-        horizontal: isLandscape ? kTabletBoardTableSidePadding : 0.0,
-      ),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        mainAxisAlignment: MainAxisAlignment.start,
-        children: content,
-      ),
+
+class WaitingForServerAnalysis extends StatelessWidget {
+  const WaitingForServerAnalysis({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.center,
+      mainAxisSize: MainAxisSize.max,
+      children: [
+        Image.asset(
+          'assets/images/stockfish/icon.png',
+          width: 30,
+          height: 30,
+        ),
+        const SizedBox(width: 8.0),
+        Text(context.l10n.waitingForAnalysis),
+        const SizedBox(width: 8.0),
+        const CircularProgressIndicator.adaptive(),
+      ],
     );
   }
 }
 
-class _Engineline extends ConsumerWidget {
-  const _Engineline(
-    this.ctrlProvider,
-    this.fromPosition,
-    this.pvData,
-  );
-
-  const _Engineline.empty(this.ctrlProvider)
-      : pvData = const PvData(moves: IListConst([])),
-        fromPosition = Chess.initial;
+class _Body extends ConsumerWidget {
+  final String pgn;
 
-  final AnalysisControllerProvider ctrlProvider;
-  final Position fromPosition;
-  final PvData pvData;
+  final AnalysisOptions options;
+  const _Body({required this.pgn, required this.options});
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    if (pvData.moves.isEmpty) {
-      return const SizedBox(
-        height: kEvalGaugeSize,
-        child: SizedBox.shrink(),
-      );
-    }
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final showEvaluationGauge = ref.watch(
+      analysisPreferencesProvider.select((value) => value.showEvaluationGauge),
+    );
 
-    final pieceNotation = ref.watch(pieceNotationProvider).maybeWhen(
-          data: (value) => value,
-          orElse: () => defaultAccountPreferences.pieceNotation,
-        );
+    final isEngineAvailable = ref.watch(
+      ctrlProvider.select(
+        (value) => value.isEngineAvailable,
+      ),
+    );
 
-    final lineBuffer = StringBuffer();
-    int ply = fromPosition.ply + 1;
-    pvData.sanMoves(fromPosition).forEachIndexed((i, s) {
-      lineBuffer.write(
-        ply.isOdd
-            ? '${(ply / 2).ceil()}. $s '
-            : i == 0
-                ? '${(ply / 2).ceil()}... $s '
-                : '$s ',
-      );
-      ply += 1;
-    });
+    final hasEval =
+        ref.watch(ctrlProvider.select((value) => value.hasAvailableEval));
 
-    final brightness = ref.watch(currentBrightnessProvider);
+    final showAnalysisSummary = ref.watch(
+      ctrlProvider.select((value) => value.displayMode == DisplayMode.summary),
+    );
 
-    final evalString = pvData.evalString;
-    return AdaptiveInkWell(
-      onTap: () => ref
-          .read(ctrlProvider.notifier)
-          .onUserMove(Move.fromUci(pvData.moves[0])!),
-      child: SizedBox(
-        height: kEvalGaugeSize,
-        child: Padding(
-          padding: const EdgeInsets.all(2.0),
-          child: Row(
-            mainAxisAlignment: MainAxisAlignment.start,
-            mainAxisSize: MainAxisSize.min,
-            crossAxisAlignment: CrossAxisAlignment.center,
-            children: [
-              Container(
-                decoration: BoxDecoration(
-                  color: pvData.winningSide == Side.black
-                      ? EngineGauge.backgroundColor(context, brightness)
-                      : EngineGauge.valueColor(context, brightness),
-                  borderRadius: BorderRadius.circular(4.0),
-                ),
-                padding: const EdgeInsets.symmetric(
-                  horizontal: 4.0,
-                  vertical: 2.0,
-                ),
-                child: Text(
-                  evalString,
-                  style: TextStyle(
-                    color: pvData.winningSide == Side.black
-                        ? Colors.white
-                        : Colors.black,
-                    fontSize: kEvalGaugeFontSize,
-                    fontWeight: FontWeight.w600,
-                  ),
-                ),
-              ),
-              const SizedBox(width: 8.0),
-              Expanded(
-                child: Text(
-                  lineBuffer.toString(),
-                  maxLines: 1,
-                  softWrap: false,
-                  style: TextStyle(
-                    fontFamily: pieceNotation == PieceNotation.symbol
-                        ? 'ChessFont'
-                        : null,
-                  ),
-                  overflow: TextOverflow.ellipsis,
-                ),
-              ),
-            ],
+    return Column(
+      children: [
+        Expanded(
+          child: SafeArea(
+            bottom: false,
+            child: LayoutBuilder(
+              builder: (context, constraints) {
+                final aspectRatio = constraints.biggest.aspectRatio;
+                final defaultBoardSize = constraints.biggest.shortestSide;
+                final isTablet = isTabletOrLarger(context);
+                final remainingHeight =
+                    constraints.maxHeight - defaultBoardSize;
+                final isSmallScreen =
+                    remainingHeight < kSmallRemainingHeightLeftBoardThreshold;
+                final boardSize = isTablet || isSmallScreen
+                    ? defaultBoardSize - kTabletBoardTableSidePadding * 2
+                    : defaultBoardSize;
+
+                return aspectRatio > 1
+                    ? Row(
+                        mainAxisSize: MainAxisSize.max,
+                        children: [
+                          Padding(
+                            padding: const EdgeInsets.only(
+                              left: kTabletBoardTableSidePadding,
+                              top: kTabletBoardTableSidePadding,
+                              bottom: kTabletBoardTableSidePadding,
+                            ),
+                            child: Row(
+                              children: [
+                                AnalysisBoard(
+                                  pgn,
+                                  options,
+                                  boardSize,
+                                  isTablet: isTablet,
+                                ),
+                                if (hasEval && showEvaluationGauge) ...[
+                                  const SizedBox(width: 4.0),
+                                  _EngineGaugeVertical(ctrlProvider),
+                                ],
+                              ],
+                            ),
+                          ),
+                          Flexible(
+                            fit: FlexFit.loose,
+                            child: Column(
+                              mainAxisAlignment: MainAxisAlignment.start,
+                              children: [
+                                if (isEngineAvailable)
+                                  _EngineLines(
+                                    ctrlProvider,
+                                    isLandscape: true,
+                                  ),
+                                Expanded(
+                                  child: PlatformCard(
+                                    margin: const EdgeInsets.all(
+                                      kTabletBoardTableSidePadding,
+                                    ),
+                                    semanticContainer: false,
+                                    child: showAnalysisSummary
+                                        ? ServerAnalysisSummary(pgn, options)
+                                        : AnalysisTreeView(
+                                            pgn,
+                                            options,
+                                            Orientation.landscape,
+                                          ),
+                                  ),
+                                ),
+                              ],
+                            ),
+                          ),
+                        ],
+                      )
+                    : Column(
+                        mainAxisAlignment: MainAxisAlignment.center,
+                        mainAxisSize: MainAxisSize.max,
+                        crossAxisAlignment: CrossAxisAlignment.center,
+                        children: [
+                          _ColumnTopTable(ctrlProvider),
+                          if (isTablet)
+                            Padding(
+                              padding: const EdgeInsets.all(
+                                kTabletBoardTableSidePadding,
+                              ),
+                              child: AnalysisBoard(
+                                pgn,
+                                options,
+                                boardSize,
+                                isTablet: isTablet,
+                              ),
+                            )
+                          else
+                            AnalysisBoard(pgn, options, boardSize, isTablet: isTablet),
+                          if (showAnalysisSummary)
+                            Expanded(child: ServerAnalysisSummary(pgn, options))
+                          else
+                            Expanded(
+                              child: AnalysisTreeView(
+                                pgn,
+                                options,
+                                Orientation.portrait,
+                              ),
+                            ),
+                        ],
+                      );
+              },
+            ),
           ),
         ),
-      ),
+        _BottomBar(pgn: pgn, options: options),
+      ],
     );
   }
 }
 
 class _BottomBar extends ConsumerWidget {
+  final String pgn;
+
+  final AnalysisOptions options;
   const _BottomBar({
     required this.pgn,
     required this.options,
   });
 
-  final String pgn;
-  final AnalysisOptions options;
-
   @override
   Widget build(BuildContext context, WidgetRef ref) {
     final ctrlProvider = analysisControllerProvider(pgn, options);
@@ -1018,11 +719,11 @@ class _BottomBar extends ConsumerWidget {
     );
   }
 
-  void _moveForward(WidgetRef ref) =>
-      ref.read(analysisControllerProvider(pgn, options).notifier).userNext();
   void _moveBackward(WidgetRef ref) => ref
       .read(analysisControllerProvider(pgn, options).notifier)
       .userPrevious();
+  void _moveForward(WidgetRef ref) =>
+      ref.read(analysisControllerProvider(pgn, options).notifier).userNext();
 
   Future<void> _showAnalysisMenu(BuildContext context, WidgetRef ref) {
     return showAdaptiveActionSheet(
@@ -1098,11 +799,41 @@ class _BottomBar extends ConsumerWidget {
   }
 }
 
+class _ColumnTopTable extends ConsumerWidget {
+  final AnalysisControllerProvider ctrlProvider;
+
+  const _ColumnTopTable(this.ctrlProvider);
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final analysisState = ref.watch(ctrlProvider);
+    final showEvaluationGauge = ref.watch(
+      analysisPreferencesProvider.select((p) => p.showEvaluationGauge),
+    );
+
+    return analysisState.hasAvailableEval
+        ? Column(
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              if (showEvaluationGauge)
+                EngineGauge(
+                  displayMode: EngineGaugeDisplayMode.horizontal,
+                  params: analysisState.engineGaugeParams,
+                ),
+              if (analysisState.isEngineAvailable)
+                _EngineLines(ctrlProvider, isLandscape: false),
+            ],
+          )
+        : kEmptyWidget;
+  }
+}
+
 class _EngineDepth extends ConsumerWidget {
-  const _EngineDepth(this.ctrlProvider);
-
   final AnalysisControllerProvider ctrlProvider;
 
+  const _EngineDepth(this.ctrlProvider);
+
   @override
   Widget build(BuildContext context, WidgetRef ref) {
     final isEngineAvailable = ref.watch(
@@ -1172,289 +903,344 @@ class _EngineDepth extends ConsumerWidget {
   }
 }
 
-class _StockfishInfo extends ConsumerWidget {
-  const _StockfishInfo(this.currentNode);
+class _EngineGaugeVertical extends ConsumerWidget {
+  final AnalysisControllerProvider ctrlProvider;
 
-  final AnalysisCurrentNode currentNode;
+  const _EngineGaugeVertical(this.ctrlProvider);
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final (engineName: engineName, eval: eval, state: engineState) =
-        ref.watch(engineEvaluationProvider);
+    final analysisState = ref.watch(ctrlProvider);
 
-    final currentEval = eval ?? currentNode.eval;
+    return Container(
+      clipBehavior: Clip.hardEdge,
+      decoration: BoxDecoration(
+        borderRadius: BorderRadius.circular(4.0),
+      ),
+      child: EngineGauge(
+        displayMode: EngineGaugeDisplayMode.vertical,
+        params: analysisState.engineGaugeParams,
+      ),
+    );
+  }
+}
 
-    final knps = engineState == EngineState.computing
-        ? ', ${eval?.knps.round()}kn/s'
-        : '';
-    final depth = currentEval?.depth ?? 0;
-    final maxDepth = math.max(depth, kMaxEngineDepth);
+class _Engineline extends ConsumerWidget {
+  final AnalysisControllerProvider ctrlProvider;
 
-    return Column(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        PlatformListTile(
-          leading: Image.asset(
-            'assets/images/stockfish/icon.png',
-            width: 44,
-            height: 44,
+  final Position fromPosition;
+
+  final PvData pvData;
+  const _Engineline(
+    this.ctrlProvider,
+    this.fromPosition,
+    this.pvData,
+  );
+  const _Engineline.empty(this.ctrlProvider)
+      : pvData = const PvData(moves: IListConst([])),
+        fromPosition = Chess.initial;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    if (pvData.moves.isEmpty) {
+      return const SizedBox(
+        height: kEvalGaugeSize,
+        child: SizedBox.shrink(),
+      );
+    }
+
+    final pieceNotation = ref.watch(pieceNotationProvider).maybeWhen(
+          data: (value) => value,
+          orElse: () => defaultAccountPreferences.pieceNotation,
+        );
+
+    final lineBuffer = StringBuffer();
+    int ply = fromPosition.ply + 1;
+    pvData.sanMoves(fromPosition).forEachIndexed((i, s) {
+      lineBuffer.write(
+        ply.isOdd
+            ? '${(ply / 2).ceil()}. $s '
+            : i == 0
+                ? '${(ply / 2).ceil()}... $s '
+                : '$s ',
+      );
+      ply += 1;
+    });
+
+    final brightness = ref.watch(currentBrightnessProvider);
+
+    final evalString = pvData.evalString;
+    return AdaptiveInkWell(
+      onTap: () => ref
+          .read(ctrlProvider.notifier)
+          .onUserMove(Move.fromUci(pvData.moves[0])!),
+      child: SizedBox(
+        height: kEvalGaugeSize,
+        child: Padding(
+          padding: const EdgeInsets.all(2.0),
+          child: Row(
+            mainAxisAlignment: MainAxisAlignment.start,
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.center,
+            children: [
+              Container(
+                decoration: BoxDecoration(
+                  color: pvData.winningSide == Side.black
+                      ? EngineGauge.backgroundColor(context, brightness)
+                      : EngineGauge.valueColor(context, brightness),
+                  borderRadius: BorderRadius.circular(4.0),
+                ),
+                padding: const EdgeInsets.symmetric(
+                  horizontal: 4.0,
+                  vertical: 2.0,
+                ),
+                child: Text(
+                  evalString,
+                  style: TextStyle(
+                    color: pvData.winningSide == Side.black
+                        ? Colors.white
+                        : Colors.black,
+                    fontSize: kEvalGaugeFontSize,
+                    fontWeight: FontWeight.w600,
+                  ),
+                ),
+              ),
+              const SizedBox(width: 8.0),
+              Expanded(
+                child: Text(
+                  lineBuffer.toString(),
+                  maxLines: 1,
+                  softWrap: false,
+                  style: TextStyle(
+                    fontFamily: pieceNotation == PieceNotation.symbol
+                        ? 'ChessFont'
+                        : null,
+                  ),
+                  overflow: TextOverflow.ellipsis,
+                ),
+              ),
+            ],
           ),
-          title: Text(engineName),
-          subtitle: Text(
-            context.l10n.depthX(
-              '$depth/$maxDepth$knps',
+        ),
+      ),
+    );
+  }
+}
+
+class _EngineLines extends ConsumerWidget {
+  final AnalysisControllerProvider ctrlProvider;
+  final bool isLandscape;
+  const _EngineLines(this.ctrlProvider, {required this.isLandscape});
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final analysisState = ref.watch(ctrlProvider);
+    final numEvalLines = ref.watch(
+      analysisPreferencesProvider.select(
+        (p) => p.numEvalLines,
+      ),
+    );
+    final engineEval = ref.watch(engineEvaluationProvider).eval;
+    final eval = engineEval ?? analysisState.currentNode.eval;
+
+    final emptyLines = List.filled(
+      numEvalLines,
+      _Engineline.empty(ctrlProvider),
+    );
+
+    final content = !analysisState.position.isGameOver
+        ? (eval != null
+            ? eval.pvs
+                .take(numEvalLines)
+                .map(
+                  (pv) => _Engineline(ctrlProvider, eval.position, pv),
+                )
+                .toList()
+            : emptyLines)
+        : emptyLines;
+
+    if (content.length < numEvalLines) {
+      final padding = List.filled(
+        numEvalLines - content.length,
+        _Engineline.empty(ctrlProvider),
+      );
+      content.addAll(padding);
+    }
+
+    return Padding(
+      padding: EdgeInsets.symmetric(
+        vertical: isLandscape ? kTabletBoardTableSidePadding : 0.0,
+        horizontal: isLandscape ? kTabletBoardTableSidePadding : 0.0,
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        mainAxisAlignment: MainAxisAlignment.start,
+        children: content,
+      ),
+    );
+  }
+}
+
+class _LoadedAnalysisScreen extends ConsumerWidget {
+  final AnalysisOptions options;
+
+  final String pgn;
+  final String? title;
+
+  const _LoadedAnalysisScreen({
+    required this.options,
+    required this.pgn,
+    this.title,
+  });
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    return ConsumerPlatformWidget(
+      androidBuilder: _androidBuilder,
+      iosBuilder: _iosBuilder,
+      ref: ref,
+    );
+  }
+
+  Widget _androidBuilder(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+
+    return Scaffold(
+      resizeToAvoidBottomInset: false,
+      appBar: AppBar(
+        title: _Title(options: options, title: title),
+        actions: [
+          _EngineDepth(ctrlProvider),
+          AppBarIconButton(
+            onPressed: () => showAdaptiveBottomSheet<void>(
+              context: context,
+              isScrollControlled: true,
+              showDragHandle: true,
+              isDismissible: true,
+              builder: (_) => AnalysisSettings(pgn, options),
+            ),
+            semanticsLabel: context.l10n.settingsSettings,
+            icon: const Icon(Icons.settings),
+          ),
+        ],
+      ),
+      body: _Body(pgn: pgn, options: options),
+    );
+  }
+
+  Widget _iosBuilder(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+
+    return CupertinoPageScaffold(
+      resizeToAvoidBottomInset: false,
+      navigationBar: CupertinoNavigationBar(
+        backgroundColor: Styles.cupertinoScaffoldColor.resolveFrom(context),
+        border: null,
+        padding: Styles.cupertinoAppBarTrailingWidgetPadding,
+        middle: _Title(options: options, title: title),
+        trailing: Row(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            _EngineDepth(ctrlProvider),
+            AppBarIconButton(
+              onPressed: () => showAdaptiveBottomSheet<void>(
+                context: context,
+                isScrollControlled: true,
+                showDragHandle: true,
+                isDismissible: true,
+                builder: (_) => AnalysisSettings(pgn, options),
+              ),
+              semanticsLabel: context.l10n.settingsSettings,
+              icon: const Icon(Icons.settings),
             ),
-          ),
+          ],
         ),
-      ],
+      ),
+      child: _Body(pgn: pgn, options: options),
     );
   }
 }
 
-class ServerAnalysisSummary extends ConsumerWidget {
-  const ServerAnalysisSummary(this.pgn, this.options);
-
-  final String pgn;
+class _LoadGame extends ConsumerWidget {
   final AnalysisOptions options;
 
+  final GameId gameId;
+  final String? title;
+  const _LoadGame(this.gameId, this.options, this.title);
+
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final ctrlProvider = analysisControllerProvider(pgn, options);
-    final playersAnalysis =
-        ref.watch(ctrlProvider.select((value) => value.playersAnalysis));
-    final pgnHeaders =
-        ref.watch(ctrlProvider.select((value) => value.pgnHeaders));
-    final currentGameAnalysis = ref.watch(currentAnalysisProvider);
+    final gameAsync = ref.watch(archivedGameProvider(id: gameId));
 
-    return playersAnalysis != null
-        ? ListView(
-            children: [
-              if (currentGameAnalysis == options.gameAnyId?.gameId)
-                const Padding(
-                  padding: EdgeInsets.only(top: 16.0),
-                  child: WaitingForServerAnalysis(),
-                ),
-              AcplChart(pgn, options),
-              Center(
-                child: SizedBox(
-                  width: math.min(MediaQuery.sizeOf(context).width, 500),
-                  child: Padding(
-                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
-                    child: Table(
-                      defaultVerticalAlignment:
-                          TableCellVerticalAlignment.middle,
-                      columnWidths: const {
-                        0: FlexColumnWidth(1),
-                        1: FlexColumnWidth(1),
-                        2: FlexColumnWidth(1),
-                      },
-                      children: [
-                        TableRow(
-                          decoration: const BoxDecoration(
-                            border: Border(
-                              bottom: BorderSide(color: Colors.grey),
-                            ),
-                          ),
-                          children: [
-                            _SummaryPlayerName(Side.white, pgnHeaders),
-                            Center(
-                              child: Text(
-                                pgnHeaders.get('Result') ?? '',
-                                style: const TextStyle(
-                                  fontWeight: FontWeight.bold,
-                                ),
-                              ),
-                            ),
-                            _SummaryPlayerName(Side.black, pgnHeaders),
-                          ],
-                        ),
-                        if (playersAnalysis.white.accuracy != null &&
-                            playersAnalysis.black.accuracy != null)
-                          TableRow(
-                            children: [
-                              _SummaryNumber(
-                                '${playersAnalysis.white.accuracy}%',
-                              ),
-                              Center(
-                                heightFactor: 1.8,
-                                child: Text(
-                                  context.l10n.accuracy,
-                                  softWrap: true,
-                                ),
-                              ),
-                              _SummaryNumber(
-                                '${playersAnalysis.black.accuracy}%',
-                              ),
-                            ],
-                          ),
-                        for (final item in [
-                          (
-                            playersAnalysis.white.inaccuracies.toString(),
-                            context.l10n
-                                .nbInaccuracies(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.inaccuracies.toString()
-                          ),
-                          (
-                            playersAnalysis.white.mistakes.toString(),
-                            context.l10n
-                                .nbMistakes(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.mistakes.toString()
-                          ),
-                          (
-                            playersAnalysis.white.blunders.toString(),
-                            context.l10n
-                                .nbBlunders(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.blunders.toString()
-                          ),
-                        ])
-                          TableRow(
-                            children: [
-                              _SummaryNumber(item.$1),
-                              Center(
-                                heightFactor: 1.2,
-                                child: Text(
-                                  item.$2,
-                                  softWrap: true,
-                                ),
-                              ),
-                              _SummaryNumber(item.$3),
-                            ],
-                          ),
-                        if (playersAnalysis.white.acpl != null &&
-                            playersAnalysis.black.acpl != null)
-                          TableRow(
-                            children: [
-                              _SummaryNumber(
-                                playersAnalysis.white.acpl.toString(),
-                              ),
-                              Center(
-                                heightFactor: 1.5,
-                                child: Text(
-                                  context.l10n.averageCentipawnLoss,
-                                  softWrap: true,
-                                  textAlign: TextAlign.center,
-                                ),
-                              ),
-                              _SummaryNumber(
-                                playersAnalysis.black.acpl.toString(),
-                              ),
-                            ],
-                          ),
-                      ],
-                    ),
-                  ),
-                ),
-              ),
-            ],
-          )
-        : Column(
-            mainAxisSize: MainAxisSize.min,
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: [
-              const Spacer(),
-              if (currentGameAnalysis == options.gameAnyId?.gameId)
-                const Center(
-                  child: Padding(
-                    padding: EdgeInsets.symmetric(vertical: 16.0),
-                    child: WaitingForServerAnalysis(),
-                  ),
-                )
-              else
-                Center(
-                  child: Padding(
-                    padding: const EdgeInsets.symmetric(vertical: 16.0),
-                    child: Builder(
-                      builder: (context) {
-                        Future<void>? pendingRequest;
-                        return StatefulBuilder(
-                          builder: (context, setState) {
-                            return FutureBuilder<void>(
-                              future: pendingRequest,
-                              builder: (context, snapshot) {
-                                return SecondaryButton(
-                                  semanticsLabel:
-                                      context.l10n.requestAComputerAnalysis,
-                                  onPressed: ref.watch(authSessionProvider) ==
-                                          null
-                                      ? () {
-                                          showPlatformSnackbar(
-                                            context,
-                                            context
-                                                .l10n.youNeedAnAccountToDoThat,
-                                          );
-                                        }
-                                      : snapshot.connectionState ==
-                                              ConnectionState.waiting
-                                          ? null
-                                          : () {
-                                              setState(() {
-                                                pendingRequest = ref
-                                                    .read(ctrlProvider.notifier)
-                                                    .requestServerAnalysis()
-                                                    .catchError((Object e) {
-                                                  if (context.mounted) {
-                                                    showPlatformSnackbar(
-                                                      context,
-                                                      e.toString(),
-                                                      type: SnackBarType.error,
-                                                    );
-                                                  }
-                                                });
-                                              });
-                                            },
-                                  child: Text(
-                                    context.l10n.requestAComputerAnalysis,
-                                  ),
-                                );
-                              },
-                            );
-                          },
-                        );
-                      },
-                    ),
-                  ),
-                ),
-              const Spacer(),
-            ],
-          );
+    return gameAsync.when(
+      data: (game) {
+        final serverAnalysis =
+            game.white.analysis != null && game.black.analysis != null
+                ? (white: game.white.analysis!, black: game.black.analysis!)
+                : null;
+        return _LoadedAnalysisScreen(
+          options: options.copyWith(
+            id: game.id,
+            opening: game.meta.opening,
+            division: game.meta.division,
+            serverAnalysis: serverAnalysis,
+          ),
+          pgn: game.makePgn(),
+          title: title,
+        );
+      },
+      loading: () => const Center(child: CircularProgressIndicator.adaptive()),
+      error: (error, _) {
+        return Center(
+          child: Text('Cannot load game analysis: $error'),
+        );
+      },
+    );
   }
 }
 
-class WaitingForServerAnalysis extends StatelessWidget {
-  const WaitingForServerAnalysis({super.key});
+class _StockfishInfo extends ConsumerWidget {
+  final AnalysisCurrentNode currentNode;
+
+  const _StockfishInfo(this.currentNode);
 
   @override
-  Widget build(BuildContext context) {
-    return Row(
-      mainAxisAlignment: MainAxisAlignment.center,
-      mainAxisSize: MainAxisSize.max,
+  Widget build(BuildContext context, WidgetRef ref) {
+    final (engineName: engineName, eval: eval, state: engineState) =
+        ref.watch(engineEvaluationProvider);
+
+    final currentEval = eval ?? currentNode.eval;
+
+    final knps = engineState == EngineState.computing
+        ? ', ${eval?.knps.round()}kn/s'
+        : '';
+    final depth = currentEval?.depth ?? 0;
+    final maxDepth = math.max(depth, kMaxEngineDepth);
+
+    return Column(
+      mainAxisSize: MainAxisSize.min,
       children: [
-        Image.asset(
-          'assets/images/stockfish/icon.png',
-          width: 30,
-          height: 30,
+        PlatformListTile(
+          leading: Image.asset(
+            'assets/images/stockfish/icon.png',
+            width: 44,
+            height: 44,
+          ),
+          title: Text(engineName),
+          subtitle: Text(
+            context.l10n.depthX(
+              '$depth/$maxDepth$knps',
+            ),
+          ),
         ),
-        const SizedBox(width: 8.0),
-        Text(context.l10n.waitingForAnalysis),
-        const SizedBox(width: 8.0),
-        const CircularProgressIndicator.adaptive(),
       ],
     );
   }
 }
 
 class _SummaryNumber extends StatelessWidget {
-  const _SummaryNumber(this.data);
   final String data;
+  const _SummaryNumber(this.data);
 
   @override
   Widget build(BuildContext context) {
@@ -1468,9 +1254,9 @@ class _SummaryNumber extends StatelessWidget {
 }
 
 class _SummaryPlayerName extends StatelessWidget {
-  const _SummaryPlayerName(this.side, this.pgnHeaders);
   final Side side;
   final IMap<String, String> pgnHeaders;
+  const _SummaryPlayerName(this.side, this.pgnHeaders);
 
   @override
   Widget build(BuildContext context) {
@@ -1516,182 +1302,27 @@ class _SummaryPlayerName extends StatelessWidget {
   }
 }
 
-class AcplChart extends ConsumerWidget {
-  const AcplChart(this.pgn, this.options);
-
-  final String pgn;
+class _Title extends StatelessWidget {
   final AnalysisOptions options;
+  final String? title;
+  const _Title({
+    required this.options,
+    this.title,
+  });
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final mainLineColor = Theme.of(context).colorScheme.secondary;
-    // yes it looks like below/above are inverted in fl_chart
-    final brightness = Theme.of(context).brightness;
-    final white = Theme.of(context).colorScheme.surfaceContainerHighest;
-    final black = Theme.of(context).colorScheme.outline;
-    // yes it looks like below/above are inverted in fl_chart
-    final belowLineColor = brightness == Brightness.light ? white : black;
-    final aboveLineColor = brightness == Brightness.light ? black : white;
-
-    VerticalLine phaseVerticalBar(double x, String label) => VerticalLine(
-          x: x,
-          color: const Color(0xFF707070),
-          strokeWidth: 0.5,
-          label: VerticalLineLabel(
-            style: TextStyle(
-              fontSize: 10,
-              color: Theme.of(context)
-                  .textTheme
-                  .labelMedium
-                  ?.color
-                  ?.withOpacity(0.3),
-            ),
-            labelResolver: (line) => label,
-            padding: const EdgeInsets.only(right: 1),
-            alignment: Alignment.topRight,
-            direction: LabelDirection.vertical,
-            show: true,
-          ),
-        );
-
-    final data = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.acplChartData),
-    );
-
-    final rootPly = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.root.position.ply),
-    );
-
-    final currentNode = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.currentNode),
-    );
-
-    final isOnMainline = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.isOnMainline),
-    );
-
-    if (data == null) {
-      return const SizedBox.shrink();
-    }
-
-    final spots = data
-        .mapIndexed(
-          (i, e) => FlSpot(i.toDouble(), e.winningChances(Side.white)),
-        )
-        .toList(growable: false);
-
-    final divisionLines = <VerticalLine>[];
-
-    if (options.division?.middlegame != null) {
-      if (options.division!.middlegame! > 0) {
-        divisionLines.add(phaseVerticalBar(0.0, context.l10n.opening));
-        divisionLines.add(
-          phaseVerticalBar(
-            options.division!.middlegame! - 1,
-            context.l10n.middlegame,
-          ),
-        );
-      } else {
-        divisionLines.add(phaseVerticalBar(0.0, context.l10n.middlegame));
-      }
-    }
-
-    if (options.division?.endgame != null) {
-      if (options.division!.endgame! > 0) {
-        divisionLines.add(
-          phaseVerticalBar(
-            options.division!.endgame! - 1,
-            context.l10n.endgame,
-          ),
-        );
-      } else {
-        divisionLines.add(
-          phaseVerticalBar(
-            0.0,
-            context.l10n.endgame,
-          ),
-        );
-      }
-    }
-    return Center(
-      child: AspectRatio(
-        aspectRatio: 2.5,
-        child: Padding(
-          padding: const EdgeInsets.all(16.0),
-          child: LineChart(
-            LineChartData(
-              lineTouchData: LineTouchData(
-                enabled: false,
-                touchCallback:
-                    (FlTouchEvent event, LineTouchResponse? touchResponse) {
-                  if (event is FlTapDownEvent ||
-                      event is FlPanUpdateEvent ||
-                      event is FlLongPressMoveUpdate) {
-                    final touchX = event.localPosition!.dx;
-                    final chartWidth = context.size!.width -
-                        32; // Insets on both sides of the chart of 16
-                    final minX = spots.first.x;
-                    final maxX = spots.last.x;
-                    final touchXDataValue =
-                        minX + (touchX / chartWidth) * (maxX - minX);
-                    final closestSpot = spots.reduce(
-                      (a, b) => (a.x - touchXDataValue).abs() <
-                              (b.x - touchXDataValue).abs()
-                          ? a
-                          : b,
-                    );
-                    final closestNodeIndex = closestSpot.x.round();
-                    ref
-                        .read(analysisControllerProvider(pgn, options).notifier)
-                        .jumpToNthNodeOnMainline(closestNodeIndex);
-                  }
-                },
-              ),
-              minY: -1.0,
-              maxY: 1.0,
-              lineBarsData: [
-                LineChartBarData(
-                  spots: spots,
-                  isCurved: false,
-                  barWidth: 1,
-                  color: mainLineColor.withOpacity(0.7),
-                  aboveBarData: BarAreaData(
-                    show: true,
-                    color: aboveLineColor,
-                    applyCutOffY: true,
-                  ),
-                  belowBarData: BarAreaData(
-                    show: true,
-                    color: belowLineColor,
-                    applyCutOffY: true,
-                  ),
-                  dotData: const FlDotData(
-                    show: false,
-                  ),
-                ),
+  Widget build(BuildContext context) {
+    return title != null
+        ? Text(title!)
+        : Row(
+            mainAxisSize: MainAxisSize.min,
+            children: [
+              if (options.variant != Variant.standard) ...[
+                Icon(options.variant.icon),
+                const SizedBox(width: 5.0),
               ],
-              extraLinesData: ExtraLinesData(
-                verticalLines: [
-                  if (isOnMainline)
-                    VerticalLine(
-                      x: (currentNode.position.ply - 1 - rootPly).toDouble(),
-                      color: mainLineColor,
-                      strokeWidth: 1.0,
-                    ),
-                  ...divisionLines,
-                ],
-              ),
-              gridData: const FlGridData(show: false),
-              borderData: FlBorderData(show: false),
-              titlesData: const FlTitlesData(show: false),
-            ),
-          ),
-        ),
-      ),
-    );
+              Text(context.l10n.analysis),
+            ],
+          );
   }
 }
diff --git a/lib/src/view/analysis/analysis_settings.dart b/lib/src/view/analysis/analysis_settings.dart
index 574b844ed2..33a8ea3749 100644
--- a/lib/src/view/analysis/analysis_settings.dart
+++ b/lib/src/view/analysis/analysis_settings.dart
@@ -140,13 +140,6 @@ class AnalysisSettings extends ConsumerWidget {
                 .read(analysisPreferencesProvider.notifier)
                 .togglePgnComments(),
           ),
-          SwitchSettingTile(
-            title: Text(context.l10n.openingExplorer),
-            value: prefs.showOpeningExplorer,
-            onChanged: (_) => ref
-                .read(analysisPreferencesProvider.notifier)
-                .toggleOpeningExplorer(),
-          ),
           SwitchSettingTile(
             title: Text(context.l10n.sound),
             value: isSoundEnabled,
diff --git a/lib/src/view/analysis/opening_explorer_screen.dart b/lib/src/view/analysis/opening_explorer_screen.dart
index d12a05b1c7..cb693a194a 100644
--- a/lib/src/view/analysis/opening_explorer_screen.dart
+++ b/lib/src/view/analysis/opening_explorer_screen.dart
@@ -1,17 +1,18 @@
-import 'package:chessground/chessground.dart' as cg;
 import 'package:dartchess/dartchess.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:intl/intl.dart';
 import 'package:lichess_mobile/src/constants.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
-import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
+import 'package:lichess_mobile/src/model/analysis/opening_explorer_repository.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
-import 'package:lichess_mobile/src/utils/chessground_compat.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
 import 'package:lichess_mobile/src/widgets/platform.dart';
 
+import 'analysis_board.dart';
+
 class OpeningExplorerScreen extends StatelessWidget {
   const OpeningExplorerScreen({required this.pgn, required this.options});
 
@@ -48,89 +49,276 @@ class OpeningExplorerScreen extends StatelessWidget {
 }
 
 class _Body extends ConsumerWidget {
-  const _Body({
-    required this.pgn,
-    required this.options,
-  });
-
   final String pgn;
+
   final AnalysisOptions options;
+  const _Body({required this.pgn, required this.options});
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    return SafeArea(
-      bottom: false,
-      child: LayoutBuilder(
-        builder: (context, constraints) {
-          final defaultBoardSize = constraints.biggest.shortestSide;
-          final isTablet = isTabletOrLarger(context);
-          final remainingHeight = constraints.maxHeight - defaultBoardSize;
-          final isSmallScreen =
-              remainingHeight < kSmallRemainingHeightLeftBoardThreshold;
-          final boardSize = isTablet || isSmallScreen
-              ? defaultBoardSize - kTabletBoardTableSidePadding * 2
-              : defaultBoardSize;
-          return _Board(pgn, options, boardSize, isTablet: isTablet);
-        },
-      ),
+    return Column(
+      children: [
+        Expanded(
+          child: SafeArea(
+            bottom: false,
+            child: LayoutBuilder(
+              builder: (context, constraints) {
+                final aspectRatio = constraints.biggest.aspectRatio;
+                final defaultBoardSize = constraints.biggest.shortestSide;
+                final isTablet = isTabletOrLarger(context);
+                final remainingHeight =
+                    constraints.maxHeight - defaultBoardSize;
+                final isSmallScreen =
+                    remainingHeight < kSmallRemainingHeightLeftBoardThreshold;
+                final boardSize = isTablet || isSmallScreen
+                    ? defaultBoardSize - kTabletBoardTableSidePadding * 2
+                    : defaultBoardSize;
+
+                return aspectRatio > 1
+                    ? Row(
+                        mainAxisSize: MainAxisSize.max,
+                        children: [
+                          Padding(
+                            padding: const EdgeInsets.only(
+                              left: kTabletBoardTableSidePadding,
+                              top: kTabletBoardTableSidePadding,
+                              bottom: kTabletBoardTableSidePadding,
+                            ),
+                            child: Row(
+                              children: [
+                                AnalysisBoard(
+                                  pgn,
+                                  options,
+                                  boardSize,
+                                  isTablet: isTablet,
+                                ),
+                              ],
+                            ),
+                          ),
+                          Flexible(
+                            fit: FlexFit.loose,
+                            child: Column(
+                              mainAxisAlignment: MainAxisAlignment.start,
+                              children: [
+                                Expanded(
+                                  child: PlatformCard(
+                                    margin: const EdgeInsets.all(
+                                      kTabletBoardTableSidePadding,
+                                    ),
+                                    semanticContainer: false,
+                                    child: _OpeningExplorer(
+                                      pgn: pgn,
+                                      options: options,
+                                    ),
+                                  ),
+                                ),
+                              ],
+                            ),
+                          ),
+                        ],
+                      )
+                    : Column(
+                        mainAxisAlignment: MainAxisAlignment.center,
+                        mainAxisSize: MainAxisSize.max,
+                        crossAxisAlignment: CrossAxisAlignment.center,
+                        children: [
+                          if (isTablet)
+                            Padding(
+                              padding: const EdgeInsets.all(
+                                kTabletBoardTableSidePadding,
+                              ),
+                              child: AnalysisBoard(
+                                pgn,
+                                options,
+                                boardSize,
+                                isTablet: isTablet,
+                              ),
+                            )
+                          else
+                            AnalysisBoard(pgn, options, boardSize, isTablet: isTablet),
+                          _OpeningExplorer(pgn: pgn, options: options),
+                        ],
+                      );
+              },
+            ),
+          ),
+        ),
+      ],
     );
   }
 }
 
-class _Board extends ConsumerStatefulWidget {
-  const _Board(
-    this.pgn,
-    this.options,
-    this.boardSize, {
-    required this.isTablet,
+class _OpeningExplorer extends ConsumerWidget {
+  const _OpeningExplorer({
+    required this.pgn,
+    required this.options,
   });
 
   final String pgn;
   final AnalysisOptions options;
-  final double boardSize;
-  final bool isTablet;
 
   @override
-  ConsumerState<_Board> createState() => _BoardState();
+  Widget build(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final position = ref.watch(ctrlProvider.select((value) => value.position));
+
+    if (position.fullmoves > 24) {
+      return const Expanded(
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            Text('Max depth reached'),
+          ],
+        ),
+      );
+    }
+
+    final masterDatabaseAsync =
+        ref.watch(masterDatabaseProvider(fen: position.fen));
+
+    return masterDatabaseAsync.when(
+      data: (masterDatabase) {
+        return masterDatabase.moves.isEmpty
+            ? const Expanded(
+                child: Column(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    Text('No game found'),
+                  ],
+                ),
+              )
+            : Expanded(
+                child: Container(
+                  width: MediaQuery.of(context).size.width,
+                  padding: const EdgeInsets.symmetric(
+                    vertical: 8.0,
+                    horizontal: 16.0,
+                  ),
+                  child: SingleChildScrollView(
+                    scrollDirection: Axis.vertical,
+                    child: DataTable(
+                      showCheckboxColumn: false,
+                      columnSpacing: 5,
+                      horizontalMargin: 0,
+                      columns: const [
+                        DataColumn(label: Text('Move')),
+                        DataColumn(label: Text('Games')),
+                        DataColumn(label: Text('White / Draw / Black')),
+                      ],
+                      rows: [
+                        ...masterDatabase.moves.map(
+                          (move) => DataRow(
+                            onSelectChanged: (_) => ref
+                                .read(ctrlProvider.notifier)
+                                .onUserMove(Move.fromUci(move.uci)!),
+                            cells: [
+                              DataCell(Text(move.san)),
+                              DataCell(
+                                Text(
+                                  '${((move.games / masterDatabase.games) * 100).round()}% / ${formatNum(move.games)}',
+                                ),
+                              ),
+                              DataCell(
+                                _WinPercentageChart(
+                                  white: move.white,
+                                  draws: move.draws,
+                                  black: move.black,
+                                ),
+                              ),
+                            ],
+                          ),
+                        ),
+                        DataRow(
+                          cells: [
+                            const DataCell(Icon(Icons.functions)),
+                            DataCell(
+                              Text(
+                                '100% / ${formatNum(masterDatabase.games)}',
+                              ),
+                            ),
+                            DataCell(
+                              _WinPercentageChart(
+                                white: masterDatabase.white,
+                                draws: masterDatabase.draws,
+                                black: masterDatabase.black,
+                              ),
+                            ),
+                          ],
+                        ),
+                      ],
+                    ),
+                  ),
+                ),
+              );
+      },
+      loading: () => const Center(
+        child: CircularProgressIndicator(),
+      ),
+      error: (error, stackTrace) => Center(
+        child: Text(error.toString()),
+      ),
+    );
+  }
+
+  String formatNum(int num) => NumberFormat.decimalPatternDigits().format(num);
 }
 
-class _BoardState extends ConsumerState<_Board> {
+class _WinPercentageChart extends StatelessWidget {
+  final int white;
+
+  final int draws;
+  final int black;
+  const _WinPercentageChart({
+    required this.white,
+    required this.draws,
+    required this.black,
+  });
+
   @override
   Widget build(BuildContext context) {
-    final ctrlProvider = analysisControllerProvider(widget.pgn, widget.options);
-    final analysisState = ref.watch(ctrlProvider);
-    final boardPrefs = ref.watch(boardPreferencesProvider);
-
-    return cg.Board(
-      size: widget.boardSize,
-      onMove: (move, {isDrop, isPremove}) =>
-          ref.read(ctrlProvider.notifier).onUserMove(Move.fromUci(move.uci)!),
-      data: cg.BoardData(
-        orientation: analysisState.pov.cg,
-        interactableSide: analysisState.position.isGameOver
-            ? cg.InteractableSide.none
-            : analysisState.position.turn == Side.white
-                ? cg.InteractableSide.white
-                : cg.InteractableSide.black,
-        fen: analysisState.position.fen,
-        isCheck: boardPrefs.boardHighlights && analysisState.position.isCheck,
-        lastMove: analysisState.lastMove?.cg,
-        sideToMove: analysisState.position.turn.cg,
-        validMoves: analysisState.validMoves,
-      ),
-      settings: cg.BoardSettings(
-        pieceAssets: boardPrefs.pieceSet.assets,
-        colorScheme: boardPrefs.boardTheme.colors,
-        showValidMoves: boardPrefs.showLegalMoves,
-        showLastMove: boardPrefs.boardHighlights,
-        enableCoordinates: boardPrefs.coordinates,
-        animationDuration: boardPrefs.pieceAnimationDuration,
-        borderRadius: widget.isTablet
-            ? const BorderRadius.all(Radius.circular(4.0))
-            : BorderRadius.zero,
-        boxShadow: widget.isTablet ? boardShadows : const <BoxShadow>[],
-        pieceShiftMethod: boardPrefs.pieceShiftMethod,
-      ),
+    int percentGames(int games) =>
+        ((games / (white + draws + black)) * 100).round();
+
+    final percentWhite = percentGames(white);
+    final percentDraws = percentGames(draws);
+    final percentBlack = percentGames(black);
+
+    return Row(
+      children: [
+        if (percentWhite != 0)
+          Expanded(
+            child: ColoredBox(
+              color: Colors.white,
+              child: Text(
+                percentWhite < 5 ? '' : '$percentWhite%',
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.black),
+              ),
+            ),
+          ),
+        if (percentDraws != 0)
+          Expanded(
+            child: ColoredBox(
+              color: Colors.grey,
+              child: Text(
+                percentDraws < 5 ? '' : '$percentDraws%',
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.white),
+              ),
+            ),
+          ),
+        if (percentBlack != 0)
+          Expanded(
+            child: ColoredBox(
+              color: Colors.black,
+              child: Text(
+                percentBlack < 5 ? '' : '$percentBlack%',
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.white),
+              ),
+            ),
+          ),
+      ],
     );
   }
 }
