diff --git a/.github/workflows/flutter-ci.yml b/.github/workflows/flutter-ci.yml
index cedd837c9..c79a8b86b 100644
--- a/.github/workflows/flutter-ci.yml
+++ b/.github/workflows/flutter-ci.yml
@@ -71,6 +71,9 @@ jobs:
       - name: Analyze code
         run: flutter analyze
 
+      - name: Run unit tests
+        run: cd test && flutter test unit
+
       - name: Run tests in emulator
         uses: reactivecircus/android-emulator-runner@b390b0e1166697ae57c242a0a33c29ca9f5ae078 # tag=v2
         with:
diff --git a/mobile-app/lib/app/app.dart b/mobile-app/lib/app/app.dart
index 935aa19e3..57202a953 100644
--- a/mobile-app/lib/app/app.dart
+++ b/mobile-app/lib/app/app.dart
@@ -5,6 +5,7 @@ import 'package:freecodecamp/service/authentication_service.dart';
 import 'package:freecodecamp/service/audio_service.dart';
 import 'package:freecodecamp/service/download_service.dart';
 import 'package:freecodecamp/service/learn_service.dart';
+import 'package:freecodecamp/service/learn_file_service.dart';
 
 import 'package:freecodecamp/ui/views/code_radio/code_radio_view.dart';
 import 'package:freecodecamp/ui/views/forum/forum-categories/forum_category_view.dart';
@@ -69,6 +70,7 @@ import 'package:sqflite_migration_service/sqflite_migration_service.dart';
     LazySingleton(classType: AppAudioService),
     LazySingleton(classType: DownloadService),
     LazySingleton(classType: LearnService),
+    LazySingleton(classType: LearnFileService),
   ],
   logger: StackedLogger(),
 )
diff --git a/mobile-app/lib/app/app.locator.dart b/mobile-app/lib/app/app.locator.dart
index c75376106..a1dc9ec58 100644
--- a/mobile-app/lib/app/app.locator.dart
+++ b/mobile-app/lib/app/app.locator.dart
@@ -15,6 +15,7 @@ import 'package:stacked_services/src/snackbar/snackbar_service.dart';
 import '../service/audio_service.dart';
 import '../service/authentication_service.dart';
 import '../service/download_service.dart';
+import '../service/learn_file_service.dart';
 import '../service/learn_service.dart';
 import '../service/notification_service.dart';
 import '../service/podcasts_service.dart';
@@ -40,4 +41,5 @@ Future<void> setupLocator(
   locator.registerLazySingleton(() => AppAudioService());
   locator.registerLazySingleton(() => DownloadService());
   locator.registerLazySingleton(() => LearnService());
+  locator.registerLazySingleton(() => LearnFileService());
 }
diff --git a/mobile-app/lib/models/learn/challenge_model.dart b/mobile-app/lib/models/learn/challenge_model.dart
index efe330f95..b79fec2f5 100644
--- a/mobile-app/lib/models/learn/challenge_model.dart
+++ b/mobile-app/lib/models/learn/challenge_model.dart
@@ -71,7 +71,7 @@ class ChallengeFile {
   final String? tail;
   final String contents;
   final List<String> history;
-  final List editableRegionBoundaries;
+  List editableRegionBoundaries;
   final String fileKey;
 
   ChallengeFile({
diff --git a/mobile-app/lib/service/authentication_service.dart b/mobile-app/lib/service/authentication_service.dart
index 27075821c..e00469af5 100644
--- a/mobile-app/lib/service/authentication_service.dart
+++ b/mobile-app/lib/service/authentication_service.dart
@@ -120,7 +120,7 @@ class AuthenticationService {
     if (await hasRequiredTokens()) {
       log('message: Tokens found in storage');
       await setRequiredTokes();
-      await fetchUser();
+      // await fetchUser();
     }
   }
 
diff --git a/mobile-app/lib/service/learn_file_service.dart b/mobile-app/lib/service/learn_file_service.dart
new file mode 100644
index 000000000..9edf0ceb8
--- /dev/null
+++ b/mobile-app/lib/service/learn_file_service.dart
@@ -0,0 +1,186 @@
+import 'package:freecodecamp/enums/ext_type.dart';
+import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:html/parser.dart';
+import 'package:shared_preferences/shared_preferences.dart';
+import 'package:html/dom.dart' as dom;
+
+class LearnFileService {
+  // This function returns a specific file content from the cache.
+  // If testing is enabled on the function it will return
+  // the first file with the given file name.
+
+  Future<String> getExactFileFromCache(
+    Challenge challenge,
+    ChallengeFile file, {
+    bool testing = false,
+  }) async {
+    String? cache;
+
+    if (testing) {
+      cache = challenge.files
+          .firstWhere((element) => element.name == file.name)
+          .contents;
+    } else {
+      SharedPreferences prefs = await SharedPreferences.getInstance();
+      cache = prefs.getString('${challenge.title}.${file.name}');
+    }
+
+    return cache ?? file.contents;
+  }
+
+  void saveFileInCache(
+    Challenge challenge,
+    String currentSelectedFile,
+    String value,
+  ) async {
+    SharedPreferences prefs = await SharedPreferences.getInstance();
+
+    prefs.setString('${challenge.title}.$currentSelectedFile', value);
+  }
+
+  // This funciton returns the first file content with the given extension from the
+  // cache. If testing is enabled it will return the file directly from the challenge.
+  // If a CSS extension is put as a parameter it will return the first HTML file instead.
+
+  Future<String> getFirstFileFromCache(
+    Challenge challenge,
+    Ext ext, {
+    bool testing = false,
+  }) async {
+    String fileContent = '';
+
+    if (testing) {
+      List<ChallengeFile> firstHtmlChallenge = challenge.files
+          .where((file) => (file.ext == Ext.css || file.ext == Ext.html)
+              ? file.ext == Ext.html
+              : file.ext == ext)
+          .toList();
+      fileContent = firstHtmlChallenge[0].contents;
+    } else {
+      List<ChallengeFile> firstChallenge = challenge.files
+          .where((file) => (file.ext == Ext.css || file.ext == Ext.html)
+              ? file.ext == Ext.html
+              : file.ext == ext)
+          .toList();
+      SharedPreferences prefs = await SharedPreferences.getInstance();
+
+      fileContent =
+          prefs.getString('${challenge.title}.${firstChallenge[0].name}') ??
+              firstChallenge[0].contents;
+    }
+
+    return fileContent;
+  }
+
+  // this function will get the current file which is being edited.
+  // otherwise we can not detect which file is currently being worked on. This is only for the new RWD.
+
+  Future<String> getCurrentEditedFileFromCache(
+    Challenge challenge, {
+    bool testing = false,
+  }) async {
+    List<ChallengeFile>? fileWithEditableRegion = challenge.files
+        .where((file) => file.editableRegionBoundaries.isNotEmpty)
+        .toList();
+
+    String? cache;
+
+    if (testing) {
+      return fileWithEditableRegion.isNotEmpty
+          ? fileWithEditableRegion[0].contents
+          : challenge.files[0].contents;
+    }
+
+    SharedPreferences prefs = await SharedPreferences.getInstance();
+
+    if (fileWithEditableRegion.isNotEmpty) {
+      cache = prefs.getString(
+            '${challenge.title}.${fileWithEditableRegion[0].name}',
+          ) ??
+          '';
+
+      if (cache.isNotEmpty) {
+        return cache;
+      } else {
+        return fileWithEditableRegion[0].contents;
+      }
+    } else {
+      return challenge.files[0].contents;
+    }
+  }
+
+  // This function checks if the given document contains any link elements.
+  // If so check if the css file name corresponds with the names put in the array.
+  // If the file is linked return true.
+
+  Future<bool> cssFileIsLinked(
+    String document,
+    String cssFileName,
+  ) async {
+    dom.Document doc = parse(document);
+
+    List<dom.Node> links = doc.getElementsByTagName('LINK');
+
+    List<String> linkedFileNames = [];
+
+    if (links.isNotEmpty) {
+      for (dom.Node node in links) {
+        if (node.attributes['href'] == null) continue;
+
+        if (node.attributes['href']!.contains('/')) {
+          linkedFileNames.add(node.attributes['href']!.split('/').last);
+        } else if (node.attributes['href']!.isNotEmpty) {
+          linkedFileNames.add(node.attributes['href'] as String);
+        }
+      }
+    }
+
+    return linkedFileNames.contains(cssFileName);
+  }
+
+  // This function puts the given css content in the same file as the HTML content.
+  // It will parse the current CSS content into style tags only if it is linked.
+  // If there is nothing to parse it will return the plain content document.
+
+  Future<String> parseCssDocmentsAsStyleTags(
+    Challenge challenge,
+    String content, {
+    bool testing = false,
+  }) async {
+    List<ChallengeFile> cssFiles =
+        challenge.files.where((element) => element.ext == Ext.css).toList();
+    List<String> cssFilesWithCache = [];
+    List<String> tags = [];
+
+    if (cssFiles.isNotEmpty) {
+      for (ChallengeFile file in cssFiles) {
+        String? cache = await getExactFileFromCache(
+          challenge,
+          file,
+          testing: testing,
+        );
+
+        if (!await cssFileIsLinked(content, '${file.name}.${file.ext.name}')) {
+          continue;
+        }
+
+        String handledFile = cache;
+
+        cssFilesWithCache.add(handledFile);
+      }
+
+      for (String contents in cssFilesWithCache) {
+        String tag = '<style> $contents </style>';
+        tags.add(tag);
+      }
+
+      for (String tag in tags) {
+        content += tag;
+      }
+
+      return content;
+    }
+
+    return content;
+  }
+}
diff --git a/mobile-app/lib/ui/views/learn/challenge_editor/challenge_model.dart b/mobile-app/lib/ui/views/learn/challenge_editor/challenge_model.dart
index baf349629..81b60153e 100644
--- a/mobile-app/lib/ui/views/learn/challenge_editor/challenge_model.dart
+++ b/mobile-app/lib/ui/views/learn/challenge_editor/challenge_model.dart
@@ -9,6 +9,7 @@ import 'package:freecodecamp/enums/ext_type.dart';
 import 'package:freecodecamp/enums/panel_type.dart';
 import 'package:freecodecamp/models/learn/challenge_model.dart';
 import 'package:freecodecamp/models/learn/curriculum_model.dart';
+import 'package:freecodecamp/service/learn_file_service.dart';
 import 'package:freecodecamp/ui/views/learn/test_runner.dart';
 import 'package:freecodecamp/ui/widgets/setup_dialog_ui.dart';
 import 'package:html/dom.dart' as dom;
@@ -24,8 +25,8 @@ class ChallengeModel extends BaseViewModel {
   String? _editorText;
   String? get editorText => _editorText;
 
-  String? _currentSelectedFile = '';
-  String? get currentSelectedFile => _currentSelectedFile;
+  String _currentSelectedFile = '';
+  String get currentSelectedFile => _currentSelectedFile;
 
   bool _showPreview = false;
   bool get showPreview => _showPreview;
@@ -77,7 +78,7 @@ class ChallengeModel extends BaseViewModel {
 
   final _dialogService = locator<DialogService>();
   final NavigationService _navigationService = locator<NavigationService>();
-
+  final LearnFileService fileService = locator<LearnFileService>();
   set setCurrentSelectedFile(String value) {
     _currentSelectedFile = value;
     notifyListeners();
@@ -169,8 +170,15 @@ class ChallengeModel extends BaseViewModel {
     setChallenge = initChallenge(url);
     Challenge challenge = await _challenge!;
 
+    List<ChallengeFile> currentEditedChallenge = challenge.files
+        .where((element) => element.editableRegionBoundaries.isNotEmpty)
+        .toList();
+
     if (editorText == null) {
-      String text = await getTextFromCache(challenge);
+      String text = await fileService.getExactFileFromCache(
+        challenge,
+        currentEditedChallenge[0],
+      );
 
       if (text != '') {
         setEditorText = text;
@@ -179,23 +187,13 @@ class ChallengeModel extends BaseViewModel {
 
     setBlock = block;
     setChallengesCompleted = challengesCompleted;
+    setCurrentSelectedFile = currentEditedChallenge[0].name;
   }
 
   // When the content in the editor is changed, save it to the cache. This prevents
   // the user from losing their work when switching between panels e.g, the preview.
   // The cache is disposed when the user switches to a new challenge.
 
-  void saveTextInCache(String value, Challenge challenge) async {
-    SharedPreferences prefs = await SharedPreferences.getInstance();
-
-    if (currentSelectedFile!.isEmpty) {
-      prefs.setString('${challenge.title}.${challenge.files[0].name}', value);
-    } else {
-      prefs.setString(
-          '${challenge.title}.${currentSelectedFile!.split('.')[0]}', value);
-    }
-  }
-
   // show a message that the console is not yet available
   void consoleSnackbar() {
     snackbar.showSnackbar(
@@ -204,36 +202,6 @@ class ChallengeModel extends BaseViewModel {
     );
   }
 
-  // Get the content of the editor from the cache if it exists. If it doesn't,
-  // return an empty string. This prevents the user from losing their work when
-  // switching between panels e.g, the preview.
-
-  Future<String> getTextFromCache(Challenge challenge) async {
-    SharedPreferences prefs = await SharedPreferences.getInstance();
-
-    if (currentSelectedFile!.isEmpty) {
-      return prefs.getString('${challenge.title}.${challenge.files[0].name}') ??
-          '';
-    } else {
-      return prefs.getString(
-              '${challenge.title}.${currentSelectedFile!.split('.')[0]}') ??
-          '';
-    }
-  }
-
-  Future<String> getExactFileFromCache(
-    Challenge challenge,
-    ChallengeFile file,
-  ) async {
-    SharedPreferences prefs = await SharedPreferences.getInstance();
-    String cache = prefs.getString('${challenge.title}.${file.name}') ?? '';
-
-    List<ChallengeFile> firstHtmlChallenge =
-        challenge.files.where((file) => file.ext == Ext.html).toList();
-
-    return cache.isEmpty ? firstHtmlChallenge[0].contents : cache;
-  }
-
   // This prevents the user from requesting the challenge more than once
   // when swichting between preview and the challenge.
 
@@ -243,8 +211,11 @@ class ChallengeModel extends BaseViewModel {
 
     if (prefs.getString(url) == null) {
       if (res.statusCode == 200) {
-        Challenge challenge = Challenge.fromJson(jsonDecode(res.body)['result']
-            ['data']['challengeNode']['challenge']);
+        Challenge challenge = Challenge.fromJson(
+          jsonDecode(
+            res.body,
+          )['result']['data']['challengeNode']['challenge'],
+        );
 
         prefs.setString(url, res.body);
 
@@ -253,8 +224,10 @@ class ChallengeModel extends BaseViewModel {
     }
 
     Challenge challenge = Challenge.fromJson(
-        jsonDecode(prefs.getString(url) as String)['result']['data']
-            ['challengeNode']['challenge']);
+      jsonDecode(
+        prefs.getString(url) as String,
+      )['result']['data']['challengeNode']['challenge'],
+    );
 
     return challenge;
   }
@@ -270,34 +243,28 @@ class ChallengeModel extends BaseViewModel {
 
     if (currChallenge == null) return parse(doc).outerHtml;
 
-    dom.Document document = parse(doc);
-
     List<ChallengeFile> cssFiles = currChallenge.files
         .where((ChallengeFile file) => file.ext == Ext.css)
         .toList();
 
-    // TODO: Handle javascript files and multiple html files
+    dom.Document document = parse(doc);
 
     List<ChallengeFile> currentFile = currChallenge.files
         .where((element) => element.ext == Ext.html)
         .toList();
 
     if (cssFiles.isNotEmpty) {
-      String text =
-          prefs.getString('${currChallenge.title}.${currentFile[0].name}') ??
-              currentFile[0].contents;
-
-      List<String> linkedCssFiles =
-          await checkForLinks(parse(text), cssFiles, currChallenge);
-
-      if (linkedCssFiles.isNotEmpty) {
-        for (int i = 0; i < linkedCssFiles.length; i++) {
-          String style = '''<style> ${linkedCssFiles[i]} </style>''';
-          dom.Document styleParsed = parse(style);
-          dom.Node styleTag = styleParsed.getElementsByTagName('STYLE')[0];
-          document.getElementsByTagName('HEAD')[0].append(styleTag);
-        }
-      }
+      String text = prefs.getString(
+            '${currChallenge.title}.${currentFile[0].name}',
+          ) ??
+          currentFile[0].contents;
+
+      document = parse(
+        await fileService.parseCssDocmentsAsStyleTags(
+          currChallenge,
+          text,
+        ),
+      );
     }
 
     String viewPort = '''<meta content="width=device-width,
@@ -313,47 +280,6 @@ class ChallengeModel extends BaseViewModel {
     return document.outerHtml;
   }
 
-  Future<List<String>> checkForLinks(dom.Document document,
-      List<ChallengeFile> cssFiles, Challenge currChallenge) async {
-    SharedPreferences prefs = await SharedPreferences.getInstance();
-
-    List<dom.Node> links = document.getElementsByTagName('LINK');
-
-    List<String> linkedFileNames = [];
-    List<String> linkedFilesContent = [];
-
-    if (links.isNotEmpty) {
-      for (dom.Node node in links) {
-        if (node.attributes['href'] == null) continue;
-
-        if (node.attributes['href']!.contains('/')) {
-          linkedFileNames.add(node.attributes['href']!.split('/').last);
-        } else if (node.attributes['href']!.isNotEmpty) {
-          linkedFileNames.add(node.attributes['href'] as String);
-        }
-      }
-    }
-
-    if (linkedFileNames.isNotEmpty) {
-      for (int i = 0; i < linkedFileNames.length; i++) {
-        List<ChallengeFile> files = cssFiles
-            .where((ChallengeFile file) =>
-                file.name == linkedFileNames[i].split('.')[0])
-            .toList();
-
-        String text =
-            prefs.getString('${currChallenge.title}.${files[0].name}') ??
-                files[0].contents;
-
-        if (files.isNotEmpty) {
-          linkedFilesContent.add(text);
-        }
-      }
-    }
-
-    return linkedFilesContent;
-  }
-
   // The hint text is the same as the test text. This is used to display the hint.
   // if the length of the hint is greater than 0, then the hint is displayed. If
   // the length of the hint is 0, then the challenge is completed.
@@ -380,9 +306,9 @@ class ChallengeModel extends BaseViewModel {
   }
 
   ChallengeFile currentFile(Challenge challenge) {
-    if (currentSelectedFile!.isNotEmpty) {
-      ChallengeFile file = challenge.files.firstWhere(
-          (file) => file.name == currentSelectedFile!.split('.')[0]);
+    if (currentSelectedFile.isNotEmpty) {
+      ChallengeFile file = challenge.files
+          .firstWhere((file) => file.name == currentSelectedFile);
       return file;
     }
 
diff --git a/mobile-app/lib/ui/views/learn/challenge_editor/challenge_view.dart b/mobile-app/lib/ui/views/learn/challenge_editor/challenge_view.dart
index 4d5086915..d66caf8b1 100644
--- a/mobile-app/lib/ui/views/learn/challenge_editor/challenge_view.dart
+++ b/mobile-app/lib/ui/views/learn/challenge_editor/challenge_view.dart
@@ -6,6 +6,7 @@ import 'package:flutter_code_editor/editor/editor.dart';
 import 'package:flutter_code_editor/models/editor_options.dart';
 import 'package:flutter_code_editor/models/file_model.dart';
 import 'package:font_awesome_flutter/font_awesome_flutter.dart';
+import 'package:freecodecamp/enums/ext_type.dart';
 import 'package:freecodecamp/enums/panel_type.dart';
 
 import 'package:freecodecamp/models/learn/challenge_model.dart';
@@ -43,8 +44,10 @@ class ChallengeView extends StatelessWidget {
                   int maxChallenges = block.challenges.length;
                   ChallengeFile currFile = model.currentFile(challenge);
 
-                  bool keyBoardIsActive =
-                      MediaQuery.of(context).viewInsets.bottom != 0;
+                  bool keyBoardIsActive = MediaQuery.of(
+                        context,
+                      ).viewInsets.bottom !=
+                      0;
 
                   Editor editor = Editor(
                     language: currFile.ext.name.toUpperCase(),
@@ -57,23 +60,25 @@ class ChallengeView extends StatelessWidget {
                   );
 
                   editor.onTextChange.stream.listen((text) {
-                    model.saveTextInCache(text, challenge);
+                    model.fileService.saveFileInCache(
+                      challenge,
+                      model.currentSelectedFile,
+                      text,
+                    );
                     model.setEditorText = text;
                     model.setCompletedChallenge = false;
                   });
-                  SchedulerBinding.instance.addPostFrameCallback((timeStamp) {
-                    bool keyboardPresent =
-                        MediaQuery.of(context).viewInsets.bottom > 0;
 
-                    if (keyboardPresent && !model.showPanel) {
+                  SchedulerBinding.instance.addPostFrameCallback((timeStamp) {
+                    if (keyBoardIsActive && !model.showPanel) {
                       if (model.hideAppBar) {
                         model.setHideAppBar = false;
                       }
-                    } else if (keyboardPresent && model.showPanel) {
+                    } else if (keyBoardIsActive && model.showPanel) {
                       if (model.hideAppBar) {
                         model.setHideAppBar = false;
                       }
-                    } else if (!keyboardPresent && model.showPanel) {
+                    } else if (!keyBoardIsActive && model.showPanel) {
                       if (!model.hideAppBar) {
                         model.setHideAppBar = true;
                       }
@@ -195,10 +200,12 @@ class ChallengeView extends StatelessWidget {
                                           webcontroller;
                                       webcontroller.loadUrl(Uri.dataFromString(
                                               await model.parsePreviewDocument(
-                                                  await model
-                                                      .getExactFileFromCache(
-                                                          challenge,
-                                                          challenge.files[0])),
+                                                await model.fileService
+                                                    .getFirstFileFromCache(
+                                                  challenge,
+                                                  Ext.html,
+                                                ),
+                                              ),
                                               mimeType: 'text/html',
                                               encoding: utf8)
                                           .toString());
@@ -324,8 +331,13 @@ class ChallengeView extends StatelessWidget {
                       ? const Color.fromRGBO(0x2A, 0x2A, 0x40, 1)
                       : Colors.white),
               onPressed: () async {
-                String currText = await model.getTextFromCache(challenge);
                 ChallengeFile currFile = model.currentFile(challenge);
+
+                String currText = await model.fileService.getExactFileFromCache(
+                  challenge,
+                  currFile,
+                );
+
                 editor.fileTextStream.sink.add(
                   FileStreamEvent(
                     ext: currFile.ext.name.toUpperCase(),
@@ -365,14 +377,12 @@ class ChallengeView extends StatelessWidget {
                                   maxChallenges, challengesCompleted);
                               return;
                             }
+
                             model.setIsRunningTests = true;
                             await model.runner.setWebViewContent(challenge,
                                 webviewController: model.testController!);
                             model.setIsRunningTests = false;
                             FocusManager.instance.primaryFocus?.unfocus();
-                            model.testController?.runJavascript('''
-                                (function(){Flutter.postMessage(window.document.body.outerHTML)})();
-                              ''');
                           }
                         : null,
                     splashColor: Colors.transparent,
diff --git a/mobile-app/lib/ui/views/learn/test_runner.dart b/mobile-app/lib/ui/views/learn/test_runner.dart
index 14816f0d9..427b606e8 100644
--- a/mobile-app/lib/ui/views/learn/test_runner.dart
+++ b/mobile-app/lib/ui/views/learn/test_runner.dart
@@ -1,8 +1,9 @@
 import 'dart:convert';
+import 'package:freecodecamp/app/app.locator.dart';
 import 'package:freecodecamp/enums/ext_type.dart';
 import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:freecodecamp/service/learn_file_service.dart';
 import 'package:html/parser.dart';
-import 'package:shared_preferences/shared_preferences.dart';
 import 'package:stacked/stacked.dart';
 import 'package:webview_flutter/webview_flutter.dart';
 import 'package:html/dom.dart' as dom;
@@ -16,162 +17,7 @@ class TestRunner extends BaseViewModel {
     notifyListeners();
   }
 
-  // This function returns a specific file content from the cache.
-  // If testing is enabled on the function it will return
-  // the first file with the given file name.
-
-  Future<String> getExactFileFromCache(
-    Challenge challenge,
-    ChallengeFile file, {
-    bool testing = false,
-  }) async {
-    String? cache;
-
-    if (testing) {
-      cache = challenge.files
-          .firstWhere((element) => element.name == file.name)
-          .contents;
-    } else {
-      SharedPreferences prefs = await SharedPreferences.getInstance();
-      cache = prefs.getString('${challenge.title}.${file.name}');
-    }
-
-    return cache ?? '';
-  }
-
-  // This funciton returns the first file content with the given extension from the
-  // cache. If testing is enabled it will return the file directly from the challenge.
-  // If a CSS extension is put as a parameter it will return the first HTML file instead.
-
-  Future<String> getFirstFileFromCache(
-    Challenge challenge,
-    Ext ext, {
-    bool testing = false,
-  }) async {
-    String fileContent = '';
-
-    if (testing) {
-      List<ChallengeFile> firstHtmlChallenge = challenge.files
-          .where((file) => (file.ext == Ext.css || file.ext == Ext.html)
-              ? file.ext == Ext.html
-              : file.ext == ext)
-          .toList();
-      fileContent = firstHtmlChallenge[0].contents;
-    } else {
-      List<ChallengeFile> firstChallenge = challenge.files
-          .where((file) => (file.ext == Ext.css || file.ext == Ext.html)
-              ? file.ext == Ext.html
-              : file.ext == ext)
-          .toList();
-      SharedPreferences prefs = await SharedPreferences.getInstance();
-
-      fileContent =
-          prefs.getString('${challenge.title}.${firstChallenge[0].name}') ??
-              firstChallenge[0].contents;
-    }
-
-    return fileContent;
-  }
-
-  // this function will get the current file which is being edited.
-  // otherwise we can not detect which file is currently being worked on. This is only for the new RWD.
-
-  Future<String> getCurrentEditedFileFromCache(
-    Challenge challenge, {
-    bool testing = false,
-  }) async {
-    List<ChallengeFile>? fileWithEditableRegion = challenge.files
-        .where((file) => file.editableRegionBoundaries.isNotEmpty)
-        .toList();
-    if (testing) {
-      return fileWithEditableRegion.isNotEmpty
-          ? fileWithEditableRegion[0].contents
-          : challenge.files[0].contents;
-    }
-
-    SharedPreferences prefs = await SharedPreferences.getInstance();
-    return prefs.getString(
-            '${challenge.title}.${fileWithEditableRegion[0].name}') ??
-        fileWithEditableRegion[0].contents;
-  }
-
-  // This function checks if the given document contains any link elements.
-  // If so check if the css file name corresponds with the names put in the array.
-  // If the file is linked return true.
-
-  Future<bool> cssFileIsLinked(
-    String document,
-    String cssFileName,
-  ) async {
-    dom.Document doc = parse(document);
-
-    List<dom.Node> links = doc.getElementsByTagName('LINK');
-
-    List<String> linkedFileNames = [];
-
-    if (links.isNotEmpty) {
-      for (dom.Node node in links) {
-        if (node.attributes['href'] == null) continue;
-
-        if (node.attributes['href']!.contains('/')) {
-          linkedFileNames.add(node.attributes['href']!.split('/').last);
-        } else if (node.attributes['href']!.isNotEmpty) {
-          linkedFileNames.add(node.attributes['href'] as String);
-        }
-      }
-    }
-
-    return linkedFileNames.contains(cssFileName);
-  }
-
-  // This function puts the given css content in the same file as the HTML content.
-  // It will parse the current CSS content into style tags only if it is linked.
-  // If there is nothing to parse it will return the plain content document.
-
-  Future<String> parseCssDocmentsAsStyleTags(
-    Challenge challenge,
-    String content, {
-    bool testing = false,
-  }) async {
-    List<ChallengeFile> cssFiles =
-        challenge.files.where((element) => element.ext == Ext.css).toList();
-    List<String> cssFilesWithCache = [];
-    List<String> tags = [];
-
-    if (cssFiles.isNotEmpty) {
-      for (ChallengeFile file in cssFiles) {
-        String? cache = await getExactFileFromCache(
-          challenge,
-          file,
-          testing: testing,
-        );
-
-        if (!await cssFileIsLinked(
-          content,
-          '${file.name}.${file.ext.name}',
-        )) {
-          continue;
-        }
-
-        String handledFile = cache;
-
-        cssFilesWithCache.add(handledFile);
-      }
-
-      for (String contents in cssFilesWithCache) {
-        String tag = '<style> $contents </style>';
-        tags.add(tag);
-      }
-
-      for (String tag in tags) {
-        content += tag;
-      }
-
-      return content;
-    }
-
-    return content;
-  }
+  final LearnFileService fileService = locator<LearnFileService>();
 
   // This function sets the webview content, and parses the document accordingly.
   // It will create a new empty document. (There is no content set from
@@ -253,13 +99,13 @@ class TestRunner extends BaseViewModel {
     Ext ext, {
     bool testing = false,
   }) async {
-    String firstHTMlfile = await getFirstFileFromCache(
+    String firstHTMlfile = await fileService.getFirstFileFromCache(
       challenge,
       ext,
       testing: testing,
     );
 
-    String parsedWithStyleTags = await parseCssDocmentsAsStyleTags(
+    String parsedWithStyleTags = await fileService.parseCssDocmentsAsStyleTags(
       challenge,
       firstHTMlfile,
       testing: testing,
@@ -278,7 +124,7 @@ class TestRunner extends BaseViewModel {
   }) async {
     var content = testing
         ? challenge.files[0].contents
-        : await getFirstFileFromCache(challenge, Ext.js);
+        : await fileService.getFirstFileFromCache(challenge, Ext.js);
 
     return content
         .replaceAll('\\', '\\\\')
@@ -354,9 +200,9 @@ class TestRunner extends BaseViewModel {
     function getUserInput(returnCase){
       switch(returnCase){
         case 'index':
-          return `${(await getCurrentEditedFileFromCache(challenge, testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$')}`;
+          return `${(await fileService.getCurrentEditedFileFromCache(challenge, testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$')}`;
         case 'editableContents':
-        return `${(await getCurrentEditedFileFromCache(challenge, testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$')}`;
+        return `${(await fileService.getCurrentEditedFileFromCache(challenge, testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$')}`;
         default:
           return code;
       }
@@ -409,9 +255,9 @@ class TestRunner extends BaseViewModel {
       function getUserInput(returnCase){
         switch(returnCase){
           case 'index':
-            return `${scriptFile.isNotEmpty ? (await getExactFileFromCache(challenge, scriptFile[0], testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$') : "empty string"}`;
+            return `${scriptFile.isNotEmpty ? (await fileService.getExactFileFromCache(challenge, scriptFile[0], testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$') : "empty string"}`;
           case 'editableContents':
-            return `${scriptFile.isNotEmpty ? (await getExactFileFromCache(challenge, scriptFile[0], testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$') : "empty string"}`;
+            return `${scriptFile.isNotEmpty ? (await fileService.getExactFileFromCache(challenge, scriptFile[0], testing: testing)).replaceAll('\\', '\\\\').replaceAll('`', '\\`').replaceAll('\$', r'\$') : "empty string"}`;
           default:
             return code;
         }
diff --git a/mobile-app/lib/ui/views/learn/widgets/custom_tab_bar/custom_tab_bar.dart b/mobile-app/lib/ui/views/learn/widgets/custom_tab_bar/custom_tab_bar.dart
index 2ff86106f..d0bc81951 100644
--- a/mobile-app/lib/ui/views/learn/widgets/custom_tab_bar/custom_tab_bar.dart
+++ b/mobile-app/lib/ui/views/learn/widgets/custom_tab_bar/custom_tab_bar.dart
@@ -28,18 +28,21 @@ class CustomTabBar extends StatelessWidget {
                   : const BorderSide())),
       child: ElevatedButton(
           onPressed: () async {
-            model.setCurrentSelectedFile = '${file.name}.${file.ext.name}';
-            String currText = await model.getTextFromCache(challenge);
+            model.setCurrentSelectedFile = file.name;
             ChallengeFile currFile = model.currentFile(challenge);
+
+            String currText = await model.fileService.getExactFileFromCache(
+              challenge,
+              currFile,
+            );
+
             editor.fileTextStream.sink.add(
               FileStreamEvent(
                 ext: currFile.ext.name.toUpperCase(),
                 content: currText == '' ? currFile.contents : currText,
               ),
             );
-            model.setEditorText = currText == ''
-                ? currFile.contents
-                : currText;
+            model.setEditorText = currText == '' ? currFile.contents : currText;
             model.setShowPreview = false;
           },
           child: Text(
diff --git a/mobile-app/pubspec.lock b/mobile-app/pubspec.lock
index a160efb01..893e86be2 100644
--- a/mobile-app/pubspec.lock
+++ b/mobile-app/pubspec.lock
@@ -218,6 +218,13 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "3.0.2"
+  coverage:
+    dependency: transitive
+    description:
+      name: coverage
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "1.2.0"
   cross_file:
     dependency: transitive
     description:
@@ -828,6 +835,13 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "1.0.0"
+  node_preamble:
+    dependency: transitive
+    description:
+      name: node_preamble
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "2.0.1"
   numerus:
     dependency: transitive
     description:
@@ -1157,6 +1171,20 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "1.3.0"
+  shelf_packages_handler:
+    dependency: transitive
+    description:
+      name: shelf_packages_handler
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "3.0.1"
+  shelf_static:
+    dependency: transitive
+    description:
+      name: shelf_static
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "1.1.1"
   shelf_web_socket:
     dependency: transitive
     description:
@@ -1190,6 +1218,20 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "1.3.2"
+  source_map_stack_trace:
+    dependency: transitive
+    description:
+      name: source_map_stack_trace
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "2.1.0"
+  source_maps:
+    dependency: transitive
+    description:
+      name: source_maps
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "0.10.10"
   source_span:
     dependency: transitive
     description:
@@ -1231,7 +1273,7 @@ packages:
       name: stacked
       url: "https://pub.dartlang.org"
     source: hosted
-    version: "2.3.10"
+    version: "3.0.0"
   stacked_core:
     dependency: transitive
     description:
@@ -1295,6 +1337,13 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "1.2.0"
+  test:
+    dependency: "direct main"
+    description:
+      name: test
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "1.21.1"
   test_api:
     dependency: transitive
     description:
@@ -1302,6 +1351,13 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "0.4.9"
+  test_core:
+    dependency: transitive
+    description:
+      name: test_core
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "0.4.13"
   timezone:
     dependency: transitive
     description:
@@ -1505,6 +1561,13 @@ packages:
       url: "https://pub.dartlang.org"
     source: hosted
     version: "3.0.0"
+  webkit_inspection_protocol:
+    dependency: transitive
+    description:
+      name: webkit_inspection_protocol
+      url: "https://pub.dartlang.org"
+    source: hosted
+    version: "1.2.0"
   webview_cookie_manager:
     dependency: "direct main"
     description:
diff --git a/mobile-app/pubspec.yaml b/mobile-app/pubspec.yaml
index 3f15a0541..19e82cbb0 100644
--- a/mobile-app/pubspec.yaml
+++ b/mobile-app/pubspec.yaml
@@ -67,6 +67,7 @@ dependencies:
   path: ^1.8.1
   audio_service: ^0.18.4
   device_info_plus: ^4.0.1
+  test: ^1.21.1
 dev_dependencies:
   build_runner: ^2.1.2
   integration_test:
diff --git a/mobile-app/test/unit/learn_file_controller_test.dart b/mobile-app/test/unit/learn_file_controller_test.dart
new file mode 100644
index 000000000..40222e6af
--- /dev/null
+++ b/mobile-app/test/unit/learn_file_controller_test.dart
@@ -0,0 +1,136 @@
+import 'package:flutter_test/flutter_test.dart';
+import 'package:freecodecamp/enums/ext_type.dart';
+import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:freecodecamp/service/learn_file_service.dart';
+import 'package:shared_preferences/shared_preferences.dart';
+
+void main() {
+  TestWidgetsFlutterBinding.ensureInitialized();
+
+  LearnFileService service = LearnFileService();
+
+  Challenge challenge = Challenge(
+      id: '1',
+      block: 'basic html',
+      title: 'hello-world',
+      description: 'this is the description',
+      instructions: 'make your first header',
+      slug: 'make-your-first-header',
+      superBlock: '2022/responsive-web-design',
+      challengeType: 1,
+      tests: [],
+      files: [
+        ChallengeFile(
+            ext: Ext.html,
+            name: 'index',
+            editableRegionBoundaries: [],
+            contents: 'this is the html file content',
+            history: [],
+            fileKey: 'index.html'),
+        ChallengeFile(
+            ext: Ext.css,
+            name: 'styles',
+            editableRegionBoundaries: [1, 5],
+            contents: 'this is the css file content',
+            history: [],
+            fileKey: 'styles.css')
+      ]);
+
+  group('getExactFileFromCache function', () {
+    testWidgets(
+      'with testing it should return the exact file',
+      (tester) async {
+        String content = await service.getExactFileFromCache(
+          challenge,
+          challenge.files[1],
+          testing: true,
+        );
+
+        expect(content, 'this is the css file content');
+      },
+    );
+  });
+
+  group('getFirstFileFromCache function', () {
+    testWidgets('it should give priority for html files over css files',
+        (tester) async {
+      String value = await service.getFirstFileFromCache(
+        challenge,
+        Ext.css,
+        testing: true,
+      );
+
+      expect(value, 'this is the html file content');
+    });
+  });
+
+  group('getCurrentEditedFileFromCache function', () {
+    testWidgets('it should get the file with the editable region',
+        (tester) async {
+      SharedPreferences.setMockInitialValues({});
+      String value = await service.getCurrentEditedFileFromCache(challenge);
+
+      expect(value, 'this is the css file content');
+    });
+
+    testWidgets(
+        'if there is no editable region it should return the first file',
+        (tester) async {
+      Challenge newChallenge = challenge;
+      newChallenge.files[1].editableRegionBoundaries = [];
+
+      String value = await service.getCurrentEditedFileFromCache(newChallenge);
+
+      expect(value, 'this is the html file content');
+    });
+  });
+
+  group('cssFileLinked function', () {
+    testWidgets('it should return false if the file is not linked',
+        (tester) async {
+      bool value = await service.cssFileIsLinked(
+        challenge.files[0].contents,
+        challenge.files[1].name,
+      );
+
+      expect(value, false);
+    });
+
+    testWidgets('it should return true if the file is linked', (tester) async {
+      String document = '''
+      <html>
+        <head>
+          <title> Document </title>
+          <link href="styles.css">
+        </head>
+      </html>
+      ''';
+
+      bool value = await service.cssFileIsLinked(
+        document,
+        challenge.files[1].fileKey,
+      );
+
+      expect(value, true);
+    });
+
+    testWidgets('it should return true if the file in a folder and is linked',
+        (tester) async {
+      String document = '''
+      <html>
+        <head>
+          <title> Document </title>
+          <link href="./src/styles.css">
+        </head>
+      </html>
+      ''';
+
+      bool value = await service.cssFileIsLinked(
+        document,
+        challenge.files[1].fileKey,
+      );
+
+      expect(value, true);
+    });
+  });
+}
