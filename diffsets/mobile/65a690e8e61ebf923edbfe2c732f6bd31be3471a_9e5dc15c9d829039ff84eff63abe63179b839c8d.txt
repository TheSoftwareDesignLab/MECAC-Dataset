diff --git a/lib/src/model/game/game_controller.dart b/lib/src/model/game/game_controller.dart
index 486f1db5d5..b78cbe30ca 100644
--- a/lib/src/model/game/game_controller.dart
+++ b/lib/src/model/game/game_controller.dart
@@ -65,18 +65,13 @@ class GameController extends _$GameController {
 
   static Uri gameSocketUri(GameFullId gameFullId) => Uri(path: '/play/$gameFullId/v6');
 
+  SocketPool get _socketPool => ref.read(socketPoolProvider);
+
   ChessClock? _clock;
   late SocketClient _socketClient;
 
   @override
   Future<GameState> build(GameFullId gameFullId) {
-    final socketPool = ref.watch(socketPoolProvider);
-
-    _socketClient = socketPool.open(gameSocketUri(gameFullId), forceReconnect: true);
-    _socketEventVersion = null;
-    _socketSubscription?.cancel();
-    _socketSubscription = _socketClient.stream.listen(_handleSocketEvent);
-
     ref.onDispose(() {
       _socketSubscription?.cancel();
       _opponentLeftCountdownTimer?.cancel();
@@ -86,6 +81,8 @@ class GameController extends _$GameController {
       _onFlagThrottler.cancel();
     });
 
+    listenToSocketEvents();
+
     return _socketClient.stream.firstWhere((e) => e.topic == 'full').then((event) async {
       final fullEvent = GameFullEvent.fromJson(event.data as Map<String, dynamic>);
 
@@ -150,6 +147,19 @@ class GameController extends _$GameController {
     });
   }
 
+  /// Starts listening to game socket events.
+  void listenToSocketEvents() {
+    _socketClient = _socketPool.open(gameSocketUri(gameFullId), forceReconnect: true);
+    _socketEventVersion = null;
+    _socketSubscription?.cancel();
+    _socketSubscription = _socketClient.stream.listen(_handleSocketEvent);
+  }
+
+  /// Stops listening to game socket events.
+  void stopListeningToSocketEvents() {
+    _socketSubscription?.cancel();
+  }
+
   void userMove(NormalMove move, {bool? isDrop, bool? isPremove}) {
     final curState = state.requireValue;
 
diff --git a/lib/src/view/game/game_body.dart b/lib/src/view/game/game_body.dart
index 3008960122..5c0d215446 100644
--- a/lib/src/view/game/game_body.dart
+++ b/lib/src/view/game/game_body.dart
@@ -16,6 +16,7 @@ import 'package:lichess_mobile/src/model/game/game_preferences.dart';
 import 'package:lichess_mobile/src/model/game/playable_game.dart';
 import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
+import 'package:lichess_mobile/src/utils/focus_detector.dart';
 import 'package:lichess_mobile/src/utils/gestures_exclusion.dart';
 import 'package:lichess_mobile/src/utils/immersive_mode.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
@@ -233,75 +234,85 @@ class GameBody extends ConsumerWidget {
                 ? Duration.zero
                 : boardPreferences.pieceAnimationDuration;
 
-        final content = WakelockWidget(
-          shouldEnableOnFocusGained: () => gameState.game.playable,
-          child: PopScope(
-            canPop: gameState.game.meta.speed == Speed.correspondence || !gameState.game.playable,
-            child: Column(
-              children: [
-                Expanded(
-                  child: SafeArea(
-                    bottom: false,
-                    child: BoardTable(
-                      key: boardKey,
-                      boardSettingsOverrides: BoardSettingsOverrides(
-                        animationDuration: animationDuration,
-                        autoQueenPromotion: gameState.canAutoQueen,
-                        autoQueenPromotionOnPremove: gameState.canAutoQueenOnPremove,
-                        blindfoldMode: blindfoldMode,
-                      ),
-                      orientation: isBoardTurned ? youAre.opposite : youAre,
-                      lastMove: gameState.game.moveAt(gameState.stepCursor) as NormalMove?,
-                      interactiveBoardParams: (
-                        variant: gameState.game.meta.variant,
-                        position: gameState.currentPosition,
-                        playerSide:
-                            gameState.game.playable && !gameState.isReplaying
-                                ? youAre == Side.white
-                                    ? PlayerSide.white
-                                    : PlayerSide.black
-                                : PlayerSide.none,
-                        promotionMove: gameState.promotionMove,
-                        onMove: (move, {isDrop}) {
-                          ref.read(ctrlProvider.notifier).userMove(move, isDrop: isDrop);
-                        },
-                        onPromotionSelection: (role) {
-                          ref.read(ctrlProvider.notifier).onPromotionSelection(role);
+        final content = FocusDetector(
+          onFocusRegained: () {
+            // force the game socket to connect
+            ref.read(ctrlProvider.notifier).listenToSocketEvents();
+          },
+          onFocusLost: () {
+            // we don't want to stop listening to socket events when the focus is lost, because
+            // if the socket connection is shut down, the server will assume the player left the game
+          },
+          child: WakelockWidget(
+            shouldEnableOnFocusGained: () => gameState.game.playable,
+            child: PopScope(
+              canPop: gameState.game.meta.speed == Speed.correspondence || !gameState.game.playable,
+              child: Column(
+                children: [
+                  Expanded(
+                    child: SafeArea(
+                      bottom: false,
+                      child: BoardTable(
+                        key: boardKey,
+                        boardSettingsOverrides: BoardSettingsOverrides(
+                          animationDuration: animationDuration,
+                          autoQueenPromotion: gameState.canAutoQueen,
+                          autoQueenPromotionOnPremove: gameState.canAutoQueenOnPremove,
+                          blindfoldMode: blindfoldMode,
+                        ),
+                        orientation: isBoardTurned ? youAre.opposite : youAre,
+                        lastMove: gameState.game.moveAt(gameState.stepCursor) as NormalMove?,
+                        interactiveBoardParams: (
+                          variant: gameState.game.meta.variant,
+                          position: gameState.currentPosition,
+                          playerSide:
+                              gameState.game.playable && !gameState.isReplaying
+                                  ? youAre == Side.white
+                                      ? PlayerSide.white
+                                      : PlayerSide.black
+                                  : PlayerSide.none,
+                          promotionMove: gameState.promotionMove,
+                          onMove: (move, {isDrop}) {
+                            ref.read(ctrlProvider.notifier).userMove(move, isDrop: isDrop);
+                          },
+                          onPromotionSelection: (role) {
+                            ref.read(ctrlProvider.notifier).onPromotionSelection(role);
+                          },
+                          premovable:
+                              gameState.canPremove
+                                  ? (
+                                    onSetPremove: (move) {
+                                      ref.read(ctrlProvider.notifier).setPremove(move);
+                                    },
+                                    premove: gameState.premove,
+                                  )
+                                  : null,
+                        ),
+                        topTable: topPlayer,
+                        bottomTable:
+                            gameState.canShowClaimWinCountdown &&
+                                    gameState.opponentLeftCountdown != null
+                                ? _ClaimWinCountdown(duration: gameState.opponentLeftCountdown!)
+                                : bottomPlayer,
+                        moves: gameState.game.steps
+                            .skip(1)
+                            .map((e) => e.sanMove!.san)
+                            .toList(growable: false),
+                        currentMoveIndex: gameState.stepCursor,
+                        onSelectMove: (moveIndex) {
+                          ref.read(ctrlProvider.notifier).cursorAt(moveIndex);
                         },
-                        premovable:
-                            gameState.canPremove
-                                ? (
-                                  onSetPremove: (move) {
-                                    ref.read(ctrlProvider.notifier).setPremove(move);
-                                  },
-                                  premove: gameState.premove,
-                                )
-                                : null,
+                        zenMode: gameState.isZenModeActive,
                       ),
-                      topTable: topPlayer,
-                      bottomTable:
-                          gameState.canShowClaimWinCountdown &&
-                                  gameState.opponentLeftCountdown != null
-                              ? _ClaimWinCountdown(duration: gameState.opponentLeftCountdown!)
-                              : bottomPlayer,
-                      moves: gameState.game.steps
-                          .skip(1)
-                          .map((e) => e.sanMove!.san)
-                          .toList(growable: false),
-                      currentMoveIndex: gameState.stepCursor,
-                      onSelectMove: (moveIndex) {
-                        ref.read(ctrlProvider.notifier).cursorAt(moveIndex);
-                      },
-                      zenMode: gameState.isZenModeActive,
                     ),
                   ),
-                ),
-                _GameBottomBar(
-                  id: id,
-                  onLoadGameCallback: onLoadGameCallback,
-                  onNewOpponentCallback: onNewOpponentCallback,
-                ),
-              ],
+                  _GameBottomBar(
+                    id: id,
+                    onLoadGameCallback: onLoadGameCallback,
+                    onNewOpponentCallback: onNewOpponentCallback,
+                  ),
+                ],
+              ),
             ),
           ),
         );
