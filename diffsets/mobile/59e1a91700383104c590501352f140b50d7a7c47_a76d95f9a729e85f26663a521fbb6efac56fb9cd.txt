diff --git a/lib/src/utils/image.dart b/lib/src/utils/image.dart
index 1067e67e3a..15c3447e1b 100644
--- a/lib/src/utils/image.dart
+++ b/lib/src/utils/image.dart
@@ -7,7 +7,7 @@ import 'package:image/image.dart' as img;
 import 'package:material_color_utilities/material_color_utilities.dart';
 
 typedef ImageColors = ({
-  Uint8List image,
+  Uint8List? image,
   int primaryContainer,
   int onPrimaryContainer,
   int error,
@@ -27,7 +27,8 @@ class ImageColorWorker {
 
   bool get closed => _closed;
 
-  /// Returns a minimal color scheme associated with the image at the given [url].
+  /// Returns a minimal color scheme associated with the image at the given [url], or
+  /// the given [image] if provided.
   ///
   /// The [fileExtension] parameter is optional and is used to specify the file
   /// extension of the image at the given [url] if it is known. It will speed up
@@ -35,13 +36,14 @@ class ImageColorWorker {
   /// against all supported decoders.
   Future<ImageColors?> getImageColors(
     String url, {
+    Uint8List? image,
     String? fileExtension,
   }) async {
     if (_closed) throw StateError('Closed');
     final completer = Completer<ImageColors?>.sync();
     final id = _idCounter++;
     _activeRequests[id] = completer;
-    _commands.send((id, url, fileExtension));
+    _commands.send((id, url, image, fileExtension));
     return await completer.future;
   }
 
@@ -97,16 +99,16 @@ class ImageColorWorker {
         receivePort.close();
         return;
       }
-      final (int id, String url, String? extension) =
-          message as (int, String, String?);
+      final (int id, String url, Uint8List? image, String? extension) =
+          message as (int, String, Uint8List?, String?);
       try {
-        final bytes = await http.readBytes(Uri.parse(url));
+        final bytes = image ?? await http.readBytes(Uri.parse(url));
         // final stopwatch0 = Stopwatch()..start();
         final decoder = extension != null
             ? img.findDecoderForNamedImage('.$extension')
             : img.findDecoderForData(bytes);
-        final image = decoder!.decode(bytes);
-        final resized = img.copyResize(image!, width: 112);
+        final decoded = decoder!.decode(bytes);
+        final resized = img.copyResize(decoded!, width: 112);
         final QuantizerResult quantizerResult =
             await QuantizerCelebi().quantize(
           resized.buffer.asUint32List(),
@@ -132,7 +134,7 @@ class ImageColorWorker {
           contrastLevel: 0.0,
         );
         final result = (
-          image: bytes,
+          image: image == null ? bytes : null,
           primaryContainer: scheme.primaryContainer,
           onPrimaryContainer: scheme.onPrimaryContainer,
           error: scheme.error,
diff --git a/lib/src/utils/l10n.dart b/lib/src/utils/l10n.dart
index fcfe83aee0..bf7b6adc33 100644
--- a/lib/src/utils/l10n.dart
+++ b/lib/src/utils/l10n.dart
@@ -1,4 +1,5 @@
 import 'package:flutter/material.dart';
+import 'package:intl/intl.dart';
 
 /// Returns a localized string with a single placeholder replaced by a widget.
 ///
@@ -43,6 +44,24 @@ Text l10nWithWidget<T extends Widget>(
   );
 }
 
+final _dayFormatter = DateFormat.E().add_jm();
+final _monthFormatter = DateFormat.MMMd().add_Hm();
+final _dateFormatterWithYear = DateFormat.yMMMd().add_Hm();
+
+String relativeDate(DateTime date) {
+  final diff = date.difference(DateTime.now());
+
+  return (!diff.isNegative && diff.inDays == 0)
+      ? diff.inHours == 0
+          ? 'in ${diff.inMinutes} minute${diff.inMinutes > 1 ? 's' : ''}' // TODO translate with https://github.com/lichess-org/lila/blob/65b28ea8e43e0133df6c7ed40e03c2954f247d1e/translation/source/timeago.xml#L8
+          : 'in ${diff.inHours} hour${diff.inHours > 1 ? 's' : ''}' // TODO translate with https://github.com/lichess-org/lila/blob/65b28ea8e43e0133df6c7ed40e03c2954f247d1e/translation/source/timeago.xml#L12
+      : diff.inDays <= 7
+          ? _dayFormatter.format(date)
+          : diff.inDays < 365
+              ? _monthFormatter.format(date)
+              : _dateFormatterWithYear.format(date);
+}
+
 /// Returns a localized locale name.
 ///
 /// Names taken from https://github.com/lichess-org/lila/blob/master/modules/i18n/src/main/LangList.scala.
diff --git a/lib/src/view/broadcast/broadcast_list_screen.dart b/lib/src/view/broadcast/broadcast_list_screen.dart
index 6ed0dab15d..dd589f6dc4 100644
--- a/lib/src/view/broadcast/broadcast_list_screen.dart
+++ b/lib/src/view/broadcast/broadcast_list_screen.dart
@@ -1,17 +1,18 @@
 import 'dart:async';
+import 'dart:typed_data';
 
 import 'package:auto_size_text/auto_size_text.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter/scheduler.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:intl/intl.dart';
 import 'package:lichess_mobile/src/model/broadcast/broadcast.dart';
 import 'package:lichess_mobile/src/model/broadcast/broadcast_providers.dart';
 import 'package:lichess_mobile/src/model/common/id.dart';
 import 'package:lichess_mobile/src/styles/lichess_colors.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
 import 'package:lichess_mobile/src/utils/image.dart';
+import 'package:lichess_mobile/src/utils/l10n.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
@@ -19,9 +20,6 @@ import 'package:lichess_mobile/src/view/broadcast/broadcast_round_screen.dart';
 import 'package:lichess_mobile/src/widgets/platform.dart';
 import 'package:lichess_mobile/src/widgets/shimmer.dart';
 
-final _dateFormatter = DateFormat.MMMd().add_Hm();
-final _dateFormatterWithYear = DateFormat.yMMMd().add_Hm();
-
 const kDefaultBroadcastImage = AssetImage('assets/images/broadcast_image.png');
 const kBroadcastGridItemBorderRadius = BorderRadius.all(Radius.circular(16.0));
 const kBroadcastGridItemContentPadding = EdgeInsets.symmetric(horizontal: 16.0);
@@ -256,6 +254,28 @@ typedef _CardColors = ({
 });
 final Map<ImageProvider, _CardColors> _colorsCache = {};
 
+Future<(_CardColors, Uint8List?)?> _computeImageColors(
+  ImageColorWorker worker,
+  String imageUrl, [
+  Uint8List? image,
+]) async {
+  final response = await worker.getImageColors(
+    imageUrl,
+    fileExtension: 'webp',
+  );
+  if (response != null) {
+    final (:image, :primaryContainer, :onPrimaryContainer, :error) = response;
+    final cardColors = (
+      primaryContainer: Color(primaryContainer),
+      onPrimaryContainer: Color(onPrimaryContainer),
+      error: Color(error),
+    );
+    _colorsCache[NetworkImage(imageUrl)] = cardColors;
+    return (cardColors, image);
+  }
+  return null;
+}
+
 class _BroadcastGridItemState extends State<BroadcastGridItem> {
   _CardColors? _cardColors;
   ImageProvider? _imageProvider;
@@ -263,16 +283,16 @@ class _BroadcastGridItemState extends State<BroadcastGridItem> {
 
   String? get imageUrl => widget.broadcast.tour.imageUrl;
 
-  ImageProvider get image =>
+  ImageProvider get imageProvider =>
       imageUrl != null ? NetworkImage(imageUrl!) : kDefaultBroadcastImage;
 
   @override
   void didChangeDependencies() {
     super.didChangeDependencies();
-    final cachedColors = _colorsCache[image];
+    final cachedColors = _colorsCache[imageProvider];
     if (cachedColors != null) {
       _cardColors = cachedColors;
-      _imageProvider = image;
+      _imageProvider = imageProvider;
     } else {
       if (imageUrl != null) {
         _fetchImageAndColors(NetworkImage(imageUrl!));
@@ -290,22 +310,12 @@ class _BroadcastGridItemState extends State<BroadcastGridItem> {
         scheduleMicrotask(() => _fetchImageAndColors(provider));
       });
     } else if (widget.worker.closed == false) {
-      final response = await widget.worker.getImageColors(
-        provider.url,
-        fileExtension: 'webp',
-      );
+      final response = await _computeImageColors(widget.worker, provider.url);
       if (response != null) {
-        final (:image, :primaryContainer, :onPrimaryContainer, :error) =
-            response;
-        final cardColors = (
-          primaryContainer: Color(primaryContainer),
-          onPrimaryContainer: Color(onPrimaryContainer),
-          error: Color(error),
-        );
-        _colorsCache[provider] = cardColors;
+        final (cardColors, image) = response;
         if (mounted) {
           setState(() {
-            _imageProvider = MemoryImage(image);
+            _imageProvider = image != null ? MemoryImage(image) : imageProvider;
             _cardColors = cardColors;
           });
         }
@@ -436,7 +446,7 @@ class _BroadcastGridItemState extends State<BroadcastGridItem> {
                             )
                           else
                             Text(
-                              _formatDate(widget.broadcast.round.startsAt!),
+                              relativeDate(widget.broadcast.round.startsAt!),
                               style: TextStyle(
                                 fontSize: 12,
                                 color: subTitleColor,
@@ -487,14 +497,32 @@ class _BroadcastGridItemState extends State<BroadcastGridItem> {
   }
 }
 
-String _formatDate(DateTime date) {
-  final diff = date.difference(DateTime.now());
-
-  return (!diff.isNegative && diff.inDays == 0)
-      ? diff.inHours == 0
-          ? 'in ${diff.inMinutes} minutes' // TODO translate with https://github.com/lichess-org/lila/blob/65b28ea8e43e0133df6c7ed40e03c2954f247d1e/translation/source/timeago.xml#L8
-          : 'in ${diff.inHours} hours' // TODO translate with https://github.com/lichess-org/lila/blob/65b28ea8e43e0133df6c7ed40e03c2954f247d1e/translation/source/timeago.xml#L12
-      : diff.inDays < 365
-          ? _dateFormatter.format(date)
-          : _dateFormatterWithYear.format(date);
+Future<void> preCacheBroadcastImages(
+  BuildContext context, {
+  required Iterable<Broadcast> broadcasts,
+  required ImageColorWorker worker,
+}) async {
+  for (final broadcast in broadcasts) {
+    final imageUrl = broadcast.tour.imageUrl;
+    if (imageUrl != null) {
+      final provider = NetworkImage(imageUrl);
+      await precacheImage(provider, context);
+      final imageStream = provider.resolve(ImageConfiguration.empty);
+      final Completer<Uint8List?> completer = Completer<Uint8List?>();
+      final ImageStreamListener listener = ImageStreamListener(
+        (imageInfo, synchronousCall) async {
+          final bytes = await imageInfo.image.toByteData();
+          if (!completer.isCompleted) {
+            completer.complete(bytes?.buffer.asUint8List());
+          }
+        },
+      );
+      imageStream.addListener(listener);
+      final imageBytes = await completer.future;
+      imageStream.removeListener(listener);
+      if (imageBytes != null) {
+        await _computeImageColors(worker, imageUrl, imageBytes);
+      }
+    }
+  }
 }
diff --git a/lib/src/view/watch/watch_tab_screen.dart b/lib/src/view/watch/watch_tab_screen.dart
index f7b93fe9c0..acf4804e53 100644
--- a/lib/src/view/watch/watch_tab_screen.dart
+++ b/lib/src/view/watch/watch_tab_screen.dart
@@ -4,7 +4,6 @@ import 'package:fast_immutable_collections/fast_immutable_collections.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:intl/intl.dart';
 import 'package:lichess_mobile/src/model/broadcast/broadcast.dart';
 import 'package:lichess_mobile/src/model/broadcast/broadcast_providers.dart';
 import 'package:lichess_mobile/src/model/tv/featured_player.dart';
@@ -17,6 +16,8 @@ import 'package:lichess_mobile/src/navigation.dart';
 import 'package:lichess_mobile/src/network/http.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
+import 'package:lichess_mobile/src/utils/image.dart';
+import 'package:lichess_mobile/src/utils/l10n.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/view/broadcast/broadcast_list_screen.dart';
@@ -143,18 +144,53 @@ class _WatchScreenState extends ConsumerState<WatchTabScreen> {
   Future<void> refreshData() => _refreshData(ref);
 }
 
-class _Body extends ConsumerWidget {
+class _Body extends ConsumerStatefulWidget {
   const _Body(this.orientation);
 
   final Orientation orientation;
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
+  ConsumerState<_Body> createState() => _BodyState();
+}
+
+class _BodyState extends ConsumerState<_Body> {
+  ImageColorWorker? _worker;
+  bool _imageAreCached = false;
+
+  @override
+  void initState() {
+    super.initState();
+    _precacheImages();
+  }
+
+  @override
+  void dispose() {
+    _worker?.close();
+    super.dispose();
+  }
+
+  Future<void> _precacheImages() async {
+    _worker = await ref.read(broadcastImageWorkerFactoryProvider).spawn();
+    ref.listenManual(broadcastsPaginatorProvider, (_, current) async {
+      if (current.hasValue && !_imageAreCached) {
+        _imageAreCached = true;
+        await preCacheBroadcastImages(
+          context,
+          broadcasts: current.value!.active.take(10),
+          worker: _worker!,
+        );
+      }
+      _worker?.close();
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
     final broadcastList = ref.watch(broadcastsPaginatorProvider);
     final featuredChannels = ref.watch(featuredChannelsProvider);
     final streamers = ref.watch(liveStreamersProvider);
 
-    final content = orientation == Orientation.portrait
+    final content = widget.orientation == Orientation.portrait
         ? [
             _BroadcastWidget(broadcastList),
             _WatchTvWidget(featuredChannels),
@@ -250,8 +286,6 @@ class _BroadcastTile extends ConsumerWidget {
 
   final Broadcast broadcast;
 
-  static final _dateFormat = DateFormat.E().add_jm();
-
   @override
   Widget build(BuildContext context, WidgetRef ref) {
     return PlatformListTile(
@@ -264,39 +298,32 @@ class _BroadcastTile extends ConsumerWidget {
         );
       },
       leading: const Icon(LichessIcons.radio_tower_lichess),
-      title: Padding(
-        padding: const EdgeInsets.only(right: 5.0),
-        child: Row(
-          children: [
-            Flexible(
-              child: Text(
-                broadcast.title,
-                maxLines: 2,
-                overflow: TextOverflow.ellipsis,
-              ),
-            ),
-          ],
-        ),
-      ),
-      trailing: Column(
-        mainAxisAlignment: MainAxisAlignment.center,
+      subtitle: Row(
         children: [
-          if (broadcast.round.startsAt != null)
-            Text(
-              _dateFormat.format(broadcast.round.startsAt!),
-              style: const TextStyle(fontSize: 10.0),
-            ),
-          if (broadcast.isLive)
+          Text(broadcast.round.name),
+          if (broadcast.isLive) ...[
+            const SizedBox(width: 5.0),
             Text(
               'LIVE',
               style: TextStyle(
-                fontSize: 12.0,
                 color: context.lichessColors.error,
                 fontWeight: FontWeight.bold,
               ),
             ),
+          ] else if (broadcast.round.startsAt != null) ...[
+            const SizedBox(width: 5.0),
+            Text(relativeDate(broadcast.round.startsAt!)),
+          ],
         ],
       ),
+      title: Padding(
+        padding: const EdgeInsets.only(right: 5.0),
+        child: Text(
+          broadcast.title,
+          maxLines: 1,
+          overflow: TextOverflow.ellipsis,
+        ),
+      ),
     );
   }
 }
diff --git a/test/view/broadcast/broadcasts_list_screen_test.dart b/test/view/broadcast/broadcasts_list_screen_test.dart
index 59b9c2e87a..1c3e093c6f 100644
--- a/test/view/broadcast/broadcasts_list_screen_test.dart
+++ b/test/view/broadcast/broadcasts_list_screen_test.dart
@@ -1,3 +1,5 @@
+import 'dart:typed_data';
+
 import 'package:flutter/material.dart';
 import 'package:flutter_test/flutter_test.dart';
 import 'package:http/testing.dart';
@@ -18,7 +20,11 @@ class FakeImageColorWorker implements ImageColorWorker {
   bool get closed => false;
 
   @override
-  Future<ImageColors?> getImageColors(String url, {String? fileExtension}) {
+  Future<ImageColors?> getImageColors(
+    String url, {
+    Uint8List? image,
+    String? fileExtension,
+  }) {
     return Future.value(null);
   }
 }
