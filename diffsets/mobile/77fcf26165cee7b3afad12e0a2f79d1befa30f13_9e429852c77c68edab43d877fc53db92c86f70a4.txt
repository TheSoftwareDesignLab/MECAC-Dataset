diff --git a/lib/src/model/game/analysis_ctrl.dart b/lib/src/model/game/analysis_ctrl.dart
new file mode 100644
index 0000000000..86f151f9bf
--- /dev/null
+++ b/lib/src/model/game/analysis_ctrl.dart
@@ -0,0 +1,62 @@
+import 'package:dartchess/dartchess.dart';
+import 'package:fast_immutable_collections/fast_immutable_collections.dart';
+import 'package:freezed_annotation/freezed_annotation.dart';
+import 'package:lichess_mobile/src/model/common/tree.dart';
+import 'package:lichess_mobile/src/model/common/uci.dart';
+import 'package:riverpod_annotation/riverpod_annotation.dart';
+import 'game.dart';
+
+part 'analysis_ctrl.g.dart';
+part 'analysis_ctrl.freezed.dart';
+
+@riverpod
+class AnalysisCtrl extends _$AnalysisCtrl {
+  late Node _gameTree;
+
+  @override
+  AnalysisCtrlState build(
+    List<GameStep> steps,
+    Side orientation,
+  ) {
+    final root = Root(
+      ply: steps[0].ply,
+      fen: steps[0].position.fen,
+      position: steps[0].position,
+    );
+    RootOrNode current = root;
+
+    for (var i = 1; i < steps.length; i++) {
+      final nextNode = Node(
+        id: UciCharPair.fromUci(steps[i].sanMove!.san),
+        ply: steps[i].ply,
+        sanMove: steps[i].sanMove!,
+        fen: steps[i].position.fen,
+        position: steps[i].position,
+      );
+
+      current.addChild(nextNode);
+      current = nextNode;
+    }
+
+    _gameTree = root.nodeAt(root.mainlinePath.penultimate) as Node;
+
+    return AnalysisCtrlState(
+      currentNode: ViewNode.fromNode(_gameTree),
+      pov: orientation,
+    );
+  }
+}
+
+@freezed
+class AnalysisCtrlState with _$AnalysisCtrlState {
+  const AnalysisCtrlState._();
+
+  const factory AnalysisCtrlState({
+    required ViewNode currentNode,
+    Move? lastMove,
+    required Side pov,
+  }) = _AnalysisCtrlState;
+
+  IMap<String, ISet<String>> get validMoves =>
+      algebraicLegalMoves(currentNode.position);
+}
diff --git a/lib/src/view/game/analysis_screen.dart b/lib/src/view/game/analysis_screen.dart
new file mode 100644
index 0000000000..c03359dfb6
--- /dev/null
+++ b/lib/src/view/game/analysis_screen.dart
@@ -0,0 +1,100 @@
+import 'package:dartchess/dartchess.dart';
+import 'package:chessground/chessground.dart' as cg;
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:lichess_mobile/src/model/game/analysis_ctrl.dart';
+import 'package:lichess_mobile/src/utils/immersive_mode.dart';
+import 'package:lichess_mobile/src/widgets/board_table.dart';
+import 'package:lichess_mobile/src/widgets/platform.dart';
+import 'package:lichess_mobile/src/utils/l10n_context.dart';
+import 'package:lichess_mobile/src/utils/chessground_compat.dart';
+import 'package:lichess_mobile/src/model/game/game.dart';
+
+class AnalysisScreen extends StatelessWidget {
+  const AnalysisScreen({
+    required this.steps,
+    required this.orientation,
+  });
+
+  final List<GameStep> steps;
+  final Side orientation;
+
+  @override
+  Widget build(BuildContext context) {
+    return PlatformWidget(
+        androidBuilder: _androidBuilder, iosBuilder: _iosBuilder);
+  }
+
+  Widget _androidBuilder(BuildContext context) {
+    return Scaffold(
+      appBar: AppBar(
+        title: Text(context.l10n.gameAnalysis),
+      ),
+      body: _Body(
+        steps: steps,
+        orientation: orientation,
+      ),
+    );
+  }
+
+  Widget _iosBuilder(BuildContext context) {
+    return CupertinoPageScaffold(
+      navigationBar: const CupertinoNavigationBar(),
+      child: _Body(
+        steps: steps,
+        orientation: orientation,
+      ),
+    );
+  }
+}
+
+class _Body extends ConsumerStatefulWidget {
+  const _Body({
+    required this.steps,
+    required this.orientation,
+  });
+
+  final List<GameStep> steps;
+  final Side orientation;
+
+  @override
+  ConsumerState<_Body> createState() => _BodyState();
+}
+
+class _BodyState extends ConsumerState<_Body> with AndroidImmersiveMode {
+  @override
+  Widget build(BuildContext context) {
+    final ctrlProvider = analysisCtrlProvider(widget.steps, widget.orientation);
+    final analysisState = ref.watch(ctrlProvider);
+
+    return Column(
+      children: [
+        Expanded(
+          child: Center(
+            child: SafeArea(
+              bottom: false,
+              child: BoardTable(
+                boardData: cg.BoardData(
+                  orientation: analysisState.pov.cg,
+                  interactableSide: analysisState
+                          .currentNode.position.isGameOver
+                      ? cg.InteractableSide.none
+                      : analysisState.currentNode.position.turn == Side.white
+                          ? cg.InteractableSide.white
+                          : cg.InteractableSide.black,
+                  fen: analysisState.currentNode.fen,
+                  isCheck: analysisState.currentNode.position.isCheck,
+                  lastMove: analysisState.lastMove?.cg,
+                  validMoves: analysisState.validMoves,
+                ),
+                bottomTable: const SizedBox.shrink(),
+                topTable: const SizedBox.shrink(),
+              ),
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+}
