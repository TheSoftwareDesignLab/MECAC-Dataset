diff --git a/lib/src/features/auth/data/auth_repository.dart b/lib/src/features/auth/data/auth_repository.dart
index 064c413ddd..aa65de3c47 100644
--- a/lib/src/features/auth/data/auth_repository.dart
+++ b/lib/src/features/auth/data/auth_repository.dart
@@ -22,17 +22,14 @@ class AuthError {
 }
 
 class AuthRepository {
-  AuthRepository(
-    FlutterAppAuth appAuth,
-    FlutterSecureStorage storage,
-    Logger log, {
-    required this.apiClient,
-  })  : _appAuth = appAuth,
+  AuthRepository(ApiClient apiClient, FlutterAppAuth appAuth,
+      FlutterSecureStorage storage, Logger log)
+      : _apiClient = apiClient,
+        _appAuth = appAuth,
         _storage = storage,
         _log = log;
 
-  final ApiClient apiClient;
-
+  final ApiClient _apiClient;
   final Logger _log;
   final FlutterAppAuth _appAuth;
   final FlutterSecureStorage _storage;
@@ -80,7 +77,7 @@ class AuthRepository {
   }
 
   TaskEither<IOError, void> signOutTask() {
-    return apiClient
+    return _apiClient
         .delete(Uri.parse('$kLichessHost/api/token'))
         .map((_) async {
       await _storage.delete(key: kOAuthTokenStorageKey);
@@ -89,14 +86,14 @@ class AuthRepository {
   }
 
   TaskEither<IOError, User> getAccountTask() {
-    return apiClient
+    return _apiClient
         .get(Uri.parse('$kLichessHost/api/account'))
         .map((response) => User.fromJson(jsonDecode(response.body)));
   }
 
   void dispose() {
     _authState.close();
-    apiClient.close();
+    _apiClient.close();
   }
 }
 
@@ -104,8 +101,8 @@ final authRepositoryProvider = Provider<AuthRepository>((ref) {
   const auth = FlutterAppAuth();
   const storage = FlutterSecureStorage();
   final apiClient = ref.watch(apiClientProvider);
-  final repo = AuthRepository(auth, storage, Logger('AuthRepository'),
-      apiClient: apiClient);
+  final repo =
+      AuthRepository(apiClient, auth, storage, Logger('AuthRepository'));
   ref.onDispose(() => repo.dispose());
   return repo;
 });
diff --git a/lib/src/features/auth/ui/auth_widget.dart b/lib/src/features/auth/ui/auth_widget.dart
index b0f2d6d0e8..e892739eab 100644
--- a/lib/src/features/auth/ui/auth_widget.dart
+++ b/lib/src/features/auth/ui/auth_widget.dart
@@ -22,39 +22,40 @@ class AuthWidget extends ConsumerWidget {
       (_, state) => state.showSnackbarOnError(context),
     );
     return authState.maybeWhen(
-        data: (account) => account != null
-            ? PopupMenuButton<AccountMenu>(
-                icon: const Icon(Icons.person),
-                onSelected: (AccountMenu item) {
-                  switch (item) {
-                    case AccountMenu.logout:
-                      if (!authActionsAsync.isLoading) {
-                        ref.read(authWidgetProvider.notifier).signOut();
-                      }
-                      break;
-                  }
-                },
-                itemBuilder: (BuildContext context) =>
-                    <PopupMenuEntry<AccountMenu>>[
-                  PopupMenuItem<AccountMenu>(
-                    value: AccountMenu.logout,
-                    child: authActionsAsync.isLoading
-                        ? const CircularProgressIndicator.adaptive()
-                        : Text(context.l10n.logOut),
-                  ),
-                ],
-              )
-            : TextButton(
-                onPressed: authActionsAsync.isLoading
-                    ? null
-                    : () => ref.read(authWidgetProvider.notifier).signIn(),
-                child: authActionsAsync.isLoading
-                    ? const CircularProgressIndicator.adaptive()
-                    : Text(context.l10n.signIn,
-                        style: brightness == Brightness.light
-                            ? const TextStyle(color: Colors.white)
-                            : null),
-              ),
-        orElse: () => const CircularProgressIndicator.adaptive());
+      data: (account) => account != null
+          ? PopupMenuButton<AccountMenu>(
+              icon: const Icon(Icons.person),
+              onSelected: (AccountMenu item) {
+                switch (item) {
+                  case AccountMenu.logout:
+                    if (!authActionsAsync.isLoading) {
+                      ref.read(authWidgetProvider.notifier).signOut();
+                    }
+                    break;
+                }
+              },
+              itemBuilder: (BuildContext context) =>
+                  <PopupMenuEntry<AccountMenu>>[
+                PopupMenuItem<AccountMenu>(
+                  value: AccountMenu.logout,
+                  child: authActionsAsync.isLoading
+                      ? const CircularProgressIndicator.adaptive()
+                      : Text(context.l10n.logOut),
+                ),
+              ],
+            )
+          : TextButton(
+              onPressed: authActionsAsync.isLoading
+                  ? null
+                  : () => ref.read(authWidgetProvider.notifier).signIn(),
+              child: authActionsAsync.isLoading
+                  ? const CircularProgressIndicator.adaptive()
+                  : Text(context.l10n.signIn,
+                      style: brightness == Brightness.light
+                          ? const TextStyle(color: Colors.white)
+                          : null),
+            ),
+      orElse: () => const CircularProgressIndicator.adaptive(),
+    );
   }
 }
diff --git a/test/features/auth/auth_widget_test.dart b/test/features/auth/auth_widget_test.dart
new file mode 100644
index 0000000000..22a3642dd0
--- /dev/null
+++ b/test/features/auth/auth_widget_test.dart
@@ -0,0 +1,131 @@
+import 'package:flutter/material.dart';
+import 'package:fpdart/fpdart.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:flutter_gen/gen_l10n/l10n.dart';
+
+import 'package:lichess_mobile/src/common/errors.dart';
+import 'package:lichess_mobile/src/utils/in_memory_store.dart';
+import 'package:lichess_mobile/src/features/auth/ui/auth_widget.dart';
+import 'package:lichess_mobile/src/features/auth/data/auth_repository.dart';
+import 'package:lichess_mobile/src/features/settings/ui/theme_mode_notifier.dart';
+import 'package:lichess_mobile/src/features/user/model/user.dart';
+
+void main() {
+  testWidgets('auth widget', (tester) async {
+    await tester.pumpWidget(
+      ProviderScope(
+        overrides: [
+          authRepositoryProvider.overrideWithValue(FakeAuthRepository(null)),
+          selectedBrigthnessProvider.overrideWithValue(Brightness.dark),
+        ],
+        child: MaterialApp(
+          localizationsDelegates: AppLocalizations.localizationsDelegates,
+          home: Consumer(builder: (context, ref, _) {
+            return Scaffold(
+              appBar: AppBar(
+                actions: const [
+                  AuthWidget(),
+                ],
+              ),
+            );
+          }),
+        ),
+      ),
+    );
+
+    expect(find.byType(CircularProgressIndicator), findsOneWidget);
+
+    await tester.pump();
+
+    expect(find.text('Sign in'), findsOneWidget);
+
+    await tester.tap(find.text('Sign in'));
+
+    await tester.pump();
+
+    expect(find.byType(CircularProgressIndicator), findsOneWidget);
+
+    await tester.pumpAndSettle();
+
+    expect(find.byIcon(Icons.person), findsOneWidget);
+  });
+}
+
+/// A fake AuthRepository
+///
+/// Optionnall pass a [User] to have it initialized with an already logged in user
+class FakeAuthRepository implements AuthRepository {
+  FakeAuthRepository(User? loggedInUser)
+      : _authState = InMemoryStore<User?>(loggedInUser);
+
+  final InMemoryStore<User?> _authState;
+
+  @override
+  Stream<User?> authStateChanges() => _authState.stream;
+
+  @override
+  User? get currentAccount => _authState.value;
+
+  @override
+  bool get isAuthenticated => _authState.value != null;
+
+  @override
+  Future<void> init() async {
+    return;
+  }
+
+  @override
+  TaskEither<IOError, void> signInTask() {
+    return TaskEither(() async {
+      await Future.delayed(const Duration(milliseconds: 5));
+      _authState.value = _fakeUser;
+      return Either.right(null);
+    });
+  }
+
+  @override
+  TaskEither<IOError, void> signOutTask() {
+    return TaskEither(() async {
+      await Future.delayed(const Duration(milliseconds: 5));
+      _authState.value = null;
+      return Either.right(null);
+    });
+  }
+
+  @override
+  TaskEither<IOError, User> getAccountTask() {
+    return TaskEither.right(_fakeUser);
+  }
+
+  @override
+  void dispose() {}
+}
+
+final _fakeUser = User(
+  id: 'test',
+  username: 'test',
+  createdAt: DateTime.now(),
+  seenAt: DateTime.now(),
+  perfs: {
+    Perf.ultraBullet: _fakePerf,
+    Perf.bullet: _fakePerf,
+    Perf.blitz: _fakePerf,
+    Perf.rapid: _fakePerf,
+    Perf.classical: _fakePerf,
+    Perf.correspondence: _fakePerf,
+    Perf.chess960: _fakePerf,
+    Perf.antichess: _fakePerf,
+    Perf.kingOfTheHill: _fakePerf,
+    Perf.threeCheck: _fakePerf,
+    Perf.atomic: _fakePerf,
+    Perf.horde: _fakePerf,
+    Perf.racingKings: _fakePerf,
+    Perf.crazyhouse: _fakePerf,
+    Perf.puzzle: _fakePerf,
+    Perf.storm: _fakePerf,
+  },
+);
+
+const _fakePerf = UserPerf(
+    rating: 1500, ratingDeviation: 0, progression: 0, numberOfGames: 0);
