diff --git a/mobile-app/lib/models/learn/challenge_model.dart b/mobile-app/lib/models/learn/challenge_model.dart
index fbfb0c83e..a57cc981d 100644
--- a/mobile-app/lib/models/learn/challenge_model.dart
+++ b/mobile-app/lib/models/learn/challenge_model.dart
@@ -67,9 +67,7 @@ class Challenge {
   final EnglishAudio? audio;
   final Scene? scene;
 
-  // Challenge Type 11 - Video
-  // TODO: Renamed to questions and its an array of questions
-  Question? question;
+  final List<Question>? questions;
 
   // Challenge Type 15 - Odin
   final List<String>? assignments;
@@ -88,7 +86,7 @@ class Challenge {
     required this.files,
     required this.helpCategory,
     this.explanation,
-    this.question,
+    this.questions,
     this.assignments,
     this.fillInTheBlank,
     this.audio,
@@ -121,8 +119,10 @@ class Challenge {
       files: (data['challengeFiles'] ?? [])
           .map<ChallengeFile>((file) => ChallengeFile.fromJson(file))
           .toList(),
-      question: (data['questions'] as List).isNotEmpty
-          ? Question.fromJson(data['questions'][0])
+      questions: (data['questions'] as List).isNotEmpty
+          ? (data['questions'] as List)
+              .map<Question>((q) => Question.fromJson(q))
+              .toList()
           : null,
       assignments: data['assignments'] != null
           ? (data['assignments'] as List).cast<String>()
@@ -169,13 +169,13 @@ class Challenge {
             },
           )
           .toList(),
-      'question': challenge.question != null
-          ? {
-              'text': challenge.question!.text,
-              'answers': challenge.question!.answers,
-              'solution': challenge.question!.solution,
-            }
-          : null,
+      'questions': challenge.questions
+          ?.map((question) => {
+                'text': question.text,
+                'answers': question.answers,
+                'solution': question.solution,
+              })
+          .toList(),
     };
   }
 }
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_view.dart b/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_view.dart
index 209d243a4..4c695e601 100644
--- a/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_view.dart
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_view.dart
@@ -7,6 +7,7 @@ import 'package:freecodecamp/ui/views/learn/widgets/assignment_widget.dart';
 import 'package:freecodecamp/ui/views/learn/widgets/audio/audio_player_view.dart';
 import 'package:freecodecamp/ui/views/learn/widgets/challenge_card.dart';
 import 'package:freecodecamp/ui/views/learn/widgets/explanation_widget.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
 import 'package:freecodecamp/ui/views/news/html_handler/html_handler.dart';
 import 'package:stacked/stacked.dart';
 import 'package:youtube_player_iframe/youtube_player_iframe.dart';
@@ -136,22 +137,12 @@ class MultipleChoiceView extends StatelessWidget {
                       ),
                     ),
                   ),
-                ChallengeCard(
-                  title: 'Question',
-                  child: Column(
-                    crossAxisAlignment: CrossAxisAlignment.start,
-                    children: [
-                      ...parser.parse(challenge.instructions),
-                      ...parser.parse(
-                        challenge.question!.text,
-                      ),
-                      const SizedBox(height: 8),
-                      for (var answerObj
-                          in challenge.question!.answers.asMap().entries)
-                        questionOption(answerObj, model, context),
-                    ],
-                  ),
-                ),
+                QuizWidget(
+                    isValidated: model.isValidated,
+                    questions: model.quizQuestions,
+                    onChanged: (questionIndex, answerIndex) {
+                      model.setSelectedAnswer(questionIndex, answerIndex);
+                    }),
                 const SizedBox(height: 8),
                 if (challenge.explanation != null &&
                     challenge.explanation!.isNotEmpty) ...[
@@ -163,6 +154,18 @@ class MultipleChoiceView extends StatelessWidget {
                   ),
                 ],
                 const SizedBox(height: 8),
+                if (model.errMessage.isNotEmpty) ...[
+                  Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                    child: Text(
+                      model.errMessage,
+                      style: const TextStyle(
+                        fontSize: 18,
+                      ),
+                    ),
+                  ),
+                ],
+                const SizedBox(height: 8),
                 Padding(
                   padding: const EdgeInsets.all(8.0),
                   child: ElevatedButton(
@@ -178,23 +181,27 @@ class MultipleChoiceView extends StatelessWidget {
                         borderRadius: BorderRadius.zero,
                       ),
                     ),
-                    onPressed: model.currentChoice != -1 &&
-                            model.assignmentsStatus.every((element) => element)
-                        ? model.choiceStatus != null && model.choiceStatus!
-                            ? () => model.learnService.goToNextChallenge(
-                                  block.challenges.length,
-                                  challengesCompleted,
-                                  challenge,
-                                  block,
-                                )
-                            : () {
-                                model.setValidationStatus(challenge);
-                                model.updateFeedback(challenge, context);
+                    onPressed:
+                        model.assignmentsStatus.every((element) => element) &&
+                                model.quizQuestions
+                                    .every((q) => q.selectedAnswer != -1)
+                            ? () {
+                                if (model.isValidated &&
+                                    model.hasPassedAllQuestions) {
+                                  model.learnService.goToNextChallenge(
+                                    block.challenges.length,
+                                    challengesCompleted,
+                                    challenge,
+                                    block,
+                                  );
+                                } else {
+                                  model.validateChallenge();
+                                }
                               }
-                        : null,
+                            : null,
                     child: Text(
-                      model.choiceStatus != null
-                          ? model.choiceStatus!
+                      model.isValidated
+                          ? model.hasPassedAllQuestions
                               ? context.t.next_challenge
                               : context.t.try_again
                           : context.t.questions_check,
@@ -210,60 +217,4 @@ class MultipleChoiceView extends StatelessWidget {
       },
     );
   }
-
-  Container questionOption(
-    MapEntry<int, Answer> answerObj,
-    MultipleChoiceViewmodel model,
-    BuildContext context,
-  ) {
-    HTMLParser parser = HTMLParser(context: context);
-
-    return Container(
-      margin: const EdgeInsets.symmetric(vertical: 8),
-      child: Material(
-        child: RadioListTile<int>(
-          key: ValueKey(model.lastAnswer),
-          selected: answerObj.key == model.currentChoice,
-          tileColor: const Color(0xFF0a0a23),
-          selectedTileColor: const Color(0xFF0a0a23),
-          value: answerObj.key,
-          shape: RoundedRectangleBorder(
-            borderRadius: BorderRadius.circular(0),
-            side: BorderSide(
-              color: const Color(0xFFAAAAAA),
-              width: 2,
-            ),
-          ),
-          groupValue: model.currentChoice,
-          onChanged: (value) {
-            model.setChoiceStatus = null;
-            model.setCurrentChoice = value ?? -1;
-          },
-          title: Align(
-            alignment: Alignment.centerLeft,
-            child: ConstrainedBox(
-              constraints: const BoxConstraints(
-                minHeight: 100,
-              ),
-              child: Column(
-                crossAxisAlignment: CrossAxisAlignment.start,
-                mainAxisAlignment: MainAxisAlignment.center,
-                children: parser.parse(
-                  answerObj.value.answer,
-                  isSelectable: false,
-                  removeParagraphMargin: true,
-                ),
-              ),
-            ),
-          ),
-          subtitle: Column(
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: [
-              if (answerObj.key == model.lastAnswer) ...model.feedback,
-            ],
-          ),
-        ),
-      ),
-    );
-  }
 }
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_viewmodel.dart b/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_viewmodel.dart
index ab61045dc..fe518e1e7 100644
--- a/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_viewmodel.dart
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_viewmodel.dart
@@ -1,54 +1,44 @@
-import 'package:flutter/material.dart';
 import 'package:freecodecamp/app/app.locator.dart';
 import 'package:freecodecamp/models/learn/challenge_model.dart';
 import 'package:freecodecamp/service/learn/learn_service.dart';
-import 'package:freecodecamp/ui/theme/fcc_theme.dart';
-import 'package:freecodecamp/ui/views/news/html_handler/html_handler.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
 import 'package:stacked/stacked.dart';
 
 class MultipleChoiceViewmodel extends BaseViewModel {
-  int _currentChoice = -1;
-  int get currentChoice => _currentChoice;
+  bool _isValidated = false;
+  bool get isValidated => _isValidated;
 
-  int _lastAnswer = -1;
-  int get lastAnswer => _lastAnswer;
-
-  bool? _choiceStatus;
-  bool? get choiceStatus => _choiceStatus;
+  bool _hasPassedAllQuestions = false;
+  bool get hasPassedAllQuestions => _hasPassedAllQuestions;
 
   String _errMessage = '';
   String get errMessage => _errMessage;
 
-  List<Widget> _feedback = [];
-  List<Widget> get feedback => _feedback;
-
   List<bool> _assignmentsStatus = [];
   List<bool> get assignmentsStatus => _assignmentsStatus;
 
-  final LearnService learnService = locator<LearnService>();
+  List<QuizWidgetQuestion> _quizQuestions = [];
+  List<QuizWidgetQuestion> get quizQuestions => _quizQuestions;
 
-  set setCurrentChoice(int choice) {
-    _currentChoice = choice;
-    notifyListeners();
-  }
+  final LearnService learnService = locator<LearnService>();
 
-  set setLastAnswer(int answer) {
-    _lastAnswer = answer;
+  set setIsValidated(bool status) {
+    _isValidated = status;
     notifyListeners();
   }
 
-  set setFeedback(List<Widget> feedback) {
-    _feedback = feedback;
+  set setHasPassedAllQuestions(bool status) {
+    _hasPassedAllQuestions = status;
     notifyListeners();
   }
 
-  set setChoiceStatus(bool? status) {
-    _choiceStatus = status;
+  set setErrMessage(String message) {
+    _errMessage = message;
     notifyListeners();
   }
 
-  set setErrMessage(String message) {
-    _errMessage = message;
+  set setQuizQuestions(List<QuizWidgetQuestion> questions) {
+    _quizQuestions = questions;
     notifyListeners();
   }
 
@@ -68,44 +58,41 @@ class MultipleChoiceViewmodel extends BaseViewModel {
       challenge.assignments?.length ?? 0,
       false,
     );
+
+    setQuizQuestions = (challenge.questions ?? [])
+        .map<QuizWidgetQuestion>((q) => QuizWidgetQuestion(
+            text: q.text, answers: q.answers, solution: q.solution))
+        .toList();
   }
 
-  void setValidationStatus(Challenge challenge) {
-    bool isCorrect = challenge.question!.solution - 1 == currentChoice;
-    setChoiceStatus = isCorrect;
-    setLastAnswer = currentChoice;
+  void setSelectedAnswer(int questionIndex, int answerIndex) {
+    final question = quizQuestions[questionIndex];
+    question.selectedAnswer = answerIndex;
+
+    // Reset the validation status when user changes the selection
+    setIsValidated = false;
+    setErrMessage = '';
+
+    notifyListeners();
   }
 
-  void updateFeedback(Challenge challenge, BuildContext context) {
-    HTMLParser parser = HTMLParser(context: context);
-    Answer answer = challenge.question!.answers[currentChoice];
-    bool isCorrect = challenge.question!.solution - 1 == currentChoice;
-
-    List<Widget> feedbackWidgets = [];
-
-    feedbackWidgets.add(
-      Padding(
-        padding: EdgeInsets.only(left: 12, bottom: isCorrect ? 32 : 0),
-        child: Text(
-          isCorrect ? 'Correct!' : 'Incorrect!',
-          style: TextStyle(
-            color: isCorrect ? FccColors.green40 : FccColors.red15,
-            fontWeight: FontWeight.bold,
-            fontSize: 18,
-          ),
-        ),
-      ),
-    );
+  void validateChallenge() {
+    // Loop through each question and set isCorrect status
+    setQuizQuestions = List.from(quizQuestions)
+      ..asMap().forEach((i, question) {
+        question.isCorrect = question.selectedAnswer == question.solution - 1;
+      });
 
-    if (answer.feedback != null && answer.feedback!.isNotEmpty) {
-      feedbackWidgets.addAll(
-        parser.parse(
-          answer.feedback!,
-          fontColor: isCorrect ? FccColors.green40 : FccColors.red15,
-        ),
-      );
-    }
+    setHasPassedAllQuestions =
+        quizQuestions.every((question) => question.isCorrect == true);
 
-    setFeedback = feedbackWidgets;
+    setIsValidated = true;
+
+    // Show the error message if there are multiple questions.
+    // Otherwise, the validation message is sufficient.
+    if (quizQuestions.length > 1) {
+      setErrMessage =
+          hasPassedAllQuestions ? '' : 'Some answers are incorrect.';
+    }
   }
 }
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/python/python_view.dart b/mobile-app/lib/ui/views/learn/challenge/templates/python/python_view.dart
index d26773283..6413b8982 100644
--- a/mobile-app/lib/ui/views/learn/challenge/templates/python/python_view.dart
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/python/python_view.dart
@@ -3,6 +3,7 @@ import 'package:freecodecamp/extensions/i18n_extension.dart';
 import 'package:freecodecamp/models/learn/challenge_model.dart';
 import 'package:freecodecamp/models/learn/curriculum_model.dart';
 import 'package:freecodecamp/ui/views/learn/challenge/templates/python/python_viewmodel.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
 import 'package:freecodecamp/ui/views/news/html_handler/html_handler.dart';
 import 'package:freecodecamp/ui/widgets/drawer_widget/drawer_widget_view.dart';
 import 'package:stacked/stacked.dart';
@@ -28,6 +29,7 @@ class PythonView extends StatelessWidget {
 
     return ViewModelBuilder<PythonViewModel>.reactive(
       viewModelBuilder: () => PythonViewModel(),
+      onViewModelReady: (model) => model.initChallenge(challenge),
       builder: (context, model, child) {
         YoutubePlayerController controller =
             YoutubePlayerController.fromVideoId(
@@ -66,7 +68,6 @@ class PythonView extends StatelessWidget {
           body: SafeArea(
             bottom: false,
             child: ListView(
-              padding: const EdgeInsets.all(12),
               children: [
                 Center(
                   child: Text(
@@ -93,43 +94,64 @@ class PythonView extends StatelessWidget {
                   challenge.description,
                 ),
                 if (challenge.description.isNotEmpty) buildDivider(),
-                ...parser.parse(
-                  challenge.question!.text,
-                ),
-                const SizedBox(height: 8),
-                for (var answerObj
-                    in challenge.question!.answers.asMap().entries)
-                  questionOption(answerObj, model, context),
+                QuizWidget(
+                    isValidated: model.isValidated,
+                    questions: model.quizQuestions,
+                    onChanged: (questionIndex, answerIndex) {
+                      model.setSelectedAnswer(questionIndex, answerIndex);
+                    }),
                 const SizedBox(height: 16),
-                ElevatedButton(
-                  style: ElevatedButton.styleFrom(
-                    minimumSize: const Size(0, 50),
-                    backgroundColor: const Color.fromRGBO(0x3b, 0x3b, 0x4f, 1),
-                    side: const BorderSide(
-                      width: 2,
-                      color: Colors.white,
-                    ),
-                    shape: RoundedRectangleBorder(
-                      borderRadius: BorderRadius.circular(0),
+                if (model.errMessage.isNotEmpty) ...[
+                  Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                    child: Text(
+                      model.errMessage,
+                      style: const TextStyle(
+                        fontSize: 18,
+                      ),
                     ),
                   ),
-                  onPressed: model.currentChoice != -1
-                      ? model.choiceStatus != null && model.choiceStatus!
-                          ? () => model.learnService.goToNextChallenge(
-                                block.challenges.length,
-                                challengesCompleted,
-                                challenge,
-                                block,
-                              )
-                          : () => model.checkOption(challenge)
-                      : null,
-                  child: Text(
-                    model.choiceStatus != null
-                        ? model.choiceStatus!
-                            ? context.t.next_challenge
-                            : context.t.try_again
-                        : context.t.questions_check,
-                    style: const TextStyle(fontSize: 20),
+                ],
+                const SizedBox(height: 16),
+                Padding(
+                  padding: const EdgeInsets.all(8.0),
+                  child: ElevatedButton(
+                    style: ElevatedButton.styleFrom(
+                      minimumSize: const Size(0, 50),
+                      backgroundColor:
+                          const Color.fromRGBO(0x3b, 0x3b, 0x4f, 1),
+                      side: const BorderSide(
+                        width: 2,
+                        color: Colors.white,
+                      ),
+                      shape: RoundedRectangleBorder(
+                        borderRadius: BorderRadius.circular(0),
+                      ),
+                    ),
+                    onPressed:
+                        model.quizQuestions.every((q) => q.selectedAnswer != -1)
+                            ? () {
+                                if (model.isValidated &&
+                                    model.hasPassedAllQuestions) {
+                                  model.learnService.goToNextChallenge(
+                                    block.challenges.length,
+                                    challengesCompleted,
+                                    challenge,
+                                    block,
+                                  );
+                                } else {
+                                  model.validateChallenge();
+                                }
+                              }
+                            : null,
+                    child: Text(
+                      model.isValidated
+                          ? model.hasPassedAllQuestions
+                              ? context.t.next_challenge
+                              : context.t.try_again
+                          : context.t.questions_check,
+                      style: const TextStyle(fontSize: 20),
+                    ),
                   ),
                 ),
                 const SizedBox(height: 50),
@@ -140,65 +162,4 @@ class PythonView extends StatelessWidget {
       },
     );
   }
-
-  Container questionOption(
-    MapEntry<int, Answer> answerObj,
-    PythonViewModel model,
-    BuildContext context,
-  ) {
-    HTMLParser parser = HTMLParser(context: context);
-
-    return Container(
-      margin: const EdgeInsets.symmetric(vertical: 8),
-      child: RadioListTile<int>(
-        selected: answerObj.key == model.currentChoice,
-        tileColor: const Color(0xFF0a0a23),
-        selectedTileColor: const Color(0xDEFFFFFF),
-        activeColor: const Color(0xFF0a0a23),
-        value: answerObj.key,
-        shape: RoundedRectangleBorder(
-          borderRadius: BorderRadius.circular(0),
-          side: BorderSide(
-            color: answerObj.key == model.currentChoice
-                ? const Color(0xFF0a0a23)
-                : const Color(0xFFAAAAAA),
-            width: 2,
-          ),
-        ),
-        groupValue: model.currentChoice,
-        onChanged: (value) {
-          model.setChoiceStatus = null;
-          model.setCurrentChoice = value ?? -1;
-        },
-        title: Row(
-          children: [
-            Expanded(
-              child: Column(
-                crossAxisAlignment: CrossAxisAlignment.start,
-                children: parser.parse(
-                  answerObj.value.answer,
-                  isSelectable: false,
-                  fontColor: answerObj.key == model.currentChoice
-                      ? const Color(0xFF0a0a23)
-                      : null,
-                ),
-              ),
-            ),
-            SizedBox(
-              width: 24,
-              child: model.choiceStatus != null &&
-                      model.currentChoice == answerObj.key
-                  ? Icon(
-                      model.choiceStatus! ? Icons.check_circle : Icons.cancel,
-                      color: model.choiceStatus!
-                          ? Colors.green.shade600
-                          : Colors.red.shade600,
-                    )
-                  : null,
-            ),
-          ],
-        ),
-      ),
-    );
-  }
 }
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/python/python_viewmodel.dart b/mobile-app/lib/ui/views/learn/challenge/templates/python/python_viewmodel.dart
index 5baf5a225..fe690301d 100644
--- a/mobile-app/lib/ui/views/learn/challenge/templates/python/python_viewmodel.dart
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/python/python_viewmodel.dart
@@ -1,29 +1,81 @@
 import 'package:freecodecamp/app/app.locator.dart';
 import 'package:freecodecamp/models/learn/challenge_model.dart';
 import 'package:freecodecamp/service/learn/learn_service.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
 import 'package:stacked/stacked.dart';
 
 class PythonViewModel extends BaseViewModel {
-  int _currentChoice = -1;
-  int get currentChoice => _currentChoice;
+  bool _isValidated = false;
+  bool get isValidated => _isValidated;
 
-  bool? _choiceStatus;
-  bool? get choiceStatus => _choiceStatus;
+  bool _hasPassedAllQuestions = false;
+  bool get hasPassedAllQuestions => _hasPassedAllQuestions;
+
+  String _errMessage = '';
+  String get errMessage => _errMessage;
+
+  List<QuizWidgetQuestion> _quizQuestions = [];
+  List<QuizWidgetQuestion> get quizQuestions => _quizQuestions;
 
   final LearnService learnService = locator<LearnService>();
 
-  set setCurrentChoice(int choice) {
-    _currentChoice = choice;
+  set setQuizQuestions(List<QuizWidgetQuestion> questions) {
+    _quizQuestions = questions;
+    notifyListeners();
+  }
+
+  set setIsValidated(bool status) {
+    _isValidated = status;
     notifyListeners();
   }
 
-  set setChoiceStatus(bool? status) {
-    _choiceStatus = status;
+  set setHasPassedAllQuestions(bool status) {
+    _hasPassedAllQuestions = status;
     notifyListeners();
   }
 
-  void checkOption(Challenge challenge) async {
-    bool isCorrect = challenge.question!.solution - 1 == currentChoice;
-    setChoiceStatus = isCorrect;
+  set setErrMessage(String message) {
+    _errMessage = message;
+    notifyListeners();
+  }
+
+  void initChallenge(Challenge challenge) {
+    setQuizQuestions = (challenge.questions ?? [])
+        .map<QuizWidgetQuestion>((q) => QuizWidgetQuestion(
+            text: q.text, answers: q.answers, solution: q.solution))
+        .toList();
+  }
+
+  void setSelectedAnswer(int questionIndex, int answerIndex) {
+    final question = quizQuestions[questionIndex];
+    question.selectedAnswer = answerIndex;
+
+    setQuizQuestions = List.from(quizQuestions)..[questionIndex] = question;
+
+    // Reset the validation status when user changes the selection
+    setIsValidated = false;
+    setErrMessage = '';
+
+    notifyListeners();
+  }
+
+  void validateChallenge() {
+    // Loop through each question and set isCorrect status
+    setQuizQuestions = List.from(quizQuestions)
+      ..asMap().forEach((i, question) {
+        question.isCorrect = question.selectedAnswer == question.solution - 1;
+      });
+
+    setHasPassedAllQuestions =
+        quizQuestions.every((question) => question.isCorrect == true);
+
+    setIsValidated = true;
+
+    // Show the error message if there are multiple questions.
+    // Otherwise, the validation message is sufficient.
+    if (quizQuestions.length > 1) {
+      setErrMessage =
+          hasPassedAllQuestions ? '' : 'Some answers are incorrect.';
+    }
   }
 }
diff --git a/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart b/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart
new file mode 100644
index 000000000..63bca24fb
--- /dev/null
+++ b/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart
@@ -0,0 +1,188 @@
+import 'package:flutter/material.dart';
+import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:freecodecamp/ui/theme/fcc_theme.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/challenge_card.dart';
+import 'package:freecodecamp/ui/views/news/html_handler/html_handler.dart';
+
+// Model that extends Question with selectedAnswer and validation status
+class QuizWidgetQuestion {
+  final String text;
+  final List<Answer> answers;
+  final int solution;
+  int selectedAnswer;
+  bool? isCorrect;
+
+  QuizWidgetQuestion({
+    required this.text,
+    required this.answers,
+    required this.solution,
+    this.selectedAnswer = -1,
+    this.isCorrect,
+  });
+}
+
+class QuizWidget extends StatelessWidget {
+  final List<QuizWidgetQuestion> questions;
+  final Function(int, int) onChanged;
+  final bool? isValidated;
+
+  const QuizWidget(
+      {super.key,
+      required this.questions,
+      required this.onChanged,
+      this.isValidated});
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      children: List.generate(
+        questions.length,
+        (index) {
+          return quizQuestion(
+              context: context,
+              questionNumber: questions.length > 1 ? index + 1 : null,
+              question: questions[index],
+              selectedAnswer: questions[index].selectedAnswer,
+              isCorrect: questions[index].isCorrect,
+              onChanged: (answerIndex) {
+                onChanged(index, answerIndex);
+              });
+        },
+      ),
+    );
+  }
+
+  ChallengeCard quizQuestion(
+      {required BuildContext context,
+      required QuizWidgetQuestion question,
+      required int selectedAnswer,
+      required ValueChanged<int> onChanged,
+      bool? isCorrect,
+      int? questionNumber}) {
+    HTMLParser parser = HTMLParser(context: context);
+
+    return ChallengeCard(
+      title: questionNumber != null ? 'Question $questionNumber' : 'Question',
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          ...parser.parse(
+            question.text,
+          ),
+          const SizedBox(height: 8),
+          for (final answerObj in question.answers.asMap().entries) ...[
+            option(
+              context: context,
+              answerObj: answerObj,
+              selectedAnswer: selectedAnswer,
+              isCorrect: isCorrect,
+              onChanged: (value) {
+                onChanged(value);
+              },
+            ),
+          ],
+        ],
+      ),
+    );
+  }
+
+  Container option({
+    required BuildContext context,
+    required MapEntry<int, Answer> answerObj,
+    required int selectedAnswer,
+    required bool? isCorrect,
+    required ValueChanged<int> onChanged,
+  }) {
+    HTMLParser parser = HTMLParser(context: context);
+
+    final isSelected = answerObj.key == selectedAnswer;
+
+    return Container(
+      margin: const EdgeInsets.symmetric(vertical: 8),
+      child: Material(
+        child: RadioListTile<int>(
+          key: ValueKey(selectedAnswer),
+          selected: isSelected,
+          tileColor: const Color(0xFF0a0a23),
+          selectedTileColor: const Color(0xFF0a0a23),
+          value: answerObj.key,
+          shape: RoundedRectangleBorder(
+            borderRadius: BorderRadius.circular(0),
+            side: BorderSide(
+              color: const Color(0xFFAAAAAA),
+              width: 2,
+            ),
+          ),
+          groupValue: selectedAnswer,
+          onChanged: (value) {
+            onChanged(value ?? -1);
+          },
+          title: Align(
+            alignment: Alignment.centerLeft,
+            child: ConstrainedBox(
+              constraints: const BoxConstraints(
+                minHeight: 100,
+              ),
+              child: Column(
+                crossAxisAlignment: CrossAxisAlignment.start,
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: parser.parse(
+                  answerObj.value.answer,
+                  isSelectable: false,
+                  removeParagraphMargin: true,
+                ),
+              ),
+            ),
+          ),
+          subtitle: isSelected && isValidated == true
+              ? validationStatusAndFeedback(
+                  context: context,
+                  isCorrect: isCorrect,
+                  feedback: answerObj.value.feedback,
+                )
+              : null,
+        ),
+      ),
+    );
+  }
+
+  Widget validationStatusAndFeedback(
+      {required BuildContext context, bool? isCorrect, String? feedback}) {
+    HTMLParser parser = HTMLParser(context: context);
+    final List<Widget> feedbackWidgets = [];
+
+    if (isCorrect == null) {
+      return const SizedBox.shrink();
+    }
+
+    feedbackWidgets.add(
+      Padding(
+        padding: EdgeInsets.only(left: 12, bottom: feedback == null ? 24 : 0),
+        child: Text(
+          isCorrect && isCorrect == true ? 'Correct!' : 'Incorrect!',
+          style: TextStyle(
+            color: isCorrect && isCorrect == true
+                ? FccColors.green40
+                : FccColors.red15,
+            fontWeight: FontWeight.bold,
+            fontSize: 18,
+          ),
+        ),
+      ),
+    );
+
+    if (feedback != null && feedback.isNotEmpty) {
+      feedbackWidgets.addAll(
+        parser.parse(
+          feedback,
+          fontColor: isCorrect == true ? FccColors.green40 : FccColors.red15,
+        ),
+      );
+    }
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: feedbackWidgets,
+    );
+  }
+}
