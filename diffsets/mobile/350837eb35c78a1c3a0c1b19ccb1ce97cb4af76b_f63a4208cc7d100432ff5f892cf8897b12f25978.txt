diff --git a/lib/src/view/home/home_tab_screen.dart b/lib/src/view/home/home_tab_screen.dart
index 4cd353ba10..16e1645696 100644
--- a/lib/src/view/home/home_tab_screen.dart
+++ b/lib/src/view/home/home_tab_screen.dart
@@ -715,21 +715,25 @@ class _ChallengeScreenButton extends ConsumerWidget {
   @override
   Widget build(BuildContext context, WidgetRef ref) {
     final session = ref.watch(authSessionProvider);
-
     if (session == null) {
       return const SizedBox.shrink();
     }
-
     final connectivity = ref.watch(connectivityChangesProvider);
     final challenges = ref.watch(challengesProvider);
-    final count = challenges.valueOrNull?.inward.length;
+
+    final inwardCount = challenges.valueOrNull?.inward.length ?? 0;
+    final outwardCount = challenges.valueOrNull?.outward.length ?? 0;
+
+    if (inwardCount == 0 && outwardCount == 0) {
+      return const SizedBox.shrink();
+    }
 
     return connectivity.maybeWhen(
       data:
           (connectivity) => SemanticIconButton(
             icon: Badge.count(
-              count: count ?? 0,
-              isLabelVisible: (count ?? 0) > 0,
+              count: inwardCount,
+              isLabelVisible: inwardCount > 0,
               child: const Icon(LichessIcons.crossed_swords, size: 18.0),
             ),
             semanticsLabel: context.l10n.preferencesNotifyChallenge,
diff --git a/lib/src/view/user/challenge_requests_screen.dart b/lib/src/view/user/challenge_requests_screen.dart
index d9b05059d4..cf1387595b 100644
--- a/lib/src/view/user/challenge_requests_screen.dart
+++ b/lib/src/view/user/challenge_requests_screen.dart
@@ -5,14 +5,17 @@ import 'package:lichess_mobile/src/model/challenge/challenge.dart';
 import 'package:lichess_mobile/src/model/challenge/challenge_repository.dart';
 import 'package:lichess_mobile/src/model/challenge/challenges.dart';
 import 'package:lichess_mobile/src/model/notifications/notification_service.dart';
+import 'package:lichess_mobile/src/model/user/user.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/view/game/game_screen.dart';
 import 'package:lichess_mobile/src/view/play/challenge_list_item.dart';
 import 'package:lichess_mobile/src/widgets/adaptive_action_sheet.dart';
+import 'package:lichess_mobile/src/widgets/buttons.dart';
 import 'package:lichess_mobile/src/widgets/feedback.dart';
 import 'package:lichess_mobile/src/widgets/list.dart';
+import 'package:lichess_mobile/src/widgets/shimmer.dart';
 
 class ChallengeRequestsScreen extends StatelessWidget {
   const ChallengeRequestsScreen({super.key});
@@ -30,6 +33,61 @@ class ChallengeRequestsScreen extends StatelessWidget {
   }
 }
 
+class ChallengeRequestsWidget extends ConsumerWidget {
+  const ChallengeRequestsWidget({super.key});
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final session = ref.watch(authSessionProvider);
+    if (session == null) {
+      return const SizedBox.shrink();
+    }
+
+    final challenges = ref.watch(challengesProvider);
+    switch (challenges) {
+      case AsyncData(:final value):
+        final list = value.inward.addAll(value.outward);
+        if (list.isEmpty) {
+          return const SizedBox.shrink();
+        }
+        return ListSection(
+          header: Text(context.l10n.preferencesNotifyChallenge),
+          headerTrailing:
+              list.length > 5
+                  ? NoPaddingTextButton(
+                    onPressed: () {
+                      Navigator.of(context).push(ChallengeRequestsScreen.buildRoute(context));
+                    },
+                    child: Text(context.l10n.more),
+                  )
+                  : null,
+          hasLeading: true,
+          children: [
+            for (final challenge in list.take(5))
+              if (challenge.challenger?.user != null)
+                _ChallengeListItem(
+                  challenge: challenge,
+                  challengerUser: challenge.challenger!.user,
+                  session: session,
+                ),
+          ],
+        );
+      case AsyncError():
+        return const Padding(
+          padding: Styles.bodySectionPadding,
+          child: Text('Error loading challenges.'),
+        );
+      case _:
+        return Shimmer(
+          child: ShimmerLoading(
+            isLoading: true,
+            child: ListSection.loading(itemsNumber: 5, header: true),
+          ),
+        );
+    }
+  }
+}
+
 class _Body extends ConsumerWidget {
   @override
   Widget build(BuildContext context, WidgetRef ref) {
@@ -54,79 +112,7 @@ class _Body extends ConsumerWidget {
 
             if (user == null) return null;
 
-            Future<void> acceptChallenge() async {
-              final challengeRepo = ref.read(challengeRepositoryProvider);
-              await challengeRepo.accept(challenge.id);
-              final fullId = await challengeRepo
-                  .show(challenge.id)
-                  .then((challenge) => challenge.gameFullId);
-              if (!context.mounted) return;
-              Navigator.of(
-                context,
-                rootNavigator: true,
-              ).push(GameScreen.buildRoute(context, initialGameId: fullId));
-            }
-
-            Future<void> declineChallenge(ChallengeDeclineReason? reason) async {
-              ref.read(challengeRepositoryProvider).decline(challenge.id, reason: reason);
-              ref.read(notificationServiceProvider).cancel(challenge.id.value.hashCode);
-            }
-
-            void confirmDialog() {
-              showAdaptiveActionSheet<void>(
-                context: context,
-                title:
-                    challenge.variant.isPlaySupported
-                        ? const Text('Do you accept the challenge?')
-                        : null,
-                actions: [
-                  if (challenge.variant.isPlaySupported)
-                    BottomSheetAction(
-                      makeLabel: (context) => Text(context.l10n.accept),
-                      leading: Icon(Icons.check, color: context.lichessColors.good),
-                      isDefaultAction: true,
-                      onPressed: acceptChallenge,
-                    ),
-                  ...ChallengeDeclineReason.values.map(
-                    (reason) => BottomSheetAction(
-                      makeLabel: (context) => Text(reason.label(context.l10n)),
-                      leading: Icon(Icons.close, color: context.lichessColors.error),
-                      isDestructiveAction: true,
-                      onPressed: () {
-                        declineChallenge(reason);
-                      },
-                    ),
-                  ),
-                ],
-              );
-            }
-
-            void showMissingAccountMessage() {
-              showSnackBar(context, context.l10n.youNeedAnAccountToDoThat);
-            }
-
-            return ChallengeListItem(
-              challenge: challenge,
-              challengerUser: user,
-              onPressed:
-                  challenge.direction == ChallengeDirection.inward
-                      ? session == null
-                          ? showMissingAccountMessage
-                          : confirmDialog
-                      : null,
-              onAccept:
-                  challenge.direction == ChallengeDirection.outward ||
-                          !challenge.variant.isPlaySupported
-                      ? null
-                      : session == null
-                      ? showMissingAccountMessage
-                      : acceptChallenge,
-              onCancel:
-                  challenge.direction == ChallengeDirection.outward
-                      ? () => ref.read(challengeRepositoryProvider).cancel(challenge.id)
-                      : null,
-              onDecline: challenge.direction == ChallengeDirection.inward ? declineChallenge : null,
-            );
+            return _ChallengeListItem(challenge: challenge, challengerUser: user, session: session);
           },
         );
       },
@@ -137,3 +123,89 @@ class _Body extends ConsumerWidget {
     );
   }
 }
+
+class _ChallengeListItem extends ConsumerWidget {
+  const _ChallengeListItem({
+    required this.challenge,
+    required this.challengerUser,
+    required this.session,
+  });
+
+  final Challenge challenge;
+  final LightUser challengerUser;
+  final AuthSessionState? session;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    Future<void> acceptChallenge() async {
+      final challengeRepo = ref.read(challengeRepositoryProvider);
+      await challengeRepo.accept(challenge.id);
+      final fullId = await challengeRepo
+          .show(challenge.id)
+          .then((challenge) => challenge.gameFullId);
+      if (!context.mounted) return;
+      Navigator.of(
+        context,
+        rootNavigator: true,
+      ).push(GameScreen.buildRoute(context, initialGameId: fullId));
+    }
+
+    Future<void> declineChallenge(ChallengeDeclineReason? reason) async {
+      ref.read(challengeRepositoryProvider).decline(challenge.id, reason: reason);
+      ref.read(notificationServiceProvider).cancel(challenge.id.value.hashCode);
+    }
+
+    void confirmDialog() {
+      showAdaptiveActionSheet<void>(
+        context: context,
+        title:
+            challenge.variant.isPlaySupported ? const Text('Do you accept the challenge?') : null,
+        actions: [
+          if (challenge.variant.isPlaySupported)
+            BottomSheetAction(
+              makeLabel: (context) => Text(context.l10n.accept),
+              leading: Icon(Icons.check, color: context.lichessColors.good),
+              isDefaultAction: true,
+              onPressed: acceptChallenge,
+            ),
+          ...ChallengeDeclineReason.values.map(
+            (reason) => BottomSheetAction(
+              makeLabel: (context) => Text(reason.label(context.l10n)),
+              leading: Icon(Icons.close, color: context.lichessColors.error),
+              isDestructiveAction: true,
+              onPressed: () {
+                declineChallenge(reason);
+              },
+            ),
+          ),
+        ],
+      );
+    }
+
+    void showMissingAccountMessage() {
+      showSnackBar(context, context.l10n.youNeedAnAccountToDoThat);
+    }
+
+    return ChallengeListItem(
+      challenge: challenge,
+      challengerUser: challengerUser,
+      onPressed:
+          challenge.direction == ChallengeDirection.inward
+              ? session == null
+                  ? showMissingAccountMessage
+                  : confirmDialog
+              : null,
+      onAccept:
+          challenge.direction == ChallengeDirection.outward || !challenge.variant.isPlaySupported
+              ? null
+              : session == null
+              ? showMissingAccountMessage
+              : acceptChallenge,
+      onCancel:
+          challenge.direction == ChallengeDirection.outward
+              ? () => ref.read(challengeRepositoryProvider).cancel(challenge.id)
+              : null,
+      onDecline: challenge.direction == ChallengeDirection.inward ? declineChallenge : null,
+    );
+  }
+}
diff --git a/lib/src/widgets/list.dart b/lib/src/widgets/list.dart
index 4132a493f9..c7e26abe14 100644
--- a/lib/src/widgets/list.dart
+++ b/lib/src/widgets/list.dart
@@ -1,4 +1,3 @@
-import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
 
diff --git a/test/view/home/home_tab_screen_test.dart b/test/view/home/home_tab_screen_test.dart
index a746d5f5d2..257ba2b1cc 100644
--- a/test/view/home/home_tab_screen_test.dart
+++ b/test/view/home/home_tab_screen_test.dart
@@ -15,6 +15,7 @@ import 'package:lichess_mobile/src/widgets/feedback.dart';
 import '../../example_data.dart';
 import '../../mock_server_responses.dart';
 import '../../model/auth/fake_session_storage.dart';
+import '../../model/challenge/challenge_repository_test.dart';
 import '../../network/fake_http_client_factory.dart';
 import '../../test_helpers.dart';
 import '../../test_provider_scope.dart';
@@ -53,11 +54,23 @@ void main() {
       );
     });
 
-    testWidgets('shows challenge button if has session', (tester) async {
+    testWidgets('shows challenge button if has challenges', (tester) async {
       final app = await makeTestProviderScope(
         tester,
         child: const Application(),
         userSession: fakeSession,
+        overrides: [
+          httpClientFactoryProvider.overrideWith(
+            (ref) => FakeHttpClientFactory(
+              () => MockClient((request) {
+                if (request.url.path == '/api/challenge') {
+                  return mockResponse(challengesList, 200);
+                }
+                return mockResponse('', 200);
+              }),
+            ),
+          ),
+        ],
       );
       await tester.pumpWidget(app);
 
@@ -65,6 +78,9 @@ void main() {
       expect(find.byType(CircularProgressIndicator), findsOneWidget);
       await tester.pump();
 
+      // wait for challenge list to load
+      await tester.pump();
+
       expect(
         tester
             .widget<SemanticIconButton>(
