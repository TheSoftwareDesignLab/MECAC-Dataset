diff --git a/mobile-app/lib/models/learn/challenge_model.dart b/mobile-app/lib/models/learn/challenge_model.dart
index 012c19648..44ada1d9c 100644
--- a/mobile-app/lib/models/learn/challenge_model.dart
+++ b/mobile-app/lib/models/learn/challenge_model.dart
@@ -73,6 +73,10 @@ class Challenge {
   // Challenge Type 15 - Odin
   final List<String>? assignments;
 
+  // Challenge Type 8 - Quiz
+  // This list contains multiple sets of quiz
+  final List<Quiz>? quizzes;
+
   Challenge({
     required this.id,
     required this.block,
@@ -93,6 +97,7 @@ class Challenge {
     this.fillInTheBlank,
     this.audio,
     this.scene,
+    this.quizzes,
     required this.hooks,
   });
 
@@ -134,6 +139,11 @@ class Challenge {
       hooks: Hooks.fromJson(
         data['hooks'] ?? {'beforeAll': ''},
       ),
+      quizzes: (data['quizzes'] != null)
+          ? (data['quizzes'] as List)
+              .map<Quiz>((quiz) => Quiz.fromJson(quiz))
+              .toList()
+          : null,
     );
   }
 
@@ -180,6 +190,17 @@ class Challenge {
                 'solution': question.solution,
               })
           .toList(),
+      'quizzes': challenge.quizzes
+          ?.map((quiz) => {
+                'questions': quiz.questions
+                    .map((question) => {
+                          'text': question.text,
+                          'answers': question.answers,
+                          'solution': question.solution,
+                        })
+                    .toList(),
+              })
+          .toList(),
     };
   }
 }
@@ -332,6 +353,56 @@ class Blank {
   }
 }
 
+class QuizQuestion {
+  final String text;
+  final List<Answer> answers;
+  final int solution;
+
+  const QuizQuestion({
+    required this.text,
+    required this.answers,
+    required this.solution,
+  });
+
+  factory QuizQuestion.fromJson(Map<String, dynamic> data) {
+    // Quiz data has answer and distractors as separate fields rather than in a single array.
+    // We combine them into one so that the question schema
+    // is consistent with the other MCQ challenges.
+    final allAnswers = [
+      ...(data['distractors'] as List)
+          .map<Answer>((item) => Answer(answer: item)),
+      Answer(answer: data['answer'])
+    ];
+
+    // shuffle so the correct answer is not always the last
+    allAnswers.shuffle();
+
+    // Solution is the index of the correct answer in the shuffled list.
+    // + 1 here so that it matches the 1-based index used in the UI logic.
+    final solutionIndex =
+        allAnswers.indexWhere((a) => a.answer == data['answer']) + 1;
+
+    return QuizQuestion(
+        text: data['text'], answers: allAnswers, solution: solutionIndex);
+  }
+}
+
+class Quiz {
+  final List<QuizQuestion> questions;
+
+  const Quiz({
+    required this.questions,
+  });
+
+  factory Quiz.fromJson(Map<String, dynamic> data) {
+    return Quiz(
+      questions: (data['questions'] as List)
+          .map<QuizQuestion>((item) => QuizQuestion.fromJson(item))
+          .toList(),
+    );
+  }
+}
+
 class Scene {
   final SceneSetup setup;
   final List<SceneCommand> commands;
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_view.dart b/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_view.dart
new file mode 100644
index 000000000..bc4a77776
--- /dev/null
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_view.dart
@@ -0,0 +1,168 @@
+import 'package:flutter/material.dart';
+import 'package:freecodecamp/extensions/i18n_extension.dart';
+import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:freecodecamp/models/learn/curriculum_model.dart';
+import 'package:freecodecamp/ui/theme/fcc_theme.dart';
+import 'package:freecodecamp/ui/views/learn/challenge/templates/quiz/quiz_viewmodel.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/challenge_card.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
+import 'package:freecodecamp/ui/views/news/html_handler/html_handler.dart';
+import 'package:stacked/stacked.dart';
+
+class QuizView extends StatelessWidget {
+  const QuizView({
+    super.key,
+    required this.challenge,
+    required this.block,
+    required this.challengesCompleted,
+  });
+
+  final Challenge challenge;
+  final Block block;
+  final int challengesCompleted;
+
+  @override
+  Widget build(BuildContext context) {
+    HTMLParser parser = HTMLParser(context: context);
+
+    return ViewModelBuilder<QuizViewModel>.reactive(
+      viewModelBuilder: () => QuizViewModel(),
+      onViewModelReady: (model) => model.initChallenge(challenge),
+      builder: (context, model, child) {
+        return PopScope<bool>(
+          canPop: false,
+          onPopInvokedWithResult: (didPop, result) async {
+            if (didPop) {
+              return;
+            }
+
+            // Show confirmation dialog
+            final shouldPop = await showDialog<bool>(
+              context: context,
+              builder: (context) => AlertDialog(
+                title: const Text('Are you sure?'),
+                content: const Text(
+                    'Do you want to leave this quiz? Your progress will be lost.'),
+                actions: [
+                  TextButton(
+                    style: TextButton.styleFrom(
+                      backgroundColor: FccColors.gray80,
+                    ),
+                    onPressed: () => Navigator.of(context).pop(false),
+                    child: const Text('Cancel'),
+                  ),
+                  TextButton(
+                    style: TextButton.styleFrom(
+                      backgroundColor: FccColors.red15,
+                    ),
+                    onPressed: () => Navigator.of(context).pop(true),
+                    child: const Text(
+                      'Leave',
+                      style: TextStyle(color: FccColors.red90),
+                    ),
+                  ),
+                ],
+              ),
+            );
+
+            // If user confirmed leaving, allow navigation
+            if (shouldPop == true) {
+              Navigator.of(context).pop();
+            }
+          },
+          child: Scaffold(
+            backgroundColor: FccColors.gray90,
+            persistentFooterAlignment: AlignmentDirectional.topStart,
+            appBar: AppBar(
+              backgroundColor: FccColors.gray90,
+            ),
+            body: SafeArea(
+              child: ListView(
+                children: [
+                  ChallengeCard(
+                    title: challenge.title,
+                    child: Column(
+                      children: [
+                        ...parser.parse(
+                          challenge.instructions,
+                          fontColor: FccColors.gray05,
+                        ),
+                        ...parser.parse(
+                          challenge.description,
+                          fontColor: FccColors.gray05,
+                        ),
+                      ],
+                    ),
+                  ),
+                  QuizWidget(
+                      isValidated: model.isValidated,
+                      questions: model.quizQuestions,
+                      onChanged: (questionIndex, answerIndex) {
+                        model.setSelectedAnswer(questionIndex, answerIndex);
+                      }),
+                  const SizedBox(height: 16),
+                  if (model.errMessage.isNotEmpty) ...[
+                    Padding(
+                      padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                      child: Text(
+                        model.errMessage,
+                        style: const TextStyle(
+                          fontSize: 18,
+                        ),
+                      ),
+                    ),
+                  ],
+                  const SizedBox(height: 16),
+                  Row(
+                    children: [
+                      Expanded(
+                        child: Container(
+                          margin: const EdgeInsets.all(8),
+                          child: ElevatedButton(
+                            style: ElevatedButton.styleFrom(
+                              minimumSize: const Size(0, 50),
+                              backgroundColor:
+                                  const Color.fromRGBO(0x3b, 0x3b, 0x4f, 1),
+                              shape: const RoundedRectangleBorder(
+                                borderRadius: BorderRadius.zero,
+                                side: BorderSide(
+                                  width: 2,
+                                  color: Colors.white,
+                                ),
+                              ),
+                            ),
+                            onPressed: () {
+                              if (model.isValidated &&
+                                  model.hasPassedAllQuestions) {
+                                model.learnService.goToNextChallenge(
+                                  block.challenges.length,
+                                  challengesCompleted,
+                                  challenge,
+                                  block,
+                                );
+                              } else {
+                                model.validateChallenge();
+                              }
+                            },
+                            child: Text(
+                              model.isValidated
+                                  ? model.hasPassedAllQuestions
+                                      ? context.t.next_challenge
+                                      : context.t.try_again
+                                  : context.t.questions_check,
+                              style: const TextStyle(fontSize: 20),
+                            ),
+                          ),
+                        ),
+                      ),
+                    ],
+                  )
+                ],
+              ),
+            ),
+          ),
+        );
+      },
+    );
+  }
+}
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_viewmodel.dart b/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_viewmodel.dart
new file mode 100644
index 000000000..41f59dfb4
--- /dev/null
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/quiz/quiz_viewmodel.dart
@@ -0,0 +1,110 @@
+import 'package:freecodecamp/app/app.locator.dart';
+import 'package:freecodecamp/models/learn/challenge_model.dart';
+import 'package:freecodecamp/service/learn/learn_service.dart';
+import 'package:freecodecamp/ui/views/learn/widgets/quiz_widget.dart';
+import 'package:stacked/stacked.dart';
+
+class QuizViewModel extends BaseViewModel {
+  bool _isValidated = false;
+  bool get isValidated => _isValidated;
+
+  bool _hasPassedAllQuestions = false;
+  bool get hasPassedAllQuestions => _hasPassedAllQuestions;
+
+  List<int> get unansweredQuestions => _quizQuestions
+      .asMap()
+      .entries
+      .where((entry) => entry.value.selectedAnswer == -1)
+      .map((entry) => entry.key + 1) // Convert to 1-based indexing for display
+      .toList();
+
+  String _errMessage = '';
+  String get errMessage => _errMessage;
+
+  List<QuizWidgetQuestion> _quizQuestions = [];
+  List<QuizWidgetQuestion> get quizQuestions => _quizQuestions;
+
+  final LearnService learnService = locator<LearnService>();
+
+  set setQuizQuestions(List<QuizWidgetQuestion> questions) {
+    _quizQuestions = questions;
+    notifyListeners();
+  }
+
+  set setIsValidated(bool status) {
+    _isValidated = status;
+    notifyListeners();
+  }
+
+  set setHasPassedAllQuestions(bool status) {
+    _hasPassedAllQuestions = status;
+    notifyListeners();
+  }
+
+  set setErrMessage(String message) {
+    _errMessage = message;
+    notifyListeners();
+  }
+
+  void initChallenge(Challenge challenge) {
+    // Randomly select a question set from challenge.quizzes
+    final questionSet =
+        (challenge.quizzes != null && challenge.quizzes!.isNotEmpty)
+            ? (challenge.quizzes!..shuffle()).first
+            : null;
+    final questions = questionSet?.questions ?? [];
+
+    setQuizQuestions = questions
+        .map<QuizWidgetQuestion>((q) => QuizWidgetQuestion(
+              text: q.text,
+              answers: q.answers,
+              solution: q.solution,
+            ))
+        .toList();
+  }
+
+  void setSelectedAnswer(int questionIndex, int answerIndex) {
+    final question = quizQuestions[questionIndex];
+    question.selectedAnswer = answerIndex;
+
+    if (isValidated) {
+      // Reset the validation status when user changes the selection
+      setIsValidated = false;
+    }
+
+    if (errMessage.isNotEmpty) {
+      // Clear the error message when user changes the selection
+      setErrMessage = '';
+    }
+
+    notifyListeners();
+  }
+
+  void validateChallenge() {
+    if (unansweredQuestions.length > 1) {
+      setErrMessage =
+          "The following questions are unanswered: ${unansweredQuestions.join(', ')}. You must answer all questions.";
+      return;
+    }
+
+    // Loop through each question and set isCorrect status
+    setQuizQuestions = List.from(quizQuestions)
+      ..asMap().forEach((i, question) {
+        question.isCorrect = question.selectedAnswer == question.solution - 1;
+      });
+
+    final correctQuestionsCount =
+        quizQuestions.where((q) => q.isCorrect == true).length;
+    final totalQuestions = quizQuestions.length;
+    final minCorrectToPass = (totalQuestions * 0.9).ceil();
+
+    setHasPassedAllQuestions = unansweredQuestions.isEmpty &&
+        correctQuestionsCount >= minCorrectToPass;
+
+    setIsValidated = true;
+
+    setErrMessage = hasPassedAllQuestions
+        ? '✅ You have $correctQuestionsCount out of $totalQuestions questions correct. You have passed.'
+        : "❌ You have $correctQuestionsCount out of $totalQuestions questions correct. You didn't pass.";
+  }
+}
diff --git a/mobile-app/lib/ui/views/learn/challenge/templates/template_view.dart b/mobile-app/lib/ui/views/learn/challenge/templates/template_view.dart
index c2e16a0c9..b39fc1ea0 100644
--- a/mobile-app/lib/ui/views/learn/challenge/templates/template_view.dart
+++ b/mobile-app/lib/ui/views/learn/challenge/templates/template_view.dart
@@ -6,6 +6,7 @@ import 'package:freecodecamp/ui/views/learn/challenge/templates/english/english_
 import 'package:freecodecamp/ui/views/learn/challenge/templates/multiple_choice/multiple_choice_view.dart';
 import 'package:freecodecamp/ui/views/learn/challenge/templates/python-project/python_project_view.dart';
 import 'package:freecodecamp/ui/views/learn/challenge/templates/python/python_view.dart';
+import 'package:freecodecamp/ui/views/learn/challenge/templates/quiz/quiz_view.dart';
 import 'package:freecodecamp/ui/views/learn/challenge/templates/review/review_view.dart';
 import 'package:freecodecamp/ui/views/learn/challenge/templates/template_viewmodel.dart';
 import 'package:stacked/stacked.dart';
@@ -52,6 +53,12 @@ class ChallengeTemplateView extends StatelessWidget {
                     challengesCompleted: challengesCompleted,
                     isProject: tiles.length > 1,
                   );
+                case 8:
+                  return QuizView(
+                    challenge: challenge,
+                    block: block,
+                    challengesCompleted: challengesCompleted,
+                  );
                 case 10:
                   return PythonProjectView(
                     challenge: challenge,
diff --git a/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart b/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart
index 63bca24fb..2ddcb6ac9 100644
--- a/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart
+++ b/mobile-app/lib/ui/views/learn/widgets/quiz_widget.dart
@@ -21,64 +21,106 @@ class QuizWidgetQuestion {
   });
 }
 
-class QuizWidget extends StatelessWidget {
+class QuizWidget extends StatefulWidget {
   final List<QuizWidgetQuestion> questions;
   final Function(int, int) onChanged;
   final bool? isValidated;
 
-  const QuizWidget(
-      {super.key,
-      required this.questions,
-      required this.onChanged,
-      this.isValidated});
+  const QuizWidget({
+    super.key,
+    required this.questions,
+    required this.onChanged,
+    this.isValidated,
+  });
+
+  @override
+  State<QuizWidget> createState() => _QuizWidgetState();
+}
+
+class _QuizWidgetState extends State<QuizWidget> {
+  late final HTMLParser parser;
+  late List<List<Widget>> parsedQuestions;
+  late List<List<List<Widget>>> parsedOptions;
+
+  @override
+  void initState() {
+    super.initState();
+    parser = HTMLParser(context: context);
+    _parseAll();
+  }
+
+  @override
+  void didUpdateWidget(covariant QuizWidget oldWidget) {
+    super.didUpdateWidget(oldWidget);
+    if (_areQuestionsChanged(oldWidget.questions, widget.questions)) {
+      _parseAll();
+    }
+  }
+
+  bool _areQuestionsChanged(List<QuizWidgetQuestion> oldQuestions,
+      List<QuizWidgetQuestion> newQuestions) {
+    if (oldQuestions.length != newQuestions.length) {
+      return true;
+    }
+
+    for (int i = 0; i < oldQuestions.length; i++) {
+      // Only check for selectedAnswer changes as the other information is not changed between updates
+      if (oldQuestions[i].selectedAnswer != newQuestions[i].selectedAnswer) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  void _parseAll() {
+    parsedQuestions =
+        widget.questions.map((q) => parser.parse(q.text)).toList();
+    parsedOptions = widget.questions
+        .map((q) => q.answers
+            .map((a) => parser.parse(
+                  a.answer,
+                  isSelectable: false,
+                  removeParagraphMargin: true,
+                ))
+            .toList())
+        .toList();
+  }
 
   @override
   Widget build(BuildContext context) {
-    return Column(
-      children: List.generate(
-        questions.length,
-        (index) {
-          return quizQuestion(
-              context: context,
-              questionNumber: questions.length > 1 ? index + 1 : null,
-              question: questions[index],
-              selectedAnswer: questions[index].selectedAnswer,
-              isCorrect: questions[index].isCorrect,
-              onChanged: (answerIndex) {
-                onChanged(index, answerIndex);
-              });
-        },
-      ),
+    return ListView.builder(
+      shrinkWrap: true,
+      physics: const NeverScrollableScrollPhysics(),
+      itemCount: widget.questions.length,
+      itemBuilder: (context, index) {
+        return quizQuestion(
+          context: context,
+          questionNumber: widget.questions.length > 1 ? index + 1 : null,
+          questionIndex: index,
+        );
+      },
     );
   }
 
-  ChallengeCard quizQuestion(
-      {required BuildContext context,
-      required QuizWidgetQuestion question,
-      required int selectedAnswer,
-      required ValueChanged<int> onChanged,
-      bool? isCorrect,
-      int? questionNumber}) {
-    HTMLParser parser = HTMLParser(context: context);
-
+  ChallengeCard quizQuestion({
+    required BuildContext context,
+    required int questionIndex,
+    int? questionNumber,
+  }) {
+    final question = widget.questions[questionIndex];
     return ChallengeCard(
       title: questionNumber != null ? 'Question $questionNumber' : 'Question',
       child: Column(
         crossAxisAlignment: CrossAxisAlignment.start,
         children: [
-          ...parser.parse(
-            question.text,
-          ),
+          ...parsedQuestions[questionIndex],
           const SizedBox(height: 8),
           for (final answerObj in question.answers.asMap().entries) ...[
             option(
               context: context,
               answerObj: answerObj,
-              selectedAnswer: selectedAnswer,
-              isCorrect: isCorrect,
-              onChanged: (value) {
-                onChanged(value);
-              },
+              questionIndex: questionIndex,
             ),
           ],
         ],
@@ -89,19 +131,19 @@ class QuizWidget extends StatelessWidget {
   Container option({
     required BuildContext context,
     required MapEntry<int, Answer> answerObj,
-    required int selectedAnswer,
-    required bool? isCorrect,
-    required ValueChanged<int> onChanged,
+    required int questionIndex,
   }) {
-    HTMLParser parser = HTMLParser(context: context);
-
+    final question = widget.questions[questionIndex];
+    final selectedAnswer = question.selectedAnswer;
+    final isCorrect = question.isCorrect;
     final isSelected = answerObj.key == selectedAnswer;
+    final optionWidgets = parsedOptions[questionIndex][answerObj.key];
 
     return Container(
       margin: const EdgeInsets.symmetric(vertical: 8),
       child: Material(
         child: RadioListTile<int>(
-          key: ValueKey(selectedAnswer),
+          key: ValueKey(answerObj.key),
           selected: isSelected,
           tileColor: const Color(0xFF0a0a23),
           selectedTileColor: const Color(0xFF0a0a23),
@@ -115,7 +157,7 @@ class QuizWidget extends StatelessWidget {
           ),
           groupValue: selectedAnswer,
           onChanged: (value) {
-            onChanged(value ?? -1);
+            widget.onChanged(questionIndex, value ?? -1);
           },
           title: Align(
             alignment: Alignment.centerLeft,
@@ -126,15 +168,11 @@ class QuizWidget extends StatelessWidget {
               child: Column(
                 crossAxisAlignment: CrossAxisAlignment.start,
                 mainAxisAlignment: MainAxisAlignment.center,
-                children: parser.parse(
-                  answerObj.value.answer,
-                  isSelectable: false,
-                  removeParagraphMargin: true,
-                ),
+                children: optionWidgets,
               ),
             ),
           ),
-          subtitle: isSelected && isValidated == true
+          subtitle: isSelected && widget.isValidated == true
               ? validationStatusAndFeedback(
                   context: context,
                   isCorrect: isCorrect,
@@ -146,8 +184,11 @@ class QuizWidget extends StatelessWidget {
     );
   }
 
-  Widget validationStatusAndFeedback(
-      {required BuildContext context, bool? isCorrect, String? feedback}) {
+  Widget validationStatusAndFeedback({
+    required BuildContext context,
+    bool? isCorrect,
+    String? feedback,
+  }) {
     HTMLParser parser = HTMLParser(context: context);
     final List<Widget> feedbackWidgets = [];
 
