diff --git a/lib/src/view/analysis/analysis_screen.dart b/lib/src/view/analysis/analysis_screen.dart
index d663a391b2..886fb8005d 100644
--- a/lib/src/view/analysis/analysis_screen.dart
+++ b/lib/src/view/analysis/analysis_screen.dart
@@ -1,43 +1,30 @@
-import 'dart:math' as math;
-
-import 'package:collection/collection.dart';
-import 'package:dartchess/dartchess.dart';
-import 'package:fast_immutable_collections/fast_immutable_collections.dart';
-import 'package:fl_chart/fl_chart.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_preferences.dart';
-import 'package:lichess_mobile/src/model/analysis/server_analysis_service.dart';
-import 'package:lichess_mobile/src/model/auth/auth_session.dart';
 import 'package:lichess_mobile/src/model/common/chess.dart';
 import 'package:lichess_mobile/src/model/common/id.dart';
-import 'package:lichess_mobile/src/model/engine/engine.dart';
-import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
 import 'package:lichess_mobile/src/model/game/game_repository_providers.dart';
 import 'package:lichess_mobile/src/model/game/game_share_service.dart';
-import 'package:lichess_mobile/src/network/connectivity.dart';
 import 'package:lichess_mobile/src/network/http.dart';
 import 'package:lichess_mobile/src/styles/lichess_icons.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/utils/navigation.dart';
-import 'package:lichess_mobile/src/utils/string.dart';
 import 'package:lichess_mobile/src/view/analysis/analysis_layout.dart';
 import 'package:lichess_mobile/src/view/analysis/analysis_share_screen.dart';
+import 'package:lichess_mobile/src/view/analysis/server_analysis.dart';
 import 'package:lichess_mobile/src/view/board_editor/board_editor_screen.dart';
+import 'package:lichess_mobile/src/view/engine/engine_depth.dart';
 import 'package:lichess_mobile/src/view/engine/engine_gauge.dart';
 import 'package:lichess_mobile/src/view/engine/engine_lines.dart';
-import 'package:lichess_mobile/src/view/opening_explorer/opening_explorer_screen.dart';
 import 'package:lichess_mobile/src/widgets/adaptive_action_sheet.dart';
 import 'package:lichess_mobile/src/widgets/adaptive_bottom_sheet.dart';
 import 'package:lichess_mobile/src/widgets/bottom_bar.dart';
 import 'package:lichess_mobile/src/widgets/bottom_bar_button.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
 import 'package:lichess_mobile/src/widgets/feedback.dart';
-import 'package:lichess_mobile/src/widgets/list.dart';
 import 'package:lichess_mobile/src/widgets/platform_scaffold.dart';
-import 'package:popover/popover.dart';
 
 import '../../utils/share.dart';
 import 'analysis_board.dart';
@@ -167,13 +154,15 @@ class _LoadedAnalysisScreenState extends ConsumerState<_LoadedAnalysisScreen>
   @override
   Widget build(BuildContext context) {
     final ctrlProvider = analysisControllerProvider(widget.pgn, widget.options);
+    final currentNodeEval =
+        ref.watch(ctrlProvider.select((value) => value.currentNode.eval));
 
     return PlatformScaffold(
       resizeToAvoidBottomInset: false,
       appBar: PlatformAppBar(
         title: _Title(options: widget.options),
         actions: [
-          _EngineDepth(ctrlProvider),
+          EngineDepth(defaultEval: currentNodeEval),
           AppBarAnalysisTabIndicator(
             tabs: tabs,
             controller: _tabController,
@@ -237,23 +226,16 @@ class _Body extends ConsumerWidget {
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final ctrlProvider = analysisControllerProvider(pgn, options);
     final showEvaluationGauge = ref.watch(
       analysisPreferencesProvider.select((value) => value.showEvaluationGauge),
     );
 
-    final isEngineAvailable = ref.watch(
-      ctrlProvider.select(
-        (value) => value.isEngineAvailable,
-      ),
-    );
-
-    final hasEval =
-        ref.watch(ctrlProvider.select((value) => value.hasAvailableEval));
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final analysisState = ref.watch(ctrlProvider);
 
-    final currentNode = ref.watch(
-      ctrlProvider.select((value) => value.currentNode),
-    );
+    final isEngineAvailable = analysisState.isEngineAvailable;
+    final hasEval = analysisState.hasAvailableEval;
+    final currentNode = analysisState.currentNode;
 
     return AnalysisLayout(
       tabController: controller,
@@ -267,8 +249,20 @@ class _Body extends ConsumerWidget {
       engineGaugeBuilder: hasEval && showEvaluationGauge
           ? (context, orientation) {
               return orientation == Orientation.portrait
-                  ? _EngineGaugeHorizontal(ctrlProvider)
-                  : _EngineGaugeVertical(ctrlProvider);
+                  ? EngineGauge(
+                      displayMode: EngineGaugeDisplayMode.horizontal,
+                      params: analysisState.engineGaugeParams,
+                    )
+                  : Container(
+                      clipBehavior: Clip.hardEdge,
+                      decoration: BoxDecoration(
+                        borderRadius: BorderRadius.circular(4.0),
+                      ),
+                      child: EngineGauge(
+                        displayMode: EngineGaugeDisplayMode.vertical,
+                        params: analysisState.engineGaugeParams,
+                      ),
+                    );
             }
           : null,
       engineLines: isEngineAvailable
@@ -287,44 +281,6 @@ class _Body extends ConsumerWidget {
   }
 }
 
-class _EngineGaugeVertical extends ConsumerWidget {
-  const _EngineGaugeVertical(this.ctrlProvider);
-
-  final AnalysisControllerProvider ctrlProvider;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final analysisState = ref.watch(ctrlProvider);
-
-    return Container(
-      clipBehavior: Clip.hardEdge,
-      decoration: BoxDecoration(
-        borderRadius: BorderRadius.circular(4.0),
-      ),
-      child: EngineGauge(
-        displayMode: EngineGaugeDisplayMode.vertical,
-        params: analysisState.engineGaugeParams,
-      ),
-    );
-  }
-}
-
-class _EngineGaugeHorizontal extends ConsumerWidget {
-  const _EngineGaugeHorizontal(this.ctrlProvider);
-
-  final AnalysisControllerProvider ctrlProvider;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final analysisState = ref.watch(ctrlProvider);
-
-    return EngineGauge(
-      displayMode: EngineGaugeDisplayMode.horizontal,
-      params: analysisState.engineGaugeParams,
-    );
-  }
-}
-
 class _BottomBar extends ConsumerWidget {
   const _BottomBar({
     required this.pgn,
@@ -338,8 +294,6 @@ class _BottomBar extends ConsumerWidget {
   Widget build(BuildContext context, WidgetRef ref) {
     final ctrlProvider = analysisControllerProvider(pgn, options);
     final analysisState = ref.watch(ctrlProvider);
-    final isOnline =
-        ref.watch(connectivityChangesProvider).valueOrNull?.isOnline ?? false;
 
     return BottomBar(
       children: [
@@ -350,22 +304,6 @@ class _BottomBar extends ConsumerWidget {
           },
           icon: Icons.menu,
         ),
-        BottomBarButton(
-          label: context.l10n.openingExplorer,
-          onTap: isOnline
-              ? () {
-                  pushPlatformRoute(
-                    context,
-                    title: context.l10n.openingExplorer,
-                    builder: (_) => OpeningExplorerScreen(
-                      pgn: ref.read(ctrlProvider.notifier).makeCurrentNodePgn(),
-                      options: analysisState.openingExplorerOptions,
-                    ),
-                  );
-                }
-              : null,
-          icon: Icons.explore,
-        ),
         RepeatButton(
           onLongPress:
               analysisState.canGoBack ? () => _moveBackward(ref) : null,
@@ -485,601 +423,3 @@ class _BottomBar extends ConsumerWidget {
     );
   }
 }
-
-class _EngineDepth extends ConsumerWidget {
-  const _EngineDepth(this.ctrlProvider);
-
-  final AnalysisControllerProvider ctrlProvider;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final isEngineAvailable = ref.watch(
-      ctrlProvider.select(
-        (value) => value.isEngineAvailable,
-      ),
-    );
-    final currentNode = ref.watch(
-      ctrlProvider.select((value) => value.currentNode),
-    );
-    final depth = ref.watch(
-          engineEvaluationProvider.select((value) => value.eval?.depth),
-        ) ??
-        currentNode.eval?.depth;
-
-    return isEngineAvailable && depth != null
-        ? AppBarTextButton(
-            onPressed: () {
-              showPopover(
-                context: context,
-                bodyBuilder: (context) {
-                  return _StockfishInfo(currentNode);
-                },
-                direction: PopoverDirection.top,
-                width: 240,
-                backgroundColor:
-                    Theme.of(context).platform == TargetPlatform.android
-                        ? Theme.of(context).dialogBackgroundColor
-                        : CupertinoDynamicColor.resolve(
-                            CupertinoColors.tertiarySystemBackground,
-                            context,
-                          ),
-                transitionDuration: Duration.zero,
-                popoverTransitionBuilder: (_, child) => child,
-              );
-            },
-            child: RepaintBoundary(
-              child: Container(
-                width: 20.0,
-                height: 20.0,
-                padding: const EdgeInsets.all(2.0),
-                decoration: BoxDecoration(
-                  color: Theme.of(context).platform == TargetPlatform.android
-                      ? Theme.of(context).colorScheme.secondary
-                      : CupertinoTheme.of(context).primaryColor,
-                  borderRadius: BorderRadius.circular(4.0),
-                ),
-                child: FittedBox(
-                  fit: BoxFit.contain,
-                  child: Text(
-                    '${math.min(99, depth)}',
-                    style: TextStyle(
-                      color: Theme.of(context).platform ==
-                              TargetPlatform.android
-                          ? Theme.of(context).colorScheme.onSecondary
-                          : CupertinoTheme.of(context).primaryContrastingColor,
-                      fontFeatures: const [
-                        FontFeature.tabularFigures(),
-                      ],
-                    ),
-                  ),
-                ),
-              ),
-            ),
-          )
-        : const SizedBox.shrink();
-  }
-}
-
-class _StockfishInfo extends ConsumerWidget {
-  const _StockfishInfo(this.currentNode);
-
-  final AnalysisCurrentNode currentNode;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final (engineName: engineName, eval: eval, state: engineState) =
-        ref.watch(engineEvaluationProvider);
-
-    final currentEval = eval ?? currentNode.eval;
-
-    final knps = engineState == EngineState.computing
-        ? ', ${eval?.knps.round()}kn/s'
-        : '';
-    final depth = currentEval?.depth ?? 0;
-    final maxDepth = math.max(depth, kMaxEngineDepth);
-
-    return Column(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        PlatformListTile(
-          leading: Image.asset(
-            'assets/images/stockfish/icon.png',
-            width: 44,
-            height: 44,
-          ),
-          title: Text(engineName),
-          subtitle: Text(
-            context.l10n.depthX(
-              '$depth/$maxDepth$knps',
-            ),
-          ),
-        ),
-      ],
-    );
-  }
-}
-
-class ServerAnalysisSummary extends ConsumerWidget {
-  const ServerAnalysisSummary(this.pgn, this.options);
-
-  final String pgn;
-  final AnalysisOptions options;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final ctrlProvider = analysisControllerProvider(pgn, options);
-    final playersAnalysis =
-        ref.watch(ctrlProvider.select((value) => value.playersAnalysis));
-    final pgnHeaders =
-        ref.watch(ctrlProvider.select((value) => value.pgnHeaders));
-    final currentGameAnalysis = ref.watch(currentAnalysisProvider);
-
-    return playersAnalysis != null
-        ? ListView(
-            children: [
-              if (currentGameAnalysis == options.gameAnyId?.gameId)
-                const Padding(
-                  padding: EdgeInsets.only(top: 16.0),
-                  child: WaitingForServerAnalysis(),
-                ),
-              AcplChart(pgn, options),
-              Center(
-                child: SizedBox(
-                  width: math.min(MediaQuery.sizeOf(context).width, 500),
-                  child: Padding(
-                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
-                    child: Table(
-                      defaultVerticalAlignment:
-                          TableCellVerticalAlignment.middle,
-                      columnWidths: const {
-                        0: FlexColumnWidth(1),
-                        1: FlexColumnWidth(1),
-                        2: FlexColumnWidth(1),
-                      },
-                      children: [
-                        TableRow(
-                          decoration: const BoxDecoration(
-                            border: Border(
-                              bottom: BorderSide(color: Colors.grey),
-                            ),
-                          ),
-                          children: [
-                            _SummaryPlayerName(Side.white, pgnHeaders),
-                            Center(
-                              child: Text(
-                                pgnHeaders.get('Result') ?? '',
-                                style: const TextStyle(
-                                  fontWeight: FontWeight.bold,
-                                ),
-                              ),
-                            ),
-                            _SummaryPlayerName(Side.black, pgnHeaders),
-                          ],
-                        ),
-                        if (playersAnalysis.white.accuracy != null &&
-                            playersAnalysis.black.accuracy != null)
-                          TableRow(
-                            children: [
-                              _SummaryNumber(
-                                '${playersAnalysis.white.accuracy}%',
-                              ),
-                              Center(
-                                heightFactor: 1.8,
-                                child: Text(
-                                  context.l10n.accuracy,
-                                  softWrap: true,
-                                ),
-                              ),
-                              _SummaryNumber(
-                                '${playersAnalysis.black.accuracy}%',
-                              ),
-                            ],
-                          ),
-                        for (final item in [
-                          (
-                            playersAnalysis.white.inaccuracies.toString(),
-                            context.l10n
-                                .nbInaccuracies(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.inaccuracies.toString()
-                          ),
-                          (
-                            playersAnalysis.white.mistakes.toString(),
-                            context.l10n
-                                .nbMistakes(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.mistakes.toString()
-                          ),
-                          (
-                            playersAnalysis.white.blunders.toString(),
-                            context.l10n
-                                .nbBlunders(2)
-                                .replaceAll('2', '')
-                                .trim()
-                                .capitalize(),
-                            playersAnalysis.black.blunders.toString()
-                          ),
-                        ])
-                          TableRow(
-                            children: [
-                              _SummaryNumber(item.$1),
-                              Center(
-                                heightFactor: 1.2,
-                                child: Text(
-                                  item.$2,
-                                  softWrap: true,
-                                ),
-                              ),
-                              _SummaryNumber(item.$3),
-                            ],
-                          ),
-                        if (playersAnalysis.white.acpl != null &&
-                            playersAnalysis.black.acpl != null)
-                          TableRow(
-                            children: [
-                              _SummaryNumber(
-                                playersAnalysis.white.acpl.toString(),
-                              ),
-                              Center(
-                                heightFactor: 1.5,
-                                child: Text(
-                                  context.l10n.averageCentipawnLoss,
-                                  softWrap: true,
-                                  textAlign: TextAlign.center,
-                                ),
-                              ),
-                              _SummaryNumber(
-                                playersAnalysis.black.acpl.toString(),
-                              ),
-                            ],
-                          ),
-                      ],
-                    ),
-                  ),
-                ),
-              ),
-            ],
-          )
-        : Column(
-            mainAxisSize: MainAxisSize.min,
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: [
-              const Spacer(),
-              if (currentGameAnalysis == options.gameAnyId?.gameId)
-                const Center(
-                  child: Padding(
-                    padding: EdgeInsets.symmetric(vertical: 16.0),
-                    child: WaitingForServerAnalysis(),
-                  ),
-                )
-              else
-                Center(
-                  child: Padding(
-                    padding: const EdgeInsets.symmetric(vertical: 16.0),
-                    child: Builder(
-                      builder: (context) {
-                        Future<void>? pendingRequest;
-                        return StatefulBuilder(
-                          builder: (context, setState) {
-                            return FutureBuilder<void>(
-                              future: pendingRequest,
-                              builder: (context, snapshot) {
-                                return SecondaryButton(
-                                  semanticsLabel:
-                                      context.l10n.requestAComputerAnalysis,
-                                  onPressed: ref.watch(authSessionProvider) ==
-                                          null
-                                      ? () {
-                                          showPlatformSnackbar(
-                                            context,
-                                            context
-                                                .l10n.youNeedAnAccountToDoThat,
-                                          );
-                                        }
-                                      : snapshot.connectionState ==
-                                              ConnectionState.waiting
-                                          ? null
-                                          : () {
-                                              setState(() {
-                                                pendingRequest = ref
-                                                    .read(ctrlProvider.notifier)
-                                                    .requestServerAnalysis()
-                                                    .catchError((Object e) {
-                                                  if (context.mounted) {
-                                                    showPlatformSnackbar(
-                                                      context,
-                                                      e.toString(),
-                                                      type: SnackBarType.error,
-                                                    );
-                                                  }
-                                                });
-                                              });
-                                            },
-                                  child: Text(
-                                    context.l10n.requestAComputerAnalysis,
-                                  ),
-                                );
-                              },
-                            );
-                          },
-                        );
-                      },
-                    ),
-                  ),
-                ),
-              const Spacer(),
-            ],
-          );
-  }
-}
-
-class WaitingForServerAnalysis extends StatelessWidget {
-  const WaitingForServerAnalysis({super.key});
-
-  @override
-  Widget build(BuildContext context) {
-    return Row(
-      mainAxisAlignment: MainAxisAlignment.center,
-      mainAxisSize: MainAxisSize.max,
-      children: [
-        Image.asset(
-          'assets/images/stockfish/icon.png',
-          width: 30,
-          height: 30,
-        ),
-        const SizedBox(width: 8.0),
-        Text(context.l10n.waitingForAnalysis),
-        const SizedBox(width: 8.0),
-        const CircularProgressIndicator.adaptive(),
-      ],
-    );
-  }
-}
-
-class _SummaryNumber extends StatelessWidget {
-  const _SummaryNumber(this.data);
-  final String data;
-
-  @override
-  Widget build(BuildContext context) {
-    return Center(
-      child: Text(
-        data,
-        softWrap: true,
-      ),
-    );
-  }
-}
-
-class _SummaryPlayerName extends StatelessWidget {
-  const _SummaryPlayerName(this.side, this.pgnHeaders);
-  final Side side;
-  final IMap<String, String> pgnHeaders;
-
-  @override
-  Widget build(BuildContext context) {
-    final playerTitle = side == Side.white
-        ? pgnHeaders.get('WhiteTitle')
-        : pgnHeaders.get('BlackTitle');
-    final playerName = side == Side.white
-        ? pgnHeaders.get('White') ?? context.l10n.white
-        : pgnHeaders.get('Black') ?? context.l10n.black;
-
-    final brightness = Theme.of(context).brightness;
-
-    return TableCell(
-      verticalAlignment: TableCellVerticalAlignment.top,
-      child: Center(
-        child: Padding(
-          padding: const EdgeInsets.only(bottom: 5),
-          child: Column(
-            children: [
-              Icon(
-                side == Side.white
-                    ? brightness == Brightness.light
-                        ? CupertinoIcons.circle
-                        : CupertinoIcons.circle_filled
-                    : brightness == Brightness.light
-                        ? CupertinoIcons.circle_filled
-                        : CupertinoIcons.circle,
-                size: 14,
-              ),
-              Text(
-                '${playerTitle != null ? '$playerTitle ' : ''}$playerName',
-                style: const TextStyle(
-                  fontWeight: FontWeight.bold,
-                ),
-                textAlign: TextAlign.center,
-                softWrap: true,
-              ),
-            ],
-          ),
-        ),
-      ),
-    );
-  }
-}
-
-class AcplChart extends ConsumerWidget {
-  const AcplChart(this.pgn, this.options);
-
-  final String pgn;
-  final AnalysisOptions options;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final mainLineColor = Theme.of(context).colorScheme.secondary;
-    // yes it looks like below/above are inverted in fl_chart
-    final brightness = Theme.of(context).brightness;
-    final white = Theme.of(context).colorScheme.surfaceContainerHighest;
-    final black = Theme.of(context).colorScheme.outline;
-    // yes it looks like below/above are inverted in fl_chart
-    final belowLineColor = brightness == Brightness.light ? white : black;
-    final aboveLineColor = brightness == Brightness.light ? black : white;
-
-    VerticalLine phaseVerticalBar(double x, String label) => VerticalLine(
-          x: x,
-          color: const Color(0xFF707070),
-          strokeWidth: 0.5,
-          label: VerticalLineLabel(
-            style: TextStyle(
-              fontSize: 10,
-              color: Theme.of(context)
-                  .textTheme
-                  .labelMedium
-                  ?.color
-                  ?.withValues(alpha: 0.3),
-            ),
-            labelResolver: (line) => label,
-            padding: const EdgeInsets.only(right: 1),
-            alignment: Alignment.topRight,
-            direction: LabelDirection.vertical,
-            show: true,
-          ),
-        );
-
-    final data = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.acplChartData),
-    );
-
-    final rootPly = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.root.position.ply),
-    );
-
-    final currentNode = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.currentNode),
-    );
-
-    final isOnMainline = ref.watch(
-      analysisControllerProvider(pgn, options)
-          .select((value) => value.isOnMainline),
-    );
-
-    if (data == null) {
-      return const SizedBox.shrink();
-    }
-
-    final spots = data
-        .mapIndexed(
-          (i, e) => FlSpot(i.toDouble(), e.winningChances(Side.white)),
-        )
-        .toList(growable: false);
-
-    final divisionLines = <VerticalLine>[];
-
-    if (options.division?.middlegame != null) {
-      if (options.division!.middlegame! > 0) {
-        divisionLines.add(phaseVerticalBar(0.0, context.l10n.opening));
-        divisionLines.add(
-          phaseVerticalBar(
-            options.division!.middlegame! - 1,
-            context.l10n.middlegame,
-          ),
-        );
-      } else {
-        divisionLines.add(phaseVerticalBar(0.0, context.l10n.middlegame));
-      }
-    }
-
-    if (options.division?.endgame != null) {
-      if (options.division!.endgame! > 0) {
-        divisionLines.add(
-          phaseVerticalBar(
-            options.division!.endgame! - 1,
-            context.l10n.endgame,
-          ),
-        );
-      } else {
-        divisionLines.add(
-          phaseVerticalBar(
-            0.0,
-            context.l10n.endgame,
-          ),
-        );
-      }
-    }
-    return Center(
-      child: AspectRatio(
-        aspectRatio: 2.5,
-        child: Padding(
-          padding: const EdgeInsets.all(16.0),
-          child: LineChart(
-            LineChartData(
-              lineTouchData: LineTouchData(
-                enabled: false,
-                touchCallback:
-                    (FlTouchEvent event, LineTouchResponse? touchResponse) {
-                  if (event is FlTapDownEvent ||
-                      event is FlPanUpdateEvent ||
-                      event is FlLongPressMoveUpdate) {
-                    final touchX = event.localPosition!.dx;
-                    final chartWidth = context.size!.width -
-                        32; // Insets on both sides of the chart of 16
-                    final minX = spots.first.x;
-                    final maxX = spots.last.x;
-                    final touchXDataValue =
-                        minX + (touchX / chartWidth) * (maxX - minX);
-                    final closestSpot = spots.reduce(
-                      (a, b) => (a.x - touchXDataValue).abs() <
-                              (b.x - touchXDataValue).abs()
-                          ? a
-                          : b,
-                    );
-                    final closestNodeIndex = closestSpot.x.round();
-                    ref
-                        .read(analysisControllerProvider(pgn, options).notifier)
-                        .jumpToNthNodeOnMainline(closestNodeIndex);
-                  }
-                },
-              ),
-              minY: -1.0,
-              maxY: 1.0,
-              lineBarsData: [
-                LineChartBarData(
-                  spots: spots,
-                  isCurved: false,
-                  barWidth: 1,
-                  color: mainLineColor.withValues(alpha: 0.7),
-                  aboveBarData: BarAreaData(
-                    show: true,
-                    color: aboveLineColor,
-                    applyCutOffY: true,
-                  ),
-                  belowBarData: BarAreaData(
-                    show: true,
-                    color: belowLineColor,
-                    applyCutOffY: true,
-                  ),
-                  dotData: const FlDotData(
-                    show: false,
-                  ),
-                ),
-              ],
-              extraLinesData: ExtraLinesData(
-                verticalLines: [
-                  if (isOnMainline)
-                    VerticalLine(
-                      x: (currentNode.position.ply - 1 - rootPly).toDouble(),
-                      color: mainLineColor,
-                      strokeWidth: 1.0,
-                    ),
-                  ...divisionLines,
-                ],
-              ),
-              gridData: const FlGridData(show: false),
-              borderData: FlBorderData(show: false),
-              titlesData: const FlTitlesData(show: false),
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/view/analysis/server_analysis.dart b/lib/src/view/analysis/server_analysis.dart
new file mode 100644
index 0000000000..93510a1f6b
--- /dev/null
+++ b/lib/src/view/analysis/server_analysis.dart
@@ -0,0 +1,501 @@
+import 'dart:math' as math;
+
+import 'package:collection/collection.dart';
+import 'package:dartchess/dartchess.dart';
+import 'package:fast_immutable_collections/fast_immutable_collections.dart';
+import 'package:fl_chart/fl_chart.dart';
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
+import 'package:lichess_mobile/src/model/analysis/server_analysis_service.dart';
+import 'package:lichess_mobile/src/model/auth/auth_session.dart';
+import 'package:lichess_mobile/src/utils/l10n_context.dart';
+import 'package:lichess_mobile/src/utils/string.dart';
+import 'package:lichess_mobile/src/widgets/buttons.dart';
+import 'package:lichess_mobile/src/widgets/feedback.dart';
+
+class ServerAnalysisSummary extends ConsumerWidget {
+  const ServerAnalysisSummary(this.pgn, this.options);
+
+  final String pgn;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+    final playersAnalysis =
+        ref.watch(ctrlProvider.select((value) => value.playersAnalysis));
+    final pgnHeaders =
+        ref.watch(ctrlProvider.select((value) => value.pgnHeaders));
+    final currentGameAnalysis = ref.watch(currentAnalysisProvider);
+
+    return playersAnalysis != null
+        ? ListView(
+            children: [
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Padding(
+                  padding: EdgeInsets.only(top: 16.0),
+                  child: WaitingForServerAnalysis(),
+                ),
+              AcplChart(pgn, options),
+              Center(
+                child: SizedBox(
+                  width: math.min(MediaQuery.sizeOf(context).width, 500),
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
+                    child: Table(
+                      defaultVerticalAlignment:
+                          TableCellVerticalAlignment.middle,
+                      columnWidths: const {
+                        0: FlexColumnWidth(1),
+                        1: FlexColumnWidth(1),
+                        2: FlexColumnWidth(1),
+                      },
+                      children: [
+                        TableRow(
+                          decoration: const BoxDecoration(
+                            border: Border(
+                              bottom: BorderSide(color: Colors.grey),
+                            ),
+                          ),
+                          children: [
+                            _SummaryPlayerName(Side.white, pgnHeaders),
+                            Center(
+                              child: Text(
+                                pgnHeaders.get('Result') ?? '',
+                                style: const TextStyle(
+                                  fontWeight: FontWeight.bold,
+                                ),
+                              ),
+                            ),
+                            _SummaryPlayerName(Side.black, pgnHeaders),
+                          ],
+                        ),
+                        if (playersAnalysis.white.accuracy != null &&
+                            playersAnalysis.black.accuracy != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                '${playersAnalysis.white.accuracy}%',
+                              ),
+                              Center(
+                                heightFactor: 1.8,
+                                child: Text(
+                                  context.l10n.accuracy,
+                                  softWrap: true,
+                                ),
+                              ),
+                              _SummaryNumber(
+                                '${playersAnalysis.black.accuracy}%',
+                              ),
+                            ],
+                          ),
+                        for (final item in [
+                          (
+                            playersAnalysis.white.inaccuracies.toString(),
+                            context.l10n
+                                .nbInaccuracies(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.inaccuracies.toString()
+                          ),
+                          (
+                            playersAnalysis.white.mistakes.toString(),
+                            context.l10n
+                                .nbMistakes(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.mistakes.toString()
+                          ),
+                          (
+                            playersAnalysis.white.blunders.toString(),
+                            context.l10n
+                                .nbBlunders(2)
+                                .replaceAll('2', '')
+                                .trim()
+                                .capitalize(),
+                            playersAnalysis.black.blunders.toString()
+                          ),
+                        ])
+                          TableRow(
+                            children: [
+                              _SummaryNumber(item.$1),
+                              Center(
+                                heightFactor: 1.2,
+                                child: Text(
+                                  item.$2,
+                                  softWrap: true,
+                                ),
+                              ),
+                              _SummaryNumber(item.$3),
+                            ],
+                          ),
+                        if (playersAnalysis.white.acpl != null &&
+                            playersAnalysis.black.acpl != null)
+                          TableRow(
+                            children: [
+                              _SummaryNumber(
+                                playersAnalysis.white.acpl.toString(),
+                              ),
+                              Center(
+                                heightFactor: 1.5,
+                                child: Text(
+                                  context.l10n.averageCentipawnLoss,
+                                  softWrap: true,
+                                  textAlign: TextAlign.center,
+                                ),
+                              ),
+                              _SummaryNumber(
+                                playersAnalysis.black.acpl.toString(),
+                              ),
+                            ],
+                          ),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+            ],
+          )
+        : Column(
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              const Spacer(),
+              if (currentGameAnalysis == options.gameAnyId?.gameId)
+                const Center(
+                  child: Padding(
+                    padding: EdgeInsets.symmetric(vertical: 16.0),
+                    child: WaitingForServerAnalysis(),
+                  ),
+                )
+              else
+                Center(
+                  child: Padding(
+                    padding: const EdgeInsets.symmetric(vertical: 16.0),
+                    child: Builder(
+                      builder: (context) {
+                        Future<void>? pendingRequest;
+                        return StatefulBuilder(
+                          builder: (context, setState) {
+                            return FutureBuilder<void>(
+                              future: pendingRequest,
+                              builder: (context, snapshot) {
+                                return SecondaryButton(
+                                  semanticsLabel:
+                                      context.l10n.requestAComputerAnalysis,
+                                  onPressed: ref.watch(authSessionProvider) ==
+                                          null
+                                      ? () {
+                                          showPlatformSnackbar(
+                                            context,
+                                            context
+                                                .l10n.youNeedAnAccountToDoThat,
+                                          );
+                                        }
+                                      : snapshot.connectionState ==
+                                              ConnectionState.waiting
+                                          ? null
+                                          : () {
+                                              setState(() {
+                                                pendingRequest = ref
+                                                    .read(ctrlProvider.notifier)
+                                                    .requestServerAnalysis()
+                                                    .catchError((Object e) {
+                                                  if (context.mounted) {
+                                                    showPlatformSnackbar(
+                                                      context,
+                                                      e.toString(),
+                                                      type: SnackBarType.error,
+                                                    );
+                                                  }
+                                                });
+                                              });
+                                            },
+                                  child: Text(
+                                    context.l10n.requestAComputerAnalysis,
+                                  ),
+                                );
+                              },
+                            );
+                          },
+                        );
+                      },
+                    ),
+                  ),
+                ),
+              const Spacer(),
+            ],
+          );
+  }
+}
+
+class WaitingForServerAnalysis extends StatelessWidget {
+  const WaitingForServerAnalysis({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.center,
+      mainAxisSize: MainAxisSize.max,
+      children: [
+        Image.asset(
+          'assets/images/stockfish/icon.png',
+          width: 30,
+          height: 30,
+        ),
+        const SizedBox(width: 8.0),
+        Text(context.l10n.waitingForAnalysis),
+        const SizedBox(width: 8.0),
+        const CircularProgressIndicator.adaptive(),
+      ],
+    );
+  }
+}
+
+class _SummaryNumber extends StatelessWidget {
+  const _SummaryNumber(this.data);
+  final String data;
+
+  @override
+  Widget build(BuildContext context) {
+    return Center(
+      child: Text(
+        data,
+        softWrap: true,
+      ),
+    );
+  }
+}
+
+class _SummaryPlayerName extends StatelessWidget {
+  const _SummaryPlayerName(this.side, this.pgnHeaders);
+  final Side side;
+  final IMap<String, String> pgnHeaders;
+
+  @override
+  Widget build(BuildContext context) {
+    final playerTitle = side == Side.white
+        ? pgnHeaders.get('WhiteTitle')
+        : pgnHeaders.get('BlackTitle');
+    final playerName = side == Side.white
+        ? pgnHeaders.get('White') ?? context.l10n.white
+        : pgnHeaders.get('Black') ?? context.l10n.black;
+
+    final brightness = Theme.of(context).brightness;
+
+    return TableCell(
+      verticalAlignment: TableCellVerticalAlignment.top,
+      child: Center(
+        child: Padding(
+          padding: const EdgeInsets.only(bottom: 5),
+          child: Column(
+            children: [
+              Icon(
+                side == Side.white
+                    ? brightness == Brightness.light
+                        ? CupertinoIcons.circle
+                        : CupertinoIcons.circle_filled
+                    : brightness == Brightness.light
+                        ? CupertinoIcons.circle_filled
+                        : CupertinoIcons.circle,
+                size: 14,
+              ),
+              Text(
+                '${playerTitle != null ? '$playerTitle ' : ''}$playerName',
+                style: const TextStyle(
+                  fontWeight: FontWeight.bold,
+                ),
+                textAlign: TextAlign.center,
+                softWrap: true,
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class AcplChart extends ConsumerWidget {
+  const AcplChart(this.pgn, this.options);
+
+  final String pgn;
+  final AnalysisOptions options;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final mainLineColor = Theme.of(context).colorScheme.secondary;
+    // yes it looks like below/above are inverted in fl_chart
+    final brightness = Theme.of(context).brightness;
+    final white = Theme.of(context).colorScheme.surfaceContainerHighest;
+    final black = Theme.of(context).colorScheme.outline;
+    // yes it looks like below/above are inverted in fl_chart
+    final belowLineColor = brightness == Brightness.light ? white : black;
+    final aboveLineColor = brightness == Brightness.light ? black : white;
+
+    VerticalLine phaseVerticalBar(double x, String label) => VerticalLine(
+          x: x,
+          color: const Color(0xFF707070),
+          strokeWidth: 0.5,
+          label: VerticalLineLabel(
+            style: TextStyle(
+              fontSize: 10,
+              color: Theme.of(context)
+                  .textTheme
+                  .labelMedium
+                  ?.color
+                  ?.withValues(alpha: 0.3),
+            ),
+            labelResolver: (line) => label,
+            padding: const EdgeInsets.only(right: 1),
+            alignment: Alignment.topRight,
+            direction: LabelDirection.vertical,
+            show: true,
+          ),
+        );
+
+    final data = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.acplChartData),
+    );
+
+    final rootPly = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.root.position.ply),
+    );
+
+    final currentNode = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.currentNode),
+    );
+
+    final isOnMainline = ref.watch(
+      analysisControllerProvider(pgn, options)
+          .select((value) => value.isOnMainline),
+    );
+
+    if (data == null) {
+      return const SizedBox.shrink();
+    }
+
+    final spots = data
+        .mapIndexed(
+          (i, e) => FlSpot(i.toDouble(), e.winningChances(Side.white)),
+        )
+        .toList(growable: false);
+
+    final divisionLines = <VerticalLine>[];
+
+    if (options.division?.middlegame != null) {
+      if (options.division!.middlegame! > 0) {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.opening));
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.middlegame! - 1,
+            context.l10n.middlegame,
+          ),
+        );
+      } else {
+        divisionLines.add(phaseVerticalBar(0.0, context.l10n.middlegame));
+      }
+    }
+
+    if (options.division?.endgame != null) {
+      if (options.division!.endgame! > 0) {
+        divisionLines.add(
+          phaseVerticalBar(
+            options.division!.endgame! - 1,
+            context.l10n.endgame,
+          ),
+        );
+      } else {
+        divisionLines.add(
+          phaseVerticalBar(
+            0.0,
+            context.l10n.endgame,
+          ),
+        );
+      }
+    }
+    return Center(
+      child: AspectRatio(
+        aspectRatio: 2.5,
+        child: Padding(
+          padding: const EdgeInsets.all(16.0),
+          child: LineChart(
+            LineChartData(
+              lineTouchData: LineTouchData(
+                enabled: false,
+                touchCallback:
+                    (FlTouchEvent event, LineTouchResponse? touchResponse) {
+                  if (event is FlTapDownEvent ||
+                      event is FlPanUpdateEvent ||
+                      event is FlLongPressMoveUpdate) {
+                    final touchX = event.localPosition!.dx;
+                    final chartWidth = context.size!.width -
+                        32; // Insets on both sides of the chart of 16
+                    final minX = spots.first.x;
+                    final maxX = spots.last.x;
+                    final touchXDataValue =
+                        minX + (touchX / chartWidth) * (maxX - minX);
+                    final closestSpot = spots.reduce(
+                      (a, b) => (a.x - touchXDataValue).abs() <
+                              (b.x - touchXDataValue).abs()
+                          ? a
+                          : b,
+                    );
+                    final closestNodeIndex = closestSpot.x.round();
+                    ref
+                        .read(analysisControllerProvider(pgn, options).notifier)
+                        .jumpToNthNodeOnMainline(closestNodeIndex);
+                  }
+                },
+              ),
+              minY: -1.0,
+              maxY: 1.0,
+              lineBarsData: [
+                LineChartBarData(
+                  spots: spots,
+                  isCurved: false,
+                  barWidth: 1,
+                  color: mainLineColor.withValues(alpha: 0.7),
+                  aboveBarData: BarAreaData(
+                    show: true,
+                    color: aboveLineColor,
+                    applyCutOffY: true,
+                  ),
+                  belowBarData: BarAreaData(
+                    show: true,
+                    color: belowLineColor,
+                    applyCutOffY: true,
+                  ),
+                  dotData: const FlDotData(
+                    show: false,
+                  ),
+                ),
+              ],
+              extraLinesData: ExtraLinesData(
+                verticalLines: [
+                  if (isOnMainline)
+                    VerticalLine(
+                      x: (currentNode.position.ply - 1 - rootPly).toDouble(),
+                      color: mainLineColor,
+                      strokeWidth: 1.0,
+                    ),
+                  ...divisionLines,
+                ],
+              ),
+              gridData: const FlGridData(show: false),
+              borderData: FlBorderData(show: false),
+              titlesData: const FlTitlesData(show: false),
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/view/engine/engine_depth.dart b/lib/src/view/engine/engine_depth.dart
new file mode 100644
index 0000000000..d3352d676d
--- /dev/null
+++ b/lib/src/view/engine/engine_depth.dart
@@ -0,0 +1,117 @@
+import 'dart:math' as math;
+
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:lichess_mobile/src/model/common/eval.dart';
+import 'package:lichess_mobile/src/model/engine/engine.dart';
+import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
+import 'package:lichess_mobile/src/utils/l10n_context.dart';
+import 'package:lichess_mobile/src/widgets/buttons.dart';
+import 'package:lichess_mobile/src/widgets/list.dart';
+import 'package:popover/popover.dart';
+
+class EngineDepth extends ConsumerWidget {
+  const EngineDepth({this.defaultEval});
+
+  final ClientEval? defaultEval;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final depth = ref.watch(
+          engineEvaluationProvider.select((value) => value.eval?.depth),
+        ) ??
+        defaultEval?.depth;
+
+    return depth != null
+        ? AppBarTextButton(
+            onPressed: () {
+              showPopover(
+                context: context,
+                bodyBuilder: (context) {
+                  return _StockfishInfo(defaultEval);
+                },
+                direction: PopoverDirection.top,
+                width: 240,
+                backgroundColor:
+                    Theme.of(context).platform == TargetPlatform.android
+                        ? Theme.of(context).dialogBackgroundColor
+                        : CupertinoDynamicColor.resolve(
+                            CupertinoColors.tertiarySystemBackground,
+                            context,
+                          ),
+                transitionDuration: Duration.zero,
+                popoverTransitionBuilder: (_, child) => child,
+              );
+            },
+            child: RepaintBoundary(
+              child: Container(
+                width: 20.0,
+                height: 20.0,
+                padding: const EdgeInsets.all(2.0),
+                decoration: BoxDecoration(
+                  color: Theme.of(context).platform == TargetPlatform.android
+                      ? Theme.of(context).colorScheme.secondary
+                      : CupertinoTheme.of(context).primaryColor,
+                  borderRadius: BorderRadius.circular(4.0),
+                ),
+                child: FittedBox(
+                  fit: BoxFit.contain,
+                  child: Text(
+                    '${math.min(99, depth)}',
+                    style: TextStyle(
+                      color: Theme.of(context).platform ==
+                              TargetPlatform.android
+                          ? Theme.of(context).colorScheme.onSecondary
+                          : CupertinoTheme.of(context).primaryContrastingColor,
+                      fontFeatures: const [
+                        FontFeature.tabularFigures(),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+            ),
+          )
+        : const SizedBox.shrink();
+  }
+}
+
+class _StockfishInfo extends ConsumerWidget {
+  const _StockfishInfo(this.defaultEval);
+
+  final ClientEval? defaultEval;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final (engineName: engineName, eval: eval, state: engineState) =
+        ref.watch(engineEvaluationProvider);
+
+    final currentEval = eval ?? defaultEval;
+
+    final knps = engineState == EngineState.computing
+        ? ', ${eval?.knps.round()}kn/s'
+        : '';
+    final depth = currentEval?.depth ?? 0;
+    final maxDepth = math.max(depth, kMaxEngineDepth);
+
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      children: [
+        PlatformListTile(
+          leading: Image.asset(
+            'assets/images/stockfish/icon.png',
+            width: 44,
+            height: 44,
+          ),
+          title: Text(engineName),
+          subtitle: Text(
+            context.l10n.depthX(
+              '$depth/$maxDepth$knps',
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+}
diff --git a/lib/src/view/opening_explorer/opening_explorer_screen.dart b/lib/src/view/opening_explorer/opening_explorer_screen.dart
index 0e2d1dbc29..341afecb60 100644
--- a/lib/src/view/opening_explorer/opening_explorer_screen.dart
+++ b/lib/src/view/opening_explorer/opening_explorer_screen.dart
@@ -1,10 +1,7 @@
 import 'package:collection/collection.dart';
-import 'package:dartchess/dartchess.dart';
-import 'package:fast_immutable_collections/fast_immutable_collections.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:intl/intl.dart';
 import 'package:lichess_mobile/src/constants.dart';
 import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
 import 'package:lichess_mobile/src/model/common/chess.dart';
@@ -13,10 +10,9 @@ import 'package:lichess_mobile/src/model/opening_explorer/opening_explorer_prefe
 import 'package:lichess_mobile/src/model/opening_explorer/opening_explorer_repository.dart';
 import 'package:lichess_mobile/src/styles/styles.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
-import 'package:lichess_mobile/src/utils/navigation.dart';
 import 'package:lichess_mobile/src/utils/screen.dart';
 import 'package:lichess_mobile/src/view/analysis/analysis_board.dart';
-import 'package:lichess_mobile/src/view/game/archived_game_screen.dart';
+import 'package:lichess_mobile/src/view/opening_explorer/opening_explorer_widgets.dart';
 import 'package:lichess_mobile/src/widgets/adaptive_bottom_sheet.dart';
 import 'package:lichess_mobile/src/widgets/bottom_bar.dart';
 import 'package:lichess_mobile/src/widgets/bottom_bar_button.dart';
@@ -36,16 +32,6 @@ const _kTableRowPadding = EdgeInsets.symmetric(
 );
 const _kTabletBoardRadius = BorderRadius.all(Radius.circular(4.0));
 
-Color _whiteBoxColor(BuildContext context) =>
-    Theme.of(context).brightness == Brightness.dark
-        ? Colors.white.withValues(alpha: 0.8)
-        : Colors.white;
-
-Color _blackBoxColor(BuildContext context) =>
-    Theme.of(context).brightness == Brightness.light
-        ? Colors.black.withValues(alpha: 0.7)
-        : Colors.black;
-
 class OpeningExplorerScreen extends ConsumerStatefulWidget {
   const OpeningExplorerScreen({required this.pgn, required this.options});
 
@@ -122,7 +108,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
         isIndexing: false,
         children: [
           openingHeader,
-          _OpeningExplorerMoveTable.maxDepth(
+          OpeningExplorerMoveTable.maxDepth(
             pgn: widget.pgn,
             options: widget.options,
           ),
@@ -189,7 +175,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
                   Shimmer(
                     child: ShimmerLoading(
                       isLoading: true,
-                      child: _OpeningExplorerMoveTable.loading(
+                      child: OpeningExplorerMoveTable.loading(
                         pgn: widget.pgn,
                         options: widget.options,
                       ),
@@ -205,7 +191,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
 
           final children = [
             openingHeader,
-            _OpeningExplorerMoveTable(
+            OpeningExplorerMoveTable(
               moves: openingExplorer.entry.moves,
               whiteWins: openingExplorer.entry.white,
               draws: openingExplorer.entry.draws,
@@ -214,7 +200,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
               options: widget.options,
             ),
             if (topGames != null && topGames.isNotEmpty) ...[
-              _OpeningExplorerHeader(
+              OpeningExplorerHeaderTile(
                 key: const Key('topGamesHeader'),
                 child: Text(context.l10n.topGames),
               ),
@@ -234,7 +220,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
               ),
             ],
             if (recentGames != null && recentGames.isNotEmpty) ...[
-              _OpeningExplorerHeader(
+              OpeningExplorerHeaderTile(
                 key: const Key('recentGamesHeader'),
                 child: Text(context.l10n.recentGames),
               ),
@@ -265,7 +251,7 @@ class _OpeningExplorerState extends ConsumerState<OpeningExplorerScreen> {
               Shimmer(
                 child: ShimmerLoading(
                   isLoading: true,
-                  child: _OpeningExplorerMoveTable.loading(
+                  child: OpeningExplorerMoveTable.loading(
                     pgn: widget.pgn,
                     options: widget.options,
                   ),
@@ -338,15 +324,7 @@ class _OpeningExplorerView extends StatelessWidget {
                 final isLandscape = aspectRatio > 1;
 
                 final loadingOverlay = Positioned.fill(
-                  child: IgnorePointer(
-                    ignoring: !isLoading,
-                    child: AnimatedOpacity(
-                      duration: const Duration(milliseconds: 300),
-                      curve: Curves.fastOutSlowIn,
-                      opacity: isLoading ? 0.10 : 0.0,
-                      child: const ColoredBox(color: Colors.black),
-                    ),
-                  ),
+                  child: IgnorePointer(ignoring: !isLoading),
                 );
 
                 if (isLandscape) {
@@ -501,482 +479,6 @@ class _IndexingIndicatorState extends State<_IndexingIndicator>
   }
 }
 
-/// Table of moves for the opening explorer.
-class _OpeningExplorerMoveTable extends ConsumerWidget {
-  const _OpeningExplorerMoveTable({
-    required this.moves,
-    required this.whiteWins,
-    required this.draws,
-    required this.blackWins,
-    required this.pgn,
-    required this.options,
-  })  : _isLoading = false,
-        _maxDepthReached = false;
-
-  const _OpeningExplorerMoveTable.loading({
-    required this.pgn,
-    required this.options,
-  })  : _isLoading = true,
-        moves = const IListConst([]),
-        whiteWins = 0,
-        draws = 0,
-        blackWins = 0,
-        _maxDepthReached = false;
-
-  const _OpeningExplorerMoveTable.maxDepth({
-    required this.pgn,
-    required this.options,
-  })  : _isLoading = false,
-        moves = const IListConst([]),
-        whiteWins = 0,
-        draws = 0,
-        blackWins = 0,
-        _maxDepthReached = true;
-
-  final IList<OpeningMove> moves;
-  final int whiteWins;
-  final int draws;
-  final int blackWins;
-  final String pgn;
-  final AnalysisOptions options;
-
-  final bool _isLoading;
-  final bool _maxDepthReached;
-
-  String formatNum(int num) => NumberFormat.decimalPatternDigits().format(num);
-
-  static const columnWidths = {
-    0: FractionColumnWidth(0.15),
-    1: FractionColumnWidth(0.35),
-    2: FractionColumnWidth(0.50),
-  };
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    if (_isLoading) {
-      return loadingTable;
-    }
-
-    final games = whiteWins + draws + blackWins;
-    final ctrlProvider = analysisControllerProvider(pgn, options);
-
-    const topPadding = EdgeInsets.only(top: _kTableRowVerticalPadding / 2);
-    const headerTextStyle = TextStyle(fontSize: 12);
-
-    return Table(
-      columnWidths: columnWidths,
-      children: [
-        TableRow(
-          decoration: BoxDecoration(
-            color: Theme.of(context).colorScheme.secondaryContainer,
-          ),
-          children: [
-            Padding(
-              padding: _kTableRowPadding.subtract(topPadding),
-              child: Text(context.l10n.move, style: headerTextStyle),
-            ),
-            Padding(
-              padding: _kTableRowPadding.subtract(topPadding),
-              child: Text(context.l10n.games, style: headerTextStyle),
-            ),
-            Padding(
-              padding: _kTableRowPadding.subtract(topPadding),
-              child: Text(context.l10n.whiteDrawBlack, style: headerTextStyle),
-            ),
-          ],
-        ),
-        ...List.generate(
-          moves.length,
-          (int index) {
-            final move = moves.get(index);
-            final percentGames = ((move.games / games) * 100).round();
-            return TableRow(
-              decoration: BoxDecoration(
-                color: index.isEven
-                    ? Theme.of(context).colorScheme.surfaceContainerLow
-                    : Theme.of(context).colorScheme.surfaceContainerHigh,
-              ),
-              children: [
-                TableRowInkWell(
-                  onTap: () => ref
-                      .read(ctrlProvider.notifier)
-                      .onUserMove(NormalMove.fromUci(move.uci)),
-                  child: Padding(
-                    padding: _kTableRowPadding,
-                    child: Text(move.san),
-                  ),
-                ),
-                TableRowInkWell(
-                  onTap: () => ref
-                      .read(ctrlProvider.notifier)
-                      .onUserMove(NormalMove.fromUci(move.uci)),
-                  child: Padding(
-                    padding: _kTableRowPadding,
-                    child: Text('${formatNum(move.games)} ($percentGames%)'),
-                  ),
-                ),
-                TableRowInkWell(
-                  onTap: () => ref
-                      .read(ctrlProvider.notifier)
-                      .onUserMove(NormalMove.fromUci(move.uci)),
-                  child: Padding(
-                    padding: _kTableRowPadding,
-                    child: _WinPercentageChart(
-                      whiteWins: move.white,
-                      draws: move.draws,
-                      blackWins: move.black,
-                    ),
-                  ),
-                ),
-              ],
-            );
-          },
-        ),
-        if (_maxDepthReached)
-          TableRow(
-            decoration: BoxDecoration(
-              color: Theme.of(context).colorScheme.surfaceContainerLow,
-            ),
-            children: [
-              Padding(
-                padding: _kTableRowPadding,
-                child: Text(
-                  String.fromCharCode(Icons.not_interested_outlined.codePoint),
-                  style: TextStyle(
-                    fontFamily: Icons.not_interested_outlined.fontFamily,
-                  ),
-                ),
-              ),
-              Padding(
-                padding: _kTableRowPadding,
-                child: Text(context.l10n.maxDepthReached),
-              ),
-              const Padding(
-                padding: _kTableRowPadding,
-                child: SizedBox.shrink(),
-              ),
-            ],
-          )
-        else if (moves.isNotEmpty)
-          TableRow(
-            decoration: BoxDecoration(
-              color: moves.length.isEven
-                  ? Theme.of(context).colorScheme.surfaceContainerLow
-                  : Theme.of(context).colorScheme.surfaceContainerHigh,
-            ),
-            children: [
-              Container(
-                padding: _kTableRowPadding,
-                alignment: Alignment.centerLeft,
-                child: const Icon(Icons.functions),
-              ),
-              Padding(
-                padding: _kTableRowPadding,
-                child: Text('${formatNum(games)} (100%)'),
-              ),
-              Padding(
-                padding: _kTableRowPadding,
-                child: _WinPercentageChart(
-                  whiteWins: whiteWins,
-                  draws: draws,
-                  blackWins: blackWins,
-                ),
-              ),
-            ],
-          )
-        else
-          TableRow(
-            decoration: BoxDecoration(
-              color: Theme.of(context).colorScheme.surfaceContainerLow,
-            ),
-            children: [
-              Padding(
-                padding: _kTableRowPadding,
-                child: Text(
-                  String.fromCharCode(Icons.not_interested_outlined.codePoint),
-                  style: TextStyle(
-                    fontFamily: Icons.not_interested_outlined.fontFamily,
-                  ),
-                ),
-              ),
-              Padding(
-                padding: _kTableRowPadding,
-                child: Text(context.l10n.noGameFound),
-              ),
-              const Padding(
-                padding: _kTableRowPadding,
-                child: SizedBox.shrink(),
-              ),
-            ],
-          ),
-      ],
-    );
-  }
-
-  static final loadingTable = Table(
-    columnWidths: columnWidths,
-    children: List.generate(
-      10,
-      (int index) => TableRow(
-        children: [
-          Padding(
-            padding: _kTableRowPadding,
-            child: Container(
-              height: 20,
-              width: double.infinity,
-              decoration: BoxDecoration(
-                color: Colors.black,
-                borderRadius: BorderRadius.circular(5),
-              ),
-            ),
-          ),
-          Padding(
-            padding: _kTableRowPadding,
-            child: Container(
-              height: 20,
-              width: double.infinity,
-              decoration: BoxDecoration(
-                color: Colors.black,
-                borderRadius: BorderRadius.circular(5),
-              ),
-            ),
-          ),
-          Padding(
-            padding: _kTableRowPadding,
-            child: Container(
-              height: 20,
-              width: double.infinity,
-              decoration: BoxDecoration(
-                color: Colors.black,
-                borderRadius: BorderRadius.circular(5),
-              ),
-            ),
-          ),
-        ],
-      ),
-    ),
-  );
-}
-
-/// A game tile for the opening explorer.
-class OpeningExplorerGameTile extends ConsumerStatefulWidget {
-  const OpeningExplorerGameTile({
-    required this.game,
-    required this.color,
-    required this.ply,
-    super.key,
-  });
-
-  final OpeningExplorerGame game;
-  final Color color;
-  final int ply;
-
-  @override
-  ConsumerState<OpeningExplorerGameTile> createState() =>
-      _OpeningExplorerGameTileState();
-}
-
-class _OpeningExplorerGameTileState
-    extends ConsumerState<OpeningExplorerGameTile> {
-  @override
-  Widget build(BuildContext context) {
-    const widthResultBox = 50.0;
-    const paddingResultBox = EdgeInsets.all(5);
-
-    return Container(
-      padding: _kTableRowPadding,
-      color: widget.color,
-      child: AdaptiveInkWell(
-        onTap: () {
-          pushPlatformRoute(
-            context,
-            builder: (_) => ArchivedGameScreen(
-              gameId: widget.game.id,
-              orientation: Side.white,
-              initialCursor: widget.ply,
-            ),
-          );
-        },
-        child: Row(
-          mainAxisAlignment: MainAxisAlignment.start,
-          children: [
-            Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Text(widget.game.white.rating.toString()),
-                Text(widget.game.black.rating.toString()),
-              ],
-            ),
-            const SizedBox(width: 10),
-            Expanded(
-              child: Column(
-                crossAxisAlignment: CrossAxisAlignment.start,
-                children: [
-                  Text(
-                    widget.game.white.name,
-                    overflow: TextOverflow.ellipsis,
-                  ),
-                  Text(
-                    widget.game.black.name,
-                    overflow: TextOverflow.ellipsis,
-                  ),
-                ],
-              ),
-            ),
-            Row(
-              children: [
-                if (widget.game.winner == 'white')
-                  Container(
-                    width: widthResultBox,
-                    padding: paddingResultBox,
-                    decoration: BoxDecoration(
-                      color: _whiteBoxColor(context),
-                      borderRadius: BorderRadius.circular(5),
-                    ),
-                    child: const Text(
-                      '1-0',
-                      textAlign: TextAlign.center,
-                      style: TextStyle(
-                        color: Colors.black,
-                      ),
-                    ),
-                  )
-                else if (widget.game.winner == 'black')
-                  Container(
-                    width: widthResultBox,
-                    padding: paddingResultBox,
-                    decoration: BoxDecoration(
-                      color: _blackBoxColor(context),
-                      borderRadius: BorderRadius.circular(5),
-                    ),
-                    child: const Text(
-                      '0-1',
-                      textAlign: TextAlign.center,
-                      style: TextStyle(
-                        color: Colors.white,
-                      ),
-                    ),
-                  )
-                else
-                  Container(
-                    width: widthResultBox,
-                    padding: paddingResultBox,
-                    decoration: BoxDecoration(
-                      color: Colors.grey,
-                      borderRadius: BorderRadius.circular(5),
-                    ),
-                    child: const Text(
-                      '-',
-                      textAlign: TextAlign.center,
-                      style: TextStyle(
-                        color: Colors.white,
-                      ),
-                    ),
-                  ),
-                if (widget.game.month != null) ...[
-                  const SizedBox(width: 10.0),
-                  Text(
-                    widget.game.month!,
-                    style: const TextStyle(
-                      fontFeatures: [FontFeature.tabularFigures()],
-                    ),
-                  ),
-                ],
-                if (widget.game.speed != null) ...[
-                  const SizedBox(width: 10.0),
-                  Icon(widget.game.speed!.icon, size: 20),
-                ],
-              ],
-            ),
-          ],
-        ),
-      ),
-    );
-  }
-}
-
-class _OpeningExplorerHeader extends StatelessWidget {
-  const _OpeningExplorerHeader({required this.child, super.key});
-
-  final Widget child;
-
-  @override
-  Widget build(BuildContext context) {
-    return Container(
-      width: double.infinity,
-      padding: _kTableRowPadding,
-      decoration: BoxDecoration(
-        color: Theme.of(context).colorScheme.secondaryContainer,
-      ),
-      child: child,
-    );
-  }
-}
-
-class _WinPercentageChart extends StatelessWidget {
-  const _WinPercentageChart({
-    required this.whiteWins,
-    required this.draws,
-    required this.blackWins,
-  });
-
-  final int whiteWins;
-  final int draws;
-  final int blackWins;
-
-  int percentGames(int games) =>
-      ((games / (whiteWins + draws + blackWins)) * 100).round();
-  String label(int percent) => percent < 20 ? '' : '$percent%';
-
-  @override
-  Widget build(BuildContext context) {
-    final percentWhite = percentGames(whiteWins);
-    final percentDraws = percentGames(draws);
-    final percentBlack = percentGames(blackWins);
-
-    return ClipRRect(
-      borderRadius: BorderRadius.circular(5),
-      child: Row(
-        children: [
-          Expanded(
-            flex: percentWhite,
-            child: ColoredBox(
-              color: _whiteBoxColor(context),
-              child: Text(
-                label(percentWhite),
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.black),
-              ),
-            ),
-          ),
-          Expanded(
-            flex: percentDraws,
-            child: ColoredBox(
-              color: Colors.grey,
-              child: Text(
-                label(percentDraws),
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.white),
-              ),
-            ),
-          ),
-          Expanded(
-            flex: percentBlack,
-            child: ColoredBox(
-              color: _blackBoxColor(context),
-              child: Text(
-                label(percentBlack),
-                textAlign: TextAlign.center,
-                style: const TextStyle(color: Colors.white),
-              ),
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-}
-
 class _MoveList extends ConsumerWidget implements PreferredSizeWidget {
   const _MoveList({
     required this.pgn,
diff --git a/lib/src/view/opening_explorer/opening_explorer_widgets.dart b/lib/src/view/opening_explorer/opening_explorer_widgets.dart
new file mode 100644
index 0000000000..f0374e07ab
--- /dev/null
+++ b/lib/src/view/opening_explorer/opening_explorer_widgets.dart
@@ -0,0 +1,504 @@
+import 'package:dartchess/dartchess.dart';
+import 'package:fast_immutable_collections/fast_immutable_collections.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:intl/intl.dart';
+import 'package:lichess_mobile/src/model/analysis/analysis_controller.dart';
+import 'package:lichess_mobile/src/model/opening_explorer/opening_explorer.dart';
+import 'package:lichess_mobile/src/utils/l10n_context.dart';
+import 'package:lichess_mobile/src/utils/navigation.dart';
+import 'package:lichess_mobile/src/view/game/archived_game_screen.dart';
+import 'package:lichess_mobile/src/widgets/buttons.dart';
+
+const _kTableRowVerticalPadding = 12.0;
+const _kTableRowHorizontalPadding = 8.0;
+const _kTableRowPadding = EdgeInsets.symmetric(
+  horizontal: _kTableRowHorizontalPadding,
+  vertical: _kTableRowVerticalPadding,
+);
+
+Color _whiteBoxColor(BuildContext context) =>
+    Theme.of(context).brightness == Brightness.dark
+        ? Colors.white.withValues(alpha: 0.8)
+        : Colors.white;
+
+Color _blackBoxColor(BuildContext context) =>
+    Theme.of(context).brightness == Brightness.light
+        ? Colors.black.withValues(alpha: 0.7)
+        : Colors.black;
+
+/// Table of moves for the opening explorer.
+class OpeningExplorerMoveTable extends ConsumerWidget {
+  const OpeningExplorerMoveTable({
+    required this.moves,
+    required this.whiteWins,
+    required this.draws,
+    required this.blackWins,
+    required this.pgn,
+    required this.options,
+  })  : _isLoading = false,
+        _maxDepthReached = false;
+
+  const OpeningExplorerMoveTable.loading({
+    required this.pgn,
+    required this.options,
+  })  : _isLoading = true,
+        moves = const IListConst([]),
+        whiteWins = 0,
+        draws = 0,
+        blackWins = 0,
+        _maxDepthReached = false;
+
+  const OpeningExplorerMoveTable.maxDepth({
+    required this.pgn,
+    required this.options,
+  })  : _isLoading = false,
+        moves = const IListConst([]),
+        whiteWins = 0,
+        draws = 0,
+        blackWins = 0,
+        _maxDepthReached = true;
+
+  final IList<OpeningMove> moves;
+  final int whiteWins;
+  final int draws;
+  final int blackWins;
+  final String pgn;
+  final AnalysisOptions options;
+
+  final bool _isLoading;
+  final bool _maxDepthReached;
+
+  String formatNum(int num) => NumberFormat.decimalPatternDigits().format(num);
+
+  static const columnWidths = {
+    0: FractionColumnWidth(0.15),
+    1: FractionColumnWidth(0.35),
+    2: FractionColumnWidth(0.50),
+  };
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    if (_isLoading) {
+      return loadingTable;
+    }
+
+    final games = whiteWins + draws + blackWins;
+    final ctrlProvider = analysisControllerProvider(pgn, options);
+
+    const topPadding = EdgeInsets.only(top: _kTableRowVerticalPadding / 2);
+    const headerTextStyle = TextStyle(fontSize: 12);
+
+    return Table(
+      columnWidths: columnWidths,
+      children: [
+        TableRow(
+          decoration: BoxDecoration(
+            color: Theme.of(context).colorScheme.secondaryContainer,
+          ),
+          children: [
+            Padding(
+              padding: _kTableRowPadding.subtract(topPadding),
+              child: Text(context.l10n.move, style: headerTextStyle),
+            ),
+            Padding(
+              padding: _kTableRowPadding.subtract(topPadding),
+              child: Text(context.l10n.games, style: headerTextStyle),
+            ),
+            Padding(
+              padding: _kTableRowPadding.subtract(topPadding),
+              child: Text(context.l10n.whiteDrawBlack, style: headerTextStyle),
+            ),
+          ],
+        ),
+        ...List.generate(
+          moves.length,
+          (int index) {
+            final move = moves.get(index);
+            final percentGames = ((move.games / games) * 100).round();
+            return TableRow(
+              decoration: BoxDecoration(
+                color: index.isEven
+                    ? Theme.of(context).colorScheme.surfaceContainerLow
+                    : Theme.of(context).colorScheme.surfaceContainerHigh,
+              ),
+              children: [
+                TableRowInkWell(
+                  onTap: () => ref
+                      .read(ctrlProvider.notifier)
+                      .onUserMove(NormalMove.fromUci(move.uci)),
+                  child: Padding(
+                    padding: _kTableRowPadding,
+                    child: Text(move.san),
+                  ),
+                ),
+                TableRowInkWell(
+                  onTap: () => ref
+                      .read(ctrlProvider.notifier)
+                      .onUserMove(NormalMove.fromUci(move.uci)),
+                  child: Padding(
+                    padding: _kTableRowPadding,
+                    child: Text('${formatNum(move.games)} ($percentGames%)'),
+                  ),
+                ),
+                TableRowInkWell(
+                  onTap: () => ref
+                      .read(ctrlProvider.notifier)
+                      .onUserMove(NormalMove.fromUci(move.uci)),
+                  child: Padding(
+                    padding: _kTableRowPadding,
+                    child: _WinPercentageChart(
+                      whiteWins: move.white,
+                      draws: move.draws,
+                      blackWins: move.black,
+                    ),
+                  ),
+                ),
+              ],
+            );
+          },
+        ),
+        if (_maxDepthReached)
+          TableRow(
+            decoration: BoxDecoration(
+              color: Theme.of(context).colorScheme.surfaceContainerLow,
+            ),
+            children: [
+              Padding(
+                padding: _kTableRowPadding,
+                child: Text(
+                  String.fromCharCode(Icons.not_interested_outlined.codePoint),
+                  style: TextStyle(
+                    fontFamily: Icons.not_interested_outlined.fontFamily,
+                  ),
+                ),
+              ),
+              Padding(
+                padding: _kTableRowPadding,
+                child: Text(context.l10n.maxDepthReached),
+              ),
+              const Padding(
+                padding: _kTableRowPadding,
+                child: SizedBox.shrink(),
+              ),
+            ],
+          )
+        else if (moves.isNotEmpty)
+          TableRow(
+            decoration: BoxDecoration(
+              color: moves.length.isEven
+                  ? Theme.of(context).colorScheme.surfaceContainerLow
+                  : Theme.of(context).colorScheme.surfaceContainerHigh,
+            ),
+            children: [
+              Container(
+                padding: _kTableRowPadding,
+                alignment: Alignment.centerLeft,
+                child: const Icon(Icons.functions),
+              ),
+              Padding(
+                padding: _kTableRowPadding,
+                child: Text('${formatNum(games)} (100%)'),
+              ),
+              Padding(
+                padding: _kTableRowPadding,
+                child: _WinPercentageChart(
+                  whiteWins: whiteWins,
+                  draws: draws,
+                  blackWins: blackWins,
+                ),
+              ),
+            ],
+          )
+        else
+          TableRow(
+            decoration: BoxDecoration(
+              color: Theme.of(context).colorScheme.surfaceContainerLow,
+            ),
+            children: [
+              Padding(
+                padding: _kTableRowPadding,
+                child: Text(
+                  String.fromCharCode(Icons.not_interested_outlined.codePoint),
+                  style: TextStyle(
+                    fontFamily: Icons.not_interested_outlined.fontFamily,
+                  ),
+                ),
+              ),
+              Padding(
+                padding: _kTableRowPadding,
+                child: Text(context.l10n.noGameFound),
+              ),
+              const Padding(
+                padding: _kTableRowPadding,
+                child: SizedBox.shrink(),
+              ),
+            ],
+          ),
+      ],
+    );
+  }
+
+  static final loadingTable = Table(
+    columnWidths: columnWidths,
+    children: List.generate(
+      10,
+      (int index) => TableRow(
+        children: [
+          Padding(
+            padding: _kTableRowPadding,
+            child: Container(
+              height: 20,
+              width: double.infinity,
+              decoration: BoxDecoration(
+                color: Colors.black,
+                borderRadius: BorderRadius.circular(5),
+              ),
+            ),
+          ),
+          Padding(
+            padding: _kTableRowPadding,
+            child: Container(
+              height: 20,
+              width: double.infinity,
+              decoration: BoxDecoration(
+                color: Colors.black,
+                borderRadius: BorderRadius.circular(5),
+              ),
+            ),
+          ),
+          Padding(
+            padding: _kTableRowPadding,
+            child: Container(
+              height: 20,
+              width: double.infinity,
+              decoration: BoxDecoration(
+                color: Colors.black,
+                borderRadius: BorderRadius.circular(5),
+              ),
+            ),
+          ),
+        ],
+      ),
+    ),
+  );
+}
+
+class OpeningExplorerHeaderTile extends StatelessWidget {
+  const OpeningExplorerHeaderTile({required this.child, super.key});
+
+  final Widget child;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      width: double.infinity,
+      padding: _kTableRowPadding,
+      decoration: BoxDecoration(
+        color: Theme.of(context).colorScheme.secondaryContainer,
+      ),
+      child: child,
+    );
+  }
+}
+
+/// A game tile for the opening explorer.
+class OpeningExplorerGameTile extends ConsumerStatefulWidget {
+  const OpeningExplorerGameTile({
+    required this.game,
+    required this.color,
+    required this.ply,
+    super.key,
+  });
+
+  final OpeningExplorerGame game;
+  final Color color;
+  final int ply;
+
+  @override
+  ConsumerState<OpeningExplorerGameTile> createState() =>
+      _OpeningExplorerGameTileState();
+}
+
+class _OpeningExplorerGameTileState
+    extends ConsumerState<OpeningExplorerGameTile> {
+  @override
+  Widget build(BuildContext context) {
+    const widthResultBox = 50.0;
+    const paddingResultBox = EdgeInsets.all(5);
+
+    return Container(
+      padding: _kTableRowPadding,
+      color: widget.color,
+      child: AdaptiveInkWell(
+        onTap: () {
+          pushPlatformRoute(
+            context,
+            builder: (_) => ArchivedGameScreen(
+              gameId: widget.game.id,
+              orientation: Side.white,
+              initialCursor: widget.ply,
+            ),
+          );
+        },
+        child: Row(
+          mainAxisAlignment: MainAxisAlignment.start,
+          children: [
+            Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                Text(widget.game.white.rating.toString()),
+                Text(widget.game.black.rating.toString()),
+              ],
+            ),
+            const SizedBox(width: 10),
+            Expanded(
+              child: Column(
+                crossAxisAlignment: CrossAxisAlignment.start,
+                children: [
+                  Text(
+                    widget.game.white.name,
+                    overflow: TextOverflow.ellipsis,
+                  ),
+                  Text(
+                    widget.game.black.name,
+                    overflow: TextOverflow.ellipsis,
+                  ),
+                ],
+              ),
+            ),
+            Row(
+              children: [
+                if (widget.game.winner == 'white')
+                  Container(
+                    width: widthResultBox,
+                    padding: paddingResultBox,
+                    decoration: BoxDecoration(
+                      color: _whiteBoxColor(context),
+                      borderRadius: BorderRadius.circular(5),
+                    ),
+                    child: const Text(
+                      '1-0',
+                      textAlign: TextAlign.center,
+                      style: TextStyle(
+                        color: Colors.black,
+                      ),
+                    ),
+                  )
+                else if (widget.game.winner == 'black')
+                  Container(
+                    width: widthResultBox,
+                    padding: paddingResultBox,
+                    decoration: BoxDecoration(
+                      color: _blackBoxColor(context),
+                      borderRadius: BorderRadius.circular(5),
+                    ),
+                    child: const Text(
+                      '0-1',
+                      textAlign: TextAlign.center,
+                      style: TextStyle(
+                        color: Colors.white,
+                      ),
+                    ),
+                  )
+                else
+                  Container(
+                    width: widthResultBox,
+                    padding: paddingResultBox,
+                    decoration: BoxDecoration(
+                      color: Colors.grey,
+                      borderRadius: BorderRadius.circular(5),
+                    ),
+                    child: const Text(
+                      '-',
+                      textAlign: TextAlign.center,
+                      style: TextStyle(
+                        color: Colors.white,
+                      ),
+                    ),
+                  ),
+                if (widget.game.month != null) ...[
+                  const SizedBox(width: 10.0),
+                  Text(
+                    widget.game.month!,
+                    style: const TextStyle(
+                      fontFeatures: [FontFeature.tabularFigures()],
+                    ),
+                  ),
+                ],
+                if (widget.game.speed != null) ...[
+                  const SizedBox(width: 10.0),
+                  Icon(widget.game.speed!.icon, size: 20),
+                ],
+              ],
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
+
+class _WinPercentageChart extends StatelessWidget {
+  const _WinPercentageChart({
+    required this.whiteWins,
+    required this.draws,
+    required this.blackWins,
+  });
+
+  final int whiteWins;
+  final int draws;
+  final int blackWins;
+
+  int percentGames(int games) =>
+      ((games / (whiteWins + draws + blackWins)) * 100).round();
+  String label(int percent) => percent < 20 ? '' : '$percent%';
+
+  @override
+  Widget build(BuildContext context) {
+    final percentWhite = percentGames(whiteWins);
+    final percentDraws = percentGames(draws);
+    final percentBlack = percentGames(blackWins);
+
+    return ClipRRect(
+      borderRadius: BorderRadius.circular(5),
+      child: Row(
+        children: [
+          Expanded(
+            flex: percentWhite,
+            child: ColoredBox(
+              color: _whiteBoxColor(context),
+              child: Text(
+                label(percentWhite),
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.black),
+              ),
+            ),
+          ),
+          Expanded(
+            flex: percentDraws,
+            child: ColoredBox(
+              color: Colors.grey,
+              child: Text(
+                label(percentDraws),
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.white),
+              ),
+            ),
+          ),
+          Expanded(
+            flex: percentBlack,
+            child: ColoredBox(
+              color: _blackBoxColor(context),
+              child: Text(
+                label(percentBlack),
+                textAlign: TextAlign.center,
+                style: const TextStyle(color: Colors.white),
+              ),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
