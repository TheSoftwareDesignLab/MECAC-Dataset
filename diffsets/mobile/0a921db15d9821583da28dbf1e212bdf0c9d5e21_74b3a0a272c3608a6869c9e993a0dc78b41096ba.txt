diff --git a/lib/src/view/home/home_tab_screen.dart b/lib/src/view/home/home_tab_screen.dart
index cc2fcd6d14..efbc407ae7 100644
--- a/lib/src/view/home/home_tab_screen.dart
+++ b/lib/src/view/home/home_tab_screen.dart
@@ -1,4 +1,3 @@
-import 'package:carousel_slider/carousel_slider.dart';
 import 'package:fast_immutable_collections/fast_immutable_collections.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
@@ -446,7 +445,7 @@ class _OfflineCorrespondenceCarousel extends ConsumerWidget {
   }
 }
 
-class _GamesCarousel<T> extends StatelessWidget {
+class _GamesCarousel<T> extends StatefulWidget {
   const _GamesCarousel({
     required this.list,
     required this.builder,
@@ -458,6 +457,13 @@ class _GamesCarousel<T> extends StatelessWidget {
   final Widget Function(BuildContext) moreScreenBuilder;
   final int maxGamesToShow;
 
+  @override
+  State<_GamesCarousel<T>> createState() => _GamesCarouselState<T>();
+}
+
+class _GamesCarouselState<T> extends State<_GamesCarousel<T>> {
+  final _pageController = PageController(viewportFraction: 0.65);
+
   @override
   Widget build(BuildContext context) {
     return Column(
@@ -471,18 +477,18 @@ class _GamesCarousel<T> extends StatelessWidget {
             children: [
               Flexible(
                 child: Text(
-                  context.l10n.nbGamesInPlay(list.length),
+                  context.l10n.nbGamesInPlay(widget.list.length),
                   style: Styles.sectionTitle,
                   overflow: TextOverflow.ellipsis,
                 ),
               ),
-              if (list.length > 2) ...[
+              if (widget.list.length > 2) ...[
                 const SizedBox(width: 6.0),
                 NoPaddingTextButton(
                   onPressed: () {
                     pushPlatformRoute(
                       context,
-                      title: context.l10n.nbGamesInPlay(list.length),
+                      title: context.l10n.nbGamesInPlay(widget.list.length),
                       builder: (_) => const OngoingGamesScreen(),
                     );
                   },
@@ -492,19 +498,16 @@ class _GamesCarousel<T> extends StatelessWidget {
             ],
           ),
         ),
-        Padding(
-          padding: const EdgeInsets.symmetric(horizontal: 8.0),
-          child: CarouselSlider.builder(
-            options: CarouselOptions(
-              aspectRatio: 1.04,
-              viewportFraction: 0.65,
-              enableInfiniteScroll: false,
-              pageSnapping: list.length > 2,
-              padEnds: false,
-            ),
-            itemCount: list.length,
-            itemBuilder: (context, index, _) {
-              return builder(list[index]);
+        AspectRatio(
+          aspectRatio: 1.04,
+          child: BoardsPageView.builder(
+            padding: const EdgeInsets.symmetric(horizontal: 10.0),
+            controller: _pageController,
+            pageSnapping: widget.list.length > 2,
+            allowImplicitScrolling: true,
+            itemCount: widget.list.length,
+            itemBuilder: (context, index) {
+              return widget.builder(widget.list[index]);
             },
           ),
         ),
diff --git a/lib/src/widgets/board_carousel_item.dart b/lib/src/widgets/board_carousel_item.dart
index 19d8276b82..bb133dc798 100644
--- a/lib/src/widgets/board_carousel_item.dart
+++ b/lib/src/widgets/board_carousel_item.dart
@@ -1,10 +1,15 @@
 import 'package:chessground/chessground.dart';
+import 'package:flutter/gestures.dart';
 import 'package:flutter/material.dart';
+import 'package:flutter/rendering.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:lichess_mobile/src/model/settings/board_preferences.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
 import 'package:lichess_mobile/src/widgets/platform.dart';
 
+const _kBoardCarouselItemMargin =
+    EdgeInsets.symmetric(vertical: 8.0, horizontal: 6.0);
+
 class BoardCarouselItem extends ConsumerWidget {
   const BoardCarouselItem({
     required this.orientation,
@@ -33,12 +38,13 @@ class BoardCarouselItem extends ConsumerWidget {
 
     return LayoutBuilder(
       builder: (context, constraints) {
-        final boardSize = constraints.biggest.shortestSide - 16.0;
+        final boardSize = constraints.biggest.shortestSide -
+            _kBoardCarouselItemMargin.horizontal;
         final card = PlatformCard(
           color: Theme.of(context).colorScheme.surfaceContainerHighest,
           margin: Theme.of(context).platform == TargetPlatform.iOS
               ? EdgeInsets.zero
-              : const EdgeInsets.all(8.0),
+              : _kBoardCarouselItemMargin,
           child: AdaptiveInkWell(
             borderRadius: BorderRadius.circular(10),
             onTap: onTap,
@@ -79,7 +85,7 @@ class BoardCarouselItem extends ConsumerWidget {
 
         return Theme.of(context).platform == TargetPlatform.iOS
             ? Padding(
-                padding: const EdgeInsets.all(8.0),
+                padding: _kBoardCarouselItemMargin,
                 child: Container(
                   decoration: BoxDecoration(
                     borderRadius: BorderRadius.circular(8.0),
@@ -98,3 +104,248 @@ class BoardCarouselItem extends ConsumerWidget {
     );
   }
 }
+
+const PageScrollPhysics _kPagePhysics = PageScrollPhysics();
+
+/// Like [PageView], but specialized for a list of boards.
+///
+/// The only difference is that the [BoardsPageView] doesn't have a [padEnds]
+/// boolean property, and takes intead a [padding] property that allows to set
+/// a specific padding for the viewport which is not dependent on the viewport
+/// fraction.
+class BoardsPageView extends StatefulWidget {
+  BoardsPageView({
+    super.key,
+    this.scrollDirection = Axis.horizontal,
+    this.reverse = false,
+    this.controller,
+    this.physics,
+    this.pageSnapping = true,
+    this.onPageChanged,
+    List<Widget> children = const <Widget>[],
+    this.dragStartBehavior = DragStartBehavior.start,
+    this.allowImplicitScrolling = false,
+    this.restorationId,
+    this.clipBehavior = Clip.hardEdge,
+    this.scrollBehavior,
+    this.padding = EdgeInsets.zero,
+  }) : childrenDelegate = SliverChildListDelegate(children);
+
+  BoardsPageView.builder({
+    super.key,
+    this.scrollDirection = Axis.horizontal,
+    this.reverse = false,
+    this.controller,
+    this.physics,
+    this.pageSnapping = true,
+    this.onPageChanged,
+    required NullableIndexedWidgetBuilder itemBuilder,
+    ChildIndexGetter? findChildIndexCallback,
+    int? itemCount,
+    this.dragStartBehavior = DragStartBehavior.start,
+    this.allowImplicitScrolling = false,
+    this.restorationId,
+    this.clipBehavior = Clip.hardEdge,
+    this.scrollBehavior,
+    this.padding = EdgeInsets.zero,
+  }) : childrenDelegate = SliverChildBuilderDelegate(
+          itemBuilder,
+          findChildIndexCallback: findChildIndexCallback,
+          childCount: itemCount,
+        );
+
+  final bool allowImplicitScrolling;
+  final String? restorationId;
+  final Axis scrollDirection;
+  final bool reverse;
+  final PageController? controller;
+  final ScrollPhysics? physics;
+  final bool pageSnapping;
+  final ValueChanged<int>? onPageChanged;
+  final SliverChildDelegate childrenDelegate;
+  final DragStartBehavior dragStartBehavior;
+  final Clip clipBehavior;
+  final ScrollBehavior? scrollBehavior;
+  final EdgeInsets padding;
+
+  @override
+  State<BoardsPageView> createState() => _BoardsPageViewState();
+}
+
+class _BoardsPageViewState extends State<BoardsPageView> {
+  int _lastReportedPage = 0;
+
+  late PageController _controller;
+
+  @override
+  void initState() {
+    super.initState();
+    _initController();
+    _lastReportedPage = _controller.initialPage;
+  }
+
+  @override
+  void dispose() {
+    if (widget.controller == null) {
+      _controller.dispose();
+    }
+    super.dispose();
+  }
+
+  void _initController() {
+    _controller = widget.controller ?? PageController();
+  }
+
+  @override
+  void didUpdateWidget(BoardsPageView oldWidget) {
+    if (oldWidget.controller != widget.controller) {
+      if (oldWidget.controller == null) {
+        _controller.dispose();
+      }
+      _initController();
+    }
+    super.didUpdateWidget(oldWidget);
+  }
+
+  AxisDirection _getDirection(BuildContext context) {
+    switch (widget.scrollDirection) {
+      case Axis.horizontal:
+        assert(debugCheckHasDirectionality(context));
+        final TextDirection textDirection = Directionality.of(context);
+        final AxisDirection axisDirection =
+            textDirectionToAxisDirection(textDirection);
+        return widget.reverse
+            ? flipAxisDirection(axisDirection)
+            : axisDirection;
+      case Axis.vertical:
+        return widget.reverse ? AxisDirection.up : AxisDirection.down;
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final AxisDirection axisDirection = _getDirection(context);
+    final ScrollPhysics physics = _ForceImplicitScrollPhysics(
+      allowImplicitScrolling: widget.allowImplicitScrolling,
+    ).applyTo(
+      widget.pageSnapping
+          ? _kPagePhysics.applyTo(
+              widget.physics ??
+                  widget.scrollBehavior?.getScrollPhysics(context),
+            )
+          : widget.physics ?? widget.scrollBehavior?.getScrollPhysics(context),
+    );
+
+    return NotificationListener<ScrollNotification>(
+      onNotification: (ScrollNotification notification) {
+        if (notification.depth == 0 &&
+            widget.onPageChanged != null &&
+            notification is ScrollUpdateNotification) {
+          final PageMetrics metrics = notification.metrics as PageMetrics;
+          final int currentPage = metrics.page!.round();
+          if (currentPage != _lastReportedPage) {
+            _lastReportedPage = currentPage;
+            widget.onPageChanged!(currentPage);
+          }
+        }
+        return false;
+      },
+      child: Scrollable(
+        dragStartBehavior: widget.dragStartBehavior,
+        axisDirection: axisDirection,
+        controller: _controller,
+        physics: physics,
+        restorationId: widget.restorationId,
+        scrollBehavior: widget.scrollBehavior ??
+            ScrollConfiguration.of(context).copyWith(scrollbars: false),
+        viewportBuilder: (BuildContext context, ViewportOffset position) {
+          return Viewport(
+            cacheExtent: 0,
+            cacheExtentStyle: CacheExtentStyle.viewport,
+            axisDirection: axisDirection,
+            offset: position,
+            clipBehavior: widget.clipBehavior,
+            slivers: <Widget>[
+              _SliverFillViewport(
+                viewportFraction: _controller.viewportFraction,
+                delegate: widget.childrenDelegate,
+                padding: widget.padding,
+              ),
+            ],
+          );
+        },
+      ),
+    );
+  }
+}
+
+class _SliverFillViewport extends StatelessWidget {
+  const _SliverFillViewport({
+    required this.delegate,
+    this.viewportFraction = 1.0,
+    this.padding,
+  }) : assert(viewportFraction > 0.0);
+
+  final double viewportFraction;
+
+  final EdgeInsets? padding;
+
+  final SliverChildDelegate delegate;
+
+  @override
+  Widget build(BuildContext context) {
+    return SliverPadding(
+      padding: padding ?? EdgeInsets.zero,
+      sliver: _SliverFillViewportRenderObjectWidget(
+        viewportFraction: viewportFraction,
+        delegate: delegate,
+      ),
+    );
+  }
+}
+
+class _SliverFillViewportRenderObjectWidget
+    extends SliverMultiBoxAdaptorWidget {
+  const _SliverFillViewportRenderObjectWidget({
+    required super.delegate,
+    this.viewportFraction = 1.0,
+  }) : assert(viewportFraction > 0.0);
+
+  final double viewportFraction;
+
+  @override
+  RenderSliverFillViewport createRenderObject(BuildContext context) {
+    final SliverMultiBoxAdaptorElement element =
+        context as SliverMultiBoxAdaptorElement;
+    return RenderSliverFillViewport(
+      childManager: element,
+      viewportFraction: viewportFraction,
+    );
+  }
+
+  @override
+  void updateRenderObject(
+    BuildContext context,
+    RenderSliverFillViewport renderObject,
+  ) {
+    renderObject.viewportFraction = viewportFraction;
+  }
+}
+
+class _ForceImplicitScrollPhysics extends ScrollPhysics {
+  const _ForceImplicitScrollPhysics({
+    required this.allowImplicitScrolling,
+    super.parent,
+  });
+
+  @override
+  _ForceImplicitScrollPhysics applyTo(ScrollPhysics? ancestor) {
+    return _ForceImplicitScrollPhysics(
+      allowImplicitScrolling: allowImplicitScrolling,
+      parent: buildParent(ancestor),
+    );
+  }
+
+  @override
+  final bool allowImplicitScrolling;
+}
diff --git a/pubspec.lock b/pubspec.lock
index 7ae41dbc74..845a506474 100644
--- a/pubspec.lock
+++ b/pubspec.lock
@@ -161,14 +161,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.2.0"
-  carousel_slider:
-    dependency: "direct main"
-    description:
-      name: carousel_slider
-      sha256: "9c695cc963bf1d04a47bd6021f68befce8970bcd61d24938e1fb0918cf5d9c42"
-      url: "https://pub.dev"
-    source: hosted
-    version: "4.2.1"
   characters:
     dependency: transitive
     description:
diff --git a/pubspec.yaml b/pubspec.yaml
index b8f35a7f81..e9a1ecf0a2 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -11,7 +11,6 @@ environment:
 dependencies:
   async: ^2.10.0
   cached_network_image: ^3.2.2
-  carousel_slider: ^4.2.1
   chessground: ^2.6.1
   collection: ^1.17.0
   connectivity_plus: ^6.0.2
