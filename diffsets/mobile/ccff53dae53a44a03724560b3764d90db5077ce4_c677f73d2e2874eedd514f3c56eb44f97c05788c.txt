diff --git a/lib/src/constants.dart b/lib/src/constants.dart
index ffbbc4c68f..48fb5061c7 100644
--- a/lib/src/constants.dart
+++ b/lib/src/constants.dart
@@ -22,6 +22,7 @@ const kClueLessDeviation = 230;
 // UI
 const kTabletThreshold = 600;
 const kCardTextScaleFactor = 1.64;
+const kMaxClockTextScaleFactor = 1.94;
 const kEmptyWidget = SizedBox.shrink();
 const kEmptyFen = '8/8/8/8/8/8/8/8 w - - 0 1';
 
diff --git a/lib/src/model/puzzle/puzzle_storm.dart b/lib/src/model/puzzle/puzzle_storm.dart
index cc0680d8a1..985f386552 100644
--- a/lib/src/model/puzzle/puzzle_storm.dart
+++ b/lib/src/model/puzzle/puzzle_storm.dart
@@ -36,7 +36,7 @@ class StormCtrl extends _$StormCtrl {
     final pov = Chess.fromSetup(Setup.parseFen(puzzles.first.fen));
     final newState = StormCtrlState(
       runOver: false,
-      runActive: false,
+      runStarted: false,
       puzzle: puzzles[_nextPuzzleIndex],
       position: pov,
       pov: pov.turn.opposite,
@@ -50,7 +50,8 @@ class StormCtrl extends _$StormCtrl {
     _nextPuzzleIndex += 1;
     _firstMoveTimer = Timer(
       const Duration(seconds: 1),
-      () => _addMove(state.expectedMove!, ComboState.noChange),
+      () =>
+          _addMove(state.expectedMove!, ComboState.noChange, runStarted: false),
     );
     newState.clock.timeStream.listen((e) {
       if (e.$1 == Duration.zero && state.clock.endAt == null) {
@@ -65,7 +66,7 @@ class StormCtrl extends _$StormCtrl {
     state.clock.start();
     final expected = state.expectedMove;
     final pos = state.position;
-    _addMove(move, ComboState.noChange);
+    _addMove(move, ComboState.noChange, runStarted: true);
     _moves += 1;
     if (state.position.isGameOver || move == expected) {
       final bonus = state.combo.bonus(getNext: true);
@@ -78,7 +79,7 @@ class StormCtrl extends _$StormCtrl {
           return;
         }
         ref.read(soundServiceProvider).play(Sound.confirmation);
-        _pushToHistory(true);
+        _pushToHistory(success: true);
         await _loadNextPuzzle(true, ComboState.increase);
         return;
       }
@@ -93,7 +94,7 @@ class StormCtrl extends _$StormCtrl {
             .moveFeedback(check: state.position.isCheck);
       }
       await Future<void>.delayed(moveDelay);
-      _addMove(state.expectedMove!, ComboState.increase);
+      _addMove(state.expectedMove!, ComboState.increase, runStarted: true);
     } else {
       _errors += 1;
       ref.read(soundServiceProvider).play(Sound.error);
@@ -102,15 +103,15 @@ class StormCtrl extends _$StormCtrl {
         state.clock.sendEnd();
         return;
       }
-      _pushToHistory(false);
+      _pushToHistory(success: false);
       await _loadNextPuzzle(false, ComboState.reset);
     }
   }
 
   void end() {
     state.clock.reset();
-    _pushToHistory(false);
-    state = state.copyWith(stats: _getStats(), runOver: true, runActive: false);
+    _pushToHistory(success: false);
+    state = state.copyWith(stats: _getStats(), runOver: true);
   }
 
   Future<void> _loadNextPuzzle(bool result, ComboState comboChange) async {
@@ -137,10 +138,10 @@ class StormCtrl extends _$StormCtrl {
     );
     _nextPuzzleIndex += 1;
     await Future<void>.delayed(moveDelay);
-    _addMove(state.expectedMove!, ComboState.noChange);
+    _addMove(state.expectedMove!, ComboState.noChange, runStarted: true);
   }
 
-  void _addMove(Move move, ComboState comboChange) {
+  void _addMove(Move move, ComboState comboChange, {required bool runStarted}) {
     int newComboCurrent;
     switch (comboChange) {
       case ComboState.increase:
@@ -151,7 +152,7 @@ class StormCtrl extends _$StormCtrl {
         newComboCurrent = state.combo.current;
     }
     state = state.copyWith(
-      runActive: true,
+      runStarted: runStarted,
       position: state.position.play(move),
       moveIndex: state.moveIndex + 1,
       combo: StormCombo(
@@ -175,15 +176,15 @@ class StormCtrl extends _$StormCtrl {
                 (maxRating, rating) => rating > maxRating ? rating : maxRating,
               )
           : 0,
-      history: _history,
+      history: _history.toIList(),
     );
   }
 
-  void _pushToHistory(bool result) {
+  void _pushToHistory({required bool success}) {
     final timeTaken = state.lastSolvedTime != null
         ? DateTime.now().difference(state.lastSolvedTime!)
         : DateTime.now().difference(state.clock.startAt!);
-    _history.add((state.puzzle, result, timeTaken));
+    _history.add((state.puzzle, success, timeTaken));
   }
 
   bool _isNextPuzzleAvailable() {
@@ -196,17 +197,38 @@ class StormCtrlState with _$StormCtrlState {
   const StormCtrlState._();
   // moveIndex starts at -1 for new puzzles
   const factory StormCtrlState({
+    /// Current puzzle being played
     required LitePuzzle puzzle,
+
+    /// Side of the run. This stays the same throughout the run
     required Side pov,
-    required Position<Chess> position,
+
+    /// Index of the move based on [puzzle.solution]. For a new puzzle it is at -1
     required int moveIndex,
+
+    /// Position of the current puzzle based on moveIndex
+    required Position<Chess> position,
+
+    /// Number of puzzles solved
     required int numSolved,
+
+    /// A clock object which stays the same throughout the run
     required StormClock clock,
+
+    /// A combo object which has the current and best combo
     required StormCombo combo,
+
+    /// Stats of the storm run. Only initialisd after the run ends
     required StormRunStats? stats,
+
+    /// Last solved time for the puzzle
     required DateTime? lastSolvedTime,
+
+    /// bool to indicate that the run has concluded. Useful for UI updates
     required bool runOver,
-    required bool runActive,
+
+    /// bool to indicate run has started
+    required bool runStarted,
   }) = _StormCtrlState;
 
   Move? get expectedMove => Move.fromUci(puzzle.solution[moveIndex + 1]);
@@ -229,7 +251,7 @@ class StormRunStats with _$StormRunStats {
     required Duration time,
     required double timePerMove,
     required int highest,
-    required List<(LitePuzzle, bool, Duration)> history,
+    required IList<(LitePuzzle, bool, Duration)> history,
   }) = _StormRunStats;
 }
 
@@ -239,6 +261,7 @@ enum ComboState {
   noChange,
 }
 
+/// A `StormCombo` object represents the current and best combo of a storm run
 @freezed
 class StormCombo with _$StormCombo {
   const StormCombo._();
@@ -248,40 +271,52 @@ class StormCombo with _$StormCombo {
     required int best,
   }) = _StormCombo;
 
-  static const levels = [
-    [0, 0],
-    [5, 3],
-    [12, 5],
-    [20, 7],
-    [30, 10]
+  /// List representing the bonus awared at each level
+  static const levelBonus = [3, 5, 6, 10];
+
+  /// List of pair of level and the bonus
+  static const levelsAndBonus = [
+    (level: 0, bonus: 0),
+    (level: 5, bonus: 3),
+    (level: 12, bonus: 5),
+    (level: 20, bonus: 7),
+    (level: 30, bonus: 10),
   ];
 
   int currentLevel() {
-    final lvl = levels.indexWhere((element) => element.first > current);
-    return lvl >= 0 ? lvl - 1 : levels.length - 1;
+    final lvl = levelsAndBonus.indexWhere((element) => element.level > current);
+    return lvl >= 0 ? lvl - 1 : levelsAndBonus.length - 1;
   }
 
+  /// Returns the level of the `current + 1` combo count
   int nextLevel() {
-    final lvl = levels.indexWhere((element) => element.first > current + 1);
-    return lvl >= 0 ? lvl - 1 : levels.length - 1;
+    final lvl =
+        levelsAndBonus.indexWhere((element) => element.level > current + 1);
+    return lvl >= 0 ? lvl - 1 : levelsAndBonus.length - 1;
   }
 
+  /// Returns the percentage completion of the `current` combo count.
+  /// If [getNext] is true it returns the percentage of `current + 1` combo count.
+  /// This is helpful for calculating the progress bar value.
   double percent({required bool getNext}) {
     final lvl = getNext ? nextLevel() : currentLevel();
-    final lastLevel = levels.last;
-    if (lvl >= levels.length - 1) {
-      final range = lastLevel.first - levels[levels.length - 2].first;
-      return (((current - lastLevel.first) / range) * 100) % 100;
+    final lastLevel = levelsAndBonus.last;
+    if (lvl >= levelsAndBonus.length - 1) {
+      final range =
+          lastLevel.level - levelsAndBonus[levelsAndBonus.length - 2].level;
+      return (((current - lastLevel.level) / range) * 100) % 100;
     }
-    final bounds = [levels[lvl].first, levels[lvl + 1].first];
+    final bounds = [levelsAndBonus[lvl].level, levelsAndBonus[lvl + 1].level];
     return ((current - bounds.first) / (bounds[1] - bounds.first)) * 100;
   }
 
+  /// Returns the bonus time if a new level is reached.
+  /// If [getNext] is true it indicates if the bonus will be reached on the next combo.
   Duration? bonus({required bool getNext}) {
     if (percent(getNext: getNext).floor() == 0) {
       final lvl = getNext ? nextLevel() : currentLevel();
       if (lvl > 0) {
-        return Duration(seconds: levels[lvl][1]);
+        return Duration(seconds: levelsAndBonus[lvl].bonus);
       }
     }
     return null;
diff --git a/lib/src/ui/puzzle/puzzle_storm.dart b/lib/src/ui/puzzle/puzzle_storm.dart
index b74ce38e5b..72752ae0d9 100644
--- a/lib/src/ui/puzzle/puzzle_storm.dart
+++ b/lib/src/ui/puzzle/puzzle_storm.dart
@@ -139,10 +139,10 @@ class _Body extends ConsumerWidget {
                   sideToMove: puzzleState.position.turn.cg,
                   validMoves: puzzleState.validMoves,
                 ),
-                topTable: _TopBar(
+                topTable: _TopTable(
                   ctrl: ctrlProvider,
                 ),
-                bottomTable: _Combo(ctrlProvider),
+                bottomTable: _Combo(puzzleState.combo),
               ),
             ),
           ),
@@ -151,7 +151,7 @@ class _Body extends ConsumerWidget {
       ],
     );
 
-    return !puzzleState.runActive
+    return !puzzleState.clock.isActive
         ? content
         : WillPopScope(
             child: content,
@@ -175,8 +175,8 @@ class _Body extends ConsumerWidget {
   }
 }
 
-class _TopBar extends ConsumerWidget {
-  const _TopBar({
+class _TopTable extends ConsumerWidget {
+  const _TopTable({
     required this.ctrl,
   });
 
@@ -196,7 +196,7 @@ class _TopBar extends ConsumerWidget {
             color: LichessColors.brag,
           ),
           const SizedBox(width: 8),
-          if (!puzzleState.runActive || !puzzleState.runOver)
+          if (!puzzleState.runStarted)
             Expanded(
               flex: 5,
               child: Column(
@@ -230,7 +230,7 @@ class _TopBar extends ConsumerWidget {
               ),
             ),
           const Spacer(),
-          StormClockWidget(ctrl: ctrl),
+          StormClockWidget(clock: puzzleState.clock),
         ],
       ),
     );
@@ -238,9 +238,9 @@ class _TopBar extends ConsumerWidget {
 }
 
 class _Combo extends ConsumerStatefulWidget {
-  const _Combo(this.ctrl);
+  const _Combo(this.combo);
 
-  final StormCtrlProvider ctrl;
+  final StormCombo combo;
 
   @override
   ConsumerState<_Combo> createState() => _ComboState();
@@ -249,19 +249,14 @@ class _Combo extends ConsumerStatefulWidget {
 class _ComboState extends ConsumerState<_Combo>
     with SingleTickerProviderStateMixin {
   late AnimationController _controller;
-  // ignore: avoid-late-keyword
-  late StormCombo combo;
-
-  static const levels = [3, 5, 7, 10];
 
   @override
   void initState() {
     super.initState();
-    combo = ref.read(widget.ctrl.select((value) => value.combo));
     _controller = AnimationController(
       vsync: this,
       duration: const Duration(milliseconds: 1000),
-      value: combo.percent(getNext: false) / 100,
+      value: widget.combo.percent(getNext: false) / 100,
     );
   }
 
@@ -269,11 +264,10 @@ class _ComboState extends ConsumerState<_Combo>
   void didUpdateWidget(covariant _Combo oldWidget) {
     super.didUpdateWidget(oldWidget);
 
-    combo = ref.read(widget.ctrl.select((value) => value.combo));
-    final newVal = combo.percent(getNext: false) / 100;
+    final newVal = widget.combo.percent(getNext: false) / 100;
     if (_controller.value != newVal) {
       // next lvl reached
-      if (_controller.value > newVal && combo.current != 0) {
+      if (_controller.value > newVal && widget.combo.current != 0) {
         if (ref.read(boardPreferencesProvider).hapticFeedback) {
           HapticFeedback.heavyImpact();
         }
@@ -299,7 +293,7 @@ class _ComboState extends ConsumerState<_Combo>
 
   @override
   Widget build(BuildContext context) {
-    final lvl = combo.currentLevel();
+    final lvl = widget.combo.currentLevel();
     final indicatorColor = Theme.of(context).colorScheme.secondary;
 
     final comboShades = generateShades(
@@ -318,7 +312,7 @@ class _ComboState extends ConsumerState<_Combo>
               text: TextSpan(
                 children: [
                   TextSpan(
-                    text: combo.current.toString(),
+                    text: widget.combo.current.toString(),
                     style: TextStyle(
                       fontSize: 35,
                       fontWeight: FontWeight.bold,
@@ -374,7 +368,7 @@ class _ComboState extends ConsumerState<_Combo>
                   Row(
                     crossAxisAlignment: CrossAxisAlignment.center,
                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
-                    children: levels.mapIndexed((index, level) {
+                    children: StormCombo.levelBonus.mapIndexed((index, level) {
                       final isCurrentLevel = index < lvl;
                       return AnimatedContainer(
                         alignment: Alignment.center,
@@ -469,7 +463,7 @@ class _BottomBar extends ConsumerWidget {
               showAndroidShortLabel: true,
               onTap: () => ref.invalidate(stormProvider),
             ),
-            if (puzzleState.runActive)
+            if (puzzleState.runStarted && !puzzleState.runOver)
               BottomBarButton(
                 icon: LichessIcons.flag,
                 label: context.l10n.stormEndRun.split(' ').take(2).join(' '),
@@ -510,22 +504,22 @@ class _RunStats extends StatelessWidget {
   Widget build(BuildContext context) {
     return CupertinoPopupSurface(
       child: defaultTargetPlatform == TargetPlatform.iOS
-          ? CupertinoPageScaffold(child: _DialogBody(stats))
-          : Scaffold(body: _DialogBody(stats)),
+          ? CupertinoPageScaffold(child: _RunStatsPopup(stats))
+          : Scaffold(body: _RunStatsPopup(stats)),
     );
   }
 }
 
-class _DialogBody extends ConsumerStatefulWidget {
-  const _DialogBody(this.stats);
+class _RunStatsPopup extends ConsumerStatefulWidget {
+  const _RunStatsPopup(this.stats);
 
   final StormRunStats stats;
 
   @override
-  ConsumerState createState() => _DialogBodyState();
+  ConsumerState createState() => _RunStatsPopupState();
 }
 
-class _DialogBodyState extends ConsumerState<_DialogBody> {
+class _RunStatsPopupState extends ConsumerState<_RunStatsPopup> {
   bool isLoading = false;
 
   @override
diff --git a/lib/src/ui/puzzle/storm_clock.dart b/lib/src/ui/puzzle/storm_clock.dart
index 4b3dd296f3..355d4f285a 100644
--- a/lib/src/ui/puzzle/storm_clock.dart
+++ b/lib/src/ui/puzzle/storm_clock.dart
@@ -9,13 +9,12 @@ import 'dart:ui';
 
 import 'package:lichess_mobile/src/model/settings/brightness.dart';
 import 'package:lichess_mobile/src/widgets/countdown_clock.dart';
+import 'package:lichess_mobile/src/constants.dart';
 
 class StormClockWidget extends ConsumerStatefulWidget {
-  const StormClockWidget({
-    required this.ctrl,
-  });
+  const StormClockWidget({required this.clock});
 
-  final StormCtrlProvider ctrl;
+  final StormClock clock;
 
   @override
   _ClockState createState() => _ClockState();
@@ -32,9 +31,6 @@ class _ClockState extends ConsumerState<StormClockWidget>
   // ignore: avoid-late-keyword
   late Animation<Offset> slideAnimation;
 
-  // ignore: avoid-late-keyword
-  late StormClock clock;
-
   StreamSubscription<(Duration, int?)>? streamSubscription;
 
   String minutes = '03';
@@ -51,9 +47,14 @@ class _ClockState extends ConsumerState<StormClockWidget>
       duration: const Duration(milliseconds: 500),
     )..addListener(() => setState(() {}));
 
-    clock = ref.read(widget.ctrl.select((value) => value.clock));
-    minutes = clock.timeLeft.inMinutes.remainder(60).toString().padLeft(2, '0');
-    seconds = clock.timeLeft.inSeconds.remainder(60).toString().padLeft(2, '0');
+    minutes = widget.clock.timeLeft.inMinutes
+        .remainder(60)
+        .toString()
+        .padLeft(2, '0');
+    seconds = widget.clock.timeLeft.inSeconds
+        .remainder(60)
+        .toString()
+        .padLeft(2, '0');
     animation = Tween<double>(begin: 0.0, end: 120.0).animate(_controller);
     fadeAnimation = Tween<double>(begin: 1.0, end: 0.0).animate(_controller);
     slideAnimation = Tween<Offset>(
@@ -61,13 +62,13 @@ class _ClockState extends ConsumerState<StormClockWidget>
       end: const Offset(0.7, -1.0),
     ).animate(_controller);
 
-    streamSubscription = clock.timeStream.listen((data) {
+    streamSubscription = widget.clock.timeStream.listen((data) {
       setState(() {
         minutes = data.$1.inMinutes.remainder(60).toString().padLeft(2, '0');
         seconds = data.$1.inSeconds.remainder(60).toString().padLeft(2, '0');
         time = data.$1;
         bonus = data.$2;
-        isActive = clock.isActive;
+        isActive = widget.clock.isActive;
         if (bonus != null) {
           _controller.forward(from: 0);
         }
diff --git a/lib/src/widgets/countdown_clock.dart b/lib/src/widgets/countdown_clock.dart
index 90c1de7689..44c24f663b 100644
--- a/lib/src/widgets/countdown_clock.dart
+++ b/lib/src/widgets/countdown_clock.dart
@@ -5,8 +5,7 @@ import 'dart:async';
 import 'dart:ui';
 
 import 'package:lichess_mobile/src/model/settings/brightness.dart';
-
-const kMaxClockTextScaleFactor = 1.94;
+import 'package:lichess_mobile/src/constants.dart';
 
 /// A simple countdown clock.
 ///
diff --git a/test/model/puzzle/storm_combo.dart b/test/model/puzzle/storm_combo.dart
new file mode 100644
index 0000000000..e47b860dbe
--- /dev/null
+++ b/test/model/puzzle/storm_combo.dart
@@ -0,0 +1,46 @@
+import 'package:flutter_test/flutter_test.dart';
+import 'package:lichess_mobile/src/model/puzzle/puzzle_storm.dart';
+
+void main() {
+  group('StormCombo', () {
+    test('currentLevel returns correct level', () {
+      const combo = StormCombo(current: 13, best: 20);
+      expect(combo.currentLevel(), 2);
+    });
+
+    test('nextLevel returns correct level', () {
+      const combo = StormCombo(current: 4, best: 20);
+      expect(combo.nextLevel(), 1);
+    });
+
+    test('percent returns correct percentage', () {
+      const combo = StormCombo(current: 7, best: 20);
+      expect(combo.percent(getNext: false), 40.0);
+    });
+
+    test('percent getNext returns correct percentage', () {
+      const combo = StormCombo(current: 7, best: 20);
+      expect(combo.percent(getNext: true), 60.0);
+    });
+
+    test('bonus returns correct bonus duration', () {
+      const combo = StormCombo(current: 5, best: 20);
+      expect(combo.bonus(getNext: false), const Duration(seconds: 3));
+    });
+
+    test('bonus returns null when no bonus is applicable', () {
+      const combo = StormCombo(current: 6, best: 20);
+      expect(combo.bonus(getNext: false), null);
+    });
+
+    test('bonus getNext returns correct bonus duration', () {
+      const combo = StormCombo(current: 4, best: 20);
+      expect(combo.bonus(getNext: true), const Duration(seconds: 3));
+    });
+
+    test('bonus getNext returns null when no bonus is applicable', () {
+      const combo = StormCombo(current: 5, best: 20);
+      expect(combo.bonus(getNext: true), null);
+    });
+  });
+}
