diff --git a/lib/src/model/engine/evaluation_mixin.dart b/lib/src/model/engine/evaluation_mixin.dart
index 3ba6976d5e..cd81ff0c5e 100644
--- a/lib/src/model/engine/evaluation_mixin.dart
+++ b/lib/src/model/engine/evaluation_mixin.dart
@@ -189,6 +189,8 @@ mixin EngineEvaluationMixin {
   void requestEval() {
     if (!evaluationState.isEngineAvailable(evaluationPrefs)) return;
 
+    _evaluationService?.resetEval();
+
     _cloudEvalGetDebounce(() {
       _sendEvalGetEvent();
       if (!evaluationState.delayLocalEngine) {
diff --git a/lib/src/model/engine/evaluation_service.dart b/lib/src/model/engine/evaluation_service.dart
index 60870f1d23..22f26bb97c 100644
--- a/lib/src/model/engine/evaluation_service.dart
+++ b/lib/src/model/engine/evaluation_service.dart
@@ -146,24 +146,11 @@ class EvaluationService {
     // cancel evaluation if we already have an interesting eval
     final cachedEval = work.steps.isEmpty ? initialPositionEval : work.evalCache;
     switch (cachedEval) {
-      // we have a local eval
-      case final LocalEval localEval:
-        // if the search time is greater than the current search time, don't evaluate again but
-        // update the engine state with the local eval
-        if (localEval.searchTime >= _options.searchTime) {
-          _state.value = (
-            engineName: _state.value.engineName,
-            state: _state.value.state,
-            eval: localEval,
-          );
-          return null;
-        }
-      // we have a cloud eval, no need to evaluate
+      // if the search time is greater than the current search time, don't evaluate again
+      case final LocalEval localEval when localEval.searchTime >= _options.searchTime:
       case CloudEval _:
-        _state.value = (engineName: _state.value.engineName, state: _state.value.state, eval: null);
         return null;
-      // no eval, continue
-      case null:
+      case _:
         break;
     }
 
@@ -184,6 +171,10 @@ class EvaluationService {
   void stop() {
     _engine?.stop();
   }
+
+  void resetEval() {
+    _state.value = (engineName: _state.value.engineName, state: _state.value.state, eval: null);
+  }
 }
 
 @Riverpod(keepAlive: true)
@@ -204,7 +195,7 @@ typedef EngineEvaluationState = ({String engineName, EngineState state, LocalEva
 class EngineEvaluation extends _$EngineEvaluation {
   @override
   EngineEvaluationState build() {
-    final listenable = ref.watch(evaluationServiceProvider).state;
+    final listenable = ref.read(evaluationServiceProvider).state;
 
     listenable.addListener(_listener);
 
diff --git a/lib/src/view/analysis/analysis_board.dart b/lib/src/view/analysis/analysis_board.dart
index 61074e079d..de87fddb0e 100644
--- a/lib/src/view/analysis/analysis_board.dart
+++ b/lib/src/view/analysis/analysis_board.dart
@@ -44,23 +44,19 @@ class AnalysisBoardState extends ConsumerState<AnalysisBoard> {
     final boardPrefs = ref.watch(boardPreferencesProvider);
     final analysisPrefs = ref.watch(analysisPreferencesProvider);
     final enginePrefs = ref.watch(engineEvaluationPreferencesProvider);
-    final enableComputerAnalysis = analysisPrefs.enableComputerAnalysis;
+
+    final enableComputerAnalysis = analysisState.isComputerAnalysisAllowedAndEnabled;
     final showBestMoveArrow = enableComputerAnalysis && analysisPrefs.showBestMoveArrow;
     final showAnnotationsOnBoard = enableComputerAnalysis && analysisPrefs.showAnnotations;
-    final evalBestMoves =
-        enableComputerAnalysis
-            ? ref.watch(engineEvaluationProvider.select((s) => s.eval?.bestMoves))
-            : null;
-
     final currentNode = analysisState.currentNode;
-    final annotation = showAnnotationsOnBoard ? makeAnnotation(currentNode.nags) : null;
-
-    final bestMoves = enableComputerAnalysis ? evalBestMoves ?? currentNode.eval?.bestMoves : null;
-
-    final sanMove = currentNode.sanMove;
 
+    final localBestMoves =
+        analysisState.isEngineAvailable(enginePrefs) && showBestMoveArrow
+            ? ref.watch(engineEvaluationProvider.select((value) => value.eval?.bestMoves))
+            : null;
+    final bestMoves = pickBestMoves(localBestMoves: localBestMoves, savedEval: currentNode.eval);
     final ISet<Shape> bestMoveShapes =
-        showBestMoveArrow && analysisState.isEngineAvailable(enginePrefs) && bestMoves != null
+        bestMoves != null
             ? computeBestMoveShapes(
               bestMoves,
               currentNode.position.turn,
@@ -68,6 +64,9 @@ class AnalysisBoardState extends ConsumerState<AnalysisBoard> {
             )
             : ISet();
 
+    final annotation = showAnnotationsOnBoard ? makeAnnotation(currentNode.nags) : null;
+    final sanMove = currentNode.sanMove;
+
     return Chessboard(
       size: widget.boardSize,
       fen: analysisState.currentPosition.fen,
diff --git a/lib/src/view/engine/engine_depth.dart b/lib/src/view/engine/engine_depth.dart
index 3cd71b46d5..b6badb6a44 100644
--- a/lib/src/view/engine/engine_depth.dart
+++ b/lib/src/view/engine/engine_depth.dart
@@ -8,6 +8,7 @@ import 'package:lichess_mobile/src/model/engine/engine.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_service.dart';
 import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
+import 'package:lichess_mobile/src/widgets/feedback.dart';
 import 'package:lichess_mobile/src/widgets/list.dart';
 import 'package:popover/popover.dart';
 
@@ -18,13 +19,19 @@ class EngineDepth extends ConsumerWidget {
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final localEval = ref.watch(engineEvaluationProvider).eval;
+    final (engineName: _, eval: localEval, state: engineState) = ref.watch(
+      engineEvaluationProvider,
+    );
     final eval = pickBestClientEval(localEval: localEval, savedEval: savedEval);
 
     const cloudSize = 30.0;
     const microChipSize = 28.0;
     const cloudIconAlignment = AlignmentDirectional(0.0, 0.20);
-    final cloudIcon = Icon(Icons.cloud, size: cloudSize, color: ColorScheme.of(context).secondary);
+    final cloudIcon = Icon(
+      Icons.cloud,
+      size: cloudSize,
+      color: ColorScheme.of(context).secondary.withValues(alpha: 0.7),
+    );
     final iconTextStyle = TextStyle(
       color: ColorScheme.of(context).onSecondary,
       fontFeatures: const [FontFeature.tabularFigures()],
@@ -72,7 +79,11 @@ class EngineDepth extends ConsumerWidget {
             children: [
               CustomPaint(
                 size: const Size(microChipSize, microChipSize),
-                painter: MicroChipPainter(ColorScheme.of(context).secondary),
+                painter: MicroChipPainter(
+                  ColorScheme.of(
+                    context,
+                  ).secondary.withValues(alpha: engineState == EngineState.computing ? 1.0 : 0.7),
+                ),
               ),
               SizedBox(
                 width: microChipSize,
@@ -95,16 +106,10 @@ class EngineDepth extends ConsumerWidget {
             ),
           ],
         ),
-        null => SizedBox(
-          width: cloudSize,
-          height: cloudSize,
-          child: Align(
-            alignment: cloudIconAlignment,
-            child: Text(
-              '\u{2026}',
-              style: iconTextStyle.copyWith(color: ColorScheme.of(context).onSurface),
-            ),
-          ),
+        null => const SizedBox(
+          width: microChipSize,
+          height: microChipSize,
+          child: Center(child: threeBounceLoadingIndicator),
         ),
       },
     );
@@ -229,7 +234,7 @@ class MicroChipPainter extends CustomPainter {
   }
 
   @override
-  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
+  bool shouldRepaint(covariant MicroChipPainter oldDelegate) => color != oldDelegate.color;
 }
 
 class _StockfishInfo extends ConsumerWidget {
diff --git a/lib/src/widgets/feedback.dart b/lib/src/widgets/feedback.dart
index 7cb4583903..274d03f440 100644
--- a/lib/src/widgets/feedback.dart
+++ b/lib/src/widgets/feedback.dart
@@ -8,6 +8,8 @@ import 'package:lichess_mobile/src/utils/l10n_context.dart';
 import 'package:lichess_mobile/src/widgets/buttons.dart';
 import 'package:signal_strength_indicator/signal_strength_indicator.dart';
 
+const threeBounceLoadingIndicator = SpinKitThreeBounce(color: Colors.grey, size: 15);
+
 class LagIndicator extends StatelessWidget {
   const LagIndicator({
     required this.lagRating,
diff --git a/test/view/engine/engine_depth_test.dart b/test/view/engine/engine_depth_test.dart
index 9ce5f1ab27..0a883c3cce 100644
--- a/test/view/engine/engine_depth_test.dart
+++ b/test/view/engine/engine_depth_test.dart
@@ -1,4 +1,5 @@
 import 'package:flutter/material.dart';
+import 'package:flutter_spinkit/flutter_spinkit.dart';
 import 'package:flutter_test/flutter_test.dart';
 import 'package:lichess_mobile/src/model/common/id.dart';
 import 'package:lichess_mobile/src/model/engine/evaluation_mixin.dart';
@@ -46,7 +47,10 @@ void main() {
       await makeEngineTestApp(tester);
 
       // displays loading indicator
-      expect(find.widgetWithText(EngineDepth, '\u{2026}'), findsOne);
+      expect(
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        findsOne,
+      );
       await tester.pump(kRequestEvalDebounceDelay);
       expect(isCloudEvalDisplayed(), isTrue);
       expect(find.widgetWithText(EngineDepth, '36'), findsOne);
@@ -64,11 +68,17 @@ void main() {
       await makeEngineTestApp(tester, isCloudEvalEnabled: false);
       expect(find.byType(EngineDepth), findsOne);
       // displays loading indicator
-      expect(find.widgetWithText(EngineDepth, '\u{2026}'), findsOne);
+      expect(
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        findsOne,
+      );
 
       await tester.pump(kRequestEvalDebounceDelay);
       // cloud eval is not available, so it still displays loading indicator
-      expect(find.widgetWithText(EngineDepth, '\u{2026}'), findsOne);
+      expect(
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        findsOne,
+      );
       // local engine eval still not available
       expect(isLocalEngineEvalDisplayed(), isFalse);
 
@@ -134,7 +144,10 @@ void main() {
       await tester.pump(const Duration(milliseconds: 50));
 
       // engine not yet started, so it still displays loading indicator
-      expect(find.widgetWithText(EngineDepth, '\u{2026}'), findsOne);
+      expect(
+        find.descendant(of: find.byType(EngineDepth), matching: find.byType(SpinKitThreeBounce)),
+        findsOne,
+      );
 
       // wait for engine
       await tester.pump(kRequestEvalDebounceDelay + kEngineEvalEmissionThrottleDelay);
