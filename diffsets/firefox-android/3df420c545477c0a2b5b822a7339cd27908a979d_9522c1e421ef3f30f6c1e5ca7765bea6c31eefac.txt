diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
index 148b9412bf09..bc715cc31609 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
@@ -4,20 +4,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 package org.mozilla.focus.webkit.matcher;
 
+import android.util.ArrayMap;
 import android.util.JsonReader;
 import android.util.JsonToken;
 
+import org.mozilla.focus.webkit.matcher.util.FocusString;
+
 import java.io.IOException;
+import java.util.Map;
 
 public class BlocklistProcessor {
 
-    final UrlMatcher matcher;
-
     public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) throws IOException {
-        this.matcher = matcher;
-
-        // TODO: refactor this class to match the EntityListProcessor example of a static method
-        // returning a Trie of blacklisted URLs.
         reader.beginObject();
 
         while (reader.hasNext()) {
@@ -26,7 +24,7 @@ public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) thr
             final String name = reader.nextName();
 
             if (name.equals("categories")) {
-                extractCategories(reader);
+                extractCategories(reader, matcher);
             } else {
                 reader.skipValue();
             }
@@ -36,29 +34,37 @@ public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) thr
         reader.endObject();
     }
 
-    private void extractCategories(final JsonReader reader) throws IOException {
+    private static void extractCategories(final JsonReader reader, final UrlMatcher matcher) throws IOException {
         reader.beginObject();
 
+        // We ship 5 categories by default - so 5 is a good initial size
+        final Map<String, Trie> categoryMap = new ArrayMap<>(5);
+
         while (reader.hasNext()) {
             final String categoryName = reader.nextName();
 
-            extractCategory(reader);
+            final Trie categoryTrie = Trie.createRootNode();
+            extractCategory(reader, categoryTrie);
+
+            categoryMap.put(categoryName, categoryTrie);
         }
 
+        matcher.putCategories(categoryMap);
+
         reader.endObject();
     }
 
-    private void extractCategory(final JsonReader reader) throws IOException {
+    private static void extractCategory(final JsonReader reader, final Trie trie) throws IOException {
         reader.beginArray();
 
         while (reader.hasNext()) {
-            extractSite(reader);
+            extractSite(reader, trie);
         }
 
         reader.endArray();
     }
 
-    private void extractSite(final JsonReader reader) throws IOException {
+    private static void extractSite(final JsonReader reader, final Trie trie) throws IOException {
         reader.beginObject();
 
         final String siteName = reader.nextName();
@@ -77,7 +83,7 @@ private void extractSite(final JsonReader reader) throws IOException {
 
                     while (reader.hasNext()) {
                         final String blockURL = reader.nextString();
-                        matcher.putURL(blockURL);
+                        trie.put(FocusString.create(blockURL).reverse());
                     }
 
                     reader.endArray();
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
index 649451448550..4a7a54f3a0d6 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
@@ -6,6 +6,7 @@
 
 
 import android.content.Context;
+import android.support.v4.util.ArrayMap;
 import android.util.JsonReader;
 
 import org.mozilla.focus.webkit.matcher.util.FocusString;
@@ -16,13 +17,19 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 public class UrlMatcher {
 
-    private final Trie rootTrie = Trie.createRootNode();
+    private final Map<String, Trie> categories = new ArrayMap<>(5);
+    private final Set<String> enabledCategories = new HashSet<>();
 
     private final EntityList entityList;
+    // A cached list of previously matched URLs. This MUST be cleared whenever items are removed from enabledCategories.
     private final HashSet<String> previouslyMatched = new HashSet<>();
+    // A cahced list of previously approved URLs. This MUST be cleared whenever items are added to enabledCategories.
     private final HashSet<String> previouslyUnmatched = new HashSet<>();
 
     public UrlMatcher(final Context context, final int blockListFile, final int entityListFile) {
@@ -62,13 +69,57 @@ public UrlMatcher(final Context context, final int blockListFile, final int enti
 
     private void buildMatcher(String[] patterns) {
         // TODO: metrics for load time?
+        final Trie defaultCategory;
+        if (!categories.containsKey("default")) {
+            defaultCategory = Trie.createRootNode();
+        } else {
+            defaultCategory = categories.get("default");
+        }
+
         for (final String pattern : patterns) {
-            putURL(pattern);
+            defaultCategory.put(FocusString.create(pattern).reverse());
+        }
+    }
+
+    /* package-private */ void putCategories(final Map<String, Trie> categoryMap) {
+        for (final Map.Entry<String, Trie> entry: categoryMap.entrySet()) {
+            if (categories.containsKey(entry.getKey())) {
+                throw new IllegalStateException("Can't add existing category");
+            } else {
+                categories.put(entry.getKey(), entry.getValue());
+                // Failsafe: enable all categories
+                enabledCategories.add(entry.getKey());
+            }
         }
     }
 
-    /* package-private */ void putURL(final String url) {
-        rootTrie.put(FocusString.create(url).reverse());
+    public Set<String> getCategories() {
+        return categories.keySet();
+    }
+
+    public void setCategoryEnabled(final String category, final boolean enabled) {
+        if (!getCategories().contains(category)) {
+            throw new IllegalArgumentException("Can't enable/disable inexistant category");
+        }
+
+        if (enabled) {
+            if (enabledCategories.contains(category)) {
+                // Early return - nothing to do
+                return;
+            } else {
+                enabledCategories.add(category);
+                previouslyUnmatched.clear();
+            }
+        } else {
+            if (!enabledCategories.contains(category)) {
+                // Early return - nothing to do
+                return;
+            } else {
+                enabledCategories.remove(category);
+                previouslyMatched.clear();
+            }
+
+        }
     }
 
     public boolean matches(final String resourceURLString, final String pageURLString) {
@@ -83,7 +134,7 @@ public boolean matches(final String resourceURLString, final String pageURLStrin
 
         if (entityList != null &&
                 entityList.isWhiteListed(pageURLString, resourceURLString)) {
-            // We must not cache entityList items (abd/or if we did, we'd have to clear the cache
+            // We must not cache entityList items (and/or if we did, we'd have to clear the cache
             // on every single location change)
             return false;
         }
@@ -95,10 +146,16 @@ public boolean matches(final String resourceURLString, final String pageURLStrin
         try {
             final String host = new URL(resourceURLString).getHost().toString();
             final FocusString revhost = FocusString.create(host).reverse();
-            if (rootTrie.findNode(revhost) != null) {
-                previouslyMatched.add(resourceURLString);
-                return true;
+
+            for (final Map.Entry<String, Trie> category : categories.entrySet()) {
+                if (enabledCategories.contains(category.getKey())) {
+                    if (category.getValue().findNode(revhost) != null) {
+                        previouslyMatched.add(resourceURLString);
+                        return true;
+                    }
+                }
             }
+
         } catch (MalformedURLException e) {
             // In reality this should never happen - unless webkit were to pass us an invalid URL.
             // If we ever hit this in the wild, we might want to think our approach...
