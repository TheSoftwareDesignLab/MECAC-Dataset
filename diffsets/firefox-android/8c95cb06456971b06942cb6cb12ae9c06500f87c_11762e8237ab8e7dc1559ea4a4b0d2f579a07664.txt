diff --git a/focus-android/app/src/testWebkit/java/org/mozilla/focus/webkit/matcher/UrlMatcherTest.java b/focus-android/app/src/testWebkit/java/org/mozilla/focus/webkit/matcher/UrlMatcherTest.java
index 6930c5a62ab4..3c89a1b112e1 100644
--- a/focus-android/app/src/testWebkit/java/org/mozilla/focus/webkit/matcher/UrlMatcherTest.java
+++ b/focus-android/app/src/testWebkit/java/org/mozilla/focus/webkit/matcher/UrlMatcherTest.java
@@ -1,15 +1,25 @@
 package org.mozilla.focus.webkit.matcher;
 
+import android.app.Application;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+
+import junit.framework.Assert;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mozilla.focus.webkit.matcher.util.FocusString;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+import java.util.HashMap;
+import java.util.Map;
 
 import static org.junit.Assert.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class UrlMatcherTest {
 
-
     @Test
     public void matches() throws Exception {
         final UrlMatcher matcher = new UrlMatcher(new String[] {
@@ -33,4 +43,89 @@ public void matches() throws Exception {
         assertTrue(!matcher.matches("http://www.bcd.specific/something", "http://mozilla.org"));
     }
 
+    @Test
+    public void categoriesWork() {
+        // Test that category enabling/disabling works correctly. We test this by creating
+        // 4 categories, each with only one domain. We then iterate over all permutations of categories,
+        // and test that only the expected domains are actually blocked.
+        // (This is an important test, since we do some caching in UrlMatcher, and we need to make
+        // sure that the caching doesn't break when categories are enabled/disabled at runtime.)
+
+        final Map<String, Trie> categories = new HashMap<>();
+        final Map<String, String> categoryPrefMap = new HashMap<>();
+
+        // Number of categories we want to test with.
+        final int CAT_COUNT = 4;
+
+        final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(RuntimeEnvironment.application);
+
+        { // Setup for category tests
+            final SharedPreferences.Editor editor = preferences.edit();
+
+            for (int i = 0; i < CAT_COUNT; i++) {
+                final String domain = "category" + i + ".com";
+
+                final Trie trie = Trie.createRootNode();
+                trie.put(FocusString.create(domain).reverse());
+
+                final String categoryName = "category" + i;
+                categories.put(categoryName, trie);
+
+                editor.putBoolean(categoryName, false);
+
+                categoryPrefMap.put(categoryName, categoryName);
+            }
+            editor.commit();
+        }
+
+        final UrlMatcher matcher = new UrlMatcher(RuntimeEnvironment.application, categoryPrefMap, categories, null);
+
+        // We can test every permutation by iterating over every value of a 4-bit integer (each bit
+        // indicates whether a given category is enabled or disabled).
+
+        // N categories -> N bits == (2^N - 1) == '1111...'
+        // 4 categories -> 4 bits == 15 == 2^N-1 = '1111'
+
+        final int allEnabledPattern = (1 << CAT_COUNT) - 1;
+        for (int categoryPattern = 0; categoryPattern <= allEnabledPattern; categoryPattern++) {
+            final SharedPreferences.Editor editor = preferences.edit();
+
+            // Ensure all the correct categories enabled
+            for (int currentCategory = 0; currentCategory < CAT_COUNT; currentCategory++) {
+                final int currentBit = 1 << currentCategory;
+
+                final boolean enabled = ((currentBit & categoryPattern) == currentBit);
+
+                editor.putBoolean("category" + currentCategory, enabled);
+
+                // Sanity checks: just make sure our category enabling code actually sets the correct
+                // values for a few known combinations (i.e. we're doing a test within the test...)
+                if (categoryPattern == 0) {
+                    assertFalse("All categories should be disabled for categorypattern==0", enabled);
+                } else if (categoryPattern == allEnabledPattern) {
+                    assertTrue("All categories should be enabled for categorypattern=='111....'", enabled);
+                } else if (categoryPattern == Integer.parseInt("1100", 2)) {
+                    if (currentCategory < 2) {
+                        assertFalse("Categories 0/1 expected to be disabled", enabled);
+                    } else {
+                        assertTrue("Categories >= 2 expected to be enabled", enabled);
+                    }
+                }
+            }
+            editor.commit();
+
+            for (int currentCategory = 0; currentCategory < CAT_COUNT; currentCategory++) {
+                final int currentBit = 1 << currentCategory;
+
+                final boolean enabled = ((currentBit & categoryPattern) == currentBit);
+
+                final String url = "http://category" + currentCategory + ".com";
+
+                Assert.assertEquals("Incorrect category matched for combo=" + categoryPattern + " url=" + url,
+                        enabled, matcher.matches(url, "http://www.mozilla.org"));
+            }
+        }
+    }
+
+
 }
\ No newline at end of file
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
index 2e4943752898..52afd6247281 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
@@ -40,7 +40,7 @@ protected Void doInBackground(Void... voids) {
 
     @WorkerThread private static synchronized UrlMatcher getMatcher(final Context context) {
         if (MATCHER == null) {
-            MATCHER = new UrlMatcher(context, R.raw.blocklist, R.raw.entitylist);
+            MATCHER = UrlMatcher.loadMatcher(context, R.raw.blocklist, R.raw.entitylist);
         }
         return MATCHER;
     }
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
index bc715cc31609..7e9f0dec728d 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
@@ -11,11 +11,33 @@
 import org.mozilla.focus.webkit.matcher.util.FocusString;
 
 import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 public class BlocklistProcessor {
 
-    public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) throws IOException {
+    final static String SOCIAL = "Social";
+    final static String DISCONNECT = "Disconnect";
+
+    private static final Set<String> IGNORED_CATEGORIES;
+
+    static {
+        final Set<String> ignored = new HashSet<>();
+
+        ignored.add("Legacy Disconnect");
+        ignored.add("Legacy Content");
+
+        IGNORED_CATEGORIES = Collections.unmodifiableSet(ignored);
+    }
+
+    public static Map<String, Trie> loadCategoryMap(final JsonReader reader) throws IOException {
+        final Map<String, Trie> categoryMap = new HashMap<>(5);
+
         reader.beginObject();
 
         while (reader.hasNext()) {
@@ -24,7 +46,7 @@ public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) thr
             final String name = reader.nextName();
 
             if (name.equals("categories")) {
-                extractCategories(reader, matcher);
+                extractCategories(reader, categoryMap);
             } else {
                 reader.skipValue();
             }
@@ -32,39 +54,87 @@ public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) thr
         }
 
         reader.endObject();
+
+        return categoryMap;
     }
 
-    private static void extractCategories(final JsonReader reader, final UrlMatcher matcher) throws IOException {
+    private interface UrlListCallback {
+        void put(final String url);
+    }
+
+    private static class ListCallback implements UrlListCallback {
+        final List<String> list;
+
+        ListCallback(final List<String> list) {
+            this.list = list;
+        }
+
+        @Override
+        public void put(final String url) {
+            list.add(url);
+        }
+    }
+
+    private static class TrieCallback implements UrlListCallback {
+        final Trie trie;
+
+        TrieCallback(final Trie trie) {
+            this.trie = trie;
+        }
+
+        @Override
+        public void put(String url) {
+            trie.put(FocusString.create(url).reverse());
+        }
+    }
+
+    private static void extractCategories(final JsonReader reader, final Map<String, Trie> categoryMap) throws IOException {
         reader.beginObject();
 
-        // We ship 5 categories by default - so 5 is a good initial size
-        final Map<String, Trie> categoryMap = new ArrayMap<>(5);
+        final List<String> socialOverrides = new LinkedList<String>();
 
         while (reader.hasNext()) {
             final String categoryName = reader.nextName();
 
-            final Trie categoryTrie = Trie.createRootNode();
-            extractCategory(reader, categoryTrie);
+            if (IGNORED_CATEGORIES.contains(categoryName)) {
+                reader.skipValue();
+            } else if (categoryName.equals(DISCONNECT)) {
+                // We move these items into a different list, see below
+                ListCallback callback = new ListCallback(socialOverrides);
+                extractCategory(reader, callback);
+            } else {
+                final Trie categoryTrie = Trie.createRootNode();
+                final TrieCallback callback = new TrieCallback(categoryTrie);
 
-            categoryMap.put(categoryName, categoryTrie);
+                extractCategory(reader, callback);
+
+                categoryMap.put(categoryName, categoryTrie);
+            }
         }
 
-        matcher.putCategories(categoryMap);
+        final Trie socialTrie = categoryMap.get(SOCIAL);
+        if (socialTrie == null) {
+            throw new IllegalStateException("Expected social list to exist. Can't copy FB/Twitter into non-existing list");
+        }
+
+        for (final String url : socialOverrides) {
+            socialTrie.put(FocusString.create(url).reverse());
+        }
 
         reader.endObject();
     }
 
-    private static void extractCategory(final JsonReader reader, final Trie trie) throws IOException {
+    private static void extractCategory(final JsonReader reader, final UrlListCallback callback) throws IOException {
         reader.beginArray();
 
         while (reader.hasNext()) {
-            extractSite(reader, trie);
+            extractSite(reader, callback);
         }
 
         reader.endArray();
     }
 
-    private static void extractSite(final JsonReader reader, final Trie trie) throws IOException {
+    private static void extractSite(final JsonReader reader, final UrlListCallback callback) throws IOException {
         reader.beginObject();
 
         final String siteName = reader.nextName();
@@ -83,7 +153,7 @@ private static void extractSite(final JsonReader reader, final Trie trie) throws
 
                     while (reader.hasNext()) {
                         final String blockURL = reader.nextString();
-                        trie.put(FocusString.create(blockURL).reverse());
+                        callback.put(blockURL);
                     }
 
                     reader.endArray();
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
index 4a7a54f3a0d6..d40013443af9 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
@@ -6,9 +6,14 @@
 
 
 import android.content.Context;
-import android.support.v4.util.ArrayMap;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.JsonReader;
 
+import org.mozilla.focus.R;
 import org.mozilla.focus.webkit.matcher.util.FocusString;
 
 import java.io.IOException;
@@ -16,14 +21,32 @@
 import java.io.InputStreamReader;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-public class UrlMatcher {
+public class UrlMatcher implements  SharedPreferences.OnSharedPreferenceChangeListener {
+    /**
+     * Map of pref to blocking category (preference key -> Blocklist category name).
+     */
+    private final Map<String, String> categoryPrefMap;
 
-    private final Map<String, Trie> categories = new ArrayMap<>(5);
+    private static Map<String, String> loadDefaultPrefMap(final Context context) {
+        Map<String, String> tempMap = new HashMap<>(5);
+
+        tempMap.put(context.getString(R.string.pref_key_privacy_block_ads), "Advertising");
+        tempMap.put(context.getString(R.string.pref_key_privacy_block_analytics), "Analytics");
+        tempMap.put(context.getString(R.string.pref_key_privacy_block_social), "Social");
+        tempMap.put(context.getString(R.string.pref_key_privacy_block_other), "Content");
+
+//        tempMap.put(context.getString(R.string.pref_performance_block_webfonts), "Webfonts");
+
+        return Collections.unmodifiableMap(tempMap);
+    }
+
+    private final Map<String, Trie> categories;
     private final Set<String> enabledCategories = new HashSet<>();
 
     private final EntityList entityList;
@@ -32,13 +55,16 @@ public class UrlMatcher {
     // A cahced list of previously approved URLs. This MUST be cleared whenever items are added to enabledCategories.
     private final HashSet<String> previouslyUnmatched = new HashSet<>();
 
-    public UrlMatcher(final Context context, final int blockListFile, final int entityListFile) {
+    public static UrlMatcher loadMatcher(final Context context, final int blockListFile, final int entityListFile) {
+        final Map<String, String> categoryPrefMap = loadDefaultPrefMap(context);
+
+        final Map<String, Trie> categoryMap;
         {
             InputStream inputStream = context.getResources().openRawResource(blockListFile);
             JsonReader jsonReader = new JsonReader(new InputStreamReader(inputStream));
 
             try {
-                new BlocklistProcessor(jsonReader, this);
+                categoryMap = BlocklistProcessor.loadCategoryMap(jsonReader);
 
                 jsonReader.close();
             } catch (IOException e) {
@@ -46,6 +72,7 @@ public UrlMatcher(final Context context, final int blockListFile, final int enti
             }
         }
 
+        final EntityList entityList;
         {
             InputStream inputStream = context.getResources().openRawResource(entityListFile);
             JsonReader jsonReader = new JsonReader(new InputStreamReader(inputStream));
@@ -57,21 +84,74 @@ public UrlMatcher(final Context context, final int blockListFile, final int enti
             }
 
         }
+
+        return new UrlMatcher(context, categoryPrefMap, categoryMap, entityList);
+    }
+
+    /* package-private */ UrlMatcher(final Context context,
+                                     @NonNull final Map<String, String> categoryPrefMap,
+                                     @NonNull final Map<String, Trie> categoryMap,
+                                     @Nullable final EntityList entityList) {
+        this.categoryPrefMap = categoryPrefMap;
+        this.entityList = entityList;
+        this.categories = categoryMap;
+
+        // Ensure all categories have been declared, and enable by default (loadPrefs() will then
+        // enabled/disable categories that have actually been configured).
+        for (final Map.Entry<String, Trie> entry: categoryMap.entrySet()) {
+            if (!categoryPrefMap.values().contains(entry.getKey())) {
+                throw new IllegalArgumentException("categoryMap contains undeclared category");
+            }
+
+            // Failsafe: enable all categories (we load preferences in the next step anyway)
+            enabledCategories.add(entry.getKey());
+        }
+
+        loadPrefs(context);
+
+        PreferenceManager.getDefaultSharedPreferences(context).registerOnSharedPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(final SharedPreferences sharedPreferences, final String prefName) {
+        final boolean prefValue = sharedPreferences.getBoolean(prefName, false);
+
+        final String categoryName = categoryPrefMap.get(prefName);
+        if (categoryName != null) {
+            setCategoryEnabled(categoryName, prefValue);
+        }
     }
 
+    private void loadPrefs(final Context context) {
+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+
+        for (final Map.Entry<String, String> entry : categoryPrefMap.entrySet()) {
+            final boolean prefValue = prefs.getBoolean(entry.getKey(), true);
+            setCategoryEnabled(entry.getValue(), prefValue);
+        }
+    }
+
+    @VisibleForTesting UrlMatcher(final String[] patterns) {
+        final Map<String, String> map = new HashMap<>();
+        map.put("default", "default");
+        categoryPrefMap = Collections.unmodifiableMap(map);
+
+        categories = new HashMap<>();
 
-    /* Test-only */
-    /* package-private */ UrlMatcher(final String[] patterns) {
         buildMatcher(patterns);
 
         entityList = null;
     }
 
+    /**
+     * Only used for testing - uses a list of urls to populate a "default" category.
+     * @param patterns
+     */
     private void buildMatcher(String[] patterns) {
-        // TODO: metrics for load time?
         final Trie defaultCategory;
         if (!categories.containsKey("default")) {
             defaultCategory = Trie.createRootNode();
+            categories.put("default", defaultCategory);
         } else {
             defaultCategory = categories.get("default");
         }
@@ -79,18 +159,8 @@ private void buildMatcher(String[] patterns) {
         for (final String pattern : patterns) {
             defaultCategory.put(FocusString.create(pattern).reverse());
         }
-    }
 
-    /* package-private */ void putCategories(final Map<String, Trie> categoryMap) {
-        for (final Map.Entry<String, Trie> entry: categoryMap.entrySet()) {
-            if (categories.containsKey(entry.getKey())) {
-                throw new IllegalStateException("Can't add existing category");
-            } else {
-                categories.put(entry.getKey(), entry.getValue());
-                // Failsafe: enable all categories
-                enabledCategories.add(entry.getKey());
-            }
-        }
+        enabledCategories.add("default");
     }
 
     public Set<String> getCategories() {
@@ -104,7 +174,7 @@ public void setCategoryEnabled(final String category, final boolean enabled) {
 
         if (enabled) {
             if (enabledCategories.contains(category)) {
-                // Early return - nothing to do
+                // Early return - nothing to do if the category is already enabled
                 return;
             } else {
                 enabledCategories.add(category);
@@ -112,7 +182,7 @@ public void setCategoryEnabled(final String category, final boolean enabled) {
             }
         } else {
             if (!enabledCategories.contains(category)) {
-                // Early return - nothing to do
+                // Early return - nothing to do if the category is already disabled
                 return;
             } else {
                 enabledCategories.remove(category);
