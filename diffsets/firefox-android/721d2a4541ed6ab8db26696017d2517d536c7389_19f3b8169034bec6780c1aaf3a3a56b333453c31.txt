diff --git a/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragment.kt
index 5b4d0aa992f5..399d46ca86d6 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragment.kt
@@ -4,8 +4,10 @@
 
 package org.mozilla.fenix.settings.sitepermissions
 
+import android.content.Context
 import android.content.DialogInterface
 import android.os.Bundle
+import androidx.annotation.VisibleForTesting
 import androidx.appcompat.app.AlertDialog
 import androidx.lifecycle.lifecycleScope
 import androidx.navigation.findNavController
@@ -19,6 +21,7 @@ import mozilla.components.feature.sitepermissions.SitePermissions
 import org.mozilla.fenix.R
 import org.mozilla.fenix.ext.components
 import org.mozilla.fenix.ext.requireComponents
+import org.mozilla.fenix.ext.settings
 import org.mozilla.fenix.ext.showToolbar
 import org.mozilla.fenix.settings.PhoneFeature
 import org.mozilla.fenix.settings.PhoneFeature.CAMERA
@@ -27,10 +30,15 @@ import org.mozilla.fenix.settings.PhoneFeature.MICROPHONE
 import org.mozilla.fenix.settings.PhoneFeature.NOTIFICATION
 import org.mozilla.fenix.settings.PhoneFeature.PERSISTENT_STORAGE
 import org.mozilla.fenix.settings.PhoneFeature.MEDIA_KEY_SYSTEM_ACCESS
+import org.mozilla.fenix.settings.PhoneFeature.AUTOPLAY
+import org.mozilla.fenix.settings.quicksettings.AutoplayValue
 import org.mozilla.fenix.settings.requirePreference
+import org.mozilla.fenix.utils.Settings
 
+@SuppressWarnings("TooManyFunctions")
 class SitePermissionsDetailsExceptionsFragment : PreferenceFragmentCompat() {
-    private lateinit var sitePermissions: SitePermissions
+    @VisibleForTesting
+    internal lateinit var sitePermissions: SitePermissions
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
@@ -54,19 +62,22 @@ class SitePermissionsDetailsExceptionsFragment : PreferenceFragmentCompat() {
         }
     }
 
-    private fun bindCategoryPhoneFeatures() {
+    @VisibleForTesting
+    internal fun bindCategoryPhoneFeatures() {
         initPhoneFeature(CAMERA)
         initPhoneFeature(LOCATION)
         initPhoneFeature(MICROPHONE)
         initPhoneFeature(NOTIFICATION)
         initPhoneFeature(PERSISTENT_STORAGE)
         initPhoneFeature(MEDIA_KEY_SYSTEM_ACCESS)
+        initAutoplayFeature()
         bindClearPermissionsButton()
     }
 
-    private fun initPhoneFeature(phoneFeature: PhoneFeature) {
-        val summary = phoneFeature.getActionLabel(requireContext(), sitePermissions)
-        val cameraPhoneFeatures = requirePreference<Preference>(phoneFeature.getPreferenceId())
+    @VisibleForTesting
+    internal fun initPhoneFeature(phoneFeature: PhoneFeature) {
+        val summary = phoneFeature.getActionLabel(provideContext(), sitePermissions)
+        val cameraPhoneFeatures = getPreference(phoneFeature)
         cameraPhoneFeatures.summary = summary
 
         cameraPhoneFeatures.onPreferenceClickListener = Preference.OnPreferenceClickListener {
@@ -75,7 +86,44 @@ class SitePermissionsDetailsExceptionsFragment : PreferenceFragmentCompat() {
         }
     }
 
-    private fun bindClearPermissionsButton() {
+    @VisibleForTesting
+    internal fun getPreference(phoneFeature: PhoneFeature): Preference =
+        requirePreference(phoneFeature.getPreferenceId())
+
+    @VisibleForTesting
+    internal fun provideContext(): Context = requireContext()
+
+    @VisibleForTesting
+    internal fun provideSettings(): Settings = provideContext().settings()
+
+    @VisibleForTesting
+    internal fun initAutoplayFeature() {
+        val phoneFeature = getPreference(AUTOPLAY)
+        phoneFeature.summary = getAutoplayLabel()
+
+        phoneFeature.onPreferenceClickListener = Preference.OnPreferenceClickListener {
+            navigateToPhoneFeature(AUTOPLAY)
+            true
+        }
+    }
+
+    @VisibleForTesting
+    internal fun getAutoplayLabel(): String {
+        val context = provideContext()
+        val settings = provideSettings()
+        val autoplayValues = AutoplayValue.values(context, settings, sitePermissions)
+        val selected =
+            autoplayValues.firstOrNull { it.isSelected() } ?: AutoplayValue.getFallbackValue(
+                context,
+                settings,
+                sitePermissions
+            )
+
+        return selected.label
+    }
+
+    @VisibleForTesting
+    internal fun bindClearPermissionsButton() {
         val button: Preference = requirePreference(R.string.pref_key_exceptions_clear_site_permissions)
 
         button.onPreferenceClickListener = Preference.OnPreferenceClickListener {
@@ -106,7 +154,8 @@ class SitePermissionsDetailsExceptionsFragment : PreferenceFragmentCompat() {
         }
     }
 
-    private fun navigateToPhoneFeature(phoneFeature: PhoneFeature) {
+    @VisibleForTesting
+    internal fun navigateToPhoneFeature(phoneFeature: PhoneFeature) {
         val directions =
             SitePermissionsDetailsExceptionsFragmentDirections.actionSitePermissionsToExceptionsToManagePhoneFeature(
                 phoneFeature = phoneFeature,
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragment.kt
index 110fc2bda8fd..dab4a76e80f2 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragment.kt
@@ -14,7 +14,10 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.Button
 import android.widget.RadioButton
+import androidx.annotation.IdRes
+import androidx.annotation.VisibleForTesting
 import androidx.appcompat.app.AlertDialog
+import androidx.core.view.isVisible
 import androidx.fragment.app.Fragment
 import androidx.lifecycle.lifecycleScope
 import androidx.navigation.fragment.navArgs
@@ -27,8 +30,11 @@ import org.mozilla.fenix.R
 import org.mozilla.fenix.ext.requireComponents
 import org.mozilla.fenix.ext.settings
 import org.mozilla.fenix.ext.showToolbar
+import org.mozilla.fenix.settings.PhoneFeature
+import org.mozilla.fenix.settings.quicksettings.AutoplayValue
 import org.mozilla.fenix.settings.setStartCheckedIndicator
 import org.mozilla.fenix.settings.update
+import org.mozilla.fenix.utils.Settings
 
 @SuppressWarnings("TooManyFunctions")
 class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
@@ -36,13 +42,14 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
     private lateinit var radioAllow: RadioButton
     private lateinit var radioBlock: RadioButton
     private lateinit var blockedByAndroidView: View
+    @VisibleForTesting
+    internal lateinit var rootView: View
     private val args by navArgs<SitePermissionsManageExceptionsPhoneFeatureFragmentArgs>()
-    val settings by lazy { requireContext().settings() }
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
 
-        showToolbar(args.phoneFeature.getLabel(requireContext()))
+        showToolbar(getFeature().getLabel(requireContext()))
     }
 
     override fun onCreateView(
@@ -50,20 +57,62 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
         container: ViewGroup?,
         savedInstanceState: Bundle?
     ): View? {
-        val rootView =
+        rootView =
             inflater.inflate(R.layout.fragment_manage_site_permissions_exceptions_feature_phone, container, false)
 
-        initAskToAllowRadio(rootView)
-        initBlockRadio(rootView)
-        bindBlockedByAndroidContainer(rootView)
-        initClearPermissionsButton(rootView)
+        if (getFeature() == PhoneFeature.AUTOPLAY) {
+            initAutoplay(getSitePermission())
+        } else {
+            initNormalFeature()
+        }
 
+        bindBlockedByAndroidContainer()
+        initClearPermissionsButton()
         return rootView
     }
 
+    @VisibleForTesting
+    internal fun getFeature(): PhoneFeature = args.phoneFeature
+
+    @VisibleForTesting
+    internal fun getSitePermission(): SitePermissions = args.sitePermissions
+
+    @VisibleForTesting
+    internal fun getSettings(): Settings = requireContext().settings()
+
+    fun initAutoplay(sitePermissions: SitePermissions? = null) {
+        val context = requireContext()
+        val autoplayValues = AutoplayValue.values(context, getSettings(), sitePermissions)
+        val allowAudioAndVideo =
+            requireNotNull(autoplayValues.find { it is AutoplayValue.AllowAll })
+        val blockAll = requireNotNull(autoplayValues.find { it is AutoplayValue.BlockAll })
+        val blockAudible = requireNotNull(autoplayValues.find { it is AutoplayValue.BlockAudible })
+
+        initAutoplayOption(R.id.ask_to_allow_radio, allowAudioAndVideo)
+        initAutoplayOption(R.id.block_radio, blockAll)
+        initAutoplayOption(R.id.optional_radio, blockAudible)
+    }
+
+    fun initNormalFeature() {
+        initAskToAllowRadio(rootView)
+        initBlockRadio()
+    }
+
     override fun onResume() {
         super.onResume()
-        initBlockedByAndroidView(args.phoneFeature, blockedByAndroidView)
+        initBlockedByAndroidView(getFeature(), blockedByAndroidView)
+    }
+
+    @VisibleForTesting
+    internal fun initAutoplayOption(@IdRes viewId: Int, value: AutoplayValue) {
+        val radio = rootView.findViewById<RadioButton>(viewId)
+        radio.isVisible = true
+        radio.text = value.label
+
+        radio.setOnClickListener {
+            updatedSitePermissions(value)
+        }
+        radio.restoreState(value)
     }
 
     private fun initAskToAllowRadio(rootView: View) {
@@ -79,13 +128,22 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
     }
 
     private fun RadioButton.restoreState(status: SitePermissions.Status) {
-        if (args.phoneFeature.getStatus(args.sitePermissions) == status) {
+        val permissionsStatus = getFeature().getStatus(getSitePermission())
+        if (permissionsStatus != SitePermissions.Status.NO_DECISION && permissionsStatus == status) {
             this.isChecked = true
             this.setStartCheckedIndicator()
         }
     }
 
-    private fun initBlockRadio(rootView: View) {
+    @VisibleForTesting
+    internal fun RadioButton.restoreState(autoplayValue: AutoplayValue) {
+        if (autoplayValue.isSelected()) {
+            this.isChecked = true
+            this.setStartCheckedIndicator()
+        }
+    }
+
+    private fun initBlockRadio() {
         radioBlock = rootView.findViewById(R.id.block_radio)
         radioBlock.setOnClickListener {
             updatedSitePermissions(BLOCKED)
@@ -93,7 +151,8 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
         radioBlock.restoreState(BLOCKED)
     }
 
-    private fun initClearPermissionsButton(rootView: View) {
+    @VisibleForTesting
+    internal fun initClearPermissionsButton() {
         val button = rootView.findViewById<Button>(R.id.reset_permission)
         button.setText(R.string.clear_permission)
         button.setOnClickListener {
@@ -101,9 +160,7 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
                 setMessage(R.string.confirm_clear_permission_site)
                 setTitle(R.string.clear_permission)
                 setPositiveButton(android.R.string.yes) { dialog: DialogInterface, _ ->
-                    val defaultStatus = args.phoneFeature.getStatus(settings = settings)
-                    updatedSitePermissions(defaultStatus)
-                    resetRadioButtonsStatus(defaultStatus)
+                    clearPermissions()
                     dialog.dismiss()
                 }
                 setNegativeButton(android.R.string.no) { dialog: DialogInterface, _ ->
@@ -113,6 +170,34 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
         }
     }
 
+    private fun clearPermissions() {
+        if (getFeature() == PhoneFeature.AUTOPLAY) {
+            clearAutoplayPermissions()
+        } else {
+            clearNormalPermissions()
+        }
+    }
+
+    private fun clearAutoplayPermissions() {
+        val context = requireContext()
+        val settings = context.settings()
+        val defaultValue =
+            AutoplayValue.values(context, settings, null).firstOrNull { it.isSelected() }
+                ?: AutoplayValue.getFallbackValue(
+                    context,
+                    settings,
+                    null
+                )
+        updatedSitePermissions(defaultValue)
+        initAutoplay()
+    }
+
+    private fun clearNormalPermissions() {
+        val defaultStatus = getFeature().getStatus(settings = getSettings())
+        updatedSitePermissions(defaultStatus)
+        resetRadioButtonsStatus(defaultStatus)
+    }
+
     private fun resetRadioButtonsStatus(defaultStatus: SitePermissions.Status) {
         radioAllow.isChecked = false
         radioBlock.isChecked = false
@@ -120,7 +205,8 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
         radioBlock.restoreState(defaultStatus)
     }
 
-    private fun bindBlockedByAndroidContainer(rootView: View) {
+    @VisibleForTesting
+    internal fun bindBlockedByAndroidContainer() {
         blockedByAndroidView = rootView.findViewById<View>(R.id.permissions_blocked_container)
         initSettingsButton(blockedByAndroidView)
     }
@@ -140,7 +226,16 @@ class SitePermissionsManageExceptionsPhoneFeatureFragment : Fragment() {
     }
 
     private fun updatedSitePermissions(status: SitePermissions.Status) {
-        val updatedSitePermissions = args.sitePermissions.update(args.phoneFeature, status)
+        val updatedSitePermissions = getSitePermission().update(getFeature(), status)
+        viewLifecycleOwner.lifecycleScope.launch(Main) {
+            requireComponents.core.permissionStorage.updateSitePermissions(updatedSitePermissions)
+            requireComponents.tryReloadTabBy(updatedSitePermissions.origin)
+        }
+    }
+
+    @VisibleForTesting
+    internal fun updatedSitePermissions(autoplayValue: AutoplayValue) {
+        val updatedSitePermissions = autoplayValue.updateSitePermissions(getSitePermission())
         viewLifecycleOwner.lifecycleScope.launch(Main) {
             requireComponents.core.permissionStorage.updateSitePermissions(updatedSitePermissions)
             requireComponents.tryReloadTabBy(updatedSitePermissions.origin)
diff --git a/fenix/app/src/main/res/layout/fragment_manage_site_permissions_exceptions_feature_phone.xml b/fenix/app/src/main/res/layout/fragment_manage_site_permissions_exceptions_feature_phone.xml
index 5da0ca90d893..2948c0b8e3e3 100644
--- a/fenix/app/src/main/res/layout/fragment_manage_site_permissions_exceptions_feature_phone.xml
+++ b/fenix/app/src/main/res/layout/fragment_manage_site_permissions_exceptions_feature_phone.xml
@@ -45,6 +45,22 @@
                 android:paddingStart="@dimen/radio_button_preference_horizontal"
                 android:paddingEnd="@dimen/radio_button_preference_horizontal"
                 android:paddingBottom="@dimen/radio_button_preference_vertical" />
+
+            <RadioButton
+                android:id="@+id/optional_radio"
+                android:layout_width="match_parent"
+                android:layout_height="@dimen/radio_button_preference_height"
+                android:text="@string/preference_option_phone_feature_blocked"
+                android:textAppearance="?android:attr/textAppearanceListItem"
+                android:background="?android:attr/selectableItemBackground"
+                android:button="@null"
+                android:visibility="gone"
+                app:drawableStartCompat="?android:attr/listChoiceIndicatorSingle"
+                android:drawablePadding="@dimen/radio_button_preference_drawable_padding"
+                android:paddingTop="@dimen/radio_button_preference_vertical"
+                android:paddingStart="@dimen/radio_button_preference_horizontal"
+                android:paddingEnd="@dimen/radio_button_preference_horizontal"
+                android:paddingBottom="@dimen/radio_button_preference_vertical" />
         </RadioGroup>
 
         <include layout="@layout/layout_clear_permission_button"/>
diff --git a/fenix/app/src/main/res/values/preference_keys.xml b/fenix/app/src/main/res/values/preference_keys.xml
index 073b48bf5b98..3c4734636aea 100644
--- a/fenix/app/src/main/res/values/preference_keys.xml
+++ b/fenix/app/src/main/res/values/preference_keys.xml
@@ -108,6 +108,7 @@
     <string name="pref_key_show_site_exceptions" translatable="false">pref_key_show_site_exceptions</string>
     <string name="pref_key_recommended_settings" translatable="false">pref_key_recommended_settings</string>
     <string name="pref_key_custom_settings" translatable="false">pref_key_custom_settings</string>
+    <string name="pref_key_browser_feature_autoplay" translatable="false">pref_key_browser_feature_autoplay</string>
     <string name="pref_key_browser_feature_autoplay_audible" translatable="false">pref_key_browser_feature_autoplay</string>
     <string name="pref_key_browser_feature_autoplay_inaudible" translatable="false">pref_key_browser_feature_autoplay_inaudible</string>
     <string name="pref_key_browser_feature_persistent_storage" translatable="false">pref_key_browser_feature_persistent_storage</string>
diff --git a/fenix/app/src/main/res/xml/site_permissions_details_exceptions_preferences.xml b/fenix/app/src/main/res/xml/site_permissions_details_exceptions_preferences.xml
index 8513deb5e403..9b8c85283e5b 100644
--- a/fenix/app/src/main/res/xml/site_permissions_details_exceptions_preferences.xml
+++ b/fenix/app/src/main/res/xml/site_permissions_details_exceptions_preferences.xml
@@ -40,6 +40,12 @@
         android:title="@string/preference_phone_feature_media_key_system_access"
         android:summary="@string/preference_option_phone_feature_ask_to_allow"/>
 
+    <androidx.preference.Preference
+        android:icon="@drawable/ic_autoplay"
+        android:key="@string/pref_key_browser_feature_autoplay"
+        android:title="@string/preference_browser_feature_autoplay"
+        android:summary="@string/preference_option_phone_feature_ask_to_allow"/>
+
     <androidx.preference.Preference
             android:key="@string/pref_key_exceptions_clear_site_permissions"
             android:layout="@layout/layout_clear_permission_button"/>
diff --git a/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragmentTest.kt b/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragmentTest.kt
new file mode 100644
index 000000000000..262cd08d97bc
--- /dev/null
+++ b/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsDetailsExceptionsFragmentTest.kt
@@ -0,0 +1,106 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.fenix.settings.sitepermissions
+
+import androidx.preference.Preference
+import io.mockk.MockKAnnotations
+import io.mockk.every
+import io.mockk.impl.annotations.MockK
+import io.mockk.spyk
+import io.mockk.verify
+import mozilla.components.feature.sitepermissions.SitePermissions
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mozilla.fenix.helpers.FenixRobolectricTestRunner
+import org.mozilla.fenix.settings.PhoneFeature
+import org.mozilla.fenix.utils.Settings
+
+@RunWith(FenixRobolectricTestRunner::class)
+class SitePermissionsDetailsExceptionsFragmentTest {
+    @MockK(relaxed = true)
+    private lateinit var settings: Settings
+
+    @MockK(relaxed = true)
+    private lateinit var permissions: SitePermissions
+
+    private lateinit var fragment: SitePermissionsDetailsExceptionsFragment
+
+    @Before
+    fun setup() {
+        MockKAnnotations.init(this)
+        fragment = spyk(SitePermissionsDetailsExceptionsFragment())
+
+        fragment.sitePermissions = permissions
+
+        every { permissions.origin } returns "mozilla.org"
+        every { fragment.provideContext() } returns testContext
+        every { fragment.provideSettings() } returns settings
+    }
+
+    @Test
+    fun `WHEN bindCategoryPhoneFeatures is called THEN all categories must be initialized`() {
+
+        every { fragment.initPhoneFeature(any()) } returns Unit
+        every { fragment.initAutoplayFeature() } returns Unit
+        every { fragment.bindClearPermissionsButton() } returns Unit
+
+        fragment.bindCategoryPhoneFeatures()
+
+        verify {
+            fragment.initPhoneFeature(PhoneFeature.CAMERA)
+            fragment.initPhoneFeature(PhoneFeature.LOCATION)
+            fragment.initPhoneFeature(PhoneFeature.MICROPHONE)
+            fragment.initPhoneFeature(PhoneFeature.NOTIFICATION)
+            fragment.initPhoneFeature(PhoneFeature.PERSISTENT_STORAGE)
+            fragment.initPhoneFeature(PhoneFeature.MEDIA_KEY_SYSTEM_ACCESS)
+            fragment.initAutoplayFeature()
+            fragment.bindClearPermissionsButton()
+        }
+    }
+
+    @Test
+    fun `WHEN initPhoneFeature is called THEN the feature label must be bind and a click listener must be attached`() {
+        val feature = spyk(PhoneFeature.CAMERA)
+        val label = "label"
+        val preference = spyk(Preference(testContext))
+
+        every { feature.getActionLabel(any(), any()) } returns label
+        every { fragment.getPreference((any())) } returns preference
+        every { fragment.navigateToPhoneFeature((any())) } returns Unit
+
+        fragment.initPhoneFeature(feature)
+
+        assertEquals(label, preference.summary)
+
+        preference.performClick()
+
+        verify {
+            fragment.navigateToPhoneFeature(feature)
+        }
+    }
+
+    @Test
+    fun `WHEN initAutoplayFeature THEN the autoplay label must be bind and a click listener must be attached`() {
+        val label = "label"
+        val preference = spyk(Preference(testContext))
+
+        every { fragment.getAutoplayLabel() } returns label
+        every { fragment.getPreference((any())) } returns preference
+        every { fragment.navigateToPhoneFeature((any())) } returns Unit
+
+        fragment.initAutoplayFeature()
+
+        assertEquals(label, preference.summary)
+
+        preference.performClick()
+
+        verify {
+            fragment.navigateToPhoneFeature(PhoneFeature.AUTOPLAY)
+        }
+    }
+}
diff --git a/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragmentTest.kt b/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragmentTest.kt
new file mode 100644
index 000000000000..76450ce1899e
--- /dev/null
+++ b/fenix/app/src/test/java/org/mozilla/fenix/settings/sitepermissions/SitePermissionsManageExceptionsPhoneFeatureFragmentTest.kt
@@ -0,0 +1,538 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.fenix.settings.sitepermissions
+
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.RadioButton
+import androidx.core.view.isVisible
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.spyk
+import io.mockk.verify
+import io.mockk.MockKAnnotations
+import io.mockk.impl.annotations.MockK
+import mozilla.components.feature.sitepermissions.SitePermissions
+import mozilla.components.feature.sitepermissions.SitePermissions.AutoplayStatus
+import mozilla.components.feature.sitepermissions.SitePermissionsRules
+import mozilla.components.feature.sitepermissions.SitePermissionsRules.AutoplayAction
+import mozilla.components.feature.sitepermissions.SitePermissionsRules.Action
+import mozilla.components.support.test.mock
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertTrue
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mozilla.fenix.R
+import org.mozilla.fenix.helpers.FenixRobolectricTestRunner
+import org.mozilla.fenix.settings.PhoneFeature
+import org.mozilla.fenix.settings.quicksettings.AutoplayValue
+import org.mozilla.fenix.utils.Settings
+
+@RunWith(FenixRobolectricTestRunner::class)
+class SitePermissionsManageExceptionsPhoneFeatureFragmentTest {
+    @MockK(relaxed = true)
+    private lateinit var settings: Settings
+
+    @MockK(relaxed = true)
+    private lateinit var permissions: SitePermissions
+
+    private lateinit var fragment: SitePermissionsManageExceptionsPhoneFeatureFragment
+
+    @Before
+    fun setup() {
+        MockKAnnotations.init(this)
+
+        fragment = spyk(SitePermissionsManageExceptionsPhoneFeatureFragment())
+        fragment.rootView = mockk(relaxed = true)
+
+        every { fragment.requireContext() } returns testContext
+        every { fragment.getSettings() } returns settings
+    }
+
+    @Test
+    fun `GIVEN an AUTOPLAY permission WHEN onCreateView is called THEN initAutoplay is called`() {
+        every { fragment.getFeature() } returns PhoneFeature.AUTOPLAY
+        every { fragment.initAutoplay(permissions) } returns Unit
+        every { fragment.getSitePermission() } returns permissions
+
+        fragment.onCreateView(LayoutInflater.from(testContext), null, null)
+
+        verify {
+            fragment.initAutoplay(permissions)
+            fragment.bindBlockedByAndroidContainer()
+            fragment.initClearPermissionsButton()
+        }
+    }
+
+    @Test
+    fun `GIVEN a none AUTOPLAY permission WHEN onCreateView is called THEN initNormalFeature is called`() {
+        val features = PhoneFeature.values().filter { it != PhoneFeature.AUTOPLAY }
+
+        features.forEach {
+            every { fragment.getFeature() } returns it
+            every { fragment.initNormalFeature() } returns Unit
+            every { fragment.getSitePermission() } returns permissions
+
+            fragment.onCreateView(LayoutInflater.from(testContext), null, null)
+
+            verify {
+                fragment.initNormalFeature()
+                fragment.bindBlockedByAndroidContainer()
+                fragment.initClearPermissionsButton()
+            }
+        }
+    }
+
+    @Test
+    fun `WHEN initAutoplay is called THEN AllowAll, BlockAll and BlockAudible radio options will be configure`() {
+        every { fragment.initAutoplayOption(any(), any()) } returns Unit
+        every { fragment.getSitePermission() } returns permissions
+        every { settings.getSitePermissionsCustomSettingsRules() } returns getRules()
+
+        fragment.initAutoplay()
+
+        verify {
+            fragment.initAutoplayOption(R.id.ask_to_allow_radio, any<AutoplayValue.AllowAll>())
+            fragment.initAutoplayOption(R.id.block_radio, any<AutoplayValue.BlockAll>())
+            fragment.initAutoplayOption(R.id.optional_radio, any<AutoplayValue.BlockAudible>())
+        }
+    }
+
+    @Test
+    fun `WHEN initAutoplayOption is called THEN the radio button will visible and a click listener will be attached`() {
+        val radioButton = spyk(RadioButton(testContext))
+        val rootView = mockk<View>()
+        val autoplayValue = mockk<AutoplayValue>(relaxed = true)
+
+        radioButton.isVisible = false
+
+        fragment.rootView = rootView
+        every { rootView.findViewById<View>(any()) } returns radioButton
+        every { autoplayValue.label } returns "label"
+        with(fragment) {
+            every { updatedSitePermissions(any()) } returns Unit
+            every { any<RadioButton>().restoreState(any()) } returns Unit
+        }
+
+        fragment.initAutoplayOption(R.id.ask_to_allow_radio, autoplayValue)
+
+        assertTrue(radioButton.isVisible)
+        assertEquals(autoplayValue.label, radioButton.text)
+
+        with(fragment) {
+            verify {
+                any<RadioButton>().restoreState(autoplayValue)
+            }
+        }
+    }
+
+    @Test
+    fun `GIVEN a AllowAll value with autoplayAudible and autoplayInaudible rules are ALLOWED WHEN isSelected is called THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.ALLOWED,
+            autoplayInaudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a AllowAll value with autoplayAudible ALLOWED and autoplayInaudible BLOCKED rules WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.ALLOWED,
+            autoplayAudible = AutoplayAction.BLOCKED
+        )
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a AllowAll value with sitePermission autoplayAudible and autoplayInaudible are ALLOWED WHEN isSelected is called THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.ALLOWED,
+            autoplayAudible = AutoplayAction.BLOCKED
+        )
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.ALLOWED,
+                autoplayInaudible = AutoplayStatus.ALLOWED
+            )
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a AllowAll value with sitePermission autoplayAudible and autoplayInaudible are BLOCKED WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.ALLOWED,
+            autoplayAudible = AutoplayAction.BLOCKED
+        )
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.BLOCKED,
+                autoplayInaudible = AutoplayStatus.BLOCKED
+            )
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAll value with autoplayAudible and autoplayInaudible rules are BLOCKED WHEN isSelected is called THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.BLOCKED,
+            autoplayInaudible = AutoplayAction.BLOCKED
+        )
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAll value with autoplayInaudible BLOCKED and autoplayAudible ALLOWED rules WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAll value with sitePermission autoplayAudible and autoplayInaudible are BLOCKED WHEN isSelected THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.BLOCKED,
+                autoplayInaudible = AutoplayStatus.BLOCKED
+            )
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAll value with sitePermission autoplayAudible ALLOWED and autoplayInaudible BLOCKED WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.ALLOWED,
+                autoplayInaudible = AutoplayStatus.BLOCKED
+            )
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible value with autoplayAudible BLOCKED and autoplayInaudible ALLOWED rules WHEN isSelected is called THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.BLOCKED,
+            autoplayInaudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible value with autoplayInaudible and autoplayAudible BLOCKED rules WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.BLOCKED
+        )
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible with sitePermission autoplayAudible BLOCKED and autoplayInaudible ALLOWED WHEN isSelected is called THEN isSelected will be true`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.BLOCKED,
+                autoplayInaudible = AutoplayStatus.ALLOWED
+            )
+        )
+
+        assertTrue(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible with sitePermission autoplayAudible ALLOWED and autoplayInaudible BLOCKED WHEN isSelected is called THEN isSelected will be false`() {
+        val rules = getRules().copy(
+            autoplayInaudible = AutoplayAction.BLOCKED,
+            autoplayAudible = AutoplayAction.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = rules,
+            sitePermission = SitePermissions(
+                origin = "",
+                savedAt = 0L,
+                autoplayAudible = AutoplayStatus.ALLOWED,
+                autoplayInaudible = AutoplayStatus.BLOCKED
+            )
+        )
+
+        assertFalse(value.isSelected())
+    }
+
+    @Test
+    fun `GIVEN a AllowAll WHEN createSitePermissionsFromCustomRules is called THEN rules will included autoplayAudible and autoplayInaudible ALLOWED`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.BLOCKED,
+            autoplayInaudible = AutoplayAction.BLOCKED
+        )
+
+        every { settings.getSitePermissionsCustomSettingsRules() } returns rules
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        val result = value.createSitePermissionsFromCustomRules("mozilla.org", settings)
+
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayInaudible)
+        assertEquals(rules.camera.toStatus(), result.camera)
+        assertEquals(rules.location.toStatus(), result.location)
+        assertEquals(rules.microphone.toStatus(), result.microphone)
+        assertEquals(rules.notification.toStatus(), result.notification)
+        assertEquals(rules.persistentStorage.toStatus(), result.localStorage)
+        assertEquals(rules.mediaKeySystemAccess.toStatus(), result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `GIVEN a BlockAll WHEN createSitePermissionsFromCustomRules is called THEN rules will included autoplayAudible and autoplayInaudible BLOCKED`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.ALLOWED,
+            autoplayInaudible = AutoplayAction.ALLOWED
+        )
+
+        every { settings.getSitePermissionsCustomSettingsRules() } returns rules
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        val result = value.createSitePermissionsFromCustomRules("mozilla.org", settings)
+
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayInaudible)
+        assertEquals(rules.camera.toStatus(), result.camera)
+        assertEquals(rules.location.toStatus(), result.location)
+        assertEquals(rules.microphone.toStatus(), result.microphone)
+        assertEquals(rules.notification.toStatus(), result.notification)
+        assertEquals(rules.persistentStorage.toStatus(), result.localStorage)
+        assertEquals(rules.mediaKeySystemAccess.toStatus(), result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible WHEN createSitePermissionsFromCustomRules is called THEN rules will included autoplayAudible BLOCKED and autoplayInaudible ALLOWED`() {
+        val rules = getRules().copy(
+            autoplayAudible = AutoplayAction.ALLOWED,
+            autoplayInaudible = AutoplayAction.ALLOWED
+        )
+
+        every { settings.getSitePermissionsCustomSettingsRules() } returns rules
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = rules,
+            sitePermission = null
+        )
+
+        val result = value.createSitePermissionsFromCustomRules("mozilla.org", settings)
+
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayInaudible)
+        assertEquals(rules.camera.toStatus(), result.camera)
+        assertEquals(rules.location.toStatus(), result.location)
+        assertEquals(rules.microphone.toStatus(), result.microphone)
+        assertEquals(rules.notification.toStatus(), result.notification)
+        assertEquals(rules.persistentStorage.toStatus(), result.localStorage)
+        assertEquals(rules.mediaKeySystemAccess.toStatus(), result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `GIVEN a AllowAll WHEN updateSitePermissions is called THEN site permissions will include autoplayAudible and autoplayInaudible ALLOWED`() {
+        val sitePermissions = SitePermissions(
+            origin = "origin",
+            savedAt = 0L,
+            autoplayAudible = AutoplayStatus.BLOCKED,
+            autoplayInaudible = AutoplayStatus.BLOCKED
+        )
+
+        val value = AutoplayValue.AllowAll(
+            label = "label",
+            rules = mock(),
+            sitePermission = null
+        )
+
+        val result = value.updateSitePermissions(sitePermissions)
+
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayInaudible)
+        assertEquals(sitePermissions.camera, result.camera)
+        assertEquals(sitePermissions.location, result.location)
+        assertEquals(sitePermissions.microphone, result.microphone)
+        assertEquals(sitePermissions.notification, result.notification)
+        assertEquals(sitePermissions.localStorage, result.localStorage)
+        assertEquals(sitePermissions.mediaKeySystemAccess, result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `GIVEN a BlockAll WHEN updateSitePermissions is called THEN site permissions will include autoplayAudible and autoplayInaudible BLOCKED`() {
+        val sitePermissions = SitePermissions(
+            origin = "origin",
+            savedAt = 0L,
+            autoplayAudible = AutoplayStatus.ALLOWED,
+            autoplayInaudible = AutoplayStatus.ALLOWED
+        )
+
+        val value = AutoplayValue.BlockAll(
+            label = "label",
+            rules = mock(),
+            sitePermission = null
+        )
+
+        val result = value.updateSitePermissions(sitePermissions)
+
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayInaudible)
+        assertEquals(sitePermissions.camera, result.camera)
+        assertEquals(sitePermissions.location, result.location)
+        assertEquals(sitePermissions.microphone, result.microphone)
+        assertEquals(sitePermissions.notification, result.notification)
+        assertEquals(sitePermissions.localStorage, result.localStorage)
+        assertEquals(sitePermissions.mediaKeySystemAccess, result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `GIVEN a BlockAudible WHEN updateSitePermissions is called THEN site permissions will include autoplayAudible BLOCKED and autoplayInaudible ALLOWED`() {
+        val sitePermissions = SitePermissions(
+            origin = "origin",
+            savedAt = 0L,
+            autoplayAudible = AutoplayStatus.ALLOWED,
+            autoplayInaudible = AutoplayStatus.BLOCKED
+        )
+
+        val value = AutoplayValue.BlockAudible(
+            label = "label",
+            rules = mock(),
+            sitePermission = null
+        )
+
+        val result = value.updateSitePermissions(sitePermissions)
+
+        assertEquals(AutoplayStatus.BLOCKED, result.autoplayAudible)
+        assertEquals(AutoplayStatus.ALLOWED, result.autoplayInaudible)
+        assertEquals(sitePermissions.camera, result.camera)
+        assertEquals(sitePermissions.location, result.location)
+        assertEquals(sitePermissions.microphone, result.microphone)
+        assertEquals(sitePermissions.notification, result.notification)
+        assertEquals(sitePermissions.localStorage, result.localStorage)
+        assertEquals(sitePermissions.mediaKeySystemAccess, result.mediaKeySystemAccess)
+    }
+
+    @Test
+    fun `WHEN calling AutoplayValue values THEN values for AllowAll,BlockAll and BlockAudible will be returned`() {
+        val values = AutoplayValue.values(testContext, settings, null)
+
+        assertTrue(values.any { it is AutoplayValue.AllowAll })
+        assertTrue(values.any { it is AutoplayValue.BlockAll })
+        assertTrue(values.any { it is AutoplayValue.BlockAudible })
+        assertEquals(3, values.size)
+    }
+
+    private fun getRules() = SitePermissionsRules(
+        camera = Action.ASK_TO_ALLOW,
+        location = Action.ASK_TO_ALLOW,
+        microphone = Action.ASK_TO_ALLOW,
+        notification = Action.ASK_TO_ALLOW,
+        autoplayAudible = AutoplayAction.BLOCKED,
+        autoplayInaudible = AutoplayAction.BLOCKED,
+        persistentStorage = Action.ASK_TO_ALLOW,
+        mediaKeySystemAccess = Action.ASK_TO_ALLOW
+    )
+}
