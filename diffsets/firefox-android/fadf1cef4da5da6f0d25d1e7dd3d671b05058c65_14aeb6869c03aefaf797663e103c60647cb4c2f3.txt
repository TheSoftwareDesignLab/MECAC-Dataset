diff --git a/focus-android/app/.gitignore b/focus-android/app/.gitignore
index 0c030e5f2332..211d72962375 100644
--- a/focus-android/app/.gitignore
+++ b/focus-android/app/.gitignore
@@ -1,6 +1,3 @@
 /build
 
-src/webview/res/raw/*.json
-src/main/res/raw/*.json
-
 src/main/java/org/mozilla/focus/generated/
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/web/WebViewProviderTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/web/WebViewProviderTest.java
deleted file mode 100644
index 20d913713b2c..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/web/WebViewProviderTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.mozilla.focus.web;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-
-@RunWith(RobolectricTestRunner.class)
-public class WebViewProviderTest {
-
-    @Test public void testGetUABrowserString() {
-        // Typical situation with a webview UA string from Android 5:
-        String focusToken = "Focus/1.0";
-        final String existing = "Mozilla/5.0 (Linux; Android 5.0.2; Android SDK built for x86_64 Build/LSY66K) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile Safari/537.36";
-        assertEquals("AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 " + focusToken + " Chrome/37.0.0.0 Mobile Safari/537.36",
-                WebViewProvider.INSTANCE.getUABrowserString(existing, focusToken));
-
-        // Make sure we can use any token, e.g Klar:
-        focusToken = "Klar/2.0";
-        assertEquals("AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 " + focusToken + " Chrome/37.0.0.0 Mobile Safari/537.36",
-                WebViewProvider.INSTANCE.getUABrowserString(existing, focusToken));
-
-        // And a non-standard UA String, which doesn't contain AppleWebKit
-        focusToken = "Focus/1.0";
-        final String imaginaryKit = "Mozilla/5.0 (Linux) ImaginaryKit/-10 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile Safari/537.36";
-        assertEquals("ImaginaryKit/-10 (KHTML, like Gecko) Version/4.0 " + focusToken + " Chrome/37.0.0.0 Mobile Safari/537.36",
-                WebViewProvider.INSTANCE.getUABrowserString(imaginaryKit, focusToken));
-
-        // Another non-standard UA String, this time with no Chrome (in which case we should be appending focus)
-        final String chromeless = "Mozilla/5.0 (Linux; Android 5.0.2; Android SDK built for x86_64 Build/LSY66K) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Imaginary/37.0.0.0 Mobile Safari/537.36";
-        assertEquals("AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Imaginary/37.0.0.0 Mobile Safari/537.36 " + focusToken,
-                WebViewProvider.INSTANCE.getUABrowserString(chromeless, focusToken));
-
-        // No AppleWebkit, no Chrome
-        final String chromelessImaginaryKit = "Mozilla/5.0 (Linux) ImaginaryKit/-10 (KHTML, like Gecko) Version/4.0 Imaginary/37.0.0.0 Mobile Safari/537.36";
-        assertEquals("ImaginaryKit/-10 (KHTML, like Gecko) Version/4.0 Imaginary/37.0.0.0 Mobile Safari/537.36 " + focusToken,
-                WebViewProvider.INSTANCE.getUABrowserString(chromelessImaginaryKit, focusToken));
-
-    }
-}
\ No newline at end of file
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/TrackingProtectionWebViewClientTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/TrackingProtectionWebViewClientTest.java
deleted file mode 100644
index 985f160729cb..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/TrackingProtectionWebViewClientTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-package org.mozilla.focus.webview;
-
-import android.net.Uri;
-import android.os.StrictMode;
-import android.webkit.WebResourceRequest;
-import android.webkit.WebResourceResponse;
-import android.webkit.WebView;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import java.util.Map;
-
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-// IMPORTANT NOTE - IF RUNNING TESTS USING ANDROID STUDIO:
-// Read the following for a guide on how to get AS to correctly load resources, if you don't
-// do this you will get Resource Loading exceptions:
-// http://robolectric.org/getting-started/#note-for-linux-and-mac-users
-
-@RunWith(RobolectricTestRunner.class)
-@Config(packageName = "org.mozilla.focus")
-public class TrackingProtectionWebViewClientTest {
-
-    private TrackingProtectionWebViewClient trackingProtectionWebViewClient;
-    private WebView webView;
-
-    @Before
-    public void setup() {
-        trackingProtectionWebViewClient = new TrackingProtectionWebViewClient(RuntimeEnvironment.application);
-
-        webView = mock(WebView.class);
-        when(webView.getContext()).thenReturn(RuntimeEnvironment.application);
-    }
-
-    @After
-    public void cleanup() {
-        // Reset strict mode: for every test, Robolectric will create FocusApplication again.
-        // FocusApplication expects strict mode to be disabled (since it loads some preferences from disk),
-        // before enabling it itself. If we run multiple tests, strict mode will stay enabled
-        // and FocusApplication crashes during initialisation for the second test.
-        // This applies across multiple Test classes, e.g. DisconnectTest can cause
-        // TrackingProtectionWebViewCLientTest to fail, unless it clears StrictMode first.
-        // (FocusApplicaiton is initialised before @Before methods are run.)
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().build());
-    }
-
-    @Test
-    public void shouldInterceptRequest() throws Exception {
-        trackingProtectionWebViewClient.notifyCurrentURL("http://www.mozilla.org");
-
-        // Just some generic sanity checks that a definitely not blocked domain can be loaded, and
-        // definitely blocked domains can't be
-        {
-            final WebResourceRequest request = createRequest("http://mozilla.org/about", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceAllowed(response);
-        }
-
-        {
-            final WebResourceRequest request = createRequest("http://trackersimulator.org/foobar", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceBlocked(response);
-        }
-    }
-
-    @Test
-    public void testMainFrameAllowed() throws Exception {
-        trackingProtectionWebViewClient.notifyCurrentURL("http://mozilla.org");
-
-        // Blocked sites can still be loaded if opened as the main frame
-        {
-            final WebResourceRequest request = createRequest("http://trackersimulator.org/foobar", true);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceAllowed(response);
-        }
-
-        // And when we're loading that site, it can load first-party resources
-        trackingProtectionWebViewClient.notifyCurrentURL("http://trackersimulator.org");
-        {
-            final WebResourceRequest request = createRequest("http://trackersimulator.org/other.js", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceAllowed(response);
-        }
-
-        // But other sites still can't load it:
-        trackingProtectionWebViewClient.notifyCurrentURL("http://mozilla.org");
-        {
-            final WebResourceRequest request = createRequest("http://trackersimulator.org/foobar", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceBlocked(response);
-        }
-    }
-
-    @Test
-    public void testFaviconBlocked() throws Exception {
-        trackingProtectionWebViewClient.notifyCurrentURL("http://www.mozilla.org");
-
-        {
-            // Webkit tries to load favicon.ico, even though it isn't used:
-            final WebResourceRequest request = createRequest("http://mozilla.org/favicon.ico", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceBlocked(response);
-        }
-
-        {
-            // But we can't block other images since they might be used by actual pages
-            final WebResourceRequest request = createRequest("http://mozilla.org/favicon.png", false);
-            final WebResourceResponse response = trackingProtectionWebViewClient.shouldInterceptRequest(webView, request);
-            assertResourceAllowed(response);
-        }
-    }
-
-    private void assertResourceAllowed(final WebResourceResponse response) {
-        // shouldInterceptRequest returns null to indicate that WebView should just load the resource
-        assertNull(response);
-    }
-
-    private void assertResourceBlocked(final WebResourceResponse response) {
-        // shouldInterceptRequest a valid response in other cases, e.g. with null data to indicate
-        // a blocked resource.
-        assertNull(response.getData());
-    }
-
-    private static WebResourceRequest createRequest(final String url, final boolean isForMainFrame) {
-        return new WebResourceRequest() {
-            @Override
-            public Uri getUrl() {
-                return Uri.parse(url);
-            }
-
-            @Override
-            public boolean isForMainFrame() {
-                return isForMainFrame;
-            }
-
-            @Override
-            public boolean isRedirect() {
-                return false;
-            }
-
-            @Override
-            public boolean hasGesture() {
-                return false;
-            }
-
-            @Override
-            public String getMethod() {
-                return null;
-            }
-
-            @Override
-            public Map<String, String> getRequestHeaders() {
-                return null;
-            }
-        };
-    }
-}
\ No newline at end of file
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/DisconnectTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/DisconnectTest.java
deleted file mode 100644
index d05fc674b9f8..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/DisconnectTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.webview.matcher;
-
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.os.StrictMode;
-import android.preference.PreferenceManager;
-
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mozilla.focus.R;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * Integration test for tracking protection, which tests that some real websites are/aren't
- * blocked under given circumstances.
- *
- * UrlMatcherTest tests the general correctness of our URL matching code, this test is intended
- * to verify that our disconnect lists are loaded correctly (and therefore are dependent on the
- * contents of our disconnect lists).
- *
- * This test also verifies that the entity lists (whitelists for specific domains) actually work
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(packageName = "org.mozilla.focus")
-public class DisconnectTest {
-
-    @After
-    public void cleanup() {
-        // Reset strict mode: for every test, Robolectric will create FocusApplication again.
-        // FocusApplication expects strict mode to be disabled (since it loads some preferences from disk),
-        // before enabling it itself. If we run multiple tests, strict mode will stay enabled
-        // and FocusApplication crashes during initialisation for the second test.
-        // This applies across multiple Test classes, e.g. DisconnectTest can cause
-        // TrackingProtectionWebViewCLientTest to fail, unless it clears StrictMode first.
-        // (FocusApplicaiton is initialised before @Before methods are run.)
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().build());
-    }
-
-    // IMPORTANT NOTE - IF RUNNING TESTS USING ANDROID STUDIO:
-    // Read the following for a guide on how to get AS to correctly load resources, if you don't
-    // do this you will get Resource Loading exceptions:
-    // http://robolectric.org/getting-started/#note-for-linux-and-mac-users
-    @Test
-    public void matches() throws Exception {
-        final UrlMatcher matcher = UrlMatcher.loadMatcher(RuntimeEnvironment.application, R.raw.blocklist, new int[] { R.raw.google_mapping }, R.raw.entitylist);
-
-
-        // Enable everything
-        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(RuntimeEnvironment.application);
-        prefs.edit()
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_ads), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_analytics), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_other), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_social), true)
-                .apply();
-
-        // We check that our google_mapping was loaded correctly. We do these checks per-category, so we have:
-        // ads:
-        assertTrue(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://mozilla.org")));
-        // And we check that the entitylist unblocks this on google properties:
-        assertFalse(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://google.com")));
-        // analytics:
-        assertTrue(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://google.com")));
-        // social:
-        assertTrue(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://google.com")));
-
-        // Facebook is special in that we move it from "Disconnect" into social:
-        assertTrue(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://facebook.com")));
-
-        // Now disable social, and check that only social sites have changed:
-        prefs.edit()
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_ads), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_analytics), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_other), true)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_social), false)
-                .apply();
-
-        // ads:
-        assertTrue(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://google.com")));
-        // analytics:
-        assertTrue(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://google.com")));
-        // social:
-        assertFalse(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://google.com")));
-
-        // And facebook which has been moved from Disconnect into social
-        assertFalse(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://facebook.com")));
-
-        // Now disable everything - all sites should work:
-        prefs.edit()
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_ads), false)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_analytics), false)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_other), false)
-                .putBoolean(RuntimeEnvironment.application.getString(R.string.pref_key_privacy_block_social), false)
-                .apply();
-
-        // ads:
-        assertFalse(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://admeld.com/foobar"), Uri.parse("http://google.com")));
-        // analytics:
-        assertFalse(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://google-analytics.com/foobar"), Uri.parse("http://google.com")));
-        // social:
-        assertFalse(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://plus.google.com/something"), Uri.parse("http://google.com")));
-
-        // Facebook is special in that we move it from "Disconnect" into social:
-        assertFalse(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://mozilla.org")));
-        assertFalse(matcher.matches(Uri.parse("http://facebook.fr"), Uri.parse("http://facebook.com")));
-    }
-}
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/EntityListTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/EntityListTest.java
deleted file mode 100644
index 35c24393a4a9..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/EntityListTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.mozilla.focus.webview.matcher;
-
-import android.net.Uri;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mozilla.focus.webview.matcher.util.FocusString;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Integration test to make sure all our whitelisting methods work as expected.
- */
-@RunWith(RobolectricTestRunner.class)
-public class EntityListTest {
-
-
-    // TODO: we might want to clean up the mess of revhost vs normal host vs inserting a whitelist
-    // item vs inserting a whitelist trie. And that isWhiteListed relies on domains, the rest doesn't
-    @Test
-    public void testWhitelist() {
-        final String mozillaOrg = "mozilla.org";
-        final String fooMozillaOrg = "foo.mozilla.org";
-        final String fooCom = "foo.com";
-        final String barCom = "bar.com";
-
-        final EntityList entityList = new EntityList();
-
-        // We set up the following data and test that matches function as expected:
-        // mozilla.org - allow all from foo.com
-        // foo.mozilla.org - additionally allow from bar.com
-        // Thus mozilla.org can only use foo.com, but foo.mozilla.org can use foo.com and bar.com
-
-        final Trie fooComTrie = Trie.createRootNode();
-        fooComTrie.put(FocusString.create(fooCom).reverse());
-
-        final Trie barComTrie = Trie.createRootNode();
-        barComTrie.put(FocusString.create(barCom).reverse());
-
-        entityList.putWhiteList(FocusString.create(mozillaOrg).reverse(), fooComTrie);
-        entityList.putWhiteList(FocusString.create(fooMozillaOrg).reverse(), barComTrie);
-
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + mozillaOrg), Uri.parse("http://" + fooCom)));
-        assertFalse(entityList.isWhiteListed(Uri.parse("http://" + mozillaOrg), Uri.parse("http://" + barCom)));
-
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + fooMozillaOrg), Uri.parse("http://" + fooCom)));
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + fooMozillaOrg), Uri.parse("http://" + barCom)));
-
-        // Test some junk inputs to make sure we haven't messed up
-        assertFalse(entityList.isWhiteListed(Uri.parse("http://" + barCom), Uri.parse("http://" + barCom)));
-        assertFalse(entityList.isWhiteListed(Uri.parse("http://" + barCom), Uri.parse("http://" + mozillaOrg)));
-
-        // Test some made up subdomains to ensure they still match *.foo.mozilla.org
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + "hello." + fooMozillaOrg), Uri.parse("http://" + fooCom)));
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + "hello." + fooMozillaOrg), Uri.parse("http://" + barCom)));
-
-        // And that these only match *.mozilla.org
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + "hello." + mozillaOrg), Uri.parse("http://" + fooCom)));
-        assertFalse(entityList.isWhiteListed(Uri.parse("http://" + "hello." + mozillaOrg), Uri.parse("http://" + barCom)));
-
-        // And random subpages don't fail:
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + mozillaOrg + "/somewhere"), Uri.parse("http://" + fooCom + "/somewhereElse/bla/bla")));
-        assertFalse(entityList.isWhiteListed(Uri.parse("http://" + mozillaOrg + "/another/page.html?u=a"), Uri.parse("http://" + barCom + "/hello")));
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + fooMozillaOrg + "/somewhere"), Uri.parse("http://" + fooCom + "/somewhereElse/bla/bla")));
-        assertTrue(entityList.isWhiteListed(Uri.parse("http://" + fooMozillaOrg + "/another/page.html?u=a"), Uri.parse("http://" + barCom + "/hello")));
-
-        // Check we don't whitelist resources from data: pages
-        assertFalse(entityList.isWhiteListed(Uri.parse("data:text/html;stuff"), Uri.parse("http://" + fooCom + "/somewhereElse/bla/bla")));
-    }
-
-}
\ No newline at end of file
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/TrieTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/TrieTest.java
deleted file mode 100644
index 9eedc69ab77c..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/TrieTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.mozilla.focus.webview.matcher;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mozilla.focus.webview.matcher.Trie.WhiteListTrie;
-import org.mozilla.focus.webview.matcher.util.FocusString;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-@RunWith(RobolectricTestRunner.class)
-public class TrieTest {
-
-    @Test
-    public void findNode() throws Exception {
-        final Trie trie = Trie.createRootNode();
-
-        assertNull(trie.findNode(FocusString.create("hello")));
-
-        final Trie putNode = trie.put(FocusString.create("hello"));
-        final Trie foundNode = trie.findNode(FocusString.create("hello"));
-
-        assertNotNull(putNode);
-        assertNotNull(foundNode);
-        assertEquals(putNode, foundNode);
-
-        // Substring matching: doesn't happen (except for subdomains, we test those later)
-        assertNull(trie.findNode(FocusString.create("hell")));
-        assertNull(trie.findNode(FocusString.create("hellop")));
-
-        trie.put(FocusString.create("hellohello"));
-
-        // Ensure both old and new overlapping strings can still be found
-        assertNotNull(trie.findNode(FocusString.create("hello")));
-        assertNotNull(trie.findNode(FocusString.create("hellohello")));
-
-        // These still don't match:
-        assertNull(trie.findNode(FocusString.create("hell")));
-        assertNull(trie.findNode(FocusString.create("hellop")));
-
-        // Domain specific / partial domain tests:
-        trie.put(FocusString.create("foo.com").reverse());
-
-        // Domain and subdomain can be found
-        assertNotNull(trie.findNode(FocusString.create("foo.com").reverse()));
-        assertNotNull(trie.findNode(FocusString.create("bar.foo.com").reverse()));
-        // But other domains with some overlap don't match
-        assertNull(trie.findNode(FocusString.create("bar-foo.com").reverse()));
-        assertNull(trie.findNode(FocusString.create("oo.com").reverse()));
-    }
-
-    @Test
-    public void testWhiteListTrie() {
-        final WhiteListTrie trie;
-
-        {
-            final Trie whitelist = Trie.createRootNode();
-
-            whitelist.put(FocusString.create("abc"));
-
-            trie = WhiteListTrie.createRootNode();
-            trie.putWhiteList(FocusString.create("def"), whitelist);
-        }
-
-        assertNull(trie.findNode(FocusString.create("abc")));
-
-        // In practice EntityList uses it's own search in order to cover all possible matching notes
-        // (e.g. in case we have separate whitelists for mozilla.org and foo.mozilla.org), however
-        // we don't need to test that here yet.
-        final WhiteListTrie foundWhitelist = (WhiteListTrie) trie.findNode(FocusString.create("def"));
-        assertNotNull(foundWhitelist);
-
-        assertNotNull(foundWhitelist.whitelist.findNode(FocusString.create("abc")));
-    }
-}
\ No newline at end of file
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/UrlMatcherTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/UrlMatcherTest.java
deleted file mode 100644
index 7e7561ef14ca..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/UrlMatcherTest.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.webview.matcher;
-
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.preference.PreferenceManager;
-
-import junit.framework.Assert;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mozilla.focus.webview.matcher.util.FocusString;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(RobolectricTestRunner.class)
-public class UrlMatcherTest {
-
-    @Test
-    public void matches() throws Exception {
-        final UrlMatcher matcher = new UrlMatcher(new String[] {
-                "bcd.random"
-        });
-
-        assertTrue(matcher.matches(Uri.parse("http://bcd.random/something"), Uri.parse("http://mozilla.org")));
-        assertTrue(matcher.matches(Uri.parse("http://bcd.random"), Uri.parse("http://mozilla.org")));
-        assertTrue(matcher.matches(Uri.parse("http://www.bcd.random"), Uri.parse("http://mozilla.org")));
-        assertTrue(matcher.matches(Uri.parse("http://www.bcd.random/something"), Uri.parse("http://mozilla.org")));
-        assertTrue(matcher.matches(Uri.parse("http://foobar.bcd.random"), Uri.parse("http://mozilla.org")));
-        assertTrue(matcher.matches(Uri.parse("http://foobar.bcd.random/something"), Uri.parse("http://mozilla.org")));
-
-        assertTrue(!matcher.matches(Uri.parse("http://other.random"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://other.random/something"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://www.other.random"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://www.other.random/something"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://bcd.specific"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://bcd.specific/something"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://www.bcd.specific"), Uri.parse("http://mozilla.org")));
-        assertTrue(!matcher.matches(Uri.parse("http://www.bcd.specific/something"), Uri.parse("http://mozilla.org")));
-
-        // Check that we still do matching for data: URIs
-        assertFalse(matcher.matches(Uri.parse("http://mozilla.org/resource"), Uri.parse("data:text/html;stuff here")));
-        assertTrue(matcher.matches(Uri.parse("http://bcd.random/resource"), Uri.parse("data:text/html;stuff here")));
-    }
-
-    @Test
-    public void categoriesWork() {
-        // Test that category enabling/disabling works correctly. We test this by creating
-        // 4 categories, each with only one domain. We then iterate over all permutations of categories,
-        // and test that only the expected domains are actually blocked.
-        // (This is an important test, since we do some caching in UrlMatcher, and we need to make
-        // sure that the caching doesn't break when categories are enabled/disabled at runtime.)
-
-        final Map<String, Trie> categories = new HashMap<>();
-        final Map<String, String> categoryPrefMap = new HashMap<>();
-
-        // Number of categories we want to test with.
-        final int CAT_COUNT = 4;
-
-        final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(RuntimeEnvironment.application);
-
-        { // Setup for category tests
-            final SharedPreferences.Editor editor = preferences.edit();
-
-            for (int i = 0; i < CAT_COUNT; i++) {
-                final String domain = "category" + i + ".com";
-
-                final Trie trie = Trie.createRootNode();
-                trie.put(FocusString.create(domain).reverse());
-
-                final String categoryName = "category" + i;
-                categories.put(categoryName, trie);
-
-                editor.putBoolean(categoryName, false);
-
-                categoryPrefMap.put(categoryName, categoryName);
-            }
-            editor.apply();
-        }
-
-        final UrlMatcher matcher = new UrlMatcher(RuntimeEnvironment.application, categoryPrefMap, categories, null);
-
-        // We can test every permutation by iterating over every value of a 4-bit integer (each bit
-        // indicates whether a given category is enabled or disabled).
-
-        // N categories -> N bits == (2^N - 1) == '1111...'
-        // 4 categories -> 4 bits == 15 == 2^N-1 = '1111'
-
-        final int allEnabledPattern = (1 << CAT_COUNT) - 1;
-        for (int categoryPattern = 0; categoryPattern <= allEnabledPattern; categoryPattern++) {
-            final SharedPreferences.Editor editor = preferences.edit();
-
-            // Ensure all the correct categories enabled
-            for (int currentCategory = 0; currentCategory < CAT_COUNT; currentCategory++) {
-                final int currentBit = 1 << currentCategory;
-
-                final boolean enabled = ((currentBit & categoryPattern) == currentBit);
-
-                editor.putBoolean("category" + currentCategory, enabled);
-
-                // Sanity checks: just make sure our category enabling code actually sets the correct
-                // values for a few known combinations (i.e. we're doing a test within the test...)
-                if (categoryPattern == 0) {
-                    assertFalse("All categories should be disabled for categorypattern==0", enabled);
-                } else if (categoryPattern == allEnabledPattern) {
-                    assertTrue("All categories should be enabled for categorypattern=='111....'", enabled);
-                } else if (categoryPattern == Integer.parseInt("1100", 2)) {
-                    if (currentCategory < 2) {
-                        assertFalse("Categories 0/1 expected to be disabled", enabled);
-                    } else {
-                        assertTrue("Categories >= 2 expected to be enabled", enabled);
-                    }
-                }
-            }
-            editor.apply();
-
-            for (int currentCategory = 0; currentCategory < CAT_COUNT; currentCategory++) {
-                final int currentBit = 1 << currentCategory;
-
-                final boolean enabled = ((currentBit & categoryPattern) == currentBit);
-
-                final String url = "http://category" + currentCategory + ".com";
-
-                Assert.assertEquals("Incorrect category matched for combo=" + categoryPattern + " url=" + url,
-                        enabled, matcher.matches(Uri.parse(url), Uri.parse("http://www.mozilla.org")));
-            }
-        }
-    }
-
-
-}
\ No newline at end of file
diff --git a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/util/FocusStringTest.java b/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/util/FocusStringTest.java
deleted file mode 100644
index 5e1f6dea72b2..000000000000
--- a/focus-android/app/src/testWebview/java/org/mozilla/focus/webview/matcher/util/FocusStringTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package org.mozilla.focus.webview.matcher.util;
-
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class FocusStringTest {
-
-    @Test (expected = StringIndexOutOfBoundsException.class)
-    public void outOfBounds() throws StringIndexOutOfBoundsException {
-        final String fullStringRaw = "a";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        // Is beyond the raw input string
-        fullString.charAt(1);
-    }
-
-    @Test (expected = StringIndexOutOfBoundsException.class)
-    public void outofBoundsAfterSubstring() throws StringIndexOutOfBoundsException {
-        final String fullStringRaw = "abcd";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        final FocusString substring = fullString.substring(3);
-        // substring == "d"
-        substring.charAt(1);
-    }
-
-    @Test (expected = StringIndexOutOfBoundsException.class)
-    public void outofBoundsSubstringLarge() throws StringIndexOutOfBoundsException {
-        final String fullStringRaw = "abcd";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        final FocusString substring = fullString.substring(5);
-    }
-
-    @Test (expected = StringIndexOutOfBoundsException.class)
-    public void outofBoundsSubstringNegative() throws StringIndexOutOfBoundsException {
-        final String fullStringRaw = "abcd";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        final FocusString substring = fullString.substring(-1);
-    }
-
-
-    @Test
-    public void testSubstringLength() {
-        final String fullStringRaw = "a";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        assertEquals("FocusString length must match input string length",
-                fullStringRaw.length(), fullString.length());
-
-        final FocusString sameString = fullString.substring(0);
-        assertEquals("substring(0) should equal input String",
-                fullStringRaw.length(), sameString.length());
-        assertEquals("substring(0) should equal input String",
-                fullStringRaw.charAt(0), sameString.charAt(0));
-
-
-        final FocusString emptyString = fullString.substring(1);
-        assertEquals("empty substring should be empty",
-                0, emptyString.length());
-    }
-
-    @Test (expected = StringIndexOutOfBoundsException.class)
-    public void outofBoundsAfterSubstringEmpty() throws StringIndexOutOfBoundsException {
-        final String fullStringRaw = "abcd";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        final FocusString substring = fullString.substring(4);
-        // substring == ""
-        substring.charAt(0);
-    }
-
-    @Test
-    public void testForwardString() {
-        final String fullStringRaw = "abcd";
-        final FocusString fullString = FocusString.create(fullStringRaw);
-
-        assertEquals("FocusString length must match input string length",
-                fullStringRaw.length(), fullString.length());
-
-        for (int i = 0; i < fullStringRaw.length(); i++) {
-            assertEquals("FocusString character doesn't match input string character",
-                    fullStringRaw.charAt(i), fullString.charAt(i));
-        }
-
-        final String substringRaw = fullStringRaw.substring(2);
-        final FocusString substring = fullString.substring(2);
-
-        for (int i = 0; i < substringRaw.length(); i++) {
-            assertEquals("FocusString character doesn't match input string character",
-                    substringRaw.charAt(i), substring.charAt(i));
-        }
-    }
-
-    @Test
-    public void testReverseString() {
-        final String fullUnreversedStringRaw = "abcd";
-
-        final String fullStringRaw = new StringBuffer(fullUnreversedStringRaw).reverse().toString();
-        final FocusString fullString = FocusString.create(fullUnreversedStringRaw).reverse();
-
-        assertEquals("FocusString length must match input string length",
-                fullStringRaw.length(), fullString.length());
-
-        for (int i = 0; i < fullStringRaw.length(); i++) {
-            assertEquals("FocusString character doesn't match input string character",
-                    fullStringRaw.charAt(i), fullString.charAt(i));
-        }
-
-        final String substringRaw = fullStringRaw.substring(2);
-        final FocusString substring = fullString.substring(2);
-
-        for (int i = 0; i < substringRaw.length(); i++) {
-            assertEquals("FocusString character doesn't match input string character",
-                    substringRaw.charAt(i), substring.charAt(i));
-        }
-    }
-}
\ No newline at end of file
