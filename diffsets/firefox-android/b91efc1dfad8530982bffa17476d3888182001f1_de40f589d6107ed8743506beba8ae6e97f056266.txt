diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/CreditCardsAddressesStorage.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/CreditCardsAddressesStorage.kt
index eaf42e058b2c..dd88ed505280 100644
--- a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/CreditCardsAddressesStorage.kt
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/CreditCardsAddressesStorage.kt
@@ -113,6 +113,11 @@ interface CreditCardsAddressesStorage {
      * @return [CreditCardCrypto] instance.
      */
     fun getCreditCardCrypto(): CreditCardCrypto
+
+    /**
+     * Removes any encrypted data from this storage. Useful after encountering key loss.
+     */
+    suspend fun scrubEncryptedData()
 }
 
 /**
diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/KeyManager.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/KeyManager.kt
new file mode 100644
index 000000000000..fe7a86d0d73c
--- /dev/null
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/KeyManager.kt
@@ -0,0 +1,108 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.storage
+
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
+import kotlin.IllegalStateException
+
+/**
+ * Knows how to manage (generate, store, validate) keys and recover from their loss.
+ */
+abstract class KeyManager : KeyProvider {
+    // Exists to ensure that key generation/validation/recovery flow is synchronized.
+    private val keyMutex = Mutex()
+
+    /**
+     * @return Generated key.
+     */
+    abstract fun createKey(): String
+
+    /**
+     * Determines if [rawKey] is still valid for a given [canary], or if recovery is necessary.
+     * @return Optional [KeyGenerationReason.RecoveryNeeded] if recovery is necessary.
+     */
+    abstract fun isKeyRecoveryNeeded(rawKey: String, canary: String): KeyGenerationReason.RecoveryNeeded?
+
+    /**
+     * Returns a stored canary, if there's one. A canary is some known string encrypted with the managed key.
+     * @return an optional, stored canary string.
+     */
+    abstract fun getStoredCanary(): String?
+
+    /**
+     * Returns a stored key, if there's one.
+     */
+    abstract fun getStoredKey(): String?
+
+    /**
+     * Stores [key]; using the key, generate and store a canary.
+     */
+    abstract fun storeKeyAndCanary(key: String)
+
+    /**
+     * Recover from key loss that happened due to [reason].
+     * If this KeyManager wraps a storage layer, it should probably remove the now-unreadable data.
+     */
+    abstract suspend fun recoverFromKeyLoss(reason: KeyGenerationReason.RecoveryNeeded)
+
+    override suspend fun getOrGenerateKey(): ManagedKey = keyMutex.withLock(this) {
+        val managedKey = getManagedKey()
+
+        (managedKey.wasGenerated as? KeyGenerationReason.RecoveryNeeded)?.let {
+            recoverFromKeyLoss(managedKey.wasGenerated)
+        }
+        return managedKey
+    }
+
+    /**
+     * Access should be guarded by [keyMutex].
+     */
+    private fun getManagedKey(): ManagedKey {
+        val storedCanaryPhrase = getStoredCanary()
+        val storedKey = getStoredKey()
+
+        return when {
+            // We expected the key to be present, and it is.
+            storedKey != null && storedCanaryPhrase != null -> {
+                // Make sure that the key is valid.
+                when (val recoveryReason = isKeyRecoveryNeeded(storedKey, storedCanaryPhrase)) {
+                    is KeyGenerationReason -> ManagedKey(generateAndStoreKey(), recoveryReason)
+                    null -> ManagedKey(storedKey)
+                }
+            }
+
+            // The key is present, but we didn't expect it to be there.
+            storedKey != null && storedCanaryPhrase == null -> {
+                // This isn't expected to happen. We can't check this key's validity.
+                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.AbnormalState)
+            }
+
+            // We expected the key to be present, but it's gone missing on us.
+            storedKey == null && storedCanaryPhrase != null -> {
+                // At this point, we're forced to generate a new key to recover and move forward.
+                // However, that means that any data that was previously encrypted is now unreadable.
+                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Lost)
+            }
+
+            // We didn't expect the key to be present, and it's not.
+            storedKey == null && storedCanaryPhrase == null -> {
+                // Normal case when interacting with this class for the first time.
+                ManagedKey(generateAndStoreKey(), KeyGenerationReason.New)
+            }
+
+            else -> throw IllegalStateException()
+        }
+    }
+
+    /**
+     * Access should be guarded by [keyMutex].
+     */
+    private fun generateAndStoreKey(): String {
+        return createKey().also { newKey ->
+            storeKeyAndCanary(newKey)
+        }
+    }
+}
diff --git a/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCreditCardsAddressesStorage.kt b/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCreditCardsAddressesStorage.kt
index 5bc968cc8dfd..35704a53ab6c 100644
--- a/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCreditCardsAddressesStorage.kt
+++ b/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCreditCardsAddressesStorage.kt
@@ -168,6 +168,10 @@ class AutofillCreditCardsAddressesStorage(
         return crypto
     }
 
+    override suspend fun scrubEncryptedData() = withContext(coroutineContext) {
+        conn.getStorage().scrubEncryptedData()
+    }
+
     override fun registerWithSyncManager() {
         conn.getStorage().registerWithSyncManager()
     }
diff --git a/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCrypto.kt b/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCrypto.kt
index b69acc14c9fd..ed3571e3e677 100644
--- a/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCrypto.kt
+++ b/android-components/components/service/sync-autofill/src/main/java/mozilla/components/service/sync/autofill/AutofillCrypto.kt
@@ -7,12 +7,12 @@ package mozilla.components.service.sync.autofill
 import android.content.Context
 import android.content.SharedPreferences
 import mozilla.appservices.autofill.AutofillException
-import mozilla.appservices.autofill.createKey
 import mozilla.appservices.autofill.decryptString
 import mozilla.appservices.autofill.encryptString
 import mozilla.components.concept.storage.CreditCardCrypto
 import mozilla.components.concept.storage.CreditCardNumber
 import mozilla.components.concept.storage.KeyGenerationReason
+import mozilla.components.concept.storage.KeyManager
 import mozilla.components.concept.storage.ManagedKey
 import mozilla.components.lib.dataprotect.SecureAbove22Preferences
 import mozilla.components.support.base.log.logger.Logger
@@ -31,7 +31,7 @@ class AutofillCrypto(
     private val context: Context,
     private val securePrefs: SecureAbove22Preferences,
     private val storage: AutofillCreditCardsAddressesStorage
-) : CreditCardCrypto {
+) : CreditCardCrypto, KeyManager() {
     private val logger = Logger("AutofillCrypto")
     private val plaintextPrefs by lazy { context.getSharedPreferences(AUTOFILL_PREFS, Context.MODE_PRIVATE) }
 
@@ -40,7 +40,7 @@ class AutofillCrypto(
         plaintextCardNumber: CreditCardNumber.Plaintext
     ): CreditCardNumber.Encrypted? {
         return try {
-            CreditCardNumber.Encrypted(encrypt(key, plaintextCardNumber.number))
+            CreditCardNumber.Encrypted(encryptString(key.key, plaintextCardNumber.number))
         } catch (e: AutofillException.JsonException) {
             logger.warn("Failed to encrypt", e)
             null
@@ -55,7 +55,7 @@ class AutofillCrypto(
         encryptedCardNumber: CreditCardNumber.Encrypted
     ): CreditCardNumber.Plaintext? {
         return try {
-            CreditCardNumber.Plaintext(decrypt(key, encryptedCardNumber.number))
+            CreditCardNumber.Plaintext(decryptString(key.key, encryptedCardNumber.number))
         } catch (e: AutofillException.JsonException) {
             logger.warn("Failed to decrypt", e)
             null
@@ -65,94 +65,45 @@ class AutofillCrypto(
         }
     }
 
-    override suspend fun getOrGenerateKey(): ManagedKey = synchronized(this) {
-        val managedKey = getManagedKey()
+    override fun createKey() = mozilla.appservices.autofill.createKey()
 
-        // Record abnormal events if any were detected.
-        // At this point, we should emit some telemetry.
-        // See https://github.com/mozilla-mobile/android-components/issues/10122
-        when (managedKey.wasGenerated) {
-            is KeyGenerationReason.RecoveryNeeded.Lost -> {
-                logger.warn("Key was lost")
-            }
-            is KeyGenerationReason.RecoveryNeeded.Corrupt -> {
-                logger.warn("Key was corrupted")
-            }
-            is KeyGenerationReason.RecoveryNeeded.AbnormalState -> {
-                logger.warn("Abnormal state while reading the key")
-            }
-            null, KeyGenerationReason.New -> {
-                // All good! Got either a brand new key or read a valid key.
+    override fun isKeyRecoveryNeeded(rawKey: String, canary: String): KeyGenerationReason.RecoveryNeeded? {
+        return try {
+            if (CANARY_PHRASE_PLAINTEXT == decryptString(rawKey, canary)) {
+                null
+            } else {
+                KeyGenerationReason.RecoveryNeeded.Corrupt
             }
+        } catch (e: AutofillException.JsonException) {
+            KeyGenerationReason.RecoveryNeeded.Corrupt
+        } catch (e: AutofillException.CryptoException) {
+            KeyGenerationReason.RecoveryNeeded.Corrupt
         }
-        (managedKey.wasGenerated as? KeyGenerationReason.RecoveryNeeded)?.let {
-            storage.conn.getStorage().scrubEncryptedData()
-        }
-        return managedKey
     }
 
-    private fun encrypt(key: ManagedKey, cleartext: String) = encryptString(key.key, cleartext)
-    private fun decrypt(key: ManagedKey, ciphertext: String) = decryptString(key.key, ciphertext)
-
-    @Suppress("ComplexMethod")
-    private fun getManagedKey(): ManagedKey = synchronized(this) {
-        val encryptedCanaryPhrase = plaintextPrefs.getString(CANARY_PHRASE_CIPHERTEXT_KEY, null)
-        val storedKey = securePrefs.getString(AUTOFILL_KEY)
-
-        return@synchronized when {
-            // We expected the key to be present, and it is.
-            storedKey != null && encryptedCanaryPhrase != null -> {
-                // Make sure that the key is valid.
-                try {
-                    if (CANARY_PHRASE_PLAINTEXT == decryptString(storedKey, encryptedCanaryPhrase)) {
-                        ManagedKey(storedKey)
-                    } else {
-                        // A bad key should trigger a CryptoException, but check this branch just in case.
-                        ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Corrupt)
-                    }
-                } catch (e: AutofillException.JsonException) {
-                    ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Corrupt)
-                } catch (e: AutofillException.CryptoException) {
-                    ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Corrupt)
-                }
-            }
-
-            // The key is present, but we didn't expect it to be there.
-            storedKey != null && encryptedCanaryPhrase == null -> {
-                // This isn't expected to happen. We can't check this key's validity.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.AbnormalState)
-            }
-
-            // We expected the key to be present, but it's gone missing on us.
-            storedKey == null && encryptedCanaryPhrase != null -> {
-                // At this point, we're forced to generate a new key to recover and move forward.
-                // However, that means that any data that was previously encrypted is now unreadable.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Lost)
-            }
+    override fun getStoredCanary(): String? {
+        return plaintextPrefs.getString(CANARY_PHRASE_CIPHERTEXT_KEY, null)
+    }
 
-            // We didn't expect the key to be present, and it's not.
-            storedKey == null && encryptedCanaryPhrase == null -> {
-                // Normal case when interacting with this class for the first time.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.New)
-            }
+    override fun getStoredKey(): String? {
+        return securePrefs.getString(AUTOFILL_KEY)
+    }
 
-            else -> throw AutofillCryptoException.IllegalState()
-        }
+    override fun storeKeyAndCanary(key: String) {
+        // To consider: should this be a non-destructive operation, just in case?
+        // e.g. if we thought we lost the key, but actually did not, that would let us recover data later on.
+        // otherwise, if we mess up and override a perfectly good key, the data is gone for good.
+        securePrefs.putString(AUTOFILL_KEY, key)
+        // To detect key corruption or absence, use the newly generated key to encrypt a known string.
+        // See isKeyValid below.
+        plaintextPrefs
+            .edit()
+            .putString(CANARY_PHRASE_CIPHERTEXT_KEY, encryptString(key, CANARY_PHRASE_PLAINTEXT))
+            .apply()
     }
 
-    private fun generateAndStoreKey(): String {
-        return createKey().also { newKey ->
-            // To consider: should this be a non-destructive operation, just in case?
-            // e.g. if we thought we lost the key, but actually did not, that would let us recover data later on.
-            // otherwise, if we mess up and override a perfectly good key, the data is gone for good.
-            securePrefs.putString(AUTOFILL_KEY, newKey)
-            // To detect key corruption or absence, use the newly generated key to encrypt a known string.
-            // See isKeyValid below.
-            plaintextPrefs
-                .edit()
-                .putString(CANARY_PHRASE_CIPHERTEXT_KEY, encryptString(newKey, CANARY_PHRASE_PLAINTEXT))
-                .apply()
-        }
+    override suspend fun recoverFromKeyLoss(reason: KeyGenerationReason.RecoveryNeeded) {
+        storage.scrubEncryptedData()
     }
 
     companion object {
diff --git a/android-components/components/service/sync-autofill/src/test/java/mozilla/components/service/sync/autofill/AutofillCryptoTest.kt b/android-components/components/service/sync-autofill/src/test/java/mozilla/components/service/sync/autofill/AutofillCryptoTest.kt
index dde8f349f5a7..be7e8ab92e3f 100644
--- a/android-components/components/service/sync-autofill/src/test/java/mozilla/components/service/sync/autofill/AutofillCryptoTest.kt
+++ b/android-components/components/service/sync-autofill/src/test/java/mozilla/components/service/sync/autofill/AutofillCryptoTest.kt
@@ -5,6 +5,7 @@
 package mozilla.components.service.sync.autofill
 
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import kotlinx.coroutines.runBlocking
 import mozilla.components.concept.storage.CreditCardNumber
 import mozilla.components.concept.storage.KeyGenerationReason
 import mozilla.components.concept.storage.ManagedKey
@@ -31,9 +32,9 @@ class AutofillCryptoTest {
     }
 
     @Test
-    fun `get key - new`() {
-        val handler = mock<KeyRecoveryHandler>()
-        val crypto = AutofillCrypto(testContext, securePrefs, handler)
+    fun `get key - new`() = runBlocking {
+        val storage = mock<AutofillCreditCardsAddressesStorage>()
+        val crypto = AutofillCrypto(testContext, securePrefs, storage)
         val key = crypto.getOrGenerateKey()
         assertEquals(KeyGenerationReason.New, key.wasGenerated)
 
@@ -42,13 +43,13 @@ class AutofillCryptoTest {
         assertNull(key2.wasGenerated)
 
         assertEquals(key.key, key2.key)
-        verifyNoInteractions(handler)
+        verifyNoInteractions(storage)
     }
 
     @Test
-    fun `get key - lost`() {
-        val handler = mock<KeyRecoveryHandler>()
-        val crypto = AutofillCrypto(testContext, securePrefs, handler)
+    fun `get key - lost`() = runBlocking {
+        val storage = mock<AutofillCreditCardsAddressesStorage>()
+        val crypto = AutofillCrypto(testContext, securePrefs, storage)
         val key = crypto.getOrGenerateKey()
         assertEquals(KeyGenerationReason.New, key.wasGenerated)
 
@@ -58,13 +59,13 @@ class AutofillCryptoTest {
         assertEquals(KeyGenerationReason.RecoveryNeeded.Lost, key2.wasGenerated)
 
         assertNotEquals(key.key, key2.key)
-        verify(handler).recoverFromBadKey(KeyGenerationReason.RecoveryNeeded.Lost)
+        verify(storage).scrubEncryptedData()
     }
 
     @Test
-    fun `get key - corrupted`() {
-        val handler = mock<KeyRecoveryHandler>()
-        val crypto = AutofillCrypto(testContext, securePrefs, handler)
+    fun `get key - corrupted`() = runBlocking {
+        val storage = mock<AutofillCreditCardsAddressesStorage>()
+        val crypto = AutofillCrypto(testContext, securePrefs, storage)
         val key = crypto.getOrGenerateKey()
         assertEquals(KeyGenerationReason.New, key.wasGenerated)
 
@@ -75,13 +76,13 @@ class AutofillCryptoTest {
         assertEquals(KeyGenerationReason.RecoveryNeeded.Corrupt, key2.wasGenerated)
 
         assertNotEquals(key.key, key2.key)
-        verify(handler).recoverFromBadKey(KeyGenerationReason.RecoveryNeeded.Corrupt)
+        verify(storage).scrubEncryptedData()
     }
 
     @Test
-    fun `get key - corrupted subtly`() {
-        val handler = mock<KeyRecoveryHandler>()
-        val crypto = AutofillCrypto(testContext, securePrefs, handler)
+    fun `get key - corrupted subtly`() = runBlocking {
+        val storage = mock<AutofillCreditCardsAddressesStorage>()
+        val crypto = AutofillCrypto(testContext, securePrefs, storage)
         val key = crypto.getOrGenerateKey()
         assertEquals(KeyGenerationReason.New, key.wasGenerated)
 
@@ -93,11 +94,11 @@ class AutofillCryptoTest {
         assertEquals(KeyGenerationReason.RecoveryNeeded.Corrupt, key2.wasGenerated)
 
         assertNotEquals(key.key, key2.key)
-        verify(handler).recoverFromBadKey(KeyGenerationReason.RecoveryNeeded.Corrupt)
+        verify(storage).scrubEncryptedData()
     }
 
     @Test
-    fun `encrypt and decrypt card - normal`() {
+    fun `encrypt and decrypt card - normal`() = runBlocking {
         val crypto = AutofillCrypto(testContext, securePrefs, mock())
         val key = crypto.getOrGenerateKey()
         val plaintext1 = CreditCardNumber.Plaintext("4111111111111111")
@@ -114,7 +115,7 @@ class AutofillCryptoTest {
     }
 
     @Test
-    fun `encrypt and decrypt card - bad keys`() {
+    fun `encrypt and decrypt card - bad keys`() = runBlocking {
         val crypto = AutofillCrypto(testContext, securePrefs, mock())
         val plaintext = CreditCardNumber.Plaintext("4111111111111111")
 
diff --git a/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/LoginsCrypto.kt b/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/LoginsCrypto.kt
index a18b70387c0a..9d89f173b10e 100644
--- a/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/LoginsCrypto.kt
+++ b/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/LoginsCrypto.kt
@@ -9,16 +9,14 @@ import android.content.SharedPreferences
 import mozilla.appservices.logins.KeyRegenerationEventReason
 import mozilla.appservices.logins.checkCanary
 import mozilla.appservices.logins.createCanary
-import mozilla.appservices.logins.createKey
 import mozilla.appservices.logins.decryptFields
 import mozilla.appservices.logins.recordKeyRegenerationEvent
 import mozilla.components.concept.storage.EncryptedLogin
 import mozilla.components.concept.storage.KeyGenerationReason
-import mozilla.components.concept.storage.KeyProvider
+import mozilla.components.concept.storage.KeyManager
 import mozilla.components.concept.storage.Login
 import mozilla.components.concept.storage.ManagedKey
 import mozilla.components.lib.dataprotect.SecureAbove22Preferences
-import mozilla.components.support.base.log.logger.Logger
 
 /**
  * A class that knows how to encrypt & decrypt strings, backed by application-services' logins lib.
@@ -34,10 +32,57 @@ class LoginsCrypto(
     private val context: Context,
     private val securePrefs: SecureAbove22Preferences,
     private val storage: SyncableLoginsStorage
-) : KeyProvider {
-    private val logger = Logger("LoginsCrypto")
+) : KeyManager() {
     private val plaintextPrefs by lazy { context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE) }
 
+    override suspend fun recoverFromKeyLoss(reason: KeyGenerationReason.RecoveryNeeded) {
+        val telemetryEventReason = when (reason) {
+            is KeyGenerationReason.RecoveryNeeded.Lost -> KeyRegenerationEventReason.Lost
+            is KeyGenerationReason.RecoveryNeeded.Corrupt -> KeyRegenerationEventReason.Corrupt
+            is KeyGenerationReason.RecoveryNeeded.AbnormalState -> KeyRegenerationEventReason.Other
+        }
+        recordKeyRegenerationEvent(telemetryEventReason)
+        storage.conn.getStorage().wipeLocal()
+    }
+
+    override fun getStoredCanary(): String? {
+        return plaintextPrefs.getString(CANARY_PHRASE_CIPHERTEXT_KEY, null)
+    }
+
+    override fun getStoredKey(): String? {
+        return securePrefs.getString(LOGINS_KEY)
+    }
+
+    override fun storeKeyAndCanary(key: String) {
+        // To consider: should this be a non-destructive operation, just in case?
+        // e.g. if we thought we lost the key, but actually did not, that would let us recover data later on.
+        // otherwise, if we mess up and override a perfectly good key, the data is gone for good.
+        securePrefs.putString(LOGINS_KEY, key)
+        // To detect key corruption or absence, use the newly generated key to encrypt a known string.
+        // See isKeyValid below.
+        plaintextPrefs
+            .edit()
+            .putString(CANARY_PHRASE_CIPHERTEXT_KEY, createCanary(CANARY_PHRASE_PLAINTEXT, key))
+            .apply()
+    }
+
+    override fun createKey(): String {
+        return mozilla.appservices.logins.createKey()
+    }
+
+    override fun isKeyRecoveryNeeded(rawKey: String, canary: String): KeyGenerationReason.RecoveryNeeded? {
+        return try {
+            if (checkCanary(canary, CANARY_PHRASE_PLAINTEXT, rawKey)) {
+                null
+            } else {
+                // A bad key should trigger a CryptoException, but check this branch just in case.
+                KeyGenerationReason.RecoveryNeeded.Corrupt
+            }
+        } catch (e: CryptoException) {
+            KeyGenerationReason.RecoveryNeeded.Corrupt
+        }
+    }
+
     /**
      * Decrypts ciphertext fields within [login], producing a plaintext [Login].
      */
@@ -75,100 +120,6 @@ class LoginsCrypto(
         )
     }
 
-    override suspend fun getOrGenerateKey(): ManagedKey = synchronized(this) {
-        val managedKey = getManagedKey()
-
-        // Record abnormal events if any were detected.
-        // At this point, we should emit some telemetry.
-        // See https://github.com/mozilla-mobile/android-components/issues/10122
-        when (managedKey.wasGenerated) {
-            is KeyGenerationReason.RecoveryNeeded.Lost -> {
-                logger.warn("Key lost")
-                recordKeyRegenerationEvent(KeyRegenerationEventReason.Lost)
-            }
-            is KeyGenerationReason.RecoveryNeeded.Corrupt -> {
-                logger.warn("Key corrupted")
-                recordKeyRegenerationEvent(KeyRegenerationEventReason.Corrupt)
-            }
-            is KeyGenerationReason.RecoveryNeeded.AbnormalState -> {
-                logger.warn("Abnormal state while reading the key")
-                recordKeyRegenerationEvent(KeyRegenerationEventReason.Other)
-            }
-            null, KeyGenerationReason.New -> {
-                // All good! Got either a brand new key or read a valid key.
-            }
-        }
-        (managedKey.wasGenerated as? KeyGenerationReason.RecoveryNeeded)?.let {
-            // If the key needed to be regenerated, then we lose all
-            // usernames/passwords which were encrypted with the old key.  This
-            // means we can't really use the logins anymore and wipeLocal() is the
-            // best we can do.
-            storage.conn.getStorage().wipeLocal()
-        }
-        return managedKey
-    }
-
-    @Suppress("ComplexMethod")
-    private fun getManagedKey(): ManagedKey = synchronized(this) {
-        val encryptedCanaryPhrase = plaintextPrefs.getString(CANARY_PHRASE_CIPHERTEXT_KEY, null)
-        val storedKey = securePrefs.getString(LOGINS_KEY)
-
-        return@synchronized when {
-            // We expected the key to be present, and it is.
-            storedKey != null && encryptedCanaryPhrase != null -> {
-                // Make sure that the key is valid.
-                try {
-                    if (checkCanary(encryptedCanaryPhrase, CANARY_PHRASE_PLAINTEXT, storedKey)) {
-                        ManagedKey(storedKey)
-                    } else {
-                        // A bad key should trigger a CryptoException, but check this branch just in case.
-                        ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Corrupt)
-                    }
-                } catch (e: CryptoException) {
-                    ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Corrupt)
-                }
-            }
-
-            // The key is present, but we didn't expect it to be there.
-            storedKey != null && encryptedCanaryPhrase == null -> {
-                // This isn't expected to happen. We can't check this key's validity.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.AbnormalState)
-            }
-
-            // We expected the key to be present, but it's gone missing on us.
-            storedKey == null && encryptedCanaryPhrase != null -> {
-                // At this point, we're forced to generate a new key to recover and move forward.
-                // However, that means that any data that was previously encrypted is now unreadable.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.RecoveryNeeded.Lost)
-            }
-
-            // We didn't expect the key to be present, and it's not.
-            storedKey == null && encryptedCanaryPhrase == null -> {
-                // Normal case when interacting with this class for the first time.
-                ManagedKey(generateAndStoreKey(), KeyGenerationReason.New)
-            }
-
-            // The above cases seem exhaustive, but Kotlin doesn't think so.
-            // Throw IllegalStateException if we get here.
-            else -> throw IllegalStateException()
-        }
-    }
-
-    private fun generateAndStoreKey(): String {
-        return createKey().also { newKey ->
-            // To consider: should this be a non-destructive operation, just in case?
-            // e.g. if we thought we lost the key, but actually did not, that would let us recover data later on.
-            // otherwise, if we mess up and override a perfectly good key, the data is gone for good.
-            securePrefs.putString(LOGINS_KEY, newKey)
-            // To detect key corruption or absence, use the newly generated key to encrypt a known string.
-            // See isKeyValid below.
-            plaintextPrefs
-                .edit()
-                .putString(CANARY_PHRASE_CIPHERTEXT_KEY, createCanary(CANARY_PHRASE_PLAINTEXT, newKey))
-                .apply()
-        }
-    }
-
     companion object {
         const val PREFS_NAME = "loginsCrypto"
         const val LOGINS_KEY = "loginsKey"
diff --git a/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/SyncableLoginsStorage.kt b/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/SyncableLoginsStorage.kt
index 18ec6f33932d..2eb6a4b86200 100644
--- a/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/SyncableLoginsStorage.kt
+++ b/android-components/components/service/sync-logins/src/main/java/mozilla/components/service/sync/logins/SyncableLoginsStorage.kt
@@ -5,7 +5,6 @@
 package mozilla.components.service.sync.logins
 
 import android.content.Context
-import android.content.SharedPreferences
 import androidx.annotation.GuardedBy
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.cancel
@@ -14,10 +13,8 @@ import kotlinx.coroutines.withContext
 import mozilla.appservices.logins.DatabaseLoginsStorage
 import mozilla.appservices.logins.migrateLoginsWithMetrics
 import mozilla.components.concept.storage.EncryptedLogin
-import mozilla.components.concept.storage.KeyGenerationReason
 import mozilla.components.concept.storage.Login
 import mozilla.components.concept.storage.LoginEntry
-import mozilla.components.concept.storage.ManagedKey
 import mozilla.components.concept.storage.LoginsStorage
 import mozilla.components.concept.sync.SyncableStore
 import mozilla.components.lib.dataprotect.SecureAbove22Preferences
@@ -291,10 +288,10 @@ class SyncableLoginsStorage(
         if (version == 0) {
             try {
                 migrateLoginsWithMetrics(
-                        context.getDatabasePath(DB_NAME).absolutePath,
-                        crypto.getOrGenerateKey().key,
-                        context.getDatabasePath(DB_NAME_SQLCIPHER).absolutePath,
-                        sqlcipherKey,
+                    context.getDatabasePath(DB_NAME).absolutePath,
+                    crypto.getOrGenerateKey().key,
+                    context.getDatabasePath(DB_NAME_SQLCIPHER).absolutePath,
+                    sqlcipherKey,
                 )
                 // Note: DatabaseLoginsStorage.migrateLogins, defined in
                 // application-services, is responsible for reporting the migration
