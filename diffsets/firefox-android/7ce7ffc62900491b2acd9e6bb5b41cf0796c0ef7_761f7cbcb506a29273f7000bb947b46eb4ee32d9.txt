diff --git a/android-components/components/browser/awesomebar/src/main/java/mozilla/components/browser/awesomebar/BrowserAwesomeBar.kt b/android-components/components/browser/awesomebar/src/main/java/mozilla/components/browser/awesomebar/BrowserAwesomeBar.kt
index 03ef34513757..3525042c4385 100644
--- a/android-components/components/browser/awesomebar/src/main/java/mozilla/components/browser/awesomebar/BrowserAwesomeBar.kt
+++ b/android-components/components/browser/awesomebar/src/main/java/mozilla/components/browser/awesomebar/BrowserAwesomeBar.kt
@@ -11,13 +11,14 @@ import android.util.AttributeSet
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.Job
+import kotlinx.coroutines.asCoroutineDispatcher
 import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
-import kotlinx.coroutines.newFixedThreadPoolContext
 import mozilla.components.browser.awesomebar.layout.SuggestionLayout
 import mozilla.components.browser.awesomebar.transform.SuggestionTransformer
 import mozilla.components.concept.awesomebar.AwesomeBar
 import mozilla.components.support.ktx.android.content.res.pxToDp
+import java.util.concurrent.Executors
 
 private const val PROVIDER_QUERY_THREADS = 3
 
@@ -35,7 +36,7 @@ class BrowserAwesomeBar @JvmOverloads constructor(
     attrs: AttributeSet? = null,
     defStyleAttr: Int = 0
 ) : RecyclerView(context, attrs, defStyleAttr), AwesomeBar {
-    private val jobDispatcher = newFixedThreadPoolContext(PROVIDER_QUERY_THREADS, "AwesomeBarProviders")
+    private val jobDispatcher = Executors.newFixedThreadPool(PROVIDER_QUERY_THREADS).asCoroutineDispatcher()
     private val providers: MutableList<AwesomeBar.SuggestionProvider> = mutableListOf()
     internal var suggestionsAdapter = SuggestionsAdapter(this)
     internal var scope = CoroutineScope(Dispatchers.Main)
diff --git a/android-components/components/browser/domains/src/main/java/mozilla/components/browser/domains/autocomplete/Providers.kt b/android-components/components/browser/domains/src/main/java/mozilla/components/browser/domains/autocomplete/Providers.kt
index 6fd7e7cee8c1..1302dc58b029 100644
--- a/android-components/components/browser/domains/src/main/java/mozilla/components/browser/domains/autocomplete/Providers.kt
+++ b/android-components/components/browser/domains/src/main/java/mozilla/components/browser/domains/autocomplete/Providers.kt
@@ -73,6 +73,7 @@ abstract class BaseDomainAutocompleteProvider(private val list: DomainList) :
             val wwwDomain = "www.${it.host}"
             if (wwwDomain.startsWith(searchText)) {
                 return DomainAutocompleteResult(
+                    input = searchText,
                     text = getResultText(query, wwwDomain),
                     url = it.url,
                     source = list.listName,
@@ -82,6 +83,7 @@ abstract class BaseDomainAutocompleteProvider(private val list: DomainList) :
 
             if (it.host.startsWith(searchText)) {
                 return DomainAutocompleteResult(
+                    input = searchText,
                     text = getResultText(query, it.host),
                     url = it.url,
                     source = list.listName,
@@ -106,12 +108,14 @@ abstract class BaseDomainAutocompleteProvider(private val list: DomainList) :
 
 /**
  * Describes an autocompletion result against a list of domains.
+* @property input Input for which this result is being provided.
  * @property text Result of autocompletion, text to be displayed.
  * @property url Result of autocompletion, full matching url.
  * @property source Name of the autocompletion source.
  * @property totalItems A total number of results also available.
  */
 class DomainAutocompleteResult(
+    val input: String,
     val text: String,
     val url: String,
     val source: String,
diff --git a/android-components/components/browser/storage-memory/src/main/java/mozilla/components/browser/storage/memory/InMemoryHistoryStorage.kt b/android-components/components/browser/storage-memory/src/main/java/mozilla/components/browser/storage/memory/InMemoryHistoryStorage.kt
index 973a4733b822..ad8e4d648d35 100644
--- a/android-components/components/browser/storage-memory/src/main/java/mozilla/components/browser/storage/memory/InMemoryHistoryStorage.kt
+++ b/android-components/components/browser/storage-memory/src/main/java/mozilla/components/browser/storage/memory/InMemoryHistoryStorage.kt
@@ -85,7 +85,7 @@ class InMemoryHistoryStorage : HistoryStorage {
     override fun getAutocompleteSuggestion(query: String): HistoryAutocompleteResult? = synchronized(pages) {
         segmentAwareDomainMatch(query, pages.keys)?.let { urlMatch ->
             return HistoryAutocompleteResult(
-                urlMatch.matchedSegment, urlMatch.url, AUTOCOMPLETE_SOURCE_NAME, pages.size)
+                query, urlMatch.matchedSegment, urlMatch.url, AUTOCOMPLETE_SOURCE_NAME, pages.size)
         }
     }
 
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
index 857b55436671..ee6d88e8b717 100644
--- a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
@@ -93,7 +93,13 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
 
         val resultText = segmentAwareDomainMatch(query, arrayListOf(url))
         return resultText?.let {
-            HistoryAutocompleteResult(it.matchedSegment, it.url, AUTOCOMPLETE_SOURCE_NAME, 1)
+            HistoryAutocompleteResult(
+                input = query,
+                text = it.matchedSegment,
+                url = it.url,
+                source = AUTOCOMPLETE_SOURCE_NAME,
+                totalItems = 1
+            )
         }
     }
 
diff --git a/android-components/components/browser/toolbar/build.gradle b/android-components/components/browser/toolbar/build.gradle
index 83cce760eb16..6bae8168e69f 100644
--- a/android-components/components/browser/toolbar/build.gradle
+++ b/android-components/components/browser/toolbar/build.gradle
@@ -34,6 +34,7 @@ dependencies {
     implementation Dependencies.support_appcompat
     implementation Dependencies.support_design
     implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
 
     testImplementation project(':support-test')
 
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
index 52e1ce22a5ae..4e0b881cd7bd 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
@@ -14,6 +14,14 @@ import android.view.View
 import android.view.View.OnFocusChangeListener
 import android.view.ViewGroup
 import android.widget.ImageButton
+import kotlinx.coroutines.CoroutineExceptionHandler
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.SupervisorJob
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.cancelChildren
+import kotlinx.coroutines.isActive
+import kotlinx.coroutines.launch
 import mozilla.components.browser.menu.BrowserMenuBuilder
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.browser.toolbar.edit.EditToolbar
@@ -21,10 +29,17 @@ import mozilla.components.concept.toolbar.AutocompleteDelegate
 import mozilla.components.concept.toolbar.AutocompleteResult
 import mozilla.components.concept.toolbar.Toolbar
 import mozilla.components.support.base.android.Padding
+import mozilla.components.support.base.log.logger.Logger
 import mozilla.components.support.ktx.android.content.res.pxToDp
 import mozilla.components.support.ktx.android.view.forEach
 import mozilla.components.support.ktx.android.view.isVisible
+import mozilla.components.ui.autocomplete.AutocompleteView
 import mozilla.components.ui.autocomplete.InlineAutocompleteEditText
+import mozilla.components.ui.autocomplete.OnFilterListener
+import java.util.concurrent.Executors
+import kotlin.coroutines.CoroutineContext
+
+private const val AUTOCOMPLETE_QUERY_THREADS = 3
 
 /**
  * A customizable toolbar for browsers.
@@ -50,11 +65,22 @@ class BrowserToolbar @JvmOverloads constructor(
     attrs: AttributeSet? = null,
     defStyleAttr: Int = 0
 ) : ViewGroup(context, attrs, defStyleAttr), Toolbar {
+    private val logger = Logger("BrowserToolbar")
+
     // displayToolbar and editToolbar are only visible internally and mutable so that we can mock
     // them in tests.
     @VisibleForTesting internal var displayToolbar = DisplayToolbar(context, this)
     @VisibleForTesting internal var editToolbar = EditToolbar(context, this)
 
+    private val autocompleteExceptionHandler = CoroutineExceptionHandler { _, throwable ->
+        logger.error("Error while processing autocomplete input", throwable)
+    }
+
+    private val autocompleteSupervisorJob = SupervisorJob()
+    private val autocompleteDispatcher = autocompleteSupervisorJob +
+        Executors.newFixedThreadPool(AUTOCOMPLETE_QUERY_THREADS).asCoroutineDispatcher() +
+        autocompleteExceptionHandler
+
     /**
      * Set/Get whether a site security icon (usually a lock or globe icon) should be next to the URL.
      */
@@ -157,24 +183,14 @@ class BrowserToolbar @JvmOverloads constructor(
         editToolbar.editListener = listener
     }
 
-    override fun setAutocompleteListener(filter: (String, AutocompleteDelegate) -> Unit) {
+    override fun setAutocompleteListener(filter: suspend (String, AutocompleteDelegate) -> Unit) {
         // Our 'filter' knows how to autocomplete, and the 'urlView' knows how to apply results of
         // autocompletion. Which gives us a lovely delegate chain!
         // urlView decides when it's appropriate to ask for autocompletion, and in turn we invoke
         // our 'filter' and send results back to 'urlView'.
-        editToolbar.urlView.setOnFilterListener { text ->
-            filter.invoke(text, object : AutocompleteDelegate {
-                override fun applyAutocompleteResult(result: AutocompleteResult) {
-                    editToolbar.urlView.applyAutocompleteResult(InlineAutocompleteEditText.AutocompleteResult(
-                        text = result.text, source = result.source, totalItems = result.totalItems
-                    ))
-                }
-
-                override fun noAutocompleteResult() {
-                    editToolbar.urlView.noAutocompleteResult()
-                }
-            })
-        }
+        editToolbar.urlView.setOnFilterListener(
+            AsyncFilterListener(editToolbar.urlView, autocompleteDispatcher, filter)
+        )
     }
 
     /**
@@ -504,3 +520,77 @@ class BrowserToolbar @JvmOverloads constructor(
             Padding(ACTION_PADDING_DP, ACTION_PADDING_DP, ACTION_PADDING_DP, ACTION_PADDING_DP)
     }
 }
+
+/**
+ * Wraps [filter] execution in a coroutine context, cancelling prior executions on every invocation.
+ * [coroutineContext] must be of type that doesn't propagate cancellation of its children upwards.
+ */
+class AsyncFilterListener(
+    private val urlView: AutocompleteView,
+    override val coroutineContext: CoroutineContext,
+    private val filter: suspend (String, AutocompleteDelegate) -> Unit,
+    private val uiContext: CoroutineContext = Dispatchers.Main
+) : OnFilterListener, CoroutineScope {
+    override fun invoke(text: String) {
+        // We got a new input, so whatever past autocomplete queries we still have running are
+        // irrelevant. We cancel them, but do not depend on cancellation to take place.
+        coroutineContext.cancelChildren()
+
+        CoroutineScope(coroutineContext).launch {
+            filter(text, AsyncAutocompleteDelegate(urlView, this, uiContext))
+        }
+    }
+}
+
+/**
+ * An autocomplete delegate which is aware of its parent scope (to check for cancellations).
+ * Responsible for processing autocompletion results and discarding stale results when [urlView] moved on.
+ */
+class AsyncAutocompleteDelegate(
+    private val urlView: AutocompleteView,
+    private val parentScope: CoroutineScope,
+    override val coroutineContext: CoroutineContext,
+    private val logger: Logger = Logger("AsyncAutocompleteDelegate")
+) : AutocompleteDelegate, CoroutineScope {
+    override fun applyAutocompleteResult(result: AutocompleteResult) {
+        // Bail out if we were cancelled already.
+        if (!parentScope.isActive) {
+            logger.debug("Autocomplete request cancelled. Discarding results.")
+            return
+        }
+
+        // Process results on the UI dispatcher.
+        CoroutineScope(coroutineContext).launch {
+            // Ignore this result if the query is stale.
+            if (result.input == urlView.originalText) {
+                urlView.applyAutocompleteResult(
+                    InlineAutocompleteEditText.AutocompleteResult(
+                        text = result.text,
+                        source = result.source,
+                        totalItems = result.totalItems
+                    )
+                )
+            } else {
+                logger.debug("Discarding stale autocomplete result.")
+            }
+        }
+    }
+
+    override fun noAutocompleteResult(input: String) {
+        // Bail out if we were cancelled already.
+        if (!parentScope.isActive) {
+            logger.debug("Autocomplete request cancelled. Discarding 'noAutocompleteResult'.")
+            return
+        }
+
+        // Process results on the UI thread.
+        CoroutineScope(coroutineContext).launch {
+            // Ignore this result if the query is stale.
+            if (input == urlView.originalText) {
+                urlView.noAutocompleteResult()
+            } else {
+                logger.debug("Discarding stale lack of autocomplete results.")
+            }
+        }
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/AsyncFilterListenerTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/AsyncFilterListenerTest.kt
new file mode 100644
index 000000000000..41e07ce57007
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/AsyncFilterListenerTest.kt
@@ -0,0 +1,299 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar
+
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.async
+import kotlinx.coroutines.cancelChildren
+import kotlinx.coroutines.isActive
+import kotlinx.coroutines.runBlocking
+import mozilla.components.concept.toolbar.AutocompleteDelegate
+import mozilla.components.concept.toolbar.AutocompleteResult
+import mozilla.components.support.test.mock
+import mozilla.components.ui.autocomplete.AutocompleteView
+import mozilla.components.ui.autocomplete.InlineAutocompleteEditText
+import org.junit.Assert.assertEquals
+import org.junit.Assert.fail
+import org.junit.Test
+import org.mockito.Mockito.atLeast
+import org.mockito.Mockito.atLeastOnce
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import java.util.concurrent.Executor
+
+class AsyncFilterListenerTest {
+    @Test
+    fun `filter listener cancels prior filter executions`() = runBlocking {
+        val urlView: AutocompleteView = mock()
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = mock()
+
+        val dispatcher = spy(Executor {
+            it.run()
+        }.asCoroutineDispatcher())
+
+        val listener = AsyncFilterListener(urlView, dispatcher, filter)
+
+        verify(dispatcher, never()).cancelChildren()
+
+        listener("test")
+
+        verify(dispatcher, atLeastOnce()).cancelChildren()
+    }
+
+    @Test
+    fun `filter delegate checks for cancellations before it runs, passes results to autocomplete view`() = runBlocking {
+        var filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            assertEquals("test", query)
+            delegate.applyAutocompleteResult(AutocompleteResult(
+                input = "test",
+                text = "testing.com",
+                url = "http://www.testing.com",
+                source = "asyncTest",
+                totalItems = 1
+            ))
+        }
+
+        val dispatcher = spy(Executor {
+            it.run()
+        }.asCoroutineDispatcher())
+
+        var didCallApply = 0
+
+        var listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "test"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                assertEquals("asyncTest", result.source)
+                assertEquals("testing.com", result.text)
+                assertEquals(1, result.totalItems)
+                didCallApply += 1
+            }
+
+            override fun noAutocompleteResult() {
+                fail()
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        verify(dispatcher, never()).isActive
+
+        async { listener("test") }.await()
+
+        // Checked if parent scope is still active. Somehow, each access to 'isActive' registers as 4?
+        verify(dispatcher, atLeast(4)).isActive
+        // Passed the result to the view's apply method exactly once.
+        assertEquals(1, didCallApply)
+
+        filter = { query, delegate ->
+            assertEquals("moz", query)
+            delegate.applyAutocompleteResult(AutocompleteResult(
+                input = "moz",
+                text = "mozilla.com",
+                url = "http://www.mozilla.com",
+                source = "asyncTestTwo",
+                totalItems = 2
+            ))
+        }
+        listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "moz"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                assertEquals("asyncTestTwo", result.source)
+                assertEquals("mozilla.com", result.text)
+                assertEquals(2, result.totalItems)
+                didCallApply += 1
+            }
+
+            override fun noAutocompleteResult() {
+                fail()
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        async { listener("moz") }.await()
+
+        verify(dispatcher, atLeast(8)).isActive
+        assertEquals(2, didCallApply)
+    }
+
+    @Test
+    fun `delegate discards stale results`() = runBlocking {
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            assertEquals("test", query)
+            delegate.applyAutocompleteResult(AutocompleteResult(
+                input = "test",
+                text = "testing.com",
+                url = "http://www.testing.com",
+                source = "asyncTest",
+                totalItems = 1
+            ))
+        }
+
+        val dispatcher = Executor {
+            it.run()
+        }.asCoroutineDispatcher()
+
+        val listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "nolongertest"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                fail()
+            }
+
+            override fun noAutocompleteResult() {
+                fail()
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        listener("test")
+    }
+
+    @Test
+    fun `delegate discards stale lack of results`() = runBlocking {
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            assertEquals("test", query)
+            delegate.noAutocompleteResult("test")
+        }
+
+        val dispatcher = Executor {
+            it.run()
+        }.asCoroutineDispatcher()
+
+        val listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "nolongertest"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                fail()
+            }
+
+            override fun noAutocompleteResult() {
+                fail()
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        listener("test")
+    }
+
+    @Test
+    fun `delegate passes through non-stale lack of results`() = runBlocking {
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            assertEquals("test", query)
+            delegate.noAutocompleteResult("test")
+        }
+
+        val dispatcher = Executor {
+            it.run()
+        }.asCoroutineDispatcher()
+
+        var calledNoResults = 0
+        val listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "test"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                fail()
+            }
+
+            override fun noAutocompleteResult() {
+                calledNoResults += 1
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        async { listener("test") }.await()
+
+        assertEquals(1, calledNoResults)
+    }
+
+    @Test
+    fun `delegate discards results if parent scope was cancelled`() = runBlocking {
+        var preservedDelegate: AutocompleteDelegate? = null
+
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            preservedDelegate = delegate
+            assertEquals("test", query)
+            delegate.applyAutocompleteResult(AutocompleteResult(
+                input = "test",
+                text = "testing.com",
+                url = "http://www.testing.com",
+                source = "asyncTest",
+                totalItems = 1
+            ))
+        }
+
+        val dispatcher = Executor {
+            it.run()
+        }.asCoroutineDispatcher()
+
+        var calledResults = 0
+        val listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "test"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                assertEquals("asyncTest", result.source)
+                assertEquals("testing.com", result.text)
+                assertEquals(1, result.totalItems)
+                calledResults += 1
+            }
+
+            override fun noAutocompleteResult() {
+                fail()
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        async {
+            listener("test")
+            listener("test")
+        }.await()
+
+        // This result application should be discarded, because scope has been cancelled by the second
+        // 'listener' call above.
+        preservedDelegate!!.applyAutocompleteResult(AutocompleteResult(
+            input = "test",
+            text = "testing.com",
+            url = "http://www.testing.com",
+            source = "asyncCancelled",
+            totalItems = 1
+        ))
+
+        assertEquals(2, calledResults)
+    }
+
+    @Test
+    fun `delegate discards lack of results if parent scope was cancelled`() = runBlocking {
+        var preservedDelegate: AutocompleteDelegate? = null
+
+        val filter: suspend (String, AutocompleteDelegate) -> Unit = { query, delegate ->
+            preservedDelegate = delegate
+            assertEquals("test", query)
+            delegate.noAutocompleteResult("test")
+        }
+
+        val dispatcher = Executor {
+            it.run()
+        }.asCoroutineDispatcher()
+
+        var calledResults = 0
+        val listener = AsyncFilterListener(object : AutocompleteView {
+            override val originalText: String = "test"
+
+            override fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult) {
+                fail()
+            }
+
+            override fun noAutocompleteResult() {
+                calledResults += 1
+            }
+        }, dispatcher, filter, this.coroutineContext)
+
+        async {
+            listener("test")
+            listener("test")
+        }.await()
+
+        // This "no results" call should be discarded, because scope has been cancelled by the second
+        // 'listener' call above.
+        preservedDelegate!!.noAutocompleteResult("test")
+
+        assertEquals(2, calledResults)
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/edit/EditToolbarTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/edit/EditToolbarTest.kt
index e52d028ed45e..05cff7e49d5a 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/edit/EditToolbarTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/edit/EditToolbarTest.kt
@@ -4,6 +4,7 @@
 
 package mozilla.components.browser.toolbar.edit
 
+import kotlinx.coroutines.runBlocking
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.toolbar.AutocompleteDelegate
 import org.junit.Assert.assertEquals
@@ -13,21 +14,30 @@ import org.junit.Test
 import org.junit.runner.RunWith
 import org.robolectric.RobolectricTestRunner
 import org.robolectric.RuntimeEnvironment
+import java.util.concurrent.CountDownLatch
 
 @RunWith(RobolectricTestRunner::class)
 class EditToolbarTest {
     @Test
-    fun `entered text is forwarded to autocomplete filter`() {
+    fun `entered text is forwarded to async autocomplete filter`() {
         val toolbar = BrowserToolbar(RuntimeEnvironment.application)
         toolbar.editToolbar.urlView.onAttachedToWindow()
 
+        val latch = CountDownLatch(1)
         var invokedWithParams: List<Any?>? = null
         toolbar.setAutocompleteListener { p1, p2 ->
             invokedWithParams = listOf(p1, p2)
+            latch.countDown()
         }
 
         toolbar.editToolbar.urlView.setText("Hello")
 
+        // Autocomplete filter will be invoked on a worker thread.
+        // Serialize here for the sake of tests.
+        runBlocking {
+            latch.await()
+        }
+
         assertEquals("Hello", invokedWithParams!![0])
         assertTrue(invokedWithParams!![1] is AutocompleteDelegate)
     }
diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
index 4ae2e2078681..c9f090715cd0 100644
--- a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
@@ -88,12 +88,14 @@ data class SearchResult(
 
 /**
  * Describes an autocompletion result against history storage.
+ * @property input Input for which this result is being provided.
  * @property text Result of autocompletion, text to be displayed.
  * @property url Result of autocompletion, full matching url.
  * @property source Name of the autocompletion source.
  * @property totalItems A total number of results also available.
  */
 data class HistoryAutocompleteResult(
+    val input: String,
     val text: String,
     val url: String,
     val source: String,
diff --git a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/AutocompleteDelegate.kt b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/AutocompleteDelegate.kt
index 790555d9a12f..f48a82de9a3c 100644
--- a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/AutocompleteDelegate.kt
+++ b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/AutocompleteDelegate.kt
@@ -17,17 +17,19 @@ interface AutocompleteDelegate {
     /**
      * Autocompletion was invoked and no match was returned.
      */
-    fun noAutocompleteResult()
+    fun noAutocompleteResult(input: String)
 }
 
 /**
  * Describes an autocompletion result.
+ * @property input Input for which this AutocompleteResult is being provided.
  * @property text AutocompleteResult of autocompletion, text to be displayed.
  * @property url AutocompleteResult of autocompletion, full matching url.
  * @property source Name of the autocompletion source.
  * @property totalItems A total number of results also available.
  */
 data class AutocompleteResult(
+    val input: String,
     val text: String,
     val url: String,
     val source: String,
diff --git a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
index 47c12c20fb74..7dce6efe37ae 100644
--- a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
+++ b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
@@ -63,7 +63,7 @@ interface Toolbar {
      *
      * @param filter A function which will perform autocompletion and send results to [AutocompleteDelegate].
      */
-    fun setAutocompleteListener(filter: (String, AutocompleteDelegate) -> Unit)
+    fun setAutocompleteListener(filter: suspend (String, AutocompleteDelegate) -> Unit)
 
     /**
      * Adds an action to be displayed on the right side of the toolbar in display mode.
diff --git a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeature.kt b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeature.kt
index 2f82a67f0391..9da12c7f4f06 100644
--- a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeature.kt
+++ b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeature.kt
@@ -28,7 +28,7 @@ class ToolbarAutocompleteFeature(val toolbar: Toolbar) {
                     return@setAutocompleteListener
                 }
             }
-            delegate.noAutocompleteResult()
+            delegate.noAutocompleteResult(value)
         }
     }
 
@@ -57,13 +57,15 @@ class ToolbarAutocompleteFeature(val toolbar: Toolbar) {
 
     private fun HistoryAutocompleteResult.into(): AutocompleteResult {
         return AutocompleteResult(
-            text = this.text, url = this.url, source = this.source, totalItems = this.totalItems
+            input = this.input, text = this.text, url = this.url, source = this.source,
+            totalItems = this.totalItems
         )
     }
 
     private fun DomainAutocompleteResult.into(): AutocompleteResult {
         return AutocompleteResult(
-                text = this.text, url = this.url, source = this.source, totalItems = this.totalItems
+            input = this.input, text = this.text, url = this.url, source = this.source,
+            totalItems = this.totalItems
         )
     }
 }
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
index eb49544a2d23..37c0cb51849c 100644
--- a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
@@ -33,7 +33,7 @@ class ToolbarAutocompleteFeatureTest {
         override var url: String = ""
         override var siteSecure: Toolbar.SiteSecurity = Toolbar.SiteSecurity.INSECURE
 
-        var autocompleteFilter: ((String, AutocompleteDelegate) -> Unit)? = null
+        var autocompleteFilter: (suspend (String, AutocompleteDelegate) -> Unit)? = null
 
         override fun setSearchTerms(searchTerms: String) {
             fail()
@@ -52,7 +52,7 @@ class ToolbarAutocompleteFeatureTest {
             fail()
         }
 
-        override fun setAutocompleteListener(filter: (String, AutocompleteDelegate) -> Unit) {
+        override fun setAutocompleteListener(filter: suspend (String, AutocompleteDelegate) -> Unit) {
             autocompleteFilter = filter
         }
 
@@ -90,9 +90,11 @@ class ToolbarAutocompleteFeatureTest {
         assertNotNull(toolbar.autocompleteFilter)
 
         val autocompleteDelegate: AutocompleteDelegate = mock()
-        toolbar.autocompleteFilter!!.invoke("moz", autocompleteDelegate)
+        runBlocking {
+            toolbar.autocompleteFilter!!("moz", autocompleteDelegate)
+        }
         verify(autocompleteDelegate, never()).applyAutocompleteResult(any())
-        verify(autocompleteDelegate, times(1)).noAutocompleteResult()
+        verify(autocompleteDelegate, times(1)).noAutocompleteResult("moz")
     }
 
     @Test
@@ -120,7 +122,12 @@ class ToolbarAutocompleteFeatureTest {
 
         verifyNoAutocompleteResult(toolbar, autocompleteDelegate, "hi")
         verifyAutocompleteResult(toolbar, autocompleteDelegate, "mo",
-            AutocompleteResult(text = "mozilla.org", url = "https://www.mozilla.org", source = "memoryHistory", totalItems = 1)
+            AutocompleteResult(
+                input = "mo",
+                text = "mozilla.org",
+                url = "https://www.mozilla.org",
+                source = "memoryHistory", totalItems = 1
+            )
         )
 
         // Can autocomplete with just an empty domain provider.
@@ -136,7 +143,13 @@ class ToolbarAutocompleteFeatureTest {
 
         verifyNoAutocompleteResult(toolbar, autocompleteDelegate, "hi")
         verifyAutocompleteResult(toolbar, autocompleteDelegate, "mo",
-            AutocompleteResult(text = "mozilla.org", url = "https://www.mozilla.org", source = "custom", totalItems = 1)
+            AutocompleteResult(
+                input = "mo",
+                text = "mozilla.org",
+                url = "https://www.mozilla.org",
+                source = "custom",
+                totalItems = 1
+            )
         )
 
         // Can autocomplete with empty history and domain providers.
@@ -154,7 +167,13 @@ class ToolbarAutocompleteFeatureTest {
         ))
 
         verifyAutocompleteResult(toolbar, autocompleteDelegate, "mo",
-            AutocompleteResult(text = "mozilla.org", url = "https://www.mozilla.org", source = "custom", totalItems = 2)
+            AutocompleteResult(
+                input = "mo",
+                text = "mozilla.org",
+                url = "https://www.mozilla.org",
+                source = "custom",
+                totalItems = 2
+            )
         )
 
         runBlocking {
@@ -162,25 +181,41 @@ class ToolbarAutocompleteFeatureTest {
         }
 
         verifyAutocompleteResult(toolbar, autocompleteDelegate, "mo",
-            AutocompleteResult(text = "mozilla.org", url = "https://www.mozilla.org", source = "memoryHistory", totalItems = 1)
+            AutocompleteResult(
+                input = "mo",
+                text = "mozilla.org",
+                url = "https://www.mozilla.org",
+                source = "memoryHistory",
+                totalItems = 1
+            )
         )
 
         verifyAutocompleteResult(toolbar, autocompleteDelegate, "mos",
-            AutocompleteResult(text = "moscow.ru", url = "https://moscow.ru", source = "custom", totalItems = 2)
+            AutocompleteResult(
+                input = "mos",
+                text = "moscow.ru",
+                url = "https://moscow.ru",
+                source = "custom",
+                totalItems = 2
+            )
         )
     }
 
     private fun verifyNoAutocompleteResult(toolbar: TestToolbar, autocompleteDelegate: AutocompleteDelegate, query: String) {
-        toolbar.autocompleteFilter!!.invoke(query, autocompleteDelegate)
+        runBlocking {
+            toolbar.autocompleteFilter!!(query, autocompleteDelegate)
+        }
         verify(autocompleteDelegate, never()).applyAutocompleteResult(any())
-        verify(autocompleteDelegate, times(1)).noAutocompleteResult()
+        verify(autocompleteDelegate, times(1)).noAutocompleteResult(query)
         reset(autocompleteDelegate)
     }
 
     private fun verifyAutocompleteResult(toolbar: TestToolbar, autocompleteDelegate: AutocompleteDelegate, query: String, result: AutocompleteResult) {
-        toolbar.autocompleteFilter!!.invoke(query, autocompleteDelegate)
+        runBlocking {
+            toolbar.autocompleteFilter!!.invoke(query, autocompleteDelegate)
+        }
         verify(autocompleteDelegate, times(1)).applyAutocompleteResult(result)
-        verify(autocompleteDelegate, never()).noAutocompleteResult()
+        verify(autocompleteDelegate, never()).noAutocompleteResult(query)
         reset(autocompleteDelegate)
     }
 }
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
index d39bed32bdce..906f37a2e64c 100644
--- a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
@@ -40,7 +40,7 @@ class ToolbarInteractorTest {
             listener("https://mozilla.org")
         }
 
-        override fun setAutocompleteListener(filter: (String, AutocompleteDelegate) -> Unit) {
+        override fun setAutocompleteListener(filter: suspend (String, AutocompleteDelegate) -> Unit) {
             fail()
         }
 
diff --git a/android-components/components/ui/autocomplete/src/main/java/mozilla/components/ui/autocomplete/InlineAutocompleteEditText.kt b/android-components/components/ui/autocomplete/src/main/java/mozilla/components/ui/autocomplete/InlineAutocompleteEditText.kt
index bab00e57bb13..73ad628b8930 100644
--- a/android-components/components/ui/autocomplete/src/main/java/mozilla/components/ui/autocomplete/InlineAutocompleteEditText.kt
+++ b/android-components/components/ui/autocomplete/src/main/java/mozilla/components/ui/autocomplete/InlineAutocompleteEditText.kt
@@ -41,6 +41,26 @@ typealias OnWindowsFocusChangeListener = (Boolean) -> Unit
 
 typealias TextFormatter = (String) -> String
 
+/**
+ * Aids in testing functionality which relies on some aspects of InlineAutocompleteEditText.
+ */
+interface AutocompleteView {
+    /**
+     * Current text.
+     */
+    val originalText: String
+
+    /**
+     * Apply provided [result] autocomplete result.
+     */
+    fun applyAutocompleteResult(result: InlineAutocompleteEditText.AutocompleteResult)
+
+    /**
+     * Notify that there is no autocomplete result available.
+     */
+    fun noAutocompleteResult()
+}
+
 /**
  * A UI edit text component which supports inline autocompletion.
  *
@@ -64,10 +84,10 @@ typealias TextFormatter = (String) -> String
  */
 @Suppress("LargeClass", "TooManyFunctions")
 open class InlineAutocompleteEditText @JvmOverloads constructor(
-    val ctx: Context,
+    ctx: Context,
     attrs: AttributeSet? = null,
     defStyleAttr: Int = R.attr.editTextStyle
-) : AppCompatEditText(ctx, attrs, defStyleAttr) {
+) : AppCompatEditText(ctx, attrs, defStyleAttr), AutocompleteView {
 
     data class AutocompleteResult(
         val text: String,
@@ -115,7 +135,7 @@ open class InlineAutocompleteEditText @JvmOverloads constructor(
     val nonAutocompleteText: String
         get() = getNonAutocompleteText(text)
 
-    val originalText: String
+    override val originalText: String
         get() = text.subSequence(0, autoCompletePrefixLength).toString()
 
     private val autoCompleteBackgroundColor: Int = {
@@ -352,7 +372,7 @@ open class InlineAutocompleteEditText @JvmOverloads constructor(
      * @param result the [AutocompleteProvider.AutocompleteResult] to apply
      */
     @Suppress("ComplexMethod", "ReturnCount")
-    fun applyAutocompleteResult(result: AutocompleteResult) {
+    override fun applyAutocompleteResult(result: AutocompleteResult) {
         // If discardAutoCompleteResult is true, we temporarily disabled
         // autocomplete (due to backspacing, etc.) and we should bail early.
         if (discardAutoCompleteResult) {
@@ -458,7 +478,7 @@ open class InlineAutocompleteEditText @JvmOverloads constructor(
         announceForAccessibility(text.toString())
     }
 
-    fun noAutocompleteResult() {
+    override fun noAutocompleteResult() {
         removeAutocomplete(text)
     }
 
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 71da09dddcd6..9c501593214e 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -130,6 +130,17 @@ permalink: /changelog/
     * `browser-engine-gecko-beta`: 66.0
     * `browser-engine-gecko-nightly`: 67.0
 
+* **browser-toolbar**
+  * Toolbar URL autocompletion is now performed off the UI thread.
+
+* **concept-storage**
+  * ⚠️ **This is a breaking API change!**
+  * `HistoryAutocompleteResult` now includes an `input` field.
+
+* **browser-domains**
+  * ⚠️ **This is a breaking API change!**
+  * `DomainAutocompleteResult` now includes an `input` field.
+
 # 0.40.0
 
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v0.39.0...v0.40.0)
