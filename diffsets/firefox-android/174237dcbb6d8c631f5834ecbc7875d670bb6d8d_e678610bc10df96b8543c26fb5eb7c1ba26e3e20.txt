diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
index 61ffa4999456..0d5031bfc8c7 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
@@ -55,13 +55,25 @@ value class Filename(val value: String)
 value class ContentSize(val value: Long)
 
 /**
- * Action for when the positive button of a download dialog was tapped.
+ * The list of all applications that can perform a download, including this application.
+ */
+@JvmInline
+value class ThirdPartyDownloaderApps(val value: List<DownloaderApp>)
+
+/**
+ * Callback for when the user picked a certain application with which to download the current file.
+ */
+@JvmInline
+value class ThirdPartyDownloaderAppChosenCallback(val value: (DownloaderApp) -> Unit)
+
+/**
+ * Callback for when the positive button of a download dialog was tapped.
  */
 @JvmInline
 value class PositiveActionCallback(val value: () -> Unit)
 
 /**
- * Action for when the negative button of a download dialog was tapped.
+ * Callback for when the negative button of a download dialog was tapped.
  */
 @JvmInline
 value class NegativeActionCallback(val value: () -> Unit)
@@ -85,7 +97,10 @@ value class NegativeActionCallback(val value: () -> Unit)
  * @property promptsStyling styling properties for the dialog.
  * @property shouldForwardToThirdParties Indicates if downloads should be forward to third party apps,
  * if there are multiple apps a chooser dialog will shown.
- * @property customDownloadDialog An optional delegate for showing a download dialog.
+ * @property customFirstPartyDownloadDialog An optional delegate for showing a dialog for a download
+ * that will be processed by the current application.
+ * @property customThirdPartyDownloadDialog An optional delegate for showing a dialog for a download
+ * that can be processed by multiple installed applications including the current one.
  */
 @Suppress("LongParameterList", "LargeClass")
 class DownloadsFeature(
@@ -100,7 +115,10 @@ class DownloadsFeature(
     private val fragmentManager: FragmentManager? = null,
     private val promptsStyling: PromptsStyling? = null,
     private val shouldForwardToThirdParties: () -> Boolean = { false },
-    private val customDownloadDialog: ((Filename, ContentSize, PositiveActionCallback, NegativeActionCallback) -> Unit)? = null,
+    private val customFirstPartyDownloadDialog:
+        ((Filename, ContentSize, PositiveActionCallback, NegativeActionCallback) -> Unit)? = null,
+    private val customThirdPartyDownloadDialog:
+        ((ThirdPartyDownloaderApps, ThirdPartyDownloaderAppChosenCallback, NegativeActionCallback) -> Unit)? = null,
 ) : LifecycleAwareFeature, PermissionsFeature {
 
     var onDownloadStopped: onDownloadStopped
@@ -187,13 +205,25 @@ class DownloadsFeature(
         val shouldShowAppDownloaderDialog = shouldForwardToThirdParties() && apps.size > 1
 
         return if (shouldShowAppDownloaderDialog) {
-            showAppDownloaderDialog(tab, download, apps)
+            when (customThirdPartyDownloadDialog) {
+                null -> showAppDownloaderDialog(tab, download, apps)
+                else -> customThirdPartyDownloadDialog.invoke(
+                    ThirdPartyDownloaderApps(apps),
+                    ThirdPartyDownloaderAppChosenCallback {
+                        onDownloaderAppSelected(it, tab, download)
+                    },
+                    NegativeActionCallback {
+                        useCases.cancelDownloadRequest.invoke(tab.id, download.id)
+                    },
+                )
+            }
+
             false
         } else {
             if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
                 when {
-                    customDownloadDialog != null && !download.skipConfirmation -> {
-                        customDownloadDialog.invoke(
+                    customFirstPartyDownloadDialog != null && !download.skipConfirmation -> {
+                        customFirstPartyDownloadDialog.invoke(
                             Filename(download.realFilenameOrGuessed),
                             ContentSize(download.contentLength ?: 0),
                             PositiveActionCallback {
@@ -309,25 +339,7 @@ class DownloadsFeature(
     ) {
         appChooserDialog.setApps(apps)
         appChooserDialog.onAppSelected = { app ->
-            if (app.packageName == applicationContext.packageName) {
-                if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
-                    startDownload(download)
-                    useCases.consumeDownload(tab.id, download.id)
-                } else {
-                    onNeedToRequestPermissions(downloadManager.permissions)
-                }
-            } else {
-                try {
-                    applicationContext.startActivity(app.toIntent())
-                } catch (error: ActivityNotFoundException) {
-                    val errorMessage = applicationContext.getString(
-                        R.string.mozac_feature_downloads_unable_to_open_third_party_app,
-                        app.name,
-                    )
-                    Toast.makeText(applicationContext, errorMessage, Toast.LENGTH_SHORT).show()
-                }
-                useCases.consumeDownload(tab.id, download.id)
-            }
+            onDownloaderAppSelected(app, tab, download)
         }
 
         appChooserDialog.onDismiss = {
@@ -339,6 +351,29 @@ class DownloadsFeature(
         }
     }
 
+    @VisibleForTesting
+    internal fun onDownloaderAppSelected(app: DownloaderApp, tab: SessionState, download: DownloadState) {
+        if (app.packageName == applicationContext.packageName) {
+            if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
+                startDownload(download)
+                useCases.consumeDownload(tab.id, download.id)
+            } else {
+                onNeedToRequestPermissions(downloadManager.permissions)
+            }
+        } else {
+            try {
+                applicationContext.startActivity(app.toIntent())
+            } catch (error: ActivityNotFoundException) {
+                val errorMessage = applicationContext.getString(
+                    R.string.mozac_feature_downloads_unable_to_open_third_party_app,
+                    app.name,
+                )
+                Toast.makeText(applicationContext, errorMessage, Toast.LENGTH_SHORT).show()
+            }
+            useCases.consumeDownload(tab.id, download.id)
+        }
+    }
+
     private fun getAppDownloaderDialog() = findPreviousAppDownloaderDialogFragment()
         ?: DownloadAppChooserDialog.newInstance(
             promptsStyling?.gravity,
@@ -409,7 +444,8 @@ class DownloadsFeature(
 
     private val ActivityInfo.identifier: String get() = packageName + name
 
-    private fun DownloaderApp.toIntent(): Intent {
+    @VisibleForTesting
+    internal fun DownloaderApp.toIntent(): Intent {
         return Intent(Intent.ACTION_VIEW).apply {
             setDataAndTypeAndNormalize(url.toUri(), contentType)
             flags = Intent.FLAG_ACTIVITY_NEW_TASK
diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
index e60a0938162c..5be32f71b386 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
@@ -16,7 +16,7 @@ import mozilla.components.feature.downloads.R
 /**
  * An adapter for displaying the applications that can perform downloads.
  */
-internal class DownloaderAppAdapter(
+class DownloaderAppAdapter(
     context: Context,
     private val apps: List<DownloaderApp>,
     val onAppSelected: ((DownloaderApp) -> Unit),
@@ -49,11 +49,14 @@ internal class DownloaderAppAdapter(
 /**
  * View holder for a [DownloaderApp] item.
  */
-internal class DownloaderAppViewHolder(
+class DownloaderAppViewHolder(
     itemView: View,
     val nameLabel: TextView,
     val iconImage: ImageView,
 ) : RecyclerView.ViewHolder(itemView) {
+    /**
+     * Show a certain downloader application in the current View.
+     */
     fun bind(app: DownloaderApp, onAppSelected: ((DownloaderApp) -> Unit)) {
         itemView.app = app
         itemView.setOnClickListener {
diff --git a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt b/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
index c0fb41e04318..58c89930cb5a 100644
--- a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
+++ b/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
@@ -8,6 +8,7 @@ import android.Manifest.permission.INTERNET
 import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
 import android.content.ActivityNotFoundException
 import android.content.Context
+import android.content.Intent
 import android.content.pm.ActivityInfo
 import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
@@ -29,6 +30,7 @@ import mozilla.components.feature.downloads.manager.DownloadManager
 import mozilla.components.feature.downloads.ui.DownloadAppChooserDialog
 import mozilla.components.feature.downloads.ui.DownloaderApp
 import mozilla.components.support.test.any
+import mozilla.components.support.test.argumentCaptor
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.ext.joinBlocking
 import mozilla.components.support.test.libstate.ext.waitUntilIdle
@@ -673,7 +675,8 @@ class DownloadsFeatureTest {
                 store = mock(),
                 useCases = usecases,
                 downloadManager = downloadManager,
-                customDownloadDialog = { filename, contentSize, positiveActionCallback, negativeActionCallback ->
+                shouldForwardToThirdParties = { true },
+                customFirstPartyDownloadDialog = { filename, contentSize, positiveActionCallback, negativeActionCallback ->
                     delegateFilename = filename.value
                     delegateContentSize = contentSize.value
                     delegatePositiveActionCallback = positiveActionCallback.value
@@ -694,6 +697,49 @@ class DownloadsFeatureTest {
         verify(cancelDownloadUseCase).invoke(tab.id, download.id)
     }
 
+    @Test
+    fun `GIVEN download should be forwarded to third party apps and a custom delegate is set WHEN processing a download request THEN forward it to the delegate`() {
+        val tab = createTab("https://www.mozilla.org", id = "test-tab")
+        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
+        val usecases: DownloadsUseCases = mock()
+        val cancelDownloadUseCase: CancelDownloadRequestUseCase = mock()
+        doReturn(cancelDownloadUseCase).`when`(usecases).cancelDownloadRequest
+        val downloadManager: DownloadManager = mock()
+        var delegateDownloaderApps: List<DownloaderApp> = emptyList()
+        var delegateChosenAppCallback: ((DownloaderApp) -> Unit)? = null
+        var delegateNegativeActionCallback: (() -> Unit)? = null
+        val ourApp = mock<DownloaderApp>()
+        val anotherApp = mock<DownloaderApp>()
+        grantPermissions()
+        doReturn(arrayOf(INTERNET, WRITE_EXTERNAL_STORAGE)).`when`(downloadManager).permissions
+        val feature = spy(
+            DownloadsFeature(
+                applicationContext = testContext,
+                store = mock(),
+                useCases = usecases,
+                downloadManager = downloadManager,
+                shouldForwardToThirdParties = { true },
+                customThirdPartyDownloadDialog = { apps, chosenAppCallback, dismissCallback ->
+                    delegateDownloaderApps = apps.value
+                    delegateChosenAppCallback = chosenAppCallback.value
+                    delegateNegativeActionCallback = dismissCallback.value
+                },
+            ),
+        )
+        doReturn(listOf(ourApp, anotherApp)).`when`(feature).getDownloaderApps(testContext, download)
+        doNothing().`when`(feature).onDownloaderAppSelected(anotherApp, tab, download)
+
+        feature.processDownload(tab, download)
+
+        assertEquals(listOf(ourApp, anotherApp), delegateDownloaderApps)
+        assertNotNull(delegateChosenAppCallback)
+        delegateChosenAppCallback?.invoke(anotherApp)
+        verify(feature).onDownloaderAppSelected(anotherApp, tab, download)
+        assertNotNull(delegateNegativeActionCallback)
+        delegateNegativeActionCallback?.invoke()
+        verify(cancelDownloadUseCase).invoke(tab.id, download.id)
+    }
+
     @Test
     fun `when url is data url return only our app as downloader app`() {
         val context = mock<Context>()
@@ -873,6 +919,137 @@ class DownloadsFeatureTest {
         verify(spyContext, times(0)).startActivity(any())
     }
 
+    @Test
+    fun `GIVEN permissions are granted WHEN our app is selected for download THEN perform the download`() {
+        val spyContext = spy(testContext)
+        val usecases: DownloadsUseCases = mock()
+        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
+        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
+        val tab = createTab("https://www.mozilla.org", id = "test-tab")
+        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
+        val ourApp = DownloaderApp(name = "app", packageName = testContext.packageName, resolver = mock(), activityName = "", url = "", contentType = null)
+        var wasPermissionsRequested = false
+        val feature = spy(
+            DownloadsFeature(
+                applicationContext = testContext,
+                store = mock(),
+                useCases = usecases,
+                onNeedToRequestPermissions = { wasPermissionsRequested = true },
+            ),
+        )
+        doReturn(false).`when`(feature).startDownload(any())
+
+        grantPermissions()
+        feature.onDownloaderAppSelected(ourApp, tab, download)
+
+        verify(feature).startDownload(download)
+        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
+        assertFalse(wasPermissionsRequested)
+        verify(spyContext, never()).startActivity(any())
+    }
+
+    @Test
+    fun `GIVEN permissions are not granted WHEN our app is selected for download THEN request the needed permissions`() {
+        val spyContext = spy(testContext)
+        val usecases: DownloadsUseCases = mock()
+        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
+        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
+        val tab = createTab("https://www.mozilla.org", id = "test-tab")
+        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
+        val ourApp = DownloaderApp(name = "app", packageName = testContext.packageName, resolver = mock(), activityName = "", url = "", contentType = null)
+        var wasPermissionsRequested = false
+        val feature = spy(
+            DownloadsFeature(
+                applicationContext = testContext,
+                store = mock(),
+                useCases = usecases,
+                onNeedToRequestPermissions = { wasPermissionsRequested = true },
+            ),
+        )
+
+        feature.onDownloaderAppSelected(ourApp, tab, download)
+
+        verify(feature, never()).startDownload(any())
+        verify(consumeDownloadUseCase, never()).invoke(anyString(), anyString())
+        assertTrue(wasPermissionsRequested)
+        verify(spyContext, never()).startActivity(any())
+    }
+
+    @Test
+    fun `GIVEN a download WHEN a 3rd party app is selected THEN delegate download to it`() {
+        val spyContext = spy(testContext)
+        val usecases: DownloadsUseCases = mock()
+        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
+        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
+        val tab = createTab("https://www.mozilla.org", id = "test-tab")
+        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
+        val anotherApp = DownloaderApp(
+            name = "app",
+            packageName = "test",
+            resolver = mock(),
+            activityName = "",
+            url = download.url,
+            contentType = null,
+        )
+        val feature = spy(
+            DownloadsFeature(
+                applicationContext = spyContext,
+                store = mock(),
+                useCases = usecases,
+            ),
+        )
+        val intentArgumentCaptor = argumentCaptor<Intent>()
+        val expectedIntent = with(feature) { anotherApp.toIntent() }
+
+        feature.onDownloaderAppSelected(anotherApp, tab, download)
+
+        verify(spyContext).startActivity(intentArgumentCaptor.capture())
+        assertEquals(expectedIntent.toUri(0), intentArgumentCaptor.value.toUri(0))
+        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
+        verify(feature, never()).startDownload(any())
+        assertNull(ShadowToast.getTextOfLatestToast())
+    }
+
+    @Test
+    fun `GIVEN a download WHEN a 3rd party app is selected and the download fails THEN show a warning toast and consume the download`() {
+        val spyContext = spy(testContext)
+        val usecases: DownloadsUseCases = mock()
+        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
+        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
+        val tab = createTab("https://www.mozilla.org", id = "test-tab")
+        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
+        val anotherApp = DownloaderApp(
+            name = "app",
+            packageName = "test",
+            resolver = mock(),
+            activityName = "",
+            url = download.url,
+            contentType = null,
+        )
+        val feature = spy(
+            DownloadsFeature(
+                applicationContext = spyContext,
+                store = mock(),
+                useCases = usecases,
+            ),
+        )
+        val expectedWarningText = testContext.getString(
+            R.string.mozac_feature_downloads_unable_to_open_third_party_app,
+            anotherApp.name,
+        )
+        val intentArgumentCaptor = argumentCaptor<Intent>()
+        val expectedIntent = with(feature) { anotherApp.toIntent() }
+        doThrow(ActivityNotFoundException()).`when`(spyContext).startActivity(any())
+
+        feature.onDownloaderAppSelected(anotherApp, tab, download)
+
+        verify(spyContext).startActivity(intentArgumentCaptor.capture())
+        assertEquals(expectedIntent.toUri(0), intentArgumentCaptor.value.toUri(0))
+        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
+        verify(feature, never()).startDownload(any())
+        assertEquals(expectedWarningText, ShadowToast.getTextOfLatestToast())
+    }
+
     @Test
     fun `when an app third party is selected for downloading we MUST forward the download`() {
         val spyContext = spy(testContext)
diff --git a/docs/changelog.md b/docs/changelog.md
index 4d6f0bffc01f..9f2c7c786049 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -11,6 +11,7 @@ permalink: /changelog/
 
 * **feature-downloads**:
   * üåüÔ∏è `DownloadsFeature` now allows passing a download dialog delegate for 1st party downloads through a new `customDownloadDialog` parameter. [Bug 1812518](https://bugzilla.mozilla.org/show_bug.cgi?id=1812518)
+  * üåü `DownloadsFeature` now allows passing a download dialog delegate for 3rd party downloads through a new `customThirdPartyDownloadDialog` parameter. [Bug 1812518](https://bugzilla.mozilla.org/show_bug.cgi?id=1812518)
 
 * **browser-toolbar**
   * ‚ö†Ô∏è **This is a breaking change**: `BrowserToolbarBehavior` will not position the `Snackbar.SnackbarLayout` anymore. The ownership for the positioning behavior should be reversed with the snackbar choosing whether it want to be shown above the toolbar and exactly how. [Bug 1812518](https://bugzilla.mozilla.org/show_bug.cgi?id=1812518)
