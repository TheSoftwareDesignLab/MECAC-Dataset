diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.java
deleted file mode 100644
index bb171986ba95..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.widget;
-
-import android.animation.Animator;
-import android.animation.ValueAnimator;
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-import android.os.Handler;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.view.ViewCompat;
-import android.util.AttributeSet;
-import android.view.animation.AnimationUtils;
-import android.view.animation.Interpolator;
-import android.view.animation.LinearInterpolator;
-import android.widget.ProgressBar;
-
-import org.mozilla.focus.R;
-
-public class AnimatedProgressBar extends ProgressBar {
-    private final static int PROGRESS_DURATION = 200;
-    private final static int CLOSING_DELAY = 300;
-    private final static int CLOSING_DURATION = 300;
-    private ValueAnimator mPrimaryAnimator;
-    private ValueAnimator mClosingAnimator = ValueAnimator.ofFloat(0f, 1f);
-    private float mClipRegion = 0f;
-    private int mExpectedProgress = 0;
-    private Rect tempRect;
-    private boolean mIsRtl;
-
-    private ValueAnimator.AnimatorUpdateListener mListener = new ValueAnimator.AnimatorUpdateListener() {
-        @Override
-        public void onAnimationUpdate(ValueAnimator animation) {
-            setProgressImmediately((int) mPrimaryAnimator.getAnimatedValue());
-        }
-    };
-
-    public AnimatedProgressBar(@NonNull Context context) {
-        super(context, null);
-        init(context, null);
-    }
-
-    public AnimatedProgressBar(@NonNull Context context,
-                               @Nullable AttributeSet attrs) {
-        super(context, attrs);
-        init(context, attrs);
-    }
-
-    public AnimatedProgressBar(@NonNull Context context,
-                               @Nullable AttributeSet attrs,
-                               int defStyleAttr) {
-
-        super(context, attrs, defStyleAttr);
-        init(context, attrs);
-    }
-
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    public AnimatedProgressBar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        init(context, attrs);
-    }
-
-    @Override
-    public void setProgress(int nextProgress) {
-        nextProgress = Math.min(nextProgress, getMax());
-        nextProgress = Math.max(0, nextProgress);
-        mExpectedProgress = nextProgress;
-
-        // a dirty-hack for reloading page.
-        if (mExpectedProgress < getProgress() && getProgress() == getMax()) {
-            setProgressImmediately(0);
-        }
-
-        if (mPrimaryAnimator != null) {
-            mPrimaryAnimator.cancel();
-            mPrimaryAnimator.setIntValues(getProgress(), nextProgress);
-            mPrimaryAnimator.start();
-        } else {
-            setProgressImmediately(nextProgress);
-        }
-
-        if (mClosingAnimator != null) {
-            if (nextProgress != getMax()) {
-                // stop closing animation
-                mClosingAnimator.cancel();
-                mClipRegion = 0f;
-            }
-        }
-    }
-
-    @Override
-    public void onDraw(Canvas canvas) {
-        if (mClipRegion == 0) {
-            super.onDraw(canvas);
-        } else {
-            canvas.getClipBounds(tempRect);
-            final float clipWidth = tempRect.width() * mClipRegion;
-            final int saveCount = canvas.save();
-
-
-            if (mIsRtl) {
-                canvas.clipRect(tempRect.left, tempRect.top, tempRect.right - clipWidth, tempRect.bottom);
-            } else {
-                canvas.clipRect(tempRect.left + clipWidth, tempRect.top, tempRect.right, tempRect.bottom);
-            }
-            super.onDraw(canvas);
-            canvas.restoreToCount(saveCount);
-        }
-    }
-
-    @Override
-    public void setVisibility(int value) {
-        if (value == GONE) {
-            if (mExpectedProgress == getMax()) {
-                animateClosing();
-            } else {
-                setVisibilityImmediately(value);
-            }
-        } else {
-            setVisibilityImmediately(value);
-        }
-    }
-
-    private void setVisibilityImmediately(int value) {
-        super.setVisibility(value);
-    }
-
-    private void animateClosing() {
-        mIsRtl = (ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL);
-
-        mClosingAnimator.cancel();
-
-        final Handler handler = getHandler();
-        if (handler != null) {
-            handler.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    mClosingAnimator.start();
-                }
-            }, CLOSING_DELAY);
-        }
-    }
-
-    private void setProgressImmediately(int progress) {
-        super.setProgress(progress);
-    }
-
-    private void init(@NonNull Context context, @Nullable AttributeSet attrs) {
-        tempRect = new Rect();
-
-        final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AnimatedProgressBar);
-        final int duration = a.getInteger(R.styleable.AnimatedProgressBar_shiftDuration, 1000);
-        final int resID = a.getResourceId(R.styleable.AnimatedProgressBar_shiftInterpolator, 0);
-        final boolean wrap = a.getBoolean(R.styleable.AnimatedProgressBar_wrapShiftDrawable, false);
-
-        mPrimaryAnimator = ValueAnimator.ofInt(getProgress(), getMax());
-        mPrimaryAnimator.setInterpolator(new LinearInterpolator());
-        mPrimaryAnimator.setDuration(PROGRESS_DURATION);
-        mPrimaryAnimator.addUpdateListener(mListener);
-
-        mClosingAnimator.setDuration(CLOSING_DURATION);
-        mClosingAnimator.setInterpolator(new LinearInterpolator());
-        mClosingAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
-            @Override
-            public void onAnimationUpdate(ValueAnimator valueAnimator) {
-                final float region = (float) valueAnimator.getAnimatedValue();
-                if (mClipRegion != region) {
-                    mClipRegion = region;
-                    invalidate();
-                }
-            }
-        });
-        mClosingAnimator.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animator) {
-                mClipRegion = 0f;
-            }
-
-            @Override
-            public void onAnimationEnd(Animator animator) {
-                setVisibilityImmediately(GONE);
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animator) {
-                mClipRegion = 0f;
-            }
-
-            @Override
-            public void onAnimationRepeat(Animator animator) {
-            }
-        });
-        setProgressDrawable(buildWrapDrawable(getProgressDrawable(), wrap, duration, resID));
-
-        a.recycle();
-    }
-
-    private Drawable buildWrapDrawable(Drawable original, boolean isWrap, int duration, int resID) {
-        if (isWrap) {
-            final Interpolator interpolator = (resID > 0)
-                    ? AnimationUtils.loadInterpolator(getContext(), resID)
-                    : null;
-            final ShiftDrawable wrappedDrawable = new ShiftDrawable(original, duration, interpolator);
-            return wrappedDrawable;
-        } else {
-            return original;
-        }
-    }
-}
\ No newline at end of file
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.kt b/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.kt
new file mode 100644
index 000000000000..1386737cedae
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/AnimatedProgressBar.kt
@@ -0,0 +1,194 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.widget
+
+import android.animation.Animator
+import android.animation.ValueAnimator
+import android.annotation.TargetApi
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Rect
+import android.graphics.drawable.Drawable
+import android.os.Build
+import android.support.v4.view.ViewCompat
+import android.util.AttributeSet
+import android.view.View
+import android.view.animation.AnimationUtils
+import android.view.animation.LinearInterpolator
+import android.widget.ProgressBar
+
+import org.mozilla.focus.R
+
+class AnimatedProgressBar : ProgressBar {
+    private var primaryAnimator: ValueAnimator? = null
+    private val closingAnimator: ValueAnimator? = ValueAnimator.ofFloat(0f, 1f)
+    private var clipRegion = 0f
+    private var expectedProgress = 0
+    private var tempRect = Rect()
+    private var isRtl: Boolean = false
+
+    private val animatorListener = ValueAnimator.AnimatorUpdateListener {
+        setProgressImmediately(primaryAnimator!!.animatedValue as Int)
+    }
+
+    constructor(context: Context) : super(context, null) {
+        init(context, null)
+    }
+
+    constructor(context: Context,
+                attrs: AttributeSet?) : super(context, attrs) {
+        init(context, attrs)
+    }
+
+    constructor(context: Context,
+                attrs: AttributeSet?,
+                defStyleAttr: Int) : super(context, attrs, defStyleAttr) {
+        init(context, attrs)
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) :
+            super(context, attrs, defStyleAttr, defStyleRes) {
+        init(context, attrs)
+    }
+
+    override fun setProgress(progress: Int) {
+        var nextProgress = progress
+        nextProgress = Math.min(nextProgress, max)
+        nextProgress = Math.max(0, nextProgress)
+        expectedProgress = nextProgress
+
+        // a dirty-hack for reloading page.
+        if (expectedProgress < progress && progress == max) {
+            setProgressImmediately(0)
+        }
+
+        primaryAnimator?.apply {
+            cancel()
+            setIntValues(progress, nextProgress)
+            start()
+        } ?: run { setProgressImmediately(nextProgress) }
+
+        closingAnimator?.apply {
+            if (nextProgress == max) { return@apply }
+
+            cancel()
+            clipRegion = 0f
+        }
+    }
+
+    public override fun onDraw(canvas: Canvas) {
+        if (clipRegion == 0f) { super.onDraw(canvas); return }
+
+        canvas.getClipBounds(tempRect)
+        val clipWidth = tempRect.width() * clipRegion
+        val saveCount = canvas.save()
+
+        if (isRtl) {
+            canvas.clipRect(tempRect.left.toFloat(),
+                    tempRect.top.toFloat(),
+                    tempRect.right - clipWidth,
+                    tempRect.bottom.toFloat())
+        } else {
+            canvas.clipRect(tempRect.left + clipWidth,
+                    tempRect.top.toFloat(),
+                    tempRect.right.toFloat(),
+                    tempRect.bottom.toFloat())
+        }
+        super.onDraw(canvas)
+        canvas.restoreToCount(saveCount)
+    }
+
+    override fun setVisibility(value: Int) {
+        if (value == View.GONE) {
+            if (expectedProgress == max) {
+                animateClosing()
+            } else {
+                setVisibilityImmediately(value)
+            }
+        } else {
+            setVisibilityImmediately(value)
+        }
+    }
+
+    private fun setVisibilityImmediately(value: Int) {
+        super.setVisibility(value)
+    }
+
+    private fun animateClosing() {
+        isRtl = ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL
+
+        closingAnimator!!.cancel()
+
+        val handler = handler
+        handler?.postDelayed({ closingAnimator.start() }, CLOSING_DELAY.toLong())
+    }
+
+    private fun setProgressImmediately(progress: Int) {
+        super.setProgress(progress)
+    }
+
+    private fun init(context: Context, attrs: AttributeSet?) {
+        val a = context.obtainStyledAttributes(attrs, R.styleable.AnimatedProgressBar)
+        val duration = a.getInteger(R.styleable.AnimatedProgressBar_shiftDuration, DEFAULT_DURATION)
+        val resID = a.getResourceId(R.styleable.AnimatedProgressBar_shiftInterpolator, DEFAULT_RESOURCE_ID)
+        val wrap = a.getBoolean(R.styleable.AnimatedProgressBar_wrapShiftDrawable, false)
+
+        primaryAnimator = ValueAnimator.ofInt(progress, max).apply {
+            interpolator = LinearInterpolator()
+            setDuration(PROGRESS_DURATION.toLong())
+            addUpdateListener(animatorListener)
+        }
+
+        closingAnimator!!.duration = CLOSING_DURATION.toLong()
+        closingAnimator.interpolator = LinearInterpolator()
+        closingAnimator.addUpdateListener { valueAnimator ->
+            val region = valueAnimator.animatedValue as Float
+            if (clipRegion != region) {
+                clipRegion = region
+                invalidate()
+            }
+        }
+        closingAnimator.addListener(object : Animator.AnimatorListener {
+            override fun onAnimationStart(animator: Animator) {
+                clipRegion = 0f
+            }
+
+            override fun onAnimationEnd(animator: Animator) {
+                setVisibilityImmediately(View.GONE)
+            }
+
+            override fun onAnimationCancel(animator: Animator) {
+                clipRegion = 0f
+            }
+
+            override fun onAnimationRepeat(animator: Animator) {}
+        })
+        progressDrawable = buildWrapDrawable(progressDrawable, wrap, duration, resID)
+
+        a.recycle()
+    }
+
+    private fun buildWrapDrawable(original: Drawable, isWrap: Boolean, duration: Int, resID: Int): Drawable {
+        return if (isWrap) {
+            val interpolator = if (resID > 0)
+                AnimationUtils.loadInterpolator(context, resID)
+            else
+                null
+            ShiftDrawable(original, duration, interpolator)
+        } else {
+            original
+        }
+    }
+
+    companion object {
+        private val PROGRESS_DURATION = 200
+        private val CLOSING_DELAY = 300
+        private val CLOSING_DURATION = 300
+
+        private val DEFAULT_DURATION = 1000
+        private val DEFAULT_RESOURCE_ID = 0
+    }
+}
