diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
index c01a0c9c3e3a..523fdc505f63 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
@@ -134,20 +134,7 @@ public void onProgress(int progress) {
 
             @Override
             public boolean handleExternalUrl(final String url) {
-                final String fallback = IntentUtils.handleExternalUri(getActivity(), url);
-
-                if (fallback != null) {
-                    // Stop loading if we've received any data. The fallback is either a success indicator
-                    // (we've shown a dialog), or a completely URL that we should try to load.
-                    if (!fallback.equals("success:")) {
-                        webView.loadUrl(fallback);
-                    }
-
-                    return true;
-                }
-
-                // Unhandled: we just let the browser finish loading (e.g. showing the unsupported protocol error page).
-                return false;
+                return IntentUtils.handleExternalUri(getContext(), webView, url);
             }
         });
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.java b/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.java
index dd766985a6d7..f8274846ad33 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.java
@@ -4,7 +4,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 package org.mozilla.focus.utils;
 
-import android.app.Activity;
+import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -14,6 +14,7 @@
 import android.support.v7.app.AlertDialog;
 
 import org.mozilla.focus.R;
+import org.mozilla.focus.web.IWebView;
 
 import java.net.URISyntaxException;
 import java.util.List;
@@ -25,15 +26,16 @@ public class IntentUtils {
 
     /**
      * Find and open the appropriate app for a given Uri. If appropriate, let the user select between
-     * multiple supported apps. Returns a fallback or error URL (which Focus should open) if appropriate.
-     * (A fallback URL will be returned if one was supplied by the uri, an error URL is returned
-     *  if some other unspecified error occured.)
+     * multiple supported apps. Returns a boolean indicating whether the URL was handled. A fallback
+     * URL will be opened in the supplied WebView if appropriate (in which case the URL was handled,
+     * and true will also be returned). If not handled, we should  fall back to webviews error handling
+     * (which ends up calling our error handling code as needed).
      *
      * Note: this method "leaks" the target Uri to Android before asking the user whether they
      * want to use an external app to open the uri. Ultimately the OS can spy on anything we're
      * doing in the app, so this isn't an actual "bug".
      */
-    public static String handleExternalUri(final Activity activity, final String uri) {
+    public static boolean handleExternalUri(final Context context, final IWebView webView, final String uri) {
         // This code is largely based on Fennec's ExternalIntentDuringPrivateBrowsingPromptFragment.java
         final Intent intent;
         try {
@@ -41,13 +43,13 @@ public static String handleExternalUri(final Activity activity, final String uri
         } catch (URISyntaxException e) {
             // Let the browser handle the url (i.e. let the browser show it's unsupported protocol /
             // invalid URL page).
-            return null;
+            return false;
         }
 
         // Since we're a browser:
         intent.addCategory(Intent.CATEGORY_BROWSABLE);
 
-        final PackageManager packageManager = activity.getPackageManager();
+        final PackageManager packageManager = context.getPackageManager();
 
         // This is where we "leak" the uri to the OS. If we're using the system webview, then the OS
         // already knows that we're opening this uri. Even if we're using GeckoView, the OS can still
@@ -55,7 +57,7 @@ public static String handleExternalUri(final Activity activity, final String uri
         final List<ResolveInfo> matchingActivities = packageManager.queryIntentActivities(intent, 0);
 
         if (matchingActivities.size() == 0) {
-            return handleUnsupportedLink(activity, intent);
+            return handleUnsupportedLink(context, webView, intent);
         } else if (matchingActivities.size() == 1) {
             final ResolveInfo info;
 
@@ -70,27 +72,27 @@ public static String handleExternalUri(final Activity activity, final String uri
             }
             final CharSequence externalAppTitle = info.loadLabel(packageManager);
 
-            showConfirmationDialog(activity, intent, activity.getString(R.string.external_app_prompt_title), R.string.external_app_prompt, externalAppTitle);
-            return "success:";
+            showConfirmationDialog(context, intent, context.getString(R.string.external_app_prompt_title), R.string.external_app_prompt, externalAppTitle);
+            return true;
         } else { // matchingActivities.size() > 1
             // By explicitly showing the chooser, we can avoid having a (default) app from opening
             // the link immediately. This isn't perfect - we'd prefer to highlight the default app,
             // but it's not clear if there's any way of doing that. An alternative
             // would be to reuse the same dialog as for the single-activity case, and offer
             // a "open in other app this time" button if we have more than one matchingActivity.
-            final String chooserTitle = activity.getResources().getString(R.string.external_multiple_apps_matched_exit);
+            final String chooserTitle = context.getString(R.string.external_multiple_apps_matched_exit);
             final Intent chooserIntent = Intent.createChooser(intent, chooserTitle);
-            activity.startActivity(chooserIntent);
+            context.startActivity(chooserIntent);
 
-            // It was handled, stop loading other stuff
-            return "success:";
+            return true;
         }
     }
 
-    private static String handleUnsupportedLink(final Activity activity, final Intent intent) {
+    private static boolean handleUnsupportedLink(final Context context, final IWebView webView, final Intent intent) {
         final String fallbackUrl = intent.getStringExtra(EXTRA_BROWSER_FALLBACK_URL);
         if (fallbackUrl != null) {
-            return fallbackUrl;
+            webView.loadUrl(fallbackUrl);
+            return true;
         }
 
         if (intent.getPackage() != null) {
@@ -99,37 +101,38 @@ private static String handleUnsupportedLink(final Activity activity, final Inten
             final Intent marketIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(marketUri));
             marketIntent.addCategory(Intent.CATEGORY_BROWSABLE);
 
-            final ResolveInfo info = activity.getPackageManager().resolveActivity(marketIntent, 0);
-            final CharSequence marketTitle = info.loadLabel(activity.getPackageManager());
-            showConfirmationDialog(activity, marketIntent,
-                    activity.getResources().getString(R.string.external_app_prompt_no_app_title),
+            final PackageManager packageManager = context.getPackageManager();
+            final ResolveInfo info = packageManager.resolveActivity(marketIntent, 0);
+            final CharSequence marketTitle = info.loadLabel(packageManager);
+            showConfirmationDialog(context, marketIntent,
+                    context.getString(R.string.external_app_prompt_no_app_title),
                     R.string.external_app_prompt_no_app, marketTitle);
 
             // Stop loading, we essentially have a result.
-            return "success:";
+            return true;
         }
 
         // If there's really no way to handle this, we just let the browser handle this URL
         // (which then shows the unsupported protocol page).
-        return null;
+        return false;
     }
 
     // We only need one param for both scenarios, hence we use just one "param" argument. If we ever
     // end up needing more or a variable number we can change this, but java varargs are a bit messy
     // so let's try to avoid that seeing as it's not needed right now.
-    private static void showConfirmationDialog(final Activity activity, final Intent targetIntent, final String title, final @StringRes int messageResource, final CharSequence param) {
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity, R.style.DialogStyle);
+    private static void showConfirmationDialog(final Context context, final Intent targetIntent, final String title, final @StringRes int messageResource, final CharSequence param) {
+        final AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.DialogStyle);
 
-        final CharSequence ourAppName = activity.getResources().getString(R.string.app_name);
+        final CharSequence ourAppName = context.getString(R.string.app_name);
 
         builder.setTitle(title);
 
-        builder.setMessage(activity.getResources().getString(messageResource, ourAppName, param));
+        builder.setMessage(context.getResources().getString(messageResource, ourAppName, param));
 
         builder.setPositiveButton(R.string.action_ok, new DialogInterface.OnClickListener() {
             @Override
             public void onClick(final DialogInterface dialog, final int which) {
-                activity.startActivity(targetIntent);
+                context.startActivity(targetIntent);
             }
         });
 
