diff --git a/focus-android/app/src/gecko/java/org/mozilla/focus/web/WebViewProvider.java b/focus-android/app/src/gecko/java/org/mozilla/focus/web/WebViewProvider.java
index 2cbc60c81e6f..2afa691d3232 100644
--- a/focus-android/app/src/gecko/java/org/mozilla/focus/web/WebViewProvider.java
+++ b/focus-android/app/src/gecko/java/org/mozilla/focus/web/WebViewProvider.java
@@ -102,6 +102,17 @@ public void cleanup() {
             // TODO: Remove browsing session/data
         }
 
+        @Override
+        public void setBlockingEnabled(boolean enabled) {
+            // TODO: Enable / disable content blocking
+        }
+
+        @Override
+        public boolean isBlockingEnabled() {
+            // TODO: Return whether content blocking is enabled
+            return true;
+        }
+
         @Override
         public void restoreWebviewState(Bundle savedInstanceState) {
             // TODO: restore navigation history, and reopen previously opened page
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
index 0c15606f2476..970ce8dcff49 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
@@ -384,10 +384,7 @@ public void onClick(View view) {
             }
 
             case R.id.back: {
-                final IWebView webView = getWebView();
-                if (webView != null) {
-                    webView.goBack();
-                }
+                goBack();
                 break;
             }
 
@@ -400,10 +397,7 @@ public void onClick(View view) {
             }
 
             case R.id.refresh: {
-                final IWebView webView = getWebView();
-                if (webView != null) {
-                    webView.reload();
-                }
+                reload();
                 break;
             }
 
@@ -554,4 +548,23 @@ public void loadURL(final String url) {
             webView.loadUrl(url);
         }
     }
+
+    public void reload() {
+        final IWebView webView = getWebView();
+        if (webView != null) {
+            webView.reload();
+        }
+    }
+
+    public void setBlockingEnabled(boolean enabled) {
+        final IWebView webView = getWebView();
+        if (webView != null) {
+            webView.setBlockingEnabled(enabled);
+        }
+    }
+
+    public boolean isBlockingEnabled() {
+        final IWebView webView = getWebView();
+        return webView == null || webView.isBlockingEnabled();
+    }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/BlockingItemViewHolder.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/BlockingItemViewHolder.java
new file mode 100644
index 000000000000..2aadb7866051
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/BlockingItemViewHolder.java
@@ -0,0 +1,47 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.menu;
+
+import android.view.View;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+
+import org.mozilla.focus.R;
+import org.mozilla.focus.fragment.BrowserFragment;
+import org.mozilla.focus.utils.ThreadUtils;
+
+/* package */ class BlockingItemViewHolder extends BrowserMenuViewHolder implements CompoundButton.OnCheckedChangeListener {
+    /* package */ static final int LAYOUT_ID = R.layout.menu_blocking_switch;
+
+    private BrowserFragment fragment;
+
+    /* package */ BlockingItemViewHolder(View itemView, BrowserFragment fragment) {
+        super(itemView);
+
+        this.fragment = fragment;
+
+        final Switch switchView = (Switch) itemView;
+        ((Switch) itemView).setChecked(fragment.isBlockingEnabled());
+
+        switchView.setOnCheckedChangeListener(this);
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        fragment.setBlockingEnabled(isChecked);
+
+        // Delay closing the menu and reloading the website a bit so that the user can actually see
+        // the switch change its state.
+        ThreadUtils.postToMainThreadDelayed(new Runnable() {
+            @Override
+            public void run() {
+                getMenu().dismiss();
+
+                fragment.reload();
+            }
+        }, /* Switch.THUMB_ANIMATION_DURATION */ 250);
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuAdapter.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuAdapter.java
index f0c704101e5c..e13a47432edf 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuAdapter.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuAdapter.java
@@ -83,6 +83,8 @@ public BrowserMenuViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
             return new NavigationItemViewHolder(inflater.inflate(R.layout.menu_navigation, parent, false), fragment);
         } else if (viewType == MenuItemViewHolder.LAYOUT_ID) {
             return new MenuItemViewHolder(inflater.inflate(R.layout.menu_item, parent, false));
+        } else if (viewType == BlockingItemViewHolder.LAYOUT_ID) {
+            return new BlockingItemViewHolder(inflater.inflate(R.layout.menu_blocking_switch, parent, false), fragment);
         }
 
         throw new IllegalArgumentException("Unknown view type: " + viewType);
@@ -93,22 +95,32 @@ public void onBindViewHolder(BrowserMenuViewHolder holder, int position) {
         holder.setMenu(menu);
         holder.setOnClickListener(fragment);
 
-        final int actualPosition = shouldShowButtonToolbar() ? position - 1 : position;
+        int actualPosition = translateToMenuPosition(position);
 
-        if (actualPosition >= 0) {
+        if (actualPosition >= 0 && position != getBlockingSwitchPosition()) {
             ((MenuItemViewHolder) holder).bind(items.get(actualPosition));
         }
     }
 
+    private int translateToMenuPosition(int position) {
+        return shouldShowButtonToolbar() ? position - 2 : position - 1;
+    }
+
     @Override
     public int getItemViewType(int position) {
         if (position == 0 && shouldShowButtonToolbar()) {
             return NavigationItemViewHolder.LAYOUT_ID;
+        } else if (position == getBlockingSwitchPosition()) {
+            return BlockingItemViewHolder.LAYOUT_ID;
         } else {
             return MenuItemViewHolder.LAYOUT_ID;
         }
     }
 
+    private int getBlockingSwitchPosition() {
+        return shouldShowButtonToolbar() ? 1 : 0;
+    }
+
     @Override
     public int getItemCount() {
         int itemCount = items.size();
@@ -117,6 +129,9 @@ public int getItemCount() {
             itemCount++;
         }
 
+        // For the blocking switch
+        itemCount++;
+
         return itemCount;
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuViewHolder.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuViewHolder.java
index d376893425c9..5c5351169c9a 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuViewHolder.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/BrowserMenuViewHolder.java
@@ -20,6 +20,10 @@ public void setMenu(BrowserMenu menu) {
         this.menu = menu;
     }
 
+    public BrowserMenu getMenu() {
+        return menu;
+    }
+
     public void setOnClickListener(View.OnClickListener listener) {
         this.listener = listener;
     }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/ThreadUtils.java b/focus-android/app/src/main/java/org/mozilla/focus/utils/ThreadUtils.java
index dc40a4bf669f..31088877812d 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/ThreadUtils.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/ThreadUtils.java
@@ -5,13 +5,21 @@
 
 package org.mozilla.focus.utils;
 
+import android.os.Handler;
+import android.os.Looper;
+
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class ThreadUtils {
     private static final ExecutorService backgroundExecutorService = Executors.newSingleThreadExecutor();
+    private static final Handler handler = new Handler(Looper.getMainLooper());
 
     public static void postToBackgroundThread(final Runnable runnable) {
         backgroundExecutorService.submit(runnable);
     }
+
+    public static void postToMainThreadDelayed(final Runnable runnable, long delayMillis) {
+        handler.postDelayed(runnable, delayMillis);
+    }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java b/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java
index 22b77b95a020..2a7f12fb8257 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java
@@ -47,6 +47,13 @@ interface Callback {
         void onLongPress(final HitTarget hitTarget);
     }
 
+    /**
+     * Enable/Disable content blocking for this session (Only the blockers that are enabled in the app's settings will be turned on/off).
+     */
+    void setBlockingEnabled(boolean enabled);
+
+    boolean isBlockingEnabled();
+
     void setCallback(Callback callback);
 
     void onPause();
diff --git a/focus-android/app/src/main/res/layout/menu_blocking_switch.xml b/focus-android/app/src/main/res/layout/menu_blocking_switch.xml
new file mode 100644
index 000000000000..ec5d3769343d
--- /dev/null
+++ b/focus-android/app/src/main/res/layout/menu_blocking_switch.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<Switch xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="48dp"
+    android:paddingStart="16dp"
+    android:paddingEnd="16dp"
+    android:clickable="true"
+    android:textSize="16sp"
+    android:gravity="center_vertical"
+    android:background="?android:attr/selectableItemBackground"
+    android:lines="1"
+    android:ellipsize="end"
+    android:text="@string/menu_block_trackers"
+    android:checked="true"
+    style="@android:style/TextAppearance.Material.Menu"/>
diff --git a/focus-android/app/src/main/res/values/strings.xml b/focus-android/app/src/main/res/values/strings.xml
index f7e709a654ae..3e968e9c1881 100644
--- a/focus-android/app/src/main/res/values/strings.xml
+++ b/focus-android/app/src/main/res/values/strings.xml
@@ -38,6 +38,11 @@
     <string name="menu_help">Help</string>
     <string name="menu_rights">Your Rights</string>
 
+    <!-- Menu item: This is the label of a switch in the menu that allows the user to temporarily
+         enable / disable the blocking of trackers for the current browsing session - for example if
+         the current website doesn't work correctly with blocked content. -->
+    <string name="menu_block_trackers">Block trackers</string>
+
     <!-- This is the title of a dialog that shows all the share targets (apps or contacts) when
          sharing an URL. -->
     <string name="share_dialog_title">Share via</string>
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/web/WebViewProvider.java b/focus-android/app/src/webkit/java/org/mozilla/focus/web/WebViewProvider.java
index 82937d9eba11..29bb719497cb 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/web/WebViewProvider.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/web/WebViewProvider.java
@@ -7,41 +7,24 @@
 
 import android.annotation.SuppressLint;
 import android.content.Context;
-import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.preference.PreferenceManager;
-import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
-import android.webkit.CookieManager;
-import android.webkit.DownloadListener;
-import android.webkit.WebBackForwardList;
-import android.webkit.WebChromeClient;
 import android.webkit.WebSettings;
-import android.webkit.WebStorage;
 import android.webkit.WebView;
-import android.webkit.WebViewDatabase;
 
-import org.mozilla.focus.BuildConfig;
 import org.mozilla.focus.R;
-import org.mozilla.focus.utils.FileUtils;
 import org.mozilla.focus.utils.Settings;
-import org.mozilla.focus.utils.ThreadUtils;
-import org.mozilla.focus.webkit.NestedWebView;
 import org.mozilla.focus.webkit.TrackingProtectionWebViewClient;
+import org.mozilla.focus.webkit.WebkitView;
 
 /**
  * WebViewProvider for creating a WebKit based IWebVIew implementation.
  */
 public class WebViewProvider {
-    private static final String KEY_CURRENTURL = "currenturl";
-
     /**
      * Preload webview data. This allows the webview implementation to load resources and other data
      * it might need, in advance of intialising the view (at which time we are probably wanting to
@@ -120,7 +103,7 @@ private static void configureDefaultSettings(Context context, WebSettings settin
         settings.setSavePassword(false);
     }
 
-    private static void applyAppSettings(Context context, WebSettings settings) {
+    public static void applyAppSettings(Context context, WebSettings settings) {
         final Settings appSettings = new Settings(context);
 
         // We could consider calling setLoadsImagesAutomatically() here too (This will block images not loaded over the network too)
@@ -191,232 +174,4 @@ private static String buildUserAgentString(final Context context, final WebSetti
 
         return uaBuilder.toString();
     }
-
-    private static class LinkHandler implements View.OnLongClickListener {
-        private final WebView webView;
-        private @Nullable IWebView.Callback callback = null;
-
-        public LinkHandler(final WebView webView) {
-            this.webView = webView;
-        }
-
-        public void setCallback(final @Nullable IWebView.Callback callback) {
-            this.callback = callback;
-        }
-
-        @Override
-        public boolean onLongClick(View v) {
-            if (callback == null) {
-                return false;
-            }
-
-            final WebView.HitTestResult hitTestResult = webView.getHitTestResult();
-
-            switch (hitTestResult.getType()) {
-                case WebView.HitTestResult.SRC_ANCHOR_TYPE:
-                    final String linkURL = hitTestResult.getExtra();
-                    callback.onLongPress(new IWebView.HitTarget(true, linkURL, false, null));
-                    return true;
-
-                case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
-                    // hitTestResult.getExtra() contains only the image URL, and not the link
-                    // URL. Internally, WebView's HitTestData contains both, but they only
-                    // make it available via requestFocusNodeHref...
-                    final Message message = new Message();
-                    message.setTarget(new Handler() {
-                        @Override
-                        public void handleMessage(Message msg) {
-                            final Bundle data = msg.getData();
-                            final String url = data.getString("url");
-                            final String src = data.getString("src");
-
-                            if (url == null || src == null) {
-                                throw new IllegalStateException("WebView did not supply url or src for image link");
-                            }
-
-                            callback.onLongPress(new IWebView.HitTarget(true, url, true, src));
-                        }
-                    });
-
-                    webView.requestFocusNodeHref(message);
-                    return true;
-            }
-
-            return false;
-        }
-    }
-
-
-    private static class WebkitView extends NestedWebView implements IWebView, SharedPreferences.OnSharedPreferenceChangeListener {
-        private Callback callback;
-        private FocusWebViewClient client;
-        private final LinkHandler linkHandler;
-
-        public WebkitView(Context context, AttributeSet attrs) {
-            super(context, attrs);
-
-            client = new FocusWebViewClient(getContext().getApplicationContext());
-
-            setWebViewClient(client);
-            setWebChromeClient(createWebChromeClient());
-            setDownloadListener(createDownloadListener());
-
-            if (BuildConfig.DEBUG) {
-                setWebContentsDebuggingEnabled(true);
-            }
-
-            setLongClickable(true);
-
-            linkHandler = new LinkHandler(this);
-            setOnLongClickListener(linkHandler);
-        }
-
-        @Override
-        protected void onAttachedToWindow() {
-            super.onAttachedToWindow();
-
-            PreferenceManager.getDefaultSharedPreferences(getContext()).registerOnSharedPreferenceChangeListener(this);
-        }
-
-        @Override
-        protected void onDetachedFromWindow() {
-            super.onDetachedFromWindow();
-
-            PreferenceManager.getDefaultSharedPreferences(getContext()).unregisterOnSharedPreferenceChangeListener(this);
-        }
-
-        @Override
-        public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
-            applyAppSettings(getContext(), getSettings());
-        }
-
-        @Override
-        public void restoreWebviewState(Bundle savedInstanceState) {
-            // We need to have a different method name because restoreState() returns
-            // a WebBackForwardList, and we can't overload with different return types:
-            final WebBackForwardList backForwardList = restoreState(savedInstanceState);
-
-            // Pages are only added to the back/forward list when loading finishes. If a new page is
-            // loading when the Activity is paused/killed, then that page won't be in the list,
-            // and needs to be restored separately to the history list. We detect this by checking
-            // whether the last fully loaded page (getCurrentItem()) matches the last page that the
-            // WebView was actively loading (which was retrieved during onSaveInstanceState():
-            // WebView.getUrl() always returns the currently loading or loaded page).
-            // If the app is paused/killed before the initial page finished loading, then the entire
-            // list will be null - so we need to additionally check whether the list even exists.
-
-            final String desiredURL = savedInstanceState.getString(KEY_CURRENTURL);
-            client.notifyCurrentURL(desiredURL);
-
-            if (backForwardList != null &&
-                    backForwardList.getCurrentItem().getUrl().equals(desiredURL)) {
-                // restoreState doesn't actually load the current page, it just restores navigation history,
-                // so we also need to explicitly reload in this case:
-                reload();
-            } else {
-                loadUrl(desiredURL);
-            }
-        }
-
-        @Override
-        public void onSaveInstanceState(Bundle outState) {
-            saveState(outState);
-            // See restoreWebViewState() for an explanation of why we need to save this in _addition_
-            // to WebView's state
-            outState.putString(KEY_CURRENTURL, getUrl());
-        }
-
-        @Override
-        public void setCallback(Callback callback) {
-            this.callback = callback;
-            client.setCallback(callback);
-            linkHandler.setCallback(callback);
-        }
-
-        public void loadUrl(String url) {
-            // We need to check external URL handling here - shouldOverrideUrlLoading() is only
-            // called by webview when clicking on a link, and not when opening a new page for the
-            // first time using loadUrl().
-            if (!client.shouldOverrideUrlLoading(this, url)) {
-                super.loadUrl(url);
-            }
-
-            client.notifyCurrentURL(url);
-        }
-
-        @Override
-        public void destroy() {
-            super.destroy();
-
-            // WebView might save data to disk once it gets destroyed. In this case our cleanup call
-            // might not have been able to see this data. Let's do it again.
-            deleteContentFromKnownLocations();
-        }
-
-        @Override
-        public void cleanup() {
-            clearFormData();
-            clearHistory();
-            clearMatches();
-            clearSslPreferences();
-            clearCache(true);
-
-            // We don't care about the callback - we just want to make sure cookies are gone
-            CookieManager.getInstance().removeAllCookies(null);
-
-            WebStorage.getInstance().deleteAllData();
-
-            final WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(getContext());
-            // It isn't entirely clear how this differs from WebView.clearFormData()
-            webViewDatabase.clearFormData();
-            webViewDatabase.clearHttpAuthUsernamePassword();
-
-            deleteContentFromKnownLocations();
-        }
-
-        private void deleteContentFromKnownLocations() {
-            final Context context = getContext();
-
-            ThreadUtils.postToBackgroundThread(new Runnable() {
-                @Override
-                public void run() {
-                    // We call all methods on WebView to delete data. But some traces still remain
-                    // on disk. This will wipe the whole webview directory.
-                    FileUtils.deleteWebViewDirectory(context);
-
-                    // WebView stores some files in the cache directory. We do not use it ourselves
-                    // so let's truncate it.
-                    FileUtils.truncateCacheDirectory(context);
-                }
-            });
-        }
-
-        private WebChromeClient createWebChromeClient() {
-            return new WebChromeClient() {
-                @Override
-                public void onProgressChanged(WebView view, int newProgress) {
-                    if (callback != null) {
-                        // This is the earliest point where we might be able to confirm a redirected
-                        // URL: we don't necessarily get a shouldInterceptRequest() after a redirect,
-                        // so we can only check the updated url in onProgressChanges(), or in onPageFinished()
-                        // (which is even later).
-                        callback.onURLChanged(view.getUrl());
-                        callback.onProgress(newProgress);
-                    }
-                }
-            };
-        }
-
-        private DownloadListener createDownloadListener() {
-            return new DownloadListener() {
-                @Override
-                public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) {
-                    if (callback != null) {
-                        final Download download = new Download(url, userAgent, contentDisposition, mimetype, contentLength);
-                        callback.onDownloadStart(download);
-                    }
-                }
-            };
-        }
-    }
 }
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/web/FocusWebViewClient.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/FocusWebViewClient.java
similarity index 98%
rename from focus-android/app/src/webkit/java/org/mozilla/focus/web/FocusWebViewClient.java
rename to focus-android/app/src/webkit/java/org/mozilla/focus/webkit/FocusWebViewClient.java
index 28f254c45f51..7bc959343ece 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/web/FocusWebViewClient.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/FocusWebViewClient.java
@@ -2,7 +2,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.web;
+package org.mozilla.focus.webkit;
 
 import android.content.Context;
 import android.content.res.Resources;
@@ -20,6 +20,7 @@
 import org.mozilla.focus.utils.HtmlLoader;
 import org.mozilla.focus.utils.SupportUtils;
 import org.mozilla.focus.utils.UrlUtils;
+import org.mozilla.focus.web.IWebView;
 import org.mozilla.focus.webkit.ErrorPage;
 import org.mozilla.focus.webkit.TrackingProtectionWebViewClient;
 
@@ -29,17 +30,16 @@
  * WebViewClient layer that handles browser specific WebViewClient functionality, such as error pages
  * and external URL handling.
  */
-public class FocusWebViewClient extends TrackingProtectionWebViewClient {
-    final static String ERROR_PROTOCOL = "error:";
+/* package */ class FocusWebViewClient extends TrackingProtectionWebViewClient {
+    private final static String ERROR_PROTOCOL = "error:";
+
+    private IWebView.Callback callback;
+    private boolean errorReceived;
 
     public FocusWebViewClient(Context context) {
         super(context);
     }
 
-    private IWebView.Callback callback;
-
-    boolean errorReceived;
-
     public void setCallback(IWebView.Callback callback) {
         this.callback = callback;
     }
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/LinkHandler.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/LinkHandler.java
new file mode 100644
index 000000000000..6d4b063e7194
--- /dev/null
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/LinkHandler.java
@@ -0,0 +1,70 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.webkit;
+
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.webkit.WebView;
+
+import org.mozilla.focus.web.IWebView;
+
+/* package */ class LinkHandler implements View.OnLongClickListener {
+    private final WebView webView;
+    private @Nullable
+    IWebView.Callback callback = null;
+
+    public LinkHandler(final WebView webView) {
+        this.webView = webView;
+    }
+
+    public void setCallback(final @Nullable IWebView.Callback callback) {
+        this.callback = callback;
+    }
+
+    @Override
+    public boolean onLongClick(View v) {
+        if (callback == null) {
+            return false;
+        }
+
+        final WebView.HitTestResult hitTestResult = webView.getHitTestResult();
+
+        switch (hitTestResult.getType()) {
+            case WebView.HitTestResult.SRC_ANCHOR_TYPE:
+                final String linkURL = hitTestResult.getExtra();
+                callback.onLongPress(new IWebView.HitTarget(true, linkURL, false, null));
+                return true;
+
+            case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
+                // hitTestResult.getExtra() contains only the image URL, and not the link
+                // URL. Internally, WebView's HitTestData contains both, but they only
+                // make it available via requestFocusNodeHref...
+                final Message message = new Message();
+                message.setTarget(new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        final Bundle data = msg.getData();
+                        final String url = data.getString("url");
+                        final String src = data.getString("src");
+
+                        if (url == null || src == null) {
+                            throw new IllegalStateException("WebView did not supply url or src for image link");
+                        }
+
+                        callback.onLongPress(new IWebView.HitTarget(true, url, true, src));
+                    }
+                });
+
+                webView.requestFocusNodeHref(message);
+                return true;
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
index 0963e9856e22..b9fdf51c6591 100644
--- a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/TrackingProtectionWebViewClient.java
@@ -20,10 +20,11 @@
 import org.mozilla.focus.webkit.matcher.UrlMatcher;
 
 public class TrackingProtectionWebViewClient extends WebViewClient {
-    protected String currentPageURL;
-
     private static volatile UrlMatcher MATCHER;
 
+    private boolean blockingEnabled;
+    /* package */ String currentPageURL;
+
     public static void triggerPreload(final Context context) {
         // Only trigger loading if MATCHER is null. (If it's null, MATCHER could already be loading,
         // but we don't have any way of being certain - and there's no real harm since we're not
@@ -47,14 +48,28 @@ protected Void doInBackground(Void... voids) {
         return MATCHER;
     }
 
-    public TrackingProtectionWebViewClient(final Context context) {
+    /* package */ TrackingProtectionWebViewClient(final Context context) {
         // Hopefully we have loaded background data already. We call triggerPreload() to try to trigger
         // background loading of the lists as early as possible.
         triggerPreload(context);
+
+        this.blockingEnabled = true;
+    }
+
+    public void setBlockingEnabled(boolean enabled) {
+        this.blockingEnabled = enabled;
+    }
+
+    public boolean isBlockingEnabled() {
+        return blockingEnabled;
     }
 
     @Override
     public WebResourceResponse shouldInterceptRequest(final WebView view, final WebResourceRequest request) {
+        if (!blockingEnabled) {
+            return super.shouldInterceptRequest(view, request);
+        }
+
         final Uri resourceUri = request.getUrl();
 
         // shouldInterceptRequest() might be called _before_ onPageStarted or shouldOverrideUrlLoading
diff --git a/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/WebkitView.java b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/WebkitView.java
new file mode 100644
index 000000000000..d771fbaf3279
--- /dev/null
+++ b/focus-android/app/src/webkit/java/org/mozilla/focus/webkit/WebkitView.java
@@ -0,0 +1,210 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.webkit;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.util.AttributeSet;
+import android.webkit.CookieManager;
+import android.webkit.DownloadListener;
+import android.webkit.WebBackForwardList;
+import android.webkit.WebChromeClient;
+import android.webkit.WebStorage;
+import android.webkit.WebView;
+import android.webkit.WebViewDatabase;
+
+import org.mozilla.focus.BuildConfig;
+import org.mozilla.focus.utils.FileUtils;
+import org.mozilla.focus.utils.ThreadUtils;
+import org.mozilla.focus.web.Download;
+import org.mozilla.focus.web.IWebView;
+import org.mozilla.focus.web.WebViewProvider;
+
+public class WebkitView extends NestedWebView implements IWebView, SharedPreferences.OnSharedPreferenceChangeListener {
+    private static final String KEY_CURRENTURL = "currenturl";
+
+    private Callback callback;
+    private FocusWebViewClient client;
+    private final LinkHandler linkHandler;
+
+    public WebkitView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        client = new FocusWebViewClient(getContext().getApplicationContext());
+
+        setWebViewClient(client);
+        setWebChromeClient(createWebChromeClient());
+        setDownloadListener(createDownloadListener());
+
+        if (BuildConfig.DEBUG) {
+            setWebContentsDebuggingEnabled(true);
+        }
+
+        setLongClickable(true);
+
+        linkHandler = new LinkHandler(this);
+        setOnLongClickListener(linkHandler);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        PreferenceManager.getDefaultSharedPreferences(getContext()).registerOnSharedPreferenceChangeListener(this);
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        PreferenceManager.getDefaultSharedPreferences(getContext()).unregisterOnSharedPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
+        WebViewProvider.applyAppSettings(getContext(), getSettings());
+    }
+
+    @Override
+    public void restoreWebviewState(Bundle savedInstanceState) {
+        // We need to have a different method name because restoreState() returns
+        // a WebBackForwardList, and we can't overload with different return types:
+        final WebBackForwardList backForwardList = restoreState(savedInstanceState);
+
+        // Pages are only added to the back/forward list when loading finishes. If a new page is
+        // loading when the Activity is paused/killed, then that page won't be in the list,
+        // and needs to be restored separately to the history list. We detect this by checking
+        // whether the last fully loaded page (getCurrentItem()) matches the last page that the
+        // WebView was actively loading (which was retrieved during onSaveInstanceState():
+        // WebView.getUrl() always returns the currently loading or loaded page).
+        // If the app is paused/killed before the initial page finished loading, then the entire
+        // list will be null - so we need to additionally check whether the list even exists.
+
+        final String desiredURL = savedInstanceState.getString(KEY_CURRENTURL);
+        client.notifyCurrentURL(desiredURL);
+
+        if (backForwardList != null &&
+                backForwardList.getCurrentItem().getUrl().equals(desiredURL)) {
+            // restoreState doesn't actually load the current page, it just restores navigation history,
+            // so we also need to explicitly reload in this case:
+            reload();
+        } else {
+            loadUrl(desiredURL);
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        saveState(outState);
+        // See restoreWebViewState() for an explanation of why we need to save this in _addition_
+        // to WebView's state
+        outState.putString(KEY_CURRENTURL, getUrl());
+    }
+
+    @Override
+    public void setBlockingEnabled(boolean enabled) {
+        client.setBlockingEnabled(enabled);
+    }
+
+    public boolean isBlockingEnabled() {
+        return client.isBlockingEnabled();
+    }
+
+    @Override
+    public void setCallback(Callback callback) {
+        this.callback = callback;
+        client.setCallback(callback);
+        linkHandler.setCallback(callback);
+    }
+
+    public void loadUrl(String url) {
+        // We need to check external URL handling here - shouldOverrideUrlLoading() is only
+        // called by webview when clicking on a link, and not when opening a new page for the
+        // first time using loadUrl().
+        if (!client.shouldOverrideUrlLoading(this, url)) {
+            super.loadUrl(url);
+        }
+
+        client.notifyCurrentURL(url);
+    }
+
+    @Override
+    public void destroy() {
+        super.destroy();
+
+        // WebView might save data to disk once it gets destroyed. In this case our cleanup call
+        // might not have been able to see this data. Let's do it again.
+        deleteContentFromKnownLocations();
+    }
+
+    @Override
+    public void cleanup() {
+        clearFormData();
+        clearHistory();
+        clearMatches();
+        clearSslPreferences();
+        clearCache(true);
+
+        // We don't care about the callback - we just want to make sure cookies are gone
+        CookieManager.getInstance().removeAllCookies(null);
+
+        WebStorage.getInstance().deleteAllData();
+
+        final WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(getContext());
+        // It isn't entirely clear how this differs from WebView.clearFormData()
+        webViewDatabase.clearFormData();
+        webViewDatabase.clearHttpAuthUsernamePassword();
+
+        deleteContentFromKnownLocations();
+    }
+
+    private void deleteContentFromKnownLocations() {
+        final Context context = getContext();
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // We call all methods on WebView to delete data. But some traces still remain
+                // on disk. This will wipe the whole webview directory.
+                FileUtils.deleteWebViewDirectory(context);
+
+                // WebView stores some files in the cache directory. We do not use it ourselves
+                // so let's truncate it.
+                FileUtils.truncateCacheDirectory(context);
+            }
+        });
+    }
+
+    private WebChromeClient createWebChromeClient() {
+        return new WebChromeClient() {
+            @Override
+            public void onProgressChanged(WebView view, int newProgress) {
+                if (callback != null) {
+                    // This is the earliest point where we might be able to confirm a redirected
+                    // URL: we don't necessarily get a shouldInterceptRequest() after a redirect,
+                    // so we can only check the updated url in onProgressChanges(), or in onPageFinished()
+                    // (which is even later).
+                    callback.onURLChanged(view.getUrl());
+                    callback.onProgress(newProgress);
+                }
+            }
+        };
+    }
+
+    private DownloadListener createDownloadListener() {
+        return new DownloadListener() {
+            @Override
+            public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) {
+                if (callback != null) {
+                    final Download download = new Download(url, userAgent, contentDisposition, mimetype, contentLength);
+                    callback.onDownloadStart(download);
+                }
+            }
+        };
+    }
+}
\ No newline at end of file
