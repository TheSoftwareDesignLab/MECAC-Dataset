diff --git a/focus-android/app/src/main/AndroidManifest.xml b/focus-android/app/src/main/AndroidManifest.xml
index 24c0514a14b3..d099f1ab1ce2 100644
--- a/focus-android/app/src/main/AndroidManifest.xml
+++ b/focus-android/app/src/main/AndroidManifest.xml
@@ -31,6 +31,7 @@
         <activity android:name=".activity.MainActivity"
             android:launchMode="singleTask"
             android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation|screenSize|locale|layoutDirection|smallestScreenSize|screenLayout"
+            android:windowSoftInputMode="adjustResize"
             android:label="@string/app_name">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.java b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.java
index cdf1cd8e6874..8b39654f2ca9 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.java
@@ -17,7 +17,6 @@
 import org.mozilla.focus.R;
 import org.mozilla.focus.fragment.BrowserFragment;
 import org.mozilla.focus.fragment.FirstrunFragment;
-import org.mozilla.focus.fragment.HomeFragment;
 import org.mozilla.focus.fragment.UrlInputFragment;
 import org.mozilla.focus.locale.LocaleAwareAppCompatActivity;
 import org.mozilla.focus.notification.BrowsingNotificationService;
@@ -217,14 +216,14 @@ private void processEraseAction(final SafeIntent intent) {
     }
 
     private void showHomeScreen() {
-        // We add the home fragment to the layout if it doesn't exist yet. I tried adding the fragment
-        // to the layout directly but then I wasn't able to remove it later. It was still visible but
-        // without an activity attached. So let's do it manually.
+        // We add the url input fragment to the layout if it doesn't exist yet. I tried adding the
+        // fragment to the layout directly but then I wasn't able to remove it later. It was still
+        // visible but without an activity attached. So let's do it manually.
         final FragmentManager fragmentManager = getSupportFragmentManager();
-        if (fragmentManager.findFragmentByTag(HomeFragment.FRAGMENT_TAG) == null) {
+        if (fragmentManager.findFragmentByTag(UrlInputFragment.FRAGMENT_TAG) == null) {
             fragmentManager
                     .beginTransaction()
-                    .replace(R.id.container, HomeFragment.create(), HomeFragment.FRAGMENT_TAG)
+                    .replace(R.id.container, UrlInputFragment.createWithBackground(), UrlInputFragment.FRAGMENT_TAG)
                     .commit();
         }
     }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
index b8920bd0c643..76b29dfac8ef 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
@@ -663,7 +663,7 @@ public void eraseAndShowHomeScreen(final boolean animateErase) {
         }
 
         transaction
-                .replace(R.id.container, HomeFragment.create(), HomeFragment.FRAGMENT_TAG)
+                .replace(R.id.container, UrlInputFragment.createWithBackground(), UrlInputFragment.FRAGMENT_TAG)
                 .commit();
 
         ViewUtils.showBrandedSnackbar(getActivity().findViewById(android.R.id.content),
@@ -690,7 +690,7 @@ public void onClick(View view) {
 
             case R.id.display_url:
                 final Fragment urlFragment = UrlInputFragment
-                        .createWithBrowserScreenAnimation(UrlUtils.getSearchTermsOrUrl(getContext(), getUrl()), urlView);
+                        .createAsOverlay(UrlUtils.getSearchTermsOrUrl(getContext(), getUrl()), urlView);
 
                 getActivity().getSupportFragmentManager()
                         .beginTransaction()
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/HomeFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/HomeFragment.java
deleted file mode 100644
index acee9571b52f..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/HomeFragment.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.fragment;
-
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.annotation.Nullable;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.support.v7.widget.PopupMenu;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.activity.InfoActivity;
-import org.mozilla.focus.locale.LocaleAwareAppCompatActivity;
-import org.mozilla.focus.locale.LocaleAwareFragment;
-
-/**
- * Fragment displaying the "home" screen when launching the app.
- */
-public class HomeFragment
-        extends LocaleAwareFragment
-        implements View.OnClickListener, PopupMenu.OnMenuItemClickListener, PopupMenu.OnDismissListener {
-    public static final String FRAGMENT_TAG = "home";
-
-    public static HomeFragment create() {
-        return new HomeFragment();
-    }
-
-    private View fakeUrlBarView;
-
-    @Nullable private PopupMenu displayedPopupMenu = null;
-
-    @Override
-    public void applyLocale() {
-        // We only show static text in this fragment, it's simplest just to reload everything:
-        getActivity()
-                .getSupportFragmentManager()
-                .beginTransaction()
-                .replace(R.id.container, HomeFragment.create(), HomeFragment.FRAGMENT_TAG)
-                .commit();
-    }
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-
-        final FragmentActivity activity = getActivity();
-        // No safe intent needed here - intent.getAction() is always safe:
-        if (activity != null && Intent.ACTION_VIEW.equals(activity.getIntent().getAction())) {
-            // If this activity was launched from a ACTION_VIEW intent then pressing back will send
-            // the user back to the previous application (finishing this activity). However if the
-            // user presses "erase" we will send the user back to the home screen. Pressing back
-            // in a new browsing session should send the user back to the home screen instead of
-            // the previous app. Therefore we clear the intent once we show the home screen.
-            activity.setIntent(new Intent(Intent.ACTION_MAIN));
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-
-        // On detach, the PopupMenu is no longer relevant to other content (e.g. BrowserFragment) so dismiss it.
-        // Note: if we don't dismiss the PopupMenu, its onMenuItemClick method references the old Fragment, which now
-        // has a null Context and will cause crashes.
-        if (displayedPopupMenu != null) {
-            displayedPopupMenu.dismiss();
-        }
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
-        final View view = inflater.inflate(R.layout.fragment_home, container, false);
-
-        fakeUrlBarView = view.findViewById(R.id.fake_urlbar);
-        fakeUrlBarView.setOnClickListener(this);
-
-        view.findViewById(R.id.menu).setOnClickListener(this);
-
-        return view;
-    }
-
-    @Override
-    public void onClick(View view) {
-        switch (view.getId()) {
-            case R.id.fake_urlbar:
-                showUrlInput();
-                break;
-
-            case R.id.menu:
-                final PopupMenu popupMenu = new PopupMenu(view.getContext(), view);
-                popupMenu.getMenuInflater().inflate(R.menu.menu_home, popupMenu.getMenu());
-                popupMenu.setOnMenuItemClickListener(this);
-                popupMenu.setGravity(Gravity.TOP);
-                popupMenu.show();
-                displayedPopupMenu = popupMenu;
-                break;
-
-            default:
-                throw new IllegalStateException("Unhandled view ID in onClick()");
-        }
-    }
-
-    private synchronized void showUrlInput() {
-        final FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
-
-        final Fragment existingFragment = fragmentManager.findFragmentByTag(UrlInputFragment.FRAGMENT_TAG);
-        if (existingFragment != null && existingFragment.isAdded() && !existingFragment.isRemoving()) {
-            // We are already showing an URL input fragment. This might have been a double click on the
-            // fake URL bar. Just ignore it.
-            return;
-        }
-
-        final UrlInputFragment fragment = UrlInputFragment.createWithHomeScreenAnimation(fakeUrlBarView);
-
-        fragmentManager.beginTransaction()
-                .add(R.id.container, fragment, UrlInputFragment.FRAGMENT_TAG)
-                .commit();
-    }
-
-    @Override
-    public boolean onMenuItemClick(MenuItem item) {
-        final int id = item.getItemId();
-
-        switch (id) {
-            case R.id.settings:
-                ((LocaleAwareAppCompatActivity) getActivity()).openPreferences();
-                return true;
-
-            case R.id.about:
-                Intent aboutIntent = InfoActivity.getAboutIntent(getActivity());
-                startActivity(aboutIntent);
-                return true;
-
-            case R.id.rights:
-                Intent rightsIntent = InfoActivity.getRightsIntent(getActivity());
-                startActivity(rightsIntent);
-                return true;
-
-            case R.id.help:
-                Intent helpIntent = InfoActivity.getHelpIntent(getActivity());
-                startActivity(helpIntent);
-                return true;
-
-            default:
-                throw new IllegalStateException("Unhandled view ID in onMenuItemClick()");
-        }
-    }
-
-    @Override
-    public void onDismiss(final PopupMenu menu) {
-        displayedPopupMenu = null;
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.java
index b7482db46b28..8d53587437b8 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.java
@@ -7,25 +7,29 @@
 
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
-import android.animation.ObjectAnimator;
 import android.app.Activity;
+import android.content.Intent;
 import android.graphics.Typeface;
 import android.os.Bundle;
 import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
+import android.support.v7.widget.PopupMenu;
 import android.text.SpannableString;
 import android.text.style.StyleSpan;
+import android.view.Gravity;
 import android.view.LayoutInflater;
+import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
-import android.view.animation.DecelerateInterpolator;
 import android.widget.FrameLayout;
 import android.widget.TextView;
 
 import org.mozilla.focus.R;
+import org.mozilla.focus.activity.InfoActivity;
 import org.mozilla.focus.autocomplete.UrlAutoCompleteFilter;
+import org.mozilla.focus.locale.LocaleAwareAppCompatActivity;
 import org.mozilla.focus.telemetry.TelemetryWrapper;
 import org.mozilla.focus.utils.ThreadUtils;
 import org.mozilla.focus.utils.UrlUtils;
@@ -36,7 +40,7 @@
 /**
  * Fragment for displaying he URL input controls.
  */
-public class UrlInputFragment extends Fragment implements View.OnClickListener, InlineAutocompleteEditText.OnCommitListener, InlineAutocompleteEditText.OnFilterListener {
+public class UrlInputFragment extends Fragment implements View.OnClickListener, InlineAutocompleteEditText.OnCommitListener, InlineAutocompleteEditText.OnFilterListener, PopupMenu.OnMenuItemClickListener {
     public static final String FRAGMENT_TAG = "url_input";
 
     private static final String ARGUMENT_URL = "url";
@@ -45,41 +49,35 @@ public class UrlInputFragment extends Fragment implements View.OnClickListener,
     private static final String ARGUMENT_Y = "y";
     private static final String ARGUMENT_WIDTH = "width";
     private static final String ARGUMENT_HEIGHT = "height";
+    private static final String ARGUMENT_OVERLAY = "translucent";
 
-    private static final String ANIMATION_HOME_SCREEN = "home_screen";
     private static final String ANIMATION_BROWSER_SCREEN = "browser_screen";
 
     private static final int ANIMATION_DURATION = 200;
 
     /**
-     * Create a new UrlInputFragment and animate the url input view from the position/size of the
-     * fake url bar view.
+     * Create a new UrlInputFragment with a gradient background (and the Focus logo). This configuration
+     * is usually shown if there's no content to be shown below (e.g. the current website).
      */
-    public static UrlInputFragment createWithHomeScreenAnimation(View fakeUrlBarView) {
-        int[] screenLocation = new int[2];
-        fakeUrlBarView.getLocationOnScreen(screenLocation);
-
-        Bundle arguments = new Bundle();
-        arguments.putString(ARGUMENT_ANIMATION, ANIMATION_HOME_SCREEN);
-        arguments.putInt(ARGUMENT_X, screenLocation[0]);
-        arguments.putInt(ARGUMENT_Y, screenLocation[1]);
-        arguments.putInt(ARGUMENT_WIDTH, fakeUrlBarView.getWidth());
-        arguments.putInt(ARGUMENT_HEIGHT, fakeUrlBarView.getHeight());
+    public static UrlInputFragment createWithBackground() {
+        final Bundle arguments = new Bundle();
+        arguments.putBoolean(ARGUMENT_OVERLAY, false);
 
-        UrlInputFragment fragment = new UrlInputFragment();
+        final UrlInputFragment fragment = new UrlInputFragment();
         fragment.setArguments(arguments);
 
         return fragment;
     }
 
     /**
-     * Create a new UrlInputFragment and animate the url input view from the position/size of the
-     * browser toolbar's URL view.
+     * Create a new UrlInputFragment as an overlay shown on top of a different view (e.g. the
+     * current website).
      */
-    public static UrlInputFragment createWithBrowserScreenAnimation(String url, View urlView) {
+    public static UrlInputFragment createAsOverlay(String url, View urlView) {
         final Bundle arguments = new Bundle();
         arguments.putString(ARGUMENT_ANIMATION, ANIMATION_BROWSER_SCREEN);
         arguments.putString(ARGUMENT_URL, url);
+        arguments.putBoolean(ARGUMENT_OVERLAY, true);
 
         int[] screenLocation = new int[2];
         urlView.getLocationOnScreen(screenLocation);
@@ -105,6 +103,9 @@ public static UrlInputFragment createWithBrowserScreenAnimation(String url, View
     private HintFrameLayout urlInputContainerView;
     private View urlInputBackgroundView;
     private View toolbarBackgroundView;
+    private View menuView;
+
+    private @Nullable PopupMenu displayedPopupMenu;
 
     private volatile boolean isAnimating;
 
@@ -141,6 +142,8 @@ public void onFocusChange(View v, boolean hasFocus) {
         toolbarBackgroundView = view.findViewById(R.id.toolbar_background);
         urlInputBackgroundView = view.findViewById(R.id.url_input_background);
 
+        menuView = view.findViewById(R.id.menu);
+
         urlInputContainerView = (HintFrameLayout) view.findViewById(R.id.url_input_container);
         urlInputContainerView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
             @Override
@@ -153,6 +156,16 @@ public boolean onPreDraw() {
             }
         });
 
+        if (isOverlay()) {
+            view.findViewById(R.id.brand_background).setVisibility(View.GONE);
+        } else {
+            dismissView.setVisibility(View.GONE);
+            toolbarBackgroundView.setVisibility(View.GONE);
+
+            menuView.setVisibility(View.VISIBLE);
+            menuView.setOnClickListener(this);
+        }
+
         urlView.setOnCommitListener(this);
 
         if (getArguments().containsKey(ARGUMENT_URL)) {
@@ -163,9 +176,17 @@ public boolean onPreDraw() {
         return view;
     }
 
+    private boolean isOverlay() {
+        return getArguments().getBoolean(ARGUMENT_OVERLAY, false);
+    }
+
     public boolean onBackPressed() {
-        animateAndDismiss();
-        return true;
+        if (isOverlay()) {
+            animateAndDismiss();
+            return true;
+        }
+
+        return false;
     }
 
     @Override
@@ -179,8 +200,7 @@ public void onStart() {
     public void onClick(View view) {
         switch (view.getId()) {
             case R.id.clear:
-                urlView.setText("");
-                urlView.requestFocus();
+                clear();
                 break;
 
             case R.id.search_hint:
@@ -188,7 +208,20 @@ public void onClick(View view) {
                 break;
 
             case R.id.dismiss:
-                animateAndDismiss();
+                if (isOverlay()) {
+                    animateAndDismiss();
+                } else {
+                    clear();
+                }
+                break;
+
+            case R.id.menu:
+                final PopupMenu popupMenu = new PopupMenu(view.getContext(), view);
+                popupMenu.getMenuInflater().inflate(R.menu.menu_home, popupMenu.getMenu());
+                popupMenu.setOnMenuItemClickListener(this);
+                popupMenu.setGravity(Gravity.TOP);
+                popupMenu.show();
+                displayedPopupMenu = popupMenu;
                 break;
 
             default:
@@ -196,13 +229,28 @@ public void onClick(View view) {
         }
     }
 
+    private void clear() {
+        urlView.setText("");
+        urlView.requestFocus();
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        // On detach, the PopupMenu is no longer relevant to other content (e.g. BrowserFragment) so dismiss it.
+        // Note: if we don't dismiss the PopupMenu, its onMenuItemClick method references the old Fragment, which now
+        // has a null Context and will cause crashes.
+        if (displayedPopupMenu != null) {
+            displayedPopupMenu.dismiss();
+        }
+    }
+
     private void animateFirstDraw() {
         final String animation = getArguments().getString(ARGUMENT_ANIMATION);
 
-        if (ANIMATION_HOME_SCREEN.equals(animation)) {
-            playHomeScreenAnimation(false);
-        } else if (ANIMATION_BROWSER_SCREEN.equals(animation)) {
-            playBrowserScreenAnimation(false);
+        if (ANIMATION_BROWSER_SCREEN.equals(animation)) {
+            playVisibilityAnimation(false);
         }
     }
 
@@ -222,110 +270,20 @@ private void animateAndDismiss() {
 
         final String animation = getArguments().getString(ARGUMENT_ANIMATION);
 
-        if (ANIMATION_HOME_SCREEN.equals(animation)) {
-            playHomeScreenAnimation(true);
-        } else if (ANIMATION_BROWSER_SCREEN.equals(animation)) {
-            playBrowserScreenAnimation(true);
+        if (ANIMATION_BROWSER_SCREEN.equals(animation)) {
+            playVisibilityAnimation(true);
         } else {
             dismiss();
         }
     }
 
     /**
-     * Play animation between home screen and the URL input.
+     * This animation is quite complex. The 'reverse' flag controls whether we want to show the UI
+     * (false) or whether we are going to hide it (true). Additionally the animation is slightly
+     * different depending on whether this fragment is shown as an overlay on top of other fragments
+     * or if it draws its own background.
      */
-    private void playHomeScreenAnimation(final boolean reverse) {
-        if (isAnimating) {
-            // We are already animating, let's ignore another request.
-            return;
-        }
-
-        isAnimating = true;
-
-        int[] screenLocation = new int[2];
-        urlInputContainerView.getLocationOnScreen(screenLocation);
-
-        int leftDelta = getArguments().getInt(ARGUMENT_X) - screenLocation[0];
-        int topDelta = getArguments().getInt(ARGUMENT_Y) - screenLocation[1];
-
-        float widthScale = (float) getArguments().getInt(ARGUMENT_WIDTH) / urlInputContainerView.getWidth();
-        float heightScale = (float) getArguments().getInt(ARGUMENT_HEIGHT) / urlInputContainerView.getHeight();
-
-        if (!reverse) {
-            // Move all views to the position of the fake URL bar on the home screen. Hide them until
-            // the animation starts because we need to switch between fake URL bar and the actual URL
-            // bar once the animation starts.
-            urlInputContainerView.setAlpha(0);
-            urlInputContainerView.setPivotX(0);
-            urlInputContainerView.setPivotY(0);
-            urlInputContainerView.setScaleX(widthScale);
-            urlInputContainerView.setScaleY(heightScale);
-            urlInputContainerView.setTranslationX(leftDelta);
-            urlInputContainerView.setTranslationY(topDelta);
-            urlInputContainerView.setAnimationOffset(1.0f);
-
-            toolbarBackgroundView.setAlpha(0);
-
-            dismissView.setAlpha(0);
-        }
-
-        // Move the URL bar from its position on the home screen to the actual position (and scale it).
-        urlInputContainerView.animate()
-                .setDuration(ANIMATION_DURATION)
-                .scaleX(reverse ? widthScale : 1)
-                .scaleY(reverse ? heightScale : 1)
-                .translationX(reverse ? leftDelta : 0)
-                .translationY(reverse ? topDelta : 0)
-                .setInterpolator(new DecelerateInterpolator())
-                .setListener(new AnimatorListenerAdapter() {
-                    @Override
-                    public void onAnimationStart(Animator animation) {
-                        ViewUtils.updateAlphaIfViewExists(getActivity(), R.id.fake_urlbar, 0f);
-
-                        urlInputContainerView.setAlpha(1);
-
-                        if (reverse) {
-                            urlView.setText("");
-                            urlView.setCursorVisible(false);
-                            urlView.clearFocus();
-                        }
-                    }
-
-                    @Override
-                    public void onAnimationEnd(Animator animation) {
-                        if (reverse) {
-                            urlInputContainerView.setAlpha(0f);
-
-                            ViewUtils.updateAlphaIfViewExists(getActivity(), R.id.fake_urlbar, 1f);
-
-                            dismiss();
-                        } else {
-                            urlView.setCursorVisible(true);
-                        }
-
-                        isAnimating = false;
-                    }
-                });
-
-        final ObjectAnimator hintAnimator = ObjectAnimator.ofFloat(
-                urlInputContainerView, "animationOffset", reverse ? 0f : 1f, reverse ? 1f : 0f);
-
-        hintAnimator.setDuration(ANIMATION_DURATION);
-        hintAnimator.start();
-
-        // Let the toolbar background come int from the top
-        toolbarBackgroundView.animate()
-                .alpha(reverse ? 0 : 1)
-                .setDuration(ANIMATION_DURATION)
-                .setInterpolator(new DecelerateInterpolator());
-
-        // Use an alpha animation on the transparent black background
-        dismissView.animate()
-                .alpha(reverse ? 0 : 1)
-                .setDuration(ANIMATION_DURATION);
-    }
-
-    private void playBrowserScreenAnimation(final boolean reverse) {
+    private void playVisibilityAnimation(final boolean reverse) {
         if (isAnimating) {
             // We are already animating, let's ignore another request.
             return;
@@ -334,21 +292,28 @@ private void playBrowserScreenAnimation(final boolean reverse) {
         isAnimating = true;
 
         {
-            float containerMargin = ((FrameLayout.LayoutParams) urlInputContainerView.getLayoutParams()).bottomMargin;
+            float xyOffset = isOverlay() ?
+                    ((FrameLayout.LayoutParams) urlInputContainerView.getLayoutParams()).bottomMargin
+                    : 0;
 
             float width = urlInputBackgroundView.getWidth();
             float height = urlInputBackgroundView.getHeight();
 
-            float widthScale = (width + (2 * containerMargin)) / width;
-            float heightScale = (height + (2 * containerMargin)) / height;
+            float widthScale = isOverlay()
+                    ? (width + (2 * xyOffset)) / width
+                    : 1;
+
+            float heightScale = isOverlay()
+                    ? (height + (2 * xyOffset)) / height
+                    : 1;
 
             if (!reverse) {
                 urlInputBackgroundView.setPivotX(0);
                 urlInputBackgroundView.setPivotY(0);
                 urlInputBackgroundView.setScaleX(widthScale);
                 urlInputBackgroundView.setScaleY(heightScale);
-                urlInputBackgroundView.setTranslationX(-containerMargin);
-                urlInputBackgroundView.setTranslationY(-containerMargin);
+                urlInputBackgroundView.setTranslationX(-xyOffset);
+                urlInputBackgroundView.setTranslationY(-xyOffset);
                 urlInputContainerView.setAnimationOffset(0f);
 
                 clearView.setAlpha(0);
@@ -359,9 +324,9 @@ private void playBrowserScreenAnimation(final boolean reverse) {
                     .setDuration(ANIMATION_DURATION)
                     .scaleX(reverse ? widthScale : 1)
                     .scaleY(reverse ? heightScale : 1)
-                    .alpha(reverse ? 0 : 1)
-                    .translationX(reverse ? -containerMargin : 0)
-                    .translationY(reverse ? -containerMargin : 0)
+                    .alpha(reverse && isOverlay() ? 0 : 1)
+                    .translationX(reverse ? -xyOffset : 0)
+                    .translationY(reverse ? -xyOffset : 0)
                     .setListener(new AnimatorListenerAdapter() {
                         @Override
                         public void onAnimationStart(Animator animation) {
@@ -373,7 +338,9 @@ public void onAnimationStart(Animator animation) {
                         @Override
                         public void onAnimationEnd(Animator animation) {
                             if (reverse) {
-                                dismiss();
+                                if (isOverlay()) {
+                                    dismiss();
+                                }
                             } else {
                                 clearView.setAlpha(1);
                             }
@@ -382,7 +349,9 @@ public void onAnimationEnd(Animator animation) {
                         }
                     });
         }
-        {
+
+        // We only need to animate the toolbar if we are an overlay.
+        if (isOverlay()) {
             int[] screenLocation = new int[2];
             urlView.getLocationOnScreen(screenLocation);
 
@@ -408,7 +377,25 @@ public void onAnimationEnd(Animator animation) {
         // The darker background appears with an alpha animation
         toolbarBackgroundView.animate()
                 .setDuration(ANIMATION_DURATION)
-                .alpha(reverse ? 0 : 1);
+                .alpha(reverse ? 0 : 1)
+                .setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationStart(Animator animation) {
+                        toolbarBackgroundView.setVisibility(View.VISIBLE);
+                    }
+
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        if (reverse) {
+                            toolbarBackgroundView.setVisibility(View.GONE);
+
+                            if (!isOverlay()) {
+                                dismissView.setVisibility(View.GONE);
+                                menuView.setVisibility(View.VISIBLE);
+                            }
+                        }
+                    }
+                });
     }
 
     private void dismiss() {
@@ -496,8 +483,18 @@ public void onFilter(String searchText, InlineAutocompleteEditText view) {
         if (searchText.trim().isEmpty()) {
             clearView.setVisibility(View.GONE);
             searchViewContainer.setVisibility(View.GONE);
+
+            if (!isOverlay()) {
+                playVisibilityAnimation(true);
+            }
         } else {
             clearView.setVisibility(View.VISIBLE);
+            menuView.setVisibility(View.GONE);
+
+            if (!isOverlay() && dismissView.getVisibility() != View.VISIBLE) {
+                playVisibilityAnimation(false);
+                dismissView.setVisibility(View.VISIBLE);
+            }
 
             final String hint = getString(R.string.search_hint, searchText);
 
@@ -508,4 +505,33 @@ public void onFilter(String searchText, InlineAutocompleteEditText view) {
             searchViewContainer.setVisibility(View.VISIBLE);
         }
     }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        final int id = item.getItemId();
+
+        switch (id) {
+            case R.id.settings:
+                ((LocaleAwareAppCompatActivity) getActivity()).openPreferences();
+                return true;
+
+            case R.id.about:
+                Intent aboutIntent = InfoActivity.getAboutIntent(getActivity());
+                startActivity(aboutIntent);
+                return true;
+
+            case R.id.rights:
+                Intent rightsIntent = InfoActivity.getRightsIntent(getActivity());
+                startActivity(rightsIntent);
+                return true;
+
+            case R.id.help:
+                Intent helpIntent = InfoActivity.getHelpIntent(getActivity());
+                startActivity(helpIntent);
+                return true;
+
+            default:
+                throw new IllegalStateException("Unhandled view ID in onMenuItemClick()");
+        }
+    }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardCoordinatorLayout.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardCoordinatorLayout.java
new file mode 100644
index 000000000000..90d9f0983ab9
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardCoordinatorLayout.java
@@ -0,0 +1,45 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.widget;
+
+import android.content.Context;
+import android.support.design.widget.CoordinatorLayout;
+import android.util.AttributeSet;
+
+/**
+ * A CoordinatorLayout implementation that resizes dynamically based on whether a keyboard is visible or not.
+ */
+public class ResizableKeyboardCoordinatorLayout extends CoordinatorLayout {
+    private final ResizableKeyboardViewDelegate delegate;
+
+    public ResizableKeyboardCoordinatorLayout(Context context) {
+        this(context, null);
+    }
+
+    public ResizableKeyboardCoordinatorLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ResizableKeyboardCoordinatorLayout(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        delegate = new ResizableKeyboardViewDelegate(this, attrs);
+    }
+
+    @Override
+    public void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        delegate.onAttachedToWindow();
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        delegate.onDetachedFromWindow();
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLayout.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLayout.java
deleted file mode 100644
index 19d064d81dad..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLayout.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.widget;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Rect;
-import android.support.annotation.Nullable;
-import android.support.design.widget.CoordinatorLayout;
-import android.util.AttributeSet;
-import android.view.View;
-import android.view.ViewTreeObserver;
-
-import org.mozilla.focus.R;
-
-/**
- * A CoordinatorLayout implementation that resizes dynamically (by adding padding to the bottom)
- * based on whether a keyboard is visible or not.
- *
- * Implementation based on:
- * https://github.com/mikepenz/MaterialDrawer/blob/master/library/src/main/java/com/mikepenz/materialdrawer/util/KeyboardUtil.java
- *
- * An optional viewToHideWhenActivated can be set: this is a View that will be hidden when the keyboard
- * is showing. That can be useful for things like FABs that you don't need when someone is typing.
- */
-public class ResizableKeyboardLayout extends CoordinatorLayout {
-    private final Rect rect;
-    private View decorView;
-
-    private final int idOfViewToHide;
-    private @Nullable View viewToHide;
-
-    public ResizableKeyboardLayout(Context context) {
-        this(context, null);
-    }
-
-    public ResizableKeyboardLayout(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-    }
-
-    public ResizableKeyboardLayout(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-
-        rect = new Rect();
-
-        final TypedArray styleAttributeArray = getContext().getTheme().obtainStyledAttributes(
-                attrs,
-                R.styleable.ResizableKeyboardLayout,
-                0, 0);
-
-        try {
-            idOfViewToHide = styleAttributeArray.getResourceId(R.styleable.ResizableKeyboardLayout_viewToHideWhenActivated, -1);
-        } finally {
-            styleAttributeArray.recycle();
-        }
-    }
-
-    private ViewTreeObserver.OnGlobalLayoutListener layoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
-        @Override
-        public void onGlobalLayout() {
-            int difference = calculateDifferenceBetweenHeightAndUsableArea();
-
-            // If difference > 0, keyboard is showing.
-            // If difference =< 0, keyboard is not showing or is in multiview mode.
-            if (difference > 0) {
-                // Keyboard showing -> Set difference has bottom padding.
-                if (getPaddingBottom() != difference) {
-                    setPadding(0, 0, 0, difference);
-
-                    if (viewToHide != null) {
-                        viewToHide.setVisibility(View.GONE);
-                    }
-                }
-            } else {
-                // Keyboard not showing -> Reset bottom padding.
-                if (getPaddingBottom() != 0) {
-                    setPadding(0, 0, 0, 0);
-
-                    if (viewToHide != null) {
-                        viewToHide.setVisibility(View.VISIBLE);
-                    }
-                }
-            }
-        }
-    };
-
-    private int calculateDifferenceBetweenHeightAndUsableArea() {
-        if (decorView == null) {
-            decorView = getRootView();
-        }
-
-        decorView.getWindowVisibleDisplayFrame(rect);
-
-        return getResources().getDisplayMetrics().heightPixels - rect.bottom;
-    }
-
-    @Override
-    public void onAttachedToWindow() {
-        super.onAttachedToWindow();
-
-        getViewTreeObserver().addOnGlobalLayoutListener(layoutListener);
-
-        if (idOfViewToHide != -1) {
-            viewToHide = findViewById(idOfViewToHide);
-        }
-    }
-
-    @Override
-    public void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-
-        getViewTreeObserver().removeOnGlobalLayoutListener(layoutListener);
-
-        viewToHide = null;
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLinearLayout.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLinearLayout.java
new file mode 100644
index 000000000000..ecba364fff79
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardLinearLayout.java
@@ -0,0 +1,52 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.widget;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.support.annotation.Nullable;
+import android.support.design.widget.CoordinatorLayout;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.widget.LinearLayout;
+
+import org.mozilla.focus.R;
+
+/**
+ * A CoordinatorLayout implementation that resizes dynamically based on whether a keyboard is visible or not.
+ */
+public class ResizableKeyboardLinearLayout extends LinearLayout {
+    private final ResizableKeyboardViewDelegate delegate;
+
+    public ResizableKeyboardLinearLayout(Context context) {
+        this(context, null);
+    }
+
+    public ResizableKeyboardLinearLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ResizableKeyboardLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        delegate = new ResizableKeyboardViewDelegate(this, attrs);
+    }
+    @Override
+    public void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        delegate.onAttachedToWindow();
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        delegate.onDetachedFromWindow();
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardViewDelegate.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardViewDelegate.java
new file mode 100644
index 000000000000..d66854302c6b
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/ResizableKeyboardViewDelegate.java
@@ -0,0 +1,147 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.widget;
+
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ValueAnimator;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewTreeObserver;
+
+import org.mozilla.focus.R;
+
+/**
+ * A helper class to implement a ViewGroup that resizes dynamically (by adding padding to the bottom)
+ * based on whether a keyboard is visible or not.
+ *
+ * Implementation based on:
+ * https://github.com/mikepenz/MaterialDrawer/blob/master/library/src/main/java/com/mikepenz/materialdrawer/util/KeyboardUtil.java
+ *
+ * An optional viewToHideWhenActivated can be set: this is a View that will be hidden when the keyboard
+ * is showing. That can be useful for things like FABs that you don't need when someone is typing.
+ *
+ * A View using this delegate needs to forward the calls to onAttachedToWindow() and onDetachedFromWindow()
+ * to this class.
+ */
+/* package */ class ResizableKeyboardViewDelegate {
+    private final Rect rect;
+    private final View delegateView;
+    private View decorView;
+
+    private int idOfViewToHide;
+    private @Nullable View viewToHide;
+    private boolean shouldAnimate;
+    private boolean isAnimating;
+
+    private ViewTreeObserver.OnGlobalLayoutListener layoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
+        @Override
+        public void onGlobalLayout() {
+            if (isAnimating) {
+                return;
+            }
+
+            int difference = calculateDifferenceBetweenHeightAndUsableArea();
+
+            // If difference > 0, keyboard is showing.
+            // If difference =< 0, keyboard is not showing or is in multiview mode.
+            if (difference > 0) {
+                // Keyboard showing -> Set difference has bottom padding.
+                if (delegateView.getPaddingBottom() != difference) {
+                    updateBottomPadding(difference);
+
+                    if (viewToHide != null) {
+                        viewToHide.setVisibility(View.GONE);
+                    }
+                }
+            } else {
+                // Keyboard not showing -> Reset bottom padding.
+                if (delegateView.getPaddingBottom() != 0) {
+                    updateBottomPadding(0);
+
+                    if (viewToHide != null) {
+                        viewToHide.setVisibility(View.VISIBLE);
+                    }
+                }
+            }
+        }
+    };
+
+    /* package */ ResizableKeyboardViewDelegate(@NonNull View view, @NonNull AttributeSet attrs) {
+        this.delegateView = view;
+        this.rect = new Rect();
+
+        final TypedArray styleAttributeArray = view.getContext().getTheme().obtainStyledAttributes(
+                attrs,
+                R.styleable.ResizableKeyboardViewDelegate,
+                0, 0);
+
+        try {
+            idOfViewToHide = styleAttributeArray.getResourceId(R.styleable.ResizableKeyboardViewDelegate_viewToHideWhenActivated, -1);
+            shouldAnimate = styleAttributeArray.getBoolean(R.styleable.ResizableKeyboardViewDelegate_animate, false);
+        } finally {
+            styleAttributeArray.recycle();
+        }
+    }
+
+    /* package */ void onAttachedToWindow() {
+        delegateView.getViewTreeObserver().addOnGlobalLayoutListener(layoutListener);
+
+        if (idOfViewToHide != -1) {
+            viewToHide = delegateView.findViewById(idOfViewToHide);
+        }
+    }
+
+    /* package */ void onDetachedFromWindow() {
+        delegateView.getViewTreeObserver().removeOnGlobalLayoutListener(layoutListener);
+
+        viewToHide = null;
+    }
+
+    private void updateBottomPadding(int value) {
+        if (shouldAnimate) {
+            animateBottomPaddingTo(value);
+        } else {
+            delegateView.setPadding(0, 0, 0, value);
+        }
+    }
+
+    private void animateBottomPaddingTo(int value) {
+        isAnimating = true;
+
+        final ValueAnimator animator = ValueAnimator.ofInt(delegateView.getPaddingBottom(), value);
+        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator animation) {
+                delegateView.setPadding(0, 0, 0, (int) animation.getAnimatedValue());
+            }
+        });
+        animator.setDuration(200);
+        animator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                isAnimating = false;
+            }
+        });
+        animator.start();
+    }
+
+
+    private int calculateDifferenceBetweenHeightAndUsableArea() {
+        if (decorView == null) {
+            decorView = delegateView.getRootView();
+        }
+
+        decorView.getWindowVisibleDisplayFrame(rect);
+
+        return delegateView.getResources().getDisplayMetrics().heightPixels - rect.bottom;
+    }
+}
diff --git a/focus-android/app/src/main/res/layout/fragment_browser.xml b/focus-android/app/src/main/res/layout/fragment_browser.xml
index 8e61bfce5db2..6ba95963297d 100644
--- a/focus-android/app/src/main/res/layout/fragment_browser.xml
+++ b/focus-android/app/src/main/res/layout/fragment_browser.xml
@@ -19,7 +19,7 @@
             android:layout_height="81dp"
             android:background="@drawable/animated_background" />
 
-        <org.mozilla.focus.widget.ResizableKeyboardLayout
+        <org.mozilla.focus.widget.ResizableKeyboardCoordinatorLayout
             app:viewToHideWhenActivated="@+id/erase"
             android:layout_marginTop="25dp"
             android:id="@+id/main_content"
@@ -81,7 +81,7 @@
                 app:layout_behavior="org.mozilla.focus.widget.FloatingActionButtonBehavior"
                 android:contentDescription="@string/content_description_erase" />
 
-        </org.mozilla.focus.widget.ResizableKeyboardLayout>
+        </org.mozilla.focus.widget.ResizableKeyboardCoordinatorLayout>
     </FrameLayout>
 
     <FrameLayout
diff --git a/focus-android/app/src/main/res/layout/fragment_home.xml b/focus-android/app/src/main/res/layout/fragment_home.xml
deleted file mode 100644
index b8ea0571b055..000000000000
--- a/focus-android/app/src/main/res/layout/fragment_home.xml
+++ /dev/null
@@ -1,71 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="@drawable/background_home">
-
-    <FrameLayout
-        android:layout_width="match_parent"
-        android:layout_height="81dp"
-        android:paddingTop="25dp">
-
-        <ImageButton
-            android:id="@+id/menu"
-            android:layout_width="48dp"
-            android:layout_height="48dp"
-            android:layout_marginBottom="8dp"
-            android:layout_marginStart="8dp"
-            android:layout_marginTop="8dp"
-            android:padding="4dp"
-            android:src="@drawable/ic_menu"
-            android:layout_gravity="end|center_vertical"
-            android:contentDescription="@string/content_description_menu"
-            android:background="?android:attr/selectableItemBackgroundBorderless" />
-
-    </FrameLayout>
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:clipChildren="false"
-        android:gravity="center"
-        android:orientation="vertical">
-
-        <ImageView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:contentDescription="@string/app_name"
-            android:paddingBottom="30dp"
-            android:src="@drawable/wordmark" />
-
-        <TextView
-            android:id="@+id/fake_urlbar"
-            android:layout_width="match_parent"
-            android:layout_height="40dp"
-            android:layout_marginLeft="18dp"
-            android:layout_marginRight="18dp"
-            android:background="@drawable/urlbar_background"
-            android:gravity="center"
-            android:padding="8dp"
-            android:hint="@string/urlbar_hint"
-            android:textColorHint="#40ffffff"
-            android:textSize="15sp"
-            android:transitionName="urlbar" />
-
-        <TextView
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:gravity="center"
-            android:lineSpacingExtra="7sp"
-            android:paddingTop="30dp"
-            android:text="@string/teaser"
-            android:textColor="#eeeeee"
-            android:textSize="14sp" />
-
-    </LinearLayout>
-
-</FrameLayout>
\ No newline at end of file
diff --git a/focus-android/app/src/main/res/layout/fragment_urlinput.xml b/focus-android/app/src/main/res/layout/fragment_urlinput.xml
index 2c8e84ee2b4c..0d7f2c2e42aa 100644
--- a/focus-android/app/src/main/res/layout/fragment_urlinput.xml
+++ b/focus-android/app/src/main/res/layout/fragment_urlinput.xml
@@ -4,19 +4,47 @@
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
     android:id="@+id/background"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:clipChildren="false"
-    android:clipToPadding="false">
+    android:background="@drawable/background_home">
+
+    <org.mozilla.focus.widget.ResizableKeyboardLinearLayout
+        android:id="@+id/brand_background"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center"
+        android:layout_marginTop="81dp"
+        android:orientation="vertical"
+        app:animate="true">
+
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:contentDescription="@string/app_name"
+            android:paddingBottom="16dp"
+            android:src="@drawable/wordmark"
+            android:focusable="false" />
+
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:lineSpacingExtra="7sp"
+            android:text="@string/teaser"
+            android:textColor="#eeeeee"
+            android:textSize="14sp"
+            android:focusable="false" />
+
+    </org.mozilla.focus.widget.ResizableKeyboardLinearLayout>
 
     <FrameLayout
         android:layout_width="match_parent"
         android:layout_height="81dp"
         android:orientation="horizontal"
-        android:elevation="4dp"
-        android:clipChildren="false"
-        android:clipToPadding="false">
+        android:elevation="4dp">
 
         <View
             android:id="@+id/toolbar_background"
@@ -81,6 +109,22 @@
                     android:background="?android:attr/selectableItemBackgroundBorderless"
                     android:contentDescription="@string/content_description_clear_input" />
 
+                <ImageButton
+                    android:id="@+id/menu"
+                    android:layout_width="40dp"
+                    android:layout_height="40dp"
+                    android:src="@drawable/ic_menu"
+                    android:layout_marginTop="8dp"
+                    android:layout_marginBottom="8dp"
+                    android:paddingTop="8dp"
+                    android:paddingBottom="8dp"
+                    android:paddingEnd="8dp"
+                    android:paddingStart="8dp"
+                    android:layout_gravity="end"
+                    android:visibility="gone"
+                    android:background="?android:attr/selectableItemBackgroundBorderless"
+                    android:contentDescription="@string/content_description_menu" />
+
             </LinearLayout>
 
         </org.mozilla.focus.widget.HintFrameLayout>
diff --git a/focus-android/app/src/main/res/values/attrs.xml b/focus-android/app/src/main/res/values/attrs.xml
index 748af952a8b0..15155f3b34cc 100644
--- a/focus-android/app/src/main/res/values/attrs.xml
+++ b/focus-android/app/src/main/res/values/attrs.xml
@@ -3,8 +3,9 @@
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 <resources>
-   <declare-styleable name="ResizableKeyboardLayout">
+   <declare-styleable name="ResizableKeyboardViewDelegate">
        <attr name="viewToHideWhenActivated" format="reference" />
+       <attr name="animate" format="boolean" />
    </declare-styleable>
 
     <declare-styleable name="AnimatedProgressBar">
