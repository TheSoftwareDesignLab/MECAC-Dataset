diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index 9f18a96c7eda..e027cd6543f6 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -1226,12 +1226,6 @@ projects:
     path: components/tooling/lint
     publish: false
     upstream_dependencies: []
-  tooling-nimbus-gradle:
-    artifact-type: jar
-    description: A Gradle plugin to generate code for the Nimbus Feature API.
-    path: components/tooling/nimbus-gradle-plugin
-    publish: true
-    upstream_dependencies: []
   ui-autocomplete:
     description: A set of components to provide autocomplete functionality.
     path: components/ui/autocomplete
diff --git a/android-components/components/tooling/nimbus-gradle-plugin/README.md b/android-components/components/tooling/nimbus-gradle-plugin/README.md
deleted file mode 100644
index 181b14106e7c..000000000000
--- a/android-components/components/tooling/nimbus-gradle-plugin/README.md
+++ /dev/null
@@ -1,3 +0,0 @@
-This directory contains a Gradle plugin for that wraps Nimbus FML. It knows how to process feature manifest definitions and generate Kotlin bindings for the configured features.
-
-This is mostly a thin wrapper around the actual code generator whose implementation lives in [A-S Nimbus FML.](https://github.com/mozilla/application-services/tree/main/components/support/nimbus-fml).
diff --git a/android-components/components/tooling/nimbus-gradle-plugin/build.gradle b/android-components/components/tooling/nimbus-gradle-plugin/build.gradle
deleted file mode 100644
index 690a71a71d03..000000000000
--- a/android-components/components/tooling/nimbus-gradle-plugin/build.gradle
+++ /dev/null
@@ -1,128 +0,0 @@
-import org.apache.tools.ant.filters.ReplaceTokens
-
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-plugins {
-    id 'groovy'
-    id 'maven-publish'
-    id 'groovy-gradle-plugin'
-    id 'org.jetbrains.kotlin.jvm'
-}
-
-gradlePlugin {
-    plugins {
-        create("nimbusPlugins") {
-            id = "org.mozilla.components.nimbus-gradle-plugin"
-            implementationClass = "mozilla.components.tooling.nimbus.NimbusPlugin"
-        }
-    }
-}
-
-// This processes the files in the resources folder and moves them into the target folder. This
-// happens automatically, but has been updated to replace tokens in the resource files. It replaces
-// any tokens (values wrapped in `@`s) with the value for that key in the tokens object.
-processResources {
-    filter ReplaceTokens, tokens: [
-            'Versions.mozilla_appservices': Versions.mozilla_appservices
-    ]
-}
-
-dependencies {
-    implementation gradleApi()
-    implementation localGroovy()
-}
-
-tasks.register("lintRelease") {
-  doLast {
-    // Do nothing. We execute the same set of tasks for all our modules in parallel on taskcluster.
-    // This project doesn't have a lint task. To avoid special casing our automation I just added
-    // an empty lint task here.
-  }
-}
-
-tasks.register("assembleAndroidTest") {
-  doLast {
-    // Do nothing. Like the `lint` task above this is just a dummy task so that this module
-    // behaves like our others and we do not need to special case it in automation.
-  }
-}
-
-tasks.register("assembleRelease") {
-  doLast {
-    // Do nothing. Like the `lint` task above this is just a dummy task so that this module
-    // behaves like our others and we do not need to special case it in automation.
-  }
-}
-
-tasks.register("testRelease") {
-  doLast {
-    // Do nothing. Like the `lint` task above this is just a dummy task so that this module
-    // behaves like our others and we do not need to special case it in automation.
-  }
-}
-
-tasks.register("sourcesJar", Jar) {
-    classifier = 'sources'
-    from sourceSets.main.allSource
-}
-
-compileKotlin {
-    kotlinOptions {
-        jvmTarget = "11"
-    }
-}
-compileTestKotlin {
-    kotlinOptions {
-        jvmTarget = "11"
-    }
-}
-
-// Must match the implementation in publish.gradle
-static def getLocalPublicationTimestamp() {
-    def date = new Date()
-    return date.format('yyyyMMddHHmmss')
-}
-
-publishing {
-    publications {
-        mavenJava(MavenPublication) {
-            from components.java
-            artifact sourcesJar
-
-            pom {
-                groupId = config.componentsGroupId
-                artifactId = archivesBaseName
-                description = project.ext.description
-                version = config.componentsVersion + (project.hasProperty('local') ? '-local' + project.property('local') : '')
-
-                licenses {
-                    license {
-                        name = libLicense
-                        url = libLicenseUrl
-                    }
-                }
-
-                developers {
-                    developer {
-                        name = 'Mozilla Nimbus Team'
-                        email = 'nimbus-team@mozilla.com'
-                    }
-                }
-
-                scm {
-                    connection = libVcsUrl
-                    developerConnection = libVcsUrl
-                    url = libUrl
-                }
-            }
-        }
-    }
-
-    repositories {
-        maven {
-            url = "$buildDir/maven"
-        }
-    }
-}
diff --git a/android-components/components/tooling/nimbus-gradle-plugin/src/main/groovy/mozilla/components/tooling/nimbus/NimbusGradlePlugin.groovy b/android-components/components/tooling/nimbus-gradle-plugin/src/main/groovy/mozilla/components/tooling/nimbus/NimbusGradlePlugin.groovy
deleted file mode 100644
index 172970f70213..000000000000
--- a/android-components/components/tooling/nimbus-gradle-plugin/src/main/groovy/mozilla/components/tooling/nimbus/NimbusGradlePlugin.groovy
+++ /dev/null
@@ -1,462 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.tooling.nimbus
-
-import org.gradle.api.Task
-import org.gradle.api.provider.ListProperty
-
-import java.util.stream.Collectors
-import java.util.zip.ZipFile
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.provider.MapProperty
-import org.gradle.api.provider.Property
-import org.gradle.api.tasks.Exec
-
-abstract class NimbusPluginExtension {
-    /**
-     * The .fml.yaml manifest file.
-     *
-     * If absent this defaults to `nimbus.fml.yaml`.
-     * If relative, it is relative to the project root.
-     *
-     * @return
-     */
-    abstract Property<String> getManifestFile()
-
-    String getManifestFileActual(Project project) {
-        var filename = this.manifestFile.getOrNull() ?: "nimbus.fml.yaml"
-        return [project.rootDir, filename].join(File.separator)
-    }
-
-    /**
-     * The mapping between the build variant and the release channel.
-     *
-     * Variants that are not in this map are used literally.
-     * @return
-     */
-    abstract MapProperty<String, String> getChannels()
-
-    String getChannelActual(variant) {
-        Map<String, String> channels = this.channels.get() ?: new HashMap()
-        return channels.getOrDefault(variant.name, variant.name)
-    }
-
-    /**
-     * @deprecated
-     *
-     * The qualified class name which is the destination for the feature classes.
-     *
-     * Like classes in the `AndroidManifest.xml` if the class name starts with a `.`,
-     * the package is derived from the app's package name.
-     *
-     * If not present, it defaults to `.nimbus.MyNimbus`.
-     *
-     * @return
-     */
-    abstract Property<String> getDestinationClass()
-
-    /**
-     * The filename of the manifest ingested by Experimenter.
-     *
-     * If this is a relative name, it is taken to be relative to the project's root directory.
-     *
-     * If missing, this defaults to `.experimenter.json`.
-     * @return
-     */
-    abstract Property<String> getExperimenterManifest()
-
-    String getExperimenterManifestActual(Project project) {
-        var filename = this.experimenterManifest.getOrNull() ?: ".experimenter.json"
-        return [project.rootDir, filename].join(File.separator)
-    }
-
-    static File getAppServicesActual(Project project) {
-        if (!project.hasProperty("appServicesSrcDir")) {
-            return null
-        }
-        def asDir = project.property"appServicesSrcDir"
-        if (asDir == null || asDir.isBlank()) {
-            return null
-        }
-
-        def dir = new File([project.rootDir, asDir].join(File.separator))
-        if (dir.exists() && dir.isDirectory()) {
-            return dir
-        }
-
-        return null
-    }
-
-    /**
-     * The directory to which the generated files should be written.
-     *
-     * This defaults to the generated sources folder in the build directory.
-     *
-     * @return
-     */
-    abstract Property<String> getOutputDir()
-
-    String getOutputDirActual(Object variant, Project project) {
-        var outputDir = this.outputDir.getOrNull() ?: ["generated", "source", "nimbus", variant.name, "kotlin"].join(File.separator)
-        return [project.buildDir, outputDir].join(File.separator)
-    }
-
-    /**
-     * The file(s) containing the version(s)/ref(s)/location(s) for additional repositories.
-     *
-     * This defaults to an empty list.
-     *
-     * @return
-     */
-    abstract ListProperty<String> getRepoFiles()
-
-    List<String> getRepoFilesActual(Project project) {
-        var repoFiles = this.repoFiles.getOrNull() ?: new ArrayList<String>()
-        return repoFiles.stream().map(filename -> {
-            [project.rootDir, filename].join(File.separator)
-        }).collect(Collectors.toList())
-    }
-
-    /**
-     * The directory where downloaded files are or where they should be cached.
-     *
-     * This defaults to `null`, in which case no cache directory will be used.
-     *
-     * @return
-     */
-    abstract Property<String> getCacheDir()
-
-    String getCacheDirActual(Project project) {
-        var cacheDir = this.cacheDir.getOrNull()
-        if (cacheDir == null)
-            return null
-        return [project.rootDir, cacheDir].join(File.separator)
-    }
-}
-
-class NimbusPlugin implements Plugin<Project> {
-
-    public static final String APPSERVICES_FML_HOME = "components/support/nimbus-fml"
-
-    void apply(Project project) {
-        def extension = project.extensions.create('nimbus', NimbusPluginExtension)
-
-        if (project.hasProperty("android")) {
-            Collection<Task> oneTimeTasks = new ArrayList<>()
-            if (project.android.hasProperty('applicationVariants')) {
-                project.android.applicationVariants.all { variant ->
-                    setupVariantTasks(variant, project, extension, oneTimeTasks, false)
-                }
-            }
-
-            if (project.android.hasProperty('libraryVariants')) {
-                project.android.libraryVariants.all { variant ->
-                    setupVariantTasks(variant, project, extension, oneTimeTasks, true)
-                }
-            }
-        }
-    }
-
-    def setupAssembleNimbusTools(Project project, NimbusPluginExtension extension) {
-        return project.task("assembleNimbusTools") {
-            group "Nimbus"
-            description "Fetch the Nimbus FML tools from Application Services"
-            doLast {
-                def asDir = extension.getAppServicesActual(project)
-                if (asDir == null) {
-                    fetchNimbusBinaries(project)
-                }
-            }
-        }
-    }
-
-    // Try one or more hosts to download the given file.
-    // Return the hostname that successfully downloaded, or null if none succeeded.
-    static def tryDownload(File directory, String filename, String[] urlPrefixes) {
-        return urlPrefixes.find { prefix ->
-            def urlString = filename == null ? prefix : "$prefix/$filename"
-            try {
-                new URL(urlString).withInputStream { from ->
-                    new File(directory, filename).withOutputStream { out ->
-                        out << from;
-                    }
-                }
-                true
-            } catch (e) {
-                false
-            }
-        }
-    }
-
-    // Fetches and extracts the pre-built nimbus-fml binaries
-    def fetchNimbusBinaries(Project project) {
-        def fmlPath = new File(getFMLPath(project))
-        println("Checking fml binaries in $fmlPath")
-        if (fmlPath.exists()) {
-            println("nimbus-fml already exists at $fmlPath")
-            return
-        }
-
-        def rootDirectory = new File(getFMLRoot(project))
-        def archive = new File(rootDirectory, "nimbus-fml.zip")
-        ensureDirExists(rootDirectory)
-
-        if (!archive.exists()) {
-            println("Downloading archive to $archive")
-
-            Properties props = new Properties()
-            props.load(getClass().getResourceAsStream("/plugin.properties"))
-
-            def asVersion = props.get("mozilla_appservices")
-            println("Using application-services v$asVersion")
-            def successfulHost = tryDownload(archive.getParentFile(), archive.getName(),
-                    // â€¦the latest one from github.
-                    "https://github.com/mozilla/application-services/releases/download/v$asVersion",
-                    "https://github.com/mozilla/application-services/releases/latest/download"
-            )
-
-            if (successfulHost == null) {
-                throw java.io.IOException("Unable to download nimbus-fml tooling")
-            }
-
-            // We get the checksum, although don't do anything with it yet;
-            // Checking it here would be able to detect if the zip file was tampered with
-            // in transit between here and the server.
-            // It won't detect compromise of the CI server.
-            tryDownload(rootDirectory, "nimbus-fml.sha256", successfulHost)
-        }
-
-        def archOs = getArchOs()
-        println("Unzipping binary, looking for $archOs/nimbus-fml")
-        def zipFile = new ZipFile(archive)
-        zipFile.entries().findAll { entry ->
-            return !entry.directory && entry.name.contains(archOs)
-        }.each { entry ->
-            fmlPath.withOutputStream { out ->
-                def from = zipFile.getInputStream(entry)
-                out << from
-                from.close()
-            }
-
-            fmlPath.setExecutable(true)
-        }
-    }
-
-    /**
-     * The directory where nimbus-fml will live.
-     * We put it in a build directory so we refresh it on a clean build.
-     * @param project
-     * @return
-     */
-    static def getFMLRoot(Project project) {
-        return [project.buildDir, "bin", "nimbus"].join(File.separator)
-    }
-
-    static def getArchOs() {
-        String osPart
-        String os = System.getProperty("os.name").toLowerCase()
-        if (os.contains("win")) {
-            osPart = "pc-windows-gnu"
-        } else if (os.contains("nix") || os.contains("nux") || os.contains("aix")) {
-            osPart = "unknown-linux-musl"
-        } else if (os.contains("mac")) {
-            osPart = "apple-darwin"
-        } else {
-            osPart = "unknown"
-        }
-
-        String arch = System.getProperty("os.arch").toLowerCase()
-        String archPart
-        if (arch.contains("x86_64")) {
-            archPart = "x86_64"
-        } else if (arch.contains("amd64")) {
-            archPart = "x86_64"
-        } else if (arch.contains("aarch")) {
-            archPart = "aarch64"
-        } else {
-            archPart = "unknown"
-        }
-        println("OS and architecture detected as $os on $arch")
-        return "${archPart}-${osPart}"
-    }
-
-    static def getFMLPath(Project project) {
-        String os = System.getProperty("os.name").toLowerCase()
-        String binaryName = "nimbus-fml"
-        if (os.contains("win")) {
-            binaryName = "nimbus-fml.exe"
-        }
-        return [getFMLRoot(project), binaryName].join(File.separator)
-    }
-
-    def setupVariantTasks(variant, project, extension, oneTimeTasks, isLibrary = false) {
-        def task = setupNimbusFeatureTasks(variant, project, extension)
-
-        if (oneTimeTasks.isEmpty()) {
-            // The extension doesn't seem to be ready until now, so we have this complicated
-            // oneTimeTasks thing going on here. Ideally, we'd run this outside of this function.
-            def assembleToolsTask = setupAssembleNimbusTools(project, extension)
-            oneTimeTasks.add(assembleToolsTask)
-
-            if (!isLibrary) {
-                def experimenterTask = setupExperimenterTasks(project, extension, isLibrary)
-                experimenterTask.dependsOn(assembleToolsTask)
-                oneTimeTasks.add(experimenterTask)
-            }
-        }
-
-        // Generating experimenter manifest is cheap, for now.
-        // So we generate this every time.
-        // In the future, we should try and make this an incremental task.
-        oneTimeTasks.forEach {oneTimeTask ->
-            if (oneTimeTask != null) {
-                task.dependsOn(oneTimeTask)
-            }
-        }
-    }
-
-    def setupNimbusFeatureTasks(variant, project, extension) {
-        String channel = extension.getChannelActual(variant)
-        String inputFile = extension.getManifestFileActual(project)
-        String outputDir = extension.getOutputDirActual(variant, project)
-        String cacheDir = extension.getCacheDirActual(project)
-        List<String> repoFiles = extension.getRepoFilesActual(project)
-
-        var localAppServices = extension.getAppServicesActual(project)
-
-        var generateTask = project.task("nimbusFeatures${variant.name.capitalize()}", type: Exec) {
-            description = "Generate Kotlin data classes for Nimbus enabled features"
-            group = "Nimbus"
-
-            doFirst {
-                ensureDirExists(new File(outputDir))
-                if (cacheDir != null)
-                    ensureDirExists(new File(cacheDir))
-                println("Nimbus FML generating Kotlin")
-                println("manifest        $inputFile")
-                println("cache dir       $cacheDir")
-                println("repo file(s)    ${repoFiles.join(", ")}")
-                println("channel         $channel")
-            }
-
-            doLast {
-                println("outputFile    $outputDir")
-            }
-
-            if (localAppServices == null) {
-                workingDir project.rootDir
-                commandLine getFMLPath(project)
-            } else {
-                workingDir new File(localAppServices, APPSERVICES_FML_HOME )
-                commandLine "cargo"
-                args "run", "--"
-            }
-            args "generate"
-            args "--language", "kotlin"
-            args "--channel", channel
-            if (cacheDir != null)
-                args "--cache-dir", cacheDir
-            for (String file : repoFiles) {
-                args "--repo-file", file
-            }
-
-            args inputFile
-            args outputDir
-
-            println args
-        }
-
-        variant.registerJavaGeneratingTask(generateTask, new File(outputDir))
-
-        def generateSourcesTask = project.tasks.findByName("generate${variant.name.capitalize()}Sources")
-        if (generateSourcesTask != null) {
-            generateSourcesTask.dependsOn(generateTask)
-        } else {
-            def compileTask = project.tasks.findByName("compile${variant.name.capitalize()}Kotlin")
-            compileTask.dependsOn(generateTask)
-        }
-
-        return generateTask
-    }
-
-    def setupExperimenterTasks(project, extension, isLibrary = false) {
-        // Experimenter works at the application level, not the library/project
-        // level. The experimenter task for the application should gather up manifests
-        // from its constituent libraries.
-        if (isLibrary) {
-            return null
-        }
-
-        String inputFile = extension.getManifestFileActual(project)
-        String experimenterFile = extension.getExperimenterManifestActual(project)
-        String cacheDir = extension.getCacheDirActual(project)
-        List<String> repoFiles = extension.getRepoFilesActual(project)
-
-        var localAppServices = extension.getAppServicesActual(project)
-
-        return project.task("nimbusExperimenter", type: Exec) {
-            description = "Generate feature manifest for Nimbus server (Experimenter)"
-            group = "Nimbus"
-
-            doFirst {
-                if (cacheDir != null)
-                    ensureDirExists(new File(cacheDir))
-                println("Nimbus FML generating JSON")
-                println("manifest             $inputFile")
-                println("cache dir            $cacheDir")
-                println("repo file(s)         ${repoFiles.join()}")
-            }
-
-            doLast {
-                println("output    $experimenterFile")
-            }
-
-            if (localAppServices == null) {
-                workingDir project.rootDir
-                commandLine getFMLPath(project)
-            } else {
-                workingDir new File(localAppServices, APPSERVICES_FML_HOME)
-                commandLine "cargo"
-                args "run", "--"
-            }
-            args "generate-experimenter"
-            if (cacheDir != null)
-                args "--cache-dir", cacheDir
-            for (String file : repoFiles) {
-                args "--repo-file", file
-            }
-
-            args inputFile
-            args experimenterFile
-        }
-    }
-
-    static def ensureDirExists(File dir) {
-        if (dir.exists()) {
-            if (!dir.isDirectory()) {
-                dir.delete()
-                dir.mkdirs()
-            }
-        } else {
-            dir.mkdirs()
-        }
-    }
-
-    static def versionCompare(String versionA, String versionB) {
-        def a = versionA.split("\\.", 3)
-        def b = versionB.split("\\.", 3)
-        for (i in 0..<a.length) {
-            def na = Integer.parseInt(a[i])
-            def nb = Integer.parseInt(b[i])
-            if (na > nb) {
-                return 1
-            } else if (na < nb) {
-                return -1
-            }
-        }
-        return 0
-    }
-}
diff --git a/android-components/components/tooling/nimbus-gradle-plugin/src/main/resources/plugin.properties b/android-components/components/tooling/nimbus-gradle-plugin/src/main/resources/plugin.properties
deleted file mode 100644
index 426d3c16a60d..000000000000
--- a/android-components/components/tooling/nimbus-gradle-plugin/src/main/resources/plugin.properties
+++ /dev/null
@@ -1 +0,0 @@
-mozilla_appservices=@Versions.mozilla_appservices@
\ No newline at end of file
diff --git a/fenix/app/build.gradle b/fenix/app/build.gradle
index a3956f4100d0..5d3cf89067d6 100644
--- a/fenix/app/build.gradle
+++ b/fenix/app/build.gradle
@@ -433,14 +433,12 @@ android.applicationVariants.all { variant ->
 
 // Generate Kotlin code for the Fenix Glean metrics.
 apply plugin: "org.mozilla.telemetry.glean-gradle-plugin"
-apply plugin: "org.mozilla.components.nimbus-gradle-plugin"
+apply plugin: "org.mozilla.appservices.nimbus-gradle-plugin"
 
 nimbus {
     // The path to the Nimbus feature manifest file
     manifestFile = "nimbus.fml.yaml"
     // The fully qualified class name for the generated features.
-    // If the classname begins with a '.' this is taken as a suffix to the app's package name
-    destinationClass = ".nimbus.FxNimbus"
     // Map from the variant name to the channel as experimenter and nimbus understand it.
     // If nimbus's channels were accurately set up well for this project, then this
     // shouldn't be needed.
@@ -455,6 +453,7 @@ nimbus {
     // and used to inform experiment configuration.
     experimenterManifest = ".experimenter.yaml"
 }
+
 configurations {
     // There's an interaction between Gradle's resolution of dependencies with different types
     // (@jar, @aar) for `implementation` and `testImplementation` and with Android Studio's built-in
diff --git a/fenix/messaging.fml.yaml b/fenix/app/messaging.fml.yaml
similarity index 100%
rename from fenix/messaging.fml.yaml
rename to fenix/app/messaging.fml.yaml
diff --git a/fenix/nimbus.fml.yaml b/fenix/app/nimbus.fml.yaml
similarity index 99%
rename from fenix/nimbus.fml.yaml
rename to fenix/app/nimbus.fml.yaml
index f726c5b18652..54b80fadea93 100644
--- a/fenix/nimbus.fml.yaml
+++ b/fenix/app/nimbus.fml.yaml
@@ -10,7 +10,7 @@ channels:
   - nightly
   - developer
 includes:
-  - ./messaging.fml.yaml
+  - messaging.fml.yaml
 features:
   homescreen:
     description: The homescreen that the user goes to when they press home or new tab.
diff --git a/fenix/build.gradle b/fenix/build.gradle
index 9a2b612ea5b8..abcdcd0c4235 100644
--- a/fenix/build.gradle
+++ b/fenix/build.gradle
@@ -65,20 +65,7 @@ buildscript {
         classpath FenixDependencies.androidx_safeargs
         classpath FenixDependencies.osslicenses_plugin
         classpath "org.mozilla.telemetry:glean-gradle-plugin:${Versions.mozilla_glean}"
-        // NOTE: The Nimbus plugin needs to be refactored into a top-level plugin
-        // and consumed via includeBuild (using composite builds). This is a short-term
-        // workaround to consume the latest version of the Nimbus plugin matching the Focus version.
-        if (Config.readVersionFromFile().contains("a")) {
-            // Use the latest version of the plugin on the main branch (nightly).
-            classpath("org.mozilla.components:tooling-nimbus-gradle:latest.release")
-        } else {
-            // Use the latest version matching the major version of the branch (beta/release).
-            classpath("org.mozilla.components:tooling-nimbus-gradle") {
-                version {
-                    strictly("${Config.majorVersion()}.+")
-                }
-            }
-        }
+        classpath "org.mozilla.appservices:tooling-nimbus-gradle:${Versions.mozilla_appservices}"
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
diff --git a/focus-android/app/build.gradle b/focus-android/app/build.gradle
index d35e872d0a7d..9db7508aa861 100644
--- a/focus-android/app/build.gradle
+++ b/focus-android/app/build.gradle
@@ -182,14 +182,11 @@ tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
 // Generate Kotlin code for the Focus Glean metrics.
 // -------------------------------------------------------------------------------------------------
 apply plugin: "org.mozilla.telemetry.glean-gradle-plugin"
-apply plugin: "org.mozilla.components.nimbus-gradle-plugin"
+apply plugin: "org.mozilla.appservices.nimbus-gradle-plugin"
 
 nimbus {
     // The path to the Nimbus feature manifest file
     manifestFile = "nimbus.fml.yaml"
-    // The fully qualified class name for the generated features.
-    // If the classname begins with a '.' this is taken as a suffix to the app's package name
-    destinationClass = ".nimbus.FocusNimbus"
     // Map from the variant name to the channel as experimenter and nimbus understand it.
     // If nimbus's channels were accurately set up well for this project, then this
     // shouldn't be needed.
diff --git a/focus-android/nimbus.fml.yaml b/focus-android/app/nimbus.fml.yaml
similarity index 100%
rename from focus-android/nimbus.fml.yaml
rename to focus-android/app/nimbus.fml.yaml
diff --git a/focus-android/build.gradle b/focus-android/build.gradle
index 2ee63956802b..02078122246a 100644
--- a/focus-android/build.gradle
+++ b/focus-android/build.gradle
@@ -19,20 +19,7 @@ buildscript {
         classpath FocusDependencies.android_gradle_plugin
         classpath FocusDependencies.kotlin_gradle_plugin
         classpath "org.mozilla.telemetry:glean-gradle-plugin:${Versions.mozilla_glean}"
-        // NOTE: The Nimbus plugin needs to be refactored into a top-level plugin
-        // and consumed via includeBuild (using composite builds). This is a short-term
-        // workaround to consume the latest version of the Nimbus plugin matching the Focus version.
-        if (Config.readVersionFromFile().contains("a")) {
-            // Use the latest version of the plugin on the main branch (nightly).
-            classpath("org.mozilla.components:tooling-nimbus-gradle:latest.release")
-        } else {
-            // Use the latest version matching the major version of the branch (beta/release).
-            classpath("org.mozilla.components:tooling-nimbus-gradle") {
-                version {
-                    strictly("${Config.majorVersion()}.+")
-                }
-            }
-        }
+        classpath "org.mozilla.appservices:tooling-nimbus-gradle:${Versions.mozilla_appservices}"
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
diff --git a/taskcluster/ci/config.yml b/taskcluster/ci/config.yml
index 9b231d1f3630..34fbe3081223 100644
--- a/taskcluster/ci/config.yml
+++ b/taskcluster/ci/config.yml
@@ -141,7 +141,6 @@ treeherder:
         support-webextensions: support-webextensions
         tooling-detekt: tooling-detekt
         tooling-fetch-tests: tooling-fetch-tests
-        tooling-nimbus-gradle: tooling-nimbus-gradle
         tooling-lint: tooling-lint
         ui-autocomplete: ui-autocomplete
         ui-colors: ui-colors
