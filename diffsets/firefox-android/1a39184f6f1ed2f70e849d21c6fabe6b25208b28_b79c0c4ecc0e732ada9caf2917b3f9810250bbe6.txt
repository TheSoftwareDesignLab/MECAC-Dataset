diff --git a/focus-android/.gitignore b/focus-android/.gitignore
index b0cc6e44ef02..299136f55a63 100644
--- a/focus-android/.gitignore
+++ b/focus-android/.gitignore
@@ -42,3 +42,7 @@ captures/
 # Local checkout of localization files
 l10n-repo/
 
+# Compiled python code
+.pyc
+
+
diff --git a/focus-android/tools/l10n/android2po/README.md b/focus-android/tools/l10n/android2po/README.md
new file mode 100644
index 000000000000..ede8e30e6be1
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/README.md
@@ -0,0 +1,4 @@
+This is an imported and forked version of android2po with some modifications to import and export
+files that Pontoon can handle.
+
+https://github.com/miracle2k/android2po
diff --git a/focus-android/tools/l10n/android2po/a2po.py b/focus-android/tools/l10n/android2po/a2po.py
new file mode 100644
index 000000000000..ddd1836d6072
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/a2po.py
@@ -0,0 +1,4 @@
+import program
+
+if __name__ == "__main__":
+    program.run()
\ No newline at end of file
diff --git a/focus-android/tools/l10n/android2po/commands.py b/focus-android/tools/l10n/android2po/commands.py
new file mode 100644
index 000000000000..7c7bb3f24ef2
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/commands.py
@@ -0,0 +1,598 @@
+from __future__ import absolute_import
+
+import os
+import collections
+try:
+    from cStringIO import StringIO as BytesIO
+except ImportError:  # pragma: no cover
+    from io import BytesIO
+from lxml import etree
+from babel.messages import pofile, Catalog
+from termcolor import colored
+
+import convert
+from env import resolve_locale
+
+
+__all__ = ('CommandError', 'ExportCommand', 'ImportCommand', 'InitCommand',)
+
+
+class CommandError(Exception):
+    pass
+
+
+def read_catalog(filename, **kwargs):
+    """Helper to read a catalog from a .po file.
+    """
+    f = open(filename, 'r')
+    try:
+        return pofile.read_po(f, **kwargs)
+    finally:
+        f.close()
+
+
+def catalog2string(catalog, **kwargs):
+    """Helper that returns a babel message catalog as a string.
+
+    This is a simple shortcut around pofile.write_po().
+    """
+    sf = BytesIO()
+    pofile.write_po(sf, catalog, **kwargs)
+    return sf.getvalue().decode('utf-8')
+
+
+def xml2string(tree, action):
+    """Helper that returns a ``ResourceTree`` as an XML string.
+
+    TODO: It would be cool if this could try to recreate the formatting
+    of the original xml file.
+    """
+    ENCODING = 'utf-8'
+    dom = convert.write_xml(tree, warnfunc=action.message)
+    return etree.tostring(dom, xml_declaration=True,
+                          encoding=ENCODING, pretty_print=True).decode('utf-8')
+
+
+def read_xml(action, filename, **kw):
+    """Wrapper around the base read_xml() that pipes warnings
+    into the given action.
+
+    Also handles errors and returns false if the file is invalid.
+    """
+    try:
+        return convert.read_xml(filename, warnfunc=action.message, **kw)
+    except convert.InvalidResourceError as e:
+        action.done('failed')
+        action.message('Failed parsing "%s": %s' % (filename.rel, e), 'error')
+        return False
+
+
+def xml2po(env, action, *a, **kw):
+    """Wrapper around the base xml2po() that uses the filters configured
+    by the environment.
+    """
+    def xml_filter(name):
+        for filter in env.config.ignores:
+            if filter.match(name):
+                return True
+    kw['resfilter'] = xml_filter
+    if action:
+        kw['warnfunc'] = action.message
+    return convert.xml2po(*a, **kw)
+
+
+def po2xml(env, action, *a, **kw):
+    """Wrapper around the base po2xml() that uses the filters configured
+    by the environment.
+    """
+    def po_filter(message):
+        if env.config.ignore_fuzzy and message.fuzzy:
+            return True
+    kw['resfilter'] = po_filter
+    kw['warnfunc'] = action.message
+    return convert.po2xml(*a, **kw)
+
+
+def get_catalog_counts(catalog):
+    """Return 3-tuple (total count, number of translated strings, number
+    of fuzzy strings), based on the given gettext catalog.
+    """
+    # Make sure we don't count the header
+    return (len(catalog),
+            len([m for m in catalog if m.string and m.id]),
+            len([m for m in catalog if m.string and m.id and m.fuzzy]))
+
+
+def list_languages(source, env, writer):
+    """Return a list of languages (by simply calling the proper
+    environment method.
+
+    However, commands should use this helper rather than working
+    with the environment directly, as this outputs helpful
+    diagnostic messages along the way.
+    """
+    assert source in ('gettext', 'android')
+    languages = getattr(env,
+        'get_gettext_languages' if source=='gettext' else 'get_android_languages')()
+    lstr = ", ".join(map(str, languages))
+    writer.action('info',
+                  "Found %d language(s): %s" % (len(languages), lstr))
+    writer.message('List of languages was based on %s' % (
+        'the existing gettext catalogs' if source=='gettext'
+        else 'the existing Android resource directories'
+    ))
+    return languages
+
+
+def ensure_directories(cmd, path):
+    """Ensure that the given directory exists.
+    """
+    # Collect all the individual directories we need to create.
+    # Yes, I know about os.makedirs(), but I'd like to print out
+    # every single directory created.
+    needs_creating = []
+    while not path.exists():
+        if path in needs_creating:
+            break
+        needs_creating.append(path)
+        path = path.dir
+
+    for path in reversed(needs_creating):
+        cmd.w.action('mkdir', path)
+        os.mkdir(path)
+
+
+def write_file(cmd, filename, content, update=True, action=None,
+               ignore_exists=False):
+    """Helper that writes a file, while sending the proper actions
+    to the command's writer for stdout display of what's going on.
+
+    ``content`` may be a callable. This is useful if you would like
+    to exploit the ``update=False`` check this function provides,
+    rather than doing that yourself before bothering to generate the
+    content you want to write.
+
+    When ``update`` is not set, then if the file already exists we don't
+    change or overwrite it.
+
+    If a Writer.Action is given in ``action``, it will be used to print
+    out messages. Otherwise, a new action will be started using the
+    filename as the text. If ``action`` is ``False``, nothing will be
+    printed.
+    """
+    if action is None:
+        action = cmd.w.begin(filename)
+
+    if filename.exists():
+        if not update:
+            if ignore_exists:
+                # Downgade level of this message
+                action.update(severity='info')
+            action.done('exists')
+            return False
+        else:
+            old_hash = filename.hash()
+    else:
+        old_hash = None
+
+    ensure_directories(cmd, filename.dir)
+
+    f = open(filename, 'wb')
+    try:
+        if isinstance(content, collections.Callable):
+            content = content()
+        f.write(content.encode('utf-8'))
+        f.flush()
+    finally:
+        f.close()
+
+    if action is not False:
+        if old_hash is None:
+            action.done('created')
+        elif old_hash != filename.hash():
+            action.done('updated')
+        else:
+            # Note that this is merely for user information. We
+            # nevertheless wrote a new version of the file, we can't
+            # actually determine a change without generating the new
+            # version.
+            action.done('unchanged')
+    return True
+
+
+class Command(object):
+    """Abstract base command class.
+    """
+
+    def __init__(self, env, writer):
+        self.env = env
+        self.w = writer
+
+    @classmethod
+    def setup_arg_parser(cls, argparser):
+        """A command should register it's sub-arguments here with the
+        given argparser instance.
+        """
+
+    def execute(self):
+        raise NotImplementedError()
+
+
+class InitCommand(Command):
+    """The init command; to initialize new languages.
+    """
+
+    @classmethod
+    def setup_arg_parser(cls, parser):
+        parser.add_argument('language', nargs='*',
+                            help='Language code to initialize. If none given, all '+
+                            'languages lacking a .po file will be initialized.')
+
+    def make_or_get_template(self, kind, read_action=None, do_write=False,
+                             update=True):
+        """Return the .pot template file (as a Catalog) for the given kind.
+
+        If ``do_write`` is given, the template file will be saved in the
+        proper location. If ``update`` is ``False``, then an existing file
+        will not be overridden, however.
+
+        If ``do_write`` is disabled, then you need to given ``read_action``,
+        the action which needs the template. This is so we can fail the
+        proper action if generating the template goes wrong.
+
+        Once generated, the template will be cached as a class member,
+        and on subsequent access the cached version is returned.
+        """
+        # Implement caching - only generate the catalog the first time
+        # this function is called.
+        if not hasattr(self, '_template_catalogs'):
+            self._template_catalogs = {}
+
+        if kind in self._template_catalogs:
+            return self._template_catalogs[kind], False
+
+        # Only one, xor the other.
+        assert read_action or do_write and not (read_action and do_write)
+
+        template_pot = self.env.default.po(kind)
+        if do_write:
+            action = self.w.begin(template_pot)
+        else:
+            action = read_action
+
+        # Read the XML, bail out if that fails
+        xmldata = read_xml(action, self.env.default.xml(kind))
+        if xmldata is False:
+            return False, False
+
+        # Actually generate the catalog
+        template_catalog = xml2po(self.env, action, xmldata)
+        self._template_catalogs[kind] = template_catalog
+
+        # Write the catalog as a template to disk if necessary.
+        something_written = False
+        if do_write:
+            # Note that this is always rendered with "ignore_exists",
+            # i.e. we only log this action if we change the template.
+            if write_file(self, template_pot,
+                          content=lambda: catalog2string(template_catalog),
+                          action=action, ignore_exists=True, update=update):
+                something_written = True
+
+        return template_catalog, something_written
+
+    def generate_templates(self, update=True):
+        """Generate the template files.
+
+        Do this only if they are not disabled.
+        """
+        something_written = False
+        if not self.env.config.no_template:
+            for kind in self.env.xmlfiles:
+                _, write_happend = self.make_or_get_template(
+                    kind, do_write=True, update=update)
+                if write_happend:
+                    something_written = True
+        return something_written
+
+    def generate_po(self, target_po_file, default_data, action,
+                    language_data=None, language_data_files=None,
+                    update=True, ignore_exists=False):
+        """Helper to generate a .po file.
+
+        ``default_data`` is the collective data from the language neutral XML
+        files, and this is what the .po we generate will be based on.
+
+        ``language_data`` is collective data from the corresponding
+        language-specific XML files, in case such data is available.
+
+        ``language_data_files`` is the list of files that ``language_data``
+        is based upon. This is because in some cases multiple XML files
+        might need to be combined into one gettext catalog.
+
+        If ``update`` is not set than we will bail out early
+        if the file doesn't exist.
+        """
+        # This is a function so that it only will be run if write_file()
+        # actually needs it.
+        def make_catalog():
+            if language_data is not None:
+                action.message('Using existing translations from %s' % ", ".join(
+                    [l.rel for l in language_data_files]))
+                lang_catalog, unmatched = xml2po(self.env, action,
+                                                 default_data,
+                                                 language_data)
+                if unmatched:
+                    action.message("Existing translation XML files for this "
+                                   "language contains strings not found in the "
+                                   "default XML files: %s" % (", ".join(unmatched)))
+            else:
+                action.message('No corresponding XML exists, generating catalog '+
+                               'without translations')
+                lang_catalog = xml2po(self.env, action, default_data)
+
+            catalog = catalog2string(lang_catalog)
+
+            num_total, num_translated, _ = get_catalog_counts(lang_catalog)
+            action.message("%d strings processed, %d translated." % (
+                num_total, num_translated))
+            return catalog
+
+        return write_file(self, target_po_file, content=make_catalog,
+                          action=action, update=update,
+                          ignore_exists=ignore_exists)
+
+    def _iterate(self, language, require_translation=True):
+        """Yield 5-tuples in the form of: (
+            action object,
+            target .po file,
+            source xml data,
+            translated xml data,
+            list of files translated xml data was read from
+        )
+
+        This is implemeted as a separate iterator so that later on we can
+        also support a mechanism in which multiple xml files are stored in
+        one .po file, i.e. on export, multiple xml files needs to be able
+        to yield into a single .po target.
+        """
+        for kind in self.env.xmlfiles:
+            language_po = language.po(kind)
+            language_xml = language.xml(kind)
+
+            action = self.w.begin(language_po)
+
+            language_data = None
+            if not language_xml.exists():
+                if require_translation:
+                    # It's easily possible that say a arrays.xml only
+                    # exists in values/, but not in values-xx/.
+                    action.done('skipped')
+                    action.message('%s doesn\'t exist' % language_po.rel,
+                                   'warning')
+                    continue
+            else:
+                language_data = read_xml(action, language_xml, language=language)
+                if language_data == False:
+                    # File was invalid
+                    continue
+
+            template_data = read_xml(action, self.env.default.xml(kind))
+            if template_data is False:
+                # File was invalid
+                continue
+
+            yield action, language_po, template_data, language_data, [language_xml]
+
+    def yield_languages(self, env, source='android'):
+        if env.options.language:
+            for code in env.options.language:
+                if code == '-':
+                    # This allows specifying - to only build the template
+                    continue
+                language = resolve_locale(code, env)
+                if language:
+                    yield language
+
+        else:
+            for l in list_languages(source, env, self.w):
+                yield l
+
+    def execute(self):
+        env = self.env
+
+        # First, make sure the templates exist. This makes the "init"
+        # command everything needed to bootstrap.
+        # TODO: Test that this happens.
+        something_done = self.generate_templates(update=False)
+
+        # Only show [exists] actions if a specific language was requested.
+        show_exists = not bool(env.options.language)
+
+        for language in self.yield_languages(env):
+            # For each language, generate a .po file. In case a language
+            # already exists (that is, it's xml files exist, use the
+            # existing translations for the new gettext catalog).
+            for (action,
+                 target_po,
+                 template_data,
+                 lang_data,
+                 lang_files) in self._iterate(language, require_translation=False):
+                if self.generate_po(target_po, template_data, action,
+                                    lang_data, lang_files,
+                                    update=False,
+                                    ignore_exists=show_exists):
+                    something_done = True
+
+            # Also for each language, generate the empty .xml resource files.
+            # This will make us pick up the language on subsequent runs.
+            for kind in self.env.xmlfiles:
+                if write_file(self, language.xml(kind),
+                              """<?xml version='1.0' encoding='utf-8'?>\n<resources>\n</resources>""",
+                              update=False, ignore_exists=show_exists):
+                    something_done = True
+
+        if not something_done:
+            self.w.action('info', 'Nothing to do.', 'default')
+
+
+class ExportCommand(InitCommand):
+    """The export command.
+
+    Inherits from ``InitCommand`` to be able to use ``generate_templates``.
+    Both commands need to write the templates.
+    """
+
+    @classmethod
+    def setup_arg_parser(cls, parser):
+        parser.add_argument(
+            'language', nargs='*',
+            help='Language code to export. If not given, all '+
+                 'initialized languages will be exported.')
+
+    def execute(self):
+        env = self.env
+        w = self.w
+
+        # First, always update the template files. Note that even if
+        # template generation is disabled, we still need to have the
+        # catalogs at least in memory for the updating process later on.
+        #
+        # TODO: Do we really want to regenerate the templates every
+        # time, or should the user be able to set fixed meta data, and
+        # we simply merge subsequent updates in?
+        self.generate_templates()
+
+        initial_warning = False
+
+        for language in self.yield_languages(env, 'gettext'):
+            for kind in self.env.xmlfiles:
+                target_po = language.po(kind)
+                if not target_po.exists():
+                    w.action('skipped', target_po)
+                    w.message('File does not exist yet. '+
+                              'Use the \'init\' command.')
+                    initial_warning = True
+                    continue
+
+                action = w.begin(target_po)
+                # If we do not provide a locale, babel will consider this
+                # catalog a template and always write out the default
+                # header. It seemingly does not consider the "Language"
+                # header inside the file at all, and indeed deletes it.
+                # TODO: It deletes all headers it doesn't know, and
+                # overrides others. That sucks.
+                lang_catalog = read_catalog(target_po, locale=language.code)
+                catalog, _ = self.make_or_get_template(kind, action)
+                if catalog is None:
+                    # Something went wrong parsing the catalog
+                    continue
+                lang_catalog.update(catalog,
+                                    no_fuzzy_matching=not env.config.enable_fuzzy_matching)
+
+                # Making monkey patching: getting values from obsolete values and
+                # setting them as the new ones while marking message fuzzy
+                for message in lang_catalog:
+                    for key in lang_catalog.obsolete:
+                        if key == "":
+                            continue
+                        if message.context == key[1]:
+                            obsolete_message = lang_catalog.obsolete[key]
+                            message.string = obsolete_message.string
+                            message.flags.add('fuzzy')
+                # Clearing obsolete messages
+                if env.config.clear_obsolete:
+                    lang_catalog.obsolete.clear()
+
+                # Set the correct plural forms.
+                current_plurals = lang_catalog.plural_forms
+                convert.set_catalog_plural_forms(lang_catalog, language)
+                if lang_catalog.plural_forms != current_plurals:
+                    action.message(
+                        'The Plural-Forms header of this catalog '
+                        'has been updated to what android2po '
+                        'requires for plurals support. See the '
+                        'README for more information.', 'warning')
+
+                # TODO: Should we include previous?
+                write_file(self, target_po,
+                           catalog2string(lang_catalog, include_previous=False),
+                           action=action)
+
+        if initial_warning:
+            print("")
+            print(colored("Warning: One or more .po files were skipped "+\
+                  "because they did not exist yet. Use the 'init' command "+\
+                  "to generate them for the first time.",
+                  color='magenta', attrs=['bold',]))
+
+
+class ImportCommand(Command):
+    """The import command.
+    """
+
+    def process(self, language):
+        """Process importing the given language.
+        """
+
+        # In order to implement the --require-min-complete option, we need
+        # to first determine the translation status across all .po catalogs
+        # for this language. We can keep the catalogs in memory because we
+        # will need them later anyway.
+        catalogs = {}
+        count_total = 0
+        count_translated = 0
+        for kind in self.env.xmlfiles:
+            language_po = language.po(kind)
+            if not language_po.exists():
+                continue
+            catalogs[kind] = catalog = read_catalog(language_po)
+            catalog.language = language
+            ntotal, ntrans, nfuzzy = get_catalog_counts(catalog)
+            count_total += ntotal
+            count_translated += ntrans
+            if self.env.config.ignore_fuzzy:
+                count_translated -= nfuzzy
+
+        # Compare our count with what is required, if anything.
+        skip_due_to_incomplete = False
+        min_required = self.env.config.min_completion
+        if count_total == 0:
+            actual_completeness = 1
+        else:
+            actual_completeness = count_translated / float(count_total)
+        if min_required:
+            skip_due_to_incomplete = actual_completeness < min_required
+
+        # Now loop through the list of target files, and either create
+        # them, or print a status message for each indicating that they
+        # were skipped.
+        for kind in self.env.xmlfiles:
+            language_xml = language.xml(kind)
+            language_po = language.po(kind)
+            action = self.w.begin(language_xml)
+
+            if skip_due_to_incomplete:
+                # TODO: Creating a catalog object here is kind of clunky.
+                # Idially, we'd refactor convert.py so that we can use a
+                # dict to represent a resource XML file.
+                xmldata = po2xml(self.env, action, Catalog(locale=language.code))
+                write_file(self, language_xml, xml2string(xmldata, action),
+                           action=False)
+                action.done('skipped', status=('%s catalogs aren\'t '
+                                               'complete enough - %.2f done' % (
+                                                   language.code,
+                                                   actual_completeness)))
+                continue
+
+            if not language_po.exists():
+                action.done('skipped')
+                self.w.message('%s doesn\'t exist' % language_po.rel, 'warning')
+                continue
+
+            content = xml2string(po2xml(self.env, action, catalogs[kind]), action)
+            write_file(self, language_xml, content, action=action)
+
+    def execute(self):
+        for language in list_languages('gettext', self.env, self.w):
+            self.process(language)
diff --git a/focus-android/tools/l10n/android2po/config.py b/focus-android/tools/l10n/android2po/config.py
new file mode 100644
index 000000000000..59739c22509b
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/config.py
@@ -0,0 +1,153 @@
+from os import path
+import argparse
+
+
+__all__ = ('Config',)
+
+
+def percentage(string):
+    errstr = "must be a float between 0 and 1, not %r" % string
+    try:
+        value = float(string)
+    except ValueError:
+        raise argparse.ArgumentTypeError(errstr)
+    if value < 0 or value > 1:
+        raise argparse.ArgumentTypeError(errstr)
+    return value
+
+
+class Config(object):
+    """Defines all the options supported by our configuration system.
+    """
+    OPTIONS = (
+        {'name': 'android',
+         'help': 'Android resource directory ($PROJECT/res by default)',
+         'dest': 'resource_dir',
+         'kwargs': {'metavar': 'DIR',}
+         # No default, and will not actually be stored on the config object.
+        },
+        {'name': 'gettext',
+         'help': 'directory containing the .po files ($PROJECT/locale by default)',
+         'dest': 'gettext_dir',
+         'kwargs': {'metavar': 'DIR',}
+         # No default, and will not actually be stored on the config object.
+        },
+        {'name': 'groups',
+         'help': 'process the given default XML files (for example '+
+                 '"strings arrays"); by default all files which contain '+
+                 'string resources will be used',
+         'dest': 'groups',
+         'default': [],
+         'kwargs': {'nargs': '+', 'metavar': 'GROUP'}
+        },
+        {'name': 'no-template',
+         'help': 'do not generate a .pot template file on export',
+         'dest': 'no_template',
+         'default': False,
+         'kwargs': {'action': 'store_true',}
+        },
+        {'name': 'template',
+         'help': 'filename to use for the .pot file(s); may contain the '+
+                 '%%(domain)s and %%(group)s variables',
+         'dest': 'template_name',
+         'default': '',
+         'kwargs': {'metavar': 'NAME',}
+        },
+        {'name': 'ignore',
+         'help': 'ignore the given message; can be given multiple times; '+
+                 'regular expressions can be used if putting the value '+
+                 'inside slashes (/match/)',
+         'dest': 'ignores',
+         'default': [],
+         'kwargs': {'metavar': 'MATCH', 'action': 'append', 'nargs': '+'}
+        },
+        {'name': 'ignore-fuzzy',
+         'help': 'during import, ignore messages marked as fuzzy in .po files',
+         'dest': 'ignore_fuzzy',
+         'default': False,
+         'kwargs': {'action': 'store_true',}
+        },
+        {'name': 'require-min-complete',
+         'help': 'ignore a language\'s .po file(s) completely if there '+
+                 'aren\'t at least the given percentage of translations',
+         'dest': 'min_completion',
+         'default': 0,
+         'kwargs': {'metavar': 'FLOAT', 'type': percentage}
+        },
+        {'name': 'domain',
+         'help': 'gettext po domain to use, affects the .po filenames',
+         'dest': 'domain',
+         'default': None,
+        },
+        {'name': 'layout',
+         'help': 'how and where .po files are stored; may be "default", '+
+                  '"gnu", or a custom path using the variables %%(locale)s '+
+                  '%%(domain)s and optionally %%(group)s. E.g., '+
+                  '"%%(group)s-%%(locale)s.po" will write to "strings-es.po" '+
+                  'for Spanish in strings.xml.',
+         'dest': 'layout',
+         'default': 'default',
+        },
+        {
+            'name': 'enable-fuzzy-matching',
+            'help': 'enable fuzzy matching during export command. When it is enabled ' +
+                    'android2po will automatically add translations for new strings. ' +
+                    'by default this behaviour is turned off',
+            'dest': 'enable_fuzzy_matching',
+            'default': False,
+            'kwargs': {'action': 'store_true', }
+        },
+        {
+            'name': 'clear-obsolete',
+            'help': 'during export do not add obsolete strings to the generated .po files',
+            'dest': 'clear_obsolete',
+            'default': True,
+            'kwargs': {'action': 'store_true', }
+        }
+    )
+
+    def __init__(self):
+        """Initialize all configuration values with a default.
+
+        It is important that we do this here manually, rather than relying
+        on the "default" mechanism of argparse, because we have multiple
+        potential congiguration sources (command line, config file), and
+        we don't want defaults to override actual values.
+
+        The attributes we define here are also used to determine
+        which command line options passed should be assigned to this
+        object, and which should be exposed via a separate ``options``
+        namespace.
+        """
+        for optdef in self.OPTIONS:
+            if 'default' in optdef:
+                setattr(self, optdef['dest'], optdef['default'])
+
+    @classmethod
+    def setup_arguments(cls, parser):
+        """Setup our configuration values as arguments in the ``argparse``
+        object in ``parser``.
+        """
+        for optdef in cls.OPTIONS:
+            names = ('--%s' % optdef.get('name'),)
+            kwargs = {
+                'help': optdef.get('help', None),
+                'dest': optdef.get('dest', None),
+                # We handle defaults ourselves. This is actually important,
+                # or defaults from one config source may override valid
+                # values from another.
+                'default': argparse.SUPPRESS,
+            }
+            kwargs.update(optdef.get('kwargs', {}))
+            parser.add_argument(*names, **kwargs)
+
+    @classmethod
+    def rebase_paths(cls, config, base_path):
+        """Make those config values that are paths relative to
+        ``base_path``, because by default, paths are relative to
+        the current working directory.
+        """
+        for name in ('gettext_dir', 'resource_dir'):
+            value = getattr(config, name, None)
+            if value is not None:
+                setattr(config, name, path.normpath(path.join(base_path, value)))
diff --git a/focus-android/tools/l10n/android2po/convert.py b/focus-android/tools/l10n/android2po/convert.py
new file mode 100644
index 000000000000..872463bfddbe
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/convert.py
@@ -0,0 +1,899 @@
+"""This module does the hard work of converting.
+
+It uses a simply dict-based memory representation of Android XML string
+resource files, via the ``ResourceTree`` class. The .po files are
+represented in memory via Babel's ``Catalog`` class.
+
+The process thus is:
+
+    read_xml() -> ResourceTree -> xml2po() -> Catalog -> po2xml
+    -> ResourceTree -> write_xml()
+
+"""
+
+from __future__ import unicode_literals
+
+from itertools import chain
+from collections import namedtuple
+from lxml import etree
+from babel.messages import Catalog
+from babel.plural import _plural_tags as PLURAL_TAGS
+try:
+    from collections import OrderedDict
+except ImportError:  # pragma: no cover
+    from ordereddict import OrderedDict
+
+__all__ = ('xml2po', 'po2xml', 'read_xml', 'write_xml',
+           'set_catalog_plural_forms', 'InvalidResourceError',)
+
+
+class InvalidResourceError(Exception):
+    pass
+
+
+class UnsupportedResourceError(Exception):
+    """A resource in a XML file can't be processed.
+    """
+    def __init__(self, reason):
+        self.reason = reason
+
+
+WHITESPACE = ' \n\t'     # Whitespace that we collapse
+EOF = None
+
+
+# Some AOSP projects like to include xliff:* tags to annotate
+# strings with more information for translators. This is actually harder
+# to support than it might look like: We want the translators to see at
+# least a tag called "xliff", not the namespace URIs, but we currently
+# don't have a way to define namespaces in the .po files (comments?),
+# so in order to properly generate an XML on import, we can only deal
+# with a fixed list of namespace that we now about.
+KNOWN_NAMESPACES = {
+    'urn:oasis:names:tc:xliff:document:1.2': 'xliff',
+}
+
+
+# The methods here sometimes need to notify the caller about warnings
+# processing on; this is why they all take a ``warn_func`` argument.
+# By default, if no warnfunc is passed, this dummy will be used.
+dummy_warn = lambda message, severity=None: None
+
+
+# These classes are used for the memory representation of an Android
+# string resource file. ``ResourceTree`` holds ``StringArray``,
+# ``Plurals`` and ``Translation`` objects, and ``StringArray`` and
+# ``Plurals`` can also hold ``Translation`` objects.
+class ResourceTree(OrderedDict):
+    language = None
+    def __init__(self, language=None):
+        OrderedDict.__init__(self)
+        self.language = language
+class StringArray(list): pass
+class Plurals(dict): pass
+Translation = namedtuple('Translation', ['text', 'comments', 'formatted'])
+
+
+def get_element_text(tag, name, warnfunc=dummy_warn):
+    """Return a tuple of the contents of the lxml ``element`` with the
+    Android specific stuff decoded and whether the text includes
+    formatting codes.
+
+    "Contents" isn't just the text; it handles nested HTML tags as well.
+    """
+
+    def convert_text(text):
+        """This is called for every distinct block of text, as they
+        are separated by tags.
+
+        It handles most of the Android syntax rules: quoting, escaping,
+        collapsing duplicate whitespace etc.
+        """
+        # '<' and '>' as literal characters inside a text need to be
+        # escaped; this is because we need to differentiate them to
+        # actual tags inside a resource string which we write to the
+        # .po file as literal '<', '>' characters. As a result, if the
+        # user puts &lt; inside his Android resource file, this is how
+        # it will end up in the .po file as well.
+        # We only do this for '<' and '<' right now, which is of course
+        # a hack. We'd need to process at least &amp; as well, because
+        # right now '&lt;' and '&amp;lt;' both generate the same on
+        # import. However, if we were to do that, a simple non-HTML
+        # text like "FAQ & Help" would end up us "FAQ &amp; Help" in
+        # the .po - not particularly nice.
+        # TODO: I can see two approaches to solve this: Handle things
+        # differently depending on whether there are nested tags. We'd
+        # be able to handle both '&amp;lt;' in a HTML string and output
+        # a nice & character in a plaintext string.
+        # Option 2: It might be possible to note the type of encoding
+        # we did in a .po comment. That would even allow us to present
+        # a string containing tags encoded using entities (but not actual
+        # nested XML tags) using plain < and > characters in the .po
+        # file. Instead of a comment, we could change the import code
+        # to require a look at the original resource xml file to
+        # determine which kind of encoding was done.
+        text = text.replace('<', '&lt;')
+        text = text.replace('>', "&gt;")
+
+        # We need to collapse multiple whitespace while paying
+        # attention to Android's quoting and escaping.
+        space_count = 0
+        active_quote = False
+        active_percent = False
+        active_escape = False
+        formatted = False
+        i = 0
+        text = list(text) + [EOF]
+        while i < len(text):
+            c = text[i]
+
+            # Handle whitespace collapsing
+            if c is not EOF and c in WHITESPACE:
+                space_count += 1
+            elif space_count > 1:
+                # Remove duplicate whitespace; Pay attention: We
+                # don't do this if we are currently inside a quote,
+                # except for one special case: If we have unbalanced
+                # quotes, e.g. we reach eof while a quote is still
+                # open, we *do* collapse that trailing part; this is
+                # how Android does it, for some reason.
+                if not active_quote or c is EOF:
+                    # Replace by a single space, will get rid of
+                    # non-significant newlines/tabs etc.
+                    text[i-space_count : i] = ' '
+                    i -= space_count - 1
+                space_count = 0
+            elif space_count == 1:
+                # At this point we have a single whitespace character,
+                # but it might be a newline or tab. If we write this
+                # kind of insignificant whitespace into the .po file,
+                # it will be considered significant on import. So,
+                # make sure that this kind of whitespace is always a
+                # standard space.
+                text[i-1] = ' '
+                space_count = 0
+            else:
+                space_count = 0
+
+            # Handle quotes
+            if c == '"' and not active_escape:
+                active_quote = not active_quote
+                del text[i]
+                i -= 1
+
+            # If the string is run through a formatter, it will have
+            # percentage signs for String.format
+            if c == '%' and not active_escape:
+                active_percent = not active_percent
+            elif not active_escape and active_percent:
+                formatted = True
+                active_percent = False
+
+            # Handle escapes
+            if c == '\\':
+                if not active_escape:
+                    active_escape = True
+                else:
+                    # A double-backslash represents a single;
+                    # simply deleting the current char will do.
+                    del text[i]
+                    i -= 1
+                    active_escape = False
+            else:
+                if active_escape:
+                    # Handle the limited amount of escape codes
+                    # that we support.
+                    # TODO: What about \r, or \r\n?
+                    if c is EOF:
+                        # Basically like any other char, but put
+                        # this first so we can use the ``in`` operator
+                        # in the clauses below without issue.
+                        pass
+                    elif c == 'n':
+                        text[i-1 : i+1] = '\n'  # an actual newline
+                        i -= 1
+                    elif c == 't':
+                        text[i-1 : i+1] = '\t'  # an actual tab
+                        i -= 1
+                    elif c in '"\'@':
+                        text[i-1 : i] = ''        # remove the backslash
+                        i -= 1
+                    elif c == 'u':
+                        # Unicode sequence. Android is nice enough to deal
+                        # with those in a way which let's us just capture
+                        # the next 4 characters and raise an error if they
+                        # are not valid (rather than having to use a new
+                        # state to parse the unicode sequence).
+                        # Exception: In case we are at the end of the
+                        # string, we support incomplete sequences by
+                        # prefixing the missing digits with zeros.
+                        # Note: max(len()) is needed in the slice due to
+                        # trailing ``None`` element.
+                        max_slice = min(i+5, len(text)-1)
+                        codepoint_str = "".join(text[i+1 : max_slice])
+                        if len(codepoint_str) < 4:
+                            codepoint_str = "0" * (4-len(codepoint_str)) + codepoint_str
+                        print(repr(codepoint_str))
+                        try:
+                            # We can't trust int() to raise a ValueError,
+                            # it will ignore leading/trailing whitespace.
+                            if not codepoint_str.isalnum():
+                                raise ValueError(codepoint_str)
+                            codepoint = chr(int(codepoint_str, 16))
+                        except ValueError:
+                            raise UnsupportedResourceError('bad unicode escape sequence')
+
+                        text[i-1 : max_slice] = codepoint
+                        i -= 1
+                    else:
+                        # All others, remove, like Android does as well.
+                        # However, Android does so silently, we show a
+                        # warning so the dev can fix the problem.
+                        warnfunc(('Resource "%s": removing unsupported '
+                                  'escape sequence "%s"') % (
+                                    name, "".join(text[i-1 : i+1])), 'warning')
+                        text[i-1 : i+1] = ''
+                        i -= 1
+                    active_escape = False
+
+            i += 1
+
+        # Join the string together again, but w/o EOF marker
+        return "".join(text[:-1]), formatted
+
+    def get_tag_name(elem):
+        """For tags without a namespace, returns ("tag", None).
+        For tags with a known-namespace, returns ("prefix:tag", None).
+        For tags with an unknown-namespace, returns ("tag", ("prefix", "ns"))
+        """
+        if elem.prefix:
+            namespace = elem.nsmap[elem.prefix]
+            raw_name = elem.tag[elem.tag.index('}')+1:]
+            if namespace in KNOWN_NAMESPACES:
+                return "%s:%s" % (KNOWN_NAMESPACES[namespace], raw_name), None
+            return "%s:%s" % (elem.prefix, raw_name), (elem.prefix, namespace)
+        return elem.tag, None
+
+    # We need to recreate the contents of this tag; this is more
+    # complicated than you might expect; firstly, there is nothing
+    # built into lxml (or any other parser I have seen for that
+    # matter). While it is possible to use ``etree.tostring``
+    # to render this tag and it's children, this still would give
+    # us valid XML code; when in fact we want to decode everything
+    # XML (including entities), *except* tags. Much more than that
+    # though, the processing rules the Android xml format needs
+    # require custom processing anyway.
+    value = ""
+    formatted = False
+    for ev, elem  in etree.iterwalk(tag, events=('start', 'end',)):
+        is_root = elem == tag
+        has_children = len(tag) > 0
+        if ev == 'start':
+            if not is_root:
+                # Take care of the tag name, namespace and attributes.
+                # Since we can't store namespace urls in a .po file, dealing
+                # with (unknown) namespaces requires generating a xmlns
+                # attribute.
+                # TODO: We are currently not dealing correctly with
+                # attribute values that need escaping.
+                tag_name, to_declare = get_tag_name(elem)
+                params = ["%s=\"%s\"" % (k, v) for k, v in list(elem.attrib.items())]
+                if to_declare:
+                    name, url = to_declare
+                    params.append('xmlns:%s="%s"' % (name, url))
+                params_str = " %s" % " ".join(params) if params else ""
+                value += "<%s%s>" % (tag_name, params_str)
+            if elem.text is not None:
+                t = elem.text
+                # Leading/Trailing whitespace is removed completely
+                # ONLY if there are no nested tags. Handle this before
+                # calling ``convert_text``, so that whitespace
+                # protecting quotes can still be considered.
+                if is_root and not has_children and len(tag) == 0:
+                    t = t.strip(WHITESPACE)
+
+                # Resources that start with @ reference other resources.
+                # While we aren't particularily interested in converting
+                # those, we also can't do it right now because we wouldn't
+                # be able to differ between literal @ characters and the
+                # reference syntax during import.
+                #
+                # While it may seem a bit early to deal with this here, we
+                # have no choice, because the caller needs *some* way of
+                # differentating between an escaped literal '@' and this
+                # kind of resource-reference. Since we unescape literals,
+                # we need to do something with the reference-@.
+                if is_root and not has_children and t and t[0] == '@':
+                    raise UnsupportedResourceError(
+                        'resource references (%s) are not supported' % t)
+
+                converted_value, elem_formatted = convert_text(t)
+                if elem_formatted:
+                    formatted = True
+                value += converted_value
+        elif ev == 'end':
+            # The closing root tag has no info for us at all.
+            if not is_root:
+                tag_name, _ = get_tag_name(elem)
+                value += "</%s>" % tag_name
+                if elem.tail is not None:
+                    converted_value, elem_formatted = convert_text(elem.tail)
+                    if elem_formatted:
+                        formatted = True
+                    value += converted_value
+
+    # Babel can't handle empty msgids, even when using a unique context;
+    # not sure if this is a general gettext limitation, but it's not
+    # unlikely that other tools would have problems, so it's for the better
+    # in any case.
+    if value == '':
+        raise UnsupportedResourceError('empty resources not supported')
+    return value, formatted
+
+
+def read_xml(xml_file, language=None, warnfunc=dummy_warn):
+    """Load all resource names from an Android strings.xml resource file.
+
+    The result is a ``ResourceTree`` instance.
+    """
+    result = ResourceTree(language)
+    comment = []
+
+    try:
+        doc = etree.parse(xml_file)
+    except etree.XMLSyntaxError as e:
+        raise InvalidResourceError(e)
+
+    for tag in doc.getroot():
+        # Collect comments so we can add them to the element that they precede.
+        if tag.tag == etree.Comment:
+            comment.append(tag.text)
+            continue
+
+        # Ignore elements we cannot or should not process
+        if 'name' not in tag.attrib:
+            comment = []
+            continue
+        if tag.attrib.get('translatable') == 'false':
+            comment = []
+            continue
+
+        name = tag.attrib['name']
+        if name in result:
+            warnfunc('Duplicate resource id found: %s, ignoring.' % name,
+                     'warning')
+            comment = []
+            continue
+
+        if tag.tag == 'string':
+            try:
+                text, formatted = get_element_text(tag, name, warnfunc)
+            except UnsupportedResourceError as e:
+                warnfunc('"%s" has been skipped, reason: %s' % (
+                    name, e.reason), 'info')
+            else:
+                translation = Translation(text, comment, formatted)
+                result[name] = translation
+
+        elif tag.tag == 'string-array':
+            result[name] = StringArray()
+            for child in tag.findall('item'):
+                try:
+                    text, formatted = get_element_text(child, name, warnfunc)
+                except UnsupportedResourceError as e:
+                    # XXX: We currently can't handle this, because even if
+                    # we write out a .po file with the proper array
+                    # indices, and items like this one missing, during
+                    # import we still need to write out those items that
+                    # we have now skipped, since the Android format is only
+                    # a simple list of items, i.e. we need to specify the
+                    # fully array, and can't override individual items on
+                    # a per-translation basis.
+                    #
+                    # To fix this, we have two options: Either we support
+                    # annotating gettext messages, in which case we could
+                    # indicate whether or not a message like this was a
+                    # reference and should be escaped or not. Or, better,
+                    # the import process would need to use information from
+                    # the default strings.xml file to fill the vacancies.
+                    warnfunc(('Warning: The array "%s" contains items '+
+                              'that can\'t be processed (reason: %s) - '
+                              'the array will be incomplete') %
+                                    (name, e.reason), 'warning')
+                else:
+                    translation = Translation(text, comment, formatted)
+                    result[name].append(translation)
+
+        elif tag.tag == 'plurals':
+            result[name] = Plurals()
+            for child in tag.findall('item'):
+                try:
+                    quantity = child.attrib['quantity']
+                    assert quantity in PLURAL_TAGS
+                except (IndexError, AssertionError):
+                    warnfunc(('"%s" contains a plural with no or '+
+                              'an invalid quantity') % name, 'warning')
+                else:
+                    try:
+                        text, formatted = get_element_text(child, name, warnfunc)
+                    except UnsupportedResourceError as e:
+                        warnfunc(('Warning: The plural "%s" can\'t '+
+                                  'be processed (reason: %s) - '
+                                  'the plural will be incomplete') %
+                                 (name, e.reason), 'warning')
+                    else:
+                        translation = Translation(text, comment, formatted)
+                        result[name][quantity] = translation
+
+        # We now have processed a tag. We either added those comments to
+        # the translation we created based on the tag, or the comments
+        # relate to a tag we do not support. In any case, dismiss them.
+        comment = []
+
+    return result
+
+
+def plural_to_gettext(rule):
+    """This is a copy of the code of ``babel.plural.to_gettext``.
+
+    We need to use a custom version, because the original only returns
+    a full plural_forms string, which the Babel catalog object does not
+    allow us to assign to anything. Instead, we need the expr and the
+    plural count separately. See http://babel.edgewall.org/ticket/291.
+    """
+    from babel.plural import (PluralRule, _fallback_tag, _plural_tags,
+                              _GettextCompiler)
+    rule = PluralRule.parse(rule)
+
+    used_tags = rule.tags | set([_fallback_tag])
+    _compile = _GettextCompiler().compile
+    _get_index = [tag for tag in _plural_tags if tag in used_tags].index
+
+    expr = ['(']
+    for tag, ast in rule.abstract:
+        expr.append('%s ? %d : ' % (_compile(ast), _get_index(tag)))
+    expr.append('%d)' % _get_index(_fallback_tag))
+    return len(used_tags), ''.join(expr)
+
+
+def set_catalog_plural_forms(catalog, language):
+    """Set the catalog to use the correct plural forms for the
+    language.
+    """
+    try:
+        catalog._num_plurals, catalog._plural_expr = plural_to_gettext(
+            language.locale.plural_form)
+    except KeyError:
+        # Babel/CDLR seems to be lacking this data sometimes, for
+        # example for "uk"; fortunately, ignoring this is narrowly
+        # acceptable.
+        pass
+
+
+def xml2po(resources, translations=None, resfilter=None, warnfunc=dummy_warn):
+    """Return ``resources`` as a Babel .po ``Catalog`` instance.
+
+    If given, ``translations`` will be used for the translated values.
+    In this case, the returned value is a 2-tuple (catalog, unmatched),
+    with the latter being a list of Android string resource names that
+    are in the translated file, but not in the original.
+
+    Both ``resources`` and ``translations`` must be ``ResourceTree``
+    objects, as returned by ``read_xml()``.
+
+    From the application perspective, it will call this function with
+    a ``translations`` object when initializing a new .po file based on
+    an existing resource file (the 'init' command). For 'export', this
+    function is called without translations. It will thus generate what
+    is essentially a POT file (an empty .po file), and this will be
+    merged into the existing .po catalogs, as per how gettext usually
+    """
+    assert not translations or translations.language
+
+    catalog = Catalog()
+    if translations is not None:
+        catalog.locale = translations.language.locale
+        # We cannot let Babel determine the plural expr for the locale by
+        # itself. It will use a custom list of plural expressions rather
+        # than generate them based on CLDR.
+        # See http://babel.edgewall.org/ticket/290.
+        set_catalog_plural_forms(catalog, translations.language)
+
+    for name, org_value in resources.items():
+        if resfilter and resfilter(name):
+            continue
+
+        trans_value = None
+        if translations:
+            trans_value = translations.pop(name, trans_value)
+
+        if isinstance(org_value, StringArray):
+            # a string-array, write as "name:index"
+            if len(org_value) == 0:
+                warnfunc("Warning: string-array '%s' is empty" % name, 'warning')
+                continue
+
+            if not isinstance(trans_value, StringArray):
+                if trans_value:
+                    warnfunc(('""%s" is a string-array in the reference '
+                              'file, but not in the translation.') %
+                                    name, 'warning')
+                trans_value = StringArray()
+
+            for index, item in enumerate(org_value):
+                item_trans = trans_value[index].text if index < len(trans_value) else ''
+
+                # If the string has formatting markers, indicate it in
+                # the gettext output
+                flags = []
+                if item.formatted:
+                    flags.append('c-format')
+
+                ctx = "%s:%d" % (name, index)
+                catalog.add(item.text, item_trans, auto_comments=item.comments,
+                            flags=flags, context=ctx)
+
+        elif isinstance(org_value, Plurals):
+            # a plurals, convert to a gettext plurals
+            if len(org_value) == 0:
+                warnfunc("Warning: plurals '%s' is empty" % name, 'warning')
+                continue
+
+            if not isinstance(trans_value, Plurals):
+                if trans_value:
+                    warnfunc(('""%s" is a plurals in the reference '
+                              'file, but not in the translation.') %
+                                    name, 'warning')
+                trans_value = Plurals()
+
+            # Taking the Translation objects for each quantity in ``org_value``,
+            # we build a list of strings, which is how plurals are represented
+            # in Babel.
+            #
+            # Since gettext only allows comments/flags on the whole
+            # thing at once, we merge the comments/flags of all individual
+            # plural strings into one.
+            formatted = False
+            comments = []
+            for _, translation in list(org_value.items()):
+                if translation.formatted:
+                    formatted = True
+                comments.extend(translation.comments)
+
+            # For the message id, choose any two plural forms, but prefer
+            # "one" and "other", assuming an English master resource.
+            temp = org_value.copy()
+            singular =\
+                temp.pop('one') if 'one' in temp else\
+                temp.pop('other') if 'other' in temp else\
+                temp.pop(list(temp.keys())[0])
+            plural =\
+                temp.pop('other') if 'other' in temp else\
+                temp[list(temp.keys())[0]] if temp else\
+                singular
+            msgid = (singular.text, plural.text)
+            del temp, singular, plural
+
+            # We pick the quantities supported by the language (the rest
+            # would be ignored by Android as well).
+            msgstr = ''
+            if trans_value:
+                allowed_keywords = translations.language.plural_keywords
+                msgstr = ['' for i in range(len(allowed_keywords))]
+                for quantity, translation in list(trans_value.items()):
+                    try:
+                        index = translations.language.plural_keywords.index(quantity)
+                    except ValueError:
+                        warnfunc(
+                            ('"plurals "%s" uses quantity "%s", which '
+                             'is not supported for this language. See '
+                             'the README for an explanation. The '
+                             'quantity has been ignored') %
+                                    (name, quantity), 'warning')
+                    else:
+                        msgstr[index] = translation.text
+
+            flags = []
+            if formatted:
+                flags.append('c-format')
+            catalog.add(msgid, tuple(msgstr), flags=flags,
+                        auto_comments=comments, context=name)
+
+        else:
+            # a normal string
+
+            # If the string has formatting markers, indicate it in
+            # the gettext output
+            # TODO DRY this.
+            flags = []
+            if org_value.formatted:
+                flags.append('c-format')
+
+            catalog.add(org_value.text, trans_value.text if trans_value else '',
+                        flags=flags, auto_comments=org_value.comments, context=name)
+
+    if translations is not None:
+        # At this point, trans_strings only contains those for which
+        # no original existed.
+        return catalog, list(translations.keys())
+    else:
+        return catalog
+
+
+def write_to_dom(elem_name, value, ref, namespaces=None, warnfunc=dummy_warn):
+    """Create a DOM object with the tag name ``elem_name``, containing
+    the string ``value`` formatted according to Android XML rules.
+
+    The result might be a <string>-tag, or a <item>-tag as found as
+    children of <string-array>, for example.
+
+    It might feel awkward at first that the Android-XML formatting
+    does not happen in a separate method, but is part of the creation
+    of a tag, but due to us having to do certain formatting based on
+    child DOM elements that ``value`` may include, the two fit
+    naturally together (see the POSTPROCESS section of this function).
+
+    If one of our supported namespace prefixes is used within nested tags
+    inside ``value``, the appropriate data is added to the
+    ``namespaces`` dict, if given, so the caller may generate the
+    proper declarations.
+    """
+
+    loose_parser = etree.XMLParser(recover=True)
+
+    if value is None:
+        value = ''
+
+    # PREPROCESS
+    # The translations may contain arbitrary XHTML, which we need
+    # to inject into the DOM to properly output. That means parsing
+    # it first.
+    # This will now get really messy, since certain XML entities
+    # we have unescaped for the translators convenience, while the
+    # tag entities &lt; and &gt; we have not, to differentiate them
+    # from actual nested tags. Is there any good way to restore this
+    # properly?
+    # TODO: In particular, the code below will once we do anything
+    # bit more complicated with entities, like &amp;amp;lt;
+    value = value.replace('&', '&amp;')
+    value = value.replace('&amp;lt;', '&lt;')
+    value = value.replace('&amp;gt;', '&gt;')
+
+    # PARSE
+    #
+    # Namespace handling complicates things a bit. We want the value
+    # we inject to support nested XML with certain supported namespace
+    # prefixes, but lxml doesn't seem to allow us to predefine those
+    # (https://answers.launchpad.net/lxml/+question/111660).
+    # So we use a wrapping element with xmlns attributes that we ignore
+    # after parsing.
+    namespace_text = " ".join(['xmlns:%s="%s"' % (prefix, ns) for ns, prefix in list(KNOWN_NAMESPACES.items())])
+    value_to_parse = "<root %s><%s>%s</%s></root>" % (namespace_text, elem_name, value, elem_name)
+    try:
+        elem = etree.fromstring(value_to_parse)
+    except etree.XMLSyntaxError as e:
+        elem = etree.fromstring(value_to_parse, loose_parser)
+        warnfunc(('%s contains invalid XHTML (%s); Falling back to '
+                  'loose parser.') % (ref, e), 'warning')
+
+    # Within the generated DOM, search for use of one of our supported
+    # namespace prefixes, so we can keep track of which namespaces have
+    # been used.
+    if namespaces is not None:
+        for c in elem.iterdescendants():
+            if c.prefix:
+                nsuri = c.nsmap[c.prefix]
+                if nsuri in KNOWN_NAMESPACES:
+                    namespaces[KNOWN_NAMESPACES[nsuri]] = nsuri
+    # Then, proceed with the actual element that we wanted to create.
+    elem = elem[0]
+
+    def quote(text):
+        """Return ``text`` surrounded by quotes if necessary.
+        """
+        if text is None:
+            return
+
+        # If there is trailing or leading whitespace, even if it's
+        # just a single space character, we need quoting.
+        needs_quoting = text.strip(WHITESPACE) != text
+
+        # Otherwise, there might be collapsible spaces inside the text.
+        if not needs_quoting:
+            space_count = 0
+            for c in chain(text, [EOF]):
+                if c is not EOF and c in WHITESPACE:
+                    space_count += 1
+                    if space_count >= 2:
+                        needs_quoting = True
+                        break
+                else:
+                    space_count = 0
+
+        if needs_quoting:
+            return '"%s"' % text
+        return text
+
+    def escape(text):
+        """Escape all the characters we know need to be escaped
+        in an Android XML file."""
+        if text is None:
+            return
+        text = text.replace('\\', '\\\\')
+        text = text.replace('\n', '\\n')
+        text = text.replace('\t', '\\t')
+        text = text.replace('\'', '\\\'')
+        text = text.replace('"', '\\"')
+        # Strictly speaking, @ only needs to be escaped when
+        # it's the first character. But, since our target XML
+        # files are basically generate-only and unlikely to be
+        # edited by a user, don't bother with pretty.
+        text = text.replace('@', '\\@')
+        return text
+
+    # POSTPROCESS
+    for child_elem in elem.iter():
+        # Strictly speaking, we wouldn't want to touch things
+        # like the root elements tail, but it doesn't matter here,
+        # since they are going to be empty string anyway.
+        child_elem.text = quote(escape(child_elem.text))
+        child_elem.tail = quote(escape(child_elem.tail))
+
+    return elem
+
+def key_plural_keywords(x):
+    """Extracts CLDR plural keywords index starting with 'zero'
+    and ending with 'other'."""
+    return PLURAL_TAGS.index(x) if x in PLURAL_TAGS else -1
+
+
+def po2xml(catalog, with_untranslated=False, resfilter=None, warnfunc=dummy_warn):
+    """Convert the gettext catalog in ``catalog`` to a ``ResourceTree``
+    instance (our in-memory representation of an Android XML resource)
+
+    This currently relies entirely in the fact that we can use the context
+    of each message to specify the Android resource name (which we need
+    to do to handle duplicates, but this is a nice by-product). However
+    that also means we cannot handle arbitrary catalogs.
+
+    The latter would in theory be possible by using the original,
+    untranslated XML to match up a messages id to a resource name, but
+    right now we don't support this (and it's not clear it would be
+    necessary, even).
+
+    If ``with_untranslated`` is given, then strings in the catalog
+    that have no translation are written out with the original id,
+    whenever this is safely possible. This does not include string-arrays,
+    which for technical reasons always must include all elements, and it
+    does not include plurals, for which the same is true.
+    """
+
+    # Validate that the plurals in the .po catalog match those that
+    # we expect on the Android side per CLDR definition. However, we
+    # only want to trouble the user with this if plurals are actually
+    # used.
+    plural_validation = {'done': False}
+    def validate_plural_config():
+        if plural_validation['done']:
+            return
+        if catalog.num_plurals != len(catalog.language.plural_keywords):
+            warnfunc(('Catalog defines %d plurals, we expect %d for '
+                      'this language. See the README for an '
+                      'explanation. plurals have very likely been '
+                      'incorrectly written.') % (
+                catalog.num_plurals, len(catalog.language.plural_keywords)), 'error')
+            pass
+        plural_validation['done'] = True
+
+    xml_tree = ResourceTree(getattr(catalog, 'language', None))
+    for message in catalog:
+        if not message.id:
+            # This is the header
+            continue
+
+        if not message.context:
+            warnfunc(('Ignoring message "%s": has no context; somebody other '+
+                      'than android2po seems to have added to this '+
+                      'catalog.') % message.id, 'error')
+            continue
+
+        if resfilter and resfilter(message):
+            continue
+
+        # Both string and id will contain a tuple of this is a plural
+        value = message.string or message.id
+
+        # A colon indicates a string array
+        if ':' in message.context:
+            # Collect all the strings of this array with their indices,
+            # so when we're done processing the whole catalog, we can
+            # sort by index and restore the proper array order.
+            name, index = message.context.split(':', 2)
+            index = int(index)
+            xml_tree.setdefault(name, StringArray())
+            while index >= len(xml_tree[name]):
+                xml_tree[name].append(None)  # fill None for missing indices
+            if xml_tree[name][index] is not None:
+                warnfunc(('Duplicate index %s in array "%s"; ignoring '+
+                          'the message. The catalog has possibly been '+
+                          'corrupted.') % (index, name), 'error')
+            xml_tree[name][index] = value
+
+        # A plurals message
+        elif isinstance(message.string, tuple):
+            validate_plural_config()
+
+            # Untranslated: Do not include those even with with_untranslated
+            # is enabled - this is because even if we could put the plural
+            # definition from the master resource here, it wouldn't make
+            # sense in the context of another language. Instead, let access
+            # to the untranslated master version continue to work.
+            if not any(message.string):
+                continue
+
+            # We need to work with ``message.string`` directly rather than
+            # ``value``, since ``message.id`` will only be a 2-tuple made
+            # up of the msgid and msgid_plural definitions.
+            xml_tree[message.context] = Plurals([
+                (k, None) for k in catalog.language.plural_keywords])
+            for index, keyword in enumerate(catalog.language.plural_keywords):
+                # Assume each keyword matches one index.
+                try:
+                    xml_tree[message.context][keyword] = message.string[index]
+                except IndexError:
+                    # Plurals are not matching up, validate_plural_config()
+                    # has already raised a warning.
+                    break
+
+        # A standard string.
+        else:
+            if not message.string and not with_untranslated:
+                # Untranslated.
+                continue
+            xml_tree[message.context] = value
+
+    return xml_tree
+
+
+def write_xml(tree, warnfunc=dummy_warn):
+    """Takes a ``ResourceTree`` (our in-memory representation of an Android
+    XML resource) and returns a XML DOM (via an etree.Element).
+    """
+    # Convert the xml tree we've built into an actual Android XML DOM.
+    root_tags = []
+    namespaces_used = {}
+    for name, value in tree.items():
+        if isinstance(value, StringArray):
+            # string-array - first, sort by index
+            array_el = etree.Element('string-array')
+            array_el.attrib['name'] = name
+            for i, v in enumerate(value):
+                item_el = write_to_dom(
+                    'item', v, '"%s" index %d' % (name, i), namespaces_used,
+                    warnfunc)
+                array_el.append(item_el)
+            root_tags.append(array_el)
+        elif isinstance(value, Plurals):
+            # plurals
+            plural_el = etree.Element('plurals')
+            plural_el.attrib['name'] = name
+            for k in sorted(value, key=key_plural_keywords):
+                item_el = write_to_dom(
+                    'item', value[k], '"%s" quantity %s' % (name, k),
+                    namespaces_used, warnfunc)
+                item_el.attrib["quantity"] = k
+                plural_el.append(item_el)
+            root_tags.append(plural_el)
+        else:
+            # standard string
+            string_el = write_to_dom(
+                'string', value, '"%s"' % name, namespaces_used, warnfunc)
+            string_el.attrib['name'] = name
+            root_tags.append(string_el)
+
+    # Generate the root element, define the namespaces that have been
+    # used across all of our child elements.
+    root_el = etree.Element('resources', nsmap=namespaces_used)
+    for e in root_tags:
+        root_el.append(e)
+    return root_el
diff --git a/focus-android/tools/l10n/android2po/env.py b/focus-android/tools/l10n/android2po/env.py
new file mode 100644
index 000000000000..5a622aeecb05
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/env.py
@@ -0,0 +1,525 @@
+from __future__ import absolute_import
+from __future__ import unicode_literals
+
+import os
+import re
+import glob
+from argparse import Namespace
+from os import path
+from babel import Locale
+from babel.core import UnknownLocaleError
+
+from convert import key_plural_keywords
+from config import Config
+from utils import Path, format_to_re
+from convert import read_xml, InvalidResourceError
+
+
+__all__ = ('EnvironmentError', 'IncompleteEnvironment',
+           'Environment', 'Language', 'resolve_locale')
+
+
+class EnvironmentError(Exception):
+    pass
+
+
+class IncompleteEnvironment(EnvironmentError):
+    pass
+
+
+ANDROID_LOCALE_MAPPING = {
+    'from': {
+        'zh_CN': 'zh_Hans_CN',
+        'zh_HK': 'zh_Hant_HK',
+        'zh_TW': 'zh_Hant_TW'
+    },
+    'to': {
+        'zh_Hans_CN': 'zh_CN',
+        'zh_Hant_HK': 'zh_HK',
+        'zh_Hant_TW': 'zh_TW'
+    }
+}
+"""
+Android uses locale scheme that differs from one used inside Babel,
+so we must provide a mapping between one another. This list is not
+full and must be updated to include all such mappings.
+
+We can not simply ignore middle element in transition from android
+to Babel locale mapping.
+"""
+
+
+class Language(object):
+    """Represents a single language.
+    """
+
+    def __init__(self, code, env=None):
+        self.code = code
+        self.env = env
+        self.locale = Locale.parse(code) if code else None
+
+    def __unicode__(self):  # pragma: no cover
+        return str(self.code)
+
+    def xml(self, kind):
+        # Android uses a special language code format for the region part
+        if self.code in ANDROID_LOCALE_MAPPING['to']:
+            code = ANDROID_LOCALE_MAPPING['to'][self.code]
+        else:
+            code = self.code
+        parts = tuple(code.split('_', 2))
+        if len(parts) == 2:
+            android_code = "%s-r%s" % parts
+        else:
+            android_code = "%s" % parts
+        return self.env.path(self.env.resource_dir,
+                             'values-%s/%s.xml' % (android_code, kind))
+
+    def po(self, kind):
+        filename = self.env.config.layout % {
+            'group': kind,
+            'domain': self.env.config.domain or 'android',
+            'locale': self.code}
+        return self.env.path(self.env.gettext_dir, filename)
+
+    @property
+    def plural_keywords(self):
+        # Sort plural rules properly
+        ret = list(self.locale.plural_form.rules.keys()) + ['other']
+        return sorted(ret, key=key_plural_keywords)
+
+
+class DefaultLanguage(Language):
+    """A special version of ``Language``, representing the default
+    language.
+
+    For the Android side, this means the XML files in the values/
+    directory. For the gettext side, it means the .pot file(s).
+    """
+
+    def __init__(self, env):
+        super(DefaultLanguage, self).__init__(None, env)
+
+    def __unicode__(self):  # pragma: no cover
+        return '<def>'
+
+    def xml(self, kind):
+        return self.env.path(self.env.resource_dir, 'values/%s.xml' % kind)
+
+    def po(self, kind):
+        filename = self.env.config.template_name % {
+            'group': kind,
+            'domain': self.env.config.domain or 'android',
+        }
+        return self.env.path(self.env.gettext_dir, filename)
+
+
+def resolve_locale(code, env):
+    """Return a ``Language`` instance for a locale code.
+
+    Deals with incorrect Babel locale values."""
+    try:
+        return Language(code, env)
+    except UnknownLocaleError:
+        env.w.action('failed', '%s is not a valid locale' % code)
+
+
+def find_project_dir_and_config():
+    """Goes upwards through the directory hierarchy and tries to find
+    either an Android project directory, a config file for ours, or both.
+
+    The latter case (both) can only happen if the config file is in the
+    root of the Android directory, because once we have either, we stop
+    searching.
+
+    Note that the two are distinct, in that if a config file is found,
+    it's directory is not considered a "project directory" from which
+    default paths can be derived.
+
+    Returns a 2-tuple (project_dir, config_file).
+    """
+    cur = os.getcwd()
+
+    while True:
+        project_dir = config_file = None
+
+        manifest_path = path.join(cur, 'AndroidManifest.xml')
+        if path.exists(manifest_path) and path.isfile(manifest_path):
+            project_dir = cur
+
+        config_path = path.join(cur, '.android2po')
+        if path.exists(config_path) and path.isfile(config_path):
+            config_file = config_path
+
+        # Stop once we found either.
+        if project_dir or config_file:
+            return project_dir, config_file
+
+        # Stop once we're at the root of the filesystem.
+        old = cur
+        cur = path.normpath(path.join(cur, path.pardir))
+        if cur == old:
+            # No further change, we are probably at root level.
+            # TODO: Is there a better way? Is path.ismount suitable?
+            # Or we could split the path into pieces by path.sep.
+            break
+
+    return None, None
+
+
+def find_android_kinds(resource_dir, get_all=False):
+    """Return a list of Android XML resource types that are in use.
+
+    For this, we simply have a look which xml files exists in the
+    default values/ resource directory, and return those which
+    include string resources.
+
+    If ``get_all`` is given, the test for string resources will be
+    skipped.
+    """
+    kinds = []
+    search_dir = path.join(resource_dir, 'values')
+    for name in os.listdir(search_dir):
+        filename = path.join(search_dir, name)
+        if path.isfile(filename) and name.endswith('.xml'):
+            # We want to support arbitrary xml resource file names, but
+            # we also need to make sure we only return those which actually
+            # contain string resources. More specifically, a file named
+            # my-colors.xml, containing only color resources, should not
+            # result in a my-colors.po catalog to be created.
+            #
+            # We thus attempt to read each file here, see if there are any
+            # strings in it. If we fail to parse a file, we return it and
+            # trust that whatever command the user selected will later also
+            # stumble and show a proper error.
+            #
+            # TODO:
+            # I'm not entirely happy about this. One obvious problem is that
+            # we are likely to parse these xml files twice, which seems like
+            # a code smell. One potential solution: Stores the parsed XML
+            # result directly in memory, with the environment, rather than
+            # parsing it a second time later.
+            #
+            # We could also opt to fail outright if we encounter an invalid
+            # XML file here, since the error doesn't belong to any "action".
+            kind = path.splitext(name)[0]
+            if kind in ('strings', 'arrays') or get_all:
+                # These kinds are special, they are always supposed to
+                # contain something translatable, so always include them.
+                kinds.append(kind)
+            else:
+                try:
+                    strings = read_xml(filename)
+                except InvalidResourceError as e:
+                    raise EnvironmentError('Failed to parse "%s": %s' % (filename, e))
+                else:
+                    # If there are any strings in the file, detect as
+                    # a kind of xml file.
+                    if strings:
+                        kinds.append(kind)
+    return kinds
+
+
+class Environment(object):
+    """Environment is the main object that holds all the data with
+    which we run.
+
+    Usage:
+
+        env = Environment()
+        env.pop_from_config(config)
+        env.init()
+    """
+
+    def __init__(self, writer):
+        self.w = writer
+        self.xmlfiles = []
+        self.default = DefaultLanguage(self)
+        self.config = Config()
+        self.auto_gettext_dir = None
+        self.auto_resource_dir = None
+        self.resource_dir = None
+        self.gettext_dir = None
+
+        # Try to determine if we are inside a project; if so, we a) might
+        # find a configuration file, and b) can potentially assume some
+        # default directory names.
+        self.project_dir, self.config_file = find_project_dir_and_config()
+
+    def _pull_into(self, namespace, target):
+        """If for a value ``namespace`` there exists a corresponding
+        attribute on ``target``, then update that attribute with the
+        values from ``namespace``, and then remove the value from
+        ``namespace``.
+
+        This is needed because certain options, if passed on the command
+        line, need nevertheless to be stored in the ``self.config``
+        object. We therefore **pull** those values in, and return the
+        rest of the options.
+        """
+        for name in dir(namespace):
+            if name.startswith('_'):
+                continue
+            if name in target.__dict__:
+                setattr(target, name, getattr(namespace, name))
+                delattr(namespace, name)
+        return namespace
+
+    def _pull_into_self(self, namespace):
+        """This is essentially like ``self._pull_info``, but we pull
+        values into the environment object itself, and in order to avoid
+        conflicts between option values and attributes on the environment
+        (for example ``config``), we explicitly specify the values we're
+        interested in: It's the "big" ones which we would like to make
+        available on the environment object directly.
+        """
+        for name in ('resource_dir', 'gettext_dir'):
+            if hasattr(namespace, name):
+                setattr(self, name, getattr(namespace, name))
+                delattr(namespace, name)
+        return namespace
+
+    def pop_from_options(self, argparse_namespace):
+        """Apply the set of options given on the command line.
+
+        These means that we need those options that are "configuration"
+        values to end up in ``self.config``. The normal options will
+        be made available as ``self.options``.
+        """
+        rest = self._pull_into_self(argparse_namespace)
+        rest = self._pull_into(rest, self.config)
+        self.options = rest
+
+    def pop_from_config(self, argparse_namespace):
+        """Load the values we support into our attributes, remove them
+        from the ``config`` namespace, and store whatever is left in
+        ``self.config``.
+        """
+        rest = self._pull_into_self(argparse_namespace)
+        rest = self._pull_into(rest, self.config)
+        # At this point, there shouldn't be anything left, because
+        # nothing should be included in the argparse result that we
+        # don't consider a configuration option.
+        ns = Namespace()
+        assert rest == ns
+
+    def auto_paths(self):
+        """Try to auto-fill some path values that don't have values yet.
+        """
+        if self.project_dir:
+            if not self.resource_dir:
+                self.resource_dir = path.join(self.project_dir, 'res')
+                self.auto_resource_dir = True
+            if not self.gettext_dir:
+                self.gettext_dir = path.join(self.project_dir, 'locale')
+                self.auto_gettext_dir = True
+
+    def path(self, *pargs):
+        """Helper that constructs a Path object using the project dir
+        as the base."""
+        return Path(*pargs, base=self.project_dir)
+
+    def init(self):
+        """Initialize the environment.
+
+        This entails finding the default Android language resource files,
+        and in the process doing some basic validation.
+        An ``EnvironmentError`` is thrown if there is something wrong.
+        """
+        # If either of those is not specified, we can't continue. Raise a
+        # special exception that let's the caller display the proper steps
+        # on how to proceed.
+        if not self.resource_dir or not self.gettext_dir:
+            raise IncompleteEnvironment()
+
+        # It's not enough for directories to be specified; they really
+        # should exist as well. In particular, the locale/ directory is
+        # not part of the standard Android tree and thus likely to not
+        # exist yet, so we create it automatically, but ONLY if it wasn't
+        # specified explicitely. If the user gave a specific location,
+        # it seems right to let him deal with it fully.
+        if not path.exists(self.gettext_dir) and self.auto_gettext_dir:
+            os.makedirs(self.gettext_dir)
+        elif not path.exists(self.gettext_dir):
+            raise EnvironmentError('Gettext directory at "%s" doesn\'t exist.' %
+                                   self.gettext_dir)
+        elif not path.exists(self.resource_dir):
+            raise EnvironmentError('Android resource direcory at "%s" doesn\'t exist.' %
+                                   self.resource_dir)
+
+        # Find the Android XML resources that are our original source
+        # files, i.e. for example the values/strings.xml file.
+        groups_found = find_android_kinds(self.resource_dir,
+                                          get_all=bool(self.config.groups))
+        if self.config.groups:
+            self.xmlfiles = self.config.groups
+            _missing = set(self.config.groups) - set(groups_found)
+            if _missing:
+                raise EnvironmentError('Unable to find the default XML '
+                    'files for the following groups: %s' % (
+                        ", ".join(["%s (%s)" % (
+                            g, path.join(self.resource_dir, 'values', "%s.xml" % g)) for g in _missing])
+                    ))
+        else:
+            self.xmlfiles = groups_found
+        if not self.xmlfiles:
+            raise EnvironmentError('no language-neutral string resources found in "values/".')
+
+        # If regular expressions are used as ignore filters, precompile
+        # those to help speed things along. For simplicity, we also
+        # convert all static ignores to regexes.
+        compiled_list = []
+        for ignore_list in self.config.ignores:
+            for ignore in ignore_list:
+                if ignore.startswith('/') and ignore.endswith('/'):
+                    compiled_list.append(re.compile(ignore[1:-1]))
+                else:
+                    compiled_list.append(re.compile("^%s$" % re.escape(ignore)))
+        self.config.ignores = compiled_list
+
+        # Validate the layout option, and resolve magic constants ("gnu")
+        # to an actual format string.
+        layout = self.config.layout
+        multiple_pos = len(self.xmlfiles) > 1
+        if not layout or layout == 'default':
+            if self.config.domain and multiple_pos:
+                layout = '%(domain)s-%(group)s-%(locale)s.po'
+            elif self.config.domain:
+                layout = '%(domain)s-%(locale)s.po'
+            elif multiple_pos:
+                layout = '%(group)s-%(locale)s.po'
+            else:
+                layout = '%(locale)s.po'
+        elif layout == 'gnu':
+            if multiple_pos:
+                layout = '%(locale)s/LC_MESSAGES/%(group)s-%(domain)s.po'
+            else:
+                layout = '%(locale)s/LC_MESSAGES/%(domain)s.po'
+        else:
+            # TODO: These tests essentially disallow any advanced
+            # formatting syntax. While that is unlikely to be used
+            # or needed, a better way to test for the existance of
+            # a placeholder would probably be to insert a unique string
+            # and see if it comes out at the end; or, come up with
+            # a proper regex to parse.
+            if '%(locale)s' not in layout:
+                raise EnvironmentError('--layout lacks %(locale)s variable')
+            if self.config.domain and '%(domain)s' not in layout:
+                raise EnvironmentError('--layout needs %(domain)s variable, ',
+                                       'since you have set a --domain')
+            if multiple_pos and '%(group)s' not in layout:
+                raise EnvironmentError('--layout needs %%(group)s variable, '
+                                       'since you have multiple groups: %s' % (
+                                           ", ".join(self.xmlfiles)))
+        self.config.layout = layout
+
+        # The --template option needs similar processing:
+        template = self.config.template_name
+        if not template:
+            if self.config.domain and multiple_pos:
+                template = '%(domain)s-%(group)s.pot'
+            elif self.config.domain:
+                template = '%(domain)s.pot'
+            elif multiple_pos:
+                template = '%(group)s.pot'
+            else:
+                template = 'template.pot'
+        elif '%s' in template and '%(group)s' not in template:
+            # In an earlier version the --template option only
+            # supported a %s placeholder for the XML kind. Make
+            # sure we still support this.
+            # TODO: Would be nice we if could raise a deprecation
+            # warning here somehow. That means adding a callback
+            # to this function. Or, probably we should just make the
+            # environment aware of the writer object. This would
+            # simplify other things as well.
+            template = template.replace('%s', '%(group)s')
+        else:
+            # Note that we do not validate %(domain)s here; we expressively
+            # allow the user to define a template without a domain.
+            # TODO: See the same case above when handling --layout
+            if multiple_pos and '%(group)s' not in template:
+                raise EnvironmentError('--template needs %%(group)s variable, '
+                                       'since you have multiple groups: %s' % (
+                                           ", ".join(self.xmlfiles)))
+        self.config.template_name = template
+
+    LANG_DIR = re.compile(r'^values-(\w\w)(?:-r(\w\w))?$')
+
+    def get_android_languages(self):
+        """Finds the languages that already exist inside the Android
+        resource directory.
+
+        Return value is a list of ``Language`` instances.
+        """
+        languages = []
+        for name in os.listdir(self.resource_dir):
+            match = self.LANG_DIR.match(name)
+            if not match:
+                continue
+            country, region = match.groups()
+            pseudo_code = "%s" % country
+            if region:
+                pseudo_code += "_%s" % region
+            if pseudo_code in ANDROID_LOCALE_MAPPING['from']:
+                code = ANDROID_LOCALE_MAPPING['from'][pseudo_code]
+            else:
+                code = pseudo_code
+            language = resolve_locale(code, self)
+            if language:
+                languages.append(language)
+        return languages
+
+    def get_gettext_languages(self):
+        """Finds the languages that already exist inside the gettext
+        directory.
+
+        This is a little more though than on the Android side, since
+        we give the user a lot of flexibility in configuring how the
+        .po files are layed out.
+
+        Return value is a list of ``Language`` instances.
+        """
+
+        # Build a glob pattern based on the layout. This will enable
+        # us to easily get a list of files that match the pattern.
+        glob_pattern = self.config.layout % {
+            'domain': self.config.domain,
+            'group': '*',
+            'locale': '*',
+        }
+
+        # Temporarily switch to the gettext directory. This allows us
+        # to simply call glob() using the relative pattern, rather than
+        # having to deal with making a full path, and then later on
+        # stripping the full path again for the regex matching, and
+        # potentially even running into problems when, say, the pattern
+        # contains references like ../ to a parent directory.
+        old_dir = os.getcwd()
+        os.chdir(self.gettext_dir)
+        try:
+            list = glob.glob(glob_pattern)
+
+            # We now have a list of matching .po files, but now idea
+            # which languages they represent, because we don't know
+            # which part of the filename is the locale. To solve this,
+            # we build a regular expression from the format string,
+            # one with a capture group where the locale code should be.
+            regex = re.compile(format_to_re(self.config.layout))
+
+            # We then try to match every single file returned by glob.
+            # In this way, we can build a list of unique locale codes.
+            languages = {}
+            for item in list:
+                m = regex.match(item)
+                if not m:
+                    continue
+                code = m.groupdict()['locale']
+                if code not in languages:
+                    language = resolve_locale(code, self)
+                    if language:
+                        languages[code] = language
+
+            return languages.values()
+        finally:
+            os.chdir(old_dir)
diff --git a/focus-android/tools/l10n/android2po/program.py b/focus-android/tools/l10n/android2po/program.py
new file mode 100644
index 000000000000..23518b451c3a
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/program.py
@@ -0,0 +1,226 @@
+"""Implements the command line interface.
+"""
+
+from __future__ import absolute_import
+from __future__ import unicode_literals
+
+import sys
+from os import path
+
+import argparse
+if hasattr(argparse, '__version__') and argparse.__version__ < '1.1':  # pragma: no cover
+    raise RuntimeError('Needs at least argparse 1.1 to function, you are ' +
+                       'using: %s' % argparse.__version__)
+
+# Resist the temptation to use "*". It won't work on Python 2.5.
+from commands import InitCommand, ExportCommand, ImportCommand, CommandError
+from env import IncompleteEnvironment, EnvironmentError, Environment
+from config import Config
+from utils import Writer
+
+
+__all__ = ('main', 'run',)
+
+
+COMMANDS = {
+    'init': InitCommand,
+    'export': ExportCommand,
+    'import': ImportCommand,
+}
+
+
+def parse_args(argv):
+    """Builds an argument parser based on all commands and configuration
+    values that we support.
+    """
+    parser = argparse.ArgumentParser(add_help=True,
+        description='Convert Android string resources to gettext .po '+
+                    'files, an import them back.',
+        epilog='Written by: Michael Elsdoerfer <michael@elsdoerfer.com>')
+    parser.add_argument('--version', action='version', version="moz1")
+
+    # Create parser for arguments shared by all commands.
+    base_parser = argparse.ArgumentParser(add_help=False)
+    group = base_parser.add_mutually_exclusive_group()
+    group.add_argument('--verbose', '-v', action='store_true',
+                       help='be extra verbose')
+    group.add_argument('--quiet', '-q', action='store_true',
+                       help='be extra quiet')
+    base_parser.add_argument('--config', '-c', metavar='FILE',
+                             help='config file to use')
+    # Add the arguments that set/override the configuration.
+    group = base_parser.add_argument_group('configuration',
+        'Those can also be specified in a configuration file. If given '
+        'here, values from the configuration file will be overwritten.')
+    Config.setup_arguments(group)
+    # Add our commands with the base arguments + their own.
+    subparsers = parser.add_subparsers(dest="command", title='commands',
+                                       description='valid commands',
+                                       help='additional help')
+    for name, cmdclass in list(COMMANDS.items()):
+        cmd_parser = subparsers.add_parser(name, parents=[base_parser], add_help=True)
+        group = cmd_parser.add_argument_group('command arguments')
+        cmdclass.setup_arg_parser(group)
+
+    return parser.parse_args(argv[1:])
+
+
+def read_config(file):
+    """Read the config file in ``file``.
+
+    ``file`` may either be a file object, or a filename.
+
+    The config file currently is simply a file with command line options,
+    each option on a separate line.
+
+    Just for reference purposes, the following ticket should be noted,
+    which intends to extend argparse with support for configuration files:
+        http://code.google.com/p/argparse/issues/detail?id=35
+    Note however that the current patch doesn't seem to provide an easy
+    way to make paths in the config relative to the config file location,
+    as we currently need.
+    """
+
+    if hasattr(file, 'read'):
+        lines = file.readlines()
+        if hasattr(file, 'name'):
+            filename = file.name
+        else:
+            filename = None
+    else:
+        # Open the config file and read the arguments.
+        filename = file
+        f = open(file, 'rb')
+        try:
+            lines = f.readlines()
+        finally:
+            f.close()
+
+    args = filter(lambda x: bool(x),     # get rid of '' elements
+                  [i.strip() for i in    # get rid of surrounding whitespace
+                      " ".join(filter(lambda x: not x.strip().startswith('#'),
+                                      lines)
+                              ).split(" ")])
+
+    # Use a parser that specifically only supports those options that
+    # we want to support within a config file (as opposed to all the
+    # options available through the command line interface).
+    parser = argparse.ArgumentParser(add_help=False)
+    Config.setup_arguments(parser)
+    config, unprocessed = parser.parse_known_args(args)
+    if unprocessed:
+        raise CommandError("unsupported config values: %s" % ' '.join(unprocessed))
+
+    # Post process the config: Paths in the config file should be relative
+    # to the config location, not the current working directory.
+    if filename:
+        Config.rebase_paths(config, path.dirname(filename))
+
+    return config
+
+
+def make_env_and_writer(argv):
+    """Given the command line arguments in ``argv``, construct an
+    environment.
+
+    This entails everything from parsing the command line, parsing
+    a config file, if there is one, merging the two etc.
+
+    Returns a 2-tuple (``Environment`` instance, ``Writer`` instance).
+    """
+
+    # Parse the command line arguments first. This is helpful in
+    # that any potential syntax errors there will cause us to
+    # fail before doing anything else.
+    options = parse_args(argv)
+
+    # Setup the writer verbosity threshold based on the options.
+    writer = Writer()
+    if options.verbose:
+        writer.verbosity = 3
+    elif options.quiet:
+        writer.verbosity = 1
+    else:
+        writer.verbosity = 2
+
+    env = Environment(writer)
+
+    # Try to load a config file, either if given at the command line,
+    # or the one that was automatically found. Note that even if a
+    # config file is used, using the default paths is still supported.
+    # That is, you can provide some extra configuration values
+    # through a file, potentially shared across multiple projects, and
+    # still rely on simply calling the script inside a default
+    # project's directory hierarchy.
+    config_file = None
+    if options.config:
+        config_file = options.config
+        env.config_file = config_file
+    elif env.config_file:
+        config_file = env.config_file
+        writer.action('info', "Using auto-detected config file: %s"  % config_file)
+    if config_file:
+        env.pop_from_config(read_config(config_file))
+
+    # Now that we have applied the config file, also apply the command
+    # line options. Those will thus override the config values.
+    env.pop_from_options(options)
+
+    # Some paths, if we still don't have values for them, can be deducted
+    # from the project directory.
+    env.auto_paths()
+    if env.auto_gettext_dir or env.auto_resource_dir:
+        # Let the user know we are deducting information from the
+        # project that we found.
+        writer.action('info',
+                      "Assuming default directory structure in %s" % env.project_dir)
+
+    # Initialize the environment. This mainly loads the list of
+    # languages, but also does some basic validation.
+    try:
+        env.init()
+    except IncompleteEnvironment:
+        if not env.project_dir:
+            if not env.config_file:
+                raise CommandError('You need to run this from inside an '
+                    'Android project directory, or specify the source and '
+                    'target directories manually, either as command line '
+                    'options, or through a configuration file')
+            else:
+                raise CommandError('Your configuration file does not specify '
+                    'the source and target directory, and you are not running '
+                    'the script from inside an Android project directory.')
+    except EnvironmentError as e:
+        raise CommandError(e)
+
+    # We're done. Just print some info out for the user.
+    writer.action('info',
+                  "Using as Android resource dir: %s" % env.resource_dir)
+    writer.action('info', "Using as gettext dir: %s" % env.gettext_dir)
+
+    return env, writer
+
+
+def main(argv):
+    """The program.
+
+    Returns an error code or None.
+    """
+    try:
+        # Build an environment from the list of arguments.
+        env, writer = make_env_and_writer(argv)
+        try:
+            cmd = COMMANDS[env.options.command](env, writer)
+            command_result = cmd.execute()
+        finally:
+            writer.finish()
+        return 1 if writer.erroneous else 0
+    except CommandError as e:
+        print('Error:', e)
+        return 2
+
+
+def run():  # pragma: no cover
+    """Simplified interface to main().
+    """
+    sys.exit(main(sys.argv) or 0)
diff --git a/focus-android/tools/l10n/android2po/utils.py b/focus-android/tools/l10n/android2po/utils.py
new file mode 100644
index 000000000000..b64df12b0a32
--- /dev/null
+++ b/focus-android/tools/l10n/android2po/utils.py
@@ -0,0 +1,332 @@
+from __future__ import absolute_import
+from __future__ import unicode_literals
+
+import os, sys, re, uuid, locale
+import codecs
+try:
+    from hashlib import md5
+except ImportError:  # pragma: no cover
+   import md5
+from os import path
+from termcolor import colored
+
+
+__all__ = ('Path', 'Writer', 'file_md5', 'format_to_re',)
+
+
+def format_to_re(format):
+    """Return the regular expression that matches all possible values
+    the given Python 2 format string (using %(foo)s placeholders) can
+    possibly resolve to.
+
+    Each placeholder in the format string is captured in a named group.
+
+    The difficult part here is inserting unescaped regular expression
+    syntax in place of the format variables, while still properly
+    escaping the rest.
+
+    See this link for more info on the problem:
+    http://stackoverflow.com/questions/2654856/python-convert-format-string-to-regular-expression
+    """
+    UNIQ = uuid.uuid1().hex
+    assert UNIQ not in format
+    class MarkPlaceholders(dict):
+        def __getitem__(self, key):
+            return UNIQ+('(?P<%s>.*?)'%key)+UNIQ
+    parts = (format % MarkPlaceholders()).split(UNIQ)
+    for i in range(0, len(parts), 2):
+        parts[i] = re.escape(parts[i])
+    return ''.join(parts)
+
+
+def file_md5(filename):
+    """Generate the md5 hash of the given file.
+    """
+    h = md5()
+    f = open(filename, 'rb')
+    try:
+        while True:
+            # 128 is the md5 digest blocksize
+            data = f.read(128*10)
+            if not data:
+                break
+            h.update(data)
+        return h.digest()
+    finally:
+        f.close()
+
+
+class Path(str):
+    """Helper representing a filesystem path that can be "bound" to a base
+    path. You can then ask it to render as a relative path to that base.
+    """
+
+    def __new__(self, *parts, **kwargs):
+        base = kwargs.pop('base', None)
+        if kwargs:
+            raise TypeError()
+        self.base = base
+        abs = path.normpath(path.abspath(path.join(*parts)))
+        return str.__new__(self, abs)
+
+    @property
+    def rel(self):
+        """Return this path relative to the base it was bound to.
+        """
+        base =  self.base or os.getcwd()
+        if not hasattr(path, 'relpath'):  # pragma: no cover
+            # Python < 2.6 doesn't have relpath, and I don't want
+            # to bother with a wbole bunch of code for this. See
+            # if we can simply remove the prefix, and if not, 2.5
+            # users will have to live with the absolute path.
+            if self.path.startswith(base):
+                return self.path[len(base)+1:]
+            return self.abs
+        return path.relpath(self, start=base)
+
+    @property
+    def abs(self):
+        return self
+
+    def exists(self):
+        return path.exists(self)
+
+    @property
+    def dir(self):
+        return Path(path.dirname(self), base=self.base)
+
+    def hash(self):
+        return file_md5(self)
+
+
+class Writer():
+    """Helps printing messages to the output, in a very particular form.
+
+    Supported are two concepts, "actions" and "messages". A message is
+    always the child of an action. There is a limited set of action
+    types (we call them events). Each event and each message may have a
+    "severity". The severity can determine how a message or event is
+    rendered (if the terminals supports colors), and will also affect
+    whether a action or message is rendered at all, depending on verbosity
+    settings.
+
+    If a message exceeds it's action in severity causing the message to
+    be visible but the action not, the action will forcably be rendered as
+    well. For this reason, the class keeps track of the last message that
+    should have been printed.
+
+    There is also a mechanism which allows to delay printing an action.
+    That is, you may begin constructing an action and collecting it's
+    messages, and only later print it out. You would want to do this if
+    the event type can only be determined after the action is completed,
+    since it often indicates the outcome.
+    """
+
+    # Action types and their default levels
+    EVENTS = {
+        'info': 'info',
+        'mkdir': 'default',
+        'updated': 'default',
+        'unchanged': 'default',
+        'skipped': 'warning',
+        'created': 'default',
+        'exists': 'default',
+        'failed': 'error',}
+
+    # Levels and the minimum verbosity required to show them
+    LEVELS = {'default': 2, 'warning': 1, 'error': 0, 'info': 3}
+
+    # +2 for [ and ]
+    # +1 for additional left padding
+    max_event_len = max([len(k) for k in list(EVENTS.keys())]) + 2 + 1
+
+    class Action(dict):
+        def __init__(self, writer, *more, **data):
+            self.writer = writer
+            self.messages = []
+            self.is_done = False
+            self.awaiting_promotion = False
+            dict.__init__(self, {'text': '', 'status': None, 'severity': None})
+            self.update(*more, **data)
+
+        def __setitem__(self, name, value):
+            if name == 'severity':
+                assert value in Writer.LEVELS, 'Not a valid severity value'
+            dict.__setitem__(self, name, value)
+
+        def done(self, event, *more, **data):
+            """Mark this action as done. This will cause it and it's
+            current messages to be printed, provided they pass the
+            verbosity threshold, of course.
+            """
+            assert event in Writer.EVENTS, 'Not a valid event type'
+            self['event'] = event
+            self.update(*more, **data)
+            self.writer._print_action(self)
+            if self in self.writer._pending_actions:
+                self.writer._pending_actions.remove(self)
+            self.is_done = True
+            if self.severity == 'error':
+                self.writer.erroneous = True
+
+        def update(self, text=None, severity=None, **more_data):
+            """Update the message with the given data.
+            """
+            if text:
+                self['text'] = text
+            if severity:
+                self['severity'] = severity
+            dict.update(self, **more_data)
+
+        def message(self, message, severity='info'):
+            """Print a message belonging to this action.
+
+            If the action is not yet done, this will be added to
+            an internal queue.
+
+            If the action is done, but was not printed because it didn't
+            pass the verbosity threshold, it will be printed now.
+
+            By default, all messages use a loglevel of 'info'.
+            """
+            is_allowed = self.writer.allowed(severity)
+            if severity == 'error':
+                self.writer.erroneous = True
+            if not self.is_done:
+                if is_allowed:
+                    self.messages.append((message, severity))
+            elif is_allowed:
+                if self.awaiting_promotion:
+                    self.writer._print_action(self, force=True)
+                self.writer._print_message(message, severity)
+
+        @property
+        def event(self):
+            return self['event']
+
+        @property
+        def severity(self):
+            sev = self['severity']
+            if not sev:
+                sev = Writer.EVENTS[self.event]
+            return sev
+
+    def __init__(self, verbosity=LEVELS['default']):
+        self._current_action = None
+        self._pending_actions = []
+        self.verbosity = verbosity
+        self.erroneous = False
+
+        # Create a codec writer wrapping stdout
+        isatty = sys.stdout.isatty() \
+            if hasattr(sys.stdout, 'isatty') else False
+        self.stdout = codecs.getwriter(
+            sys.stdout.encoding
+                if isatty
+                else locale.getpreferredencoding())(sys.stdout)
+
+    def action(self, event, *a, **kw):
+        action = Writer.Action(self, *a, **kw)
+        action.done(event)
+        return action
+
+    def begin(self, *a, **kw):
+        """Begin a new action, and return it. The action will not be
+        printed until you call ``done()`` on it.
+
+        In the meantime, you can attach message to it though, which will
+        be printed together with the action once it is "done".
+        """
+        action = Writer.Action(self, *a, **kw)
+        self._pending_actions.append(action)
+        return action
+
+    def message(self, *a, **kw):
+        """Attach a message to the last action to be completed. This
+        includes actions that have not yet been printed (due to not
+        passing the threshold), but does not include actions that are
+        not yet marked as 'done'.
+        """
+        self._current_action.message(*a, **kw)
+
+    def finish(self):
+        """Close down all pending actions that have been began(), but
+        are not yet done.
+
+        Not the sibling of begin()!
+        """
+        for action in self._pending_actions:
+            if not action.is_done:
+                action.done('failed')
+        self._pending_actions = []
+
+    def allowed(self, severity):
+        """Return ``True`` if mesages with this severity pass
+        the current verbosity threshold.
+        """
+        return self.verbosity >= self.LEVELS[severity]
+
+    def _get_style_for_level(self, severity):
+        """Return a dict that can be passed as **kwargs to colored().
+        """
+        # Other colors that work moderately well on both dark and
+        # light backgrounds and aren't yet used: cyan, green
+        return {
+            'default': {'color': 'blue'},
+            'info': {},
+            'warning': {'color': 'magenta'},
+            'error': {'color': 'red'},
+        }.get(severity, {})
+
+    def get_style_for_action(self, action):
+        """First looks at the event type to determine a style, then
+        falls back to severity for good measure.
+        """
+        try:
+            return {
+                'info': {},   # alyways render info in default
+                'exists': {'color': 'blue'}
+            }[action.event]
+        except KeyError:
+            return self._get_style_for_level(action.severity)
+
+    def _print_action(self, action, force=False):
+        """Print the action and all it's attached messages.
+        """
+        if force or self.allowed(action.severity) or action.messages:
+            self._print_action_header(action)
+            for m, severity in action.messages:
+                self._print_message(m, severity)
+            action.awaiting_promotion = False
+        else:
+            # Indicates that this message has not been printed yet,
+            # and is waiting for a dependent message that needs to
+            # be printed to trigger it.
+            action.awaiting_promotion = True
+        self._current_action = action
+
+    def _print_action_header(self, action):
+        text = action['text']
+        status = action['status']
+        if isinstance(text, Path):
+            # Handle Path instances manually. This doesn't happen
+            # automatically because we haven't figur out how to make
+            # that class represent itself through the relative path
+            # by default, while still returning the full path if it
+            # is used, say, during an open() operation.
+            text = text.rel
+        if status:
+            text = "%s (%s)" % (text, status)
+        tag = "[%s]" % action['event']
+
+        style = self.get_style_for_action(action)
+        self.stdout.write(colored("%*s" % (self.max_event_len, tag), attrs=['bold',], **style))
+        self.stdout.write(" ")
+        self.stdout.write(colored(text, **style))
+        self.stdout.write("\n")
+
+    def _print_message(self, message, severity):
+        style = self._get_style_for_level(severity)
+        self.stdout.write(colored(" "*(self.max_event_len+1) + "- %s" % message,
+                          **style))
+        self.stdout.write("\n")
