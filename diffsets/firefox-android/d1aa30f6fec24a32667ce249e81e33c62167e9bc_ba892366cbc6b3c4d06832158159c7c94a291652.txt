diff --git a/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkController.kt b/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkController.kt
index 1e45c8beed6e..2b6915bd8328 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkController.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkController.kt
@@ -76,7 +76,6 @@ class DefaultBookmarkController(
     private val showSnackbar: (String) -> Unit,
     private val deleteBookmarkNodes: (Set<BookmarkNode>, BookmarkRemoveType) -> Unit,
     private val deleteBookmarkFolder: (Set<BookmarkNode>) -> Unit,
-    private val invokePendingDeletion: () -> Unit,
     private val showTabTray: () -> Unit
 ) : BookmarkController {
 
@@ -103,7 +102,6 @@ class DefaultBookmarkController(
 
     override fun handleBookmarkExpand(folder: BookmarkNode) {
         handleAllBookmarksDeselected()
-        invokePendingDeletion.invoke()
         scope.launch {
             val node = loadBookmarkNode.invoke(folder.guid) ?: return@launch
             sharedViewModel.selectedFolder = node
@@ -169,7 +167,6 @@ class DefaultBookmarkController(
     override fun handleRequestSync() {
         scope.launch {
             store.dispatch(BookmarkFragmentAction.StartSync)
-            invokePendingDeletion()
             activity.components.backgroundServices.accountManager.syncNow(SyncReason.User)
             // The current bookmark node we are viewing may be made invalid after syncing so we
             // check if the current node is valid and if it isn't we find the nearest valid ancestor
@@ -184,7 +181,6 @@ class DefaultBookmarkController(
     }
 
     override fun handleBackPressed() {
-        invokePendingDeletion.invoke()
         scope.launch {
             val parentGuid = store.state.guidBackstack.findLast { guid ->
                 store.state.tree?.guid != guid && activity.bookmarkStorage.getBookmark(guid) != null
@@ -211,7 +207,6 @@ class DefaultBookmarkController(
         mode: BrowsingMode,
         flags: EngineSession.LoadUrlFlags = EngineSession.LoadUrlFlags.none()
     ) {
-        invokePendingDeletion.invoke()
         with(activity) {
             browsingModeManager.mode = mode
             openToBrowserAndLoad(searchTermOrURL, newTab, from, flags = flags)
@@ -222,13 +217,11 @@ class DefaultBookmarkController(
         url: String,
         mode: BrowsingMode
     ) {
-        invokePendingDeletion.invoke()
         activity.browsingModeManager.mode = BrowsingMode.fromBoolean(mode == BrowsingMode.Private)
         tabsUseCases?.addTab?.invoke(url, private = (mode == BrowsingMode.Private))
     }
 
     private fun navigateToGivenDirection(directions: NavDirections) {
-        invokePendingDeletion.invoke()
         navController.nav(R.id.bookmarkFragment, directions)
     }
 }
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkFragment.kt
index fe9cd34a9986..c6a48a3e4b2e 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/library/bookmarks/BookmarkFragment.kt
@@ -4,6 +4,7 @@
 
 package org.mozilla.fenix.library.bookmarks
 
+import android.content.Context
 import android.content.DialogInterface
 import android.os.Bundle
 import android.text.SpannableString
@@ -24,6 +25,7 @@ import androidx.navigation.fragment.navArgs
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers.IO
 import kotlinx.coroutines.Dispatchers.Main
+import kotlinx.coroutines.MainScope
 import kotlinx.coroutines.async
 import kotlinx.coroutines.awaitAll
 import kotlinx.coroutines.isActive
@@ -46,6 +48,7 @@ import org.mozilla.fenix.components.StoreProvider
 import org.mozilla.fenix.databinding.FragmentBookmarkBinding
 import org.mozilla.fenix.ext.bookmarkStorage
 import org.mozilla.fenix.ext.components
+import org.mozilla.fenix.ext.getRootView
 import org.mozilla.fenix.ext.minus
 import org.mozilla.fenix.ext.nav
 import org.mozilla.fenix.ext.requireComponents
@@ -69,7 +72,6 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
     private val sharedViewModel: BookmarksSharedViewModel by activityViewModels()
     private val desktopFolders by lazy { DesktopFolders(requireContext(), showMobileRoot = false) }
 
-    private var pendingBookmarkDeletionJob: (suspend () -> Unit)? = null
     private var pendingBookmarksToDelete: MutableSet<BookmarkNode> = mutableSetOf()
 
     private var _binding: FragmentBookmarkBinding? = null
@@ -80,7 +82,11 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
 
     override val selectedItems get() = bookmarkStore.state.mode.selectedItems
 
-    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View {
         _binding = FragmentBookmarkBinding.inflate(inflater, container, false)
 
         bookmarkStore = StoreProvider.get(this) {
@@ -100,7 +106,6 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
                 showSnackbar = ::showSnackBarWithText,
                 deleteBookmarkNodes = ::deleteMulti,
                 deleteBookmarkFolder = ::showRemoveFolderDialog,
-                invokePendingDeletion = ::invokePendingDeletion,
                 showTabTray = ::showTabTray
             ),
             metrics = metrics!!
@@ -210,7 +215,6 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
                 true
             }
             R.id.close_bookmarks -> {
-                invokePendingDeletion()
                 close()
                 true
             }
@@ -255,12 +259,10 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
     }
 
     private fun showTabTray() {
-        invokePendingDeletion()
         navigateToBookmarkFragment(BookmarkFragmentDirections.actionGlobalTabsTrayFragment())
     }
 
     private fun navigateToBookmarkFragment(directions: NavDirections) {
-        invokePendingDeletion()
         findNavController().nav(
             R.id.bookmarkFragment,
             directions
@@ -268,7 +270,6 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
     }
 
     override fun onBackPressed(): Boolean {
-        invokePendingDeletion()
         sharedViewModel.selectedFolder = null
         return bookmarkView.onBackPressed()
     }
@@ -294,21 +295,10 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
             }
     }
 
-    override fun onPause() {
-        invokePendingDeletion()
-        super.onPause()
-    }
-
-    private suspend fun deleteSelectedBookmarks(selected: Set<BookmarkNode>) {
-        CoroutineScope(IO).launch {
-            val tempStorage = context?.bookmarkStorage
-            selected.map {
-                async { tempStorage?.deleteNode(it.guid) }
-            }.awaitAll()
-        }
-    }
-
-    private fun deleteMulti(selected: Set<BookmarkNode>, eventType: BookmarkRemoveType = BookmarkRemoveType.MULTIPLE) {
+    private fun deleteMulti(
+        selected: Set<BookmarkNode>,
+        eventType: BookmarkRemoveType = BookmarkRemoveType.MULTIPLE
+    ) {
         selected.iterator().forEach {
             if (it.type == BookmarkNodeType.FOLDER) {
                 showRemoveFolderDialog(selected)
@@ -317,8 +307,6 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
         }
         updatePendingBookmarksToDelete(selected)
 
-        pendingBookmarkDeletionJob = getDeleteOperation(eventType)
-
         val message = when (eventType) {
             BookmarkRemoveType.MULTIPLE -> {
                 getRemoveBookmarksSnackBarMessage(selected, containsFolders = false)
@@ -328,13 +316,15 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
                 val bookmarkNode = selected.first()
                 getString(
                     R.string.bookmark_deletion_snackbar_message,
-                    bookmarkNode.url?.toShortUrl(requireContext().components.publicSuffixList) ?: bookmarkNode.title
+                    bookmarkNode.url?.toShortUrl(requireContext().components.publicSuffixList)
+                        ?: bookmarkNode.title
                 )
             }
         }
 
-        viewLifecycleOwner.lifecycleScope.allowUndo(
-            requireView(), message,
+        MainScope().allowUndo(
+            requireActivity().getRootView()!!,
+            message,
             getString(R.string.bookmark_undo_deletion),
             {
                 undoPendingDeletion(selected)
@@ -365,7 +355,10 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
 
     private fun getDialogConfirmationMessage(selected: Set<BookmarkNode>): String {
         return if (selected.size > 1) {
-            getString(R.string.bookmark_delete_multiple_folders_confirmation_dialog, getString(R.string.app_name))
+            getString(
+                R.string.bookmark_delete_multiple_folders_confirmation_dialog,
+                getString(R.string.app_name)
+            )
         } else {
             getString(R.string.bookmark_delete_folder_confirmation_dialog)
         }
@@ -387,12 +380,12 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
                 }
                 setPositiveButton(R.string.delete_browsing_data_prompt_allow) { dialog: DialogInterface, _ ->
                     updatePendingBookmarksToDelete(selected)
-                    pendingBookmarkDeletionJob = getDeleteOperation(BookmarkRemoveType.FOLDER)
                     dialog.dismiss()
-                    val snackbarMessage = getRemoveBookmarksSnackBarMessage(selected, containsFolders = true)
+                    val snackbarMessage =
+                        getRemoveBookmarksSnackBarMessage(selected, containsFolders = true)
                     // Use fragment's lifecycle; the view may be gone by the time dialog is interacted with.
-                    lifecycleScope.allowUndo(
-                        requireView(),
+                    MainScope().allowUndo(
+                        requireActivity().getRootView()!!,
                         snackbarMessage,
                         getString(R.string.bookmark_undo_deletion),
                         {
@@ -416,14 +409,16 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
 
     private suspend fun undoPendingDeletion(selected: Set<BookmarkNode>) {
         pendingBookmarksToDelete.removeAll(selected)
-        pendingBookmarkDeletionJob = null
         refreshBookmarks()
     }
 
-    private fun getDeleteOperation(event: BookmarkRemoveType): (suspend () -> Unit) {
-        return {
-            deleteSelectedBookmarks(pendingBookmarksToDelete)
-            pendingBookmarkDeletionJob = null
+    private fun getDeleteOperation(event: BookmarkRemoveType): (suspend (context: Context) -> Unit) {
+        return { context ->
+            CoroutineScope(IO).launch {
+                pendingBookmarksToDelete.map {
+                    async { context.bookmarkStorage.deleteNode(it.guid) }
+                }.awaitAll()
+            }
             when (event) {
                 BookmarkRemoveType.FOLDER ->
                     BookmarksManagement.folderRemove.record(NoExtras())
@@ -435,14 +430,4 @@ class BookmarkFragment : LibraryPageFragment<BookmarkNode>(), UserInteractionHan
             refreshBookmarks()
         }
     }
-
-    private fun invokePendingDeletion() {
-        pendingBookmarkDeletionJob?.let {
-            viewLifecycleOwner.lifecycleScope.launch {
-                it.invoke()
-            }.invokeOnCompletion {
-                pendingBookmarkDeletionJob = null
-            }
-        }
-    }
 }
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/library/downloads/DownloadFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/library/downloads/DownloadFragment.kt
index 763bc9e6066a..5bd5579a3676 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/library/downloads/DownloadFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/library/downloads/DownloadFragment.kt
@@ -4,6 +4,7 @@
 
 package org.mozilla.fenix.library.downloads
 
+import android.content.Context
 import android.os.Bundle
 import android.text.SpannableString
 import android.view.LayoutInflater
@@ -13,14 +14,13 @@ import android.view.MenuItem
 import android.view.View
 import android.view.ViewGroup
 import androidx.annotation.VisibleForTesting
-import androidx.lifecycle.lifecycleScope
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers.IO
+import kotlinx.coroutines.MainScope
 import mozilla.components.browser.state.state.BrowserState
 import kotlinx.coroutines.launch
 import mozilla.components.browser.state.state.content.DownloadState
 import mozilla.components.feature.downloads.AbstractFetchDownloadService
-import mozilla.components.feature.downloads.DownloadsUseCases
 import mozilla.components.lib.state.ext.consumeFrom
 import mozilla.components.support.base.feature.UserInteractionHandler
 import org.mozilla.fenix.HomeActivity
@@ -33,6 +33,7 @@ import org.mozilla.fenix.ext.filterNotExistsOnDisk
 import org.mozilla.fenix.ext.requireComponents
 import org.mozilla.fenix.ext.setTextColor
 import org.mozilla.fenix.ext.showToolbar
+import org.mozilla.fenix.ext.getRootView
 import org.mozilla.fenix.library.LibraryPageFragment
 import org.mozilla.fenix.utils.allowUndo
 
@@ -41,9 +42,6 @@ class DownloadFragment : LibraryPageFragment<DownloadItem>(), UserInteractionHan
     private lateinit var downloadStore: DownloadFragmentStore
     private lateinit var downloadView: DownloadView
     private lateinit var downloadInteractor: DownloadInteractor
-    private var undoScope: CoroutineScope? = null
-    private var pendingDownloadDeletionJob: (suspend () -> Unit)? = null
-    private lateinit var downloadsUseCases: DownloadsUseCases
 
     private var _binding: FragmentDownloadsBinding? = null
     private val binding get() = _binding!!
@@ -56,7 +54,6 @@ class DownloadFragment : LibraryPageFragment<DownloadItem>(), UserInteractionHan
         _binding = FragmentDownloadsBinding.inflate(inflater, container, false)
 
         val items = provideDownloads(requireComponents.core.store.state)
-        downloadsUseCases = requireContext().components.useCases.downloadUseCases
 
         downloadStore = StoreProvider.get(this) {
             DownloadFragmentStore(
@@ -128,15 +125,14 @@ class DownloadFragment : LibraryPageFragment<DownloadItem>(), UserInteractionHan
      */
     private fun deleteDownloadItems(items: Set<DownloadItem>) {
         updatePendingDownloadToDelete(items)
-        undoScope = CoroutineScope(IO)
-        undoScope?.allowUndo(
-            requireView(),
+        MainScope().allowUndo(
+            requireActivity().getRootView()!!,
             getMultiSelectSnackBarMessage(items),
             getString(R.string.bookmark_undo_deletion),
             onCancel = {
                 undoPendingDeletion(items)
             },
-            operation = getDeleteDownloadItemsOperation(downloadsUseCases, items)
+            operation = getDeleteDownloadItemsOperation(items)
         )
     }
 
@@ -203,13 +199,7 @@ class DownloadFragment : LibraryPageFragment<DownloadItem>(), UserInteractionHan
         }
     }
 
-    override fun onPause() {
-        invokePendingDeletion()
-        super.onPause()
-    }
-
     override fun onBackPressed(): Boolean {
-        invokePendingDeletion()
         return downloadView.onBackPressed()
     }
 
@@ -236,53 +226,29 @@ class DownloadFragment : LibraryPageFragment<DownloadItem>(), UserInteractionHan
         }
     }
 
-    /**
-     * Launches the coroutine to delete the provided [items].
-     */
     private fun getDeleteDownloadItemsOperation(
-        downloadUseCases: DownloadsUseCases,
         items: Set<DownloadItem>
-    ): (suspend () -> Unit) {
-        return {
+    ): (suspend (context: Context) -> Unit) {
+        return { context ->
             CoroutineScope(IO).launch {
                 downloadStore.dispatch(DownloadFragmentAction.EnterDeletionMode)
-                for (item in items) {
-                    downloadUseCases.removeDownload(item.id)
+                context.let {
+                    for (item in items) {
+                        it.components.useCases.downloadUseCases.removeDownload(item.id)
+                    }
                 }
                 downloadStore.dispatch(DownloadFragmentAction.ExitDeletionMode)
-                pendingDownloadDeletionJob = null
             }
         }
     }
 
-    /**
-     * Queues the [getDeleteDownloadItemsOperation] job in [pendingDownloadDeletionJob] in case
-     * the user exits the fragment and we need to quickly execute the queued deletion.
-     * And adds the [items] to be deleted to the list of [DownloadFragmentStore.pendingDeletionIds],
-     * which is used to determine what items to show and what items to hide from the user.
-     */
     private fun updatePendingDownloadToDelete(items: Set<DownloadItem>) {
-        pendingDownloadDeletionJob = getDeleteDownloadItemsOperation(downloadsUseCases, items)
         val ids = items.map { item -> item.id }.toSet()
         downloadStore.dispatch(DownloadFragmentAction.AddPendingDeletionSet(ids))
     }
 
     private fun undoPendingDeletion(items: Set<DownloadItem>) {
-        pendingDownloadDeletionJob = null
         val ids = items.map { item -> item.id }.toSet()
         downloadStore.dispatch(DownloadFragmentAction.UndoPendingDeletionSet(ids))
     }
-
-    /**
-     * Executes pending job(s) when leaving [DownloadFragment].
-     */
-    private fun invokePendingDeletion() {
-        pendingDownloadDeletionJob?.let {
-            viewLifecycleOwner.lifecycleScope.launch {
-                it.invoke()
-            }.invokeOnCompletion {
-                pendingDownloadDeletionJob = null
-            }
-        }
-    }
 }
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/library/history/HistoryFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/library/history/HistoryFragment.kt
index 93fbad58df99..575c5afd751e 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/library/history/HistoryFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/library/history/HistoryFragment.kt
@@ -4,6 +4,7 @@
 
 package org.mozilla.fenix.library.history
 
+import android.content.Context
 import android.content.DialogInterface
 import android.os.Bundle
 import android.text.SpannableString
@@ -51,6 +52,7 @@ import org.mozilla.fenix.ext.nav
 import org.mozilla.fenix.ext.requireComponents
 import org.mozilla.fenix.ext.setTextColor
 import org.mozilla.fenix.ext.toShortUrl
+import org.mozilla.fenix.ext.getRootView
 import org.mozilla.fenix.library.LibraryPageFragment
 import org.mozilla.fenix.utils.allowUndo
 import org.mozilla.fenix.GleanMetrics.History as GleanHistory
@@ -71,9 +73,6 @@ class HistoryFragment : LibraryPageFragment<History>(), UserInteractionHandler {
         )
     }.flow
 
-    private var undoScope: CoroutineScope? = null
-    private var pendingHistoryDeletionJob: (suspend () -> Unit)? = null
-
     private var _historyView: HistoryView? = null
     private val historyView: HistoryView
         get() = _historyView!!
@@ -148,9 +147,8 @@ class HistoryFragment : LibraryPageFragment<History>(), UserInteractionHandler {
 
     private fun deleteHistoryItems(items: Set<History>) {
         updatePendingHistoryToDelete(items)
-        undoScope = CoroutineScope(IO)
-        undoScope?.allowUndo(
-            requireView(),
+        CoroutineScope(IO).allowUndo(
+            requireActivity().getRootView()!!,
             getMultiSelectSnackBarMessage(items),
             getString(R.string.bookmark_undo_deletion),
             {
@@ -270,7 +268,6 @@ class HistoryFragment : LibraryPageFragment<History>(), UserInteractionHandler {
     }
 
     private fun showTabTray() {
-        invokePendingDeletion()
         findNavController().nav(
             R.id.historyFragment,
             HistoryFragmentDirections.actionGlobalTabsTrayFragment()
@@ -294,13 +291,7 @@ class HistoryFragment : LibraryPageFragment<History>(), UserInteractionHandler {
         }
     }
 
-    override fun onPause() {
-        invokePendingDeletion()
-        super.onPause()
-    }
-
     override fun onBackPressed(): Boolean {
-        invokePendingDeletion()
         return historyView.onBackPressed()
     }
 
@@ -365,63 +356,47 @@ class HistoryFragment : LibraryPageFragment<History>(), UserInteractionHandler {
     }
 
     private fun navigateToHistoryFragment(directions: NavDirections) {
-        invokePendingDeletion()
         findNavController().nav(
             R.id.historyFragment,
             directions
         )
     }
 
-    private fun getDeleteHistoryItemsOperation(items: Set<History>): (suspend () -> Unit) {
-        return {
+    private fun getDeleteHistoryItemsOperation(items: Set<History>): (suspend (context: Context) -> Unit) {
+        return { context ->
             CoroutineScope(IO).launch {
                 historyStore.dispatch(HistoryFragmentAction.EnterDeletionMode)
-                context?.components?.run {
-                    for (item in items) {
-                        GleanHistory.removed.record(NoExtras())
-
-                        when (item) {
-                            is History.Regular -> core.historyStorage.deleteVisitsFor(item.url)
-                            is History.Group -> {
-                                // NB: If we have non-search groups, this logic needs to be updated.
-                                historyProvider.deleteMetadataSearchGroup(item)
-                                core.store.dispatch(
-                                    HistoryMetadataAction.DisbandSearchGroupAction(searchTerm = item.title)
-                                )
-                            }
-                            // We won't encounter individual metadata entries outside of groups.
-                            is History.Metadata -> {}
+                for (item in items) {
+                    GleanHistory.removed.record(NoExtras())
+
+                    when (item) {
+                        is History.Regular -> context.components.core.historyStorage.deleteVisitsFor(item.url)
+                        is History.Group -> {
+                            // NB: If we have non-search groups, this logic needs to be updated.
+                            historyProvider.deleteMetadataSearchGroup(item)
+                            context.components.core.store.dispatch(
+                                HistoryMetadataAction.DisbandSearchGroupAction(searchTerm = item.title)
+                            )
                         }
+                        // We won't encounter individual metadata entries outside of groups.
+                        is History.Metadata -> {}
                     }
                 }
                 historyStore.dispatch(HistoryFragmentAction.ExitDeletionMode)
-                pendingHistoryDeletionJob = null
             }
         }
     }
 
     private fun updatePendingHistoryToDelete(items: Set<History>) {
-        pendingHistoryDeletionJob = getDeleteHistoryItemsOperation(items)
         val ids = items.map { item -> item.visitedAt }.toSet()
         historyStore.dispatch(HistoryFragmentAction.AddPendingDeletionSet(ids))
     }
 
     private fun undoPendingDeletion(items: Set<History>) {
-        pendingHistoryDeletionJob = null
         val ids = items.map { item -> item.visitedAt }.toSet()
         historyStore.dispatch(HistoryFragmentAction.UndoPendingDeletionSet(ids))
     }
 
-    private fun invokePendingDeletion() {
-        pendingHistoryDeletionJob?.let {
-            viewLifecycleOwner.lifecycleScope.launch {
-                it.invoke()
-            }.invokeOnCompletion {
-                pendingHistoryDeletionJob = null
-            }
-        }
-    }
-
     private suspend fun syncHistory() {
         val accountManager = requireComponents.backgroundServices.accountManager
         accountManager.syncNow(SyncReason.User)
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/utils/Undo.kt b/fenix/app/src/main/java/org/mozilla/fenix/utils/Undo.kt
index 7ba20701b66b..a9f2116407f8 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/utils/Undo.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/utils/Undo.kt
@@ -51,7 +51,7 @@ fun CoroutineScope.allowUndo(
     message: String,
     undoActionTitle: String,
     onCancel: suspend () -> Unit = {},
-    operation: suspend () -> Unit,
+    operation: suspend (context: Context) -> Unit,
     anchorView: View? = null,
     elevation: Float? = null,
     paddedForBottomToolbar: Boolean = false
@@ -111,7 +111,7 @@ fun CoroutineScope.allowUndo(
 
             if (!requestedUndo.get()) {
                 snackbar.dismiss()
-                operation.invoke()
+                operation.invoke(view.context)
             }
         }
     }
diff --git a/fenix/app/src/test/java/org/mozilla/fenix/library/bookmarks/BookmarkControllerTest.kt b/fenix/app/src/test/java/org/mozilla/fenix/library/bookmarks/BookmarkControllerTest.kt
index a683353d9aa8..9b93b125c4c6 100644
--- a/fenix/app/src/test/java/org/mozilla/fenix/library/bookmarks/BookmarkControllerTest.kt
+++ b/fenix/app/src/test/java/org/mozilla/fenix/library/bookmarks/BookmarkControllerTest.kt
@@ -116,16 +116,10 @@ class BookmarkControllerTest {
 
     @Test
     fun `WHEN handleBookmarkTapped is called with BrowserFragment THEN load the bookmark in current tab`() {
-        var invokePendingDeletionInvoked = false
         val flags = EngineSession.LoadUrlFlags.select(EngineSession.LoadUrlFlags.ALLOW_JAVASCRIPT_URL)
 
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkTapped(item)
+        createController().handleBookmarkTapped(item)
 
-        assertTrue(invokePendingDeletionInvoked)
         verify {
             homeActivity.openToBrowserAndLoad(
                 item.url!!,
@@ -138,18 +132,12 @@ class BookmarkControllerTest {
 
     @Test
     fun `WHEN handleBookmarkTapped is called with HomeFragment THEN load the bookmark in new tab`() {
-        var invokePendingDeletionInvoked = false
         val flags = EngineSession.LoadUrlFlags.select(EngineSession.LoadUrlFlags.ALLOW_JAVASCRIPT_URL)
 
         every { navDestination.id } returns R.id.homeFragment
 
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkTapped(item)
+        createController().handleBookmarkTapped(item)
 
-        assertTrue(invokePendingDeletionInvoked)
         verify {
             homeActivity.openToBrowserAndLoad(
                 item.url!!,
@@ -162,17 +150,11 @@ class BookmarkControllerTest {
 
     @Test
     fun `WHEN handleBookmarkTapped is called with private browsing THEN load the bookmark in new tab`() {
-        var invokePendingDeletionInvoked = false
         every { homeActivity.browsingModeManager.mode } returns BrowsingMode.Private
         val flags = EngineSession.LoadUrlFlags.select(EngineSession.LoadUrlFlags.ALLOW_JAVASCRIPT_URL)
 
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkTapped(item)
+        createController().handleBookmarkTapped(item)
 
-        assertTrue(invokePendingDeletionInvoked)
         verify {
             homeActivity.openToBrowserAndLoad(
                 item.url!!,
@@ -199,18 +181,6 @@ class BookmarkControllerTest {
         assertEquals(BrowsingMode.Private, homeActivity.browsingModeManager.mode)
     }
 
-    @Test
-    fun `handleBookmarkExpand clears selection and invokes pending deletions`() {
-        var invokePendingDeletionInvoked = false
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkExpand(tree)
-
-        assertTrue(invokePendingDeletionInvoked)
-    }
-
     @Test
     fun `handleBookmarkExpand should refresh and change the active bookmark node`() {
         var loadBookmarkNodeInvoked = false
@@ -239,14 +209,8 @@ class BookmarkControllerTest {
 
     @Test
     fun `handleBookmarkEdit should navigate to the 'Edit' fragment`() {
-        var invokePendingDeletionInvoked = false
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkEdit(item)
+        createController().handleBookmarkEdit(item)
 
-        assertTrue(invokePendingDeletionInvoked)
         verify {
             navController.navigate(
                 BookmarkFragmentDirections.actionBookmarkFragmentToBookmarkEditFragment(
@@ -328,17 +292,11 @@ class BookmarkControllerTest {
 
     @Test
     fun `handleBookmarkTapped should open the bookmark`() {
-        var invokePendingDeletionInvoked = false
         val flags =
             EngineSession.LoadUrlFlags.select(EngineSession.LoadUrlFlags.ALLOW_JAVASCRIPT_URL)
 
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBookmarkTapped(item)
+        createController().handleBookmarkTapped(item)
 
-        assertTrue(invokePendingDeletionInvoked)
         verify {
             homeActivity.openToBrowserAndLoad(
                 item.url!!,
@@ -351,18 +309,13 @@ class BookmarkControllerTest {
 
     @Test
     fun `handleOpeningBookmark should open the bookmark a new 'Normal' tab`() {
-        var invokePendingDeletionInvoked = false
         var showTabTrayInvoked = false
         createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            },
             showTabTray = {
                 showTabTrayInvoked = true
             }
         ).handleOpeningBookmark(item, BrowsingMode.Normal)
 
-        assertTrue(invokePendingDeletionInvoked)
         assertTrue(showTabTrayInvoked)
         verifyOrder {
             homeActivity.browsingModeManager.mode = BrowsingMode.Normal
@@ -372,18 +325,13 @@ class BookmarkControllerTest {
 
     @Test
     fun `handleOpeningBookmark should open the bookmark a new 'Private' tab`() {
-        var invokePendingDeletionInvoked = false
         var showTabTrayInvoked = false
         createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            },
             showTabTray = {
                 showTabTrayInvoked = true
             }
         ).handleOpeningBookmark(item, BrowsingMode.Private)
 
-        assertTrue(invokePendingDeletionInvoked)
         assertTrue(showTabTrayInvoked)
         verifyOrder {
             homeActivity.browsingModeManager.mode = BrowsingMode.Private
@@ -450,14 +398,7 @@ class BookmarkControllerTest {
         every { bookmarkStore.state.guidBackstack } returns listOf(tree.guid)
         every { bookmarkStore.state.tree } returns tree
 
-        var invokePendingDeletionInvoked = false
-        createController(
-            invokePendingDeletion = {
-                invokePendingDeletionInvoked = true
-            }
-        ).handleBackPressed()
-
-        assertTrue(invokePendingDeletionInvoked)
+        createController().handleBackPressed()
 
         verify {
             navController.popBackStack()
@@ -482,7 +423,6 @@ class BookmarkControllerTest {
         showSnackbar: (String) -> Unit = { _ -> },
         deleteBookmarkNodes: (Set<BookmarkNode>, BookmarkRemoveType) -> Unit = { _, _ -> },
         deleteBookmarkFolder: (Set<BookmarkNode>) -> Unit = { _ -> },
-        invokePendingDeletion: () -> Unit = { },
         showTabTray: () -> Unit = { }
     ): BookmarkController {
         return DefaultBookmarkController(
@@ -497,7 +437,6 @@ class BookmarkControllerTest {
             showSnackbar = showSnackbar,
             deleteBookmarkNodes = deleteBookmarkNodes,
             deleteBookmarkFolder = deleteBookmarkFolder,
-            invokePendingDeletion = invokePendingDeletion,
             showTabTray = showTabTray
         )
     }
