diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FullScreenIntegration.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FullScreenIntegration.kt
index 857fef337668..61a3fbb63fb1 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FullScreenIntegration.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FullScreenIntegration.kt
@@ -9,6 +9,7 @@ import android.os.Build
 import android.view.View
 import android.view.WindowManager
 import androidx.annotation.RequiresApi
+import androidx.annotation.VisibleForTesting
 import mozilla.components.browser.state.store.BrowserStore
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.engine.EngineView
@@ -18,17 +19,26 @@ import mozilla.components.support.base.feature.LifecycleAwareFeature
 import mozilla.components.support.base.feature.UserInteractionHandler
 import org.mozilla.focus.ext.disableDynamicBehavior
 import org.mozilla.focus.ext.enableDynamicBehavior
+import org.mozilla.focus.ext.hide
+import org.mozilla.focus.ext.showAsFixed
+import org.mozilla.focus.utils.Settings
+import org.mozilla.focus.widget.FloatingEraseButton
+import org.mozilla.focus.widget.FloatingSessionsButton
 
 class FullScreenIntegration(
     val activity: Activity,
     val store: BrowserStore,
     tabId: String?,
     sessionUseCases: SessionUseCases,
+    private val settings: Settings,
     private val toolbarView: BrowserToolbar,
     private val statusBar: View,
-    private val engineView: EngineView
+    private val engineView: EngineView,
+    private val eraseFab: FloatingEraseButton,
+    private val sessionsFab: FloatingSessionsButton
 ) : LifecycleAwareFeature, UserInteractionHandler {
-    private val feature = FullScreenFeature(
+    @VisibleForTesting
+    internal var feature = FullScreenFeature(
         store,
         sessionUseCases,
         tabId,
@@ -44,17 +54,16 @@ class FullScreenIntegration(
         feature.stop()
     }
 
-    private fun fullScreenChanged(enabled: Boolean) {
+    @VisibleForTesting
+    internal fun fullScreenChanged(enabled: Boolean) {
         if (enabled) {
-            toolbarView.collapse()
-            toolbarView.disableDynamicBehavior(engineView)
+            enterBrowserFullscreen()
             statusBar.visibility = View.GONE
 
             switchToImmersiveMode()
         } else {
             statusBar.visibility = View.VISIBLE
-            toolbarView.enableDynamicBehavior(activity, engineView)
-            toolbarView.expand()
+            exitBrowserFullscreen()
 
             exitImmersiveModeIfNeeded()
         }
@@ -64,8 +73,9 @@ class FullScreenIntegration(
         return feature.onBackPressed()
     }
 
+    @VisibleForTesting
     @RequiresApi(Build.VERSION_CODES.P)
-    private fun viewportFitChanged(viewportFit: Int) {
+    internal fun viewportFitChanged(viewportFit: Int) {
         activity.window.attributes.layoutInDisplayCutoutMode = viewportFit
     }
 
@@ -74,7 +84,8 @@ class FullScreenIntegration(
      * the top of the screen. These transient system bars will overlay appâ€™s content, may have some
      * degree of transparency, and will automatically hide after a short timeout.
      */
-    private fun switchToImmersiveMode() {
+    @VisibleForTesting
+    internal fun switchToImmersiveMode() {
         val window = activity.window
         window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
         @Suppress("DEPRECATION") // https://github.com/mozilla-mobile/focus-android/issues/5016
@@ -102,4 +113,28 @@ class FullScreenIntegration(
         @Suppress("DEPRECATION") // https://github.com/mozilla-mobile/focus-android/issues/5016
         window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
     }
+
+    @VisibleForTesting
+    internal fun enterBrowserFullscreen() {
+        if (settings.isAccessibilityEnabled()) {
+            toolbarView.hide(engineView)
+            eraseFab.visibility = View.GONE
+            sessionsFab.visibility = View.GONE
+        } else {
+            toolbarView.collapse()
+            toolbarView.disableDynamicBehavior(engineView)
+        }
+    }
+
+    @VisibleForTesting
+    internal fun exitBrowserFullscreen() {
+        if (settings.isAccessibilityEnabled()) {
+            toolbarView.showAsFixed(activity, engineView)
+            eraseFab.visibility = View.VISIBLE
+            sessionsFab.visibility = View.VISIBLE
+        } else {
+            toolbarView.enableDynamicBehavior(activity, engineView)
+            toolbarView.expand()
+        }
+    }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt b/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
index b55d82f93545..586f76acf5a1 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
@@ -5,6 +5,7 @@
 package org.mozilla.focus.ext
 
 import android.content.Context
+import android.view.View
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
@@ -41,9 +42,38 @@ fun BrowserToolbar.enableDynamicBehavior(context: Context, engineView: EngineVie
     )
 
     engineView.setDynamicToolbarMaxHeight(height)
-    (engineView.asView().layoutParams as CoordinatorLayout.LayoutParams).behavior =
-        EngineViewBrowserToolbarBehavior(
+    (engineView.asView().layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
+        topMargin = 0
+        behavior = EngineViewBrowserToolbarBehavior(
             context, null, engineView.asView(), context.resources.getDimension(R.dimen.browser_toolbar_height).toInt(),
             mozilla.components.feature.session.behavior.ToolbarPosition.TOP
         )
+    }
+}
+
+/**
+ * Show this toolbar at the top of the screen, fixed in place, with the EngineView immediately below it.
+ *
+ * @param context [Context] used for various system interactions
+ * @param engineView [EngineView] that must be shown immediately below the toolbar.
+ */
+fun BrowserToolbar.showAsFixed(context: Context, engineView: EngineView) {
+    visibility = View.VISIBLE
+
+    engineView.setDynamicToolbarMaxHeight(0)
+
+    val toolbarHeight = context.resources.getDimension(R.dimen.browser_toolbar_height).toInt()
+    (engineView.asView().layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin = toolbarHeight
+}
+
+/**
+ * Remove this toolbar from the screen and allow the EngineView to occupy the entire screen.
+ *
+ * @param engineView [EngineView] that will be configured to occupy the entire screen.
+ */
+fun BrowserToolbar.hide(engineView: EngineView) {
+    engineView.setDynamicToolbarMaxHeight(0)
+    (engineView.asView().layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin = 0
+
+    visibility = View.GONE
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/ext/Context.kt b/focus-android/app/src/main/java/org/mozilla/focus/ext/Context.kt
index b46043c57cbe..65a7851ea0d6 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/ext/Context.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/ext/Context.kt
@@ -5,6 +5,7 @@
 package org.mozilla.focus.ext
 
 import android.content.Context
+import android.view.accessibility.AccessibilityManager
 import org.mozilla.focus.Components
 import org.mozilla.focus.FocusApplication
 import org.mozilla.focus.utils.Settings
@@ -28,6 +29,12 @@ val Context.components: Components
 val Context.settings: Settings
     get() = application.components.settings
 
+/**
+ * System's [AccessibilityManager].
+ */
+val Context.accessibilityManager: AccessibilityManager
+    get() = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
+
 /**
  * Get the app install date.
  */
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
index aabde993cb92..8ddc106e2ea1 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
@@ -63,6 +63,7 @@ import org.mozilla.focus.contextmenu.ContextMenuCandidates
 import org.mozilla.focus.downloads.DownloadService
 import org.mozilla.focus.engine.EngineSharedPreferencesListener
 import org.mozilla.focus.exceptions.ExceptionDomains
+import org.mozilla.focus.ext.accessibilityManager
 import org.mozilla.focus.ext.components
 import org.mozilla.focus.ext.disableDynamicBehavior
 import org.mozilla.focus.ext.enableDynamicBehavior
@@ -70,6 +71,7 @@ import org.mozilla.focus.ext.ifCustomTab
 import org.mozilla.focus.ext.isCustomTab
 import org.mozilla.focus.ext.requireComponents
 import org.mozilla.focus.ext.settings
+import org.mozilla.focus.ext.showAsFixed
 import org.mozilla.focus.ext.titleOrDomain
 import org.mozilla.focus.menu.browser.DefaultBrowserMenu
 import org.mozilla.focus.open.OpenWithFragment
@@ -105,6 +107,8 @@ class BrowserFragment :
 
     private lateinit var engineView: EngineView
     private lateinit var toolbar: BrowserToolbar
+    private lateinit var eraseFab: FloatingEraseButton
+    private lateinit var sessionsFab: FloatingSessionsButton
 
     private val findInPageIntegration = ViewBoundFeatureWrapper<FindInPageIntegration>()
     private val fullScreenIntegration = ViewBoundFeatureWrapper<FullScreenIntegration>()
@@ -145,6 +149,8 @@ class BrowserFragment :
 
         popupTint = view.findViewById(R.id.popup_tint)
 
+        requireContext().accessibilityManager.addAccessibilityStateChangeListener(this)
+
         return view
     }
 
@@ -154,6 +160,8 @@ class BrowserFragment :
 
         engineView = (view.findViewById<View>(R.id.engineView) as EngineView)
         toolbar = view.findViewById(R.id.browserToolbar)
+        eraseFab = view.findViewById(R.id.erase)
+        sessionsFab = view.findViewById(R.id.tabs)
 
         findInPageIntegration.set(
             FindInPageIntegration(
@@ -170,9 +178,12 @@ class BrowserFragment :
                 components.store,
                 tab.id,
                 components.sessionUseCases,
+                requireContext().settings,
                 toolbar,
                 statusBar!!,
-                engineView
+                engineView,
+                eraseFab,
+                sessionsFab
             ),
             this, view
         )
@@ -285,7 +296,7 @@ class BrowserFragment :
 
         val customTabConfig = tab.ifCustomTab()?.config
         if (customTabConfig != null) {
-            initialiseCustomTabUi(view, customTabConfig)
+            initialiseCustomTabUi(customTabConfig)
 
             // TODO Add custom tabs window feature support
             // We to add support for Custom Tabs here, however in order to send the window request
@@ -306,8 +317,11 @@ class BrowserFragment :
     }
 
     override fun onAccessibilityStateChanged(enabled: Boolean) = when (enabled) {
-        true -> toolbar.enableDynamicBehavior(requireContext(), engineView)
-        false -> toolbar.disableDynamicBehavior(engineView)
+        false -> toolbar.enableDynamicBehavior(requireContext(), engineView)
+        true -> {
+            toolbar.disableDynamicBehavior(engineView)
+            toolbar.showAsFixed(requireContext(), engineView)
+        }
     }
 
     private fun getAdditionalNote(hitResult: HitResult): String? {
@@ -368,6 +382,8 @@ class BrowserFragment :
     private fun initialiseNormalBrowserUi(view: View) {
         if (!requireContext().settings.isAccessibilityEnabled()) {
             toolbar.enableDynamicBehavior(requireContext(), engineView)
+        } else {
+            toolbar.showAsFixed(requireContext(), engineView)
         }
 
         val eraseButton = view.findViewById<FloatingEraseButton>(R.id.erase)
@@ -387,25 +403,30 @@ class BrowserFragment :
         )
     }
 
-    private fun initialiseCustomTabUi(view: View, customTabConfig: CustomTabConfig) {
+    private fun initialiseCustomTabUi(customTabConfig: CustomTabConfig) {
         // Unfortunately there's no simpler way to have the FAB only in normal-browser mode.
         // - ViewStub: requires splitting attributes for the FAB between the ViewStub, and actual FAB layout file.
         //             Moreover, the layout behaviour just doesn't work unless you set it programatically.
         // - View.GONE: doesn't work because the layout-behaviour makes the FAB visible again when scrolling.
         // - Adding at runtime: works, but then we need to use a separate layout file (and you need
         //   to set some attributes programatically, same as ViewStub).
-        val erase = view.findViewById<FloatingEraseButton>(R.id.erase)
-        val eraseContainer = erase.parent as ViewGroup
-        eraseContainer.removeView(erase)
+        val eraseContainer = eraseFab.parent as ViewGroup
+        eraseContainer.removeView(eraseFab)
 
-        val sessions = view.findViewById<FloatingSessionsButton>(R.id.tabs)
-        eraseContainer.removeView(sessions)
+        eraseContainer.removeView(sessionsFab)
 
         if (customTabConfig.enableUrlbarHiding && !requireContext().settings.isAccessibilityEnabled()) {
             toolbar.enableDynamicBehavior(requireContext(), engineView)
+        } else {
+            toolbar.showAsFixed(requireContext(), engineView)
         }
     }
 
+    override fun onDestroyView() {
+        super.onDestroyView()
+        requireContext().accessibilityManager.removeAccessibilityStateChangeListener(this)
+    }
+
     override fun onDestroy() {
         super.onDestroy()
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/FloatingSessionsButton.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/FloatingSessionsButton.java
index 21c46e360d4d..f035be999dbd 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/widget/FloatingSessionsButton.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/FloatingSessionsButton.java
@@ -97,10 +97,9 @@ protected void onDraw(Canvas canvas) {
     public void setVisibility(int visibility) {
         final boolean shouldBeVisible = shouldBeVisible();
 
-        if ((!shouldBeVisible && visibility == View.VISIBLE) ||
-                (shouldBeVisible && visibility != View.VISIBLE)) {
+        if (!shouldBeVisible && visibility == View.VISIBLE) {
             // no-op.
-            // Based on "shouldBeVisible" we know better if this should be visible or not.
+            // Based on "shouldBeVisible" we know better when this should be visible.
         } else {
             super.setVisibility(visibility);
         }
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/browser/integration/FullScreenIntegrationTest.kt b/focus-android/app/src/test/java/org/mozilla/focus/browser/integration/FullScreenIntegrationTest.kt
new file mode 100644
index 000000000000..a2ca9460cd5a
--- /dev/null
+++ b/focus-android/app/src/test/java/org/mozilla/focus/browser/integration/FullScreenIntegrationTest.kt
@@ -0,0 +1,316 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.integration
+
+import android.app.Activity
+import android.content.res.Resources
+import android.view.View
+import android.view.Window
+import android.view.WindowManager
+import android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
+import mozilla.components.browser.engine.gecko.GeckoEngineView
+import mozilla.components.browser.toolbar.BrowserToolbar
+import mozilla.components.feature.session.FullScreenFeature
+import mozilla.components.support.test.mock
+import org.junit.Test
+import org.junit.jupiter.api.Assertions.assertEquals
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.inOrder
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import org.mozilla.focus.ext.disableDynamicBehavior
+import org.mozilla.focus.ext.enableDynamicBehavior
+import org.mozilla.focus.ext.hide
+import org.mozilla.focus.ext.showAsFixed
+import org.mozilla.focus.utils.Settings
+import org.mozilla.focus.widget.FloatingEraseButton
+import org.mozilla.focus.widget.FloatingSessionsButton
+
+internal class FullScreenIntegrationTest {
+    @Test
+    fun `WHEN the integration is started THEN start FullScreenFeature`() {
+        val feature: FullScreenFeature = mock()
+        val integration = FullScreenIntegration(
+            mock(), mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        ).apply {
+            this.feature = feature
+        }
+
+        integration.start()
+
+        verify(feature).start()
+    }
+
+    @Test
+    fun `WHEN the integration is stopped THEN stop FullScreenFeature`() {
+        val feature: FullScreenFeature = mock()
+        val integration = FullScreenIntegration(
+            mock(), mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        ).apply {
+            this.feature = feature
+        }
+
+        integration.stop()
+
+        verify(feature).stop()
+    }
+
+    @Test
+    fun `WHEN back is pressed THEN send this to the feature`() {
+        val feature: FullScreenFeature = mock()
+        val integration = FullScreenIntegration(
+            mock(), mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        ).apply {
+            this.feature = feature
+        }
+
+        integration.onBackPressed()
+
+        verify(feature).onBackPressed()
+    }
+
+    @Test
+    fun `WHEN the viewport changes THEN update layoutInDisplayCutoutMode`() {
+        val windowAttributes = WindowManager.LayoutParams()
+        val activityWindow: Window = mock()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(windowAttributes).`when`(activityWindow).attributes
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        )
+
+        integration.viewportFitChanged(33)
+
+        assertEquals(33, windowAttributes.layoutInDisplayCutoutMode)
+    }
+
+    @Test
+    @Suppress("DEPRECATION")
+    fun `WHEN entering immersive mode THEN hide all system bars`() {
+        val decorView: View = mock()
+        val activityWindow: Window = mock()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(decorView).`when`(activityWindow).decorView
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        )
+
+        integration.switchToImmersiveMode()
+
+        verify(activityWindow).addFlags(FLAG_KEEP_SCREEN_ON)
+        verify(decorView).systemUiVisibility =
+            View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or
+            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or
+            View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
+    }
+
+    @Test
+    @Suppress("DEPRECATION")
+    fun `GIVEN immersive mode WHEN exitImmersiveModeIfNeeded is called THEN show the system bars`() {
+        val windowAttributes = WindowManager.LayoutParams()
+        // This flag is checked to infer whether already in immersive mode or not
+        windowAttributes.flags = FLAG_KEEP_SCREEN_ON
+        val decorView: View = mock()
+        val activityWindow: Window = mock()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(decorView).`when`(activityWindow).decorView
+        doReturn(windowAttributes).`when`(activityWindow).attributes
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        )
+
+        integration.exitImmersiveModeIfNeeded()
+
+        verify(activityWindow).clearFlags(FLAG_KEEP_SCREEN_ON)
+        verify(decorView).systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+    }
+
+    @Test
+    @Suppress("DEPRECATION")
+    fun `GIVEN not in immersive mode WHEN exitImmersiveModeIfNeeded is called THEN don't change anything`() {
+        val windowAttributes = WindowManager.LayoutParams()
+        // This flag is checked to infer whether already in immersive mode or not
+        windowAttributes.flags = 0
+        val decorView: View = mock()
+        val activityWindow: Window = mock()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(decorView).`when`(activityWindow).decorView
+        doReturn(windowAttributes).`when`(activityWindow).attributes
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), mock(), mock(), mock(), mock(), mock(), mock()
+        )
+
+        integration.exitImmersiveModeIfNeeded()
+
+        verify(activityWindow, never()).clearFlags(anyInt())
+        verify(decorView, never()).systemUiVisibility = anyInt()
+    }
+
+    @Test
+    fun `GIVEN a11y is enabled WHEN enterBrowserFullscreen THEN hide the toolbar and the fabs`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(true).`when`(settings).isAccessibilityEnabled()
+        val integration = FullScreenIntegration(
+            mock(), mock(), null, mock(), settings, toolbar, mock(), engineView, eraseFab, sessionsFab
+        )
+
+        integration.enterBrowserFullscreen()
+
+        verify(toolbar).hide(engineView)
+        verify(eraseFab).visibility = View.GONE
+        verify(sessionsFab).visibility = View.GONE
+        verify(toolbar, never()).collapse()
+        verify(toolbar, never()).disableDynamicBehavior(engineView)
+    }
+
+    @Test
+    fun `GIVEN a11y is disabled WHEN enterBrowserFullscreen THEN collapse and disable the dynamic toolbar`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(false).`when`(settings).isAccessibilityEnabled()
+        val integration = FullScreenIntegration(
+            mock(), mock(), null, mock(), settings, toolbar, mock(), engineView, eraseFab, sessionsFab
+        )
+
+        integration.enterBrowserFullscreen()
+
+        verify(toolbar, never()).hide(engineView)
+        verify(eraseFab, never()).visibility = View.GONE
+        verify(sessionsFab, never()).visibility = View.GONE
+        with(inOrder(toolbar)) {
+            verify(toolbar).collapse()
+            verify(toolbar).disableDynamicBehavior(engineView)
+        }
+    }
+
+    @Test
+    fun `GIVEN a11y is enabled WHEN exitBrowserFullscreen THEN show the toolbar and the fabs`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(true).`when`(settings).isAccessibilityEnabled()
+        val resources: Resources = mock()
+        val activity: Activity = mock()
+        doReturn(resources).`when`(activity).resources
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), settings, toolbar, mock(), engineView, eraseFab, sessionsFab
+        )
+
+        integration.exitBrowserFullscreen()
+
+        verify(toolbar).showAsFixed(activity, engineView)
+        verify(eraseFab).visibility = View.VISIBLE
+        verify(sessionsFab).visibility = View.VISIBLE
+        verify(toolbar, never()).expand()
+        verify(toolbar, never()).enableDynamicBehavior(activity, engineView)
+    }
+
+    @Test
+    fun `GIVEN a11y is disabled WHEN exitBrowserFullscreen THEN enable the dynamic toolbar and expand it`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(false).`when`(settings).isAccessibilityEnabled()
+        val resources: Resources = mock()
+        val activity: Activity = mock()
+        doReturn(resources).`when`(activity).resources
+        val integration = FullScreenIntegration(
+            activity, mock(), null, mock(), settings, toolbar, mock(), engineView, eraseFab, sessionsFab
+        )
+
+        integration.exitBrowserFullscreen()
+
+        verify(toolbar, never()).showAsFixed(activity, engineView)
+        verify(eraseFab, never()).visibility = View.VISIBLE
+        verify(sessionsFab, never()).visibility = View.VISIBLE
+        with(inOrder(toolbar)) {
+            verify(toolbar).enableDynamicBehavior(activity, engineView)
+            verify(toolbar).expand()
+        }
+    }
+
+    @Test
+    fun `WHEN entering fullscreen THEN put browser in fullscreen, hide system bars and enter immersive mode`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(false).`when`(settings).isAccessibilityEnabled()
+        val resources: Resources = mock()
+        val activityWindow: Window = mock()
+        val decorView: View = mock()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(decorView).`when`(activityWindow).decorView
+        doReturn(resources).`when`(activity).resources
+        val statusBar: View = mock()
+        val integration = spy(
+            FullScreenIntegration(
+                activity, mock(), null, mock(), settings, toolbar, statusBar, engineView, eraseFab, sessionsFab
+            )
+        )
+
+        integration.fullScreenChanged(true)
+
+        verify(integration).enterBrowserFullscreen()
+        verify(integration).switchToImmersiveMode()
+        verify(statusBar).visibility = View.GONE
+    }
+
+    @Test
+    fun `WHEN exiting fullscreen THEN put browser in fullscreen, hide system bars and enter immersive mode`() {
+        val toolbar: BrowserToolbar = mock()
+        val engineView: GeckoEngineView = mock()
+        doReturn(mock<View>()).`when`(engineView).asView()
+        val eraseFab: FloatingEraseButton = mock()
+        val sessionsFab: FloatingSessionsButton = mock()
+        val settings: Settings = mock()
+        doReturn(false).`when`(settings).isAccessibilityEnabled()
+        val resources: Resources = mock()
+        val activityWindow: Window = mock()
+        val decorView: View = mock()
+        val windowAttributes = WindowManager.LayoutParams()
+        val activity: Activity = mock()
+        doReturn(activityWindow).`when`(activity).window
+        doReturn(decorView).`when`(activityWindow).decorView
+        doReturn(windowAttributes).`when`(activityWindow).attributes
+        doReturn(resources).`when`(activity).resources
+        val statusBar: View = mock()
+        val integration = spy(
+            FullScreenIntegration(
+                activity, mock(), null, mock(), settings, toolbar, statusBar, engineView, eraseFab, sessionsFab
+            )
+        )
+
+        integration.fullScreenChanged(false)
+
+        verify(integration).exitBrowserFullscreen()
+        verify(integration).exitImmersiveModeIfNeeded()
+        verify(statusBar).visibility = View.VISIBLE
+    }
+}
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt b/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
index cb3b6f02f2c4..3f6ec4e84e79 100644
--- a/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
+++ b/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
@@ -4,6 +4,7 @@
 
 package org.mozilla.focus.ext
 
+import android.view.View
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import mozilla.components.browser.engine.gecko.GeckoEngineView
 import mozilla.components.browser.toolbar.BrowserToolbar
@@ -36,10 +37,14 @@ internal class BrowserToolbarTest {
 
     @Test
     fun `GIVEN a BrowserToolbar WHEN enableDynamicBehavior THEN set custom behaviors for the toolbar and engineView`() {
+        // Simulate previously having a fixed toolbar
+        (engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin = 222
+
         toolbar.enableDynamicBehavior(testContext, engineView)
 
         assertTrue((toolbar.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is BrowserToolbarBehavior)
         assertTrue((engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is EngineViewBrowserToolbarBehavior)
+        assertEquals(0, (engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin)
         verify(engineView).setDynamicToolbarMaxHeight(toolbarHeight)
     }
 
@@ -54,4 +59,22 @@ internal class BrowserToolbarTest {
         assertEquals(0f, engineView.asView().translationY)
         verify(engineView).setDynamicToolbarMaxHeight(0)
     }
+
+    @Test
+    fun `GIVEN a BrowserToolbar WHEN showAsFixed is called THEN show the toolbar with the engineView below it`() {
+        toolbar.showAsFixed(testContext, engineView)
+
+        verify(toolbar).visibility = View.VISIBLE
+        verify(engineView).setDynamicToolbarMaxHeight(0)
+        assertEquals(toolbarHeight, (engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin)
+    }
+
+    @Test
+    fun `GIVEN a BrowserToolbar WHEN hide is called THEN show the toolbar with the engineView below it`() {
+        toolbar.hide(engineView)
+
+        verify(toolbar).visibility = View.GONE
+        verify(engineView).setDynamicToolbarMaxHeight(0)
+        assertEquals(0, (engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin)
+    }
 }
