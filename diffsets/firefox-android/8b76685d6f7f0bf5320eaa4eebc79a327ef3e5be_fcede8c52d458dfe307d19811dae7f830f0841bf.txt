diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
new file mode 100644
index 000000000000..956ef9358180
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
@@ -0,0 +1,179 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import android.content.Context
+import android.view.GestureDetector
+import android.view.MotionEvent
+import android.view.ScaleGestureDetector
+import androidx.annotation.VisibleForTesting
+import kotlin.math.abs
+
+/**
+ * Custom [MotionEvent] gestures detector with scroll / zoom callbacks.
+ *
+ * Favors zoom gestures in detriment of the scroll gestures with:
+ *  - higher sensitivity for multi-finger zoom gestures
+ *  - ignoring scrolls if zoom is in progress
+ *
+ *  @param applicationContext context used for registering internal gesture listeners.
+ *  @param listener client interested in zoom / scroll events.
+ */
+internal class BrowserGestureDetector(
+    applicationContext: Context,
+    listener: GesturesListener
+) {
+    /**
+     * Accepts MotionEvents and dispatches zoom / scroll events to the registered listener when appropriate.
+     *
+     * Applications should pass a complete and consistent event stream to this method.
+     * A complete and consistent event stream involves all MotionEvents from the initial ACTION_DOWN
+     * to the final ACTION_UP or ACTION_CANCEL.
+     *
+     * @return if the event was handled by any of the registered detectors
+     */
+    internal fun handleTouchEvent(event: MotionEvent): Boolean {
+        // A double tap for a quick scale gesture (quick double tap followed by a drag)
+        // would trigger a ACTION_CANCEL event before the MOVE_EVENT.
+        // This would prevent the scale detector from properly inferring the movement.
+        // We'll want to ignore ACTION_CANCEL but process the next stream of events.
+        if (event.actionMasked != MotionEvent.ACTION_CANCEL) {
+            scaleGestureDetector.onTouchEvent(event)
+        }
+
+        // Ignore scrolling if zooming is already in progress.
+        return if (!scaleGestureDetector.isInProgress) {
+            gestureDetector.onTouchEvent(event)
+        } else {
+            false
+        }
+    }
+
+    @VisibleForTesting
+    @Suppress("MaxLineLength")
+    internal val gestureDetector: GestureDetector by lazy(LazyThreadSafetyMode.NONE) {
+        GestureDetector(
+            applicationContext,
+            CustomScrollDetectorListener { previousEvent: MotionEvent, currentEvent: MotionEvent, distanceX, distanceY ->
+                run {
+                    listener.onScroll?.invoke(distanceX, distanceY)
+
+                    if (abs(currentEvent.y - previousEvent.y) >= abs(currentEvent.x - previousEvent.x)) {
+                        listener.onVerticalScroll?.invoke(distanceY)
+                    } else {
+                        listener.onHorizontalScroll?.invoke(distanceX)
+                    }
+                }
+            }
+        )
+    }
+
+    @VisibleForTesting
+    internal val scaleGestureDetector: ScaleGestureDetector by lazy(LazyThreadSafetyMode.NONE) {
+        ScaleGestureDetector(
+            applicationContext,
+            CustomScaleDetectorListener(
+                listener.onScaleBegin ?: {},
+                listener.onScale ?: {},
+                listener.onScaleEnd ?: {})
+        ).apply {
+            // Use reflection to modify two fields controlling the sensitivity of our scale detector.
+            // The lower the values the higher the sensitivity.
+            // Values of 0 here would mean all swipe events will be treated as pinch/spread to zoom gestures,
+            // in our context effectively meaning no scrolling, only zooming.
+            listOf(
+                javaClass.getDeclaredField("mSpanSlop"),
+                javaClass.getDeclaredField("mMinSpan")
+            ).forEach { field ->
+                field.isAccessible = true
+                field.set(this, (field.get(this) as Int) / 2)
+            }
+        }
+    }
+
+    /**
+     * A convenience containing listeners for zoom / scroll events
+     *
+     * Provide implementation for the events you are interested in.
+     * The others will be no-op.
+     */
+    internal class GesturesListener(
+        /**
+         * Responds to scroll events for a gesture in progress.
+         * The distance in x and y is also supplied for convenience.
+         */
+        val onScroll: ((distanceX: Float, distanceY: Float) -> Unit)? = { _, _ -> run {} },
+
+        /**
+         * Responds to an in progress scroll occuring more on the vertical axis.
+         * The scroll distance is also supplied for convenience.
+         */
+        val onVerticalScroll: ((distance: Float) -> Unit)? = {},
+
+        /**
+         * Responds to an in progress scroll occurring more on the horizontal axis.
+         * The scroll distance is also supplied for convenience.
+         */
+        val onHorizontalScroll: ((distance: Float) -> Unit)? = {},
+
+        /**
+         * Responds to the the beginning of a new scale gesture.
+         * Reported by new pointers going down.
+         */
+        val onScaleBegin: ((scaleFactor: Float) -> Unit)? = {},
+
+        /**
+         * Responds to scaling events for a gesture in progress.
+         * The scaling factor is also supplied for convenience.
+         * This value is represents the difference from the previous scale event to the current event.
+         */
+        val onScale: ((scaleFactor: Float) -> Unit)? = {},
+
+        /**
+         * Responds to the end of a scale gesture.
+         * Reported by existing pointers going up.
+         */
+        val onScaleEnd: ((scaleFactor: Float) -> Unit)? = {}
+    )
+
+    private class CustomScrollDetectorListener(
+        val onScrolling: (
+            previousEvent: MotionEvent,
+            currentEvent: MotionEvent,
+            distanceX: Float,
+            distanceY: Float
+        ) -> Unit
+    ) : GestureDetector.SimpleOnGestureListener() {
+        override fun onScroll(
+            e1: MotionEvent,
+            e2: MotionEvent,
+            distanceX: Float,
+            distanceY: Float
+        ): Boolean {
+            onScrolling(e1, e2, distanceX, distanceY)
+            return true
+        }
+    }
+
+    private class CustomScaleDetectorListener(
+        val onScaleBegin: (scaleFactor: Float) -> Unit = {},
+        val onScale: (scaleFactor: Float) -> Unit = {},
+        val onScaleEnd: (scaleFactor: Float) -> Unit = {}
+    ) : ScaleGestureDetector.SimpleOnScaleGestureListener() {
+        override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
+            onScaleBegin(detector.scaleFactor)
+            return true
+        }
+
+        override fun onScale(detector: ScaleGestureDetector): Boolean {
+            onScale(detector.scaleFactor)
+            return true
+        }
+
+        override fun onScaleEnd(detector: ScaleGestureDetector) {
+            onScaleEnd(detector.scaleFactor)
+        }
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
index 72d118066990..f06d3caa1518 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
@@ -8,6 +8,7 @@ import android.animation.ValueAnimator
 import android.content.Context
 import android.util.AttributeSet
 import android.view.Gravity
+import android.view.MotionEvent
 import android.view.View
 import android.view.animation.DecelerateInterpolator
 import androidx.annotation.VisibleForTesting
@@ -32,8 +33,9 @@ private const val SMALL_ELEVATION_CHANGE = 0.01f
  * - On showing a [Snackbar] position it above the [BrowserToolbar].
  * - Snap the [BrowserToolbar] to be hidden or visible when the user stops scrolling.
  */
+@Suppress("TooManyFunctions")
 class BrowserToolbarBottomBehavior(
-    context: Context?,
+    val context: Context?,
     attrs: AttributeSet?
 ) : CoordinatorLayout.Behavior<BrowserToolbar>(context, attrs) {
     // This implementation is heavily based on this blog article:
@@ -51,7 +53,14 @@ class BrowserToolbarBottomBehavior(
     /**
      * Reference to [EngineView] used to check user's [android.view.MotionEvent]s.
      */
-    private var engineView: EngineView? = null
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal var engineView: EngineView? = null
+
+    /**
+     * Reference to the actual [BrowserToolbar] that we'll animate.
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal lateinit var browserToolbar: BrowserToolbar
 
     /**
      * Depending on how user's touch was consumed by EngineView / current website,
@@ -67,6 +76,9 @@ class BrowserToolbarBottomBehavior(
     internal val shouldScroll: Boolean
         get() = engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_HANDLED
 
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal var gesturesDetector: BrowserGestureDetector = createGestureDetector()
+
     override fun onStartNestedScroll(
         coordinatorLayout: CoordinatorLayout,
         child: BrowserToolbar,
@@ -105,22 +117,18 @@ class BrowserToolbarBottomBehavior(
         }
     }
 
-    override fun onNestedPreScroll(
-        coordinatorLayout: CoordinatorLayout,
+    override fun onInterceptTouchEvent(
+        parent: CoordinatorLayout,
         child: BrowserToolbar,
-        target: View,
-        dx: Int,
-        dy: Int,
-        consumed: IntArray,
-        type: Int
-    ) {
-        if (shouldScroll) {
-            super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type)
-            child.translationY = max(0f, min(child.height.toFloat(), child.translationY + dy))
-        }
+        ev: MotionEvent
+    ): Boolean {
+        gesturesDetector.handleTouchEvent(ev)
+        return false // allow events to be passed to below listeners
     }
 
     override fun layoutDependsOn(parent: CoordinatorLayout, child: BrowserToolbar, dependency: View): Boolean {
+        browserToolbar = child
+
         engineView = parent.findViewInHierarchy { it is EngineView } as? EngineView
 
         if (dependency is Snackbar.SnackbarLayout) {
@@ -144,6 +152,20 @@ class BrowserToolbarBottomBehavior(
         start()
     }
 
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun snapToolbarVertically() {
+        if (snapAnimator.isStarted) {
+            snapAnimator.end()
+        } else {
+            browserToolbar.translationY =
+                if (browserToolbar.translationY >= browserToolbar.height / 2) {
+                    browserToolbar.height.toFloat()
+                } else {
+                    0f
+                }
+        }
+    }
+
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal fun positionSnackbar(child: View, snackbarLayout: Snackbar.SnackbarLayout) {
         val params = snackbarLayout.layoutParams as CoordinatorLayout.LayoutParams
@@ -160,6 +182,37 @@ class BrowserToolbarBottomBehavior(
         // out from under the toolbar.
         snackbarLayout.elevation = child.elevation - SMALL_ELEVATION_CHANGE
     }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun tryToScrollVertically(distance: Float) {
+        if (shouldScroll) {
+            browserToolbar.translationY =
+                max(0f, min(browserToolbar.height.toFloat(), browserToolbar.translationY + distance))
+        }
+    }
+
+    /**
+     * Helper function to ease testing.
+     * (Re)Initializes the [BrowserGestureDetector] in a new context.
+     *
+     * Useful in spied behaviors, to ensure callbacks are of the spy and not of the initially created object
+     * if the passed in argument is the result of [createGestureDetector].
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun initGesturesDetector(detector: BrowserGestureDetector) {
+        gesturesDetector = detector
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun createGestureDetector() =
+        BrowserGestureDetector(context!!, BrowserGestureDetector.GesturesListener(
+            onVerticalScroll = ::tryToScrollVertically,
+            onScaleBegin = {
+                // Scale shouldn't animate the toolbar but a small y translation is still possible
+                // because of a previous scroll. Try to be swift about such an in progress animation.
+                snapToolbarVertically()
+            }
+        ))
 }
 
 @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
new file mode 100644
index 000000000000..a46965ee4459
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
@@ -0,0 +1,172 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import android.view.GestureDetector
+import android.view.MotionEvent
+import android.view.MotionEvent.ACTION_CANCEL
+import android.view.MotionEvent.ACTION_DOWN
+import android.view.MotionEvent.ACTION_MOVE
+import android.view.ScaleGestureDetector
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.anyFloat
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class BrowserGestureDetectorTest {
+    // Robolectric currently (April 17th 2020) only offer a stub in it's `ShadowScaleGestureDetector`
+    // so unit tests based on the actual implementation of `ScaleGestureListener` are not possible.
+
+    // Used spies and not mocks as it was observed that verifying more of the below as mocks
+    // will fail the tests because of "UnfinishedVerificationException"
+    private val scrollListener = spy { _: Float, _: Float -> run {} }
+    private val verticalScrollListener = spy { _: Float -> run {} }
+    private val horizontalScrollListener = spy { _: Float -> run {} }
+    private val scaleBeginListener = spy { _: Float -> run {} }
+    private val scaleInProgressListener = spy { _: Float -> run {} }
+    private val scaleEndListener = spy { _: Float -> run {} }
+    private val gesturesListener = BrowserGestureDetector.GesturesListener(
+        onScroll = scrollListener,
+        onVerticalScroll = verticalScrollListener,
+        onHorizontalScroll = horizontalScrollListener,
+        onScaleBegin = scaleBeginListener,
+        onScale = scaleInProgressListener,
+        onScaleEnd = scaleEndListener
+    )
+
+    @Test
+    fun `Detector should not attempt to detect zoom if MotionEvent's action is ACTION_CANCEL`() {
+        val detector = spy(BrowserGestureDetector(testContext, mock()))
+        val scaleDetector: ScaleGestureDetector = mock()
+        doReturn(scaleDetector).`when`(detector).scaleGestureDetector
+
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+        val cancelEvent = TestUtils.getMotionEvent(ACTION_CANCEL, previousEvent = downEvent)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, previousEvent = downEvent)
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(cancelEvent)
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+
+        verify(scaleDetector, times(3)).onTouchEvent(any<MotionEvent>())
+    }
+
+    @Test
+    fun `Detector should not attempt to detect scrolls if a zoom gesture is in progress`() {
+        val detector = spy(BrowserGestureDetector(testContext, mock()))
+        val scrollDetector: GestureDetector = mock()
+        val scaleDetector: ScaleGestureDetector = mock()
+        doReturn(scrollDetector).`when`(detector).gestureDetector
+        doReturn(scaleDetector).`when`(detector).scaleGestureDetector
+        `when`(scaleDetector.isInProgress).thenReturn(true)
+
+        detector.handleTouchEvent(TestUtils.getMotionEvent(ACTION_DOWN))
+
+        verify(scrollDetector, never()).onTouchEvent(any<MotionEvent>())
+    }
+
+    @Test
+    fun `Detector's handleTouchEvent returns false if the event was not handled`() {
+        val detector = spy(BrowserGestureDetector(testContext, mock()))
+        val unhandledEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+
+        // Neither the scale detector, nor the scroll detector should be interested
+        // in a one of a time ACTION_CANCEL MotionEvent
+        val wasEventHandled = detector.handleTouchEvent(
+            TestUtils.getMotionEvent(ACTION_CANCEL, previousEvent = unhandledEvent)
+        )
+
+        assertFalse(wasEventHandled)
+    }
+
+    @Test
+    fun `Detector's handleTouchEvent returns true if the event was handled`() {
+        val detector = spy(BrowserGestureDetector(testContext, mock()))
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 0f, previousEvent = downEvent)
+        val moveEvent2 = TestUtils.getMotionEvent(ACTION_MOVE, 100f, 100f, previousEvent = moveEvent)
+
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+        val wasEventHandled = detector.handleTouchEvent(moveEvent2)
+
+        assertTrue(wasEventHandled)
+    }
+
+    @Test
+    fun `Detector should inform about scroll and vertical scrolls events`() {
+        val detector = spy(BrowserGestureDetector(testContext, gesturesListener))
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 0f, previousEvent = downEvent)
+        val moveEvent2 = TestUtils.getMotionEvent(ACTION_MOVE, 100f, 200f, previousEvent = moveEvent)
+
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+        detector.handleTouchEvent(moveEvent2)
+
+        // If the movement was more on the Y axis both "onScroll" and "onVerticalScroll" callbacks
+        // should be called but no others.
+        verify(scrollListener).invoke(-100f, -200f)
+        verify(verticalScrollListener).invoke(-200f)
+        verify(horizontalScrollListener, never()).invoke(anyFloat())
+        verify(scaleBeginListener, never()).invoke(anyFloat())
+        verify(scaleInProgressListener, never()).invoke(anyFloat())
+        verify(scaleEndListener, never()).invoke(anyFloat())
+    }
+
+    @Test
+    fun `Detector should prioritize vertical scrolls over horizontal scrolls`() {
+        val detector = spy(BrowserGestureDetector(testContext, gesturesListener))
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 0f, previousEvent = downEvent)
+        val moveEvent2 = TestUtils.getMotionEvent(ACTION_MOVE, 100f, 100f, previousEvent = moveEvent)
+
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+        detector.handleTouchEvent(moveEvent2)
+
+        // If the movement was for the same amount on both the Y axis and the X axis
+        // both "onScroll" and "onVerticalScroll" callbacks should be called but no others.
+        verify(scrollListener).invoke(-100f, -100f)
+        verify(verticalScrollListener).invoke(-100f)
+        verify(horizontalScrollListener, never()).invoke(anyFloat())
+        verify(scaleBeginListener, never()).invoke(anyFloat())
+        verify(scaleInProgressListener, never()).invoke(anyFloat())
+        verify(scaleEndListener, never()).invoke(anyFloat())
+    }
+
+    @Test
+    fun `Detector should inform about scroll and horizontal scrolls events`() {
+        val detector = spy(BrowserGestureDetector(testContext, gesturesListener))
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 0f, previousEvent = downEvent)
+        val moveEvent2 = TestUtils.getMotionEvent(ACTION_MOVE, 101f, 100f, previousEvent = moveEvent)
+
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+        detector.handleTouchEvent(moveEvent2)
+
+        // If the movement was for the same amount on both the Y axis and the X axis
+        // both "onScroll" and "onVerticalScroll" callbacks should be called but no others.
+        verify(scrollListener).invoke(-101f, -100f)
+        verify(horizontalScrollListener).invoke(-101f)
+        verify(verticalScrollListener, never()).invoke(anyFloat())
+        verify(scaleBeginListener, never()).invoke(anyFloat())
+        verify(scaleInProgressListener, never()).invoke(anyFloat())
+        verify(scaleEndListener, never()).invoke(anyFloat())
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
index 065fbf7a22e6..40fe34315eca 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
@@ -6,11 +6,14 @@ package mozilla.components.browser.toolbar.behavior
 
 import android.animation.ValueAnimator
 import android.view.Gravity
+import android.view.MotionEvent.ACTION_DOWN
+import android.view.MotionEvent.ACTION_MOVE
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.google.android.material.snackbar.Snackbar
 import mozilla.components.browser.toolbar.BrowserToolbar
+import mozilla.components.concept.engine.EngineView
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
 import org.junit.Assert.assertEquals
@@ -18,6 +21,8 @@ import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.anyFloat
+import org.mockito.Mockito.`when`
 import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.never
 import org.mockito.Mockito.spy
@@ -133,26 +138,152 @@ class BrowserToolbarBottomBehaviorTest {
     }
 
     @Test
-    fun `Behavior will apply translation to toolbar for nested scroll`() {
+    fun `Behavior will intercept MotionEvents and pass them to the custom gesture detector`() {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
-        doReturn(true).`when`(behavior).shouldScroll
+        val gestureDetector: BrowserGestureDetector = mock()
+        behavior.initGesturesDetector(gestureDetector)
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
 
-        val child = mock<BrowserToolbar>()
+        behavior.onInterceptTouchEvent(mock(), mock(), downEvent)
+
+        verify(gestureDetector).handleTouchEvent(downEvent)
+    }
+
+    @Test
+    fun `Behavior will apply translation to toolbar only for vertical scrolls`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        behavior.initGesturesDetector(behavior.createGestureDetector())
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN, 0f, 0f)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 100f, downEvent)
+
+        behavior.onInterceptTouchEvent(mock(), mock(), downEvent)
+        behavior.onInterceptTouchEvent(mock(), mock(), moveEvent)
+
+        verify(behavior).tryToScrollVertically(-100f)
+    }
+
+    @Test
+    fun `Behaviour shouldScroll if EngineView handled the MotionEvent`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED)
+        behavior.engineView = engineView
+
+        assertTrue(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_UNHANDLED)
+        behavior.engineView = engineView
+
+        assertFalse(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent but the website`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT)
+        behavior.engineView = engineView
+
+        assertFalse(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behavior will vertically scroll for such and event and if EngineView handled the event`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        doReturn(true).`when`(behavior).shouldScroll
+        val child = spy(BrowserToolbar(testContext, null, 0))
+        behavior.browserToolbar = child
         doReturn(100).`when`(child).height
         doReturn(0f).`when`(child).translationY
 
-        behavior.onNestedPreScroll(
-            coordinatorLayout = mock(),
-            child = child,
-            target = mock(),
-            dx = 0,
-            dy = 25,
-            consumed = IntArray(0),
-            type = 0)
+        behavior.tryToScrollVertically(25f)
 
         verify(child).translationY = 25f
     }
 
+    @Test
+    fun `Behavior will not scroll vertically if EngineView did not handled the event`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        doReturn(false).`when`(behavior).shouldScroll
+        val child = spy(BrowserToolbar(testContext, null, 0))
+        behavior.browserToolbar = child
+        doReturn(100).`when`(child).height
+        doReturn(0f).`when`(child).translationY
+
+        behavior.tryToScrollVertically(25f)
+
+        verify(child, never()).setTranslationY(anyFloat())
+    }
+
+    @Test
+    fun `Behavior will snap toolbar first finishing translation animations if they are in progress`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+        doReturn(true).`when`(animator).isStarted
+        val child = mock<BrowserToolbar>()
+        behavior.browserToolbar = child
+        doReturn(100).`when`(child).height
+        doReturn(40f).`when`(child).translationY
+
+        behavior.snapToolbarVertically()
+
+        verify(animator).end()
+    }
+
+    @Test
+    fun `Behavior can snap toolbar if it is translated to the bottom half`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+        doReturn(false).`when`(animator).isStarted
+        val child = mock<BrowserToolbar>()
+        behavior.browserToolbar = child
+        doReturn(100).`when`(child).height
+        doReturn(40f).`when`(child).translationY
+
+        behavior.snapToolbarVertically()
+
+        verify(child).translationY = 0f
+    }
+
+    @Test
+    fun `Behavior can snap toolbar if it is translated to the top half`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+        doReturn(false).`when`(animator).isStarted
+        val child = mock<BrowserToolbar>()
+        behavior.browserToolbar = child
+        doReturn(100).`when`(child).height
+        doReturn(60f).`when`(child).translationY
+
+        behavior.snapToolbarVertically()
+
+        verify(child).translationY = 100f
+    }
+
+    @Test
+    fun `Behavior will snap toolbar to top if it is translated to exactly half`() {
+        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+        doReturn(false).`when`(animator).isStarted
+        val child = mock<BrowserToolbar>()
+        doReturn(100).`when`(child).height
+        doReturn(50f).`when`(child).translationY
+        behavior.browserToolbar = child
+
+        behavior.snapToolbarVertically()
+
+        verify(child).translationY = 100f
+    }
+
     @Test
     fun `Behavior will position snackbar above toolbar`() {
         val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
@@ -186,4 +317,4 @@ class BrowserToolbarBottomBehaviorTest {
 
         verify(behavior).animateSnap(toolbar, SnapDirection.UP)
     }
-}
\ No newline at end of file
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt
new file mode 100644
index 000000000000..4b9d5bc3bc63
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt
@@ -0,0 +1,62 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import android.view.MotionEvent
+
+object TestUtils {
+    fun getMotionEvent(
+        action: Int,
+        x: Float = 0f,
+        y: Float = 0f,
+        previousEvent: MotionEvent? = null
+    ): MotionEvent {
+        val currentTime = System.currentTimeMillis()
+        val downTime = previousEvent?.downTime ?: System.currentTimeMillis()
+
+        var pointerCount = previousEvent?.pointerCount ?: 0
+        if (action == MotionEvent.ACTION_POINTER_DOWN) {
+            pointerCount++
+        } else if (action == MotionEvent.ACTION_DOWN) {
+            pointerCount = 1
+        }
+
+        val properties = Array(pointerCount, ::getPointerProperties)
+        val pointerCoords = getPointerCoords(x, y, pointerCount)
+
+        return MotionEvent.obtain(
+            downTime, currentTime,
+            action, pointerCount, properties,
+            pointerCoords, 0, 0, 1f, 1f, 0, 0, 0, 0
+        )
+    }
+
+    private fun getPointerCoords(
+        x: Float,
+        y: Float,
+        pointerCount: Int,
+        previousEvent: MotionEvent? = null
+    ): Array<MotionEvent.PointerCoords?> {
+        val currentEventCoords = MotionEvent.PointerCoords().apply {
+            this.x = x; this.y = y; pressure = 1f; size = 1f
+        }
+
+        return if (pointerCount > 1 && previousEvent != null) {
+            arrayOf(
+                MotionEvent.PointerCoords().apply {
+                    this.x = previousEvent.x; this.y = previousEvent.y; pressure = 1f; size = 1f
+                },
+                currentEventCoords
+            )
+        } else {
+            arrayOf(currentEventCoords)
+        }
+    }
+
+    private fun getPointerProperties(id: Int): MotionEvent.PointerProperties =
+        MotionEvent.PointerProperties().apply {
+            this.id = id; this.toolType = MotionEvent.TOOL_TYPE_FINGER
+        }
+}
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 02c3b9d34519..fb7dec38f548 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -31,7 +31,10 @@ permalink: /changelog/
   * Glean was updated to v29.1.0
     * ⚠️ **This is a breaking change**: glinter errors found during code generation will now return an error code.
     * The minimum and maximum values of a timing distribution can now be controlled by the `time_unit` parameter. See [bug 1630997](https://bugzilla.mozilla.org/show_bug.cgi?id=1630997) for more details.
-  
+
+* **browser-toolbar**
+  * It will only be animated for vertical scrolls inside the EngineView. Not for horizontal scrolls. Not for zoom gestures.
+
 # 40.0.0
 
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v39.0.0...v40.0.0)
@@ -151,7 +154,7 @@ permalink: /changelog/
 
 * **Developer ergonomics**
   * Improved autoPublication workflow. See https://mozac.org/contributing/testing-components-inside-app for updated documentation.
-
+  
 * **browser-search**
   * Added `getSearchTemplate` to reconstruct the user-entered search engine url template
 
