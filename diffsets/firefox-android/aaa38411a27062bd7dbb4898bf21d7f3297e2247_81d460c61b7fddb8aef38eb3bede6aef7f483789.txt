diff --git a/focus-android/app/src/main/java/org/mozilla/focus/Components.kt b/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
index 74aff134dd90..8d60b1979b84 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
@@ -52,7 +52,6 @@ import org.mozilla.focus.downloads.DownloadService
 import org.mozilla.focus.engine.AppContentInterceptor
 import org.mozilla.focus.engine.ClientWrapper
 import org.mozilla.focus.engine.SanityCheckMiddleware
-import org.mozilla.focus.engine.TabsFeatureMiddleware
 import org.mozilla.focus.exceptions.ExceptionMigrationMiddleware
 import org.mozilla.focus.experiments.createNimbus
 import org.mozilla.focus.ext.components
@@ -64,6 +63,7 @@ import org.mozilla.focus.search.SearchMigration
 import org.mozilla.focus.state.AppState
 import org.mozilla.focus.state.AppStore
 import org.mozilla.focus.state.Screen
+import org.mozilla.focus.tabs.MergeTabsMiddleware
 import org.mozilla.focus.telemetry.GleanMetricsService
 import org.mozilla.focus.telemetry.TelemetryMiddleware
 import org.mozilla.focus.topsites.DefaultTopSitesStorage
@@ -141,7 +141,7 @@ class Components(
                 PromptMiddleware(),
                 AdsTelemetryMiddleware(adsTelemetry),
                 BlockedTrackersMiddleware(context),
-                TabsFeatureMiddleware()
+                MergeTabsMiddleware(),
             ) + EngineMiddleware.create(engine)
         )
     }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/engine/TabsFeatureMiddleware.kt b/focus-android/app/src/main/java/org/mozilla/focus/engine/TabsFeatureMiddleware.kt
deleted file mode 100644
index 31ec3c019564..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/engine/TabsFeatureMiddleware.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.engine
-
-import mozilla.components.browser.state.action.BrowserAction
-import mozilla.components.browser.state.action.InitAction
-import mozilla.components.browser.state.action.TabListAction
-import mozilla.components.browser.state.state.BrowserState
-import mozilla.components.lib.state.Middleware
-import mozilla.components.lib.state.MiddlewareContext
-import org.mozilla.focus.utils.AppConstants
-import org.mozilla.focus.utils.Features
-import java.lang.IllegalStateException
-
-/**
- * This middleware throws an exception if there's more than one tab and the feature flag for tabs
- * is disabled. It's primary purpose is to uncover situations where we unintentionally have to many
- * tabs.
- */
-class TabsFeatureMiddleware : Middleware<BrowserState, BrowserAction> {
-    override fun invoke(
-        context: MiddlewareContext<BrowserState, BrowserAction>,
-        next: (BrowserAction) -> Unit,
-        action: BrowserAction
-    ) {
-        next(action)
-
-        if (AppConstants.isDevOrNightlyBuild && (action is TabListAction || action is InitAction)) {
-            verifyTabFeatures(context.state)
-        }
-    }
-
-    private fun verifyTabFeatures(state: BrowserState) {
-        if (state.tabs.size > 1 && !Features.TABS) {
-            throw IllegalStateException("More than one tab even though tabs feature is disabled")
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/tabs/MergeTabsMiddleware.kt b/focus-android/app/src/main/java/org/mozilla/focus/tabs/MergeTabsMiddleware.kt
new file mode 100644
index 000000000000..99dd5e50334a
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/tabs/MergeTabsMiddleware.kt
@@ -0,0 +1,97 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.tabs
+
+import mozilla.components.browser.state.action.BrowserAction
+import mozilla.components.browser.state.action.EngineAction
+import mozilla.components.browser.state.action.TabListAction
+import mozilla.components.browser.state.selector.privateTabs
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.TabSessionState
+import mozilla.components.concept.engine.EngineSession
+import mozilla.components.lib.state.Middleware
+import mozilla.components.lib.state.MiddlewareContext
+import org.mozilla.focus.utils.Features
+
+/**
+ * If the tabs feature is disabled then this middleware will look at incoming [TabListAction.AddTabAction]
+ * actions and, instead of creating a new tab, will merge the new tab with the existing tab to create
+ * a single tab with a merged state.
+ */
+class MergeTabsMiddleware : Middleware<BrowserState, BrowserAction> {
+    override fun invoke(
+        context: MiddlewareContext<BrowserState, BrowserAction>,
+        next: (BrowserAction) -> Unit,
+        action: BrowserAction
+    ) {
+        if (Features.TABS || action !is TabListAction.AddTabAction) {
+            // If the feature flag for tabs is enabled then we can just let the reducer create a
+            // new tab.
+            next(action)
+            return
+        }
+
+        if (context.state.privateTabs.isEmpty()) {
+            // If we do not have any tabs yet then we can let the reducer create one.
+            next(action)
+            return
+        }
+
+        val currentTab = context.state.privateTabs.first()
+        val newTab = action.tab
+
+        if (!shouldLoadInExistingTab(newTab.content.url)) {
+            // This is a URL we do not want to load in an existing tab. Let's just bail.
+            return
+        }
+
+        val mergedTab = mergeTabs(currentTab, newTab)
+
+        // First we add the merged tab. The engine middleware will take care of linking the existing
+        // engine session to this tab.
+        next(TabListAction.AddTabAction(mergedTab, select = true))
+
+        // Then we can remove the previous tab. We first unlink the engine session to prevent the
+        // middleware from closing the engine session, which is now linked to the new tab.
+        context.dispatch(EngineAction.UnlinkEngineSessionAction(currentTab.id))
+        context.dispatch(TabListAction.RemoveTabAction(currentTab.id))
+
+        // Now we load the URL in the new tab.
+        context.dispatch(
+            EngineAction.LoadUrlAction(
+                mergedTab.id,
+                url = newTab.content.url,
+                flags = EngineSession.LoadUrlFlags.select(
+                    // To be safe we use the external flag here, since its not the user who decided to
+                    // load this URL in this existing session.
+                    EngineSession.LoadUrlFlags.EXTERNAL
+                )
+            )
+        )
+    }
+}
+
+private fun mergeTabs(
+    currentTab: TabSessionState,
+    newTab: TabSessionState
+): TabSessionState {
+    // We want to use the state of the current tab, but give it the ID of the new tab. This will make
+    // sure that code that created the tab can still access it with the ID.
+    return currentTab.copy(
+        newTab.id,
+        engineState = currentTab.engineState.copy(
+            // We are clearing the engine observer, which would update the state of the tab with the
+            // old ID. The engine middleware will create a new observer.
+            engineObserver = null
+        )
+    )
+}
+
+private fun shouldLoadInExistingTab(url: String): Boolean {
+    val cleanedUrl = url.lowercase().trim()
+    return cleanedUrl.startsWith("http:") ||
+        cleanedUrl.startsWith("https:") ||
+        cleanedUrl.startsWith("data:")
+}
