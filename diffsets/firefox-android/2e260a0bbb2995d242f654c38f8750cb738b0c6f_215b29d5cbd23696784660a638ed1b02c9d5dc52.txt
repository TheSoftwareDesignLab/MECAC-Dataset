diff --git a/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.java b/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.java
index 28aa8e4f7ef9..00d5adaa09cd 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.java
@@ -19,6 +19,7 @@
 import org.mozilla.focus.session.Session;
 import org.mozilla.focus.session.SessionManager;
 import org.mozilla.focus.session.SessionNotificationService;
+import org.mozilla.focus.session.VisibilityLifeCycleCallback;
 import org.mozilla.focus.telemetry.TelemetrySessionObserver;
 import org.mozilla.focus.telemetry.TelemetryWrapper;
 import org.mozilla.focus.utils.AdjustHelper;
@@ -28,6 +29,7 @@
 import java.util.List;
 
 public class FocusApplication extends LocaleAwareApplication {
+    private VisibilityLifeCycleCallback visibilityLifeCycleCallback;
 
     @Override
     public void onCreate() {
@@ -42,12 +44,18 @@ public void onCreate() {
         TelemetryWrapper.init(this);
         AdjustHelper.setupAdjustIfNeeded(this);
 
+        registerActivityLifecycleCallbacks(visibilityLifeCycleCallback = new VisibilityLifeCycleCallback(this));
+
         final LiveData<List<Session>> sessions = SessionManager.getInstance().getSessions();
         sessions.observeForever(new NotificationSessionObserver(this));
         sessions.observeForever(new TelemetrySessionObserver());
         sessions.observeForever(new CleanupSessionObserver(this));
     }
 
+    public VisibilityLifeCycleCallback getVisibilityLifeCycleCallback() {
+        return visibilityLifeCycleCallback;
+    }
+
     private void enableStrictMode() {
         // Android/WebView sometimes commit strict mode violations, see e.g.
         // https://github.com/mozilla-mobile/focus-android/issues/660
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java
index f059aba2bd61..e1dfed1cbfac 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java
@@ -66,6 +66,8 @@ public int onStartCommand(Intent intent, int flags, int startId) {
                 TelemetryWrapper.eraseNotificationEvent();
 
                 SessionManager.getInstance().removeAllSessions();
+
+                VisibilityLifeCycleCallback.finishAndRemoveTaskIfInBackground(this);
                 break;
 
             default:
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/VisibilityLifeCycleCallback.java b/focus-android/app/src/main/java/org/mozilla/focus/session/VisibilityLifeCycleCallback.java
new file mode 100644
index 000000000000..6555eaff5176
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/VisibilityLifeCycleCallback.java
@@ -0,0 +1,79 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.Application;
+import android.content.Context;
+import android.os.Bundle;
+
+import org.mozilla.focus.FocusApplication;
+
+/**
+ * This ActivityLifecycleCallbacks implementations tracks if there is at least one activity in the
+ * STARTED state (meaning some part of our application is visible).
+ * Based on this information the current task can be removed if the app is not visible.
+ */
+public class VisibilityLifeCycleCallback implements Application.ActivityLifecycleCallbacks {
+    /**
+     * If all activities of this app are in the background then finish and remove all tasks. After
+     * that the app won't show up in "recent apps" anymore.
+     */
+    /* package */ static void finishAndRemoveTaskIfInBackground(Context context) {
+        ((FocusApplication) context.getApplicationContext())
+                .getVisibilityLifeCycleCallback()
+                .finishAndRemoveTaskIfInBackground();
+    }
+
+    private Context context;
+
+    /**
+     * Activities are not stopped/started in an ordered way. So we are using
+     */
+    private int activitiesInStartedState;
+
+    public VisibilityLifeCycleCallback(Context context) {
+        this.context = context;
+    }
+
+    private void finishAndRemoveTaskIfInBackground() {
+        if (activitiesInStartedState == 0) {
+            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+            if (activityManager == null) {
+                return;
+            }
+
+            for (ActivityManager.AppTask task : activityManager.getAppTasks()) {
+                task.finishAndRemoveTask();
+            }
+        }
+    }
+
+    @Override
+    public void onActivityStarted(Activity activity) {
+        activitiesInStartedState++;
+    }
+
+    @Override
+    public void onActivityStopped(Activity activity) {
+        activitiesInStartedState--;
+    }
+
+    @Override
+    public void onActivityResumed(Activity activity) {}
+
+    @Override
+    public void onActivityPaused(Activity activity) {}
+
+    @Override
+    public void onActivityCreated(Activity activity, Bundle bundle) {}
+
+    @Override
+    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {}
+
+    @Override
+    public void onActivityDestroyed(Activity activity) {}
+}
