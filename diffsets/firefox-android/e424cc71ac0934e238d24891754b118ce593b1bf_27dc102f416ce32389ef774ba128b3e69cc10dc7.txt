diff --git a/android-components/buildSrc/src/main/java/Dependencies.kt b/android-components/buildSrc/src/main/java/Dependencies.kt
index 5f6327ad1ea7..b0552c405ba5 100644
--- a/android-components/buildSrc/src/main/java/Dependencies.kt
+++ b/android-components/buildSrc/src/main/java/Dependencies.kt
@@ -25,7 +25,7 @@ object Versions {
     const val jna = "5.2.0"
     const val disklrucache = "2.0.2"
 
-    const val mozilla_appservices = "0.30.0"
+    const val mozilla_appservices = "0.31.0"
     const val servo = "0.0.1.20181017.aa95911"
 
     const val material = "1.0.0"
@@ -114,6 +114,7 @@ object Dependencies {
     const val mozilla_rustlog = "org.mozilla.appservices:rustlog:${Versions.mozilla_appservices}"
     const val mozilla_servo_arm = "org.mozilla.servoview:servoview-armv7:${Versions.servo}"
     const val mozilla_servo_x86 = "org.mozilla.servoview:servoview-x86:${Versions.servo}"
+    const val mozilla_sync15 = "org.mozilla.appservices:sync15:${Versions.mozilla_appservices}"
 
     const val thirdparty_okhttp = "com.squareup.okhttp3:okhttp:${Versions.okhttp}"
     const val thirdparty_okhttp_urlconnection = "com.squareup.okhttp3:okhttp-urlconnection:${Versions.okhttp}"
diff --git a/android-components/components/browser/storage-sync/build.gradle b/android-components/components/browser/storage-sync/build.gradle
index c0e2d6f7b4c3..0e838658f0aa 100644
--- a/android-components/components/browser/storage-sync/build.gradle
+++ b/android-components/components/browser/storage-sync/build.gradle
@@ -2,6 +2,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+plugins {
+    id "com.jetbrains.python.envs" version "0.0.26"
+}
+
 apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
@@ -46,7 +50,9 @@ dependencies {
     api project(':concept-storage')
     api project(':concept-sync')
 
+    implementation project(':service-glean')
     implementation project(':support-utils')
+    implementation Dependencies.mozilla_sync15
 
     implementation Dependencies.kotlin_stdlib
 
@@ -61,7 +67,11 @@ dependencies {
     testImplementation Dependencies.mozilla_support
     testImplementation files(configurations.jnaForTest.copyRecursive().files)
     testImplementation Dependencies.mozilla_places_forUnitTests
+    testImplementation Dependencies.testing_mockwebserver
+    testImplementation Dependencies.androidx_work_testing
 }
 
 apply from: '../../../publish.gradle'
 ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
+
+apply from: '../../service/glean/scripts/sdk_generator.gradle'
diff --git a/android-components/components/browser/storage-sync/metrics.yaml b/android-components/components/browser/storage-sync/metrics.yaml
new file mode 100644
index 000000000000..b2ba4a9e0606
--- /dev/null
+++ b/android-components/components/browser/storage-sync/metrics.yaml
@@ -0,0 +1,272 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0
+
+# The `sync.history` and `sync.bookmarks` metrics use the same structure,
+# but must be specified twice. We can't define them once and use
+# `send_in_pings` because the stores might be synced in parallel, and we can't
+# guarantee that a ping for one store would be sent before the others.
+history_sync:
+  uid:
+    type: string
+    description: >
+      The user's hashed Firefox Account ID.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  started_at:
+    type: datetime
+    time_unit: millisecond
+    description: >
+      Records when the history sync started.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  finished_at:
+    type: datetime
+    time_unit: millisecond
+    description: >
+      Records when the history sync finished. This includes the time to
+      download, apply, and upload all records.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  incoming:
+    type: labeled_counter
+    labels:
+    - applied
+    - failed_to_apply
+    - reconciled
+    description: >
+      Records incoming history record counts. `applied` is the number of
+      incoming history pages that were successfully stored or updated in the
+      local database. `failed_to_apply` is the number of pages that were
+      ignored due to errors. `reconciled` is the number of pages with new visits
+      locally and remotely, and had their visits merged.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  outgoing:
+    type: labeled_counter
+    labels:
+    - uploaded
+    - failed_to_upload
+    description: >
+      Records outgoing history record counts. `uploaded` is the number of
+      records that were successfully sent to the server. `failed_to_upload`
+      is the number of records that weren't uploaded, and will be retried
+      on the next sync.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  outgoing_batches:
+    type: counter
+    description: >
+      Records the number of batches needed to upload all outgoing records. The
+      Sync server has a hard limit on the number of records (and request body
+      bytes) on the number of records that can fit into a single batch, and
+      large syncs may require multiple batches.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  failure_reason:
+    type: labeled_string
+    labels:
+    - other
+    - unexpected
+    - auth
+    description: >
+      Records why the history sync failed: either due to an authentication
+      error, unexpected exception, or other error. The error strings are
+      truncated and sanitized to omit PII, like URLs and file system paths.
+    send_in_pings:
+    - history_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+
+bookmarks_sync:
+  uid:
+    type: string
+    description: >
+      The user's hashed Firefox Account ID.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  started_at:
+    type: datetime
+    time_unit: millisecond
+    description: >
+      Records when the bookmark sync started.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  finished_at:
+    type: datetime
+    time_unit: millisecond
+    description: >
+      Records when the bookmark sync finished.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  incoming:
+    type: labeled_counter
+    labels:
+    - applied
+    - failed_to_apply
+    - reconciled
+    description: >
+      Records incoming bookmark record counts.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  outgoing:
+    type: labeled_counter
+    labels:
+    - uploaded
+    - failed_to_upload
+    description: >
+      Records outgoing bookmark record counts.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  outgoing_batches:
+    type: counter
+    description: >
+      Records the number of batches needed to upload all outgoing records.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  failure_reason:
+    type: labeled_string
+    labels:
+    - other
+    - unexpected
+    - auth
+    description: >
+      Records bookmark sync failure reasons.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
+  remote_tree_problems:
+    type: labeled_counter
+    labels:
+    - orphans
+    - misparented_roots
+    - multiple_parents_by_children
+    - missing_parent_guids
+    - non_folder_parent_guids
+    - parent_child_disagreements
+    - missing_children
+    description: >
+      Records counts for structure problems and divergences in the remote
+      bookmarks tree. These are documented in
+      https://github.com/mozilla/dogear/blob/fbade15f2a4f11215e30b8f428a0a8df3defeaec/src/tree.rs#L1273-L1294.
+    send_in_pings:
+    - bookmarks_sync
+    bugs:
+    - 3092
+    data_reviews:
+    - https://github.com/mozilla-mobile/android-components/pull/3092
+    notification_emails:
+    - sync-core@mozilla.com
+    expires: never
+    lifetime: ping
diff --git a/android-components/components/browser/storage-sync/pings.yaml b/android-components/components/browser/storage-sync/pings.yaml
new file mode 100644
index 000000000000..abc084c09266
--- /dev/null
+++ b/android-components/components/browser/storage-sync/pings.yaml
@@ -0,0 +1,28 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+$schema: moz://mozilla.org/schemas/glean/pings/1-0-0
+
+history_sync:
+  description: >
+    A ping sent for every history sync. It doesn't include the `client_id`
+    because it reports a hashed version of the user's Firefox Account ID.
+  include_client_id: false
+  bugs:
+  - 3092
+  notification_emails:
+  - sync-core@mozilla.com
+  data_reviews:
+  - https://github.com/mozilla-mobile/android-components/pull/3092
+bookmarks_sync:
+  description: >
+    A ping sent for every bookmarks sync. It doesn't include the `client_id`
+    because it reports a hashed version of the user's Firefox Account ID.
+  include_client_id: false
+  bugs:
+  - 3092
+  notification_emails:
+  - sync-core@mozilla.com
+  data_reviews:
+  - https://github.com/mozilla-mobile/android-components/pull/3092
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
index af82da03a714..042eb93593ed 100644
--- a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
@@ -8,10 +8,17 @@ import androidx.annotation.GuardedBy
 import mozilla.appservices.places.PlacesApi
 import mozilla.appservices.places.PlacesReaderConnection
 import mozilla.appservices.places.PlacesWriterConnection
+import mozilla.appservices.sync15.FailureName
+import mozilla.appservices.sync15.FailureReason
+import mozilla.appservices.sync15.SyncTelemetryPing
+import mozilla.components.browser.storage.sync.GleanMetrics.BookmarksSync
+import mozilla.components.browser.storage.sync.GleanMetrics.HistorySync
+import mozilla.components.browser.storage.sync.GleanMetrics.Pings
 import java.io.Closeable
 import java.io.File
 
 const val DB_NAME = "places.sqlite"
+const val MAX_FAILURE_REASON_LENGTH = 100
 
 /**
  * A slight abstraction over [PlacesApi].
@@ -22,7 +29,7 @@ const val DB_NAME = "places.sqlite"
  *
  * Writer is always the same, as guaranteed by [PlacesApi].
  */
-interface Connection : Closeable {
+internal interface Connection : Closeable {
     fun reader(): PlacesReaderConnection
     fun writer(): PlacesWriterConnection
 
@@ -30,6 +37,112 @@ interface Connection : Closeable {
     // strange split that doesn't quite map all that well to our internal storage model.
     fun syncHistory(syncInfo: SyncAuthInfo)
     fun syncBookmarks(syncInfo: SyncAuthInfo)
+
+    // These are implemented as default methods on `Connection` instead of
+    // `RustPlacesConnection` to make testing easier.
+    @Suppress("ComplexMethod", "NestedBlockDepth")
+    fun assembleHistoryPing(ping: SyncTelemetryPing) {
+        ping.syncs.forEach eachSync@{ sync ->
+            sync.failureReason?.let {
+                recordHistoryFailureReason(it)
+                sendHistoryPing()
+                return@eachSync
+            }
+            sync.engines.forEach eachEngine@{ engine ->
+                if (engine.name != "history") {
+                    return@eachEngine
+                }
+                HistorySync.apply {
+                    val base = BaseGleanSyncPing.fromEngineInfo(ping.uid, engine)
+                    uid.set(base.uid)
+                    startedAt.set(base.startedAt)
+                    finishedAt.set(base.finishedAt)
+                    if (base.applied > 0) {
+                        // Since all Sync ping counters have `lifetime: ping`, and
+                        // we send the ping immediately after, we don't need to
+                        // reset the counters before calling `add`.
+                        incoming["applied"].add(base.applied)
+                    }
+                    if (base.failedToApply > 0) {
+                        incoming["failed_to_apply"].add(base.failedToApply)
+                    }
+                    if (base.reconciled > 0) {
+                        incoming["reconciled"].add(base.reconciled)
+                    }
+                    if (base.uploaded > 0) {
+                        outgoing["uploaded"].add(base.uploaded)
+                    }
+                    if (base.failedToUpload > 0) {
+                        outgoing["failed_to_upload"].add(base.failedToUpload)
+                    }
+                    if (base.outgoingBatches > 0) {
+                        outgoingBatches.add(base.outgoingBatches)
+                    }
+                    base.failureReason?.let {
+                        recordHistoryFailureReason(it)
+                    }
+                }
+                sendHistoryPing()
+            }
+        }
+    }
+    fun sendHistoryPing() {}
+
+    // This function is almost identical to `recordHistoryPing`, with additional
+    // reporting for validation problems. Unfortunately, since the
+    // `BookmarksSync` and `HistorySync` metrics are two separate objects, we
+    // can't factor this out into a generic function.
+    @Suppress("ComplexMethod", "NestedBlockDepth")
+    fun assembleBookmarksPing(ping: SyncTelemetryPing) {
+        ping.syncs.forEach eachSync@{ sync ->
+            sync.failureReason?.let {
+                // If the entire sync fails, don't try to unpack the ping; just
+                // report the error and bail.
+                recordBookmarksFailureReason(it)
+                sendBookmarksPing()
+                return@eachSync
+            }
+            sync.engines.forEach eachEngine@{ engine ->
+                if (engine.name != "bookmarks") {
+                    return@eachEngine
+                }
+                BookmarksSync.apply {
+                    val base = BaseGleanSyncPing.fromEngineInfo(ping.uid, engine)
+                    uid.set(base.uid)
+                    startedAt.set(base.startedAt)
+                    finishedAt.set(base.finishedAt)
+                    if (base.applied > 0) {
+                        incoming["applied"].add(base.applied)
+                    }
+                    if (base.failedToApply > 0) {
+                        incoming["failed_to_apply"].add(base.failedToApply)
+                    }
+                    if (base.reconciled > 0) {
+                        incoming["reconciled"].add(base.reconciled)
+                    }
+                    if (base.uploaded > 0) {
+                        outgoing["uploaded"].add(base.uploaded)
+                    }
+                    if (base.failedToUpload > 0) {
+                        outgoing["failed_to_upload"].add(base.failedToUpload)
+                    }
+                    if (base.outgoingBatches > 0) {
+                        outgoingBatches.add(base.outgoingBatches)
+                    }
+                    base.failureReason?.let {
+                        recordBookmarksFailureReason(it)
+                    }
+                    engine.validation?.let {
+                        it.problems.forEach {
+                            remoteTreeProblems[it.name].add(it.count)
+                        }
+                    }
+                }
+                sendBookmarksPing()
+            }
+        }
+    }
+    fun sendBookmarksPing() {}
 }
 
 /**
@@ -67,12 +180,22 @@ internal object RustPlacesConnection : Connection {
 
     override fun syncHistory(syncInfo: SyncAuthInfo) {
         check(api != null) { "must call init first" }
-        api!!.syncHistory(syncInfo)
+        val ping = api!!.syncHistory(syncInfo)
+        assembleHistoryPing(ping)
+    }
+
+    override fun sendHistoryPing() {
+        Pings.historySync.send()
     }
 
     override fun syncBookmarks(syncInfo: SyncAuthInfo) {
         check(api != null) { "must call init first" }
-        api!!.syncBookmarks(syncInfo)
+        val ping = api!!.syncBookmarks(syncInfo)
+        assembleBookmarksPing(ping)
+    }
+
+    override fun sendBookmarksPing() {
+        Pings.bookmarksSync.send()
     }
 
     override fun close() = synchronized(this) {
@@ -81,3 +204,25 @@ internal object RustPlacesConnection : Connection {
         api = null
     }
 }
+
+private fun recordHistoryFailureReason(reason: FailureReason) {
+    val metric = when (reason.name) {
+        FailureName.Other, FailureName.Unknown -> HistorySync.failureReason["other"]
+        FailureName.Unexpected, FailureName.Http -> HistorySync.failureReason["unexpected"]
+        FailureName.Auth -> HistorySync.failureReason["auth"]
+        FailureName.Shutdown -> return
+    }
+    val message = reason.message ?: "Unexpected error: ${reason.code}"
+    metric.set(message.take(MAX_FAILURE_REASON_LENGTH))
+}
+
+private fun recordBookmarksFailureReason(reason: FailureReason) {
+    val metric = when (reason.name) {
+        FailureName.Other, FailureName.Unknown -> BookmarksSync.failureReason["other"]
+        FailureName.Unexpected, FailureName.Http -> BookmarksSync.failureReason["unexpected"]
+        FailureName.Auth -> BookmarksSync.failureReason["auth"]
+        FailureName.Shutdown -> return
+    }
+    val message = reason.message ?: "Unexpected error: ${reason.code}"
+    metric.set(message.take(MAX_FAILURE_REASON_LENGTH))
+}
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Types.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Types.kt
index 29df213165d4..fdd0e43357e1 100644
--- a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Types.kt
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Types.kt
@@ -2,8 +2,12 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+@file:Suppress("MatchingDeclarationName")
 package mozilla.components.browser.storage.sync
 
+import java.util.Date
+import mozilla.appservices.sync15.EngineInfo
+import mozilla.appservices.sync15.FailureReason
 import mozilla.components.concept.storage.VisitInfo
 import mozilla.components.concept.storage.VisitType
 import mozilla.components.concept.sync.AuthInfo
@@ -60,3 +64,51 @@ internal fun mozilla.appservices.places.VisitInfo.into(): VisitInfo {
         visitType = this.visitType.into()
     )
 }
+
+/**
+ * Holds fields common to all Glean sync engine pings.
+ */
+internal data class BaseGleanSyncPing(
+    val uid: String,
+    val startedAt: Date,
+    val finishedAt: Date,
+    val applied: Int,
+    val failedToApply: Int,
+    val reconciled: Int,
+    val uploaded: Int,
+    val failedToUpload: Int,
+    val outgoingBatches: Int,
+    val failureReason: FailureReason?
+) {
+    companion object {
+        const val MILLIS_PER_SEC = 1000L
+
+        fun fromEngineInfo(uid: String, info: EngineInfo): BaseGleanSyncPing {
+            val failedToApply = info.incoming?.let {
+                it.failed + it.newFailed
+            } ?: 0
+            val (uploaded, failedToUpload) = info.outgoing.fold(Pair(0, 0)) { totals, batch ->
+                val (uploaded, failedToUpload) = totals
+                Pair(uploaded + batch.sent, failedToUpload + batch.failed)
+            }
+            return BaseGleanSyncPing(
+                uid = uid,
+                startedAt = Date(info.at.toLong() * MILLIS_PER_SEC),
+                // Glean intentionally doesn't support recording arbitrary
+                // durations in timespans, and we can't use the timespan
+                // measurement API because everything is measured in Rust
+                // code. Instead, we record absolute start and end times.
+                // The Sync ping records both `at` _and_ `took`, so this doesn't
+                // leak additional info.
+                finishedAt = Date(info.at.toLong() * MILLIS_PER_SEC + info.took),
+                applied = info.incoming?.applied ?: 0,
+                failedToApply = failedToApply,
+                reconciled = info.incoming?.reconciled ?: 0,
+                uploaded = uploaded,
+                failedToUpload = failedToUpload,
+                outgoingBatches = info.outgoing.size,
+                failureReason = info.failureReason
+            )
+        }
+    }
+}
diff --git a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt
index b34ce267cab8..c40520217833 100644
--- a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt
+++ b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt
@@ -5,11 +5,24 @@ import mozilla.appservices.places.BookmarkRoot
 import mozilla.appservices.places.BookmarkUpdateInfo
 import mozilla.appservices.places.PlacesReaderConnection
 import mozilla.appservices.places.PlacesWriterConnection
+import mozilla.appservices.sync15.EngineInfo
+import mozilla.appservices.sync15.FailureName
+import mozilla.appservices.sync15.FailureReason
+import mozilla.appservices.sync15.OutgoingInfo
+import mozilla.appservices.sync15.ProblemInfo
+import mozilla.appservices.sync15.SyncInfo
+import mozilla.appservices.sync15.SyncTelemetryPing
+import mozilla.appservices.sync15.ValidationInfo
+import mozilla.components.browser.storage.sync.GleanMetrics.BookmarksSync
+import mozilla.components.browser.storage.sync.GleanMetrics.Pings
 import mozilla.components.concept.storage.BookmarkInfo
 import mozilla.components.concept.storage.BookmarkNode
 import mozilla.components.concept.storage.BookmarkNodeType
+import mozilla.components.concept.sync.AuthInfo
+import mozilla.components.concept.sync.SyncStatus
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -17,6 +30,7 @@ import org.mockito.Mockito.`when`
 import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
 import org.robolectric.RobolectricTestRunner
+import java.util.Date
 
 @RunWith(RobolectricTestRunner::class)
 class PlacesBookmarksStorageTest {
@@ -34,7 +48,7 @@ class PlacesBookmarksStorageTest {
     private val newSeparator = BookmarkNode(BookmarkNodeType.SEPARATOR, "654", "987",
             null, null, null, null)
 
-    class TestablePlacesBookmarksStorage(override val places: Connection) : PlacesBookmarksStorage(testContext)
+    internal class TestablePlacesBookmarksStorage(override val places: Connection) : PlacesBookmarksStorage(testContext)
 
     @Before
     fun setup() {
@@ -263,5 +277,345 @@ class PlacesBookmarksStorageTest {
         verify(writer, times(1)).deleteBookmarkNode(newSeparator.guid)
     }
 
+    @Test
+    fun `sends bookmarks telemetry pings on success`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                Assert.fail()
+            }
+
+            override fun sendHistoryPing() {
+                Assert.fail()
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                assembleBookmarksPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "xyz789",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now + 20,
+                            took = 8000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 25,
+                                    took = 6000,
+                                    incoming = null,
+                                    outgoing = listOf(
+                                        OutgoingInfo(
+                                            sent = 10,
+                                            failed = 5
+                                        )
+                                    ),
+                                    failureReason = null,
+                                    validation = ValidationInfo(
+                                        version = 2,
+                                        problems = listOf(
+                                            ProblemInfo(
+                                                name = "missingParents",
+                                                count = 5
+                                            ),
+                                            ProblemInfo(
+                                                name = "missingChildren",
+                                                count = 7
+                                            )
+                                        ),
+                                        failureReason = null
+                                    )
+                                )
+                            ),
+                            failureReason = null
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendBookmarksPing() {
+                when (pingCount) {
+                    0 -> {
+                        BookmarksSync.apply {
+                            Assert.assertEquals("xyz789", uid.testGetValue())
+                            Assert.assertEquals(now + 25, startedAt.testGetValue().asSeconds())
+                            Assert.assertEquals(now + 31, finishedAt.testGetValue().asSeconds())
+                            Assert.assertFalse(incoming["applied"].testHasValue())
+                            Assert.assertFalse(incoming["failed_to_apply"].testHasValue())
+                            Assert.assertFalse(incoming["reconciled"].testHasValue())
+                            Assert.assertEquals(10, outgoing["uploaded"].testGetValue())
+                            Assert.assertEquals(5, outgoing["failed_to_upload"].testGetValue())
+                            Assert.assertEquals(1, outgoingBatches.testGetValue())
+                        }
+                    }
+                    else -> Assert.fail()
+                }
+                Pings.bookmarksSync.send()
+                pingCount++
+            }
+
+            override fun close() {
+                Assert.fail()
+            }
+        }
+        val storage = TestablePlacesBookmarksStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        Assert.assertTrue(result is SyncStatus.Ok)
+        Assert.assertEquals(conn.pingCount, 1)
+    }
+
+    @Test
+    fun `sends bookmarks telemetry pings on engine failure`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                Assert.fail()
+            }
+
+            override fun sendHistoryPing() {
+                Assert.fail()
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                assembleBookmarksPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "abc123",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now,
+                            took = 5000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 1,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unknown, "Boxes not locked"),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 2,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Shutdown),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 3,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unknown, "Synergies not aligned"),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 4,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Http, code = 418),
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        ),
+                        SyncInfo(
+                            at = now + 5,
+                            took = 4000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 6,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Auth, "Splines not reticulated", 999),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 7,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unexpected, "Kaboom!"),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 8,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Other, "Qualia unsynchronized"), // other
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendBookmarksPing() {
+                when (pingCount) {
+                    0 -> {
+                        // Shutdown errors shouldn't be reported.
+                        Assert.assertTrue(listOf(
+                            "other",
+                            "unexpected",
+                            "auth"
+                        ).none { BookmarksSync.failureReason[it].testHasValue() })
+                    }
+                    1 -> BookmarksSync.apply {
+                        Assert.assertEquals("Synergies not aligned", failureReason["other"].testGetValue())
+                        Assert.assertFalse(failureReason["unexpected"].testHasValue())
+                        Assert.assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    2 -> BookmarksSync.apply {
+                        Assert.assertEquals("Unexpected error: 418", failureReason["unexpected"].testGetValue())
+                        Assert.assertFalse(failureReason["other"].testHasValue())
+                        Assert.assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    3 -> BookmarksSync.apply {
+                        Assert.assertEquals("Splines not reticulated", failureReason["auth"].testGetValue())
+                        Assert.assertFalse(failureReason["other"].testHasValue())
+                        Assert.assertFalse(failureReason["unexpected"].testHasValue())
+                    }
+                    4 -> BookmarksSync.apply {
+                        Assert.assertEquals("Kaboom!", failureReason["unexpected"].testGetValue())
+                        Assert.assertFalse(failureReason["other"].testHasValue())
+                        Assert.assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    5 -> BookmarksSync.apply {
+                        Assert.assertEquals("Qualia unsynchronized", failureReason["other"].testGetValue())
+                        Assert.assertFalse(failureReason["unexpected"].testHasValue())
+                        Assert.assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    else -> Assert.fail()
+                }
+                // We still need to send the ping, so that the counters are
+                // cleared out between calls to `sendBookmarksPing`.
+                Pings.bookmarksSync.send()
+                pingCount++
+            }
+
+            override fun close() {
+                Assert.fail()
+            }
+        }
+        val storage = TestablePlacesBookmarksStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        Assert.assertTrue(result is SyncStatus.Ok)
+        Assert.assertEquals(6, conn.pingCount)
+    }
+
+    @Test
+    fun `sends bookmarks telemetry pings on sync failure`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                Assert.fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                Assert.fail()
+            }
+
+            override fun sendHistoryPing() {
+                Assert.fail()
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                assembleBookmarksPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "abc123",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now,
+                            took = 5000,
+                            engines = emptyList(),
+                            failureReason = FailureReason(FailureName.Unknown, "Synergies not aligned")
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendBookmarksPing() {
+                when (pingCount) {
+                    0 -> BookmarksSync.apply {
+                        Assert.assertEquals("Synergies not aligned", failureReason["other"].testGetValue())
+                        Assert.assertFalse(failureReason["unexpected"].testHasValue())
+                        Assert.assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    else -> Assert.fail()
+                }
+                // We still need to send the ping, so that the counters are
+                // cleared out between calls to `sendHistoryPing`.
+                Pings.bookmarksSync.send()
+                pingCount++
+            }
+
+            override fun close() {
+                Assert.fail()
+            }
+        }
+        val storage = TestablePlacesBookmarksStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        Assert.assertTrue(result is SyncStatus.Ok)
+        Assert.assertEquals(1, conn.pingCount)
+    }
+
     private fun BookmarkInfo.asBookmarkUpdateInfo(): BookmarkUpdateInfo = BookmarkUpdateInfo(this.parentGuid, this.position, this.title, this.url)
 }
\ No newline at end of file
diff --git a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
index 087f23f798f3..cc06ce9d0268 100644
--- a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
+++ b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
@@ -10,6 +10,15 @@ import mozilla.appservices.places.InternalPanic
 import mozilla.appservices.places.PlacesException
 import mozilla.appservices.places.PlacesReaderConnection
 import mozilla.appservices.places.PlacesWriterConnection
+import mozilla.appservices.sync15.EngineInfo
+import mozilla.appservices.sync15.FailureName
+import mozilla.appservices.sync15.FailureReason
+import mozilla.appservices.sync15.IncomingInfo
+import mozilla.appservices.sync15.OutgoingInfo
+import mozilla.appservices.sync15.SyncInfo
+import mozilla.appservices.sync15.SyncTelemetryPing
+import mozilla.components.browser.storage.sync.GleanMetrics.HistorySync
+import mozilla.components.browser.storage.sync.GleanMetrics.Pings
 import mozilla.components.concept.storage.PageObservation
 import mozilla.components.concept.storage.VisitType
 import mozilla.components.concept.sync.AuthInfo
@@ -18,6 +27,7 @@ import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
 import org.junit.After
 import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNull
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
@@ -25,6 +35,7 @@ import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.robolectric.RobolectricTestRunner
+import java.util.Date
 
 @RunWith(RobolectricTestRunner::class)
 class PlacesHistoryStorageTest {
@@ -477,7 +488,7 @@ class PlacesHistoryStorageTest {
 
     // We can't test 'sync' stuff yet, since that exercises the network and we can't mock that out currently.
     // Instead, we test that our wrappers act correctly.
-    class MockingPlacesHistoryStorage(override val places: Connection) : PlacesHistoryStorage(testContext)
+    internal class MockingPlacesHistoryStorage(override val places: Connection) : PlacesHistoryStorage(testContext)
 
     @Test
     fun `storage passes through sync calls`() = runBlocking {
@@ -579,6 +590,393 @@ class PlacesHistoryStorageTest {
         assertEquals("test error", error.exception.message)
     }
 
+    @Test
+    fun `sends history telemetry pings on success`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                assembleHistoryPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "abc123",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now,
+                            took = 10000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "logins",
+                                    at = now + 5,
+                                    took = 5000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = null,
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "history",
+                                    at = now,
+                                    took = 5000,
+                                    incoming = IncomingInfo(
+                                        applied = 5,
+                                        failed = 4,
+                                        newFailed = 3,
+                                        reconciled = 2
+                                    ),
+                                    outgoing = listOf(
+                                        OutgoingInfo(
+                                            sent = 10,
+                                            failed = 5
+                                        ),
+                                        OutgoingInfo(
+                                            sent = 4,
+                                            failed = 2
+                                        )
+                                    ),
+                                    failureReason = null,
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        ),
+                        SyncInfo(
+                            at = now + 10,
+                            took = 5000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 10,
+                                    took = 5000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = null,
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendHistoryPing() {
+                when (pingCount) {
+                    0 -> {
+                        HistorySync.apply {
+                            assertEquals("abc123", uid.testGetValue())
+                            assertEquals(now, startedAt.testGetValue().asSeconds())
+                            assertEquals(now + 5, finishedAt.testGetValue().asSeconds())
+                            assertEquals(5, incoming["applied"].testGetValue())
+                            assertEquals(7, incoming["failed_to_apply"].testGetValue())
+                            assertEquals(2, incoming["reconciled"].testGetValue())
+                            assertEquals(14, outgoing["uploaded"].testGetValue())
+                            assertEquals(7, outgoing["failed_to_upload"].testGetValue())
+                            assertEquals(2, outgoingBatches.testGetValue())
+                        }
+                    }
+                    1 -> {
+                        HistorySync.apply {
+                            assertEquals("abc123", uid.testGetValue())
+                            assertEquals(now + 10, startedAt.testGetValue().asSeconds())
+                            assertEquals(now + 15, finishedAt.testGetValue().asSeconds())
+                            assertTrue(listOf(
+                                incoming["applied"],
+                                incoming["failed_to_apply"],
+                                incoming["reconciled"],
+                                outgoing["uploaded"],
+                                outgoing["failed_to_upload"],
+                                outgoingBatches
+                            ).none { it.testHasValue() })
+                        }
+                    }
+                    else -> fail()
+                }
+                // We still need to send the ping, so that the counters are
+                // cleared out between calls to `sendHistoryPing`.
+                Pings.historySync.send()
+                pingCount++
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                fail()
+            }
+
+            override fun sendBookmarksPing() {
+                fail()
+            }
+
+            override fun close() {
+                fail()
+            }
+        }
+        val storage = MockingPlacesHistoryStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        assertTrue(result is SyncStatus.Ok)
+        assertEquals(2, conn.pingCount)
+    }
+
+    @Test
+    fun `sends history telemetry pings on engine failure`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                assembleHistoryPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "abc123",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now,
+                            took = 5000,
+                            engines = listOf(
+                                // We should ignore any engines that aren't
+                                // history.
+                                EngineInfo(
+                                    name = "bookmarks",
+                                    at = now + 1,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unknown, "Boxes not locked"),
+                                    validation = null
+                                ),
+                                // Multiple history engine syncs per sync isn't
+                                // expected, but it's easier to test the
+                                // different failure types this way, instead of
+                                // creating a top-level `SyncInfo` for each
+                                // one.
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 2,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Shutdown),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 3,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unknown, "Synergies not aligned"),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 4,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Http, code = 418),
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        ),
+                        // ...But, just in case, we also test multiple top-level
+                        // syncs.
+                        SyncInfo(
+                            at = now + 5,
+                            took = 4000,
+                            engines = listOf(
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 6,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Auth, "Splines not reticulated", 999),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 7,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Unexpected, "Kaboom!"),
+                                    validation = null
+                                ),
+                                EngineInfo(
+                                    name = "history",
+                                    at = now + 8,
+                                    took = 1000,
+                                    incoming = null,
+                                    outgoing = emptyList(),
+                                    failureReason = FailureReason(FailureName.Other, "Qualia unsynchronized"), // other
+                                    validation = null
+                                )
+                            ),
+                            failureReason = null
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendHistoryPing() {
+                when (pingCount) {
+                    0 -> {
+                        // Shutdown errors shouldn't be reported at all.
+                        assertTrue(listOf(
+                            "other",
+                            "unexpected",
+                            "auth"
+                        ).none { HistorySync.failureReason[it].testHasValue() })
+                    }
+                    1 -> HistorySync.apply {
+                        assertEquals("Synergies not aligned", failureReason["other"].testGetValue())
+                        assertFalse(failureReason["unexpected"].testHasValue())
+                        assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    2 -> HistorySync.apply {
+                        assertEquals("Unexpected error: 418", failureReason["unexpected"].testGetValue())
+                        assertFalse(failureReason["other"].testHasValue())
+                        assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    3 -> HistorySync.apply {
+                        assertEquals("Splines not reticulated", failureReason["auth"].testGetValue())
+                        assertFalse(failureReason["other"].testHasValue())
+                        assertFalse(failureReason["unexpected"].testHasValue())
+                    }
+                    4 -> HistorySync.apply {
+                        assertEquals("Kaboom!", failureReason["unexpected"].testGetValue())
+                        assertFalse(failureReason["other"].testHasValue())
+                        assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    5 -> HistorySync.apply {
+                        assertEquals("Qualia unsynchronized", failureReason["other"].testGetValue())
+                        assertFalse(failureReason["unexpected"].testHasValue())
+                        assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    else -> fail()
+                }
+                // We still need to send the ping, so that the counters are
+                // cleared out between calls to `sendHistoryPing`.
+                Pings.historySync.send()
+                pingCount++
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                fail()
+            }
+
+            override fun sendBookmarksPing() {
+                fail()
+            }
+
+            override fun close() {
+                fail()
+            }
+        }
+        val storage = MockingPlacesHistoryStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        assertTrue(result is SyncStatus.Ok)
+        assertEquals(6, conn.pingCount)
+    }
+
+    @Test
+    fun `sends history telemetry pings on sync failure`() = runBlocking {
+        resetGlean()
+
+        val now = Date().asSeconds()
+        val conn = object : Connection {
+            var pingCount = 0
+
+            override fun reader(): PlacesReaderConnection {
+                fail()
+                return mock()
+            }
+
+            override fun writer(): PlacesWriterConnection {
+                fail()
+                return mock()
+            }
+
+            override fun syncHistory(syncInfo: SyncAuthInfo) {
+                assembleHistoryPing(SyncTelemetryPing(
+                    version = 1,
+                    uid = "abc123",
+                    syncs = listOf(
+                        SyncInfo(
+                            at = now,
+                            took = 5000,
+                            engines = emptyList(),
+                            failureReason = FailureReason(FailureName.Unknown, "Synergies not aligned")
+                        )
+                    ),
+                    events = emptyList()
+                ))
+            }
+
+            override fun sendHistoryPing() {
+                when (pingCount) {
+                    0 -> HistorySync.apply {
+                        assertEquals("Synergies not aligned", failureReason["other"].testGetValue())
+                        assertFalse(failureReason["unexpected"].testHasValue())
+                        assertFalse(failureReason["auth"].testHasValue())
+                    }
+                    else -> fail()
+                }
+                // We still need to send the ping, so that the counters are
+                // cleared out between calls to `sendHistoryPing`.
+                Pings.historySync.send()
+                pingCount++
+            }
+
+            override fun syncBookmarks(syncInfo: SyncAuthInfo) {
+                fail()
+            }
+
+            override fun sendBookmarksPing() {
+                fail()
+            }
+
+            override fun close() {
+                fail()
+            }
+        }
+        val storage = MockingPlacesHistoryStorage(conn)
+
+        val result = storage.sync(AuthInfo("kid", "token", "key", "serverUrl"))
+
+        assertTrue(result is SyncStatus.Ok)
+        assertEquals(1, conn.pingCount)
+    }
+
     @Test(expected = InternalPanic::class)
     fun `storage re-throws sync panics`() = runBlocking {
         val exception = InternalPanic("test panic")
diff --git a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/TestUtil.kt b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/TestUtil.kt
new file mode 100644
index 000000000000..edb75264f413
--- /dev/null
+++ b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/TestUtil.kt
@@ -0,0 +1,31 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.storage.sync
+
+import android.content.Context
+import androidx.test.core.app.ApplicationProvider
+import androidx.work.testing.WorkManagerTestInitHelper
+import mozilla.components.service.glean.Glean
+import java.util.Date
+
+/**
+ * Enable testing mode, initialize [WorkManagerTestInitHelper] for testing,
+ * and initialize Glean. This is used in tests that send Glean pings.
+ *
+ * @param context the application context to init Glean with
+ */
+internal fun resetGlean(
+    context: Context = ApplicationProvider.getApplicationContext()
+) {
+    Glean.enableTestingMode()
+
+    // We're using the WorkManager in a bunch of places, and Glean will crash
+    // in tests without this line. Let's simply put it here.
+    WorkManagerTestInitHelper.initializeTestWorkManager(context)
+
+    Glean.initialize(context)
+}
+
+fun Date.asSeconds() = time / BaseGleanSyncPing.MILLIS_PER_SEC
diff --git a/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/StorageSync.kt b/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/StorageSync.kt
index b44e13ae3b09..346e66ff142c 100644
--- a/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/StorageSync.kt
+++ b/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/StorageSync.kt
@@ -11,10 +11,10 @@ import mozilla.components.concept.sync.AuthException
 import mozilla.components.concept.sync.AuthInfo
 import mozilla.components.concept.sync.OAuthAccount
 import mozilla.components.concept.sync.StoreSyncStatus
+import mozilla.components.concept.sync.SyncableStore
 import mozilla.components.concept.sync.SyncResult
 import mozilla.components.concept.sync.SyncStatus
 import mozilla.components.concept.sync.SyncStatusObserver
-import mozilla.components.concept.sync.SyncableStore
 import mozilla.components.support.base.log.logger.Logger
 import mozilla.components.support.base.observer.Observable
 import mozilla.components.support.base.observer.ObserverRegistry
