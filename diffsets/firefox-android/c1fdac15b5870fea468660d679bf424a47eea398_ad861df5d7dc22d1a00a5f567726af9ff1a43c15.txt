diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
index 9d2955cba75f..fffda93a24f1 100644
--- a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/Connection.kt
@@ -6,8 +6,8 @@ package mozilla.components.browser.storage.sync
 
 import android.support.annotation.GuardedBy
 import mozilla.appservices.places.PlacesApi
-import mozilla.appservices.places.ReadableHistoryConnection
-import mozilla.appservices.places.WritableHistoryConnection
+import mozilla.appservices.places.PlacesReaderConnection
+import mozilla.appservices.places.PlacesWriterConnection
 import java.io.Closeable
 import java.io.File
 
@@ -23,8 +23,8 @@ const val DB_NAME = "places.sqlite"
  * Writer is always the same, as guaranteed by [PlacesApi].
  */
 interface Connection : Closeable {
-    fun reader(): ReadableHistoryConnection
-    fun writer(): WritableHistoryConnection
+    fun reader(): PlacesReaderConnection
+    fun writer(): PlacesWriterConnection
     fun sync(syncInfo: SyncAuthInfo)
 }
 
@@ -36,7 +36,7 @@ internal object RustPlacesConnection : Connection {
     private var api: PlacesApi? = null
 
     @GuardedBy("this")
-    private var cachedReader: ReadableHistoryConnection? = null
+    private var cachedReader: PlacesReaderConnection? = null
 
     /**
      * Creates a long-lived [PlacesApi] instance, and caches a reader connection.
@@ -52,12 +52,12 @@ internal object RustPlacesConnection : Connection {
         cachedReader = api!!.openReader()
     }
 
-    override fun reader(): ReadableHistoryConnection = synchronized(this) {
+    override fun reader(): PlacesReaderConnection = synchronized(this) {
         check(cachedReader != null) { "must call init first" }
         return cachedReader!!
     }
 
-    override fun writer(): WritableHistoryConnection {
+    override fun writer(): PlacesWriterConnection {
         check(api != null) { "must call init first" }
         return api!!.getWriter()
     }
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorage.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorage.kt
new file mode 100644
index 000000000000..5075cdad0b24
--- /dev/null
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorage.kt
@@ -0,0 +1,142 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.storage.sync
+
+import android.content.Context
+import kotlinx.coroutines.withContext
+import mozilla.appservices.places.BookmarkFolder
+import mozilla.appservices.places.BookmarkItem
+import mozilla.appservices.places.BookmarkSeparator
+import mozilla.appservices.places.BookmarkTreeNode
+import mozilla.appservices.places.BookmarkUpdateInfo
+import mozilla.components.concept.storage.BookmarkInfo
+import mozilla.components.concept.storage.BookmarkNode
+import mozilla.components.concept.storage.BookmarkNodeType
+import mozilla.components.concept.storage.BookmarksStorage
+import mozilla.components.concept.sync.SyncableStore
+
+/**
+ * Implementation of the [BookmarksStorage] which is backed by a Rust Places lib via [PlacesApi].
+ */
+open class PlacesBookmarksStorage(context: Context) : PlacesStorage(context), BookmarksStorage, SyncableStore {
+
+    /**
+     * Produces a bookmarks tree for the given guid string.
+     *
+     * @param guid The bookmark guid to obtain.
+     * @param recursive Whether to recurse and obtain all levels of children.
+     * @return The populated root starting from the guid.
+     */
+    override suspend fun getTree(guid: String, recursive: Boolean): BookmarkNode? {
+        return withContext(scope.coroutineContext) {
+            reader.getBookmarksTree(guid, recursive)?.let {
+                asBookmarkNode(it)
+            }
+        }
+    }
+
+    /**
+     * Searches bookmarks with a query string.
+     *
+     * @param query The query string to search.
+     * @param limit The maximum number of entries to return.
+     * @return The list of matching bookmark nodes up to the limit number of items.
+     */
+    override suspend fun searchBookmarks(query: String, limit: Int): List<BookmarkNode> {
+        return withContext(scope.coroutineContext) {
+            reader.searchBookmarks(query, limit).mapNotNull(::asBookmarkNode)
+        }
+    }
+
+    /**
+     * Adds a new bookmark item to a given node.
+     *
+     * Sync behavior: will add new bookmark item to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param url The URL of the bookmark item to add.
+     * @param title The title of the bookmark item to add.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    override suspend fun addItem(parentGuid: String, url: String, title: String, position: Int?): String {
+        return withContext(scope.coroutineContext) {
+            writer.createBookmarkItem(parentGuid, url, title, position)
+        }
+    }
+
+    /**
+     * Adds a new bookmark folder to a given node.
+     *
+     * Sync behavior: will add new separator to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param title The title of the bookmark folder to add.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    override suspend fun addFolder(parentGuid: String, title: String, position: Int?): String {
+        return withContext(scope.coroutineContext) {
+            writer.createFolder(parentGuid, title, position)
+        }
+    }
+
+    /**
+     * Adds a new bookmark separator to a given node.
+     *
+     * Sync behavior: will add new separator to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    override suspend fun addSeparator(parentGuid: String, position: Int?): String {
+        return withContext(scope.coroutineContext) {
+            writer.createSeparator(parentGuid, position)
+        }
+    }
+
+    /**
+     * Edits the properties of an existing bookmark item and/or moves an existing one underneath a new parent guid.
+     *
+     * Sync behavior: will alter bookmark item on remote devices.
+     *
+     * @param guid The guid of the item to update.
+     * @param info The info to change in the bookmark.
+     */
+    override suspend fun updateNode(guid: String, info: BookmarkInfo) {
+        return withContext(scope.coroutineContext) {
+            writer.updateBookmark(guid, BookmarkUpdateInfo(info.parentGuid, info.position, info.title, info.url))
+        }
+    }
+
+    /**
+     * Deletes a bookmark node and all of its children, if any.
+     *
+     * Sync behavior: will remove bookmark from remote devices.
+     *
+     * @return Whether the bookmark existed or not.
+     */
+    override suspend fun deleteNode(guid: String): Boolean = withContext(scope.coroutineContext) {
+        writer.deleteBookmarkNode(guid)
+    }
+
+    private fun asBookmarkNode(node: BookmarkTreeNode?): BookmarkNode? {
+        return node?.let {
+            when (it) {
+                is BookmarkItem -> {
+                    BookmarkNode(BookmarkNodeType.ITEM, it.guid, it.parentGUID, it.position, it.title, it.url, null)
+                }
+                is BookmarkFolder -> {
+                    BookmarkNode(BookmarkNodeType.FOLDER, it.guid, it.parentGUID, it.position, it.title, null,
+                            it.children?.mapNotNull(::asBookmarkNode))
+                }
+                is BookmarkSeparator -> {
+                    BookmarkNode(BookmarkNodeType.SEPARATOR, it.guid, it.parentGUID, it.position, null, null, null)
+                }
+            }
+        }
+    }
+}
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
index d40a9fbc1baa..56e69f8f6acc 100644
--- a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesHistoryStorage.kt
@@ -5,22 +5,15 @@
 package mozilla.components.browser.storage.sync
 
 import android.content.Context
-import android.support.annotation.VisibleForTesting
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.cancelChildren
-import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.withContext
-import mozilla.appservices.places.PlacesException
 import mozilla.appservices.places.VisitObservation
 import mozilla.components.concept.storage.HistoryAutocompleteResult
 import mozilla.components.concept.storage.HistoryStorage
 import mozilla.components.concept.storage.PageObservation
 import mozilla.components.concept.storage.SearchResult
 import mozilla.components.concept.storage.VisitInfo
-import mozilla.components.concept.sync.SyncStatus
-import mozilla.components.concept.sync.SyncableStore
 import mozilla.components.concept.storage.VisitType
-import mozilla.components.concept.sync.AuthInfo
+import mozilla.components.concept.sync.SyncableStore
 import mozilla.components.support.utils.segmentAwareDomainMatch
 
 const val AUTOCOMPLETE_SOURCE_NAME = "placesHistory"
@@ -31,15 +24,7 @@ typealias SyncAuthInfo = mozilla.appservices.places.SyncAuthInfo
  * Implementation of the [HistoryStorage] which is backed by a Rust Places lib via [PlacesApi].
  */
 @SuppressWarnings("TooManyFunctions")
-open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStore {
-    private val scope by lazy { CoroutineScope(Dispatchers.IO) }
-    private val storageDir by lazy { context.filesDir }
-
-    @VisibleForTesting
-    internal open val places: Connection by lazy {
-        RustPlacesConnection.init(storageDir)
-        RustPlacesConnection
-    }
+open class PlacesHistoryStorage(context: Context) : PlacesStorage(context), HistoryStorage, SyncableStore {
 
     override suspend fun recordVisit(uri: String, visitType: VisitType) {
         withContext(scope.coroutineContext) {
@@ -51,11 +36,11 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
         // NB: visitType 'UPDATE_PLACE' means "record meta information about this URL".
         withContext(scope.coroutineContext) {
             places.writer().noteObservation(
-                VisitObservation(
-                    url = uri,
-                    visitType = mozilla.appservices.places.VisitType.UPDATE_PLACE,
-                    title = observation.title
-                )
+                    VisitObservation(
+                            url = uri,
+                            visitType = mozilla.appservices.places.VisitType.UPDATE_PLACE,
+                            title = observation.title
+                    )
             )
         }
     }
@@ -67,9 +52,9 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
     override suspend fun getVisited(): List<String> {
         return withContext(scope.coroutineContext) {
             places.reader().getVisitedUrlsInRange(
-                start = 0,
-                end = System.currentTimeMillis(),
-                includeRemote = true
+                    start = 0,
+                    end = System.currentTimeMillis(),
+                    includeRemote = true
             )
         }
     }
@@ -80,11 +65,6 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
         }
     }
 
-    override fun cleanup() {
-        scope.coroutineContext.cancelChildren()
-        places.close()
-    }
-
     override fun getSuggestions(query: String, limit: Int): List<SearchResult> {
         require(limit >= 0) { "Limit must be a positive integer" }
         return places.reader().queryAutocomplete(query, limit = limit).map {
@@ -98,11 +78,11 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
         val resultText = segmentAwareDomainMatch(query, arrayListOf(url))
         return resultText?.let {
             HistoryAutocompleteResult(
-                input = query,
-                text = it.matchedSegment,
-                url = it.url,
-                source = AUTOCOMPLETE_SOURCE_NAME,
-                totalItems = 1
+                    input = query,
+                    text = it.matchedSegment,
+                    url = it.url,
+                    source = AUTOCOMPLETE_SOURCE_NAME,
+                    totalItems = 1
             )
         }
     }
@@ -156,22 +136,4 @@ open class PlacesHistoryStorage(context: Context) : HistoryStorage, SyncableStor
             places.writer().pruneDestructively()
         }
     }
-
-    /**
-     * Internal database maintenance tasks. Ideally this should be called once a day.
-     */
-    override suspend fun runMaintenance() {
-        withContext(scope.coroutineContext) {
-            places.writer().runMaintenance()
-        }
-    }
-
-    override suspend fun sync(authInfo: AuthInfo): SyncStatus {
-        return try {
-            places.sync(authInfo.into())
-            SyncStatus.Ok
-        } catch (e: PlacesException) {
-            SyncStatus.Error(e)
-        }
-    }
 }
diff --git a/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesStorage.kt b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesStorage.kt
new file mode 100644
index 000000000000..4978d9ee94a7
--- /dev/null
+++ b/android-components/components/browser/storage-sync/src/main/java/mozilla/components/browser/storage/sync/PlacesStorage.kt
@@ -0,0 +1,71 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.storage.sync
+
+import android.content.Context
+import android.support.annotation.VisibleForTesting
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.cancelChildren
+import kotlinx.coroutines.withContext
+import mozilla.appservices.places.PlacesException
+import mozilla.appservices.places.PlacesReaderConnection
+import mozilla.appservices.places.PlacesWriterConnection
+import mozilla.components.concept.storage.Storage
+import mozilla.components.concept.sync.AuthInfo
+import mozilla.components.concept.sync.SyncStatus
+import mozilla.components.concept.sync.SyncableStore
+
+/**
+ * A base class for concrete implementations of PlacesStorages
+ */
+open class PlacesStorage(context: Context) : Storage, SyncableStore {
+
+    internal val scope by lazy { CoroutineScope(Dispatchers.IO) }
+    private val storageDir by lazy { context.filesDir }
+
+    @VisibleForTesting
+    internal open val places: Connection by lazy {
+        RustPlacesConnection.init(storageDir)
+        RustPlacesConnection
+    }
+
+    internal val writer: PlacesWriterConnection by lazy { places.writer() }
+    internal val reader: PlacesReaderConnection by lazy { places.reader() }
+
+    /**
+     * Internal database maintenance tasks. Ideally this should be called once a day.
+     */
+    override suspend fun runMaintenance() {
+        withContext(scope.coroutineContext) {
+            places.writer().runMaintenance()
+        }
+    }
+
+    /**
+     * Cleans up background work and database connections
+     */
+    override fun cleanup() {
+        scope.coroutineContext.cancelChildren()
+        places.close()
+    }
+
+    /**
+     * Runs sync() method on the places Connection
+     *
+     * @param authInfo The authentication information to sync with.
+     * @return Sync status of OK or Error
+     */
+    override suspend fun sync(authInfo: AuthInfo): SyncStatus {
+        return try {
+            withContext(scope.coroutineContext) {
+                places.sync(authInfo.into())
+                SyncStatus.Ok
+            }
+        } catch (e: PlacesException) {
+            SyncStatus.Error(e)
+        }
+    }
+}
diff --git a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt
new file mode 100644
index 000000000000..1a593be82604
--- /dev/null
+++ b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesBookmarksStorageTest.kt
@@ -0,0 +1,241 @@
+package mozilla.components.browser.storage.sync
+
+import kotlinx.coroutines.runBlocking
+import mozilla.appservices.places.BookmarkRoot
+import mozilla.appservices.places.BookmarkUpdateInfo
+import mozilla.appservices.places.PlacesReaderConnection
+import mozilla.appservices.places.PlacesWriterConnection
+import mozilla.components.concept.storage.BookmarkInfo
+import mozilla.components.concept.storage.BookmarkNode
+import mozilla.components.concept.storage.BookmarkNodeType
+import mozilla.components.support.test.mock
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+
+@RunWith(RobolectricTestRunner::class)
+class PlacesBookmarksStorageTest {
+
+    private var conn: Connection? = null
+    private var reader: PlacesReaderConnection? = null
+    private var writer: PlacesWriterConnection? = null
+
+    private var storage: PlacesBookmarksStorage? = null
+
+    private val newItem = BookmarkNode(BookmarkNodeType.ITEM, "123", "456", null,
+            "Mozilla", "http://www.mozilla.org", null)
+    private val newFolder = BookmarkNode(BookmarkNodeType.FOLDER, "789", "321", null,
+            "Cool Sites", null, listOf())
+    private val newSeparator = BookmarkNode(BookmarkNodeType.SEPARATOR, "654", "987",
+            null, null, null, null)
+
+    class TestablePlacesBookmarksStorage(override val places: Connection) : PlacesBookmarksStorage(RuntimeEnvironment.application)
+
+    @Before
+    fun setup() {
+        conn = mock()
+        reader = mock()
+        writer = mock()
+        `when`(conn!!.reader()).thenReturn(reader)
+        `when`(conn!!.writer()).thenReturn(writer)
+        storage = TestablePlacesBookmarksStorage(conn!!)
+    }
+
+    @Test
+    fun `get bookmarks tree by root, recursive or not`() {
+        val reader = reader!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.getTree(BookmarkRoot.Root.id)
+        }
+        verify(reader, times(1)).getBookmarksTree(BookmarkRoot.Root.id, false)
+
+        runBlocking {
+            storage.getTree(BookmarkRoot.Root.id, true)
+        }
+        verify(reader, times(1)).getBookmarksTree(BookmarkRoot.Root.id, true)
+    }
+
+    @Test
+    fun `search bookmarks by keyword`() {
+        val reader = reader!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.searchBookmarks("mozilla")
+        }
+        verify(reader, times(1)).searchBookmarks("mozilla", 10)
+
+        runBlocking {
+            storage.searchBookmarks("mozilla", 30)
+        }
+        verify(reader, times(1)).searchBookmarks("mozilla", 30)
+    }
+
+    @Test
+    fun `add a bookmark item`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.addItem(BookmarkRoot.Mobile.id, newItem.url!!, newItem.title!!, null)
+        }
+        verify(writer, times(1)).createBookmarkItem(
+                BookmarkRoot.Mobile.id, "http://www.mozilla.org", "Mozilla", null)
+
+        runBlocking {
+            storage.addItem(BookmarkRoot.Mobile.id, newItem.url!!, newItem.title!!, 3)
+        }
+        verify(writer, times(1)).createBookmarkItem(
+                BookmarkRoot.Mobile.id, "http://www.mozilla.org", "Mozilla", 3)
+    }
+
+    @Test
+    fun `add a bookmark folder`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.addFolder(BookmarkRoot.Mobile.id, newFolder.title!!, null)
+        }
+        verify(writer, times(1)).createFolder(
+                BookmarkRoot.Mobile.id, "Cool Sites", null)
+
+        runBlocking {
+            storage.addFolder(BookmarkRoot.Mobile.id, newFolder.title!!, 4)
+        }
+        verify(writer, times(1)).createFolder(
+                BookmarkRoot.Mobile.id, "Cool Sites", 4)
+    }
+
+    @Test
+    fun `add a bookmark separator`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.addSeparator(BookmarkRoot.Mobile.id, null)
+        }
+        verify(writer, times(1)).createSeparator(
+                BookmarkRoot.Mobile.id, null)
+
+        runBlocking {
+            storage.addSeparator(BookmarkRoot.Mobile.id, 4)
+        }
+        verify(writer, times(1)).createSeparator(
+                BookmarkRoot.Mobile.id, 4)
+    }
+
+    @Test
+    fun `move a bookmark item`() {
+        val writer = writer!!
+        val storage = storage!!
+        val info = BookmarkInfo(newItem.parentGuid, newItem.position, newItem.title, newItem.url)
+
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info)
+        }
+        verify(writer, times(1)).updateBookmark(
+                BookmarkRoot.Mobile.id, info.asBookmarkUpdateInfo())
+
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info.copy(position = 4))
+        }
+        verify(writer, times(1)).updateBookmark(
+                BookmarkRoot.Mobile.id, info.copy(position = 4).asBookmarkUpdateInfo())
+    }
+
+    @Test
+    fun `move a bookmark folder and its contents`() {
+        val writer = writer!!
+        val storage = storage!!
+        val info = BookmarkInfo(newFolder.parentGuid, newFolder.position, newFolder.title, newFolder.url)
+
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info)
+        }
+        verify(writer, times(1)).updateBookmark(
+                BookmarkRoot.Mobile.id, info.asBookmarkUpdateInfo()
+        )
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info.copy(position = 5))
+        }
+        verify(writer, times(1)).updateBookmark(
+                BookmarkRoot.Mobile.id, info.copy(position = 5).asBookmarkUpdateInfo()
+        )
+    }
+
+    @Test
+    fun `move a bookmark separator`() {
+        val writer = writer!!
+        val storage = storage!!
+        val info = BookmarkInfo(newSeparator.parentGuid, newSeparator.position, newSeparator.title, newSeparator.url)
+
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info)
+        }
+        verify(writer, times(1)).updateBookmark(
+                BookmarkRoot.Mobile.id, info.asBookmarkUpdateInfo()
+        )
+        runBlocking {
+            storage.updateNode(BookmarkRoot.Mobile.id, info.copy(position = 6))
+        }
+        verify(writer, times(1)).updateBookmark(BookmarkRoot.Mobile.id, info.copy(position = 6).asBookmarkUpdateInfo())
+    }
+
+    @Test
+    fun `update a bookmark item`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        val info = BookmarkInfo("121", 1, "Firefox", "https://www.mozilla.org/en-US/firefox/")
+
+        runBlocking {
+            storage.updateNode(newItem.guid, info)
+        }
+        verify(writer, times(1)).updateBookmark("123", info.asBookmarkUpdateInfo())
+    }
+
+    @Test
+    fun `update a bookmark folder`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        val info = BookmarkInfo("131", 2, "Firefox", null)
+
+        runBlocking {
+            storage.updateNode(newFolder.guid, info)
+        }
+        verify(writer, times(1)).updateBookmark(newFolder.guid, info.asBookmarkUpdateInfo())
+    }
+
+    @Test
+    fun `delete a bookmark item`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.deleteNode(newItem.guid)
+        }
+        verify(writer, times(1)).deleteBookmarkNode(newItem.guid)
+    }
+
+    @Test
+    fun `delete a bookmark separator`() {
+        val writer = writer!!
+        val storage = storage!!
+
+        runBlocking {
+            storage.deleteNode(newSeparator.guid)
+        }
+        verify(writer, times(1)).deleteBookmarkNode(newSeparator.guid)
+    }
+
+    private fun BookmarkInfo.asBookmarkUpdateInfo(): BookmarkUpdateInfo = BookmarkUpdateInfo(this.parentGuid, this.position, this.title, this.url)
+}
\ No newline at end of file
diff --git a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
index b923c493a6ee..f725d181fe14 100644
--- a/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
+++ b/android-components/components/browser/storage-sync/src/test/java/mozilla/components/browser/storage/sync/PlacesHistoryStorageTest.kt
@@ -6,37 +6,36 @@ package mozilla.components.browser.storage.sync
 
 import kotlinx.coroutines.runBlocking
 import mozilla.appservices.places.PlacesException
-import mozilla.appservices.places.ReadableHistoryConnection
+import mozilla.appservices.places.PlacesReaderConnection
+import mozilla.appservices.places.PlacesWriterConnection
 import mozilla.appservices.places.SearchResult
 import mozilla.appservices.places.VisitInfo
 import mozilla.appservices.places.VisitObservation
-import mozilla.appservices.places.WritableHistoryConnection
 import mozilla.components.concept.storage.PageObservation
 import mozilla.components.concept.storage.VisitType
 import mozilla.components.concept.sync.AuthInfo
 import mozilla.components.concept.sync.SyncStatus
 import mozilla.components.support.test.eq
-import org.junit.Test
 import mozilla.components.support.test.mock
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNull
 import org.junit.Assert.fail
 import org.junit.Before
+import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers
 import org.mockito.Mockito.`when`
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.times
 import org.mockito.Mockito.never
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
 import org.robolectric.RobolectricTestRunner
 import org.robolectric.RuntimeEnvironment
-import java.lang.IllegalArgumentException
 
 @RunWith(RobolectricTestRunner::class)
 class PlacesHistoryStorageTest {
     private var conn: Connection? = null
-    private var reader: ReadableHistoryConnection? = null
-    private var writer: WritableHistoryConnection? = null
+    private var reader: PlacesReaderConnection? = null
+    private var writer: PlacesWriterConnection? = null
 
     private var storage: PlacesHistoryStorage? = null
 
@@ -301,12 +300,12 @@ class PlacesHistoryStorageTest {
     fun `storage passes through sync calls`() = runBlocking {
         var passedAuthInfo: SyncAuthInfo? = null
         val conn = object : Connection {
-            override fun reader(): ReadableHistoryConnection {
+            override fun reader(): PlacesReaderConnection {
                 fail()
                 return mock()
             }
 
-            override fun writer(): WritableHistoryConnection {
+            override fun writer(): PlacesWriterConnection {
                 fail()
                 return mock()
             }
@@ -333,12 +332,12 @@ class PlacesHistoryStorageTest {
     @Test
     fun `storage passes through sync OK results`() = runBlocking {
         val conn = object : Connection {
-            override fun reader(): ReadableHistoryConnection {
+            override fun reader(): PlacesReaderConnection {
                 fail()
                 return mock()
             }
 
-            override fun writer(): WritableHistoryConnection {
+            override fun writer(): PlacesWriterConnection {
                 fail()
                 return mock()
             }
@@ -359,12 +358,12 @@ class PlacesHistoryStorageTest {
     fun `storage passes through sync exceptions`() = runBlocking {
         val exception = PlacesException("test error")
         val conn = object : Connection {
-            override fun reader(): ReadableHistoryConnection {
+            override fun reader(): PlacesReaderConnection {
                 fail()
                 return mock()
             }
 
-            override fun writer(): WritableHistoryConnection {
+            override fun writer(): PlacesWriterConnection {
                 fail()
                 return mock()
             }
diff --git a/android-components/components/browser/storage-sync/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/browser/storage-sync/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 000000000000..ca6ee9cea8ec
--- /dev/null
+++ b/android-components/components/browser/storage-sync/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1 @@
+mock-maker-inline
\ No newline at end of file
diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/BookmarksStorage.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/BookmarksStorage.kt
new file mode 100644
index 000000000000..ebd9a1a8a2e2
--- /dev/null
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/BookmarksStorage.kt
@@ -0,0 +1,118 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.storage
+
+/**
+ * An interface which defines read/write operations for bookmarks data.
+ */
+interface BookmarksStorage : Storage {
+
+    /**
+     * Produces a bookmarks tree for the given guid string.
+     *
+     * @param guid The bookmark guid to obtain.
+     * @param recursive Whether to recurse and obtain all levels of children.
+     * @return The populated root starting from the guid.
+     */
+    suspend fun getTree(guid: String, recursive: Boolean = false): BookmarkNode?
+
+    /**
+     * Searches bookmarks with a query string.
+     *
+     * @param query The query string to search.
+     * @param limit The maximum number of entries to return.
+     * @return The list of matching bookmark nodes up to the limit number of items.
+     */
+    suspend fun searchBookmarks(query: String, limit: Int = defaultBookmarkSearchLimit): List<BookmarkNode>
+
+    /**
+     * Adds a new bookmark item to a given node.
+     *
+     * Sync behavior: will add new bookmark item to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param url The URL of the bookmark item to add.
+     * @param title The title of the bookmark item to add.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    suspend fun addItem(parentGuid: String, url: String, title: String, position: Int?): String
+
+    /**
+     * Adds a new bookmark folder to a given node.
+     *
+     * Sync behavior: will add new separator to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param title The title of the bookmark folder to add.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    suspend fun addFolder(parentGuid: String, title: String, position: Int? = null): String
+
+    /**
+     * Adds a new bookmark separator to a given node.
+     *
+     * Sync behavior: will add new separator to remote devices.
+     *
+     * @param parentGuid The parent guid of the new node.
+     * @param position The optional position to add the new node or null to append.
+     * @return The guid of the newly inserted bookmark item.
+     */
+    suspend fun addSeparator(parentGuid: String, position: Int?): String
+
+    /**
+     * Edits the properties of an existing bookmark item and/or moves an existing one underneath a new parent guid.
+     *
+     * Sync behavior: will alter bookmark item on remote devices.
+     *
+     * @param guid The guid of the item to update.
+     * @param info The info to change in the bookmark.
+     */
+    suspend fun updateNode(guid: String, info: BookmarkInfo)
+
+    /**
+     * Deletes a bookmark node and all of its children, if any.
+     *
+     * Sync behavior: will remove bookmark from remote devices.
+     *
+     * @return Whether the bookmark existed or not.
+     */
+    suspend fun deleteNode(guid: String): Boolean
+
+    companion object {
+        const val defaultBookmarkSearchLimit = 10
+    }
+}
+
+/**
+ * Class for holding metadata about any bookmark node
+ */
+data class BookmarkNode(
+    val type: BookmarkNodeType,
+    val guid: String,
+    val parentGuid: String?,
+    val position: Int?,
+    val title: String?,
+    val url: String?,
+    val children: List<BookmarkNode?>?
+)
+
+/**
+ * Class for making alterations to any bookmark node
+ */
+data class BookmarkInfo(
+    val parentGuid: String?,
+    val position: Int?,
+    val title: String?,
+    val url: String?
+)
+
+/**
+ * The types of bookmark nodes
+ */
+enum class BookmarkNodeType {
+    ITEM, FOLDER, SEPARATOR
+}
diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
index 66d51f6bd8bf..ed42e702e2e6 100644
--- a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/HistoryStorage.kt
@@ -8,7 +8,7 @@ package mozilla.components.concept.storage
  * An interface which defines read/write methods for history data.
  */
 @SuppressWarnings("TooManyFunctions")
-interface HistoryStorage {
+interface HistoryStorage : Storage {
     /**
      * Records a visit to a page.
      * @param uri of the page which was visited.
@@ -87,16 +87,6 @@ interface HistoryStorage {
      * Prune history storage, removing stale history.
      */
     suspend fun prune()
-
-    /**
-     * Perform internal storage maintenance.
-     */
-    suspend fun runMaintenance()
-
-    /**
-     * Cleanup any allocated resources.
-     */
-    fun cleanup()
 }
 
 data class PageObservation(val title: String?)
diff --git a/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/Storage.kt b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/Storage.kt
new file mode 100644
index 000000000000..7a78be79c7da
--- /dev/null
+++ b/android-components/components/concept/storage/src/main/java/mozilla/components/concept/storage/Storage.kt
@@ -0,0 +1,21 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.storage
+
+/**
+ * An interface which provides generic operations for storing browser data like history and bookmarks.
+ */
+interface Storage {
+
+    /**
+     * Runs internal database maintenance tasks
+     */
+    suspend fun runMaintenance()
+
+    /**
+     * Cleans up background work and database connections
+     */
+    fun cleanup()
+}
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 59b99e25ffa8..fcfdb8cd9cbf 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -42,7 +42,7 @@ permalink: /changelog/
 * **concept-fetch**
   * ⚠️ **This is a breaking API change!**: `Headers.Common` was renamed to `Headers.Names`.
   * Added `Headers.Values`.
-
+  
 * **service-pocket**
   * Access an article's text-to-speech listen metadata via `PocketListenEndpoint.getListenArticleMetadata`.
   * ⚠️ **This is a breaking API change!**: `PocketGlobalVideoRecommendation.id` is now a Long instead of an Int
@@ -76,9 +76,13 @@ permalink: /changelog/
 * **concept-storage**
   * ⚠️ **This is a breaking API change!** for non-component implementations of `HistoryStorage`.
   * `HistoryStorage` got new APIs: `deleteEverything`, `deleteVisitsSince`, `deleteVisitsBetween`, `deleteVisitsFor`, `prune` and `runMaintenance`.
+  * Added `BookmarksStorage` for handling the saving, searching, and management of browser bookmarks.
 
 * **browser-storage-sync**, **browser-storage-memory**
   * Implementations of `concept-storage`/`HistoryStorage` expose the newly added APIs.
+  
+* **browser-storage-sync**
+  * Implementations of `concept-storage`/`BookmarksStorage` expose the newly added APIs.
 
 # 0.47.0
 
