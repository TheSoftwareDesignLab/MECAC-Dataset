diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
index 1b66cde97241..aad888ce1f0f 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
@@ -29,14 +29,19 @@ internal class BrowserGestureDetector(
     @Suppress("MaxLineLength")
     internal var gestureDetector = GestureDetector(
         applicationContext,
-        CustomScrollDetectorListener { previousEvent: MotionEvent, currentEvent: MotionEvent, distanceX, distanceY ->
+        CustomScrollDetectorListener { previousEvent: MotionEvent?, currentEvent: MotionEvent, distanceX, distanceY ->
             run {
                 listener.onScroll?.invoke(distanceX, distanceY)
 
-                if (abs(currentEvent.y - previousEvent.y) >= abs(currentEvent.x - previousEvent.x)) {
-                    listener.onVerticalScroll?.invoke(distanceY)
-                } else {
-                    listener.onHorizontalScroll?.invoke(distanceX)
+                // We got many crashes because of the initial event - ACTION_DOWN being null.
+                // Investigations to be continued in android-components/issues/8552.
+                // In the meantime we'll protect against this with a simple null check.
+                if (previousEvent != null) {
+                    if (abs(currentEvent.y - previousEvent.y) >= abs(currentEvent.x - previousEvent.x)) {
+                        listener.onVerticalScroll?.invoke(distanceY)
+                    } else {
+                        listener.onHorizontalScroll?.invoke(distanceX)
+                    }
                 }
             }
         }
@@ -150,14 +155,14 @@ internal class BrowserGestureDetector(
 
     private class CustomScrollDetectorListener(
         val onScrolling: (
-            previousEvent: MotionEvent,
+            previousEvent: MotionEvent?,
             currentEvent: MotionEvent,
             distanceX: Float,
             distanceY: Float
         ) -> Unit
     ) : GestureDetector.SimpleOnGestureListener() {
         override fun onScroll(
-            e1: MotionEvent,
+            e1: MotionEvent?,
             e2: MotionEvent,
             distanceX: Float,
             distanceY: Float
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
index 5ad406ef1130..f4b00190dee2 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
@@ -9,6 +9,7 @@ import android.view.MotionEvent
 import android.view.MotionEvent.ACTION_CANCEL
 import android.view.MotionEvent.ACTION_DOWN
 import android.view.MotionEvent.ACTION_MOVE
+import android.view.MotionEvent.ACTION_POINTER_DOWN
 import android.view.MotionEvent.ACTION_UP
 import android.view.ScaleGestureDetector
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -200,4 +201,27 @@ class BrowserGestureDetectorTest {
         verify(scrollDetector, times(1)).onTouchEvent(cancelEvent)
         verify(scrollDetector, never()).onTouchEvent(moveEvent)
     }
+
+    @Test
+    fun `Detector should not crash when the scroll detector receives a null first MotionEvent`() {
+        val detector = BrowserGestureDetector(testContext, gesturesListener)
+        // We need a previous event for ACTION_MOVE.
+        // Don't use ACTION_DOWN (first pointer on the screen) but ACTION_POINTER_DOWN (other later pointer)
+        // just to artificially be able to recreate the bug from 8552. This should not happen IRL.
+        val downEvent = TestUtils.getMotionEvent(ACTION_POINTER_DOWN)
+        val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 0f, previousEvent = downEvent)
+        val moveEvent2 = TestUtils.getMotionEvent(ACTION_MOVE, 100f, 200f, previousEvent = moveEvent)
+
+        detector.handleTouchEvent(downEvent)
+        detector.handleTouchEvent(moveEvent)
+        detector.handleTouchEvent(moveEvent2)
+
+        verify(scrollListener).invoke(-100f, -200f)
+        // We don't crash but neither can identify vertical / horizontal scrolls.
+        verify(verticalScrollListener, never()).invoke(anyFloat())
+        verify(horizontalScrollListener, never()).invoke(anyFloat())
+        verify(scaleBeginListener, never()).invoke(anyFloat())
+        verify(scaleInProgressListener, never()).invoke(anyFloat())
+        verify(scaleEndListener, never()).invoke(anyFloat())
+    }
 }
