diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
index 1f3f58ef44ca..874e577b9c7a 100644
--- a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
@@ -28,7 +28,6 @@ import mozilla.components.support.base.utils.NamedThreadFactory
 import mozilla.components.support.base.log.logger.Logger
 import mozilla.components.support.base.observer.Observable
 import mozilla.components.support.base.observer.ObserverRegistry
-import java.io.File
 import java.util.concurrent.Executors
 import kotlin.coroutines.CoroutineContext
 
@@ -37,32 +36,39 @@ import kotlin.coroutines.CoroutineContext
  * in the Application's onCreate. It receives messages from a service and forwards them
  * to be decrypted and routed.
  *
- * <code>
- *     class Application {
- *          override fun onCreate() {
- *              val feature = AutoPushFeature(context, service, configuration)
- *              PushProvider.install(push)
- *          }
- *     }
- * </code>
+ * ```kotlin
+ * class Application {
+ *      override fun onCreate() {
+ *          val feature = AutoPushFeature(context, service, configuration)
+ *          PushProvider.install(push)
+ *      }
+ * }
+ * ```
  *
- * Listen for subscription information changes for each registered scope:
+ * Observe for subscription information changes for each registered scope:
  *
- * <code>
- *    feature.register(object: AutoPushFeature.Observer {
- *        override fun onSubscriptionChanged(scope: PushScope) { }
- *    })
- *    feature.subscribe("push_subscription_scope_id")
- * </code>
+ * ```kotlin
+ * feature.register(object: AutoPushFeature.Observer {
+ *     override fun onSubscriptionChanged(scope: PushScope) { }
+ * })
  *
- * Listen also for push messages:
+ * feature.subscribe("push_subscription_scope_id")
+ * ```
  *
- * <code>
- *    feature.register(object: AutoPushFeature.Observer {
- *        override fun onMessageReceived(scope: PushScope, message: ByteArray?) { }
- *     })
- * </code>
+ * You should also observe for push messages:
  *
+ * ```kotlin
+ * feature.register(object: AutoPushFeature.Observer {
+ *     override fun onMessageReceived(scope: PushScope, message: ByteArray?) { }
+ * })
+ * ```
+ *
+ * @param context the application [Context].
+ * @param service A [PushService] bridge that receives the encrypted push messages.
+ * @param config An instance of [PushConfig] to configure the feature.
+ * @param coroutineContext An instance of [CoroutineContext] used for executing async push tasks.
+ * @param connection An implementation of [PushConnection] to communicate with any native layer.
+ * @param crashReporter An optional instance of a [CrashReporting].
  */
 @Suppress("TooManyFunctions", "LargeClass", "LongParameterList")
 class AutoPushFeature(
@@ -73,11 +79,11 @@ class AutoPushFeature(
         NamedThreadFactory("AutoPushFeature")
     ).asCoroutineDispatcher(),
     private val connection: PushConnection = RustPushConnection(
+        context = context,
         senderId = config.senderId,
         serverHost = config.serverHost,
         socketProtocol = config.protocol,
-        serviceType = config.serviceType,
-        databasePath = File(context.filesDir, DB_NAME).canonicalPath
+        serviceType = config.serviceType
     ),
     private val crashReporter: CrashReporting? = null
 ) : PushProcessor, Observable<AutoPushFeature.Observer> by ObserverRegistry() {
@@ -95,8 +101,8 @@ class AutoPushFeature(
 
     init {
         // If we have a token, initialize the rust component first.
-        prefToken?.let { token ->
-            coroutineScope.launch {
+        coroutineScope.launch {
+            prefToken?.let { token ->
                 logger.debug("Initializing native component with the cached token.")
 
                 connection.updateToken(token)
@@ -281,26 +287,24 @@ class AutoPushFeature(
      * Verifies status (active, expired) of the push subscriptions and then notifies observers.
      */
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun verifyActiveSubscriptions() {
+    internal suspend fun verifyActiveSubscriptions() {
         connection.ifInitialized {
-            coroutineScope.launchAndTry {
-                val subscriptionChanges = verifyConnection()
+            val subscriptionChanges = verifyConnection()
 
-                if (subscriptionChanges.isNotEmpty()) {
-                    logger.info("Subscriptions have changed; notifying observers..")
+            if (subscriptionChanges.isNotEmpty()) {
+                logger.info("Subscriptions have changed; notifying observers..")
 
-                    subscriptionChanges.forEach { sub ->
-                        notifyObservers { onSubscriptionChanged(sub.scope) }
-                    }
-                } else {
-                    logger.info("No change to subscriptions. Doing nothing.")
+                subscriptionChanges.forEach { sub ->
+                    notifyObservers { onSubscriptionChanged(sub.scope) }
                 }
+            } else {
+                logger.info("No change to subscriptions. Doing nothing.")
             }
         }
     }
 
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun tryVerifySubscriptions() {
+    internal fun tryVerifySubscriptions() = coroutineScope.launch {
         logger.info("Trying to check validity of push subscriptions.")
 
         if (config.disableRateLimit || shouldVerifyNow()) {
@@ -349,7 +353,6 @@ class AutoPushFeature(
     companion object {
         internal const val PREFERENCE_NAME = "mozac_feature_push"
         internal const val PREF_TOKEN = "token"
-        internal const val DB_NAME = "push.sqlite"
 
         internal const val LAST_VERIFIED = "last_verified_push_connection"
         internal const val PERIODIC_INTERVAL_MILLISECONDS = 24 * 60 * 60 * 1000L // 24 hours
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
index 44ffa9914ad9..99ebff2223a5 100644
--- a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
@@ -4,6 +4,7 @@
 
 package mozilla.components.feature.push
 
+import android.content.Context
 import androidx.annotation.GuardedBy
 import androidx.annotation.VisibleForTesting
 import mozilla.appservices.push.BridgeType
@@ -13,6 +14,7 @@ import mozilla.appservices.push.PushManager
 import mozilla.appservices.push.PushSubscriptionChanged as SubscriptionChanged
 import mozilla.appservices.push.SubscriptionResponse
 import java.io.Closeable
+import java.io.File
 import java.util.Locale
 import java.util.UUID
 
@@ -103,10 +105,10 @@ interface PushConnection : Closeable {
  *
  * With this in mind, we decided to write our implementation to be a 1-1 mapping of the public API 'scope' to the
  * internal API 'channel ID' by generating a UUID from the scope value. This means that we have a reproducible way to
- * always retrieve the chid when the caller passes the scope to us.
+ * always retrieve the channel ID when the caller passes the scope to us.
  *
  * Some nuances are that we also need to provide the native API the same scope value along with the
- * scope-based chid value to satisfy the internal API requirements, at the cost of some noticeable duplication of
+ * scope-based channel ID value to satisfy the internal API requirements, at the cost of some noticeable duplication of
  * information, so that we can retrieve those values later; see [RustPushConnection.subscribe] and
  * [RustPushConnection.unsubscribe] implementations for details.
  *
@@ -115,13 +117,15 @@ interface PushConnection : Closeable {
  * receiver; see [RustPushConnection.decryptMessage] implementation for details.
  */
 internal class RustPushConnection(
-    private val databasePath: String,
+    context: Context,
     private val senderId: String,
     private val serverHost: String,
     private val socketProtocol: Protocol,
     private val serviceType: ServiceType
 ) : PushConnection {
 
+    private val databasePath by lazy { File(context.filesDir, DB_NAME).canonicalPath }
+
     @VisibleForTesting
     internal var api: PushAPI? = null
 
@@ -249,6 +253,10 @@ internal class RustPushConnection(
 
     @GuardedBy("this")
     override fun isInitialized() = synchronized(this) { api != null }
+
+    companion object {
+        internal const val DB_NAME = "push.sqlite"
+    }
 }
 
 /**
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt
index 60b47e6792de..5a40d5f8a09d 100644
--- a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt
@@ -4,6 +4,7 @@
 
 package mozilla.components.feature.push
 
+import androidx.test.ext.junit.runners.AndroidJUnit4
 import kotlinx.coroutines.runBlocking
 import mozilla.appservices.push.DispatchInfo
 import mozilla.appservices.push.KeyInfo
@@ -14,6 +15,7 @@ import mozilla.appservices.push.SubscriptionResponse
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.nullable
+import mozilla.components.support.test.robolectric.testContext
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNotNull
@@ -21,12 +23,14 @@ import org.junit.Assert.assertNull
 import org.junit.Assert.assertTrue
 import org.junit.Ignore
 import org.junit.Test
+import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers
 import org.mockito.Mockito.`when`
 import org.mockito.Mockito.anyString
 import org.mockito.Mockito.never
 import org.mockito.Mockito.verify
 
+@RunWith(AndroidJUnit4::class)
 class RustPushConnectionTest {
 
     @Ignore("Requires push-forUnitTests; seems unnecessary to introduce it for this one test.")
@@ -277,7 +281,7 @@ class RustPushConnectionTest {
     }
 
     private fun createConnection() = RustPushConnection(
-        "/sdcard/",
+        testContext,
         "push-test",
         "push.mozilla.com",
         Protocol.HTTPS,
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 3e66e4163317..b6962396c76e 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -12,6 +12,9 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/android-components/blob/master/.config.yml)
 
+* **feature-push**
+  * ‚ö†Ô∏è **This is a breaking change**: Removed `databasePath` from `RustPushConnection` constructor and added `context`. The file path is now queries lazily.
+
 # 73.0.0
 
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v72.0.0...v73.0.0)
@@ -46,12 +49,12 @@ permalink: /changelog/
 
 * **feature-webauthn**
   * üÜï New component to enable support for WebAuthn specification with `WebAuthnFeature`.
-  
+
 * **feature-awesomebar**
   * added `SearchEngineSuggestionProvider` that offers suggestion(s) for search engines based on user search engine list
 
 * **browser-storage-sync**
-  * Added `AutofillCreditCardsAddressesStorage` implementation of the `CreditCardsAddressesStorage` interface back by the application-services' `autofill` library. 
+  * Added `AutofillCreditCardsAddressesStorage` implementation of the `CreditCardsAddressesStorage` interface back by the application-services' `autofill` library.
 
 * **concept-engine**
   * Added `defaultSettings: Settings?` parameter to registerTabHandler to supply a default Tracking Policy when opening a new extension tab.
