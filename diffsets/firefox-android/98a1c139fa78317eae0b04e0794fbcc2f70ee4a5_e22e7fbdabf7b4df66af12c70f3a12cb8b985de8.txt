diff --git a/android-components/components/support/ktx/src/main/java/mozilla/components/support/ktx/android/graphics/Bitmap.kt b/android-components/components/support/ktx/src/main/java/mozilla/components/support/ktx/android/graphics/Bitmap.kt
index bd326adf5af7..cd6de5ba22dc 100644
--- a/android-components/components/support/ktx/src/main/java/mozilla/components/support/ktx/android/graphics/Bitmap.kt
+++ b/android-components/components/support/ktx/src/main/java/mozilla/components/support/ktx/android/graphics/Bitmap.kt
@@ -5,6 +5,11 @@
 package mozilla.components.support.ktx.android.graphics
 
 import android.graphics.Bitmap
+import android.graphics.BitmapShader
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Shader.TileMode
+import android.support.annotation.CheckResult
 import android.util.Base64
 import java.io.ByteArrayOutputStream
 
@@ -17,3 +22,26 @@ fun Bitmap.toDataUri(): String {
     val encodedImage = Base64.encodeToString(stream.toByteArray(), Base64.DEFAULT)
     return "data:image/png;base64," + encodedImage
 }
+
+/**
+ * Returns a new bitmap that is the receiver Bitmap with four rounded corners;
+ * the receiver is unmodified.
+ *
+ * This operation is expensive: it requires allocating an identical Bitmap and copying
+ * all of the Bitmap's pixels. Consider these theoretically cheaper alternatives:
+ * - android:background= a drawable with rounded corners
+ * - Wrap your bitmap's ImageView with a layout that masks your view with rounded corners (e.g. CardView)
+ */
+@CheckResult
+fun Bitmap.withRoundedCorners(cornerRadiusPx: Float): Bitmap {
+    val roundedBitmap = Bitmap.createBitmap(width, height, config)
+    val canvas = Canvas(roundedBitmap)
+    val paint = Paint().apply {
+        isAntiAlias = true
+        shader = BitmapShader(this@withRoundedCorners, TileMode.CLAMP, TileMode.CLAMP)
+    }
+
+    canvas.drawRoundRect(0.0f, 0.0f, width.toFloat(), height.toFloat(),
+            cornerRadiusPx, cornerRadiusPx, paint)
+    return roundedBitmap
+}
