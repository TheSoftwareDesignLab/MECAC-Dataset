diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
index 0b2458c8db75..8a42436d5303 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
@@ -233,7 +233,7 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
         val fragmentManager = supportFragmentManager
 
         val fragment = fragmentManager.findFragmentByTag(BrowserFragment.FRAGMENT_TAG) as BrowserFragment?
-        if (fragment != null && fragment.session.isSameAs(currentSession)) {
+        if (fragment != null && fragment.session == currentSession) {
             // There's already a BrowserFragment displaying this session.
             return
         }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
deleted file mode 100644
index 24e17deea212..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
+++ /dev/null
@@ -1,1531 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.fragment;
-
-import android.Manifest;
-import android.app.Activity;
-import android.app.DownloadManager;
-import android.app.PendingIntent;
-import android.arch.lifecycle.LifecycleObserver;
-import android.arch.lifecycle.Observer;
-import android.arch.lifecycle.ProcessLifecycleOwner;
-import android.content.ClipData;
-import android.content.ClipboardManager;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.TransitionDrawable;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Environment;
-import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RequiresApi;
-import android.support.design.widget.AppBarLayout;
-import android.support.design.widget.CoordinatorLayout;
-import android.support.v4.app.ActivityCompat;
-import android.support.v4.app.DialogFragment;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentManager;
-import android.support.v4.content.ContextCompat;
-import android.support.v4.widget.SwipeRefreshLayout;
-import android.text.Editable;
-import android.text.TextUtils;
-import android.text.TextWatcher;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityManager;
-import android.view.inputmethod.EditorInfo;
-import android.webkit.CookieManager;
-import android.webkit.URLUtil;
-import android.widget.FrameLayout;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.PopupWindow;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.activity.InstallFirefoxActivity;
-import org.mozilla.focus.activity.MainActivity;
-import org.mozilla.focus.animation.TransitionDrawableGroup;
-import org.mozilla.focus.architecture.NonNullObserver;
-import org.mozilla.focus.autocomplete.AutocompleteQuickAddPopup;
-import org.mozilla.focus.biometrics.BiometricAuthenticationDialogFragment;
-import org.mozilla.focus.biometrics.BiometricAuthenticationHandler;
-import org.mozilla.focus.biometrics.Biometrics;
-import org.mozilla.focus.broadcastreceiver.DownloadBroadcastReceiver;
-import org.mozilla.focus.customtabs.CustomTabConfig;
-import org.mozilla.focus.findinpage.FindInPageCoordinator;
-import org.mozilla.focus.locale.LocaleAwareAppCompatActivity;
-import org.mozilla.focus.menu.browser.BrowserMenu;
-import org.mozilla.focus.menu.context.WebContextMenu;
-import org.mozilla.focus.observer.LoadTimeObserver;
-import org.mozilla.focus.open.OpenWithFragment;
-import org.mozilla.focus.popup.PopupUtils;
-import org.mozilla.focus.session.NullSession;
-import org.mozilla.focus.session.Session;
-import org.mozilla.focus.session.SessionCallbackProxy;
-import org.mozilla.focus.session.SessionManager;
-import org.mozilla.focus.session.Source;
-import org.mozilla.focus.session.ui.SessionsSheetFragment;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.utils.Browsers;
-import org.mozilla.focus.utils.Features;
-import org.mozilla.focus.utils.Settings;
-import org.mozilla.focus.utils.StatusBarUtils;
-import org.mozilla.focus.utils.SupportUtils;
-import org.mozilla.focus.utils.UrlUtils;
-import org.mozilla.focus.utils.ViewUtils;
-import org.mozilla.focus.web.Download;
-import org.mozilla.focus.web.HttpAuthenticationDialogBuilder;
-import org.mozilla.focus.web.IWebView;
-import org.mozilla.focus.widget.AnimatedProgressBar;
-import org.mozilla.focus.widget.FloatingEraseButton;
-import org.mozilla.focus.widget.FloatingSessionsButton;
-
-import java.lang.ref.WeakReference;
-import java.util.List;
-import java.util.Objects;
-
-import kotlin.Unit;
-import kotlin.jvm.functions.Function1;
-import mozilla.components.support.utils.ColorUtils;
-import mozilla.components.support.utils.DownloadUtils;
-import mozilla.components.support.utils.DrawableUtils;
-
-/**
- * Fragment for displaying the browser UI.
- */
-@SuppressWarnings({"PMD.ExcessiveClassLength", "PMD.CyclomaticComplexity", "PMD.TooManyMethods",
-        "PMD.ModifiedCyclomaticComplexity", "PMD.TooManyFields", "PMD.StdCyclomaticComplexity",
-        "PMD.NcssCount"})
-public class BrowserFragment extends WebFragment implements LifecycleObserver, View.OnClickListener,
-        DownloadDialogFragment.DownloadDialogListener, View.OnLongClickListener,
-        BiometricAuthenticationDialogFragment.BiometricAuthenticationListener {
-    public static final String FRAGMENT_TAG = "browser";
-
-    private static final int REQUEST_CODE_STORAGE_PERMISSION = 101;
-    private static final int ANIMATION_DURATION = 300;
-
-    private static final String ARGUMENT_SESSION_UUID = "sessionUUID";
-    private static final String RESTORE_KEY_DOWNLOAD = "download";
-
-    public static BrowserFragment createForSession(Session session) {
-        final Bundle arguments = new Bundle();
-        arguments.putString(ARGUMENT_SESSION_UUID, session.getUUID());
-
-        BrowserFragment fragment = new BrowserFragment();
-        fragment.setArguments(arguments);
-
-        return fragment;
-    }
-
-    private Download pendingDownload;
-    private TransitionDrawableGroup backgroundTransitionGroup;
-    private TextView urlView;
-    private AnimatedProgressBar progressView;
-    private FrameLayout blockView;
-    private ImageView securityView;
-    private ImageButton menuView;
-    private View statusBar;
-    private View urlBar;
-    private FrameLayout popupTint;
-    private SwipeRefreshLayout swipeRefresh;
-    private WeakReference<BrowserMenu> menuWeakReference = new WeakReference<>(null);
-    private WeakReference<AutocompleteQuickAddPopup> autocompletePopupWeakReference = new WeakReference<>(null);
-
-    /**
-     * Container for custom video views shown in fullscreen mode.
-     */
-    private ViewGroup videoContainer;
-
-    private boolean isFullscreen;
-
-    /**
-     * Container containing the browser chrome and web content.
-     */
-    private View browserContainer;
-
-    private View forwardButton;
-    private View backButton;
-    private View refreshButton;
-    private View stopButton;
-
-    private View findInPageView;
-    private int findInPageViewHeight;
-    private TextView findInPageQuery;
-    private TextView findInPageResultTextView;
-    private ImageButton findInPageNext;
-    private ImageButton findInPagePrevious;
-    private ImageButton closeFindInPage;
-
-    private IWebView.FullscreenCallback fullscreenCallback;
-
-    private DownloadManager manager;
-
-    private DownloadBroadcastReceiver downloadBroadcastReceiver;
-
-    private final SessionManager sessionManager;
-    private Session session;
-    private final FindInPageCoordinator findInPageCoordinator = new FindInPageCoordinator();
-
-    private BiometricAuthenticationHandler biometricController = null;
-
-    public BrowserFragment() {
-        sessionManager = SessionManager.getInstance();
-    }
-
-
-    @SuppressWarnings({"PMD.ExcessiveMethodLength"})
-    @Override
-    public void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
-
-        if (biometricController == null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
-                Biometrics.INSTANCE.hasFingerprintHardware(getContext())) {
-            biometricController = new BiometricAuthenticationHandler(getContext());
-        }
-
-        final String sessionUUID = getArguments().getString(ARGUMENT_SESSION_UUID);
-        if (sessionUUID == null) {
-            throw new IllegalAccessError("No session exists");
-        }
-
-        session = sessionManager.hasSessionWithUUID(sessionUUID)
-                ? sessionManager.getSessionByUUID(sessionUUID)
-                : new NullSession();
-
-        session.getBlockedTrackers().observe(this, new Observer<Integer>() {
-            @Override
-            public void onChanged(@Nullable Integer blockedTrackers) {
-                if (menuWeakReference == null) {
-                    return;
-                }
-
-                final BrowserMenu menu = menuWeakReference.get();
-
-                if (menu != null) {
-                    //noinspection ConstantConditions - Not null
-                    menu.updateTrackers(blockedTrackers);
-                }
-            }
-        });
-
-        findInPageCoordinator.getMatches().observe(this, new Observer<kotlin.Pair<Integer, Integer>>() {
-            @Override
-            public void onChanged(@Nullable kotlin.Pair<Integer, Integer> matches) {
-                updateFindInPageResult(matches.getFirst(), matches.getSecond());
-            }
-        });
-    }
-
-    public Session getSession() {
-        return session;
-    }
-
-    @Override
-    public String getInitialUrl() {
-        return session.getUrl().getValue();
-    }
-
-    @SuppressWarnings({"PMD.ExcessiveMethodLength"})
-    @Override
-    public void onPause() {
-        super.onPause();
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
-                Settings.getInstance(getContext()).shouldUseBiometrics() &&
-                Biometrics.INSTANCE.hasFingerprintHardware(getContext())) {
-            biometricController.stopListening();
-            getView().setAlpha(0);
-        }
-
-        getContext().unregisterReceiver(downloadBroadcastReceiver);
-
-        if (isFullscreen) {
-            IWebView webView = getWebView();
-            if (webView != null) {
-                webView.exitFullscreen();
-            }
-        }
-
-        final BrowserMenu menu = menuWeakReference.get();
-        if (menu != null) {
-            menu.dismiss();
-
-            menuWeakReference.clear();
-        }
-    }
-
-    @Override
-    public View inflateLayout(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
-        if (savedInstanceState != null && savedInstanceState.containsKey(RESTORE_KEY_DOWNLOAD)) {
-            // If this activity was destroyed before we could start a download (e.g. because we were waiting for a permission)
-            // then restore the download object.
-            pendingDownload = savedInstanceState.getParcelable(RESTORE_KEY_DOWNLOAD);
-        }
-
-        final View view = inflater.inflate(R.layout.fragment_browser, container, false);
-
-        videoContainer = (ViewGroup) view.findViewById(R.id.video_container);
-        browserContainer = view.findViewById(R.id.browser_container);
-
-        urlBar = view.findViewById(R.id.urlbar);
-        statusBar = view.findViewById(R.id.status_bar_background);
-
-        popupTint = view.findViewById(R.id.popup_tint);
-
-        urlView = (TextView) view.findViewById(R.id.display_url);
-        urlView.setOnLongClickListener(this);
-
-        progressView = (AnimatedProgressBar) view.findViewById(R.id.progress);
-
-        swipeRefresh = (SwipeRefreshLayout) view.findViewById(R.id.swipe_refresh);
-        swipeRefresh.setColorSchemeResources(R.color.colorAccent);
-        swipeRefresh.setEnabled(Features.SWIPE_TO_REFRESH);
-
-        swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
-            @Override
-            public void onRefresh() {
-                reload();
-
-                TelemetryWrapper.swipeReloadEvent();
-            }
-        });
-
-        session.getUrl().observe(this, new Observer<String>() {
-            @Override
-            public void onChanged(@Nullable String url) {
-                urlView.setText(UrlUtils.stripUserInfo(url));
-            }
-        });
-
-        findInPageView = view.findViewById(R.id.find_in_page);
-
-        findInPageQuery = view.findViewById(R.id.queryText);
-        findInPageResultTextView = view.findViewById(R.id.resultText);
-
-        findInPageQuery.addTextChangedListener(
-                new TextWatcher() {
-                    @Override
-                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
-
-                    @Override
-                    public void afterTextChanged(Editable s) {}
-
-                    @Override
-                    public void onTextChanged(CharSequence s, int start, int before, int count) {
-                        if (!TextUtils.isEmpty(s)) {
-                            final IWebView webView = getWebView();
-                            if (webView == null) {
-                                return;
-                            }
-
-                            webView.findAllAsync(s.toString());
-                        }
-                    }
-                }
-        );
-        findInPageQuery.setOnClickListener(this);
-        findInPageQuery.setOnEditorActionListener(new TextView.OnEditorActionListener() {
-            @Override
-            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
-                if (actionId == EditorInfo.IME_ACTION_DONE) {
-                    ViewUtils.hideKeyboard(findInPageQuery);
-                    findInPageQuery.setCursorVisible(false);
-                }
-                return false;
-            }
-        });
-
-        findInPagePrevious = view.findViewById(R.id.previousResult);
-        findInPagePrevious.setOnClickListener(this);
-
-        findInPageNext = view.findViewById(R.id.nextResult);
-        findInPageNext.setOnClickListener(this);
-
-        closeFindInPage = view.findViewById(R.id.close_find_in_page);
-        closeFindInPage.setOnClickListener(this);
-
-        setBlockingEnabled(session.isBlockingEnabled());
-        setShouldRequestDesktop(session.shouldRequestDesktopSite());
-
-        LoadTimeObserver.addObservers(session, this);
-
-        session.getLoading().observe(this, new NonNullObserver<Boolean>() {
-            @Override
-            public void onValueChanged(@NonNull Boolean loading) {
-                if (loading) {
-                    backgroundTransitionGroup.resetTransition();
-
-                    progressView.setProgress(5);
-                    progressView.setVisibility(View.VISIBLE);
-                } else {
-                    if (progressView.getVisibility() == View.VISIBLE) {
-                        // We start a transition only if a page was just loading before
-                        // allowing to avoid issue #1179
-                        backgroundTransitionGroup.startTransition(ANIMATION_DURATION);
-                        progressView.setVisibility(View.GONE);
-                    }
-                    swipeRefresh.setRefreshing(false);
-                }
-
-                updateBlockingBadging(loading || session.isBlockingEnabled());
-
-                updateToolbarButtonStates(loading);
-
-                final BrowserMenu menu = menuWeakReference.get();
-                if (menu != null) {
-                    menu.updateLoading(loading);
-                }
-
-                hideFindInPage();
-            }
-        });
-
-        if ((refreshButton = view.findViewById(R.id.refresh)) != null) {
-            refreshButton.setOnClickListener(this);
-        }
-
-        if ((stopButton = view.findViewById(R.id.stop)) != null) {
-            stopButton.setOnClickListener(this);
-        }
-
-        if ((forwardButton = view.findViewById(R.id.forward)) != null) {
-            forwardButton.setOnClickListener(this);
-        }
-
-        if ((backButton = view.findViewById(R.id.back)) != null) {
-            backButton.setOnClickListener(this);
-        }
-
-        final ImageView blockIcon = (ImageView) view.findViewById(R.id.block_image);
-        blockIcon.setImageResource(R.drawable.ic_tracking_protection_disabled);
-
-        blockView = (FrameLayout) view.findViewById(R.id.block);
-
-        securityView = view.findViewById(R.id.security_info);
-        session.getSecure().observe(this, new Observer<Boolean>() {
-            @Override
-            public void onChanged(Boolean secure) {
-                if (!session.getLoading().getValue()) {
-                    if (secure) {
-                        securityView.setImageResource(R.drawable.ic_lock);
-                    } else {
-                        if (URLUtil.isHttpUrl(getUrl())) {
-                            // HTTP site
-                            securityView.setImageResource(R.drawable.ic_internet);
-                        } else {
-                            // Certificate is bad
-                            securityView.setImageResource(R.drawable.ic_warning);
-                        }
-                    }
-                } else {
-                    securityView.setImageResource(R.drawable.ic_internet);
-                }
-            }
-        });
-        securityView.setOnClickListener(this);
-
-        session.getProgress().observe(this, new Observer<Integer>() {
-            @Override
-            public void onChanged(Integer progress) {
-                progressView.setProgress(progress);
-            }
-        });
-
-        menuView = (ImageButton) view.findViewById(R.id.menuView);
-        menuView.setOnClickListener(this);
-
-        if (session.isCustomTab()) {
-            initialiseCustomTabUi(view);
-        } else {
-            initialiseNormalBrowserUi(view);
-        }
-
-        // Pre-calculate the height of the find in page UI so that we can accurately add padding
-        // to the WebView when we present it.
-        findInPageView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
-        findInPageViewHeight = findInPageView.getMeasuredHeight();
-
-        return view;
-    }
-
-    private void initialiseNormalBrowserUi(final @NonNull View view) {
-        final FloatingEraseButton eraseButton = view.findViewById(R.id.erase);
-        eraseButton.setOnClickListener(this);
-
-        urlView.setOnClickListener(this);
-
-        final FloatingSessionsButton tabsButton = view.findViewById(R.id.tabs);
-        tabsButton.setOnClickListener(this);
-
-        sessionManager.getSessions().observe(this, new NonNullObserver<List<Session>>() {
-            @Override
-            protected void onValueChanged(@NonNull List<Session> sessions) {
-                tabsButton.updateSessionsCount(sessions.size());
-                eraseButton.updateSessionsCount(sessions.size());
-            }
-        });
-    }
-
-    private void initialiseCustomTabUi(final @NonNull View view) {
-        final CustomTabConfig customTabConfig = session.getCustomTabConfig();
-
-        // Unfortunately there's no simpler way to have the FAB only in normal-browser mode.
-        // - ViewStub: requires splitting attributes for the FAB between the ViewStub, and actual FAB layout file.
-        //             Moreover, the layout behaviour just doesn't work unless you set it programatically.
-        // - View.GONE: doesn't work because the layout-behaviour makes the FAB visible again when scrolling.
-        // - Adding at runtime: works, but then we need to use a separate layout file (and you need
-        //   to set some attributes programatically, same as ViewStub).
-        final FloatingEraseButton erase = view.findViewById(R.id.erase);
-        final ViewGroup eraseContainer = (ViewGroup) erase.getParent();
-        eraseContainer.removeView(erase);
-
-        final FloatingSessionsButton sessions = view.findViewById(R.id.tabs);
-        eraseContainer.removeView(sessions);
-
-        final int textColor;
-
-        if (customTabConfig.toolbarColor != null) {
-            urlBar.setBackgroundColor(customTabConfig.toolbarColor);
-
-            textColor = ColorUtils.getReadableTextColor(customTabConfig.toolbarColor);
-            urlView.setTextColor(textColor);
-        } else {
-            textColor = Color.WHITE;
-        }
-
-        final ImageView closeButton = (ImageView) view.findViewById(R.id.customtab_close);
-
-        closeButton.setVisibility(View.VISIBLE);
-        closeButton.setOnClickListener(this);
-
-        if (customTabConfig.closeButtonIcon != null) {
-            closeButton.setImageBitmap(customTabConfig.closeButtonIcon);
-        } else {
-            // Always set the icon in case it's been overridden by a previous CT invocation
-            final Drawable closeIcon = DrawableUtils.INSTANCE.loadAndTintDrawable(getContext(), R.drawable.ic_close, textColor);
-
-            closeButton.setImageDrawable(closeIcon);
-        }
-
-        if (customTabConfig.disableUrlbarHiding) {
-            AppBarLayout.LayoutParams params = (AppBarLayout.LayoutParams) urlBar.getLayoutParams();
-            params.setScrollFlags(0);
-        }
-
-        if (customTabConfig.actionButtonConfig != null) {
-            final ImageButton actionButton = (ImageButton) view.findViewById(R.id.customtab_actionbutton);
-            actionButton.setVisibility(View.VISIBLE);
-
-            actionButton.setImageBitmap(customTabConfig.actionButtonConfig.icon);
-            actionButton.setContentDescription(customTabConfig.actionButtonConfig.description);
-
-            final PendingIntent pendingIntent = customTabConfig.actionButtonConfig.pendingIntent;
-
-            actionButton.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    try {
-                        final Intent intent = new Intent();
-                        intent.setData(Uri.parse(getUrl()));
-
-                        pendingIntent.send(getContext(), 0, intent);
-                    } catch (PendingIntent.CanceledException e) {
-                        // There's really nothing we can do here...
-                    }
-                    TelemetryWrapper.customTabActionButtonEvent();
-                }
-            });
-        } else {
-            // If the third-party app doesn't provide an action button configuration then we are
-            // going to disable a "Share" button in the toolbar instead.
-
-            final ImageButton shareButton = view.findViewById(R.id.customtab_actionbutton);
-            shareButton.setVisibility(View.VISIBLE);
-            shareButton.setImageDrawable(DrawableUtils.INSTANCE.loadAndTintDrawable(getContext(), R.drawable.ic_share, textColor));
-            shareButton.setContentDescription(getString(R.string.menu_share));
-            shareButton.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    shareCurrentUrl();
-                }
-            });
-        }
-
-        // We need to tint some icons.. We already tinted the close button above. Let's tint our other icons too.
-        securityView.setColorFilter(textColor);
-
-        final Drawable menuIcon = DrawableUtils.INSTANCE.loadAndTintDrawable(getContext(), R.drawable.ic_menu, textColor);
-        menuView.setImageDrawable(menuIcon);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        if (pendingDownload != null) {
-            // We were not able to start this download yet (waiting for a permission). Save this download
-            // so that we can start it once we get restored and receive the permission.
-            outState.putParcelable(RESTORE_KEY_DOWNLOAD, pendingDownload);
-        }
-    }
-
-    @Override
-    public IWebView.Callback createCallback() {
-        return new SessionCallbackProxy(session, new IWebView.Callback() {
-            @Override
-            public void onPageStarted(final String url) {}
-
-            @Override
-            public void onPageFinished(boolean isSecure) {}
-
-            @Override
-            public void onSecurityChanged(boolean isSecure, String host, String organization) {}
-
-            @Override
-            public void onURLChanged(final String url) {}
-
-            @Override
-            public void onTitleChanged(String title) {}
-
-            @Override
-            public void onRequest(boolean isTriggeredByUserGesture) {}
-
-            @Override
-            public void onProgress(int progress) {}
-
-            @Override
-            public void countBlockedTracker() {}
-
-            @Override
-            public void resetBlockedTrackers() {}
-
-            @Override
-            public void onBlockingStateChanged(boolean isBlockingEnabled) {}
-
-            @Override
-            public void onHttpAuthRequest(@NonNull final IWebView.HttpAuthCallback callback, String host, String realm) {
-                HttpAuthenticationDialogBuilder builder = new HttpAuthenticationDialogBuilder.Builder(getActivity(), host, realm)
-                                .setOkListener(new HttpAuthenticationDialogBuilder.OkListener() {
-                                    @Override
-                                    public void onOk(String host, String realm, String username, String password) {
-                                        callback.proceed(username, password);
-                                    }
-                                })
-                                .setCancelListener(new HttpAuthenticationDialogBuilder.CancelListener() {
-                                    @Override
-                                    public void onCancel() {
-                                        callback.cancel();
-                                    }
-                                })
-                                .build();
-
-                builder.createDialog();
-                builder.show();
-            }
-
-            @Override
-            public void onRequestDesktopStateChanged(boolean shouldRequestDesktop) {}
-
-            @Override
-            public void onLongPress(final IWebView.HitTarget hitTarget) {
-                WebContextMenu.show(getActivity(), this, hitTarget);
-            }
-
-            @Override
-            public void onEnterFullScreen(@NonNull final IWebView.FullscreenCallback callback, @Nullable View view) {
-                fullscreenCallback = callback;
-                isFullscreen = true;
-
-                // View is passed in as null for GeckoView fullscreen
-                if (view != null) {
-                    // Hide browser UI and web content
-                    browserContainer.setVisibility(View.INVISIBLE);
-
-                    // Add view to video container and make it visible
-                    final FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
-                            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
-                    videoContainer.addView(view, params);
-                    videoContainer.setVisibility(View.VISIBLE);
-
-                    // Switch to immersive mode: Hide system bars other UI controls
-                    switchToImmersiveMode();
-                } else {
-                    // Hide status bar when entering fullscreen with GeckoView
-                    statusBar.setVisibility(View.GONE);
-                    // Switch to immersive mode: Hide system bars other UI controls
-                    switchToImmersiveMode();
-                }
-            }
-
-            @Override
-            public void onExitFullScreen() {
-                isFullscreen = false;
-
-                // Remove custom video views and hide container
-                videoContainer.removeAllViews();
-                videoContainer.setVisibility(View.GONE);
-
-                // Show browser UI and web content again
-                browserContainer.setVisibility(View.VISIBLE);
-
-                // Show status bar again (hidden in GeckoView versions)
-                statusBar.setVisibility(View.VISIBLE);
-
-                exitImmersiveModeIfNeeded();
-
-                // Notify renderer that we left fullscreen mode.
-                if (fullscreenCallback != null) {
-                    fullscreenCallback.fullScreenExited();
-                    fullscreenCallback = null;
-                }
-            }
-
-            @Override
-            public void onDownloadStart(Download download) {
-                if (PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
-                    // Long press image displays its own dialog and we handle other download cases here
-                    if (!isDownloadFromLongPressImage(download)) {
-                        showDownloadPromptDialog(download);
-                    } else {
-                        // Download dialog has already been shown from long press on image. Proceed with download.
-                        queueDownload(download);
-                    }
-                } else {
-                    // We do not have the permission to write to the external storage. Request the permission and start the
-                    // download from onRequestPermissionsResult().
-                    final Activity activity = getActivity();
-                    if (activity == null) {
-                        return;
-                    }
-
-                    pendingDownload = download;
-
-                    ActivityCompat.requestPermissions(getActivity(), new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_CODE_STORAGE_PERMISSION);
-                }
-            }
-        });
-    }
-
-    /**
-     * Checks a download's destination directory to determine if it is being called from
-     * a long press on an image or otherwise.
-     */
-    private boolean isDownloadFromLongPressImage(Download download) {
-        return download.getDestinationDirectory().equals(Environment.DIRECTORY_PICTURES);
-    }
-
-    /**
-     * Hide system bars. They can be revealed temporarily with system gestures, such as swiping from
-     * the top of the screen. These transient system bars will overlay appâ€™s content, may have some
-     * degree of transparency, and will automatically hide after a short timeout.
-     */
-    private void switchToImmersiveMode() {
-        final Activity activity = getActivity();
-        if (activity == null) {
-            return;
-        }
-
-        final Window window = activity.getWindow();
-        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        window.getDecorView().setSystemUiVisibility(
-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                        | View.SYSTEM_UI_FLAG_FULLSCREEN
-                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
-    }
-
-    /**
-     * Show the system bars again.
-     */
-    private void exitImmersiveModeIfNeeded() {
-        final Activity activity = getActivity();
-        if (activity == null) {
-            return;
-        }
-
-        if ((WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON & activity.getWindow().getAttributes().flags) == 0) {
-            // We left immersive mode already.
-            return;
-        }
-
-        final Window window = activity.getWindow();
-        window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        window.getDecorView().setSystemUiVisibility(
-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-
-        // This fragment might get destroyed before the user left immersive mode (e.g. by opening another URL from an app).
-        // In this case let's leave immersive mode now when the fragment gets destroyed.
-        exitImmersiveModeIfNeeded();
-    }
-
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        if (requestCode != REQUEST_CODE_STORAGE_PERMISSION) {
-            return;
-        }
-
-        if (grantResults.length <= 0 || grantResults[0] != PackageManager.PERMISSION_GRANTED) {
-            // We didn't get the storage permission: We are not able to start this download.
-            pendingDownload = null;
-        }
-
-        // The actual download dialog will be shown from onResume(). If this activity/fragment is
-        // getting restored then we need to 'resume' first before we can show a dialog (attaching
-        // another fragment).
-    }
-
-    void showDownloadPromptDialog(Download download) {
-        final FragmentManager fragmentManager = getFragmentManager();
-
-        if (fragmentManager.findFragmentByTag(DownloadDialogFragment.Companion.getFRAGMENT_TAG()) != null) {
-            // We are already displaying a download dialog fragment (Probably a restored fragment).
-            // No need to show another one.
-            return;
-        }
-
-        final DialogFragment downloadDialogFragment = DownloadDialogFragment.Companion.newInstance(download);
-        downloadDialogFragment.setTargetFragment(BrowserFragment.this, 300);
-
-        try {
-            downloadDialogFragment.show(fragmentManager, DownloadDialogFragment.Companion.getFRAGMENT_TAG());
-        } catch (IllegalStateException e) {
-            // It can happen that at this point in time the activity is already in the background
-            // and onSaveInstanceState() has already been called. Fragment transactions are not
-            // allowed after that anymore. It's probably safe to guess that the user might not
-            // be interested in the download at this point. So we could just *not* show the dialog.
-            // Unfortunately we can't call commitAllowingStateLoss() because committing the
-            // transaction is happening inside the DialogFragment code. Therefore we just swallow
-            // the exception here. Gulp!
-        }
-    }
-
-    void showAddToHomescreenDialog(String url, String title) {
-        final FragmentManager fragmentManager = getFragmentManager();
-
-        if (fragmentManager.findFragmentByTag(AddToHomescreenDialogFragment.FRAGMENT_TAG) != null) {
-            // We are already displaying a homescreen dialog fragment (Probably a restored fragment).
-            // No need to show another one.
-            return;
-        }
-
-        final AddToHomescreenDialogFragment addToHomescreenDialogFragment = AddToHomescreenDialogFragment.newInstance(url, title, session.isBlockingEnabled(), session.shouldRequestDesktopSite());
-        addToHomescreenDialogFragment.setTargetFragment(BrowserFragment.this, 300);
-
-        try {
-            addToHomescreenDialogFragment.show(fragmentManager, AddToHomescreenDialogFragment.FRAGMENT_TAG);
-        } catch (IllegalStateException e) {
-            // It can happen that at this point in time the activity is already in the background
-            // and onSaveInstanceState() has already been called. Fragment transactions are not
-            // allowed after that anymore. It's probably safe to guess that the user might not
-            // be interested in adding to homescreen now.
-        }
-    }
-
-    @Override
-    public void onFinishDownloadDialog(Download download, boolean shouldDownload) {
-        if (shouldDownload) {
-            queueDownload(download);
-        }
-    }
-
-    @Override
-    public void onCreateNewSession() {
-        erase();
-    }
-
-    @Override
-    public void onAuthSuccess() {
-        getView().setAlpha(1);
-    }
-
-    @Override
-    public void onCreateViewCalled() {
-        manager = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);
-        downloadBroadcastReceiver = new DownloadBroadcastReceiver(browserContainer, manager);
-
-        final IWebView webView = getWebView();
-        if (webView != null) {
-            webView.setFindListener(findInPageCoordinator);
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        final IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
-        getContext().registerReceiver(downloadBroadcastReceiver, filter);
-
-        if (pendingDownload != null
-                && PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
-            // There's a pending download (waiting for the storage permission) and now we have the
-            // missing permission: Show the dialog to ask whether the user wants to actually proceed
-            // with downloading this file.
-            showDownloadPromptDialog(pendingDownload);
-            pendingDownload = null;
-        }
-
-        StatusBarUtils.getStatusBarHeight(statusBar, new StatusBarUtils.StatusBarHeightListener() {
-            @Override
-            public void onStatusBarHeightFetched(int statusBarHeight) {
-                statusBar.getLayoutParams().height = statusBarHeight;
-            }
-        });
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
-                Settings.getInstance(getContext()).shouldUseBiometrics() &&
-                Biometrics.INSTANCE.hasFingerprintHardware(getContext())) {
-            displayBiometricPromptIfNeeded();
-        } else {
-            getView().setAlpha(1);
-        }
-    }
-
-    @RequiresApi(api = Build.VERSION_CODES.M)
-    private void displayBiometricPromptIfNeeded() {
-        final FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
-
-        // Check that we need to auth and that the fragment isn't already displayed
-        if (biometricController.getNeedsAuth()) {
-            biometricController.startAuthentication();
-
-            // Are we already displaying the biometric fragment?
-            if (fragmentManager.findFragmentByTag(BiometricAuthenticationDialogFragment.Companion.getFRAGMENT_TAG()) != null) {
-                return;
-            }
-
-            biometricController.getBiometricFragment().setTargetFragment(BrowserFragment.this, 300);
-            biometricController.getBiometricFragment().show(fragmentManager, BiometricAuthenticationDialogFragment.Companion.getFRAGMENT_TAG());
-        } else {
-            getView().setAlpha(1);
-        }
-    }
-
-    /**
-     * Use Android's Download Manager to queue this download.
-     */
-    private void queueDownload(Download download) {
-        if (download == null) {
-            return;
-        }
-
-        final Context context = getContext();
-        if (context == null) {
-            return;
-        }
-
-        final String fileName = !TextUtils.isEmpty(download.getFileName()) ? download.getFileName() :
-                DownloadUtils.guessFileName(
-                        download.getContentDisposition(),
-                        download.getUrl(),
-                        download.getMimeType());
-
-        final DownloadManager.Request request = new DownloadManager.Request(Uri.parse(download.getUrl()))
-                .addRequestHeader("Referer", getUrl())
-                .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
-                .setMimeType(download.getMimeType());
-
-        if (!AppConstants.INSTANCE.isGeckoBuild()) {
-            final String cookie = CookieManager.getInstance().getCookie(download.getUrl());
-            request.addRequestHeader("Cookie", cookie)
-                    .addRequestHeader("User-Agent", download.getUserAgent());
-        }
-
-        try {
-            request.setDestinationInExternalPublicDir(download.getDestinationDirectory(), fileName);
-        } catch (IllegalStateException e) {
-            Log.e(FRAGMENT_TAG, "Cannot create download directory");
-            return;
-        }
-
-        request.allowScanningByMediaScanner();
-
-        try {
-            long downloadReference = manager.enqueue(request);
-            downloadBroadcastReceiver.addQueuedDownload(downloadReference);
-        } catch (RuntimeException e) {
-            Log.e(FRAGMENT_TAG, "Download failed: " + e);
-        }
-    }
-
-    public boolean onBackPressed() {
-        if (findInPageView.getVisibility() == View.VISIBLE) {
-            hideFindInPage();
-        } else if (isFullscreen) {
-            final IWebView webView = getWebView();
-            if (webView != null) {
-                webView.exitFullscreen();
-            }
-        } else if (canGoBack()) {
-            // Go back in web history
-            goBack();
-        } else {
-            if (session.getSource() == Source.VIEW || session.getSource() == Source.CUSTOM_TAB) {
-                TelemetryWrapper.eraseBackToAppEvent();
-
-                // This session has been started from a VIEW intent. Go back to the previous app
-                // immediately and erase the current browsing session.
-                erase();
-
-                // If there are no other sessions then we remove the whole task because otherwise
-                // the old session might still be partially visible in the app switcher.
-                if (!SessionManager.getInstance().hasSession()) {
-                    getActivity().finishAndRemoveTask();
-                } else {
-                    getActivity().finish();
-                }
-
-                // We can't show a snackbar outside of the app. So let's show a toast instead.
-                Toast.makeText(getContext(), R.string.feedback_erase, Toast.LENGTH_SHORT).show();
-            } else {
-                // Just go back to the home screen.
-                TelemetryWrapper.eraseBackToHomeEvent();
-
-                erase();
-            }
-        }
-
-        return true;
-    }
-
-    public void erase() {
-        final IWebView webView = getWebView();
-        final Context context = getContext();
-
-        // Notify the user their session has been erased if Talk Back is enabled:
-        if (context != null) {
-            final AccessibilityManager manager = (AccessibilityManager) context
-                    .getSystemService(Context.ACCESSIBILITY_SERVICE);
-            if (manager != null && manager.isEnabled()) {
-                AccessibilityEvent event = AccessibilityEvent.obtain();
-                event.setEventType(AccessibilityEvent.TYPE_ANNOUNCEMENT);
-                event.setClassName(getClass().getName());
-                event.setPackageName(getContext().getPackageName());
-                event.getText().add(getString(R.string.feedback_erase));
-            }
-        }
-
-        if (webView != null) {
-            webView.cleanup();
-        }
-
-        if (session.isCustomTab()) {
-            SessionManager.getInstance().removeCustomTabSession(session.getUUID());
-        } else {
-            SessionManager.getInstance().removeCurrentSession();
-        }
-    }
-
-    private void shareCurrentUrl() {
-        final String url = getUrl();
-
-        final Intent shareIntent = new Intent(Intent.ACTION_SEND);
-        shareIntent.setType("text/plain");
-        shareIntent.putExtra(Intent.EXTRA_TEXT, url);
-
-        // Use title from webView if it's content matches the url
-        final IWebView webView = getWebView();
-        if (webView != null) {
-            final String contentUrl = webView.getUrl();
-            if (contentUrl != null && contentUrl.equals(url)) {
-                final String contentTitle = webView.getTitle();
-                shareIntent.putExtra(Intent.EXTRA_SUBJECT, contentTitle);
-            }
-        }
-
-        startActivity(Intent.createChooser(shareIntent, getString(R.string.share_dialog_title)));
-
-        TelemetryWrapper.shareEvent();
-    }
-
-    @Override
-    public void onClick(View view) {
-        switch (view.getId()) {
-            case R.id.menuView:
-                BrowserMenu menu = new BrowserMenu(getActivity(), this, session.getCustomTabConfig());
-                menu.show(menuView);
-
-                menuWeakReference = new WeakReference<>(menu);
-                break;
-
-            case R.id.display_url:
-                if (SessionManager.getInstance().hasSessionWithUUID(session.getUUID())) {
-                    final Fragment urlFragment = UrlInputFragment
-                            .createWithSession(session, urlView);
-
-                    getActivity().getSupportFragmentManager()
-                            .beginTransaction()
-                            .add(R.id.container, urlFragment, UrlInputFragment.FRAGMENT_TAG)
-                            .commit();
-                }
-                break;
-
-            case R.id.erase: {
-                TelemetryWrapper.eraseEvent();
-
-                erase();
-                break;
-            }
-
-            case R.id.tabs:
-                getActivity().getSupportFragmentManager()
-                        .beginTransaction()
-                        .add(R.id.container, new SessionsSheetFragment(), SessionsSheetFragment.FRAGMENT_TAG)
-                        .commit();
-
-                TelemetryWrapper.openTabsTrayEvent();
-                break;
-
-            case R.id.back: {
-                goBack();
-                break;
-            }
-
-            case R.id.forward: {
-                final IWebView webView = getWebView();
-                if (webView != null) {
-                    webView.goForward();
-                }
-                break;
-            }
-
-            case R.id.refresh: {
-                reload();
-
-                TelemetryWrapper.menuReloadEvent();
-                break;
-            }
-
-            case R.id.stop: {
-                final IWebView webView = getWebView();
-                if (webView != null) {
-                    webView.stopLoading();
-                }
-                break;
-            }
-
-            case R.id.open_in_firefox_focus: {
-                sessionManager.moveCustomTabToRegularSessions(session);
-
-                final IWebView webView = getWebView();
-                if (webView != null) {
-                    webView.saveWebViewState(session);
-                }
-
-                final Intent intent = new Intent(getContext(), MainActivity.class);
-                intent.setAction(Intent.ACTION_MAIN);
-                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                startActivity(intent);
-
-                TelemetryWrapper.openFullBrowser();
-
-                final Activity activity = getActivity();
-                if (activity != null) {
-                    activity.finish();
-                }
-
-                break;
-            }
-
-            case R.id.share: {
-                shareCurrentUrl();
-                break;
-            }
-
-            case R.id.settings:
-                ((LocaleAwareAppCompatActivity) getActivity()).openPreferences();
-                break;
-
-            case R.id.open_default: {
-                final Browsers browsers = new Browsers(getContext(), getUrl());
-
-                final ActivityInfo defaultBrowser = browsers.getDefaultBrowser();
-
-                if (defaultBrowser == null) {
-                    // We only add this menu item when a third party default exists, in
-                    // BrowserMenuAdapter.initializeMenu()
-                    throw new IllegalStateException("<Open with $Default> was shown when no default browser is set");
-                }
-
-                final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(getUrl()));
-                intent.setPackage(defaultBrowser.packageName);
-                startActivity(intent);
-
-                if (browsers.isFirefoxDefaultBrowser()) {
-                    TelemetryWrapper.openFirefoxEvent();
-                } else {
-                    TelemetryWrapper.openDefaultAppEvent();
-                }
-                break;
-            }
-
-            case R.id.open_select_browser: {
-                final Browsers browsers = new Browsers(getContext(), getUrl());
-
-                final ActivityInfo[] apps = browsers.getInstalledBrowsers();
-                final ActivityInfo store = browsers.hasFirefoxBrandedBrowserInstalled()
-                        ? null
-                        : InstallFirefoxActivity.Companion.resolveAppStore(getContext());
-
-                final OpenWithFragment fragment = OpenWithFragment.newInstance(
-                        apps,
-                        getUrl(),
-                        store);
-                fragment.show(getFragmentManager(), OpenWithFragment.FRAGMENT_TAG);
-
-                TelemetryWrapper.openSelectionEvent();
-                break;
-            }
-
-            case R.id.customtab_close: {
-                erase();
-                getActivity().finish();
-
-                TelemetryWrapper.closeCustomTabEvent();
-                break;
-            }
-
-            case R.id.help:
-                SessionManager.getInstance().createSession(Source.MENU, SupportUtils.HELP_URL);
-                break;
-
-            case R.id.help_trackers:
-                SessionManager.getInstance().createSession(Source.MENU,
-                        SupportUtils.getSumoURLForTopic(getContext(), SupportUtils.SumoTopic.TRACKERS));
-                break;
-
-            case R.id.add_to_homescreen: {
-                final IWebView webView = getWebView();
-                if (webView == null) {
-                    break;
-                }
-
-                final String url = webView.getUrl();
-                final String title = webView.getTitle();
-                showAddToHomescreenDialog(url, title);
-                break;
-            }
-
-            case R.id.security_info:
-                showSecurityPopUp();
-                break;
-
-            case R.id.report_site_issue:
-                SessionManager.getInstance()
-                        .createSession(Source.MENU,
-                                String.format(SupportUtils.REPORT_SITE_ISSUE_URL, getUrl()));
-                TelemetryWrapper.reportSiteIssueEvent();
-                break;
-
-            case R.id.find_in_page:
-                showFindInPage();
-                ViewUtils.showKeyboard(findInPageQuery);
-                TelemetryWrapper.findInPageMenuEvent();
-                break;
-
-            case R.id.queryText:
-                findInPageQuery.setCursorVisible(true);
-                break;
-
-            case R.id.nextResult: {
-                ViewUtils.hideKeyboard(findInPageQuery);
-                findInPageQuery.setCursorVisible(false);
-
-                final IWebView webView = getWebView();
-                if (webView == null) {
-                    break;
-                }
-
-                webView.findNext(true);
-                break;
-            }
-
-            case R.id.previousResult: {
-                ViewUtils.hideKeyboard(findInPageQuery);
-                findInPageQuery.setCursorVisible(false);
-
-                final IWebView webView = getWebView();
-                if (webView == null) {
-                    break;
-                }
-
-                webView.findNext(false);
-                break;
-            }
-
-            case R.id.close_find_in_page: {
-                hideFindInPage();
-
-                break;
-            }
-
-            default:
-                throw new IllegalArgumentException("Unhandled menu item in BrowserFragment");
-        }
-    }
-
-    private void updateToolbarButtonStates(boolean isLoading) {
-        if (forwardButton == null || backButton == null || refreshButton == null || stopButton == null) {
-            return;
-        }
-
-        final IWebView webView = getWebView();
-        if (webView == null) {
-            return;
-        }
-
-        final boolean canGoForward = webView.canGoForward();
-        final boolean canGoBack = webView.canGoBack();
-
-        forwardButton.setEnabled(canGoForward);
-        forwardButton.setAlpha(canGoForward ? 1.0f : 0.5f);
-        backButton.setEnabled(canGoBack);
-        backButton.setAlpha(canGoBack ? 1.0f : 0.5f);
-
-        refreshButton.setVisibility(isLoading ? View.GONE : View.VISIBLE);
-        stopButton.setVisibility(isLoading ? View.VISIBLE : View.GONE);
-    }
-
-    @NonNull
-    public String getUrl() {
-        // getUrl() is used for things like sharing the current URL. We could try to use the webview,
-        // but sometimes it's null, and sometimes it returns a null URL. Sometimes it returns a data:
-        // URL for error pages. The URL we show in the toolbar is (A) always correct and (B) what the
-        // user is probably expecting to share, so lets use that here:
-        return urlView.getText().toString();
-    }
-
-    public boolean canGoForward() {
-        final IWebView webView = getWebView();
-        return webView != null && webView.canGoForward();
-    }
-
-    public boolean canGoBack() {
-        final IWebView webView = getWebView();
-        return webView != null && webView.canGoBack();
-    }
-
-    public void goBack() {
-        final IWebView webView = getWebView();
-        if (webView != null) {
-            webView.goBack();
-        }
-    }
-
-    public void loadUrl(final String url) {
-        final IWebView webView = getWebView();
-        if (webView != null && !TextUtils.isEmpty(url)) {
-            webView.loadUrl(url);
-        }
-    }
-
-    public void reload() {
-        final IWebView webView = getWebView();
-        if (webView != null) {
-            webView.reload();
-        }
-    }
-
-    public void setBlockingEnabled(boolean enabled) {
-        final IWebView webView = getWebView();
-        if (webView != null) {
-            webView.setBlockingEnabled(enabled);
-        }
-
-        statusBar.setBackgroundResource(enabled ? R.drawable.animated_background : R.drawable.animated_background_disabled);
-
-        if (!session.isCustomTab()) {
-            // Only update the toolbar background if this is not a custom tab. Custom tabs set their
-            // own color and we do not want to override this here.
-            urlBar.setBackgroundResource(enabled ? R.drawable.animated_background : R.drawable.animated_background_disabled);
-
-            backgroundTransitionGroup = new TransitionDrawableGroup(
-                    (TransitionDrawable) urlBar.getBackground(),
-                    (TransitionDrawable) statusBar.getBackground()
-            );
-        } else {
-            backgroundTransitionGroup = new TransitionDrawableGroup(
-                    (TransitionDrawable) statusBar.getBackground()
-            );
-        }
-    }
-
-    public void setShouldRequestDesktop(boolean enabled) {
-        final IWebView webView = getWebView();
-
-        if (enabled) {
-            PreferenceManager.getDefaultSharedPreferences(getContext()).edit()
-                    .putBoolean(getContext().getString(R.string.has_requested_desktop),
-                            true).apply();
-        }
-
-        if (webView != null) {
-            webView.setRequestDesktop(enabled);
-        }
-    }
-
-    private void showSecurityPopUp() {
-        // Don't show Security Popup if the page is loading
-        if (session.getLoading().getValue()) {
-            return;
-        }
-        final PopupWindow securityPopup = PopupUtils.INSTANCE.createSecurityPopup(getContext(), session);
-        if (securityPopup != null) {
-            securityPopup.setOnDismissListener(new PopupWindow.OnDismissListener() {
-                @Override
-                public void onDismiss() {
-                    popupTint.setVisibility(View.GONE);
-                }
-            });
-            securityPopup.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
-            securityPopup.setAnimationStyle(android.R.style.Animation_Dialog);
-            securityPopup.setTouchable(true);
-            securityPopup.setFocusable(true);
-            securityPopup.setElevation(getResources().getDimension(R.dimen.menu_elevation));
-            final int offsetY = getContext().getResources().getDimensionPixelOffset(R.dimen.doorhanger_offsetY);
-            securityPopup.showAtLocation(urlBar, Gravity.TOP | Gravity.CENTER_HORIZONTAL, 0, offsetY);
-            popupTint.setVisibility(View.VISIBLE);
-        }
-    }
-
-    // In the future, if more badging icons are needed, this should be abstracted
-    public void updateBlockingBadging(boolean enabled) {
-        blockView.setVisibility(enabled ? View.GONE : View.VISIBLE);
-    }
-
-    private void dismissAutocompletePopup() {
-        autocompletePopupWeakReference.get().dismiss();
-        autocompletePopupWeakReference.clear();
-    }
-
-    public boolean onLongClick(View view) {
-        // Detect long clicks on display_url
-        if (view.getId() == R.id.display_url) {
-            Context context = getActivity();
-            if (context == null) {
-                return false;
-            }
-
-            if (session.isCustomTab()) {
-                ClipboardManager clipBoard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
-                if (clipBoard != null) {
-                    final Uri uri = Uri.parse(getUrl());
-                    clipBoard.setPrimaryClip(ClipData.newRawUri("Uri", uri));
-                    Toast.makeText(context, getString(R.string.custom_tab_copy_url_action), Toast.LENGTH_SHORT).show();
-                }
-            }
-
-            AutocompleteQuickAddPopup autocompletePopup = new AutocompleteQuickAddPopup(context, urlView.getText().toString());
-
-            // Show the Snackbar and dismiss the popup when a new URL is added.
-            autocompletePopup.setOnUrlAdded(new Function1<Boolean, Unit>() {
-                @Override
-                public Unit invoke(final Boolean didAddSuccessfully) {
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            final int messageId = didAddSuccessfully ? R.string.preference_autocomplete_add_confirmation : R.string.preference_autocomplete_duplicate_url_error;
-                            ViewUtils.showBrandedSnackbar(Objects.requireNonNull(getView()), messageId, 0);
-                            dismissAutocompletePopup();
-                        }
-                    });
-
-                    return Unit.INSTANCE;
-                }
-            });
-
-            autocompletePopup.show(urlView);
-            autocompletePopupWeakReference = new WeakReference<>(autocompletePopup);
-        }
-
-        return false;
-    }
-
-    private void showFindInPage() {
-        findInPageView.setVisibility(View.VISIBLE);
-        findInPageQuery.requestFocus();
-
-        CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams) swipeRefresh.getLayoutParams();
-        params.bottomMargin = findInPageViewHeight;
-        swipeRefresh.setLayoutParams(params);
-    }
-
-    private void hideFindInPage() {
-        final IWebView webView = getWebView();
-        if (webView == null) {
-            return;
-        }
-
-        webView.clearMatches();
-        findInPageCoordinator.reset();
-        findInPageView.setVisibility(View.GONE);
-        findInPageQuery.setText("");
-        findInPageQuery.clearFocus();
-
-        CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams) swipeRefresh.getLayoutParams();
-        params.bottomMargin = 0;
-        swipeRefresh.setLayoutParams(params);
-        ViewUtils.hideKeyboard(findInPageQuery);
-    }
-
-    private void updateFindInPageResult(Integer activeMatchOrdinal, Integer numberOfMatches) {
-        final Context context = getContext();
-        if (context == null) {
-            return;
-        }
-
-        if (numberOfMatches > 0) {
-            findInPageNext.setColorFilter(getResources().getColor(R.color.photonWhite));
-            findInPageNext.setAlpha(1.0F);
-            findInPagePrevious.setColorFilter(getResources().getColor(R.color.photonWhite));
-            findInPagePrevious.setAlpha(1.0F);
-            // We don't want the presentation of the activeMatchOrdinal to be zero indexed. So let's
-            // increment it by one for WebView.
-            if (!AppConstants.INSTANCE.isGeckoBuild()) {
-                activeMatchOrdinal++;
-            }
-            final String visibleString = String.format(context.getString(R.string.find_in_page_result), activeMatchOrdinal, numberOfMatches);
-            final String accessibleString = String.format(context.getString(R.string.find_in_page_result), activeMatchOrdinal, numberOfMatches);
-
-            findInPageResultTextView.setText(visibleString);
-            findInPageResultTextView.setContentDescription(accessibleString);
-        } else {
-            findInPageNext.setColorFilter(getResources().getColor(R.color.photonGrey10));
-            findInPageNext.setAlpha(0.4F);
-            findInPagePrevious.setColorFilter(getResources().getColor(R.color.photonWhite));
-            findInPagePrevious.setAlpha(0.4F);
-            findInPageResultTextView.setText("");
-            findInPageResultTextView.setContentDescription("");
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
new file mode 100644
index 000000000000..41233326edee
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
@@ -0,0 +1,1352 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.fragment
+
+import android.Manifest
+import android.app.DownloadManager
+import android.app.PendingIntent
+import android.arch.lifecycle.LifecycleObserver
+import android.arch.lifecycle.Observer
+import android.arch.lifecycle.ProcessLifecycleOwner
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.content.IntentFilter
+import android.content.pm.PackageManager
+import android.graphics.Color
+import android.graphics.drawable.ColorDrawable
+import android.graphics.drawable.TransitionDrawable
+import android.net.Uri
+import android.os.Build
+import android.os.Bundle
+import android.os.Environment
+import android.preference.PreferenceManager
+import android.support.annotation.RequiresApi
+import android.support.design.widget.AppBarLayout
+import android.support.design.widget.CoordinatorLayout
+import android.support.v4.app.ActivityCompat
+import android.support.v4.content.ContextCompat
+import android.support.v4.widget.SwipeRefreshLayout
+import android.text.Editable
+import android.text.TextUtils
+import android.text.TextWatcher
+import android.util.Log
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.view.WindowManager
+import android.view.accessibility.AccessibilityEvent
+import android.view.accessibility.AccessibilityManager
+import android.view.inputmethod.EditorInfo
+import android.webkit.CookieManager
+import android.webkit.URLUtil
+import android.widget.FrameLayout
+import android.widget.ImageButton
+import android.widget.ImageView
+import android.widget.TextView
+import android.widget.Toast
+
+import org.mozilla.focus.R
+import org.mozilla.focus.activity.InstallFirefoxActivity
+import org.mozilla.focus.activity.MainActivity
+import org.mozilla.focus.animation.TransitionDrawableGroup
+import org.mozilla.focus.architecture.NonNullObserver
+import org.mozilla.focus.autocomplete.AutocompleteQuickAddPopup
+import org.mozilla.focus.biometrics.BiometricAuthenticationDialogFragment
+import org.mozilla.focus.biometrics.BiometricAuthenticationHandler
+import org.mozilla.focus.biometrics.Biometrics
+import org.mozilla.focus.broadcastreceiver.DownloadBroadcastReceiver
+import org.mozilla.focus.findinpage.FindInPageCoordinator
+import org.mozilla.focus.locale.LocaleAwareAppCompatActivity
+import org.mozilla.focus.menu.browser.BrowserMenu
+import org.mozilla.focus.menu.context.WebContextMenu
+import org.mozilla.focus.observer.LoadTimeObserver
+import org.mozilla.focus.open.OpenWithFragment
+import org.mozilla.focus.popup.PopupUtils
+import org.mozilla.focus.session.NullSession
+import org.mozilla.focus.session.Session
+import org.mozilla.focus.session.SessionCallbackProxy
+import org.mozilla.focus.session.SessionManager
+import org.mozilla.focus.session.Source
+import org.mozilla.focus.session.ui.SessionsSheetFragment
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.utils.AppConstants
+import org.mozilla.focus.utils.Browsers
+import org.mozilla.focus.utils.Features
+import org.mozilla.focus.utils.Settings
+import org.mozilla.focus.utils.StatusBarUtils
+import org.mozilla.focus.utils.SupportUtils
+import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.utils.ViewUtils
+import org.mozilla.focus.web.Download
+import org.mozilla.focus.web.HttpAuthenticationDialogBuilder
+import org.mozilla.focus.web.IWebView
+import org.mozilla.focus.widget.AnimatedProgressBar
+import org.mozilla.focus.widget.FloatingEraseButton
+import org.mozilla.focus.widget.FloatingSessionsButton
+
+import java.lang.ref.WeakReference
+import java.util.Objects
+import mozilla.components.support.utils.ColorUtils
+import mozilla.components.support.utils.DownloadUtils
+import mozilla.components.support.utils.DrawableUtils
+
+/**
+ * Fragment for displaying the browser UI.
+ */
+@Suppress("LargeClass", "TooManyFunctions")
+class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
+    DownloadDialogFragment.DownloadDialogListener, View.OnLongClickListener,
+    BiometricAuthenticationDialogFragment.BiometricAuthenticationListener {
+
+    private var pendingDownload: Download? = null
+    private var backgroundTransitionGroup: TransitionDrawableGroup? = null
+    private var urlView: TextView? = null
+    private var progressView: AnimatedProgressBar? = null
+    private var blockView: FrameLayout? = null
+    private var securityView: ImageView? = null
+    private var menuView: ImageButton? = null
+    private var statusBar: View? = null
+    private var urlBar: View? = null
+    private var popupTint: FrameLayout? = null
+    private var swipeRefresh: SwipeRefreshLayout? = null
+    private var menuWeakReference: WeakReference<BrowserMenu>? = WeakReference<BrowserMenu>(null)
+    private var autocompletePopupWeakReference = WeakReference<AutocompleteQuickAddPopup>(null)
+
+    /**
+     * Container for custom video views shown in fullscreen mode.
+     */
+    private var videoContainer: ViewGroup? = null
+
+    private var isFullscreen: Boolean = false
+
+    /**
+     * Container containing the browser chrome and web content.
+     */
+    private var browserContainer: View? = null
+
+    private var forwardButton: View? = null
+    private var backButton: View? = null
+    private var refreshButton: View? = null
+    private var stopButton: View? = null
+
+    private var findInPageView: View? = null
+    private var findInPageViewHeight: Int = 0
+    private var findInPageQuery: TextView? = null
+    private var findInPageResultTextView: TextView? = null
+    private var findInPageNext: ImageButton? = null
+    private var findInPagePrevious: ImageButton? = null
+    private var closeFindInPage: ImageButton? = null
+
+    private var fullscreenCallback: IWebView.FullscreenCallback? = null
+
+    private var manager: DownloadManager? = null
+
+    private var downloadBroadcastReceiver: DownloadBroadcastReceiver? = null
+
+    private val sessionManager: SessionManager = SessionManager.getInstance()
+    private val findInPageCoordinator = FindInPageCoordinator()
+
+    private var biometricController: BiometricAuthenticationHandler? = null
+
+    // The url property is used for things like sharing the current URL. We could try to use the webview,
+    // but sometimes it's null, and sometimes it returns a null URL. Sometimes it returns a data:
+    // URL for error pages. The URL we show in the toolbar is (A) always correct and (B) what the
+    // user is probably expecting to share, so lets use that here:
+    val url: String
+        get() = urlView!!.text.toString()
+
+    override var session: Session? = null
+
+    override val initialUrl: String?
+        get() = session!!.url.value
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        ProcessLifecycleOwner.get().lifecycle.addObserver(this)
+
+        if (biometricController == null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
+            Biometrics.hasFingerprintHardware(context!!)
+        ) {
+            biometricController = BiometricAuthenticationHandler(context!!)
+        }
+
+        val sessionUUID = arguments!!.getString(ARGUMENT_SESSION_UUID) ?: throw IllegalAccessError("No session exists")
+
+        session = if (sessionManager.hasSessionWithUUID(sessionUUID))
+            sessionManager.getSessionByUUID(sessionUUID)
+        else
+            NullSession()
+
+        session!!.blockedTrackers.observe(this, Observer { blockedTrackers ->
+            if (menuWeakReference == null) {
+                return@Observer
+            }
+
+            val menu = menuWeakReference!!.get()
+
+            menu?.updateTrackers(blockedTrackers!!)
+        })
+
+        findInPageCoordinator.matches.observe(
+            this,
+            Observer { matches -> updateFindInPageResult(matches!!.first, matches.second) })
+    }
+
+    override fun onPause() {
+        super.onPause()
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
+            Settings.getInstance(context!!).shouldUseBiometrics() &&
+            Biometrics.hasFingerprintHardware(context!!)
+        ) {
+            biometricController!!.stopListening()
+            view!!.alpha = 0f
+        }
+
+        context!!.unregisterReceiver(downloadBroadcastReceiver)
+
+        if (isFullscreen) {
+            getWebView()?.exitFullscreen()
+        }
+
+        val menu = menuWeakReference!!.get()
+        if (menu != null) {
+            menu.dismiss()
+
+            menuWeakReference!!.clear()
+        }
+    }
+
+    @Suppress("LongMethod", "ComplexMethod")
+    override fun inflateLayout(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
+        if (savedInstanceState != null && savedInstanceState.containsKey(RESTORE_KEY_DOWNLOAD)) {
+            // If this activity was destroyed before we could start a download (e.g. because we were waiting for a
+            // permission) then restore the download object.
+            pendingDownload = savedInstanceState.getParcelable(RESTORE_KEY_DOWNLOAD)
+        }
+
+        val view = inflater.inflate(R.layout.fragment_browser, container, false)
+
+        videoContainer = view.findViewById<View>(R.id.video_container) as ViewGroup
+        browserContainer = view.findViewById(R.id.browser_container)
+
+        urlBar = view.findViewById(R.id.urlbar)
+        statusBar = view.findViewById(R.id.status_bar_background)
+
+        popupTint = view.findViewById(R.id.popup_tint)
+
+        urlView = view.findViewById<View>(R.id.display_url) as TextView
+        urlView!!.setOnLongClickListener(this)
+
+        progressView = view.findViewById<View>(R.id.progress) as AnimatedProgressBar
+
+        swipeRefresh = view.findViewById<View>(R.id.swipe_refresh) as SwipeRefreshLayout
+        swipeRefresh!!.setColorSchemeResources(R.color.colorAccent)
+        swipeRefresh!!.isEnabled = Features.SWIPE_TO_REFRESH
+
+        swipeRefresh!!.setOnRefreshListener {
+            reload()
+
+            TelemetryWrapper.swipeReloadEvent()
+        }
+
+        session!!.url.observe(this, Observer { url -> urlView!!.text = UrlUtils.stripUserInfo(url) })
+
+        findInPageView = view.findViewById(R.id.find_in_page)
+
+        findInPageQuery = view.findViewById(R.id.queryText)
+        findInPageResultTextView = view.findViewById(R.id.resultText)
+
+        findInPageQuery!!.addTextChangedListener(
+            object : TextWatcher {
+                override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
+
+                override fun afterTextChanged(s: Editable) {}
+
+                override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
+                    if (!TextUtils.isEmpty(s)) {
+                        getWebView()?.findAllAsync(s.toString())
+                    }
+                }
+            }
+        )
+        findInPageQuery!!.setOnClickListener(this)
+        findInPageQuery!!.setOnEditorActionListener { _, actionId, _ ->
+            if (actionId == EditorInfo.IME_ACTION_DONE) {
+                ViewUtils.hideKeyboard(findInPageQuery!!)
+                findInPageQuery!!.isCursorVisible = false
+            }
+            false
+        }
+
+        findInPagePrevious = view.findViewById(R.id.previousResult)
+        findInPagePrevious!!.setOnClickListener(this)
+
+        findInPageNext = view.findViewById(R.id.nextResult)
+        findInPageNext!!.setOnClickListener(this)
+
+        closeFindInPage = view.findViewById(R.id.close_find_in_page)
+        closeFindInPage!!.setOnClickListener(this)
+
+        setBlockingEnabled(session!!.isBlockingEnabled)
+        setShouldRequestDesktop(session!!.shouldRequestDesktopSite())
+
+        LoadTimeObserver.addObservers(session!!, this)
+
+        session!!.loading.observe(this, object : NonNullObserver<Boolean>() {
+            public override fun onValueChanged(t: Boolean) {
+                val loading = t
+                if (loading) {
+                    backgroundTransitionGroup!!.resetTransition()
+
+                    progressView!!.progress = BrowserFragment.INITIAL_PROGRESS
+                    progressView!!.visibility = View.VISIBLE
+                } else {
+                    if (progressView!!.visibility == View.VISIBLE) {
+                        // We start a transition only if a page was just loading before
+                        // allowing to avoid issue #1179
+                        backgroundTransitionGroup!!.startTransition(ANIMATION_DURATION)
+                        progressView!!.visibility = View.GONE
+                    }
+                    swipeRefresh!!.isRefreshing = false
+                }
+
+                updateBlockingBadging(loading || session!!.isBlockingEnabled)
+
+                updateToolbarButtonStates(loading)
+
+                val menu = menuWeakReference!!.get()
+                menu?.updateLoading(loading)
+
+                hideFindInPage()
+            }
+        })
+
+        refreshButton = view.findViewById(R.id.refresh)
+        refreshButton?.let { it.setOnClickListener(this) }
+
+        stopButton = view.findViewById(R.id.stop)
+        stopButton?.let { it.setOnClickListener(this) }
+
+        forwardButton = view.findViewById(R.id.forward)
+        forwardButton?.let { it.setOnClickListener(this) }
+
+        backButton = view.findViewById(R.id.back)
+        backButton?.let { it.setOnClickListener(this) }
+
+        val blockIcon = view.findViewById<View>(R.id.block_image) as ImageView
+        blockIcon.setImageResource(R.drawable.ic_tracking_protection_disabled)
+
+        blockView = view.findViewById<View>(R.id.block) as FrameLayout
+
+        securityView = view.findViewById(R.id.security_info)
+        session!!.secure.observe(this, Observer { secure ->
+            if (!session!!.loading.value) {
+                if (secure!!) {
+                    securityView!!.setImageResource(R.drawable.ic_lock)
+                } else {
+                    if (URLUtil.isHttpUrl(url)) {
+                        // HTTP site
+                        securityView!!.setImageResource(R.drawable.ic_internet)
+                    } else {
+                        // Certificate is bad
+                        securityView!!.setImageResource(R.drawable.ic_warning)
+                    }
+                }
+            } else {
+                securityView!!.setImageResource(R.drawable.ic_internet)
+            }
+        })
+        securityView!!.setOnClickListener(this)
+
+        session!!.progress.observe(this, Observer { progress -> progressView!!.progress = progress!! })
+
+        menuView = view.findViewById<View>(R.id.menuView) as ImageButton
+        menuView!!.setOnClickListener(this)
+
+        if (session!!.isCustomTab) {
+            initialiseCustomTabUi(view)
+        } else {
+            initialiseNormalBrowserUi(view)
+        }
+
+        // Pre-calculate the height of the find in page UI so that we can accurately add padding
+        // to the WebView when we present it.
+        findInPageView!!.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED)
+        findInPageViewHeight = findInPageView!!.measuredHeight
+
+        return view
+    }
+
+    private fun initialiseNormalBrowserUi(view: View) {
+        val eraseButton = view.findViewById<FloatingEraseButton>(R.id.erase)
+        eraseButton.setOnClickListener(this)
+
+        urlView!!.setOnClickListener(this)
+
+        val tabsButton = view.findViewById<FloatingSessionsButton>(R.id.tabs)
+        tabsButton.setOnClickListener(this)
+
+        sessionManager.sessions.observe(this, object : NonNullObserver<List<Session>>() {
+            override fun onValueChanged(t: List<Session>) {
+                val sessions = t
+                tabsButton.updateSessionsCount(sessions.size)
+                eraseButton.updateSessionsCount(sessions.size)
+            }
+        })
+    }
+
+    private fun initialiseCustomTabUi(view: View) {
+        val customTabConfig = session!!.customTabConfig
+
+        // Unfortunately there's no simpler way to have the FAB only in normal-browser mode.
+        // - ViewStub: requires splitting attributes for the FAB between the ViewStub, and actual FAB layout file.
+        //             Moreover, the layout behaviour just doesn't work unless you set it programatically.
+        // - View.GONE: doesn't work because the layout-behaviour makes the FAB visible again when scrolling.
+        // - Adding at runtime: works, but then we need to use a separate layout file (and you need
+        //   to set some attributes programatically, same as ViewStub).
+        val erase = view.findViewById<FloatingEraseButton>(R.id.erase)
+        val eraseContainer = erase.parent as ViewGroup
+        eraseContainer.removeView(erase)
+
+        val sessions = view.findViewById<FloatingSessionsButton>(R.id.tabs)
+        eraseContainer.removeView(sessions)
+
+        val textColor: Int
+
+        if (customTabConfig.toolbarColor != null) {
+            urlBar!!.setBackgroundColor(customTabConfig.toolbarColor)
+
+            textColor = ColorUtils.getReadableTextColor(customTabConfig.toolbarColor)
+            urlView!!.setTextColor(textColor)
+        } else {
+            textColor = Color.WHITE
+        }
+
+        val closeButton = view.findViewById<View>(R.id.customtab_close) as ImageView
+
+        closeButton.visibility = View.VISIBLE
+        closeButton.setOnClickListener(this)
+
+        if (customTabConfig.closeButtonIcon != null) {
+            closeButton.setImageBitmap(customTabConfig.closeButtonIcon)
+        } else {
+            // Always set the icon in case it's been overridden by a previous CT invocation
+            val closeIcon = DrawableUtils.loadAndTintDrawable(context!!, R.drawable.ic_close, textColor)
+
+            closeButton.setImageDrawable(closeIcon)
+        }
+
+        if (customTabConfig.disableUrlbarHiding) {
+            val params = urlBar!!.layoutParams as AppBarLayout.LayoutParams
+            params.scrollFlags = 0
+        }
+
+        if (customTabConfig.actionButtonConfig != null) {
+            val actionButton = view.findViewById<View>(R.id.customtab_actionbutton) as ImageButton
+            actionButton.visibility = View.VISIBLE
+
+            actionButton.setImageBitmap(customTabConfig.actionButtonConfig.icon)
+            actionButton.contentDescription = customTabConfig.actionButtonConfig.description
+
+            val pendingIntent = customTabConfig.actionButtonConfig.pendingIntent
+
+            actionButton.setOnClickListener {
+                try {
+                    val intent = Intent()
+                    intent.data = Uri.parse(url)
+
+                    pendingIntent.send(context, 0, intent)
+                } catch (e: PendingIntent.CanceledException) {
+                    // There's really nothing we can do here...
+                }
+
+                TelemetryWrapper.customTabActionButtonEvent()
+            }
+        } else {
+            // If the third-party app doesn't provide an action button configuration then we are
+            // going to disable a "Share" button in the toolbar instead.
+
+            val shareButton = view.findViewById<ImageButton>(R.id.customtab_actionbutton)
+            shareButton.visibility = View.VISIBLE
+            shareButton.setImageDrawable(DrawableUtils.loadAndTintDrawable(context!!, R.drawable.ic_share, textColor))
+            shareButton.contentDescription = getString(R.string.menu_share)
+            shareButton.setOnClickListener { shareCurrentUrl() }
+        }
+
+        // We need to tint some icons.. We already tinted the close button above. Let's tint our other icons too.
+        securityView!!.setColorFilter(textColor)
+
+        val menuIcon = DrawableUtils.loadAndTintDrawable(context!!, R.drawable.ic_menu, textColor)
+        menuView!!.setImageDrawable(menuIcon)
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+
+        if (pendingDownload != null) {
+            // We were not able to start this download yet (waiting for a permission). Save this download
+            // so that we can start it once we get restored and receive the permission.
+            outState.putParcelable(RESTORE_KEY_DOWNLOAD, pendingDownload)
+        }
+    }
+
+    @Suppress("ComplexMethod")
+    override fun createCallback(): IWebView.Callback {
+        return SessionCallbackProxy(session, object : IWebView.Callback {
+            override fun onPageStarted(url: String) {}
+
+            override fun onPageFinished(isSecure: Boolean) {}
+
+            override fun onSecurityChanged(isSecure: Boolean, host: String, organization: String) {}
+
+            override fun onURLChanged(url: String) {}
+
+            override fun onTitleChanged(title: String) {}
+
+            override fun onRequest(isTriggeredByUserGesture: Boolean) {}
+
+            override fun onProgress(progress: Int) {}
+
+            override fun countBlockedTracker() {}
+
+            override fun resetBlockedTrackers() {}
+
+            override fun onBlockingStateChanged(isBlockingEnabled: Boolean) {}
+
+            override fun onHttpAuthRequest(callback: IWebView.HttpAuthCallback, host: String, realm: String) {
+                val builder = HttpAuthenticationDialogBuilder.Builder(activity, host, realm)
+                    .setOkListener { _, _, username, password -> callback.proceed(username, password) }
+                    .setCancelListener { callback.cancel() }
+                    .build()
+
+                builder.createDialog()
+                builder.show()
+            }
+
+            override fun onRequestDesktopStateChanged(shouldRequestDesktop: Boolean) {}
+
+            override fun onLongPress(hitTarget: IWebView.HitTarget) {
+                WebContextMenu.show(activity!!, this, hitTarget)
+            }
+
+            override fun onEnterFullScreen(callback: IWebView.FullscreenCallback, view: View?) {
+                fullscreenCallback = callback
+                isFullscreen = true
+
+                // View is passed in as null for GeckoView fullscreen
+                if (view != null) {
+                    // Hide browser UI and web content
+                    browserContainer!!.visibility = View.INVISIBLE
+
+                    // Add view to video container and make it visible
+                    val params = FrameLayout.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
+                    )
+                    videoContainer!!.addView(view, params)
+                    videoContainer!!.visibility = View.VISIBLE
+
+                    // Switch to immersive mode: Hide system bars other UI controls
+                    switchToImmersiveMode()
+                } else {
+                    // Hide status bar when entering fullscreen with GeckoView
+                    statusBar!!.visibility = View.GONE
+                    // Switch to immersive mode: Hide system bars other UI controls
+                    switchToImmersiveMode()
+                }
+            }
+
+            override fun onExitFullScreen() {
+                isFullscreen = false
+
+                // Remove custom video views and hide container
+                videoContainer!!.removeAllViews()
+                videoContainer!!.visibility = View.GONE
+
+                // Show browser UI and web content again
+                browserContainer!!.visibility = View.VISIBLE
+
+                // Show status bar again (hidden in GeckoView versions)
+                statusBar!!.visibility = View.VISIBLE
+
+                exitImmersiveModeIfNeeded()
+
+                // Notify renderer that we left fullscreen mode.
+                if (fullscreenCallback != null) {
+                    fullscreenCallback!!.fullScreenExited()
+                    fullscreenCallback = null
+                }
+            }
+
+            override fun onDownloadStart(download: Download) {
+                if (PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(
+                        context!!,
+                        Manifest.permission.WRITE_EXTERNAL_STORAGE
+                    )
+                ) {
+                    // Long press image displays its own dialog and we handle other download cases here
+                    if (!isDownloadFromLongPressImage(download)) {
+                        showDownloadPromptDialog(download)
+                    } else {
+                        // Download dialog has already been shown from long press on image. Proceed with download.
+                        queueDownload(download)
+                    }
+                } else {
+                    // We do not have the permission to write to the external storage. Request the permission and start
+                    // the  download from onRequestPermissionsResult().
+                    val activity = activity ?: return
+
+                    pendingDownload = download
+
+                    ActivityCompat.requestPermissions(
+                        activity,
+                        arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
+                        REQUEST_CODE_STORAGE_PERMISSION
+                    )
+                }
+            }
+        })
+    }
+
+    /**
+     * Checks a download's destination directory to determine if it is being called from
+     * a long press on an image or otherwise.
+     */
+    private fun isDownloadFromLongPressImage(download: Download): Boolean {
+        return download.destinationDirectory == Environment.DIRECTORY_PICTURES
+    }
+
+    /**
+     * Hide system bars. They can be revealed temporarily with system gestures, such as swiping from
+     * the top of the screen. These transient system bars will overlay appâ€™s content, may have some
+     * degree of transparency, and will automatically hide after a short timeout.
+     */
+    private fun switchToImmersiveMode() {
+        val activity = activity ?: return
+
+        val window = activity.window
+        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
+        window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+            or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+            or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+            or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
+            or View.SYSTEM_UI_FLAG_FULLSCREEN
+            or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)
+    }
+
+    /**
+     * Show the system bars again.
+     */
+    private fun exitImmersiveModeIfNeeded() {
+        val activity = activity ?: return
+
+        if (WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON and activity.window.attributes.flags == 0) {
+            // We left immersive mode already.
+            return
+        }
+
+        val window = activity.window
+        window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
+        window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+
+        // This fragment might get destroyed before the user left immersive mode (e.g. by opening another URL from an
+        // app). In this case let's leave immersive mode now when the fragment gets destroyed.
+        exitImmersiveModeIfNeeded()
+    }
+
+    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
+        if (requestCode != REQUEST_CODE_STORAGE_PERMISSION) {
+            return
+        }
+
+        if (grantResults.size <= 0 || grantResults[0] != PackageManager.PERMISSION_GRANTED) {
+            // We didn't get the storage permission: We are not able to start this download.
+            pendingDownload = null
+        }
+
+        // The actual download dialog will be shown from onResume(). If this activity/fragment is
+        // getting restored then we need to 'resume' first before we can show a dialog (attaching
+        // another fragment).
+    }
+
+    internal fun showDownloadPromptDialog(download: Download) {
+        val fragmentManager = fragmentManager
+
+        if (fragmentManager!!.findFragmentByTag(DownloadDialogFragment.FRAGMENT_TAG) != null) {
+            // We are already displaying a download dialog fragment (Probably a restored fragment).
+            // No need to show another one.
+            return
+        }
+
+        val downloadDialogFragment = DownloadDialogFragment.newInstance(download)
+        downloadDialogFragment.setTargetFragment(this@BrowserFragment, REQUEST_CODE_DOWNLOAD_DIALOG)
+
+        try {
+            downloadDialogFragment.show(fragmentManager, DownloadDialogFragment.FRAGMENT_TAG)
+        } catch (e: IllegalStateException) {
+            // It can happen that at this point in time the activity is already in the background
+            // and onSaveInstanceState() has already been called. Fragment transactions are not
+            // allowed after that anymore. It's probably safe to guess that the user might not
+            // be interested in the download at this point. So we could just *not* show the dialog.
+            // Unfortunately we can't call commitAllowingStateLoss() because committing the
+            // transaction is happening inside the DialogFragment code. Therefore we just swallow
+            // the exception here. Gulp!
+        }
+    }
+
+    internal fun showAddToHomescreenDialog(url: String, title: String) {
+        val fragmentManager = fragmentManager
+
+        if (fragmentManager!!.findFragmentByTag(AddToHomescreenDialogFragment.FRAGMENT_TAG) != null) {
+            // We are already displaying a homescreen dialog fragment (Probably a restored fragment).
+            // No need to show another one.
+            return
+        }
+
+        val addToHomescreenDialogFragment = AddToHomescreenDialogFragment.newInstance(
+            url,
+            title,
+            session!!.isBlockingEnabled,
+            session!!.shouldRequestDesktopSite()
+        )
+        addToHomescreenDialogFragment.setTargetFragment(
+            this@BrowserFragment,
+            REQUEST_CODE_ADD_TO_HOMESCREEN_DIALOG)
+
+        try {
+            addToHomescreenDialogFragment.show(fragmentManager, AddToHomescreenDialogFragment.FRAGMENT_TAG)
+        } catch (e: IllegalStateException) {
+            // It can happen that at this point in time the activity is already in the background
+            // and onSaveInstanceState() has already been called. Fragment transactions are not
+            // allowed after that anymore. It's probably safe to guess that the user might not
+            // be interested in adding to homescreen now.
+        }
+    }
+
+    override fun onFinishDownloadDialog(download: Download?, shouldDownload: Boolean) {
+        if (shouldDownload) {
+            queueDownload(download)
+        }
+    }
+
+    override fun onCreateNewSession() {
+        erase()
+    }
+
+    override fun onAuthSuccess() {
+        view!!.alpha = 1f
+    }
+
+    override fun onCreateViewCalled() {
+        manager = context!!.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
+        downloadBroadcastReceiver = DownloadBroadcastReceiver(browserContainer, manager)
+
+        val webView = getWebView()
+        webView?.setFindListener(findInPageCoordinator)
+    }
+
+    override fun onResume() {
+        super.onResume()
+
+        val filter = IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)
+        context!!.registerReceiver(downloadBroadcastReceiver, filter)
+
+        if (pendingDownload != null && PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(
+                context!!,
+                Manifest.permission.WRITE_EXTERNAL_STORAGE
+            )
+        ) {
+            // There's a pending download (waiting for the storage permission) and now we have the
+            // missing permission: Show the dialog to ask whether the user wants to actually proceed
+            // with downloading this file.
+            showDownloadPromptDialog(pendingDownload!!)
+            pendingDownload = null
+        }
+
+        StatusBarUtils.getStatusBarHeight(statusBar) { statusBarHeight ->
+            statusBar!!.layoutParams.height = statusBarHeight
+        }
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
+            Settings.getInstance(context!!).shouldUseBiometrics() &&
+            Biometrics.hasFingerprintHardware(context!!)
+        ) {
+            displayBiometricPromptIfNeeded()
+        } else {
+            view!!.alpha = 1f
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.M)
+    private fun displayBiometricPromptIfNeeded() {
+        val fragmentManager = activity!!.supportFragmentManager
+
+        // Check that we need to auth and that the fragment isn't already displayed
+        if (biometricController!!.needsAuth) {
+            biometricController!!.startAuthentication()
+
+            // Are we already displaying the biometric fragment?
+            if (fragmentManager.findFragmentByTag(BiometricAuthenticationDialogFragment.FRAGMENT_TAG) != null) {
+                return
+            }
+
+            biometricController!!.biometricFragment!!.setTargetFragment(
+                this@BrowserFragment, REQUEST_CODE_BIOMETRIC_PROMPT)
+            biometricController!!.biometricFragment!!.show(
+                fragmentManager,
+                BiometricAuthenticationDialogFragment.FRAGMENT_TAG
+            )
+        } else {
+            view!!.alpha = 1f
+        }
+    }
+
+    /**
+     * Use Android's Download Manager to queue this download.
+     */
+    private fun queueDownload(download: Download?) {
+        if (download == null) {
+            return
+        }
+
+        val fileName = if (!TextUtils.isEmpty(download.fileName))
+            download.fileName
+        else
+            DownloadUtils.guessFileName(
+                download.contentDisposition,
+                download.url,
+                download.mimeType
+            )
+
+        val request = DownloadManager.Request(Uri.parse(download.url))
+            .addRequestHeader("Referer", url)
+            .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
+            .setMimeType(download.mimeType)
+
+        if (!AppConstants.isGeckoBuild) {
+            val cookie = CookieManager.getInstance().getCookie(download.url)
+            request.addRequestHeader("Cookie", cookie)
+                .addRequestHeader("User-Agent", download.userAgent)
+        }
+
+        try {
+            request.setDestinationInExternalPublicDir(download.destinationDirectory, fileName)
+        } catch (e: IllegalStateException) {
+            Log.e(FRAGMENT_TAG, "Cannot create download directory")
+            return
+        }
+
+        request.allowScanningByMediaScanner()
+
+        @Suppress("TooGenericExceptionCaught")
+        try {
+            val downloadReference = manager!!.enqueue(request)
+            downloadBroadcastReceiver!!.addQueuedDownload(downloadReference)
+        } catch (e: RuntimeException) {
+            Log.e(FRAGMENT_TAG, "Download failed: $e")
+        }
+    }
+
+    @Suppress("ComplexMethod")
+    fun onBackPressed(): Boolean {
+        if (findInPageView!!.visibility == View.VISIBLE) {
+            hideFindInPage()
+        } else if (isFullscreen) {
+            val webView = getWebView()
+            webView?.exitFullscreen()
+        } else if (canGoBack()) {
+            // Go back in web history
+            goBack()
+        } else {
+            if (session!!.source == Source.VIEW || session!!.source == Source.CUSTOM_TAB) {
+                TelemetryWrapper.eraseBackToAppEvent()
+
+                // This session has been started from a VIEW intent. Go back to the previous app
+                // immediately and erase the current browsing session.
+                erase()
+
+                // If there are no other sessions then we remove the whole task because otherwise
+                // the old session might still be partially visible in the app switcher.
+                if (!SessionManager.getInstance().hasSession()) {
+                    activity!!.finishAndRemoveTask()
+                } else {
+                    activity!!.finish()
+                }
+
+                // We can't show a snackbar outside of the app. So let's show a toast instead.
+                Toast.makeText(context, R.string.feedback_erase, Toast.LENGTH_SHORT).show()
+            } else {
+                // Just go back to the home screen.
+                TelemetryWrapper.eraseBackToHomeEvent()
+
+                erase()
+            }
+        }
+
+        return true
+    }
+
+    fun erase() {
+        val webView = getWebView()
+        val context = context
+
+        // Notify the user their session has been erased if Talk Back is enabled:
+        if (context != null) {
+            val manager = context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
+            if (manager.isEnabled) {
+                val event = AccessibilityEvent.obtain()
+                event.eventType = AccessibilityEvent.TYPE_ANNOUNCEMENT
+                event.className = javaClass.name
+                event.packageName = getContext()!!.packageName
+                event.text.add(getString(R.string.feedback_erase))
+            }
+        }
+
+        webView?.cleanup()
+
+        if (session!!.isCustomTab) {
+            SessionManager.getInstance().removeCustomTabSession(session!!.uuid)
+        } else {
+            SessionManager.getInstance().removeCurrentSession()
+        }
+    }
+
+    private fun shareCurrentUrl() {
+        val url = url
+
+        val shareIntent = Intent(Intent.ACTION_SEND)
+        shareIntent.type = "text/plain"
+        shareIntent.putExtra(Intent.EXTRA_TEXT, url)
+
+        // Use title from webView if it's content matches the url
+        val webView = getWebView()
+        if (webView != null) {
+            val contentUrl = webView.url
+            if (contentUrl != null && contentUrl == url) {
+                val contentTitle = webView.title
+                shareIntent.putExtra(Intent.EXTRA_SUBJECT, contentTitle)
+            }
+        }
+
+        startActivity(Intent.createChooser(shareIntent, getString(R.string.share_dialog_title)))
+
+        TelemetryWrapper.shareEvent()
+    }
+
+    @Suppress("ComplexMethod")
+    override fun onClick(view: View) {
+        when (view.id) {
+            R.id.menuView -> {
+                val menu = BrowserMenu(activity, this, session!!.customTabConfig)
+                menu.show(menuView)
+
+                menuWeakReference = WeakReference(menu)
+            }
+
+            R.id.display_url -> if (SessionManager.getInstance().hasSessionWithUUID(session!!.uuid)) {
+                val urlFragment = UrlInputFragment
+                    .createWithSession(session!!, urlView!!)
+
+                activity!!.supportFragmentManager
+                    .beginTransaction()
+                    .add(R.id.container, urlFragment, UrlInputFragment.FRAGMENT_TAG)
+                    .commit()
+            }
+
+            R.id.erase -> {
+                TelemetryWrapper.eraseEvent()
+
+                erase()
+            }
+
+            R.id.tabs -> {
+                activity!!.supportFragmentManager
+                    .beginTransaction()
+                    .add(R.id.container, SessionsSheetFragment(), SessionsSheetFragment.FRAGMENT_TAG)
+                    .commit()
+
+                TelemetryWrapper.openTabsTrayEvent()
+            }
+
+            R.id.back -> {
+                goBack()
+            }
+
+            R.id.forward -> {
+                val webView = getWebView()
+                webView?.goForward()
+            }
+
+            R.id.refresh -> {
+                reload()
+
+                TelemetryWrapper.menuReloadEvent()
+            }
+
+            R.id.stop -> {
+                val webView = getWebView()
+                webView?.stopLoading()
+            }
+
+            R.id.open_in_firefox_focus -> {
+                sessionManager.moveCustomTabToRegularSessions(session)
+
+                val webView = getWebView()
+                webView?.saveWebViewState(session!!)
+
+                val intent = Intent(context, MainActivity::class.java)
+                intent.action = Intent.ACTION_MAIN
+                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
+                startActivity(intent)
+
+                TelemetryWrapper.openFullBrowser()
+
+                val activity = activity
+                activity?.finish()
+            }
+
+            R.id.share -> {
+                shareCurrentUrl()
+            }
+
+            R.id.settings -> (activity as LocaleAwareAppCompatActivity).openPreferences()
+
+            R.id.open_default -> {
+                val browsers = Browsers(context!!, url)
+
+                val defaultBrowser = browsers.defaultBrowser
+                    ?: // We only add this menu item when a third party default exists, in
+                    // BrowserMenuAdapter.initializeMenu()
+                    throw IllegalStateException("<Open with \$Default> was shown when no default browser is set")
+
+                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
+                intent.setPackage(defaultBrowser.packageName)
+                startActivity(intent)
+
+                if (browsers.isFirefoxDefaultBrowser) {
+                    TelemetryWrapper.openFirefoxEvent()
+                } else {
+                    TelemetryWrapper.openDefaultAppEvent()
+                }
+            }
+
+            R.id.open_select_browser -> {
+                val browsers = Browsers(context!!, url)
+
+                val apps = browsers.installedBrowsers
+                val store = if (browsers.hasFirefoxBrandedBrowserInstalled())
+                    null
+                else
+                    InstallFirefoxActivity.resolveAppStore(context!!)
+
+                val fragment = OpenWithFragment.newInstance(
+                    apps,
+                    url,
+                    store
+                )
+                fragment.show(fragmentManager!!, OpenWithFragment.FRAGMENT_TAG)
+
+                TelemetryWrapper.openSelectionEvent()
+            }
+
+            R.id.customtab_close -> {
+                erase()
+                activity!!.finish()
+
+                TelemetryWrapper.closeCustomTabEvent()
+            }
+
+            R.id.help -> SessionManager.getInstance().createSession(Source.MENU, SupportUtils.HELP_URL)
+
+            R.id.help_trackers -> SessionManager.getInstance().createSession(
+                Source.MENU,
+                SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.TRACKERS)
+            )
+
+            R.id.add_to_homescreen -> {
+                val webView = getWebView() ?: return
+
+                val url = webView.url
+                val title = webView.title
+                showAddToHomescreenDialog(url, title)
+            }
+
+            R.id.security_info -> showSecurityPopUp()
+
+            R.id.report_site_issue -> {
+                SessionManager.getInstance()
+                    .createSession(
+                        Source.MENU,
+                        String.format(SupportUtils.REPORT_SITE_ISSUE_URL, url)
+                    )
+                TelemetryWrapper.reportSiteIssueEvent()
+            }
+
+            R.id.find_in_page -> {
+                showFindInPage()
+                ViewUtils.showKeyboard(findInPageQuery)
+                TelemetryWrapper.findInPageMenuEvent()
+            }
+
+            R.id.queryText -> findInPageQuery!!.isCursorVisible = true
+
+            R.id.nextResult -> {
+                ViewUtils.hideKeyboard(findInPageQuery!!)
+                findInPageQuery!!.isCursorVisible = false
+
+                getWebView()?.findNext(true)
+            }
+
+            R.id.previousResult -> {
+                ViewUtils.hideKeyboard(findInPageQuery!!)
+                findInPageQuery!!.isCursorVisible = false
+
+                getWebView()?.findNext(false)
+            }
+
+            R.id.close_find_in_page -> {
+                hideFindInPage()
+            }
+
+            else -> throw IllegalArgumentException("Unhandled menu item in BrowserFragment")
+        }
+    }
+
+    @Suppress("MagicNumber")
+    private fun updateToolbarButtonStates(isLoading: Boolean) {
+        @Suppress("ComplexCondition")
+        if (forwardButton == null || backButton == null || refreshButton == null || stopButton == null) {
+            return
+        }
+
+        val webView = getWebView() ?: return
+
+        val canGoForward = webView.canGoForward()
+        val canGoBack = webView.canGoBack()
+
+        forwardButton!!.isEnabled = canGoForward
+        forwardButton!!.alpha = if (canGoForward) 1.0f else 0.5f
+        backButton!!.isEnabled = canGoBack
+        backButton!!.alpha = if (canGoBack) 1.0f else 0.5f
+
+        refreshButton!!.visibility = if (isLoading) View.GONE else View.VISIBLE
+        stopButton!!.visibility = if (isLoading) View.VISIBLE else View.GONE
+    }
+
+    fun canGoForward(): Boolean = getWebView()?.canGoForward() ?: false
+
+    fun canGoBack(): Boolean = getWebView()?.canGoBack() ?: false
+
+    fun goBack() = getWebView()?.goBack()
+
+    fun loadUrl(url: String) {
+        val webView = getWebView()
+        if (webView != null && !TextUtils.isEmpty(url)) {
+            webView.loadUrl(url)
+        }
+    }
+
+    fun reload() = getWebView()?.reload()
+
+    fun setBlockingEnabled(enabled: Boolean) {
+        val webView = getWebView()
+        webView?.setBlockingEnabled(enabled)
+
+        statusBar!!.setBackgroundResource(if (enabled)
+                R.drawable.animated_background
+            else
+                R.drawable.animated_background_disabled
+        )
+
+        backgroundTransitionGroup = if (!session!!.isCustomTab) {
+            // Only update the toolbar background if this is not a custom tab. Custom tabs set their
+            // own color and we do not want to override this here.
+            urlBar!!.setBackgroundResource(if (enabled)
+                    R.drawable.animated_background
+                else
+                    R.drawable.animated_background_disabled)
+
+            TransitionDrawableGroup(
+                urlBar!!.background as TransitionDrawable,
+                statusBar!!.background as TransitionDrawable
+            )
+        } else {
+            TransitionDrawableGroup(
+                statusBar!!.background as TransitionDrawable
+            )
+        }
+    }
+
+    fun setShouldRequestDesktop(enabled: Boolean) {
+        if (enabled) {
+            PreferenceManager.getDefaultSharedPreferences(context).edit()
+                .putBoolean(
+                    context!!.getString(R.string.has_requested_desktop),
+                    true
+                ).apply()
+        }
+
+        getWebView()?.setRequestDesktop(enabled)
+    }
+
+    private fun showSecurityPopUp() {
+        // Don't show Security Popup if the page is loading
+        if (session!!.loading.value!!) {
+            return
+        }
+        val securityPopup = PopupUtils.createSecurityPopup(context!!, session!!)
+        if (securityPopup != null) {
+            securityPopup.setOnDismissListener { popupTint!!.visibility = View.GONE }
+            securityPopup.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
+            securityPopup.animationStyle = android.R.style.Animation_Dialog
+            securityPopup.isTouchable = true
+            securityPopup.isFocusable = true
+            securityPopup.elevation = resources.getDimension(R.dimen.menu_elevation)
+            val offsetY = context!!.resources.getDimensionPixelOffset(R.dimen.doorhanger_offsetY)
+            securityPopup.showAtLocation(urlBar, Gravity.TOP or Gravity.CENTER_HORIZONTAL, 0, offsetY)
+            popupTint!!.visibility = View.VISIBLE
+        }
+    }
+
+    // In the future, if more badging icons are needed, this should be abstracted
+    fun updateBlockingBadging(enabled: Boolean) {
+        blockView!!.visibility = if (enabled) View.GONE else View.VISIBLE
+    }
+
+    private fun dismissAutocompletePopup() {
+        autocompletePopupWeakReference.get()?.dismiss()
+        autocompletePopupWeakReference.clear()
+    }
+
+    override fun onLongClick(view: View): Boolean {
+        // Detect long clicks on display_url
+        if (view.id == R.id.display_url) {
+            val context = activity ?: return false
+
+            if (session!!.isCustomTab) {
+                val clipBoard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+                val uri = Uri.parse(url)
+                clipBoard.primaryClip = ClipData.newRawUri("Uri", uri)
+                Toast.makeText(context, getString(R.string.custom_tab_copy_url_action), Toast.LENGTH_SHORT).show()
+            }
+
+            val autocompletePopup = AutocompleteQuickAddPopup(context, urlView!!.text.toString())
+
+            // Show the Snackbar and dismiss the popup when a new URL is added.
+            autocompletePopup.onUrlAdded = fun(didAddSuccessfully: Boolean?) {
+                activity!!.runOnUiThread {
+                    val messageId =
+                        if (didAddSuccessfully!!)
+                            R.string.preference_autocomplete_add_confirmation
+                        else
+                            R.string.preference_autocomplete_duplicate_url_error
+                    ViewUtils.showBrandedSnackbar(Objects.requireNonNull<View>(getView()), messageId, 0)
+                    dismissAutocompletePopup()
+                }
+
+                return Unit
+            }
+
+            autocompletePopup.show(urlView!!)
+            autocompletePopupWeakReference = WeakReference(autocompletePopup)
+        }
+
+        return false
+    }
+
+    private fun showFindInPage() {
+        findInPageView!!.visibility = View.VISIBLE
+        findInPageQuery!!.requestFocus()
+
+        val params = swipeRefresh!!.layoutParams as CoordinatorLayout.LayoutParams
+        params.bottomMargin = findInPageViewHeight
+        swipeRefresh!!.layoutParams = params
+    }
+
+    private fun hideFindInPage() {
+        val webView = getWebView() ?: return
+
+        webView.clearMatches()
+        findInPageCoordinator.reset()
+        findInPageView!!.visibility = View.GONE
+        findInPageQuery!!.text = ""
+        findInPageQuery!!.clearFocus()
+
+        val params = swipeRefresh!!.layoutParams as CoordinatorLayout.LayoutParams
+        params.bottomMargin = 0
+        swipeRefresh!!.layoutParams = params
+        ViewUtils.hideKeyboard(findInPageQuery!!)
+    }
+
+    @Suppress("DEPRECATION", "MagicNumber")
+    private fun updateFindInPageResult(activeMatchOrdinal: Int, numberOfMatches: Int) {
+        var actualActiveMatchOrdinal = activeMatchOrdinal
+        val context = context ?: return
+
+        if (numberOfMatches > 0) {
+            findInPageNext!!.setColorFilter(resources.getColor(R.color.photonWhite))
+            findInPageNext!!.alpha = 1.0f
+            findInPagePrevious!!.setColorFilter(resources.getColor(R.color.photonWhite))
+            findInPagePrevious!!.alpha = 1.0f
+            // We don't want the presentation of the activeMatchOrdinal to be zero indexed. So let's
+            // increment it by one for WebView.
+            if (!AppConstants.isGeckoBuild) {
+                actualActiveMatchOrdinal++
+            }
+
+            val visibleString = String.format(
+                context.getString(R.string.find_in_page_result),
+                actualActiveMatchOrdinal,
+                numberOfMatches)
+
+            val accessibleString = String.format(
+                context.getString(R.string.find_in_page_result),
+                actualActiveMatchOrdinal,
+                numberOfMatches)
+
+            findInPageResultTextView!!.text = visibleString
+            findInPageResultTextView!!.contentDescription = accessibleString
+        } else {
+            findInPageNext!!.setColorFilter(resources.getColor(R.color.photonGrey10))
+            findInPageNext!!.alpha = 0.4f
+            findInPagePrevious!!.setColorFilter(resources.getColor(R.color.photonWhite))
+            findInPagePrevious!!.alpha = 0.4f
+            findInPageResultTextView!!.text = ""
+            findInPageResultTextView!!.contentDescription = ""
+        }
+    }
+
+    companion object {
+        const val FRAGMENT_TAG = "browser"
+
+        private const val REQUEST_CODE_STORAGE_PERMISSION = 101
+        private const val ANIMATION_DURATION = 300
+
+        private const val ARGUMENT_SESSION_UUID = "sessionUUID"
+        private const val RESTORE_KEY_DOWNLOAD = "download"
+
+        private const val INITIAL_PROGRESS = 5
+        private const val REQUEST_CODE_DOWNLOAD_DIALOG = 300
+        private const val REQUEST_CODE_ADD_TO_HOMESCREEN_DIALOG = 301
+        private const val REQUEST_CODE_BIOMETRIC_PROMPT = 302
+
+        fun createForSession(session: Session): BrowserFragment {
+            val arguments = Bundle()
+            arguments.putString(ARGUMENT_SESSION_UUID, session.uuid)
+
+            val fragment = BrowserFragment()
+            fragment.arguments = arguments
+
+            return fragment
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.java
deleted file mode 100644
index f9f88b4b0b21..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.fragment;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.webkit.WebView;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.locale.LocaleAwareFragment;
-import org.mozilla.focus.locale.LocaleManager;
-import org.mozilla.focus.session.Session;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.web.IWebView;
-
-import java.util.Locale;
-
-/**
- * Base implementation for fragments that use an IWebView instance. Based on Android's WebViewFragment.
- */
-public abstract class WebFragment extends LocaleAwareFragment {
-    private IWebView webView;
-    private boolean isWebViewAvailable;
-
-    /**
-     * Inflate a layout for this fragment. The layout needs to contain a view implementing IWebView
-     * with the id set to "webview".
-     */
-    @NonNull
-    public abstract View inflateLayout(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState);
-
-    public abstract IWebView.Callback createCallback();
-
-    public abstract Session getSession();
-
-    /**
-     * Get the initial URL to load after the view has been created.
-     */
-    @Nullable
-    public abstract String getInitialUrl();
-
-    /**
-     * Adds ability to add methods to onCreateView without override because onCreateView is final.
-     */
-    public abstract void onCreateViewCalled();
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
-        final View view = inflateLayout(inflater, container, savedInstanceState);
-
-        webView = view.findViewById(R.id.webview);
-        isWebViewAvailable = true;
-        webView.setCallback(createCallback());
-
-        final Session session = getSession();
-
-        if (session != null) {
-            webView.setBlockingEnabled(session.isBlockingEnabled());
-            webView.setRequestDesktop(session.shouldRequestDesktopSite());
-        }
-
-        if (session == null || !session.hasWebViewState()) {
-            final String url = getInitialUrl();
-            if (!TextUtils.isEmpty(url)) {
-                webView.loadUrl(url);
-            }
-        } else if (!(AppConstants.INSTANCE.isGeckoBuild())) {
-            webView.restoreWebViewState(session);
-        }
-
-        onCreateViewCalled();
-        return view;
-    }
-
-    @Override
-    public void applyLocale() {
-        Context context = getContext();
-        final LocaleManager localeManager = LocaleManager.getInstance();
-        if (!localeManager.isMirroringSystemLocale(context)) {
-            final Locale currentLocale = localeManager.getCurrentLocale(context);
-            Locale.setDefault(currentLocale);
-            final Resources resources = context.getResources();
-            final Configuration config = resources.getConfiguration();
-            config.setLocale(currentLocale);
-            context.getResources().updateConfiguration(config, null);
-        }
-        // We create and destroy a new WebView here to force the internal state of WebView to know
-        // about the new language. See issue #666.
-        final WebView unneeded = new WebView(getContext());
-        unneeded.destroy();
-    }
-
-    @Override
-    public void onPause() {
-        final Session session = getSession();
-        if (session != null) {
-            webView.saveWebViewState(session);
-        }
-
-        webView.onPause();
-
-        super.onPause();
-    }
-
-    @Override
-    public void onResume() {
-        webView.onResume();
-
-        super.onResume();
-    }
-
-    @Override
-    public void onDestroy() {
-        if (webView != null) {
-            webView.setCallback(null);
-            webView.destroy();
-            webView = null;
-        }
-
-        super.onDestroy();
-    }
-
-    @Override
-    public void onDestroyView() {
-        isWebViewAvailable = false;
-
-        super.onDestroyView();
-    }
-
-    @Nullable
-    protected IWebView getWebView() {
-        return isWebViewAvailable ? webView : null;
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt
new file mode 100644
index 000000000000..8dddd7f9bd7f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt
@@ -0,0 +1,135 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.fragment
+
+import android.os.Bundle
+import android.text.TextUtils
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.webkit.WebView
+
+import org.mozilla.focus.R
+import org.mozilla.focus.locale.LocaleAwareFragment
+import org.mozilla.focus.locale.LocaleManager
+import org.mozilla.focus.session.Session
+import org.mozilla.focus.utils.AppConstants
+import org.mozilla.focus.web.IWebView
+
+import java.util.Locale
+
+/**
+ * Base implementation for fragments that use an IWebView instance. Based on Android's WebViewFragment.
+ */
+abstract class WebFragment : LocaleAwareFragment() {
+    private var webViewInstance: IWebView? = null
+    private var isWebViewAvailable: Boolean = false
+
+    abstract val session: Session?
+
+    /**
+     * Get the initial URL to load after the view has been created.
+     */
+    abstract val initialUrl: String?
+
+    /**
+     * Inflate a layout for this fragment. The layout needs to contain a view implementing IWebView
+     * with the id set to "webview".
+     */
+    abstract fun inflateLayout(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View
+
+    abstract fun createCallback(): IWebView.Callback
+
+    /**
+     * Adds ability to add methods to onCreateView without override because onCreateView is final.
+     */
+    abstract fun onCreateViewCalled()
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        val view = inflateLayout(inflater, container, savedInstanceState)
+
+        val actualWebView = view.findViewById<View>(R.id.webview)
+        webViewInstance = actualWebView as IWebView
+
+        isWebViewAvailable = true
+        webViewInstance!!.setCallback(createCallback())
+
+        val session = session
+
+        if (session != null) {
+            webViewInstance!!.setBlockingEnabled(session.isBlockingEnabled)
+            webViewInstance!!.setRequestDesktop(session.shouldRequestDesktopSite())
+        }
+
+        if (session == null || !session.hasWebViewState()) {
+            val url = initialUrl
+            if (!TextUtils.isEmpty(url)) {
+                webViewInstance!!.loadUrl(url)
+            }
+        } else if (!AppConstants.isGeckoBuild) {
+            webViewInstance!!.restoreWebViewState(session)
+        }
+
+        onCreateViewCalled()
+        return view
+    }
+
+    override fun applyLocale() {
+        val context = context ?: return
+        val localeManager = LocaleManager.getInstance()
+        if (!localeManager.isMirroringSystemLocale(context)) {
+            val currentLocale = localeManager.getCurrentLocale(context)
+            Locale.setDefault(currentLocale)
+            val resources = context.resources
+            val config = resources.configuration
+            config.setLocale(currentLocale)
+
+            @Suppress("DEPRECATION")
+            context.resources.updateConfiguration(config, null)
+        }
+        // We create and destroy a new WebView here to force the internal state of WebView to know
+        // about the new language. See issue #666.
+        val unneeded = WebView(getContext())
+        unneeded.destroy()
+    }
+
+    override fun onPause() {
+        val session = session
+        if (session != null) {
+            webViewInstance!!.saveWebViewState(session)
+        }
+
+        webViewInstance!!.onPause()
+
+        super.onPause()
+    }
+
+    override fun onResume() {
+        webViewInstance!!.onResume()
+
+        super.onResume()
+    }
+
+    override fun onDestroy() {
+        if (webViewInstance != null) {
+            webViewInstance!!.setCallback(null)
+            webViewInstance!!.destroy()
+            webViewInstance = null
+        }
+
+        super.onDestroy()
+    }
+
+    override fun onDestroyView() {
+        isWebViewAvailable = false
+
+        super.onDestroyView()
+    }
+
+    protected fun getWebView(): IWebView? {
+        return if (isWebViewAvailable) webViewInstance else null
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.java b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.java
deleted file mode 100644
index b40b900cdc3f..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session.ui;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.graphics.drawable.Drawable;
-import android.support.v7.content.res.AppCompatResources;
-import android.support.v7.widget.RecyclerView;
-import android.view.View;
-import android.widget.TextView;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.session.SessionManager;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-
-public class EraseViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {
-    public static final int LAYOUT_ID = R.layout.item_erase;
-
-    private final SessionsSheetFragment fragment;
-
-    public EraseViewHolder(final SessionsSheetFragment fragment, View itemView) {
-        super(itemView);
-
-        this.fragment = fragment;
-
-        final TextView textView = (TextView) itemView;
-        final Drawable leftDrawable = AppCompatResources.getDrawable(itemView.getContext(), R.drawable.ic_delete);
-        textView.setCompoundDrawablesWithIntrinsicBounds(leftDrawable, null, null, null);
-        textView.setOnClickListener(this);
-    }
-
-    @Override
-    public void onClick(View view) {
-        TelemetryWrapper.eraseInTabsTrayEvent();
-
-        fragment.animateAndDismiss().addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                SessionManager.getInstance().removeAllSessions();
-            }
-        });
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt
new file mode 100644
index 000000000000..8b8d76d6ce3f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt
@@ -0,0 +1,41 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session.ui
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.support.v7.content.res.AppCompatResources
+import android.support.v7.widget.RecyclerView
+import android.view.View
+import android.widget.TextView
+import org.mozilla.focus.R
+import org.mozilla.focus.session.SessionManager
+import org.mozilla.focus.telemetry.TelemetryWrapper
+
+class EraseViewHolder(private val fragment: SessionsSheetFragment, itemView: View) : RecyclerView.ViewHolder(itemView),
+    View.OnClickListener {
+
+    init {
+
+        val textView = itemView as TextView
+        val leftDrawable = AppCompatResources.getDrawable(itemView.getContext(), R.drawable.ic_delete)
+        textView.setCompoundDrawablesWithIntrinsicBounds(leftDrawable, null, null, null)
+        textView.setOnClickListener(this)
+    }
+
+    override fun onClick(view: View) {
+        TelemetryWrapper.eraseInTabsTrayEvent()
+
+        fragment.animateAndDismiss().addListener(object : AnimatorListenerAdapter() {
+            override fun onAnimationEnd(animation: Animator) {
+                SessionManager.getInstance().removeAllSessions()
+            }
+        })
+    }
+
+    companion object {
+        const val LAYOUT_ID = R.layout.item_erase
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.java
deleted file mode 100644
index 6f80463a93f2..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session.ui;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.os.Bundle;
-import android.support.annotation.Nullable;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewAnimationUtils;
-import android.view.ViewGroup;
-import android.view.animation.AccelerateInterpolator;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.activity.MainActivity;
-import org.mozilla.focus.locale.LocaleAwareFragment;
-import org.mozilla.focus.session.SessionManager;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.OneShotOnPreDrawListener;
-
-public class SessionsSheetFragment extends LocaleAwareFragment implements View.OnClickListener {
-    public static final String FRAGMENT_TAG = "tab_sheet";
-
-    private static final int ANIMATION_DURATION = 200;
-
-    private View backgroundView;
-    private View cardView;
-    private boolean isAnimating;
-
-    @Nullable
-    @Override
-    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
-        final View view = inflater.inflate(R.layout.fragment_sessionssheet, container, false);
-
-        backgroundView = view.findViewById(R.id.background);
-        backgroundView.setOnClickListener(this);
-
-        cardView = view.findViewById(R.id.card);
-        cardView.getViewTreeObserver().addOnPreDrawListener(new OneShotOnPreDrawListener(cardView) {
-            @Override
-            protected void onPreDraw(View view) {
-                playAnimation(false);
-            }
-        });
-
-        final SessionsAdapter sessionsAdapter = new SessionsAdapter(this);
-        SessionManager.getInstance().getSessions().observe(this, sessionsAdapter);
-
-        final RecyclerView sessionView = view.findViewById(R.id.sessions);
-        sessionView.setLayoutManager(new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false));
-        sessionView.setAdapter(sessionsAdapter);
-
-        return view;
-    }
-
-    private Animator playAnimation(final boolean reverse) {
-        isAnimating = true;
-
-        final int offset = getResources().getDimensionPixelSize(R.dimen.floating_action_button_size) / 2;
-        final int cx = cardView.getMeasuredWidth() - offset;
-        final int cy = cardView.getMeasuredHeight() - offset;
-
-        // The final radius is the diagonal of the card view -> sqrt(w^2 + h^2)
-        final float fullRadius = (float) Math.sqrt(
-                Math.pow(cardView.getWidth(), 2) + Math.pow(cardView.getHeight(), 2));
-
-        final Animator sheetAnimator = ViewAnimationUtils.createCircularReveal(
-                cardView, cx, cy, reverse ? fullRadius : 0, reverse ? 0 : fullRadius);
-        sheetAnimator.setDuration(ANIMATION_DURATION);
-        sheetAnimator.setInterpolator(new AccelerateInterpolator());
-        sheetAnimator.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                cardView.setVisibility(View.VISIBLE);
-            }
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                isAnimating = false;
-
-                cardView.setVisibility(reverse ? View.GONE : View.VISIBLE);
-            }
-        });
-        sheetAnimator.start();
-
-        backgroundView.setAlpha(reverse ? 1f : 0f);
-        backgroundView.animate()
-                .alpha(reverse ? 0f : 1f)
-                .setDuration(ANIMATION_DURATION)
-                .start();
-
-        return sheetAnimator;
-    }
-
-    /* package */ Animator animateAndDismiss() {
-        final Animator animator = playAnimation(true);
-
-        animator.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                final MainActivity activity = (MainActivity) getActivity();
-                if (activity != null) {
-                    activity.getSupportFragmentManager()
-                            .beginTransaction()
-                            .remove(SessionsSheetFragment.this)
-                            .commit();
-                }
-            }
-        });
-
-        return animator;
-    }
-
-    public boolean onBackPressed() {
-        animateAndDismiss();
-
-        TelemetryWrapper.closeTabsTrayEvent();
-        return true;
-    }
-
-    @Override
-    public void applyLocale() {}
-
-    @Override
-    public void onClick(View view) {
-        if (isAnimating) {
-            // Ignore touched while we are animating
-            return;
-        }
-
-        switch (view.getId()) {
-            case R.id.background:
-                animateAndDismiss();
-
-                TelemetryWrapper.closeTabsTrayEvent();
-                break;
-
-            default:
-                throw new IllegalStateException("Unhandled view in onClick()");
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.kt
new file mode 100644
index 000000000000..c21381d8c5e5
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsSheetFragment.kt
@@ -0,0 +1,140 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session.ui
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.os.Bundle
+import android.support.v7.widget.LinearLayoutManager
+import android.support.v7.widget.RecyclerView
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewAnimationUtils
+import android.view.ViewGroup
+import android.view.animation.AccelerateInterpolator
+
+import org.mozilla.focus.R
+import org.mozilla.focus.activity.MainActivity
+import org.mozilla.focus.locale.LocaleAwareFragment
+import org.mozilla.focus.session.SessionManager
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.utils.OneShotOnPreDrawListener
+
+class SessionsSheetFragment : LocaleAwareFragment(), View.OnClickListener {
+
+    private lateinit var backgroundView: View
+    private lateinit var cardView: View
+    private var isAnimating: Boolean = false
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        val view = inflater.inflate(R.layout.fragment_sessionssheet, container, false)
+
+        backgroundView = view.findViewById(R.id.background)
+        backgroundView.setOnClickListener(this)
+
+        cardView = view.findViewById(R.id.card)
+        cardView.viewTreeObserver.addOnPreDrawListener(object : OneShotOnPreDrawListener(cardView) {
+            override fun onPreDraw(view: View) {
+                playAnimation(false)
+            }
+        })
+
+        val sessionsAdapter = SessionsAdapter(this)
+        SessionManager.getInstance().sessions.observe(this, sessionsAdapter)
+
+        view.findViewById<RecyclerView>(R.id.sessions).let {
+            it.layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false)
+            it.adapter = sessionsAdapter
+        }
+
+        return view
+    }
+
+    @Suppress("ComplexMethod")
+    private fun playAnimation(reverse: Boolean): Animator {
+        isAnimating = true
+
+        val offset = resources.getDimensionPixelSize(R.dimen.floating_action_button_size) / 2
+        val cx = cardView.measuredWidth - offset
+        val cy = cardView.measuredHeight - offset
+
+        // The final radius is the diagonal of the card view -> sqrt(w^2 + h^2)
+        val fullRadius = Math.sqrt(
+            Math.pow(cardView.width.toDouble(), 2.0) + Math.pow(cardView.height.toDouble(), 2.0)
+        ).toFloat()
+
+        val sheetAnimator = ViewAnimationUtils.createCircularReveal(
+            cardView, cx, cy, if (reverse) fullRadius else 0f, if (reverse) 0f else fullRadius
+        ).apply {
+            duration = ANIMATION_DURATION.toLong()
+            interpolator = AccelerateInterpolator()
+            addListener(object : AnimatorListenerAdapter() {
+                override fun onAnimationStart(animation: Animator) {
+                    cardView.visibility = View.VISIBLE
+                }
+
+                override fun onAnimationEnd(animation: Animator) {
+                    isAnimating = false
+
+                    cardView.visibility = if (reverse) View.GONE else View.VISIBLE
+                }
+            })
+            start()
+        }
+
+        backgroundView.alpha = if (reverse) 1f else 0f
+        backgroundView.animate()
+            .alpha(if (reverse) 0f else 1f)
+            .setDuration(ANIMATION_DURATION.toLong())
+            .start()
+
+        return sheetAnimator
+    }
+
+    internal fun animateAndDismiss(): Animator {
+        val animator = playAnimation(true)
+
+        animator.addListener(object : AnimatorListenerAdapter() {
+            override fun onAnimationEnd(animation: Animator) {
+                val activity = activity as MainActivity?
+                activity?.supportFragmentManager?.beginTransaction()?.remove(this@SessionsSheetFragment)?.commit()
+            }
+        })
+
+        return animator
+    }
+
+    fun onBackPressed(): Boolean {
+        animateAndDismiss()
+
+        TelemetryWrapper.closeTabsTrayEvent()
+        return true
+    }
+
+    override fun applyLocale() {}
+
+    override fun onClick(view: View) {
+        if (isAnimating) {
+            // Ignore touched while we are animating
+            return
+        }
+
+        when (view.id) {
+            R.id.background -> {
+                animateAndDismiss()
+
+                TelemetryWrapper.closeTabsTrayEvent()
+            }
+
+            else -> throw IllegalStateException("Unhandled view in onClick()")
+        }
+    }
+
+    companion object {
+        const val FRAGMENT_TAG = "tab_sheet"
+
+        private const val ANIMATION_DURATION = 200
+    }
+}
