diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/EraseBrowsingDataTest.kt b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/EraseBrowsingDataTest.kt
index 24f494402e11..ae527959d669 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/EraseBrowsingDataTest.kt
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/EraseBrowsingDataTest.kt
@@ -66,6 +66,11 @@ class EraseBrowsingDataTest {
         } catch (e: IOException) {
             throw AssertionError("Could not start web server", e)
         }
+
+        notificationTray {
+            mDevice.openNotification()
+            clearNotifications()
+        }
     }
 
     @After
@@ -111,23 +116,6 @@ class EraseBrowsingDataTest {
         }
     }
 
-    @Test
-    fun notificationOpenButtonTest() {
-        // Open a webpage
-        searchScreen {
-        }.loadPage(webServer.url("").toString()) { }
-        // Send app to background
-        pressHomeKey()
-        // Pull down system bar and select Open
-        mDevice.openNotification()
-        notificationTray {
-            verifySystemNotificationExists(getStringResource(R.string.notification_erase_text))
-            expandEraseBrowsingNotification()
-        }.clickNotificationOpenButton {
-            verifyBrowserView()
-        }
-    }
-
     @Test
     fun deleteHistoryOnRestartTest() {
         searchScreen {
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.kt b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.kt
index 8f140920ee6b..5ea33cb1c253 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.kt
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.kt
@@ -1,5 +1,4 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
+/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 package org.mozilla.focus.activity
@@ -7,36 +6,33 @@ package org.mozilla.focus.activity
 import androidx.test.internal.runner.junit4.AndroidJUnit4ClassRunner
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.By
-import androidx.test.uiautomator.UiObjectNotFoundException
 import androidx.test.uiautomator.UiSelector
 import androidx.test.uiautomator.Until
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
 import org.hamcrest.core.IsNull
 import org.junit.After
-import org.junit.Assert
+import org.junit.Assert.assertThat
+import org.junit.Assert.assertTrue
 import org.junit.Before
-import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
+import org.mozilla.focus.R
+import org.mozilla.focus.activity.robots.notificationTray
+import org.mozilla.focus.activity.robots.searchScreen
 import org.mozilla.focus.helpers.MainActivityFirstrunTestRule
-import org.mozilla.focus.helpers.TestHelper
-import org.mozilla.focus.helpers.TestHelper.expandNotification
-import org.mozilla.focus.helpers.TestHelper.openNotification
-import org.mozilla.focus.helpers.TestHelper.pressEnterKey
+import org.mozilla.focus.helpers.TestHelper.getStringResource
+import org.mozilla.focus.helpers.TestHelper.mDevice
 import org.mozilla.focus.helpers.TestHelper.pressHomeKey
 import org.mozilla.focus.helpers.TestHelper.readTestAsset
-import org.mozilla.focus.helpers.TestHelper.waitForIdle
-import org.mozilla.focus.helpers.TestHelper.waitForWebSiteTitleLoad
 import org.mozilla.focus.helpers.TestHelper.waitingTime
 import java.io.IOException
 
-// This test opens enters and invalid URL, and Focus should provide an appropriate error message
+// This test switches out of Focus and opens it from the private browsing notification
 @RunWith(AndroidJUnit4ClassRunner::class)
-@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 class SwitchContextTest {
-    private var webServer: MockWebServer? = null
+    private lateinit var webServer: MockWebServer
 
     @get: Rule
     var mActivityTestRule = MainActivityFirstrunTestRule(showFirstRun = false)
@@ -45,7 +41,7 @@ class SwitchContextTest {
     fun setUp() {
         webServer = MockWebServer()
         try {
-            webServer!!.enqueue(
+            webServer.enqueue(
                 MockResponse()
                     .setBody(readTestAsset("image_test.html"))
                     .addHeader(
@@ -53,151 +49,93 @@ class SwitchContextTest {
                         "sphere=battery; Expires=Wed, 21 Oct 2035 07:28:00 GMT;"
                     )
             )
-            webServer!!.enqueue(
+            webServer.enqueue(
                 MockResponse()
                     .setBody(readTestAsset("rabbit.jpg"))
             )
-            webServer!!.enqueue(
+            webServer.enqueue(
                 MockResponse()
                     .setBody(readTestAsset("download.jpg"))
             )
-            webServer!!.start()
+            webServer.start()
         } catch (e: IOException) {
             throw AssertionError("Could not start web server", e)
         }
+
+        notificationTray {
+            mDevice.openNotification()
+            clearNotifications()
+        }
     }
 
     @After
     fun tearDown() {
-        mActivityTestRule.activity.finishAndRemoveTask()
         try {
-            webServer!!.close()
-            webServer!!.shutdown()
+            webServer.close()
+            webServer.shutdown()
         } catch (e: IOException) {
             throw AssertionError("Could not stop web server", e)
         }
     }
 
     @Test
-    @Throws(UiObjectNotFoundException::class)
-    fun ForegroundTest() {
-
-        // Open a webpage
-        TestHelper.inlineAutocompleteEditText.waitForExists(waitingTime)
-        Assert.assertTrue(TestHelper.inlineAutocompleteEditText.exists())
-        TestHelper.inlineAutocompleteEditText.clearTextField()
-        TestHelper.inlineAutocompleteEditText.text =
-            webServer!!.url(TEST_PATH).toString()
-        TestHelper.hint.waitForExists(waitingTime)
-        pressEnterKey()
-
-        // Assert website is loaded
-        waitForWebSiteTitleLoad()
-
-        // Switch out of Focus, pull down system bar and select open action
-        pressHomeKey()
-        openNotification()
-        waitForIdle()
-        // If simulator has more recent message, the options need to be expanded
-        expandNotification()
-        TestHelper.notificationOpenItem.click()
-
-        // Verify that it's on the main view, showing the previous browsing session
-        TestHelper.browserURLbar.waitForExists(waitingTime)
-        Assert.assertTrue(TestHelper.browserURLbar.exists())
-        waitForWebSiteTitleLoad()
-    }
-
-    @Test
-    @Throws(UiObjectNotFoundException::class)
-    fun eraseAndOpenTest() {
-
+    fun notificationOpenButtonTest() {
         // Open a webpage
-        TestHelper.inlineAutocompleteEditText.waitForExists(waitingTime)
-        Assert.assertTrue(TestHelper.inlineAutocompleteEditText.exists())
-        TestHelper.inlineAutocompleteEditText.clearTextField()
-        TestHelper.inlineAutocompleteEditText.text =
-            webServer!!.url(TEST_PATH).toString()
-        TestHelper.hint.waitForExists(waitingTime)
-        pressEnterKey()
-
-        // Assert website is loaded
-        waitForWebSiteTitleLoad()
-
-        // Switch out of Focus, pull down system bar and select open action
+        searchScreen {
+        }.loadPage(webServer.url("").toString()) { }
+        // Send app to background
         pressHomeKey()
-        openNotification()
-
-        // If simulator has more recent message, the options need to be expanded
-        expandNotification()
-        TestHelper.notificationEraseOpenItem.click()
-
-        // Verify that it's on the main view, showing the initial view
-        TestHelper.erasedMsg.waitForExists(waitingTime)
-        Assert.assertTrue(TestHelper.erasedMsg.exists())
-        Assert.assertTrue(TestHelper.inlineAutocompleteEditText.exists())
-        Assert.assertTrue(TestHelper.initialView.exists())
+        // Pull down system bar and select Open
+        mDevice.openNotification()
+        notificationTray {
+            verifySystemNotificationExists(getStringResource(R.string.notification_erase_text))
+            expandEraseBrowsingNotification()
+        }.clickNotificationOpenButton {
+            verifyBrowserView()
+        }
     }
 
-    @Suppress("LongMethod")
     @Test
-    @Throws(UiObjectNotFoundException::class)
-    fun settingsToFocus() {
-
+    fun switchFromSettingsToFocusTest() {
         // Initialize UiDevice instance
         val LAUNCH_TIMEOUT = 5000
         val SETTINGS_APP = "com.android.settings"
-        val settings = TestHelper.mDevice.findObject(
+        val settingsApp = mDevice.findObject(
             UiSelector()
                 .packageName(SETTINGS_APP)
                 .enabled(true)
         )
+        val launcherPackage = mDevice.launcherPackageName
+        val context = InstrumentationRegistry.getInstrumentation().targetContext.applicationContext
+        val intent = context.packageManager
+            .getLaunchIntentForPackage(SETTINGS_APP)
 
         // Open a webpage
-        TestHelper.inlineAutocompleteEditText.waitForExists(waitingTime)
-        TestHelper.inlineAutocompleteEditText.clearTextField()
-        TestHelper.inlineAutocompleteEditText.text = webServer!!.url(TEST_PATH).toString()
-        TestHelper.hint.waitForExists(waitingTime)
-        pressEnterKey()
-
-        // Assert website is loaded
-        waitForWebSiteTitleLoad()
+        searchScreen {
+        }.loadPage(webServer.url("").toString()) { }
 
         // Switch out of Focus, open settings app
         pressHomeKey()
 
         // Wait for launcher
-        val launcherPackage = TestHelper.mDevice.launcherPackageName
-        Assert.assertThat(launcherPackage, IsNull.notNullValue())
-        TestHelper.mDevice.wait(
+        assertThat(launcherPackage, IsNull.notNullValue())
+        mDevice.wait(
             Until.hasObject(By.pkg(launcherPackage).depth(0)),
             LAUNCH_TIMEOUT.toLong()
         )
 
         // Launch the app
-        val context = InstrumentationRegistry.getInstrumentation()
-            .targetContext
-            .applicationContext
-        val intent = context.packageManager
-            .getLaunchIntentForPackage(SETTINGS_APP)
         context.startActivity(intent)
+        settingsApp.waitForExists(waitingTime)
+        assertTrue(settingsApp.exists())
 
         // switch to Focus
-        settings.waitForExists(waitingTime)
-        Assert.assertTrue(settings.exists())
-        openNotification()
-
-        // If simulator has more recent message, the options need to be expanded
-        expandNotification()
-        TestHelper.notificationOpenItem.click()
-
-        // Verify that it's on the main view, showing the previous browsing session
-        TestHelper.browserURLbar.waitForExists(waitingTime)
-        Assert.assertTrue(TestHelper.browserURLbar.exists())
-        waitForWebSiteTitleLoad()
-    }
-
-    companion object {
-        private const val TEST_PATH = "/"
+        mDevice.openNotification()
+        notificationTray {
+            verifySystemNotificationExists(getStringResource(R.string.notification_erase_text))
+            expandEraseBrowsingNotification()
+        }.clickNotificationOpenButton {
+            verifyBrowserView()
+        }
     }
 }
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/robots/NotificationRobot.kt b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/robots/NotificationRobot.kt
index e97025483e11..8df2a5a56b49 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/robots/NotificationRobot.kt
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/robots/NotificationRobot.kt
@@ -1,70 +1,70 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
 package org.mozilla.focus.activity.robots
 
 import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.UiObjectNotFoundException
 import androidx.test.uiautomator.UiScrollable
 import androidx.test.uiautomator.UiSelector
 import org.junit.Assert.assertTrue
 import org.mozilla.focus.R
 import org.mozilla.focus.helpers.TestHelper
+import org.mozilla.focus.helpers.TestHelper.getStringResource
 import org.mozilla.focus.helpers.TestHelper.mDevice
 import org.mozilla.focus.helpers.TestHelper.waitingTime
 
 class NotificationRobot {
 
+    fun clearNotifications() {
+        if (clearButton.exists()) {
+            clearButton.click()
+        } else {
+            notificationTray.flingToEnd(3)
+            if (clearButton.exists()) {
+                clearButton.click()
+            } else if (notificationTray.exists()) {
+                mDevice.pressBack()
+            }
+        }
+    }
+
     fun expandEraseBrowsingNotification() {
         val PINCH_PERCENT = 50
         val PINCH_STEPS = 5
 
-        val notificationExpandSwitch = mDevice.findObject(
-            UiSelector()
-                .resourceId("android:id/expand_button")
-                .textContains("Firefox Focus")
-        )
         if (!notificationEraseAndOpenButton.waitForExists(waitingTime)) {
-            if (!notificationExpandSwitch.exists()) {
+            if (!notificationTray.ensureFullyVisible(notificationHeader)) {
                 eraseBrowsingNotification.pinchOut(
                     PINCH_PERCENT,
                     PINCH_STEPS
                 )
             } else {
-                notificationExpandSwitch.click()
+                notificationHeader.click()
             }
+            notificationTray.ensureFullyVisible(notificationEraseAndOpenButton)
             assertTrue(notificationEraseAndOpenButton.exists())
         }
     }
 
     fun verifySystemNotificationExists(notificationMessage: String) {
-        var notificationTray =
-            mDevice.findObject(
-                UiSelector().resourceId("com.android.systemui:id/notification_stack_scroller")
-            )
-
-        if (notificationTray.isScrollable) {
-            notificationTray = UiScrollable(
-                UiSelector().resourceId("com.android.systemui:id/notification_stack_scroller")
-            )
-
-            var notificationFound = false
-
-            do {
-                try {
-                    notificationFound = notificationTray.getChildByText(
-                        UiSelector().text(notificationMessage), notificationMessage, true
-                    ).waitForExists(TestHelper.waitingTime)
-                    assertTrue(notificationFound)
-                } catch (e: UiObjectNotFoundException) {
-                    Log.d("TestLog", e.message.toString())
-                    // scrolls down the notifications until it reaches the end, then it will close
-                    notificationTray.scrollForward()
-                    mDevice.waitForIdle()
-                }
-            } while (!notificationFound)
-        } else {
-            val notificationFound =
-                notificationTray.getChild(UiSelector().textContains(notificationMessage)).exists()
-            assertTrue(notificationFound)
-        }
+        var notificationFound = false
+
+        do {
+            try {
+                notificationFound = notificationTray.getChildByText(
+                    UiSelector().text(notificationMessage), notificationMessage, true
+                ).waitForExists(waitingTime)
+                assertTrue(notificationFound)
+            } catch (e: UiObjectNotFoundException) {
+                Log.d("TestLog", e.message.toString())
+                // scrolls down the notifications until it reaches the end, then it will close
+                notificationTray.scrollForward()
+                mDevice.waitForIdle()
+            }
+        } while (!notificationFound)
     }
 
     class Transition {
@@ -93,14 +93,28 @@ fun notificationTray(interact: NotificationRobot.() -> Unit): NotificationRobot.
 
 private val eraseBrowsingNotification =
     mDevice.findObject(
-        UiSelector().text(TestHelper.getStringResource(R.string.notification_erase_text))
+        UiSelector().text(getStringResource(R.string.notification_erase_text))
     )
 
 private val notificationEraseAndOpenButton =
     mDevice.findObject(
-        UiSelector().description(TestHelper.getStringResource(R.string.notification_action_erase_and_open))
+        UiSelector().description(getStringResource(R.string.notification_action_erase_and_open))
     )
 
 private val notificationOpenButton = mDevice.findObject(
-    UiSelector().description(TestHelper.getStringResource(R.string.notification_action_open))
+    UiSelector().description(getStringResource(R.string.notification_action_open))
 )
+
+private val notificationTray = UiScrollable(
+    UiSelector().resourceId("com.android.systemui:id/notification_stack_scroller")
+).setAsVerticalList()
+
+private val appName = InstrumentationRegistry.getInstrumentation().targetContext.getString(R.string.app_name)
+
+private val notificationHeader = mDevice.findObject(
+    UiSelector()
+        .resourceId("android:id/app_name_text")
+        .textContains(appName)
+)
+
+private val clearButton = mDevice.findObject(UiSelector().resourceId("com.android.systemui:id/dismiss_text"))
