diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
index 9d7d0e1a5bb4..131a94f44eb8 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.java
@@ -75,6 +75,7 @@
 import org.mozilla.focus.session.Source;
 import org.mozilla.focus.session.ui.SessionsSheetFragment;
 import org.mozilla.focus.telemetry.TelemetryWrapper;
+import org.mozilla.focus.utils.AppConstants;
 import org.mozilla.focus.utils.Browsers;
 import org.mozilla.focus.utils.Features;
 import org.mozilla.focus.utils.StatusBarUtils;
@@ -1387,13 +1388,15 @@ private void updateFindInPageResult(Integer activeMatchOrdinal, Integer numberOf
         }
 
         if (numberOfMatches > 0) {
-            // We don't want the presentation of the activeMatchOrdinal to be zero indexed. So let's
-            // increment it by one.
             findInPageNext.setColorFilter(getResources().getColor(R.color.photonWhite));
             findInPageNext.setAlpha(1.0F);
             findInPagePrevious.setColorFilter(getResources().getColor(R.color.photonWhite));
             findInPagePrevious.setAlpha(1.0F);
-            activeMatchOrdinal++;
+            // We don't want the presentation of the activeMatchOrdinal to be zero indexed. So let's
+            // increment it by one for WebView.
+            if (!AppConstants.isGeckoBuild(context)) {
+                activeMatchOrdinal++;
+            }
             final String visibleString = String.format(context.getString(R.string.find_in_page_result), activeMatchOrdinal, numberOfMatches);
             final String accessibleString = String.format(context.getString(R.string.find_in_page_result), activeMatchOrdinal, numberOfMatches);
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.java b/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.java
deleted file mode 100644
index a690ff597444..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.java
+++ /dev/null
@@ -1,619 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Environment;
-import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.View;
-import android.webkit.WebSettings;
-
-import org.jetbrains.annotations.NotNull;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.mozilla.focus.browser.LocalizedContent;
-import org.mozilla.focus.gecko.GeckoViewPrompt;
-import org.mozilla.focus.gecko.NestedGeckoView;
-import org.mozilla.focus.session.Session;
-import org.mozilla.focus.telemetry.SentryWrapper;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.utils.IntentUtils;
-import org.mozilla.focus.utils.Settings;
-import org.mozilla.focus.utils.UrlUtils;
-import org.mozilla.focus.webview.SystemWebView;
-import org.mozilla.gecko.util.GeckoBundle;
-import org.mozilla.gecko.util.ThreadUtils;
-import org.mozilla.geckoview.GeckoResponse;
-import org.mozilla.geckoview.GeckoRuntime;
-import org.mozilla.geckoview.GeckoRuntimeSettings;
-import org.mozilla.geckoview.GeckoSession;
-import org.mozilla.geckoview.GeckoSessionSettings;
-
-import java.util.concurrent.CountDownLatch;
-
-import kotlin.text.Charsets;
-
-/**
- * WebViewProvider implementation for creating a Gecko based implementation of IWebView.
- */
-public class GeckoWebViewProvider implements IWebViewProvider {
-    private static volatile GeckoRuntime geckoRuntime;
-
-    public void preload(@NonNull final Context context) {
-        createGeckoRuntimeIfNeeded(context);
-    }
-
-    @NonNull
-    public View create(@NonNull Context context, AttributeSet attrs) {
-        return new GeckoWebView(context, attrs);
-    }
-
-    public void performCleanup(@NonNull final Context context) {
-        // Nothing: does Gecko need extra private mode cleanup?
-    }
-
-    public void performNewBrowserSessionCleanup() {
-        // Nothing: a WebKit work-around.
-    }
-
-    private void createGeckoRuntimeIfNeeded(Context context) {
-        if (geckoRuntime == null) {
-            final GeckoRuntimeSettings.Builder runtimeSettingsBuilder =
-                    new GeckoRuntimeSettings.Builder();
-            runtimeSettingsBuilder.useContentProcessHint(true);
-            runtimeSettingsBuilder.nativeCrashReportingEnabled(true);
-            geckoRuntime = GeckoRuntime.create(context.getApplicationContext(), runtimeSettingsBuilder.build());
-        }
-    }
-
-    @Override
-    public void requestMobileSite(@NotNull Context context, @NotNull WebSettings webSettings) {
-
-    }
-
-    @Override
-    public void requestDesktopSite(@NotNull WebSettings webSettings) {
-
-    }
-
-    @Override
-    public void applyAppSettings(@NotNull Context context, @NotNull WebSettings webSettings, @NotNull SystemWebView systemWebView) {
-
-    }
-
-    @Override
-    public void disableBlocking(@NotNull WebSettings webSettings, @NotNull SystemWebView systemWebView) {
-
-    }
-
-    @Override
-    public String getUABrowserString(@NotNull String existingUAString, @NotNull String focusToken) {
-        return null;
-    }
-
-    public static class GeckoWebView extends NestedGeckoView implements IWebView, SharedPreferences.OnSharedPreferenceChangeListener {
-        private static final String TAG = "GeckoWebView";
-        private Callback callback;
-        private String currentUrl = "about:blank";
-        private boolean canGoBack;
-        private boolean canGoForward;
-        private boolean isSecure;
-        private GeckoSession geckoSession;
-        private String webViewTitle;
-        private boolean isLoadingInternalUrl = false;
-        private String internalAboutData = null;
-        private String internalRightsData = null;
-
-        public GeckoWebView(Context context, AttributeSet attrs) {
-            super(context, attrs);
-            PreferenceManager.getDefaultSharedPreferences(context)
-                    .registerOnSharedPreferenceChangeListener(this);
-            geckoSession = createGeckoSession();
-            applySettingsAndSetDelegates();
-            setSession(geckoSession, geckoRuntime);
-        }
-
-        private void applySettingsAndSetDelegates() {
-            applyAppSettings();
-            updateBlocking();
-
-            geckoSession.setContentDelegate(createContentDelegate());
-            geckoSession.setProgressDelegate(createProgressDelegate());
-            geckoSession.setNavigationDelegate(createNavigationDelegate());
-            geckoSession.setTrackingProtectionDelegate(createTrackingProtectionDelegate());
-            geckoSession.setPromptDelegate(createPromptDelegate());
-        }
-
-        private GeckoSession createGeckoSession() {
-            final GeckoSessionSettings settings = new GeckoSessionSettings();
-            settings.setBoolean(GeckoSessionSettings.USE_MULTIPROCESS, true);
-            settings.setBoolean(GeckoSessionSettings.USE_PRIVATE_MODE, true);
-
-            return new GeckoSession(settings);
-        }
-
-        @Override
-        public void setCallback(Callback callback) {
-            this.callback = callback;
-        }
-
-        @Override
-        public void onPause() {
-            if (geckoSession != null) {
-                geckoSession.setActive(false);
-            }
-        }
-
-        @Override
-        public void goBack() {
-            geckoSession.goBack();
-        }
-
-        @Override
-        public void goForward() {
-            geckoSession.goForward();
-        }
-
-        @Override
-        public void reload() {
-            geckoSession.reload();
-        }
-
-        @Override
-        public void destroy() {
-            geckoSession.close();
-        }
-
-        @Override
-        public void onResume() {
-            if (geckoSession != null) {
-                geckoSession.setActive(true);
-            }
-            if (TelemetryWrapper.dayPassedSinceLastUpload(getContext())) {
-                sendTelemetrySnapshots();
-            }
-        }
-
-        @Override
-        public void stopLoading() {
-            geckoSession.stop();
-            if (callback != null) {
-                callback.onPageFinished(isSecure);
-            }
-        }
-
-        @Override
-        public String getUrl() {
-            return currentUrl;
-        }
-
-        @Override
-        public void loadUrl(final String url) {
-            currentUrl = url;
-            geckoSession.loadUri(currentUrl);
-            if (callback != null) {
-                callback.onProgress(10);
-            }
-        }
-
-        @Override
-        public void cleanup() {
-            // We're running in a private browsing window, so nothing to do
-        }
-
-        @Override
-        public void setBlockingEnabled(boolean enabled) {
-            geckoSession.getSettings().setBoolean(GeckoSessionSettings.USE_TRACKING_PROTECTION, enabled);
-            if (enabled) {
-                updateBlocking();
-                applyAppSettings();
-            } else {
-                geckoRuntime.getSettings().setTrackingProtectionCategories(0);
-                geckoRuntime.getSettings().setJavaScriptEnabled(true);
-                geckoRuntime.getSettings().setWebFontsEnabled(true);
-                geckoRuntime.getSettings().setCookieBehavior(GeckoRuntimeSettings.COOKIE_ACCEPT_ALL);
-            }
-            if (callback != null) {
-                callback.onBlockingStateChanged(enabled);
-            }
-        }
-
-        @Override
-        public void setRequestDesktop(boolean shouldRequestDesktop) {
-            geckoSession.getSettings().setBoolean(GeckoSessionSettings.USE_DESKTOP_MODE, shouldRequestDesktop);
-            if (callback != null) {
-                callback.onRequestDesktopStateChanged(shouldRequestDesktop);
-            }
-        }
-
-        @Override
-        public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String prefName) {
-            updateBlocking();
-            applyAppSettings();
-        }
-
-        private void applyAppSettings() {
-            geckoRuntime.getSettings().setJavaScriptEnabled(!Settings.getInstance(getContext()).shouldBlockJavaScript());
-            geckoRuntime.getSettings().setWebFontsEnabled(!Settings.getInstance(getContext()).shouldBlockWebFonts());
-            geckoRuntime.getSettings().setRemoteDebuggingEnabled(false);
-            final int cookiesValue;
-            if (Settings.getInstance(getContext()).shouldBlockCookies() && Settings.getInstance(getContext()).shouldBlockThirdPartyCookies()) {
-                cookiesValue = GeckoRuntimeSettings.COOKIE_ACCEPT_NONE;
-            } else if (Settings.getInstance(getContext()).shouldBlockThirdPartyCookies()) {
-                cookiesValue = GeckoRuntimeSettings.COOKIE_ACCEPT_FIRST_PARTY;
-            } else {
-                cookiesValue = GeckoRuntimeSettings.COOKIE_ACCEPT_ALL;
-            }
-            geckoRuntime.getSettings().setCookieBehavior(cookiesValue);
-        }
-
-        private void updateBlocking() {
-            final Settings settings = Settings.getInstance(getContext());
-
-            int categories = 0;
-            if (settings.shouldBlockSocialTrackers()) {
-                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_SOCIAL;
-            }
-            if (settings.shouldBlockAdTrackers()) {
-                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_AD;
-            }
-            if (settings.shouldBlockAnalyticTrackers()) {
-                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_ANALYTIC;
-            }
-            if (settings.shouldBlockOtherTrackers()) {
-                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_CONTENT;
-            }
-
-            geckoRuntime.getSettings().setTrackingProtectionCategories(categories);
-        }
-
-        private GeckoSession.ContentDelegate createContentDelegate() {
-            return new GeckoSession.ContentDelegate() {
-                @Override
-                public void onTitleChange(GeckoSession session, String title) {
-                    webViewTitle = title;
-                    if (callback != null) {
-                        callback.onTitleChanged(title);
-                    }
-                }
-
-                @Override
-                public void onFullScreen(GeckoSession session, boolean fullScreen) {
-                    if (callback != null) {
-                        if (fullScreen) {
-                            callback.onEnterFullScreen(new FullscreenCallback() {
-                                @Override
-                                public void fullScreenExited() {
-                                    geckoSession.exitFullScreen();
-                                }
-                            }, null);
-                        } else {
-                            callback.onExitFullScreen();
-                        }
-                    }
-                }
-
-                @Override
-                public void onContextMenu(GeckoSession session, int screenX, int screenY, String uri, @ElementType int elementType, String elementSrc) {
-                    if (callback != null) {
-                        if (elementSrc != null && uri != null && elementType ==
-                                ELEMENT_TYPE_IMAGE) {
-                            callback.onLongPress(new HitTarget(true, uri, true, elementSrc));
-                        } else if (elementSrc != null && elementType == ELEMENT_TYPE_IMAGE) {
-                            callback.onLongPress(new HitTarget(false, null, true, elementSrc));
-                        } else if (uri != null) {
-                            callback.onLongPress(new HitTarget(true, uri, false, null));
-                        }
-                    }
-                }
-
-                @Override
-                public void onExternalResponse(GeckoSession session, GeckoSession.WebResponseInfo response) {
-                    if (!AppConstants.supportsDownloadingFiles()) {
-                        return;
-                    }
-
-                    final String scheme = Uri.parse(response.uri).getScheme();
-                    if (scheme == null || (!scheme.equals("http") && !scheme.equals("https"))) {
-                        // We are ignoring everything that is not http or https. This is a limitation of
-                        // Android's download manager. There's no reason to show a download dialog for
-                        // something we can't download anyways.
-                        Log.w(TAG, "Ignoring download from non http(s) URL: " + response.uri);
-                        return;
-                    }
-
-                    if (callback != null) {
-                        // TODO: get user agent from GeckoView #2470
-                        final Download download = new Download(response.uri, "Mozilla/5.0 (Android 8.1.0; Mobile; rv:60.0) Gecko/60.0 Firefox/60.0",
-                                response.filename, response.contentType, response.contentLength,
-                                Environment.DIRECTORY_DOWNLOADS);
-                        callback.onDownloadStart(download);
-                    }
-                }
-
-                @Override
-                public void onCrash(GeckoSession session) {
-                    Log.i(TAG, "Crashed, opening new session");
-                    SentryWrapper.INSTANCE.captureGeckoCrash();
-                    geckoSession.close();
-                    geckoSession = createGeckoSession();
-                    applySettingsAndSetDelegates();
-                    geckoSession.open(geckoRuntime);
-                    setSession(geckoSession);
-                    geckoSession.loadUri(currentUrl);
-                }
-
-                @Override
-                public void onFocusRequest(GeckoSession geckoSession) {
-
-                }
-
-                @Override
-                public void onCloseRequest(GeckoSession geckoSession) {
-                    // TODO: #2150
-                }
-            };
-        }
-
-        private GeckoSession.ProgressDelegate createProgressDelegate() {
-            return new GeckoSession.ProgressDelegate() {
-                @Override
-                public void onPageStart(GeckoSession session, String url) {
-                    if (callback != null) {
-                        callback.onPageStarted(url);
-                        callback.resetBlockedTrackers();
-                        callback.onProgress(25);
-                        isSecure = false;
-                    }
-                }
-
-                @Override
-                public void onPageStop(GeckoSession session, boolean success) {
-                    if (callback != null) {
-                        if (success) {
-                            if (UrlUtils.isLocalizedContent(getUrl())) {
-                                // When the url is a localized content, then the page is secure
-                                isSecure = true;
-                            }
-
-                            callback.onProgress(100);
-                            callback.onPageFinished(isSecure);
-                        }
-                    }
-                }
-
-                @Override
-                public void onSecurityChange(GeckoSession session,
-                                             GeckoSession.ProgressDelegate.SecurityInformation securityInfo) {
-                    isSecure = securityInfo.isSecure;
-
-                    if (UrlUtils.isLocalizedContent(getUrl())) {
-                        // When the url is a localized content, then the page is secure
-                        isSecure = true;
-                    }
-
-                    if (callback != null) {
-                        callback.onSecurityChanged(isSecure, securityInfo.host, securityInfo.issuerOrganization);
-                    }
-                }
-            };
-        }
-
-        private GeckoSession.NavigationDelegate createNavigationDelegate() {
-            return new GeckoSession.NavigationDelegate() {
-                public void onLocationChange(GeckoSession session, String url) {
-                    // Save internal data: urls we should override to present focus:about, focus:rights
-                    if (isLoadingInternalUrl) {
-                        if (currentUrl.equals(LocalizedContent.URL_ABOUT)) {
-                            internalAboutData = url;
-                        } else if (currentUrl.equals(LocalizedContent.URL_RIGHTS)) {
-                            internalRightsData = url;
-                        }
-                        isLoadingInternalUrl = false;
-                        url = currentUrl;
-                    }
-
-                    // Check for internal data: urls to instead present focus:rights, focus:about
-                    if (!TextUtils.isEmpty(internalAboutData) && internalAboutData.equals(url)) {
-                        url = LocalizedContent.URL_ABOUT;
-                    } else if (!TextUtils.isEmpty(internalRightsData) && internalRightsData.equals(url)) {
-                        url = LocalizedContent.URL_RIGHTS;
-                    }
-
-                    currentUrl = url;
-                    if (callback != null) {
-                        callback.onURLChanged(url);
-                    }
-                }
-
-                public void onCanGoBack(GeckoSession session, boolean canGoBack) {
-                    GeckoWebView.this.canGoBack = canGoBack;
-                }
-
-                public void onCanGoForward(GeckoSession session, boolean canGoForward) {
-                    GeckoWebView.this.canGoForward = canGoForward;
-                }
-
-                @Override
-                public void onLoadRequest(GeckoSession session, String uri, int target, int flags, GeckoResponse<Boolean> response) {
-                    // If this is trying to load in a new tab, just load it in the current one
-                    if (target == GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW) {
-                        geckoSession.loadUri(uri);
-                        response.respond(true);
-                    }
-
-                    // Check if we should handle an internal link
-                    if (LocalizedContent.handleInternalContent(uri, GeckoWebView.this, getContext())) {
-                        response.respond(true);
-                    }
-
-                    // Check if we should handle an external link
-                    final Uri urlToURI = Uri.parse(uri);
-                    if (!UrlUtils.isSupportedProtocol(urlToURI.getScheme()) && callback != null &&
-                            IntentUtils.handleExternalUri(getContext(), GeckoWebView.this, uri)) {
-                        response.respond(true);
-                    }
-
-                    if (uri.equals("about:neterror") || uri.equals("about:certerror")) {
-                        // TODO: Error Page handling with Components ErrorPages #2471
-                        response.respond(true);
-                    }
-
-                    if (callback != null) {
-                        callback.onRequest(flags == GeckoSession.NavigationDelegate.LOAD_REQUEST_IS_USER_TRIGGERED);
-                    }
-
-                    // Otherwise allow the load to continue normally
-                    response.respond(false);
-                }
-
-                @Override
-                public void onNewSession(GeckoSession session, String uri, GeckoResponse<GeckoSession> response) {
-                    // TODO: #2151
-                }
-            };
-        }
-
-        private GeckoSession.TrackingProtectionDelegate createTrackingProtectionDelegate() {
-            return new GeckoSession.TrackingProtectionDelegate() {
-                @Override
-                public void onTrackerBlocked(GeckoSession geckoSession, String s, int i) {
-                    if (callback != null) {
-                        callback.countBlockedTracker();
-                    }
-                }
-            };
-        }
-
-        private GeckoSession.PromptDelegate createPromptDelegate() {
-            return new GeckoViewPrompt((Activity) getContext());
-        }
-
-        @Override
-        public boolean canGoForward() {
-            return canGoForward;
-        }
-
-        @Override
-        public boolean canGoBack() {
-            return canGoBack;
-        }
-
-        @Override
-        public void restoreWebViewState(Session session) {
-            final Bundle stateData = session.getWebViewState();
-            final String desiredURL = session.getUrl().getValue();
-            final GeckoSession.SessionState sessionState = stateData.getParcelable("state");
-            if (sessionState != null) {
-                geckoSession.restoreState(sessionState);
-            } else {
-                loadUrl(desiredURL);
-            }
-        }
-
-        @Override
-        public void saveWebViewState(@NonNull final Session session) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            saveStateInBackground(latch, session);
-            try {
-                latch.await();
-            } catch (InterruptedException e) {
-                // State was not saved
-            }
-        }
-
-        private void saveStateInBackground(final CountDownLatch latch, final Session session) {
-            ThreadUtils.postToBackgroundThread(new Runnable() {
-                @Override
-                public void run() {
-                    final GeckoResponse<GeckoSession.SessionState> response = new GeckoResponse<GeckoSession.SessionState>() {
-                        @Override
-                        public void respond(GeckoSession.SessionState value) {
-                            if (value != null) {
-                                final Bundle bundle = new Bundle();
-                                bundle.putParcelable("state", value);
-                                session.saveWebViewState(bundle);
-                            }
-                            latch.countDown();
-                        }
-                    };
-
-                    geckoSession.saveState(response);
-                }
-            });
-        }
-
-        @Override
-        public String getTitle() {
-            return webViewTitle;
-        }
-
-        @Override
-        public void exitFullscreen() {
-            geckoSession.exitFullScreen();
-        }
-
-        @Override
-        public void findAllAsync(String find) {
-            // TODO: #2690
-        }
-
-        @Override
-        public void findNext(boolean forward) {
-            // TODO: #2690
-        }
-
-        @Override
-        public void clearMatches() {
-            // TODO: #2690
-        }
-
-        @Override
-        public void setFindListener(IFindListener findListener) {
-            // TODO: #2690
-        }
-
-        @Override
-        public void loadData(String baseURL, String data, String mimeType, String encoding, String historyURL) {
-            geckoSession.loadData(data.getBytes(Charsets.UTF_8), mimeType, baseURL);
-            currentUrl = baseURL;
-            isLoadingInternalUrl = currentUrl.equals(LocalizedContent.URL_RIGHTS) || currentUrl.equals(LocalizedContent.URL_ABOUT);
-        }
-
-        private void sendTelemetrySnapshots() {
-            final GeckoResponse<GeckoBundle> response = new GeckoResponse<GeckoBundle>() {
-                @Override
-                public void respond(GeckoBundle value) {
-                    if (value != null) {
-                        try {
-                            final JSONObject jsonData = value.toJSONObject();
-                            TelemetryWrapper.addMobileMetricsPing(jsonData);
-                        } catch (JSONException e) {
-                            Log.e("getSnapshots failed", e.getMessage());
-                        }
-                    }
-                }
-            };
-
-            geckoRuntime.getTelemetry().getSnapshots(true, response);
-        }
-
-        @Override
-        public void onDetachedFromWindow() {
-            PreferenceManager.getDefaultSharedPreferences(getContext()).unregisterOnSharedPreferenceChangeListener(this);
-            super.onDetachedFromWindow();
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt b/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt
new file mode 100644
index 000000000000..8526ff280daa
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt
@@ -0,0 +1,577 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.web
+
+import android.app.Activity
+import android.content.Context
+import android.content.SharedPreferences
+import android.net.Uri
+import android.os.Bundle
+import android.os.Environment
+import android.preference.PreferenceManager
+import android.text.TextUtils
+import android.util.AttributeSet
+import android.util.Log
+import android.view.View
+import android.webkit.WebSettings
+import kotlinx.coroutines.experimental.CompletableDeferred
+import kotlinx.coroutines.experimental.runBlocking
+import org.json.JSONException
+import org.mozilla.focus.browser.LocalizedContent
+import org.mozilla.focus.gecko.GeckoViewPrompt
+import org.mozilla.focus.gecko.NestedGeckoView
+import org.mozilla.focus.session.Session
+import org.mozilla.focus.telemetry.SentryWrapper
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.utils.AppConstants
+import org.mozilla.focus.utils.IntentUtils
+import org.mozilla.focus.utils.Settings
+import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.webview.SystemWebView
+import org.mozilla.gecko.util.GeckoBundle
+import org.mozilla.gecko.util.ThreadUtils
+import org.mozilla.geckoview.GeckoResponse
+import org.mozilla.geckoview.GeckoResult
+import org.mozilla.geckoview.GeckoRuntime
+import org.mozilla.geckoview.GeckoRuntimeSettings
+import org.mozilla.geckoview.GeckoSession
+import org.mozilla.geckoview.GeckoSessionSettings
+import org.mozilla.geckoview.SessionFinder
+
+/**
+ * WebViewProvider implementation for creating a Gecko based implementation of IWebView.
+ */
+class GeckoWebViewProvider : IWebViewProvider {
+
+    override fun preload(context: Context) {
+        createGeckoRuntime(context)
+    }
+
+    override fun create(context: Context, attributeSet: AttributeSet?): View {
+        return GeckoWebView(context, attributeSet)
+    }
+
+    override fun performCleanup(context: Context) {
+        // Nothing: does Gecko need extra private mode cleanup?
+    }
+
+    override fun performNewBrowserSessionCleanup() {
+        // Nothing: a WebKit work-around.
+    }
+
+    private fun createGeckoRuntime(context: Context) {
+        val runtimeSettingsBuilder = GeckoRuntimeSettings.Builder()
+        runtimeSettingsBuilder.useContentProcessHint(true)
+        runtimeSettingsBuilder.nativeCrashReportingEnabled(true)
+        geckoRuntime = GeckoRuntime.create(context.applicationContext, runtimeSettingsBuilder.build())
+    }
+
+    override fun requestMobileSite(context: Context, webSettings: WebSettings) {
+    }
+
+    override fun requestDesktopSite(webSettings: WebSettings) {
+    }
+
+    override fun applyAppSettings(context: Context, webSettings: WebSettings, systemWebView: SystemWebView) {
+    }
+
+    override fun disableBlocking(webSettings: WebSettings, systemWebView: SystemWebView) {
+    }
+
+    override fun getUABrowserString(existingUAString: String, focusToken: String): String? {
+        return null
+    }
+
+    @Suppress("LargeClass", "TooManyFunctions")
+    class GeckoWebView(context: Context, attrs: AttributeSet?) :
+            NestedGeckoView(context, attrs),
+            IWebView,
+            SharedPreferences.OnSharedPreferenceChangeListener {
+        private var callback: IWebView.Callback? = null
+        private var findListener: IFindListener? = null
+        private var currentUrl: String = "about:blank"
+        private var canGoBack: Boolean = false
+        private var canGoForward: Boolean = false
+        private var isSecure: Boolean = false
+        private var geckoSession: GeckoSession
+        private var webViewTitle: String? = null
+        private var isLoadingInternalUrl = false
+        private lateinit var finder: SessionFinder
+
+        init {
+            PreferenceManager.getDefaultSharedPreferences(context)
+                    .registerOnSharedPreferenceChangeListener(this)
+            geckoSession = createGeckoSession()
+            applySettingsAndSetDelegates()
+            setSession(geckoSession, geckoRuntime)
+        }
+
+        private fun applySettingsAndSetDelegates() {
+            applyAppSettings()
+            updateBlocking()
+
+            geckoSession.contentDelegate = createContentDelegate()
+            geckoSession.progressDelegate = createProgressDelegate()
+            geckoSession.navigationDelegate = createNavigationDelegate()
+            geckoSession.trackingProtectionDelegate = createTrackingProtectionDelegate()
+            geckoSession.promptDelegate = createPromptDelegate()
+            finder = geckoSession.finder
+            // TODO #2998
+            finder.displayFlags = GeckoSession.FINDER_DISPLAY_HIGHLIGHT_ALL
+        }
+
+        private fun createGeckoSession(): GeckoSession {
+            val settings = GeckoSessionSettings()
+            settings.setBoolean(GeckoSessionSettings.USE_MULTIPROCESS, true)
+            settings.setBoolean(GeckoSessionSettings.USE_PRIVATE_MODE, true)
+
+            return GeckoSession(settings)
+        }
+
+        override fun setCallback(callback: IWebView.Callback) {
+            this.callback = callback
+        }
+
+        override fun onPause() {
+            geckoSession.setActive(false)
+        }
+
+        override fun goBack() {
+            geckoSession.goBack()
+        }
+
+        override fun goForward() {
+            geckoSession.goForward()
+        }
+
+        override fun reload() {
+            geckoSession.reload()
+        }
+
+        override fun destroy() {
+            geckoSession.close()
+        }
+
+        override fun onResume() {
+            geckoSession.setActive(true)
+            if (TelemetryWrapper.dayPassedSinceLastUpload(context)) {
+                sendTelemetrySnapshots()
+            }
+        }
+
+        override fun stopLoading() {
+            geckoSession.stop()
+            callback?.onPageFinished(isSecure)
+        }
+
+        override fun getUrl(): String? {
+            return currentUrl
+        }
+
+        override fun loadUrl(url: String) {
+            currentUrl = url
+            geckoSession.loadUri(currentUrl)
+            callback?.onProgress(firstProgress)
+        }
+
+        override fun cleanup() {
+            // We're running in a private browsing window, so nothing to do
+        }
+
+        override fun setBlockingEnabled(enabled: Boolean) {
+            geckoSession.settings.setBoolean(GeckoSessionSettings.USE_TRACKING_PROTECTION, enabled)
+            if (enabled) {
+                updateBlocking()
+                applyAppSettings()
+            } else {
+                geckoRuntime.settings.trackingProtectionCategories = 0
+                geckoRuntime.settings.javaScriptEnabled = true
+                geckoRuntime.settings.webFontsEnabled = true
+                geckoRuntime.settings.cookieBehavior = GeckoRuntimeSettings.COOKIE_ACCEPT_ALL
+            }
+            callback?.onBlockingStateChanged(enabled)
+        }
+
+        override fun setRequestDesktop(shouldRequestDesktop: Boolean) {
+            geckoSession.settings.setBoolean(GeckoSessionSettings.USE_DESKTOP_MODE, shouldRequestDesktop)
+            callback?.onRequestDesktopStateChanged(shouldRequestDesktop)
+        }
+
+        override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences, prefName: String) {
+            updateBlocking()
+            applyAppSettings()
+        }
+
+        private fun applyAppSettings() {
+            geckoRuntime.settings.javaScriptEnabled = !Settings.getInstance(context).shouldBlockJavaScript()
+            geckoRuntime.settings.webFontsEnabled = !Settings.getInstance(context).shouldBlockWebFonts()
+            geckoRuntime.settings.remoteDebuggingEnabled = false
+            val cookiesValue = if (Settings.getInstance(context).shouldBlockCookies() &&
+                    Settings.getInstance(context).shouldBlockThirdPartyCookies()) {
+                GeckoRuntimeSettings.COOKIE_ACCEPT_NONE
+            } else if (Settings.getInstance(context).shouldBlockThirdPartyCookies()) {
+                GeckoRuntimeSettings.COOKIE_ACCEPT_FIRST_PARTY
+            } else {
+                GeckoRuntimeSettings.COOKIE_ACCEPT_ALL
+            }
+            geckoRuntime.settings.cookieBehavior = cookiesValue
+        }
+
+        private fun updateBlocking() {
+            val settings = Settings.getInstance(context)
+
+            var categories = 0
+            if (settings.shouldBlockSocialTrackers()) {
+                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_SOCIAL
+            }
+            if (settings.shouldBlockAdTrackers()) {
+                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_AD
+            }
+            if (settings.shouldBlockAnalyticTrackers()) {
+                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_ANALYTIC
+            }
+            if (settings.shouldBlockOtherTrackers()) {
+                categories += GeckoSession.TrackingProtectionDelegate.CATEGORY_CONTENT
+            }
+
+            geckoRuntime.settings.trackingProtectionCategories = categories
+        }
+
+        @Suppress("ComplexMethod")
+        private fun createContentDelegate(): GeckoSession.ContentDelegate {
+            return object : GeckoSession.ContentDelegate {
+                override fun onTitleChange(session: GeckoSession, title: String) {
+                    webViewTitle = title
+                    callback?.onTitleChanged(title)
+                }
+
+                override fun onFullScreen(session: GeckoSession, fullScreen: Boolean) {
+                    if (fullScreen) {
+                        callback?.onEnterFullScreen({ geckoSession.exitFullScreen() }, null)
+                    } else {
+                        callback?.onExitFullScreen()
+                    }
+                }
+
+                override fun onContextMenu(
+                    session: GeckoSession,
+                    screenX: Int,
+                    screenY: Int,
+                    uri: String?,
+                    elementType: Int,
+                    elementSrc: String?
+                ) {
+                    if (elementSrc != null && uri != null &&
+                            elementType == GeckoSession.ContentDelegate.ELEMENT_TYPE_IMAGE) {
+                        callback?.onLongPress(IWebView.HitTarget(true, uri, true, elementSrc))
+                    } else if (elementSrc != null && elementType == GeckoSession.ContentDelegate.ELEMENT_TYPE_IMAGE) {
+                        callback?.onLongPress(IWebView.HitTarget(false, null, true, elementSrc))
+                    } else if (uri != null) {
+                        callback?.onLongPress(IWebView.HitTarget(true, uri, false, null))
+                    }
+                }
+
+                override fun onExternalResponse(
+                    session: GeckoSession,
+                    response: GeckoSession.WebResponseInfo
+                ) {
+                    if (!AppConstants.supportsDownloadingFiles()) {
+                        return
+                    }
+
+                    val scheme = Uri.parse(response.uri).scheme
+                    if (scheme == null || scheme != "http" && scheme != "https") {
+                        // We are ignoring everything that is not http or https. This is a limitation of
+                        // Android's download manager. There's no reason to show a download dialog for
+                        // something we can't download anyways.
+                        Log.w(TAG, "Ignoring download from non http(s) URL: " + response.uri)
+                        return
+                    }
+
+                    // TODO: get user agent from GeckoView #2470
+                    val download = Download(response.uri, userAgent,
+                            response.filename, response.contentType, response.contentLength,
+                            Environment.DIRECTORY_DOWNLOADS)
+                    callback?.onDownloadStart(download)
+                }
+
+                override fun onCrash(session: GeckoSession) {
+                    Log.i(TAG, "Crashed, opening new session")
+                    SentryWrapper.captureGeckoCrash()
+                    geckoSession.close()
+                    geckoSession = createGeckoSession()
+                    applySettingsAndSetDelegates()
+                    geckoSession.open(geckoRuntime)
+                    setSession(geckoSession)
+                    geckoSession.loadUri(currentUrl)
+                }
+
+                override fun onFocusRequest(geckoSession: GeckoSession) { }
+
+                override fun onCloseRequest(geckoSession: GeckoSession) {
+                    // TODO: #2150
+                }
+            }
+        }
+
+        private fun createProgressDelegate(): GeckoSession.ProgressDelegate {
+            return object : GeckoSession.ProgressDelegate {
+                override fun onPageStart(session: GeckoSession, url: String) {
+                    callback?.onPageStarted(url)
+                    callback?.resetBlockedTrackers()
+                    callback?.onProgress(quarterProgress)
+                    isSecure = false
+                }
+
+                override fun onPageStop(session: GeckoSession, success: Boolean) {
+                    if (success) {
+                        if (UrlUtils.isLocalizedContent(url)) {
+                            // When the url is a localized content, then the page is secure
+                            isSecure = true
+                        }
+
+                        callback?.onProgress(finalProgress)
+                        callback?.onPageFinished(isSecure)
+                    }
+                }
+
+                override fun onSecurityChange(
+                    session: GeckoSession,
+                    securityInfo: GeckoSession.ProgressDelegate.SecurityInformation
+                ) {
+                    isSecure = securityInfo.isSecure
+
+                    if (UrlUtils.isLocalizedContent(url)) {
+                        // When the url is a localized content, then the page is secure
+                        isSecure = true
+                    }
+
+                    callback?.onSecurityChanged(isSecure, securityInfo.host, securityInfo.issuerOrganization)
+                }
+            }
+        }
+
+        @Suppress("ComplexMethod")
+        private fun createNavigationDelegate(): GeckoSession.NavigationDelegate {
+            return object : GeckoSession.NavigationDelegate {
+                override fun onLocationChange(session: GeckoSession, url: String) {
+                    var desiredUrl = url
+                    // Save internal data: urls we should override to present focus:about, focus:rights
+                    if (isLoadingInternalUrl) {
+                        if (currentUrl == LocalizedContent.URL_ABOUT) {
+                            internalAboutData = desiredUrl
+                        } else if (currentUrl == LocalizedContent.URL_RIGHTS) {
+                            internalRightsData = desiredUrl
+                        }
+                        isLoadingInternalUrl = false
+                        desiredUrl = currentUrl
+                    }
+
+                    // Check for internal data: urls to instead present focus:rights, focus:about
+                    if (!TextUtils.isEmpty(internalAboutData) && internalAboutData == desiredUrl) {
+                        desiredUrl = LocalizedContent.URL_ABOUT
+                    } else if (!TextUtils.isEmpty(internalRightsData) && internalRightsData == desiredUrl) {
+                        desiredUrl = LocalizedContent.URL_RIGHTS
+                    }
+
+                    currentUrl = desiredUrl
+                    callback?.onURLChanged(desiredUrl)
+                }
+
+                override fun onCanGoBack(session: GeckoSession, canGoBack: Boolean) {
+                    this@GeckoWebView.canGoBack = canGoBack
+                }
+
+                override fun onCanGoForward(session: GeckoSession, canGoForward: Boolean) {
+                    this@GeckoWebView.canGoForward = canGoForward
+                }
+
+                override fun onLoadRequest(
+                    session: GeckoSession,
+                    uri: String,
+                    target: Int,
+                    flags: Int,
+                    response: GeckoResponse<Boolean>
+                ) {
+                    // If this is trying to load in a new tab, just load it in the current one
+                    if (target == GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW) {
+                        geckoSession.loadUri(uri)
+                        response.respond(true)
+                    }
+
+                    // Check if we should handle an internal link
+                    if (LocalizedContent.handleInternalContent(uri, this@GeckoWebView, context)) {
+                        response.respond(true)
+                    }
+
+                    // Check if we should handle an external link
+                    val urlToURI = Uri.parse(uri)
+                    if (!UrlUtils.isSupportedProtocol(urlToURI.scheme) && callback != null &&
+                            IntentUtils.handleExternalUri(context, this@GeckoWebView, uri)) {
+                        response.respond(true)
+                    }
+
+                    if (uri == "about:neterror" || uri == "about:certerror") {
+                        // TODO: Error Page handling with Components ErrorPages #2471
+                        response.respond(true)
+                    }
+
+                    callback?.onRequest(flags == GeckoSession.NavigationDelegate.LOAD_REQUEST_IS_USER_TRIGGERED)
+
+                    // Otherwise allow the load to continue normally
+                    response.respond(false)
+                }
+
+                override fun onNewSession(
+                    session: GeckoSession,
+                    uri: String,
+                    response: GeckoResponse<GeckoSession>
+                ) {
+                    // TODO: #2151
+                }
+            }
+        }
+
+        private fun createTrackingProtectionDelegate(): GeckoSession.TrackingProtectionDelegate {
+            return GeckoSession.TrackingProtectionDelegate { _, _, _ ->
+                callback?.countBlockedTracker()
+            }
+        }
+
+        private fun createPromptDelegate(): GeckoSession.PromptDelegate {
+            return GeckoViewPrompt(context as Activity)
+        }
+
+        override fun canGoForward(): Boolean {
+            return canGoForward
+        }
+
+        override fun canGoBack(): Boolean {
+            return canGoBack
+        }
+
+        override fun restoreWebViewState(session: Session) {
+            val stateData = session.webViewState
+            val desiredURL = session.url.value
+            val sessionState = stateData.getParcelable<GeckoSession.SessionState>("state")
+            if (sessionState != null) {
+                geckoSession.restoreState(sessionState)
+            } else {
+                loadUrl(desiredURL)
+            }
+        }
+
+        override fun saveWebViewState(session: Session) {
+            val sessionBundle = saveStateInBackground()
+            if (sessionBundle.containsKey("state")) {
+                session.saveWebViewState(sessionBundle)
+            }
+        }
+
+        private fun saveStateInBackground(): Bundle = runBlocking {
+            val stateBundle = CompletableDeferred<Bundle>()
+            ThreadUtils.sGeckoHandler.post {
+                geckoSession.saveState().then({ state ->
+                    val bundle = Bundle()
+                    bundle.putParcelable("state", state)
+                    stateBundle.complete(bundle)
+                    GeckoResult<Void>()
+                }, { throwable ->
+                    stateBundle.completeExceptionally(throwable)
+                    GeckoResult<Void>()
+                })
+            }
+            stateBundle.await()
+        }
+
+        override fun getTitle(): String? {
+            return webViewTitle
+        }
+
+        override fun exitFullscreen() {
+            geckoSession.exitFullScreen()
+        }
+
+        override fun findAllAsync(find: String) {
+            finder.find(find, 0).then({ result ->
+                if (result != null) {
+                    findListener?.onFindResultReceived(result.current, result.total, true)
+                }
+                GeckoResult<Void>()
+            }, { _ ->
+                GeckoResult<Void>()
+            })
+        }
+
+        override fun findNext(forward: Boolean) {
+            finder.find(null, if (forward) 0 else GeckoSession.FINDER_FIND_BACKWARDS)
+                    .then({ result ->
+                if (result != null) {
+                    findListener?.onFindResultReceived(result.current, result.total, true)
+                }
+                GeckoResult<Void>()
+            }, { _ ->
+                GeckoResult<Void>()
+            })
+        }
+
+        override fun clearMatches() {
+            finder.clear()
+        }
+
+        override fun setFindListener(findListener: IFindListener) {
+            this.findListener = findListener
+        }
+
+        override fun loadData(
+            baseURL: String,
+            data: String,
+            mimeType: String,
+            encoding: String,
+            historyURL: String
+        ) {
+            geckoSession.loadData(data.toByteArray(Charsets.UTF_8), mimeType, baseURL)
+            currentUrl = baseURL
+            isLoadingInternalUrl = currentUrl == LocalizedContent.URL_RIGHTS || currentUrl == LocalizedContent.URL_ABOUT
+        }
+
+        private fun sendTelemetrySnapshots() {
+            val response = GeckoResponse<GeckoBundle> { value ->
+                if (value != null) {
+                    try {
+                        val jsonData = value.toJSONObject()
+                        TelemetryWrapper.addMobileMetricsPing(jsonData)
+                    } catch (e: JSONException) {
+                        Log.e("getSnapshots failed", e.message)
+                    }
+                }
+            }
+
+            geckoRuntime.telemetry.getSnapshots(true, response)
+        }
+
+        override fun onDetachedFromWindow() {
+            PreferenceManager.getDefaultSharedPreferences(context)
+                    .unregisterOnSharedPreferenceChangeListener(this)
+            super.onDetachedFromWindow()
+        }
+
+        companion object {
+            private const val TAG = "GeckoWebView"
+        }
+    }
+
+    companion object {
+        @Volatile
+        private lateinit var geckoRuntime: GeckoRuntime
+        private var internalAboutData: String? = null
+        private var internalRightsData: String? = null
+        private const val firstProgress = 10
+        private const val quarterProgress = 25
+        private const val finalProgress = 100
+        private const val userAgent = "Mozilla/5.0 (Android 8.1.0; Mobile; rv:60.0) Gecko/60.0 Firefox/60.0"
+    }
+}
diff --git a/focus-android/build.gradle b/focus-android/build.gradle
index 5a0afc55cdfd..4542ad1bb760 100644
--- a/focus-android/build.gradle
+++ b/focus-android/build.gradle
@@ -5,8 +5,8 @@ buildscript {
     ext.support_libraries_version = '27.1.1'
     ext.espresso_version = '3.0.1'
     ext.kotlin_version = '1.2.30'
-    ext.geckoview_revision = '02069dab4f3cabe06bdf8f824031e1aa6aef7dfd'
-    ext.geckoview_version = '62.0.20180712042337' // 62.0b8
+    ext.geckoview_revision = '88222b8b526d8a6a0f2e4ca099f425af17f7d10d'
+    ext.geckoview_version = '62.0.20180723144101' // 62.0b11
     ext.spotbugs_version = '3.1.2'
     ext.mozilla_components_version = '0.16.1'
 
