diff --git a/android-components/README.md b/android-components/README.md
index 25453c1803a6..f54cf8f9af77 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -62,6 +62,8 @@ _Generic low-level UI components for building apps._
 
 * **Icons** - A collection of often used browser icons.
 
+* **Progress+* - An animated progress bar following the Photon Design System. 
+
 ## Service
 
 _Components and libraries to interact with backend services._
diff --git a/android-components/components/ui/progress/build.gradle b/android-components/components/ui/progress/build.gradle
new file mode 100644
index 000000000000..d31d4076d734
--- /dev/null
+++ b/android-components/components/ui/progress/build.gradle
@@ -0,0 +1,43 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+android {
+    compileSdkVersion rootProject.ext.build['compileSdkVersion']
+
+    defaultConfig {
+        minSdkVersion rootProject.ext.build['minSdkVersion']
+        targetSdkVersion rootProject.ext.build['targetSdkVersion']
+    }
+
+    lintOptions {
+        warningsAsErrors true
+        abortOnError true
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    implementation project(':ui-colors')
+
+    implementation "org.jetbrains.kotlin:kotlin-stdlib:${rootProject.ext.dependencies['kotlin']}"
+
+    implementation "com.android.support:support-v4:${rootProject.ext.dependencies['supportLibraries']}"
+}
+
+archivesBaseName = "progress"
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(
+        'org.mozilla.photon',
+        'progress',
+        'An animated progress bar following the Photon Design System.')
diff --git a/android-components/components/ui/progress/proguard-rules.pro b/android-components/components/ui/progress/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/ui/progress/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/ui/progress/src/main/AndroidManifest.xml b/android-components/components/ui/progress/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..7d2f2d8d6239
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="mozilla.components.ui.progress" />
diff --git a/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/AnimatedProgressBar.kt b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/AnimatedProgressBar.kt
new file mode 100644
index 000000000000..2b51ff272e22
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/AnimatedProgressBar.kt
@@ -0,0 +1,186 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.progress
+
+import android.animation.Animator
+import android.animation.ValueAnimator
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Rect
+import android.graphics.drawable.Drawable
+import android.support.v4.view.ViewCompat
+import android.util.AttributeSet
+import android.view.View
+import android.view.animation.AnimationUtils
+import android.view.animation.LinearInterpolator
+import android.widget.ProgressBar
+
+/**
+ * An animated progress bar following the Photon Design System.
+ */
+class AnimatedProgressBar @JvmOverloads constructor(
+    context: Context,
+    attrs: AttributeSet? = null,
+    defStyleAttr: Int = 0
+) : ProgressBar(context, attrs, defStyleAttr) {
+    private var primaryAnimator: ValueAnimator? = null
+    private val closingAnimator: ValueAnimator? = ValueAnimator.ofFloat(0f, 1f)
+    private var clipRegion = 0f
+    private var expectedProgress = 0
+    private var tempRect = Rect()
+    private var isRtl: Boolean = false
+
+    private val animatorListener = ValueAnimator.AnimatorUpdateListener {
+        setProgressImmediately(primaryAnimator!!.animatedValue as Int)
+    }
+
+    /**
+     * Sets the current progress to the specified value.
+     */
+    override fun setProgress(progress: Int) {
+        var nextProgress = progress
+        nextProgress = Math.min(nextProgress, max)
+        nextProgress = Math.max(0, nextProgress)
+        expectedProgress = nextProgress
+
+        // a dirty-hack for reloading page.
+        if (expectedProgress < progress && progress == max) {
+            setProgressImmediately(0)
+        }
+
+        primaryAnimator?.apply {
+            cancel()
+            setIntValues(progress, nextProgress)
+            start()
+        } ?: run { setProgressImmediately(nextProgress) }
+
+        closingAnimator?.apply {
+            if (nextProgress == max) { return@apply }
+
+            cancel()
+            clipRegion = 0f
+        }
+    }
+
+    override fun onDraw(canvas: Canvas) {
+        if (clipRegion == 0f) { super.onDraw(canvas); return }
+
+        canvas.getClipBounds(tempRect)
+        val clipWidth = tempRect.width() * clipRegion
+        val saveCount = canvas.save()
+
+        if (isRtl) {
+            canvas.clipRect(tempRect.left.toFloat(),
+                    tempRect.top.toFloat(),
+                    tempRect.right - clipWidth,
+                    tempRect.bottom.toFloat())
+        } else {
+            canvas.clipRect(tempRect.left + clipWidth,
+                    tempRect.top.toFloat(),
+                    tempRect.right.toFloat(),
+                    tempRect.bottom.toFloat())
+        }
+        super.onDraw(canvas)
+        canvas.restoreToCount(saveCount)
+    }
+
+    /**
+     * Set the visibility state of this view.
+     */
+    override fun setVisibility(value: Int) {
+        if (value == View.GONE) {
+            if (expectedProgress == max) {
+                animateClosing()
+            } else {
+                setVisibilityImmediately(value)
+            }
+        } else {
+            setVisibilityImmediately(value)
+        }
+    }
+
+    private fun setVisibilityImmediately(value: Int) {
+        super.setVisibility(value)
+    }
+
+    private fun animateClosing() {
+        isRtl = ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL
+
+        closingAnimator!!.cancel()
+
+        val handler = handler
+        handler?.postDelayed({ closingAnimator.start() }, CLOSING_DELAY.toLong())
+    }
+
+    private fun setProgressImmediately(progress: Int) {
+        super.setProgress(progress)
+    }
+
+    init {
+        val a = context.obtainStyledAttributes(attrs, R.styleable.AnimatedProgressBar)
+        val duration = a.getInteger(R.styleable.AnimatedProgressBar_shiftDuration, DEFAULT_DURATION)
+        val resID = a.getResourceId(R.styleable.AnimatedProgressBar_shiftInterpolator, DEFAULT_RESOURCE_ID)
+        val wrap = a.getBoolean(R.styleable.AnimatedProgressBar_wrapShiftDrawable, true)
+
+        primaryAnimator = ValueAnimator.ofInt(progress, max).apply {
+            interpolator = LinearInterpolator()
+            setDuration(PROGRESS_DURATION.toLong())
+            addUpdateListener(animatorListener)
+        }
+
+        closingAnimator!!.duration = CLOSING_DURATION.toLong()
+        closingAnimator.interpolator = LinearInterpolator()
+        closingAnimator.addUpdateListener { valueAnimator ->
+            val region = valueAnimator.animatedValue as Float
+            if (clipRegion != region) {
+                clipRegion = region
+                invalidate()
+            }
+        }
+        closingAnimator.addListener(object : Animator.AnimatorListener {
+            override fun onAnimationStart(animator: Animator) {
+                clipRegion = 0f
+            }
+
+            override fun onAnimationEnd(animator: Animator) {
+                setVisibilityImmediately(View.GONE)
+            }
+
+            override fun onAnimationCancel(animator: Animator) {
+                clipRegion = 0f
+            }
+
+            override fun onAnimationRepeat(animator: Animator) {}
+        })
+
+        if (progressDrawable == null) {
+            progressDrawable = resources.getDrawable(R.drawable.mozac_progressbar, context.theme)
+        }
+        progressDrawable = buildWrapDrawable(progressDrawable, wrap, duration, resID)
+
+        a.recycle()
+    }
+
+    private fun buildWrapDrawable(original: Drawable, isWrap: Boolean, duration: Int, resID: Int): Drawable {
+        return if (isWrap) {
+            val interpolator = if (resID > 0)
+                AnimationUtils.loadInterpolator(context, resID)
+            else
+                null
+            ShiftDrawable(original, duration, interpolator)
+        } else {
+            original
+        }
+    }
+
+    companion object {
+        private const val PROGRESS_DURATION = 200
+        private const val CLOSING_DELAY = 300
+        private const val CLOSING_DURATION = 300
+
+        private const val DEFAULT_DURATION = 1000
+        private const val DEFAULT_RESOURCE_ID = 0
+    }
+}
diff --git a/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/DrawableWrapper.kt b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/DrawableWrapper.kt
new file mode 100644
index 000000000000..a9faba6a5fe1
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/DrawableWrapper.kt
@@ -0,0 +1,140 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.progress
+
+import android.content.res.Resources
+import android.graphics.Canvas
+import android.graphics.ColorFilter
+import android.graphics.PorterDuff
+import android.graphics.Rect
+import android.graphics.Region
+import android.graphics.drawable.Drawable
+import android.support.annotation.IntRange
+import android.util.AttributeSet
+
+import org.xmlpull.v1.XmlPullParser
+import org.xmlpull.v1.XmlPullParserException
+
+import java.io.IOException
+
+/**
+ * DrawableWrapper was added since API Level 23. But in v7 support library, it has annotation
+ * "@RestrictTo(LIBRARY_GROUP)". Hence we should not extends it, so we create this wrapper for now.
+ * Once we start to support API 23, or v7-support-library allows us to extends its DrawableWrapper,
+ * then this file can be removed.
+ */
+@Suppress("TooManyFunctions") // We are overriding functions of Drawable
+internal open class DrawableWrapper(val wrappedDrawable: Drawable) : Drawable() {
+
+    override fun draw(canvas: Canvas) {
+        wrappedDrawable.draw(canvas)
+    }
+
+    override fun getChangingConfigurations(): Int {
+        return wrappedDrawable.changingConfigurations
+    }
+
+    override fun getConstantState(): Drawable.ConstantState? {
+        return wrappedDrawable.constantState
+    }
+
+    override fun getCurrent(): Drawable {
+        return wrappedDrawable.current
+    }
+
+    override fun getIntrinsicHeight(): Int {
+        return wrappedDrawable.intrinsicHeight
+    }
+
+    override fun getIntrinsicWidth(): Int {
+        return wrappedDrawable.intrinsicWidth
+    }
+
+    override fun getMinimumHeight(): Int {
+        return wrappedDrawable.minimumHeight
+    }
+
+    override fun getMinimumWidth(): Int {
+        return wrappedDrawable.minimumWidth
+    }
+
+    override fun getOpacity(): Int {
+        return wrappedDrawable.opacity
+    }
+
+    override fun getPadding(padding: Rect): Boolean {
+        return wrappedDrawable.getPadding(padding)
+    }
+
+    override fun getState(): IntArray {
+        return wrappedDrawable.state
+    }
+
+    override fun getTransparentRegion(): Region? {
+        return wrappedDrawable.transparentRegion
+    }
+
+    @Throws(XmlPullParserException::class, IOException::class)
+    override fun inflate(r: Resources, parser: XmlPullParser, attrs: AttributeSet) {
+        wrappedDrawable.inflate(r, parser, attrs)
+    }
+
+    override fun isStateful(): Boolean {
+        return wrappedDrawable.isStateful
+    }
+
+    override fun jumpToCurrentState() {
+        wrappedDrawable.jumpToCurrentState()
+    }
+
+    override fun mutate(): Drawable {
+        return wrappedDrawable.mutate()
+    }
+
+    @Suppress("MagicNumber")
+    override fun setAlpha(@IntRange(from = 0, to = 255) i: Int) {
+        wrappedDrawable.alpha = i
+    }
+
+    override fun scheduleSelf(what: Runnable, `when`: Long) {
+        wrappedDrawable.scheduleSelf(what, `when`)
+    }
+
+    override fun setChangingConfigurations(configs: Int) {
+        wrappedDrawable.changingConfigurations = configs
+    }
+
+    override fun setColorFilter(colorFilter: ColorFilter?) {
+        wrappedDrawable.colorFilter = colorFilter
+    }
+
+    override fun setColorFilter(color: Int, mode: PorterDuff.Mode) {
+        wrappedDrawable.setColorFilter(color, mode)
+    }
+
+    override fun setFilterBitmap(filter: Boolean) {
+        wrappedDrawable.isFilterBitmap = filter
+    }
+
+    override fun setVisible(visible: Boolean, restart: Boolean): Boolean {
+        return wrappedDrawable.setVisible(visible, restart)
+    }
+
+    override fun unscheduleSelf(what: Runnable) {
+        wrappedDrawable.unscheduleSelf(what)
+    }
+
+    override fun onBoundsChange(bounds: Rect) {
+        wrappedDrawable.bounds = bounds
+    }
+
+    override fun onLevelChange(level: Int): Boolean {
+        return wrappedDrawable.setLevel(level)
+    }
+
+    override fun onStateChange(state: IntArray): Boolean {
+        return wrappedDrawable.setState(state)
+    }
+}
diff --git a/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/ShiftDrawable.kt b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/ShiftDrawable.kt
new file mode 100644
index 000000000000..7f8e46f5ab2a
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/java/mozilla/components/ui/progress/ShiftDrawable.kt
@@ -0,0 +1,110 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.progress
+
+import android.animation.ValueAnimator
+import android.graphics.Canvas
+import android.graphics.Path
+import android.graphics.Rect
+import android.graphics.drawable.Drawable
+import android.view.animation.Interpolator
+import android.view.animation.LinearInterpolator
+
+internal class ShiftDrawable @JvmOverloads constructor(
+    drawable: Drawable,
+    duration: Int = DEFAULT_DURATION,
+    interpolator: Interpolator? = LinearInterpolator()
+) : DrawableWrapper(drawable) {
+
+    private val animator = ValueAnimator.ofFloat(0f, 1f)
+    private val visibleRect = Rect()
+    private var path: Path? = null
+
+    init {
+        animator.duration = duration.toLong()
+        animator.repeatCount = ValueAnimator.INFINITE
+        animator.interpolator = interpolator ?: LinearInterpolator()
+        animator.addUpdateListener {
+            if (isVisible) {
+                invalidateSelf()
+            }
+        }
+        animator.start()
+    }
+
+    override fun setVisible(visible: Boolean, restart: Boolean): Boolean {
+        val result = super.setVisible(visible, restart)
+
+        if (isVisible) {
+            animator.start()
+        } else {
+            animator.end()
+        }
+
+        return result
+    }
+
+    override fun onBoundsChange(bounds: Rect) {
+        super.onBoundsChange(bounds)
+        updateBounds()
+    }
+
+    override fun onLevelChange(level: Int): Boolean {
+        val result = super.onLevelChange(level)
+        updateBounds()
+        return result
+    }
+
+    override fun draw(canvas: Canvas) {
+        val d = wrappedDrawable
+        val fraction = animator.animatedFraction
+        val width = visibleRect.width()
+        val offset = (width * fraction).toInt()
+        val stack = canvas.save()
+
+        canvas.clipPath(path!!)
+
+        // shift from right to left.
+        // draw left-half part
+        canvas.save()
+        canvas.translate((-offset).toFloat(), 0f)
+        d.draw(canvas)
+        canvas.restore()
+
+        // draw right-half part
+        canvas.save()
+        canvas.translate((width - offset).toFloat(), 0f)
+        d.draw(canvas)
+        canvas.restore()
+
+        canvas.restoreToCount(stack)
+    }
+
+    private fun updateBounds() {
+        val b = bounds
+        val width = (b.width().toFloat() * level / MAX_LEVEL).toInt()
+        val radius = b.height() / 2f
+        visibleRect.set(b.left, b.top, b.left + width, b.height())
+
+        // draw round to head of progressbar. I know it looks stupid, don't blame me now.
+        path = Path().apply {
+            addRect(
+                b.left.toFloat(),
+                b.top.toFloat(),
+                b.left + width - radius,
+                b.height().toFloat(),
+                Path.Direction.CCW)
+            addCircle(b.left + width - radius, radius, radius, Path.Direction.CCW)
+        }
+    }
+
+    companion object {
+
+        // align to ScaleDrawable implementation
+        private const val MAX_LEVEL = 10000
+
+        private const val DEFAULT_DURATION = 1000
+    }
+}
diff --git a/android-components/components/ui/progress/src/main/res/drawable/mozac_progressbar.xml b/android-components/components/ui/progress/src/main/res/drawable/mozac_progressbar.xml
new file mode 100644
index 000000000000..8d889612cc3f
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/res/drawable/mozac_progressbar.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@android:id/progress">
+        <scale
+            android:scaleGravity="fill_vertical|start"
+            android:scaleHeight="100%"
+            android:scaleWidth="100%">
+            <shape>
+                <gradient
+                    android:startColor="@color/photonBlue40"
+                    android:centerColor="@color/photonBlue70"
+                    android:endColor="@color/photonBlue40" />
+            </shape>
+        </scale>
+    </item>
+</layer-list>
diff --git a/android-components/components/ui/progress/src/main/res/values/attrs.xml b/android-components/components/ui/progress/src/main/res/values/attrs.xml
new file mode 100644
index 000000000000..e5b2879c761b
--- /dev/null
+++ b/android-components/components/ui/progress/src/main/res/values/attrs.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<resources>
+
+    <declare-styleable name="AnimatedProgressBar">
+        <attr name="wrapShiftDrawable" format="boolean" />
+        <attr name="shiftDuration" format="reference" />
+        <attr name="shiftInterpolator" format="reference" />
+    </declare-styleable>
+
+</resources>
\ No newline at end of file
diff --git a/android-components/settings.gradle b/android-components/settings.gradle
index 9de357ce65c7..2c89c077dbb8 100644
--- a/android-components/settings.gradle
+++ b/android-components/settings.gradle
@@ -63,6 +63,9 @@ project(':ui-fonts').projectDir = new File('components/ui/fonts')
 include ':ui-icons'
 project(':ui-icons').projectDir = new File('components/ui/icons')
 
+include ':ui-progress'
+project(':ui-progress').projectDir = new File('components/ui/progress')
+
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 // Services
 ////////////////////////////////////////////////////////////////////////////////////////////////////
