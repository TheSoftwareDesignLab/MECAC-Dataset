diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index a18407ef6dc7..67a6e2365d80 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -96,6 +96,10 @@ projects:
     path: components/feature/prompts
     description: 'Feature that will subscribe to the selected session and will handle all the common prompt dialogs from web content.'
     publish: true
+  feature-push:
+    path: components/feature/push
+    description: 'Feature that implements push notifications with a supported push service.'
+    publish: true
   feature-pwa:
     path: components/feature/pwa
     description: 'Feature implementation for Progressive Web Apps (PWA).'
diff --git a/android-components/README.md b/android-components/README.md
index d20d1eed06bf..b3002b396e46 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -142,6 +142,8 @@ _Combined components to implement feature-specific use cases._
 
 * âšª [**Prompts**](components/feature/prompts/README.md) - A component that will handle all the common prompt dialogs from web content.
 
+* âšª [**Push**](components/feature/push/README.md) - A component that provides Autopush messages with help from a supported push service.
+
 * âšª [**Find In Page**](components/feature/findinpage/README.md) - A component that provides an UI widget for [find in page functionality](https://support.mozilla.org/en-US/kb/search-contents-current-page-text-or-links).
 
 * ðŸ”´ [**Site Permissions**](components/feature/sitepermissions/README.md) - A feature for showing site permission request prompts.
diff --git a/android-components/buildSrc/src/main/java/Dependencies.kt b/android-components/buildSrc/src/main/java/Dependencies.kt
index b8e6ddd24fed..31293126cef2 100644
--- a/android-components/buildSrc/src/main/java/Dependencies.kt
+++ b/android-components/buildSrc/src/main/java/Dependencies.kt
@@ -107,6 +107,7 @@ object Dependencies {
     const val mozilla_sync_logins = "org.mozilla.appservices:logins:${Versions.mozilla_appservices}"
     const val mozilla_places = "org.mozilla.appservices:places:${Versions.mozilla_appservices}"
     const val mozilla_places_forUnitTests = "org.mozilla.appservices:places-forUnitTests:${Versions.mozilla_appservices}"
+    const val mozilla_push = "org.mozilla.appservices:push:${Versions.mozilla_appservices}"
     const val mozilla_rustlog = "org.mozilla.appservices:rustlog:${Versions.mozilla_appservices}"
     const val mozilla_servo_arm = "org.mozilla.servoview:servoview-armv7:${Versions.servo}"
     const val mozilla_servo_x86 = "org.mozilla.servoview:servoview-x86:${Versions.servo}"
diff --git a/android-components/components/feature/push/README.md b/android-components/components/feature/push/README.md
new file mode 100644
index 000000000000..871a808d18b8
--- /dev/null
+++ b/android-components/components/feature/push/README.md
@@ -0,0 +1,69 @@
+# [Android Components](../../../README.md) > Feature > Push
+
+A compoennt that implements push notifications with a supported push service.
+
+## Usage
+
+Add a supported push service for providing the encrypted messages (for example Firebase Cloud Messaging via `lib-push-firebase`):
+```kotlin
+class FirebasePush : AbstractFirebasePushService()
+```
+
+Create a push configuration with the project info and also place the required service's API keys in the project directory:
+
+```kotlin
+PushConfig(
+  senderId = "push-test-f408f",
+  serverHost = "push.service.mozilla.com",
+  serviceType = ServiceType.FCM,
+  protocol = Protocol.HTTPS
+)
+```
+
+We can then start the AutoPushFeature to get the subscription info and decrypted push message:
+```kolin
+val service = FirebasePush()
+
+val feature = AutoPushFeature(
+  context = context,
+  service = pushService,
+  config = config
+)
+
+// To start the feature and the service.
+feature.initialize()
+
+// To stop the feature and the service.
+feature.shutdown()
+
+// To receive the subscription info for all the subscription changes.
+feature.registerForSubscriptions(object : PushSubscriptionObserver {
+  override fun onSubscriptionAvailable(subscription: AutoPushSubscription) {
+    // handle subscription info here.
+  }
+}, lifecycle, false)
+
+// Force request all subscription information.
+feature.subscribeAll()
+
+// To receive a message for a specific push message type.
+feature.registerForPushMessages(PushType.Services, object: Bus.Observer<PushType, String> {
+  override fun onEvent(type: PushType, message: String) {
+    // Handle decrypted message here.
+  }
+}, lifecycle, false)
+```
+
+### Setting up the dependency
+
+Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
+
+```Groovy
+implementation "org.mozilla.components:feature-push:{latest-version}"
+```
+
+## License
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/feature/push/build.gradle b/android-components/components/feature/push/build.gradle
new file mode 100644
index 000000000000..8dea17eebb77
--- /dev/null
+++ b/android-components/components/feature/push/build.gradle
@@ -0,0 +1,46 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-android-extensions'
+
+android {
+    compileSdkVersion config.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion config.minSdkVersion
+        targetSdkVersion config.targetSdkVersion
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+
+dependencies {
+    implementation project(':concept-push')
+
+    implementation Dependencies.mozilla_push
+
+    // Remove when the MessageBus is implemented somewhere else.
+    implementation project(':support-base')
+
+    implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
+
+    testImplementation project(':support-test')
+
+    testImplementation Dependencies.androidx_test_core
+    testImplementation Dependencies.testing_junit
+    testImplementation Dependencies.testing_robolectric
+    testImplementation Dependencies.testing_mockito
+}
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
\ No newline at end of file
diff --git a/android-components/components/feature/push/proguard-rules.pro b/android-components/components/feature/push/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/feature/push/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/feature/push/src/main/AndroidManifest.xml b/android-components/components/feature/push/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..4e7abef55789
--- /dev/null
+++ b/android-components/components/feature/push/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="mozilla.components.feature.push" />
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
new file mode 100644
index 000000000000..fc4eecfeae5b
--- /dev/null
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
@@ -0,0 +1,327 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import android.content.Context
+import android.content.SharedPreferences
+import androidx.lifecycle.LifecycleOwner
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.SupervisorJob
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.plus
+import mozilla.appservices.push.PushError as RustPushError
+import mozilla.appservices.push.SubscriptionResponse
+import mozilla.components.concept.push.Bus
+import mozilla.components.concept.push.EncryptedPushMessage
+import mozilla.components.concept.push.PushError
+import mozilla.components.concept.push.PushProcessor
+import mozilla.components.concept.push.PushService
+import mozilla.components.support.base.log.logger.Logger
+import mozilla.components.support.base.observer.Observable
+import mozilla.components.support.base.observer.ObserverRegistry
+import java.io.File
+import java.util.UUID
+import java.util.concurrent.Executors
+import kotlin.coroutines.CoroutineContext
+
+/**
+ * A implementation of a [PushProcessor] that should live as a singleton by being installed
+ * in the Application's onCreate. It receives messages from a service and forwards them
+ * to be decrypted and routed.
+ *
+ * <code>
+ *     class Application {
+ *          override fun onCreate() {
+ *              val feature = AutoPushFeature(context, service, configuration)
+ *              PushProvider.install(push)
+ *          }
+ *     }
+ * </code>
+ *
+ * Listen for subscription information changes for each registered [PushType]:
+ *
+ * <code>
+ *    feature.registerForSubscriptions(object: Bus.Observer<PushType, String> {
+ *        override fun onSubscriptionAvailable(subscription: AutoPushSubscription) { }
+ *    })
+ *    feature.subscribeForType(PushType.Services)
+ * </code>
+ *
+ * Listen also for push messages for each registered [PushType]:
+ *
+ * <code>
+ *     feature.registerForPushMessages(object: Bus.Observer<PushType, String> {
+ *        override fun onEvent(message: String) { }
+ *     })
+ * </code>
+ *
+ */
+@Suppress("TooManyFunctions")
+class AutoPushFeature(
+    private val context: Context,
+    private val service: PushService,
+    config: PushConfig,
+    coroutineContext: CoroutineContext = Executors.newSingleThreadExecutor().asCoroutineDispatcher(),
+    private val connection: PushConnection = RustPushConnection(
+        senderId = config.senderId,
+        serverHost = config.serverHost,
+        socketProtocol = config.protocol,
+        serviceType = config.serviceType,
+        databasePath = File(context.filesDir, DB_NAME).canonicalPath
+    )
+) : PushProcessor {
+
+    private val logger = Logger("AutoPushFeature")
+    private val subscriptionObservers: Observable<PushSubscriptionObserver> = ObserverRegistry()
+    private val messageObserverBus: Bus<PushType, String> = MessageBus()
+    // The preference that stores new registration tokens.
+    private val prefToken = preferences(context).getString(PREF_TOKEN, null)
+
+    internal var job: Job = SupervisorJob()
+    private val scope = CoroutineScope(coroutineContext) + job
+
+    init {
+        // If we have a token, initialize the rust component first.
+        prefToken?.let { token ->
+            scope.launch {
+                connection.updateToken(token)
+            }
+        }
+    }
+
+    /**
+     * Starts the push service provided.
+     */
+    override fun initialize() { service.start(context) }
+
+    /**
+     * Un-subscribes from all push message channels and stops the push service.
+     * This should only be done on an account logout or app data deletion.
+     */
+    override fun shutdown() {
+        service.stop()
+
+        DeliveryManager.with(connection) {
+            scope.launch {
+                // TODO replace with unsubscribeAll API when available
+                PushType.values().forEach { type ->
+                    unsubscribe(type.toChannelId())
+                }
+                job.cancel()
+            }
+        }
+    }
+
+    /**
+     * New registration tokens are received and sent to the Autopush server which also performs subscriptions for
+     * each push type and notifies the subscribers.
+     */
+    override fun onNewToken(newToken: String) {
+        scope.launchAndTry {
+            connection.updateToken(newToken)
+
+            // Subscribe all only if this is the first time.
+            if (prefToken.isNullOrEmpty()) {
+                subscribeAll()
+            }
+
+            putPreference(context, PREF_TOKEN, newToken)
+        }
+    }
+
+    /**
+     * New encrypted messages received from a supported push messaging service.
+     */
+    override fun onMessageReceived(message: EncryptedPushMessage) {
+        scope.launchAndTry {
+            val type = DeliveryManager.serviceForChannelId(message.channelId)
+            DeliveryManager.with(connection) {
+                val decrypted = decrypt(
+                    channelId = message.channelId,
+                    body = message.body,
+                    encoding = message.encoding,
+                    salt = message.salt,
+                    cryptoKey = message.cryptoKey
+                )
+                messageObserverBus.notifyObservers(type, String(decrypted))
+            }
+        }
+    }
+
+    override fun onError(error: PushError) {
+        // Only log errors for now.
+        logger.error("${error.javaClass.simpleName} error: ${error.desc}")
+    }
+
+    /**
+     * Register to receive push subscriptions when requested or when they have been re-registered.
+     */
+    fun registerForSubscriptions(
+        observer: PushSubscriptionObserver,
+        owner: LifecycleOwner,
+        autoPause: Boolean
+    ) = subscriptionObservers.register(observer, owner, autoPause)
+
+    /**
+     * Register to receive push messages for the associated [PushType].
+     */
+    fun registerForPushMessages(
+        type: PushType,
+        observer: Bus.Observer<PushType, String>,
+        owner: LifecycleOwner,
+        autoPause: Boolean
+    ) = messageObserverBus.register(type, observer, owner, autoPause)
+
+    /**
+     * Notifies observers about the subscription information for the push type if available.
+     */
+    fun subscribeForType(type: PushType) {
+        DeliveryManager.with(connection) {
+            scope.launchAndTry {
+                val sub = subscribe(type.toChannelId()).toPushSubscription()
+                subscriptionObservers.notifyObservers { onSubscriptionAvailable(sub) }
+            }
+        }
+    }
+
+    /**
+     * Returns subscription information for the push type if available.
+     */
+    internal fun unsubscribeForType(type: PushType) {
+        DeliveryManager.with(connection) {
+            scope.launchAndTry {
+                unsubscribe(type.toChannelId())
+            }
+        }
+    }
+
+    /**
+     * Returns all subscription for the push type if available.
+     */
+    fun subscribeAll() {
+        DeliveryManager.with(connection) {
+            scope.launchAndTry {
+                PushType.values().forEach { type ->
+                    val sub = subscribe(type.toChannelId()).toPushSubscription()
+                    subscriptionObservers.notifyObservers { onSubscriptionAvailable(sub) }
+                }
+            }
+        }
+    }
+
+    internal fun CoroutineScope.launchAndTry(block: suspend CoroutineScope.() -> Unit) {
+        job = launch {
+            try {
+                block()
+            } catch (e: RustPushError) {
+                onError(PushError.Rust(e.toString()))
+            }
+        }
+    }
+
+    private fun putPreference(context: Context, key: String, value: String) {
+        preferences(context).edit().putString(key, value).apply()
+    }
+
+    private fun preferences(context: Context): SharedPreferences =
+        context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_PRIVATE)
+
+    companion object {
+        internal const val PREFERENCE_NAME = "mozac_feature_push"
+        internal const val PREF_TOKEN = "token"
+        internal const val DB_NAME = "push.sqlite"
+    }
+}
+
+/**
+ * The different kind of message types that a [EncryptedPushMessage] can be:
+ *  - Application Services (e.g. FxA/Send Tab)
+ *  - WebPush messages (see: https://www.w3.org/TR/push-api/)
+ */
+enum class PushType {
+    Services,
+    WebPush;
+
+    /**
+     * Retrieve a channel ID from the PushType.
+     *
+     * This is a reproducible UUID that is used for mapping a push message type with the push manager.
+     */
+    fun toChannelId() = UUID.nameUUIDFromBytes(name.toByteArray()).toString().replace("-", "")
+}
+
+/**
+ * Observers that want to receive updates for new subscriptions.
+ */
+interface PushSubscriptionObserver {
+    fun onSubscriptionAvailable(subscription: AutoPushSubscription)
+}
+
+/**
+ * This is manager mapping of service type to channel ID, it will eventually be replaced by the
+ * Application Service implementation.
+ */
+internal object DeliveryManager {
+    fun serviceForChannelId(channelId: String): PushType {
+        return PushType.values().first { it.toChannelId() == channelId }
+    }
+
+    /**
+     * Executes the block if the Push Manager is initialized.
+     */
+    fun with(connection: PushConnection, block: PushConnection.() -> Unit) {
+        if (connection.isInitialized()) {
+            block(connection)
+        }
+    }
+}
+
+/**
+ * Supported push services.
+ */
+enum class ServiceType {
+    FCM,
+    ADM
+}
+
+/**
+ * Supported network protocols.
+ */
+enum class Protocol {
+    HTTP,
+    HTTPS
+}
+
+/**
+ * The subscription information from Autopush that can be used to send push messages to other devices.
+ */
+data class AutoPushSubscription(val type: PushType, val endpoint: String, val publicKey: String, val authKey: String)
+
+/**
+ * Configuration object for initializing the Push Manager.
+ */
+data class PushConfig(
+    val senderId: String,
+    val serverHost: String = "push.service.mozilla.com",
+    val protocol: Protocol = Protocol.HTTPS,
+    val serviceType: ServiceType = ServiceType.FCM
+)
+
+/**
+ * A helper to convert the internal data class.
+ */
+internal fun SubscriptionResponse.toPushSubscription(): AutoPushSubscription {
+    val type = DeliveryManager.serviceForChannelId(channelID)
+    return AutoPushSubscription(
+        type = type,
+        endpoint = subscriptionInfo.endpoint,
+        authKey = subscriptionInfo.keys.auth,
+        publicKey = subscriptionInfo.keys.p256dh
+    )
+}
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
new file mode 100644
index 000000000000..abe71c2b161f
--- /dev/null
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
@@ -0,0 +1,129 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import androidx.annotation.GuardedBy
+import androidx.annotation.VisibleForTesting
+import mozilla.appservices.push.BridgeType
+import mozilla.appservices.push.PushAPI
+import mozilla.appservices.push.PushManager
+import mozilla.appservices.push.SubscriptionResponse
+import java.io.Closeable
+
+/**
+ * An interface that wraps the [PushAPI].
+ *
+ * This aides in testing and abstracting out the hurdles of initialization checks required before performing actions
+ * on the API.
+ */
+interface PushConnection : Closeable {
+    suspend fun subscribe(channelId: String, scope: String = ""): SubscriptionResponse
+    suspend fun unsubscribe(channelId: String): Boolean
+    suspend fun unsubscribeAll(): Boolean
+    suspend fun updateToken(token: String): Boolean
+    suspend fun verifyConnection(): Boolean
+    fun decrypt(
+        channelId: String,
+        body: String,
+        encoding: String = "",
+        salt: String = "",
+        cryptoKey: String = ""
+    ): ByteArray
+    fun isInitialized(): Boolean
+}
+
+internal class RustPushConnection(
+    private val databasePath: String,
+    private val senderId: String,
+    private val serverHost: String,
+    private val socketProtocol: Protocol,
+    private val serviceType: ServiceType
+) : PushConnection {
+
+    @VisibleForTesting
+    internal var api: PushAPI? = null
+
+    @GuardedBy("this")
+    override suspend fun subscribe(channelId: String, scope: String): SubscriptionResponse = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        return pushApi.subscribe(channelId, scope)
+    }
+
+    @GuardedBy("this")
+    override suspend fun unsubscribe(channelId: String): Boolean = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        return pushApi.unsubscribe(channelId)
+    }
+
+    @GuardedBy("this")
+    override suspend fun unsubscribeAll(): Boolean = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        // TODO replace with unsubscribeAll when API exists
+        return pushApi.unsubscribe("")
+    }
+
+    @GuardedBy("this")
+    override suspend fun updateToken(token: String): Boolean = synchronized(this) {
+        val pushApi = api
+        if (pushApi == null) {
+            api = PushManager(
+                senderId = senderId,
+                serverHost = serverHost,
+                httpProtocol = socketProtocol.asString(),
+                bridgeType = serviceType.toBridgeType(),
+                registrationId = token,
+                databasePath = databasePath
+            )
+            return true
+        }
+        return pushApi.update(token)
+    }
+
+    @GuardedBy("this")
+    override suspend fun verifyConnection(): Boolean = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        pushApi.verifyConnection()
+    }
+
+    @GuardedBy("this")
+    override fun decrypt(
+        channelId: String,
+        body: String,
+        encoding: String,
+        salt: String,
+        cryptoKey: String
+    ): ByteArray = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        return pushApi.decrypt(channelID = channelId, body = body, encoding = encoding, salt = salt, dh = cryptoKey)
+    }
+
+    @GuardedBy("this")
+    override fun close() = synchronized(this) {
+        val pushApi = api
+        check(pushApi != null) { "Rust API is not initiated; updateToken hasn't been called yet." }
+        pushApi.close()
+    }
+
+    override fun isInitialized() = api != null
+}
+
+/**
+ * Helper function to get the corresponding support [BridgeType] from the support set.
+ */
+@VisibleForTesting
+internal fun ServiceType.toBridgeType() = when (this) {
+    ServiceType.FCM -> BridgeType.FCM
+    ServiceType.ADM -> BridgeType.ADM
+}
+
+@VisibleForTesting
+internal fun Protocol.asString() = name.toLowerCase()
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/MessageBus.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/MessageBus.kt
new file mode 100644
index 000000000000..0e546bfaa416
--- /dev/null
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/MessageBus.kt
@@ -0,0 +1,76 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import androidx.lifecycle.LifecycleOwner
+import mozilla.components.concept.push.Bus
+import mozilla.components.support.base.observer.ObserverRegistry
+
+typealias Registry<T, M> = ObserverRegistry<Bus.Observer<T, M>>
+
+/**
+ * An implementation of [Bus] where the event type is restricted to an enum.
+ */
+class MessageBus<T : Enum<T>, M> : Bus<T, M> {
+
+    private val bus: HashMap<T, Registry<T, M>> = hashMapOf()
+
+    override fun register(type: T, observer: Bus.Observer<T, M>) {
+        synchronized(bus) {
+            val registry = bus[type]
+
+            if (registry != null) {
+                registry.register(observer)
+                return
+            }
+
+            val newRegistry = Registry<T, M>()
+            newRegistry.register(observer)
+            bus[type] = newRegistry
+        }
+    }
+
+    override fun register(type: T, observer: Bus.Observer<T, M>, owner: LifecycleOwner, autoPause: Boolean) {
+        synchronized(bus) {
+            val registry = bus[type]
+
+            if (registry != null) {
+                registry.register(observer, owner, autoPause)
+                return
+            }
+
+            val newRegistry = Registry<T, M>()
+            newRegistry.register(observer, owner, autoPause)
+            bus[type] = newRegistry
+        }
+    }
+
+    override fun unregister(type: T, observer: Bus.Observer<T, M>) {
+        runOnRegistryOfType(type) { registry ->
+            registry.unregister(observer)
+
+            if (!registry.isObserved()) {
+                bus.remove(type)
+            }
+        }
+    }
+
+    override fun notifyObservers(type: T, message: M) {
+        runOnRegistryOfType(type) { bus ->
+            bus.notifyObservers { onEvent(type, message) }
+        }
+    }
+
+    private inline fun runOnRegistryOfType(type: T, block: (Registry<T, M>) -> Unit) {
+        synchronized(bus) {
+            val registry = bus[type]
+            if (registry != null) {
+                block(registry)
+            }
+        }
+    }
+}
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureKtTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureKtTest.kt
new file mode 100644
index 000000000000..c8872481507e
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureKtTest.kt
@@ -0,0 +1,44 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import mozilla.appservices.push.KeyInfo
+import mozilla.appservices.push.SubscriptionInfo
+import mozilla.appservices.push.SubscriptionResponse
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class AutoPushFeatureKtTest {
+    @Test
+    fun `transform response to PushSubscription`() {
+        val response = SubscriptionResponse(
+            "992a0f0542383f1ea5ef51b7cf4ae6c4",
+            SubscriptionInfo("https://mozilla.com", KeyInfo("123", "456"))
+        )
+        val sub = response.toPushSubscription()
+
+        assertEquals(PushType.Services, sub.type)
+        assertEquals(response.subscriptionInfo.endpoint, sub.endpoint)
+        assertEquals(response.subscriptionInfo.keys.auth, sub.authKey)
+        assertEquals(response.subscriptionInfo.keys.p256dh, sub.publicKey)
+    }
+
+    @Test
+    fun `asserts PushConfig's default values`() {
+        val config = PushConfig("sample-browser")
+        assertEquals("sample-browser", config.senderId)
+        assertEquals("push.service.mozilla.com", config.serverHost)
+        assertEquals(Protocol.HTTPS, config.protocol)
+        assertEquals(ServiceType.FCM, config.serviceType)
+
+        val config2 = PushConfig("sample-browser", "push.test.mozilla.com", Protocol.HTTP, ServiceType.ADM)
+        assertEquals("sample-browser", config2.senderId)
+        assertEquals("push.test.mozilla.com", config2.serverHost)
+        assertEquals(Protocol.HTTP, config2.protocol)
+        assertEquals(ServiceType.ADM, config2.serviceType)
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt
new file mode 100644
index 000000000000..c188a405e520
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt
@@ -0,0 +1,261 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import android.content.Context
+import android.content.SharedPreferences
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LifecycleOwner
+import androidx.test.core.app.ApplicationProvider
+import kotlinx.coroutines.runBlocking
+import mozilla.appservices.push.KeyInfo
+import mozilla.appservices.push.SubscriptionInfo
+import mozilla.appservices.push.SubscriptionResponse
+import mozilla.components.concept.push.Bus
+import mozilla.components.concept.push.EncryptedPushMessage
+import mozilla.components.concept.push.PushService
+import mozilla.components.feature.push.AutoPushFeature.Companion.PREFERENCE_NAME
+import mozilla.components.feature.push.AutoPushFeature.Companion.PREF_TOKEN
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.anyString
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class AutoPushFeatureTest {
+
+    private val context: Context
+        get() = ApplicationProvider.getApplicationContext()
+
+    @Before
+    fun setup() {
+        preference(context)
+            .edit()
+            .clear()
+            .apply()
+    }
+
+    @Test
+    fun `initialize starts push service`() {
+        val service: PushService = mock()
+        val config = PushConfig("push-test")
+        val feature = AutoPushFeature(context, service, config)
+
+        feature.initialize()
+
+        verify(service).start(context)
+    }
+
+    @Test
+    fun `updateToken not called if no token in prefs`() {
+        val connection: PushConnection = spy(TestPushConnection())
+
+        spy(AutoPushFeature(context, mock(), mock(), connection = connection))
+
+        runBlocking {
+            verify(connection, never()).updateToken(anyString())
+        }
+    }
+
+    @Test
+    fun `updateToken called if token is in prefs`() {
+        val connection: PushConnection = spy(TestPushConnection())
+
+        preference(context).edit().putString(PREF_TOKEN, "token").apply()
+
+        spy(AutoPushFeature(context, mock(), mock(), connection = connection))
+
+        runBlocking {
+            verify(connection).updateToken("token")
+        }
+    }
+
+    @Test
+    fun `shutdown stops service and unsubscribes all`() {
+        val service: PushService = mock()
+        val connection: PushConnection = mock()
+        `when`(connection.isInitialized()).thenReturn(true)
+        val feature = runBlocking {
+            spy(AutoPushFeature(context, service, mock(), coroutineContext, connection)).also {
+                it.shutdown()
+            }
+        }
+        runBlocking {
+            verify(service).stop()
+            verify(connection, times(PushType.values().size)).unsubscribe(anyString())
+            assertTrue(feature.job.isCancelled)
+        }
+    }
+
+    @Test
+    fun `onNewToken updates connection and saves pref`() {
+        val connection: PushConnection = mock()
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+
+            feature.onNewToken("token")
+        }
+        runBlocking {
+            verify(connection).updateToken("token")
+        }
+        val pref = preference(context).getString(PREF_TOKEN, null)
+        assertNotNull(pref)
+        assertEquals("token", pref)
+    }
+
+    @Ignore
+    @Test
+    fun `onNewToken updates subscriptions based on pref`() {
+        val connection: PushConnection = spy(TestPushConnection(true))
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+
+            feature.onNewToken("token")
+            verify(feature).subscribeAll()
+
+            feature.onNewToken("token")
+            verify(feature, never()).subscribeAll()
+        }
+    }
+
+    @Test
+    fun `onMessageReceived decrypts message and notifies observers`() {
+        val connection: PushConnection = mock()
+        val encryptedMessage: EncryptedPushMessage = mock()
+        val owner: LifecycleOwner = mock()
+        val lifecycle: Lifecycle = mock()
+        `when`(owner.lifecycle).thenReturn(lifecycle)
+        `when`(lifecycle.currentState).thenReturn(Lifecycle.State.STARTED)
+        `when`(connection.isInitialized()).thenReturn(true)
+        `when`(encryptedMessage.channelId).thenReturn("992a0f0542383f1ea5ef51b7cf4ae6c4")
+        `when`(connection.decrypt(any(), any(), any(), any(), any())).thenReturn("test".toByteArray())
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+
+            feature.registerForPushMessages(PushType.Services, object : Bus.Observer<PushType, String> {
+                override fun onEvent(type: PushType, message: String) {
+                    assertEquals("test", message)
+                }
+            }, owner, true)
+
+            feature.onMessageReceived(encryptedMessage)
+        }
+    }
+
+    @Test
+    fun `subscribeForType notifies observers`() {
+        val connection: PushConnection = spy(TestPushConnection(true))
+        val owner: LifecycleOwner = mock()
+        val lifecycle: Lifecycle = mock()
+        `when`(owner.lifecycle).thenReturn(lifecycle)
+        `when`(lifecycle.currentState).thenReturn(Lifecycle.State.STARTED)
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+
+            feature.registerForSubscriptions(object : PushSubscriptionObserver {
+                override fun onSubscriptionAvailable(subscription: AutoPushSubscription) {
+                    assertEquals(PushType.Services, subscription.type)
+                }
+            }, owner, true)
+
+            feature.subscribeForType(PushType.Services)
+        }
+    }
+
+    @Test
+    fun `unsubscribeForType calls rust layer`() {
+        val connection: PushConnection = mock()
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+            feature.unsubscribeForType(PushType.Services)
+        }
+
+        runBlocking {
+            verify(connection, never()).unsubscribe(anyString())
+        }
+
+        `when`(connection.isInitialized()).thenReturn(true)
+
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+            feature.unsubscribeForType(PushType.Services)
+        }
+
+        runBlocking {
+            verify(connection).unsubscribe(anyString())
+        }
+    }
+
+    @Test
+    fun `subscribeAll notifies observers`() {
+        val connection: PushConnection = spy(TestPushConnection(true))
+        val owner: LifecycleOwner = mock()
+        val lifecycle: Lifecycle = mock()
+        `when`(owner.lifecycle).thenReturn(lifecycle)
+        `when`(lifecycle.currentState).thenReturn(Lifecycle.State.STARTED)
+        `when`(connection.isInitialized()).thenReturn(true)
+        runBlocking {
+            val feature = spy(AutoPushFeature(context, mock(), mock(), coroutineContext, connection))
+
+            feature.registerForSubscriptions(object : PushSubscriptionObserver {
+                override fun onSubscriptionAvailable(subscription: AutoPushSubscription) {
+                    assertEquals(PushType.Services, subscription.type)
+                }
+            }, owner, true)
+
+            feature.subscribeAll()
+        }
+    }
+
+    private fun preference(context: Context): SharedPreferences {
+        return context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_PRIVATE)
+    }
+
+    class TestPushConnection(private val init: Boolean = false) : PushConnection {
+        override suspend fun subscribe(channelId: String, scope: String) =
+            SubscriptionResponse(
+                "992a0f0542383f1ea5ef51b7cf4ae6c4",
+                SubscriptionInfo("https://foo", KeyInfo("auth", "p256dh"))
+            )
+
+        override suspend fun unsubscribe(channelId: String): Boolean = true
+
+        override suspend fun unsubscribeAll(): Boolean = true
+
+        override suspend fun updateToken(token: String) = true
+
+        override suspend fun verifyConnection(): Boolean {
+            TODO("not implemented")
+        }
+
+        override fun decrypt(
+            channelId: String,
+            body: String,
+            encoding: String,
+            salt: String,
+            cryptoKey: String
+        ): ByteArray {
+            TODO("not implemented")
+        }
+
+        override fun isInitialized() = init
+
+        override fun close() {}
+    }
+}
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/ConnectionKtTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/ConnectionKtTest.kt
new file mode 100644
index 000000000000..34cf483df28b
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/ConnectionKtTest.kt
@@ -0,0 +1,25 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import mozilla.appservices.push.BridgeType
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class ConnectionKtTest {
+    @Test
+    fun `ServiceType to BridgeType`() {
+        assertEquals(BridgeType.FCM, ServiceType.FCM.toBridgeType())
+        assertEquals(BridgeType.ADM, ServiceType.ADM.toBridgeType())
+    }
+
+    @Test
+    fun `Protocol to string`() {
+        assertEquals("http", Protocol.HTTP.asString())
+        assertEquals("https", Protocol.HTTPS.asString())
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/DeliveryManagerTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/DeliveryManagerTest.kt
new file mode 100644
index 000000000000..dd5477cb411a
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/DeliveryManagerTest.kt
@@ -0,0 +1,44 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.mockito.Mockito.`when`
+
+class DeliveryManagerTest {
+
+    @Test
+    fun `serviceType found for PushType`() {
+        val pushType = DeliveryManager.serviceForChannelId("992a0f0542383f1ea5ef51b7cf4ae6c4")
+        assertEquals(PushType.Services, pushType)
+    }
+
+    @Test(expected = NoSuchElementException::class)
+    fun `exception thrown if serviceType not found`() {
+        DeliveryManager.serviceForChannelId("992a0f0542383f1ea5ef51b7cf4ea6c4")
+    }
+
+    @Test
+    fun `DeliveryManager executes block with initialized connection`() {
+        val connection: PushConnection = mock()
+        var invoked = false
+
+        DeliveryManager.with(connection) { invoked = true }
+
+        assertFalse(invoked)
+
+        `when`(connection.isInitialized()).thenReturn(true)
+
+        DeliveryManager.with(connection) { invoked = true }
+
+        assertTrue(invoked)
+    }
+}
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/MessageBusTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/MessageBusTest.kt
new file mode 100644
index 000000000000..5eeaabed7afb
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/MessageBusTest.kt
@@ -0,0 +1,241 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LifecycleObserver
+import androidx.lifecycle.LifecycleOwner
+import mozilla.components.concept.push.Bus
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class MessageBusTest {
+
+    @Test
+    fun `register adds a new registry`() {
+        val bus = MessageBus<TestType, String>()
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+            }
+        })
+
+        bus.notifyObservers(TestType.FIRST, "test")
+    }
+
+    @Test
+    fun `register multiple observers to a registry`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        })
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        })
+
+        bus.notifyObservers(TestType.FIRST, "test")
+        assertEquals(2, count)
+    }
+
+    @Test
+    fun `register with lifecycle owner adds a new register`() {
+        val bus = MessageBus<TestType, String>()
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+    }
+
+    @Test
+    fun `register with lifecycle owner and multiple observers to a register`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+        assertEquals(2, count)
+    }
+
+    @Test
+    fun `observer on one registry does not notify another`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.register(TestType.SECOND, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                count++
+                throw IllegalStateException("this should never happen")
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        assertEquals(1, count)
+    }
+
+    @Test
+    fun `observer on separate registries notify both individually`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+
+        bus.register(TestType.FIRST, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.register(TestType.SECOND, object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test2", message)
+                count++
+            }
+        }, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+        bus.notifyObservers(TestType.SECOND, "test2")
+
+        assertEquals(2, count)
+    }
+
+    @Test
+    fun `unregister removes observer from registry`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+        val observer = object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }
+
+        bus.register(TestType.FIRST, observer, MockedLifecycleOwner(MockedLifecycle(Lifecycle.State.STARTED)), false)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        bus.unregister(TestType.FIRST, observer)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        assertEquals(1, count)
+    }
+
+    @Test
+    fun `unregister removes only the specified observer from a registry`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+        val observer = object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }
+        val observer2 = object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }
+
+        bus.register(TestType.FIRST, observer)
+        bus.register(TestType.FIRST, observer2)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        bus.unregister(TestType.FIRST, observer)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        assertEquals(3, count)
+    }
+
+    @Test
+    fun `unregister removes only the specified observer from a specified registry`() {
+        val bus = MessageBus<TestType, String>()
+        var count = 0
+        val observer = object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }
+        val observer2 = object : Bus.Observer<TestType, String> {
+            override fun onEvent(type: TestType, message: String) {
+                assertEquals("test", message)
+                count++
+            }
+        }
+
+        bus.register(TestType.FIRST, observer)
+        bus.register(TestType.SECOND, observer2)
+
+        bus.notifyObservers(TestType.FIRST, "test")
+
+        bus.unregister(TestType.FIRST, observer)
+
+        bus.notifyObservers(TestType.SECOND, "test")
+
+        assertEquals(2, count)
+    }
+
+    private class MockedLifecycle(var state: State) : Lifecycle() {
+        var observer: LifecycleObserver? = null
+
+        override fun addObserver(observer: LifecycleObserver) {
+            this.observer = observer
+        }
+
+        override fun removeObserver(observer: LifecycleObserver) {
+            this.observer = null
+        }
+
+        override fun getCurrentState(): State = state
+    }
+
+    private class MockedLifecycleOwner(private val lifecycle: MockedLifecycle) : LifecycleOwner {
+        override fun getLifecycle(): Lifecycle = lifecycle
+    }
+
+    enum class TestType {
+        FIRST,
+        SECOND
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/PushTypeTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/PushTypeTest.kt
new file mode 100644
index 000000000000..cc2b04e8de8d
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/PushTypeTest.kt
@@ -0,0 +1,23 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class PushTypeTest {
+
+    @Test
+    fun `channelId never changes for Services`() {
+        assertEquals("992a0f0542383f1ea5ef51b7cf4ae6c4", PushType.Services.toChannelId())
+    }
+
+    @Test
+    fun `channelId never changes for WebPush`() {
+        assertEquals("97a36501975938cea04e226e39dacb55", PushType.WebPush.toChannelId())
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt
new file mode 100644
index 000000000000..b5c13bcc394b
--- /dev/null
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/RustPushConnectionTest.kt
@@ -0,0 +1,207 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+package mozilla.components.feature.push
+
+import kotlinx.coroutines.runBlocking
+import mozilla.appservices.push.PushAPI
+import mozilla.components.support.test.eq
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Ignore
+import org.junit.Test
+import org.mockito.Mockito.anyString
+import org.mockito.Mockito.verify
+
+class RustPushConnectionTest {
+
+    @Ignore("Requires push-forUnitTests; seems unnecessary to introduce it for this one test.")
+    @Test
+    fun `new token initializes API`() {
+        val connection = createConnection()
+
+        assertNull(connection.api)
+
+        runBlocking {
+            connection.updateToken("token")
+        }
+
+        assertNotNull(connection.api)
+    }
+
+    @Test
+    fun `new token calls update if API is already initialized`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.updateToken("123")
+        }
+
+        verify(api).update(anyString())
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `subscribe throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.subscribe("123", "")
+        }
+    }
+
+    @Test
+    fun `subscribe calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.subscribe("123", "")
+        }
+
+        verify(api).subscribe(anyString(), anyString())
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `unsubscribe throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.unsubscribe("123")
+        }
+    }
+
+    @Test
+    fun `unsubscribe calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.unsubscribe("123")
+        }
+
+        verify(api).unsubscribe(anyString())
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `unsubscribeAll throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.unsubscribeAll()
+        }
+    }
+
+    @Test
+    fun `unsubscribeAll calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.unsubscribeAll()
+        }
+
+        verify(api).unsubscribe("")
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `verifyConnection throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.verifyConnection()
+        }
+    }
+
+    @Test
+    fun `verifyConnection calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.verifyConnection()
+        }
+
+        verify(api).verifyConnection()
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `decrypt throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.decrypt("123", "plain text")
+        }
+    }
+
+    @Test
+    fun `decrypt calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.decrypt("123", "body")
+        }
+
+        verify(api).decrypt(anyString(), anyString(), eq(""), eq(""), eq(""))
+
+        runBlocking {
+            connection.decrypt("123", "body", "enc", "salt", "key")
+        }
+
+        verify(api).decrypt(anyString(), anyString(), eq("enc"), eq("salt"), eq("key"))
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `close throws if API is not initialized first`() {
+        val connection = createConnection()
+
+        runBlocking {
+            connection.close()
+        }
+    }
+
+    @Test
+    fun `close calls Rust API`() {
+        val connection = createConnection()
+        val api: PushAPI = mock()
+        connection.api = api
+
+        runBlocking {
+            connection.close()
+        }
+
+        verify(api).close()
+    }
+
+    @Test
+    fun `initialized is true when api is not null`() {
+        val connection = createConnection()
+
+        assertFalse(connection.isInitialized())
+
+        connection.api = mock()
+
+        assertTrue(connection.isInitialized())
+    }
+
+    private fun createConnection() = RustPushConnection(
+        "/sdcard/",
+        "push-test",
+        "push.mozilla.com",
+        Protocol.HTTPS,
+        ServiceType.FCM
+    )
+}
diff --git a/android-components/components/feature/push/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/feature/push/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 000000000000..cf1c399ea81e
--- /dev/null
+++ b/android-components/components/feature/push/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1,2 @@
+mock-maker-inline
+// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/tabstray/TabsTrayPresenterTest.kt b/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/tabstray/TabsTrayPresenterTest.kt
index 20c192f47cbd..e1233679eb8e 100644
--- a/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/tabstray/TabsTrayPresenterTest.kt
+++ b/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/tabstray/TabsTrayPresenterTest.kt
@@ -293,6 +293,8 @@ private class MockedTabsTray : TabsTray {
 
     override fun <R> wrapConsumers(block: TabsTray.Observer.(R) -> Boolean): List<(R) -> Boolean> = emptyList()
 
+    override fun isObserved(): Boolean = false
+
     override fun pauseObserver(observer: TabsTray.Observer) {}
 
     override fun resumeObserver(observer: TabsTray.Observer) {}
diff --git a/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/Observable.kt b/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/Observable.kt
index 36f6dd3d9271..a44b27d30b9e 100644
--- a/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/Observable.kt
+++ b/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/Observable.kt
@@ -87,4 +87,9 @@ interface Observable<T> {
      * Returns a list of lambdas wrapping a consuming method of an observer.
      */
     fun <R> wrapConsumers(block: T.(R) -> Boolean): List<(R) -> Boolean>
+
+    /**
+     * If the observable has registered observers.
+     */
+    fun isObserved(): Boolean
 }
diff --git a/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/ObserverRegistry.kt b/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/ObserverRegistry.kt
index 1c7308074232..e0502543001d 100644
--- a/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/ObserverRegistry.kt
+++ b/android-components/components/support/base/src/main/java/mozilla/components/support/base/observer/ObserverRegistry.kt
@@ -132,6 +132,12 @@ class ObserverRegistry<T> : Observable<T> {
         return consumers
     }
 
+    override fun isObserved(): Boolean {
+        synchronized(observers) {
+            return !observers.isEmpty()
+        }
+    }
+
     /**
      * LifecycleObserver implementation to bind an observer to a Lifecycle.
      */
diff --git a/android-components/components/support/base/src/test/java/mozilla/components/support/base/observer/ObserverRegistryTest.kt b/android-components/components/support/base/src/test/java/mozilla/components/support/base/observer/ObserverRegistryTest.kt
index 0daad208c77d..a17ceb017cde 100644
--- a/android-components/components/support/base/src/test/java/mozilla/components/support/base/observer/ObserverRegistryTest.kt
+++ b/android-components/components/support/base/src/test/java/mozilla/components/support/base/observer/ObserverRegistryTest.kt
@@ -430,6 +430,22 @@ class ObserverRegistryTest {
         assertEquals(0, observer.notified.size)
     }
 
+    @Test
+    fun `isObserved is true if observers is empty`() {
+        val registry = spy(ObserverRegistry<TestIntObserver>())
+        val observer = TestIntObserver()
+
+        assertFalse(registry.isObserved())
+
+        registry.register(observer)
+
+        assertTrue(registry.isObserved())
+
+        registry.unregister(observer)
+
+        assertFalse(registry.isObserved())
+    }
+
     private class TestObserver {
         var notified: Boolean = false
 
diff --git a/android-components/settings.gradle b/android-components/settings.gradle
index 05dfe88dd797..a894a1d65dd6 100644
--- a/android-components/settings.gradle
+++ b/android-components/settings.gradle
@@ -69,6 +69,7 @@ if (localProperties != null) {
                 substitute module('org.mozilla.appservices:logins') with project(':logins-library')
                 substitute module('org.mozilla.appservices:places') with project(':places-library')
                 substitute module('org.mozilla.appservices:rustlog') with project(':rustlog-library')
+                substitute module('org.mozilla.appservices:push') with project(':push-library')
             }
         }
 
