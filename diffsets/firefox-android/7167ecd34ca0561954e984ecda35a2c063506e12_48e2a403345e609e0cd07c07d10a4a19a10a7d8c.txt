diff --git a/focus-android/app/build.gradle b/focus-android/app/build.gradle
index ce42306f6be8..c43db8cc681c 100644
--- a/focus-android/app/build.gradle
+++ b/focus-android/app/build.gradle
@@ -154,6 +154,7 @@ dependencies {
     compileOnly 'net.jcip:jcip-annotations:1.0'
     implementation("com.google.code.findbugs:jsr305:3.0.2")
 
+    implementation "org.mozilla.components:browser-engine-gecko:$mozilla_components_version"
     implementation "org.mozilla.components:browser-domains:$mozilla_components_version"
     implementation "org.mozilla.components:browser-errorpages:$mozilla_components_version"
     implementation "org.mozilla.components:browser-search:$mozilla_components_version"
@@ -162,6 +163,12 @@ dependencies {
     implementation "org.mozilla.components:concept-engine:$mozilla_components_version"
     implementation "org.mozilla.components:concept-fetch:$mozilla_components_version"
     implementation "org.mozilla.components:feature-customtabs:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-contextmenu:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-downloads:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-findinpage:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-prompts:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-session:$mozilla_components_version"
+    implementation "org.mozilla.components:feature-tabs:$mozilla_components_version"
     implementation "org.mozilla.components:lib-crash:$mozilla_components_version"
     implementation "org.mozilla.components:lib-fetch-httpurlconnection:$mozilla_components_version"
     implementation "org.mozilla.components:service-telemetry:$mozilla_components_version_telemetry"
@@ -177,8 +184,6 @@ dependencies {
     focusImplementation 'com.adjust.sdk:adjust-android:4.11.4'
     focusImplementation 'com.android.installreferrer:installreferrer:1.1' // Required by Adjust
 
-    implementation "org.mozilla.components:browser-engine-gecko:$mozilla_components_version"
-    implementation "org.mozilla.geckoview:geckoview:$gecko_release_version"
     implementation "androidx.palette:palette:$support_libraries_version"
 
     testImplementation "org.junit.jupiter:junit-jupiter-api:5.3.1"
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AccessAboutAndYourRightsPagesTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AccessAboutAndYourRightsPagesTest.java
index 9cc33e2524f9..315163e9dd9c 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AccessAboutAndYourRightsPagesTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AccessAboutAndYourRightsPagesTest.java
@@ -15,6 +15,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,6 +37,7 @@
 // This test visits each page and checks whether some essential elements are being displayed
 // https://testrail.stage.mozaws.net/index.php?/cases/view/81664
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class AccessAboutAndYourRightsPagesTest {
 
     @Rule
@@ -50,9 +52,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AddToHomescreenTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AddToHomescreenTest.java
index fa7b6e19a5e0..09999affb30c 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AddToHomescreenTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/AddToHomescreenTest.java
@@ -135,9 +135,6 @@ public void AddToHomeScreenTest() throws UiObjectNotFoundException {
         TestHelper.pressEnterKey();
         TestHelper.progressBar.waitForExists(waitingTime);
         Assert.assertTrue(TestHelper.progressBar.waitUntilGone(webPageLoadwaitingTime));
-        if (!AppConstants.INSTANCE.isGeckoBuild()) {
-            TestHelper.waitForWebSiteTitleLoad();
-        }
 
         openAddtoHSDialog();
         // Add to Home screen dialog is now shown
@@ -186,9 +183,6 @@ public void NonameTest() throws UiObjectNotFoundException {
         TestHelper.pressEnterKey();
         TestHelper.progressBar.waitForExists(waitingTime);
         Assert.assertTrue(TestHelper.progressBar.waitUntilGone(webPageLoadwaitingTime));
-        if (!AppConstants.INSTANCE.isGeckoBuild()) {
-            TestHelper.waitForWebSiteTitleLoad();
-        }
 
         openAddtoHSDialog();
 
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/BadURLTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/BadURLTest.java
index fa9452e18d36..d088b8c3a4ee 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/BadURLTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/BadURLTest.java
@@ -17,6 +17,7 @@
 import androidx.test.uiautomator.UiSelector;
 
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -34,6 +35,7 @@
 // This test opens enters and invalid URL, and Focus should provide an appropriate error message
 @RunWith(AndroidJUnit4.class)
 @RequiresDevice
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class BadURLTest {
 
     @Rule
@@ -48,9 +50,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ChangeSearchEngineTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ChangeSearchEngineTest.java
index 5a1aa7eb4efd..aaec858cbf00 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ChangeSearchEngineTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ChangeSearchEngineTest.java
@@ -17,6 +17,7 @@
 import android.widget.RadioButton;
 
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,6 +47,7 @@
 // This test checks the search engine can be changed
 // https://testrail.stage.mozaws.net/index.php?/cases/view/47588
 @RunWith(Parameterized.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class ChangeSearchEngineTest {
     @Parameterized.Parameter
     public String mSearchEngine;
@@ -66,9 +68,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/CustomTabTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/CustomTabTest.java
index 51c6a3cdbe52..e3c8ce76c376 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/CustomTabTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/CustomTabTest.java
@@ -91,11 +91,6 @@ public void testCustomTabUI() {
             Context appContext = InstrumentationRegistry.getInstrumentation()
                     .getTargetContext()
                     .getApplicationContext();
-            if (!AppConstants.INSTANCE.isGeckoBuild()) {
-                onWebView()
-                        .withElement(findElement(Locator.ID, TEST_PAGE_HEADER_ID))
-                        .check(webMatches(getText(), equalTo(TEST_PAGE_HEADER_TEXT)));
-            }
 
             // Verify action button is visible
             onView(withContentDescription(ACTION_BUTTON_DESCRIPTION))
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/DownloadFileTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/DownloadFileTest.java
index 7222934fca29..ae0c420f2d8e 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/DownloadFileTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/DownloadFileTest.java
@@ -18,6 +18,7 @@
 
 import org.junit.After;
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,6 +34,7 @@
 import static org.mozilla.focus.helpers.TestHelper.waitingTime;
 
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 // https://testrail.stage.mozaws.net/index.php?/cases/view/53141
 public class DownloadFileTest {
     private static final String TEST_PATH = "/";
@@ -49,8 +51,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
             // This test is for API 25 and greater. see https://github.com/mozilla-mobile/focus-android/issues/2696
             org.junit.Assume.assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.N);
 
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ImageSelectTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ImageSelectTest.java
index 0e81a507a4c7..2218b872d638 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ImageSelectTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ImageSelectTest.java
@@ -20,6 +20,7 @@
 import junit.framework.Assert;
 
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,6 +40,7 @@
 import static org.mozilla.focus.helpers.TestHelper.waitingTime;
 
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class ImageSelectTest {
     private static final String TEST_PATH = "/";
 
@@ -78,9 +80,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/MultitaskingTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/MultitaskingTest.java
index f6d7d0a08ce1..6203ac3f8038 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/MultitaskingTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/MultitaskingTest.java
@@ -18,6 +18,7 @@
 import mozilla.components.browser.session.SessionManager;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,8 +26,6 @@
 import org.mozilla.focus.ext.ContextKt;
 import org.mozilla.focus.helpers.SessionLoadedIdlingResource;
 import org.mozilla.focus.helpers.TestHelper;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.web.IWebView;
 
 import okhttp3.mockwebserver.MockWebServer;
 
@@ -50,12 +49,12 @@
 import static org.mozilla.focus.helpers.EspressoHelper.onFloatingEraseButton;
 import static org.mozilla.focus.helpers.EspressoHelper.onFloatingTabsButton;
 import static org.mozilla.focus.helpers.TestHelper.createMockResponseFromAsset;
-import static org.mozilla.focus.helpers.WebViewFakeLongPress.injectHitTarget;
 
 /**
  * Open multiple sessions and verify that the UI looks like it should.
  */
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class MultitaskingTest {
 
     @Rule
@@ -70,10 +69,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeFalse(AppConstants.INSTANCE.isGeckoBuild());
-            org.junit.Assume.assumeFalse(AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
@@ -191,14 +186,9 @@ private void longPressLink(String id, String label, String path) {
                 .withElement(findElement(Locator.ID, id))
                 .check(webMatches(getText(), equalTo(label)));
 
-        simulateLinkLongPress(path);
-    }
-
-    // Webview only method
-    private void simulateLinkLongPress(String path) {
-        onView(withId(R.id.webview))
-                .perform(injectHitTarget(
-                        new IWebView.HitTarget(true, webServer.url(path).toString(), false, null)));
+        // Removed the following code since it depended on the IWebView abstraction that was removed
+        // in favor of the AC engine components.
+        // simulateLinkLongPress(path);
     }
 
     private void openInNewTab() {
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/PullDownToRefreshTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/PullDownToRefreshTest.java
deleted file mode 100644
index 2f27108ce4c0..000000000000
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/PullDownToRefreshTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.activity;
-
-import androidx.test.espresso.UiController;
-import androidx.test.espresso.ViewAction;
-import androidx.test.espresso.web.webdriver.Locator;
-import androidx.test.rule.ActivityTestRule;
-import androidx.test.runner.AndroidJUnit4;
-import android.view.View;
-
-import org.hamcrest.Matcher;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mozilla.focus.R;
-import org.mozilla.focus.helpers.MainActivityFirstrunTestRule;
-import org.mozilla.focus.helpers.TestHelper;
-
-import java.io.IOException;
-
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-
-import static androidx.test.espresso.Espresso.onView;
-import static androidx.test.espresso.action.ViewActions.click;
-import static androidx.test.espresso.action.ViewActions.pressImeActionButton;
-import static androidx.test.espresso.action.ViewActions.replaceText;
-import static androidx.test.espresso.action.ViewActions.swipeDown;
-import static androidx.test.espresso.assertion.ViewAssertions.matches;
-import static androidx.test.espresso.matcher.ViewMatchers.hasChildCount;
-import static androidx.test.espresso.matcher.ViewMatchers.hasFocus;
-import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
-import static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;
-import static androidx.test.espresso.matcher.ViewMatchers.withId;
-import static androidx.test.espresso.matcher.ViewMatchers.withText;
-import static androidx.test.espresso.web.assertion.WebViewAssertions.webMatches;
-import static androidx.test.espresso.web.sugar.Web.onWebView;
-import static androidx.test.espresso.web.webdriver.DriverAtoms.findElement;
-import static androidx.test.espresso.web.webdriver.DriverAtoms.getText;
-import static org.hamcrest.Matchers.containsString;
-
-
-// https://testrail.stage.mozaws.net/index.php?/cases/view/94146
-@RunWith(AndroidJUnit4.class)
-@Ignore("Pull to refresh is currently disabled in all builds")
-public class PullDownToRefreshTest {
-    private static final String COUNTER = "counter";
-    private static final String FIRST_TIME = "1";
-    private static final String SECOND_TIME = "2";
-
-    private MockWebServer webServer;
-    @Rule
-    public ActivityTestRule<MainActivity> mActivityTestRule = new MainActivityFirstrunTestRule(false);
-
-    @Before
-    public void setUpWebServer() throws IOException {
-        webServer = new MockWebServer();
-
-        // Test page
-        webServer.enqueue(new MockResponse().setBody(TestHelper.readTestAsset("counter.html")));
-        webServer.enqueue(new MockResponse().setBody(TestHelper.readTestAsset("counter.html")));
-    }
-
-    @After
-    public void tearDownWebServer() {
-        try {
-            webServer.close();
-            webServer.shutdown();
-        } catch (IOException e) {
-            throw new AssertionError("Could not stop web server", e);
-        }
-    }
-
-    @Test
-    public void pullDownToRefreshTest() {
-
-       onView(withId(R.id.urlView))
-                .check(matches(isDisplayed()))
-                .check(matches(hasFocus()))
-                .perform(click(), replaceText(webServer.url("/").toString()), pressImeActionButton());
-
-        onView(withId(R.id.display_url))
-                .check(matches(isDisplayed()))
-                .check(matches(withText(containsString(webServer.getHostName()))));
-
-        onWebView()
-                .withElement(findElement(Locator.ID, COUNTER))
-                .check(webMatches(getText(), containsString(FIRST_TIME)));
-
-        onView(withId(R.id.swipe_refresh))
-                .check(matches(isDisplayed()));
-
-        // Swipe down to refresh, spinner is shown (2nd child) and progress bar is shown
-        onView(withId(R.id.swipe_refresh))
-              .perform(withCustomConstraints(swipeDown(), isDisplayingAtLeast(85)))
-              .check(matches(hasChildCount(2)));
-
-        onWebView()
-                .withElement(findElement(Locator.ID, COUNTER))
-                .check(webMatches(getText(), containsString(SECOND_TIME)));
-    }
-
-    public static ViewAction withCustomConstraints(final ViewAction action, final Matcher<View> constraints) {
-        return new ViewAction() {
-            @Override
-            public Matcher<View> getConstraints() {
-                return constraints;
-            }
-
-            @Override
-            public String getDescription() {
-                return action.getDescription();
-            }
-
-            @Override
-            public void perform(UiController uiController, View view) {
-                action.perform(uiController, view);
-            }
-        };
-    }
-}
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ShareWebsiteTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ShareWebsiteTest.java
index 3b8777e8fdd1..f156961fbd56 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ShareWebsiteTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ShareWebsiteTest.java
@@ -16,6 +16,7 @@
 import androidx.test.uiautomator.UiSelector;
 
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,6 +36,7 @@
 // This test opens share menu
 // https://testrail.stage.mozaws.net/index.php?/cases/view/47592
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class ShareWebsiteTest {
     private static final String TEST_PATH = "/";
     private MockWebServer webServer;
@@ -51,9 +53,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.java
index 778a255bf43d..f80e1a4213a2 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/SwitchContextTest.java
@@ -20,6 +20,7 @@
 
 import org.junit.After;
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,6 +40,7 @@
 
 // This test opens enters and invalid URL, and Focus should provide an appropriate error message
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class SwitchContextTest {
 
     private static final String TEST_PATH = "/";
@@ -54,9 +56,6 @@ protected void beforeActivityLaunched() {
                     .getTargetContext()
                     .getApplicationContext();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             PreferenceManager.getDefaultSharedPreferences(appContext)
                     .edit()
                     .putBoolean(FIRSTRUN_PREF, true)
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ToggleBlockTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ToggleBlockTest.java
index f51a2ee8604e..733fc856bf45 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ToggleBlockTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/ToggleBlockTest.java
@@ -19,7 +19,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mozilla.focus.R;
-import org.mozilla.focus.exceptions.ExceptionDomains;
 import org.mozilla.focus.helpers.SessionLoadedIdlingResource;
 import org.mozilla.focus.helpers.TestHelper;
 
@@ -64,8 +63,6 @@ protected void beforeActivityLaunched() {
                     .putBoolean(FIRSTRUN_PREF, true)
                     .apply();
 
-            ExceptionDomains.INSTANCE.remove(appContext, ExceptionDomains.INSTANCE.load(appContext));
-
             // This test runs on both GV and WV.
             // Klar is used to test Geckoview. make sure it's set to Gecko
             TestHelper.selectGeckoForKlar();
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/URLExceptionTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/URLExceptionTest.java
index 6b45d34aba3e..f1f0187138f7 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/URLExceptionTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/activity/URLExceptionTest.java
@@ -21,7 +21,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mozilla.focus.R;
-import org.mozilla.focus.exceptions.ExceptionDomains;
 import org.mozilla.focus.helpers.TestHelper;
 
 import static androidx.test.espresso.Espresso.onView;
@@ -67,8 +66,6 @@ protected void beforeActivityLaunched() {
                     .putBoolean(FIRSTRUN_PREF, true)
                     .apply();
 
-            ExceptionDomains.INSTANCE.remove(appContext, ExceptionDomains.INSTANCE.load(appContext));
-
             // This test runs on both GV and WV.
             // Klar is used to test Geckoview. make sure it's set to Gecko
             TestHelper.selectGeckoForKlar();
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/MainActivityFirstrunTestRule.kt b/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/MainActivityFirstrunTestRule.kt
index e2a2dbc77dc8..4d905b8faefa 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/MainActivityFirstrunTestRule.kt
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/MainActivityFirstrunTestRule.kt
@@ -12,7 +12,6 @@ import mozilla.components.support.utils.ThreadUtils
 import org.mozilla.focus.activity.MainActivity
 import org.mozilla.focus.ext.components
 import org.mozilla.focus.fragment.FirstrunFragment.Companion.FIRSTRUN_PREF
-import org.mozilla.focus.session.removeAllAndCloseAllSessions
 
 open class MainActivityFirstrunTestRule(private val showFirstRun: Boolean) :
     ActivityTestRule<MainActivity>(MainActivity::class.java) {
@@ -39,6 +38,6 @@ open class MainActivityFirstrunTestRule(private val showFirstRun: Boolean) :
         val sessionManager =
             InstrumentationRegistry.getInstrumentation().targetContext.applicationContext.components.sessionManager
 
-        ThreadUtils.postToMainThread(Runnable { sessionManager.removeAllAndCloseAllSessions() })
+        ThreadUtils.postToMainThread(Runnable { sessionManager.removeAll() })
     }
 }
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/TestHelper.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/TestHelper.java
index d6c6ea614c1a..41f2a371d640 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/TestHelper.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/TestHelper.java
@@ -55,11 +55,7 @@ public static String getAppName() {
 
     // wait for web area to be visible
     public static void waitForWebContent() {
-        if (!AppConstants.INSTANCE.isGeckoBuild()) {
-            assertTrue(webView.waitForExists(waitingTime));
-        } else {
-            assertTrue(geckoView.waitForExists(waitingTime));
-        }
+        assertTrue(geckoView.waitForExists(waitingTime));
     }
 
     /********* First View Locators ***********/
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/WebViewFakeLongPress.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/WebViewFakeLongPress.java
deleted file mode 100644
index 1f31dc9c1f8d..000000000000
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/helpers/WebViewFakeLongPress.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.mozilla.focus.helpers;
-
-import androidx.test.espresso.UiController;
-import androidx.test.espresso.ViewAction;
-import androidx.test.espresso.matcher.ViewMatchers;
-import android.view.View;
-
-import org.hamcrest.Matcher;
-import org.mozilla.focus.R;
-import org.mozilla.focus.web.IWebView;
-import org.mozilla.focus.webview.SystemWebView;
-
-public class WebViewFakeLongPress implements ViewAction {
-    public static ViewAction injectHitTarget(IWebView.HitTarget hitTarget) {
-        return new WebViewFakeLongPress(hitTarget);
-    }
-
-    private IWebView.HitTarget hitTarget;
-
-    private WebViewFakeLongPress(IWebView.HitTarget hitTarget) {
-        this.hitTarget = hitTarget;
-    }
-
-    @Override
-    public Matcher<View> getConstraints() {
-        return ViewMatchers.withId(R.id.webview);
-    }
-
-    @Override
-    public String getDescription() {
-        return "Long pressing webview";
-    }
-
-    @Override
-    public void perform(UiController uiController, View view) {
-        final SystemWebView webView = (SystemWebView) view;
-
-        webView.getCallback()
-                .onLongPress(hitTarget);
-    }
-}
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/privacy/LocalSessionStorageTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/privacy/LocalSessionStorageTest.java
index 12f9da2c4c80..183d277dab65 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/privacy/LocalSessionStorageTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/privacy/LocalSessionStorageTest.java
@@ -17,6 +17,7 @@
 import junit.framework.Assert;
 
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,6 +36,7 @@
 import static org.mozilla.focus.helpers.TestHelper.waitingTime;
 
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class LocalSessionStorageTest {
     public static final String SESSION_STORAGE_HIT = "Session storage has value";
     public static final String LOCAL_STORAGE_MISS = "Local storage empty";
@@ -55,9 +57,6 @@ protected void beforeActivityLaunched() {
                     .putBoolean(FIRSTRUN_PREF, true)
                     .apply();
 
-            // This test is for webview only. Debug is defaulted to Webview, and Klar is used for GV testing.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() && !AppConstants.INSTANCE.isKlarBuild());
-
             webServer = new MockWebServer();
 
             try {
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/FirstRunScreenshots.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/FirstRunScreenshots.java
index 904be52b5ccd..fff798c02234 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/FirstRunScreenshots.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/FirstRunScreenshots.java
@@ -11,6 +11,7 @@
 import androidx.test.uiautomator.UiSelector;
 
 import org.junit.ClassRule;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,16 +31,13 @@
 import static junit.framework.Assert.assertTrue;
 
 @RunWith(AndroidJUnit4.class)
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 public class FirstRunScreenshots extends ScreenshotTest {
     @Rule
     public ActivityTestRule<MainActivity> mActivityTestRule = new MainActivityFirstrunTestRule(true) {
         @Override
         protected void beforeActivityLaunched() {
             super.beforeActivityLaunched();
-
-            // This test is for webview only for now.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() &&
-                    !AppConstants.INSTANCE.isKlarBuild());
         }
     };
 
diff --git a/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/ScreenshotTest.java b/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/ScreenshotTest.java
index 40a0b5bb4924..e30edb26b23e 100644
--- a/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/ScreenshotTest.java
+++ b/focus-android/app/src/androidTest/java/org/mozilla/focus/screenshots/ScreenshotTest.java
@@ -9,6 +9,7 @@
 import android.text.format.DateUtils;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.rules.TestRule;
 import org.junit.rules.TestWatcher;
@@ -24,6 +25,7 @@
 /**
  * Base class for tests that take screenshots.
  */
+@Ignore("This test was written specifically for WebView and needs to be adapted for GeckoView")
 abstract class ScreenshotTest {
     final long waitingTime = DateUtils.SECOND_IN_MILLIS * 10;
 
@@ -37,10 +39,6 @@ abstract class ScreenshotTest {
         @Override
         protected void beforeActivityLaunched() {
             super.beforeActivityLaunched();
-
-            // This test is for webview only for now.
-            org.junit.Assume.assumeTrue(!AppConstants.INSTANCE.isGeckoBuild() &&
-                    !AppConstants.INSTANCE.isKlarBuild());
         }
     };
 
diff --git a/focus-android/app/src/main/AndroidManifest.xml b/focus-android/app/src/main/AndroidManifest.xml
index 8de85cc4a6aa..1c071866705c 100644
--- a/focus-android/app/src/main/AndroidManifest.xml
+++ b/focus-android/app/src/main/AndroidManifest.xml
@@ -7,10 +7,13 @@
     package="org.mozilla.focus">
 
     <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> <!-- Used by sentry. -->
     <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT" />
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
+    <!-- Needed to prompt the user to give permission for camera access -->
+    <uses-permission android:name="android.permission.CAMERA" />
     <!-- Needed to prompt the user to give permission to install a downloaded apk -->
     <uses-permission-sdk-23 android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
 
@@ -132,6 +135,9 @@
             </intent-filter>
         </service>
 
+        <service android:name=".downloads.DownloadService"
+            android:exported="false" />
+
         <service android:name=".session.SessionNotificationService"
             android:exported="false" />
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/Components.kt b/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
index 76495dae1afc..4d100eca23f7 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/Components.kt
@@ -5,8 +5,6 @@
 package org.mozilla.focus
 
 import android.content.Context
-import android.util.AttributeSet
-import android.util.JsonReader
 import mozilla.components.browser.search.SearchEngineManager
 import mozilla.components.browser.search.provider.AssetsSearchEngineProvider
 import mozilla.components.browser.search.provider.localization.LocaleSearchLocalizationProvider
@@ -14,34 +12,59 @@ import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
 import mozilla.components.browser.session.engine.EngineMiddleware
 import mozilla.components.browser.state.store.BrowserStore
-import mozilla.components.concept.base.profiler.Profiler
 import mozilla.components.concept.engine.DefaultSettings
 import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.utils.EngineVersion
-import org.json.JSONObject
+import mozilla.components.concept.fetch.Client
+import mozilla.components.feature.contextmenu.ContextMenuUseCases
+import mozilla.components.feature.downloads.DownloadMiddleware
+import mozilla.components.feature.downloads.DownloadsUseCases
+import mozilla.components.feature.session.SessionUseCases
+import mozilla.components.feature.session.SettingsUseCases
+import mozilla.components.feature.session.TrackingProtectionUseCases
+import mozilla.components.feature.tabs.TabsUseCases
+import org.mozilla.focus.components.EngineProvider
+import org.mozilla.focus.downloads.DownloadService
+import org.mozilla.focus.engine.LocalizedContentInterceptor
 import org.mozilla.focus.search.BingSearchEngineFilter
 import org.mozilla.focus.search.CustomSearchEngineProvider
 import org.mozilla.focus.search.HiddenSearchEngineFilter
+import org.mozilla.focus.utils.Settings
 
 /**
  * Helper object for lazily initializing components.
  */
-class Components {
-    val sessionManager by lazy {
-        SessionManager(DummyEngine(), store).apply {
-            @Suppress("DEPRECATION")
-            register(SessionSetupObserver())
+class Components(
+    context: Context
+) {
+    val engineDefaultSettings by lazy {
+        val settings = Settings.getInstance(context)
+
+        DefaultSettings(
+                requestInterceptor = LocalizedContentInterceptor(context),
+                trackingProtectionPolicy = settings.createTrackingProtectionPolicy(),
+                javascriptEnabled = !settings.shouldBlockJavaScript(),
+                remoteDebuggingEnabled = settings.shouldEnableRemoteDebugging(),
+                webFontsEnabled = !settings.shouldBlockWebFonts()
+        )
+    }
+
+    val engine: Engine by lazy {
+        EngineProvider.createEngine(context, engineDefaultSettings).apply {
+            Settings.getInstance(context).setupSafeBrowsing(this)
         }
     }
 
-    // This dummy engine solution is not great.
+    val client: Client by lazy { EngineProvider.createClient(context) }
+
+    val trackingProtectionUseCases by lazy { TrackingProtectionUseCases(store, engine) }
+
+    val settingsUseCases by lazy { SettingsUseCases(engine, store) }
+
     val store by lazy {
         BrowserStore(
-            middleware = EngineMiddleware.create(DummyEngine(), ::findSessionById)
+            middleware = listOf(
+                DownloadMiddleware(context, DownloadService::class.java)
+            ) + EngineMiddleware.create(engine, ::findSessionById)
         )
     }
 
@@ -49,6 +72,18 @@ class Components {
         return sessionManager.findSessionById(tabId)
     }
 
+    val sessionUseCases: SessionUseCases by lazy { SessionUseCases(store, sessionManager) }
+
+    val tabsUseCases: TabsUseCases by lazy { TabsUseCases(store, sessionManager) }
+
+    val contextMenuUseCases: ContextMenuUseCases by lazy { ContextMenuUseCases(store) }
+
+    val downloadsUseCases: DownloadsUseCases by lazy { DownloadsUseCases(store) }
+
+    val sessionManager by lazy {
+        SessionManager(engine, store)
+    }
+
     val searchEngineManager by lazy {
         val assetsProvider = AssetsSearchEngineProvider(
                 LocaleSearchLocalizationProvider(),
@@ -60,50 +95,3 @@ class Components {
         SearchEngineManager(listOf(assetsProvider, customProvider))
     }
 }
-
-/**
- * We are not using an "Engine" implementation yet. Therefore we create this dummy that we pass to
- * the <code>SessionManager</code> for now.
- */
-private class DummyEngine : Engine {
-    override val version: EngineVersion = EngineVersion(1, 0, 0)
-    override val profiler: Profiler? = null
-    override val settings: Settings = DefaultSettings()
-
-    override fun createSession(private: Boolean, contextId: String?): EngineSession {
-        throw NotImplementedError()
-    }
-
-    override fun createSessionState(json: JSONObject): EngineSessionState {
-        throw NotImplementedError()
-    }
-
-    override fun createSessionStateFrom(reader: JsonReader): EngineSessionState {
-        throw NotImplementedError()
-    }
-
-    override fun createView(context: Context, attrs: AttributeSet?): EngineView {
-        throw NotImplementedError()
-    }
-
-    override fun name(): String {
-        throw NotImplementedError()
-    }
-
-    override fun speculativeConnect(url: String) {
-        throw NotImplementedError()
-    }
-}
-
-/**
- * This is a workaround for setting up the Session object. Once we use browser-engine we can just setup the Engine to
- * use specific default settings. For now we need to manually update every created Session model to reflect what Focus
- * expects as default.
- */
-class SessionSetupObserver : SessionManager.Observer {
-    override fun onSessionAdded(session: Session) {
-        // Tracking protection is enabled by default for every tab. Instead of setting up the engine we modify Session
-        // here and IWebView will get its default behavior from Session.
-        session.trackerBlockingEnabled = true
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.kt b/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.kt
index a3f6f353b3b6..c352e49cdb94 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/FocusApplication.kt
@@ -14,6 +14,7 @@ import kotlinx.coroutines.Job
 import kotlinx.coroutines.launch
 import mozilla.components.support.base.log.Log
 import mozilla.components.support.base.log.sink.AndroidLogSink
+import mozilla.components.support.ktx.android.content.isMainProcess
 import org.mozilla.focus.locale.LocaleAwareApplication
 import org.mozilla.focus.session.NotificationSessionObserver
 import org.mozilla.focus.session.VisibilityLifeCycleCallback
@@ -23,7 +24,6 @@ import org.mozilla.focus.telemetry.TelemetryWrapper
 import org.mozilla.focus.utils.AdjustHelper
 import org.mozilla.focus.utils.AppConstants
 import org.mozilla.focus.utils.StethoWrapper
-import org.mozilla.focus.web.CleanupSessionObserver
 import kotlin.coroutines.CoroutineContext
 
 class FocusApplication : LocaleAwareApplication(), CoroutineScope {
@@ -31,7 +31,7 @@ class FocusApplication : LocaleAwareApplication(), CoroutineScope {
     override val coroutineContext: CoroutineContext
         get() = job + Dispatchers.Main
 
-    val components: Components by lazy { Components() }
+    val components: Components by lazy { Components(this) }
 
     var visibilityLifeCycleCallback: VisibilityLifeCycleCallback? = null
         private set
@@ -42,34 +42,36 @@ class FocusApplication : LocaleAwareApplication(), CoroutineScope {
         Log.addSink(AndroidLogSink("Focus"))
         CrashReporterWrapper.init(this)
 
-        StethoWrapper.init(this)
+        if (isMainProcess()) {
+            StethoWrapper.init(this)
 
-        PreferenceManager.setDefaultValues(this, R.xml.settings, false)
+            PreferenceManager.setDefaultValues(this, R.xml.settings, false)
 
-        TelemetryWrapper.init(this)
+            TelemetryWrapper.init(this)
 
-        enableStrictMode()
+            enableStrictMode()
 
-        components.searchEngineManager.apply {
-            launch(IO) {
-                loadAsync(this@FocusApplication).await()
+            components.searchEngineManager.apply {
+                launch(IO) {
+                    loadAsync(this@FocusApplication).await()
+                }
+
+                registerForLocaleUpdates(this@FocusApplication)
             }
 
-            registerForLocaleUpdates(this@FocusApplication)
-        }
+            AdjustHelper.setupAdjustIfNeeded(this@FocusApplication)
 
-        AdjustHelper.setupAdjustIfNeeded(this@FocusApplication)
+            visibilityLifeCycleCallback = VisibilityLifeCycleCallback(this@FocusApplication)
+            registerActivityLifecycleCallbacks(visibilityLifeCycleCallback)
 
-        visibilityLifeCycleCallback = VisibilityLifeCycleCallback(this@FocusApplication)
-        registerActivityLifecycleCallbacks(visibilityLifeCycleCallback)
+            components.sessionManager.apply {
+                @Suppress("DEPRECATION")
+                register(NotificationSessionObserver(this@FocusApplication))
+                @Suppress("DEPRECATION")
+                register(TelemetrySessionObserver(components.store))
+            }
 
-        components.sessionManager.apply {
-            @Suppress("DEPRECATION")
-            register(NotificationSessionObserver(this@FocusApplication))
-            @Suppress("DEPRECATION")
-            register(TelemetrySessionObserver(components.store))
-            @Suppress("DEPRECATION")
-            register(CleanupSessionObserver(this@FocusApplication))
+            components.engine.warmUp()
         }
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/CustomTabActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/CustomTabActivity.kt
index 679e48b78104..f36e8e13968d 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/CustomTabActivity.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/CustomTabActivity.kt
@@ -8,7 +8,6 @@ import android.os.Bundle
 import mozilla.components.browser.session.Session
 import mozilla.components.support.utils.SafeIntent
 import org.mozilla.focus.ext.components
-import org.mozilla.focus.session.removeAndCloseSession
 
 /**
  * The main entry point for "custom tabs" opened by third-party apps.
@@ -39,7 +38,7 @@ class CustomTabActivity : MainActivity() {
         if (isFinishing && customTabSession.isCustomTabSession()) {
             // This may not be a custom tab session anymore ("open in firefox focus"). So only remove it if this
             // activity is finishing and this is still a custom tab session.
-            components.sessionManager.removeAndCloseSession(customTabSession)
+            components.sessionManager.remove(customTabSession)
         }
     }
     companion object {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseAndOpenShortcutActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseAndOpenShortcutActivity.kt
index 78682062a6f6..ede6a6c708d9 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseAndOpenShortcutActivity.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseAndOpenShortcutActivity.kt
@@ -8,7 +8,6 @@ import android.app.Activity
 import android.content.Intent
 import android.os.Bundle
 import org.mozilla.focus.ext.components
-import org.mozilla.focus.session.removeAndCloseAllSessions
 import org.mozilla.focus.telemetry.TelemetryWrapper
 
 class EraseAndOpenShortcutActivity : Activity() {
@@ -16,7 +15,7 @@ class EraseAndOpenShortcutActivity : Activity() {
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
 
-        components.sessionManager.removeAndCloseAllSessions()
+        components.sessionManager.removeSessions()
 
         TelemetryWrapper.eraseAndOpenShortcutEvent()
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseShortcutActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseShortcutActivity.kt
index 80c4cface1df..a6a7b4f36e20 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseShortcutActivity.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/EraseShortcutActivity.kt
@@ -6,7 +6,6 @@ package org.mozilla.focus.activity
 import android.app.Activity
 import android.os.Bundle
 import org.mozilla.focus.ext.components
-import org.mozilla.focus.session.removeAndCloseAllSessions
 
 import org.mozilla.focus.telemetry.TelemetryWrapper
 
@@ -14,7 +13,7 @@ class EraseShortcutActivity : Activity() {
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
 
-        components.sessionManager.removeAndCloseAllSessions()
+        components.sessionManager.removeSessions()
 
         TelemetryWrapper.eraseShortcutEvent()
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/InfoActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/InfoActivity.kt
deleted file mode 100644
index e0549d47f1d3..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/InfoActivity.kt
+++ /dev/null
@@ -1,95 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.activity
-
-import android.content.Context
-import android.content.Intent
-import android.os.Bundle
-import androidx.appcompat.widget.Toolbar
-import android.util.AttributeSet
-import android.view.View
-
-import org.mozilla.focus.R
-import org.mozilla.focus.browser.LocalizedContent
-import org.mozilla.focus.fragment.InfoFragment
-import org.mozilla.focus.locale.LocaleAwareAppCompatActivity
-import org.mozilla.focus.locale.Locales
-import org.mozilla.focus.web.ClassicWebViewProvider
-import org.mozilla.focus.web.IWebView
-import org.mozilla.focus.web.WebViewProvider
-
-/**
- * A generic activity that supports showing additional information in a WebView. This is useful
- * for showing any web based content, including About/Help/Rights, and also SUMO pages.
- */
-class InfoActivity : LocaleAwareAppCompatActivity() {
-    private var url: String? = null
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-        setContentView(R.layout.activity_info)
-        url = intent.getStringExtra(EXTRA_URL)
-        val title = intent.getStringExtra(EXTRA_TITLE)
-        supportFragmentManager.beginTransaction()
-            .replace(R.id.infofragment, InfoFragment.create(url))
-            .commit()
-        val toolbar = findViewById<Toolbar>(R.id.toolbar)
-        toolbar.title = title
-        setSupportActionBar(toolbar)
-        supportActionBar?.setDisplayHomeAsUpEnabled(true)
-        supportActionBar?.setDisplayShowHomeEnabled(true)
-        toolbar.setNavigationOnClickListener { finish() }
-    }
-
-    override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? {
-        if (name == IWebView::class.java.name) {
-            // We use a WebView for focus:rights as a workaround to link to other internal pages
-            val view = if (url in listOf(LocalizedContent.URL_RIGHTS, LocalizedContent.URL_ABOUT)) {
-                ClassicWebViewProvider().create(context, attrs)
-            } else {
-                WebViewProvider.create(context, attrs)
-            }
-
-            val webView = view as IWebView
-            webView.setBlockingEnabled(false)
-            return view
-        }
-        return super.onCreateView(name, context, attrs)
-    }
-
-    override fun applyLocale() {
-        // We don't care about this
-    }
-
-    companion object {
-        private val EXTRA_URL = "extra_url"
-        private val EXTRA_TITLE = "extra_title"
-
-        fun getIntentFor(context: Context, url: String, title: String): Intent {
-            val intent = Intent(context, InfoActivity::class.java)
-            intent.putExtra(EXTRA_URL, url)
-            intent.putExtra(EXTRA_TITLE, title)
-            return intent
-        }
-
-        fun getAboutIntent(context: Context): Intent {
-            val resources = Locales.getLocalizedResources(context)
-            return getIntentFor(
-                context,
-                LocalizedContent.URL_ABOUT,
-                resources.getString(R.string.menu_about)
-            )
-        }
-
-        fun getRightsIntent(context: Context): Intent {
-            val resources = Locales.getLocalizedResources(context)
-            return getIntentFor(
-                context,
-                LocalizedContent.URL_RIGHTS,
-                resources.getString(R.string.menu_rights)
-            )
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
index 32b8c81300a0..dbfe6d86cea5 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/activity/MainActivity.kt
@@ -13,6 +13,7 @@ import androidx.preference.PreferenceManager
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
 import mozilla.components.browser.state.state.SessionState
+import mozilla.components.concept.engine.EngineView
 import mozilla.components.lib.crash.Crash
 import mozilla.components.support.utils.SafeIntent
 import org.mozilla.focus.R
@@ -24,16 +25,12 @@ import org.mozilla.focus.fragment.FirstrunFragment
 import org.mozilla.focus.fragment.UrlInputFragment
 import org.mozilla.focus.locale.LocaleAwareAppCompatActivity
 import org.mozilla.focus.session.IntentProcessor
-import org.mozilla.focus.session.removeAndCloseAllSessions
 import org.mozilla.focus.session.ui.SessionsSheetFragment
 import org.mozilla.focus.shortcut.HomeScreen
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
 import org.mozilla.focus.utils.Settings
 import org.mozilla.focus.utils.SupportUtils
 import org.mozilla.focus.utils.ViewUtils
-import org.mozilla.focus.web.IWebView
-import org.mozilla.focus.web.WebViewProvider
 
 @Suppress("TooManyFunctions")
 open class MainActivity : LocaleAwareAppCompatActivity() {
@@ -83,8 +80,6 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
 
         registerSessionObserver()
 
-        WebViewProvider.preload(this)
-
         val launchCount = Settings.getInstance(this).getAppLaunchCount()
         PreferenceManager.getDefaultSharedPreferences(this)
                 .edit()
@@ -101,24 +96,18 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
 
             override fun onAllSessionsRemoved() {
                 showUrlInputScreen()
-
-                WebViewProvider.performNewBrowserSessionCleanup()
             }
 
             override fun onSessionRemoved(session: Session) {
                 previousSessionCount = components.sessionManager.sessions.count()
                 if (!isCustomTabMode && components.sessionManager.sessions.isEmpty()) {
                     showUrlInputScreen()
-
-                    WebViewProvider.performNewBrowserSessionCleanup()
                 }
             }
         }, owner = this)
 
         if (!isCustomTabMode && components.sessionManager.sessions.isEmpty()) {
             showUrlInputScreen()
-
-            WebViewProvider.performNewBrowserSessionCleanup()
         } else {
             showBrowserScreenForCurrentSession()
         }
@@ -141,10 +130,6 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
     }
 
     override fun onPause() {
-        if (isFinishing) {
-            WebViewProvider.performCleanup(this)
-        }
-
         val fragmentManager = supportFragmentManager
         val browserFragment =
             fragmentManager.findFragmentByTag(BrowserFragment.FRAGMENT_TAG) as BrowserFragment?
@@ -207,7 +192,7 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
         val fromShortcut = intent.getBooleanExtra(EXTRA_SHORTCUT, false)
         val fromNotification = intent.getBooleanExtra(EXTRA_NOTIFICATION, false)
 
-        components.sessionManager.removeAndCloseAllSessions()
+        components.sessionManager.removeSessions()
 
         if (fromShortcut) {
             TelemetryWrapper.eraseShortcutEvent()
@@ -241,11 +226,7 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
         val shouldAnimate = isShowingBrowser && browserFragment!!.isResumed
 
         if (shouldAnimate) {
-            if (AppConstants.isGeckoBuild) {
-                transaction.setCustomAnimations(0, R.anim.erase_animation_gv)
-            } else {
-                transaction.setCustomAnimations(0, R.anim.erase_animation)
-            }
+            transaction.setCustomAnimations(0, R.anim.erase_animation)
         }
 
         // Currently this callback can get invoked while the app is in the background. Therefore we are using
@@ -292,9 +273,8 @@ open class MainActivity : LocaleAwareAppCompatActivity() {
     }
 
     override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? {
-        return if (name == IWebView::class.java.name) {
-            // Inject our implementation of IWebView from the WebViewProvider.
-            WebViewProvider.create(this, attrs)
+        return if (name == EngineView::class.java.name) {
+            components.engine.createView(context, attrs).asView()
         } else super.onCreateView(name, context, attrs)
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/broadcastreceiver/DownloadBroadcastReceiver.java b/focus-android/app/src/main/java/org/mozilla/focus/broadcastreceiver/DownloadBroadcastReceiver.java
deleted file mode 100644
index 33fd168ff53b..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/broadcastreceiver/DownloadBroadcastReceiver.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.broadcastreceiver;
-
-import android.app.DownloadManager;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.net.Uri;
-import com.google.android.material.snackbar.Snackbar;
-import androidx.core.content.ContextCompat;
-import androidx.core.content.FileProvider;
-import android.view.View;
-
-import mozilla.components.support.utils.DownloadUtils;
-
-import org.mozilla.focus.BuildConfig;
-import org.mozilla.focus.R;
-import org.mozilla.focus.utils.IntentUtils;
-
-import java.io.File;
-import java.util.HashSet;
-
-/**
- * BroadcastReceiver for finished downloads
- */
-public class DownloadBroadcastReceiver extends BroadcastReceiver {
-    private static final String FILE_SCHEME = "file://";
-    private static final String FILE_PROVIDER_EXTENSION = ".fileprovider";
-
-    private final HashSet<Long> queuedDownloadReferences = new HashSet<>();
-    private final View browserContainer;
-    private final DownloadManager downloadManager;
-
-    public DownloadBroadcastReceiver(View view, DownloadManager downloadManager) {
-        this.browserContainer = view;
-        this.downloadManager = downloadManager;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        final long downloadReference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
-        displaySnackbar(context, downloadReference, downloadManager);
-    }
-
-    private void displaySnackbar(final Context context, long completedDownloadReference, DownloadManager downloadManager) {
-        if (!isFocusDownload(completedDownloadReference)) {
-            return;
-        }
-
-        final DownloadManager.Query query = new DownloadManager.Query();
-        query.setFilterById(completedDownloadReference);
-        try (Cursor cursor = downloadManager.query(query)) {
-            if (cursor.moveToFirst()) {
-                int statusColumnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
-                if (DownloadManager.STATUS_SUCCESSFUL == cursor.getInt(statusColumnIndex)) {
-                    String uriString = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));
-
-                    final String localUri = uriString.startsWith(FILE_SCHEME) ? uriString.substring(FILE_SCHEME.length()) : uriString;
-                    final String decoded = Uri.decode(localUri);
-                    File file = new File(decoded);
-                    final String mimeType = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_MEDIA_TYPE));
-                    String fileName = DownloadUtils.guessFileName(null, null, decoded, null);
-                    final String fileName2 = DownloadUtils.guessFileName(null, null, decoded, mimeType);
-                    // Rename the file extension if it lacks a known MIME type and the server provided a Content-Type header.
-                    if (!fileName.equals(fileName2)) {
-                        final File file2 = new File(file.getParent(), fileName2);
-                        if (file.renameTo(file2)) {
-                            file = file2;
-                            fileName = fileName2;
-                        }
-                    }
-
-                    final Uri uriForFile = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + FILE_PROVIDER_EXTENSION, file);
-                    final Intent openFileIntent = IntentUtils.INSTANCE.createOpenFileIntent(uriForFile, mimeType);
-                    showSnackbarForFilename(openFileIntent, context, fileName);
-                }
-            }
-        }
-        removeFromHashSet(completedDownloadReference);
-    }
-
-    private void showSnackbarForFilename(final Intent openFileIntent, final Context context, String fileName) {
-        final Snackbar snackbar = Snackbar
-                .make(browserContainer, String.format(context.getString(R.string.download_snackbar_finished), fileName), Snackbar.LENGTH_LONG);
-        if (IntentUtils.INSTANCE.activitiesFoundForIntent(context, openFileIntent)) {
-            snackbar.setAction(context.getString(R.string.download_snackbar_open), new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    context.startActivity(openFileIntent);
-                }
-            });
-            snackbar.setActionTextColor(ContextCompat.getColor(context, R.color.snackbarActionText));
-        }
-        snackbar.show();
-    }
-
-    private boolean isFocusDownload(long completedDownloadReference) {
-        return (queuedDownloadReferences.contains(completedDownloadReference));
-    }
-
-    private void removeFromHashSet(long completedDownloadReference) {
-        queuedDownloadReferences.remove(completedDownloadReference);
-    }
-
-    public void addQueuedDownload(long referenceId) {
-        queuedDownloadReferences.add(referenceId);
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java b/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java
deleted file mode 100644
index 4bb9f5181512..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.browser;
-
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.view.View;
-
-import androidx.annotation.NonNull;
-import androidx.collection.ArrayMap;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.locale.Locales;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.utils.HtmlLoader;
-import org.mozilla.focus.utils.SupportUtils;
-import org.mozilla.focus.web.IWebView;
-import org.mozilla.geckoview.BuildConfig;
-
-import java.util.Map;
-
-public class LocalizedContent {
-    // We can't use "about:" because webview silently swallows about: pages, hence we use
-    // a custom scheme.
-    public static final String URL_ABOUT = "focus:about";
-    public static final String URL_RIGHTS = "focus:rights";
-
-    public static boolean handleInternalContent(String url, IWebView webView, Context context) {
-        if (URL_ABOUT.equals(url)) {
-            loadAbout(webView, context);
-            return true;
-        } else if (URL_RIGHTS.equals(url)) {
-            loadRights(webView, context);
-            return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Load the content for focus:about
-     */
-    private static void loadAbout(@NonNull final IWebView webView, Context context) {
-        final Resources resources = Locales.getLocalizedResources(context);
-
-        final Map<String, String> substitutionMap = new ArrayMap<>();
-        final String appName = context.getResources().getString(R.string.app_name);
-        final String learnMoreURL = SupportUtils.INSTANCE.getManifestoURL();
-
-        String aboutVersion = "";
-        try {
-            final String engineIndicator = AppConstants.INSTANCE.isGeckoBuild() ?
-                    " \uD83E\uDD8E " + BuildConfig.MOZ_APP_VERSION + "-" + BuildConfig.MOZ_APP_BUILDID : "";
-            final PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-
-            aboutVersion = String.format("%s (Build #%s)", packageInfo.versionName, packageInfo.versionCode + engineIndicator);
-        } catch (PackageManager.NameNotFoundException e) {
-            // Nothing to do if we can't find the package name.
-        }
-        substitutionMap.put("%about-version%", aboutVersion);
-
-        final String aboutContent = resources.getString(R.string.about_content, appName, learnMoreURL);
-        substitutionMap.put("%about-content%", aboutContent);
-
-        final String wordmark = HtmlLoader.loadPngAsDataURI(context, R.drawable.wordmark);
-        substitutionMap.put("%wordmark%", wordmark);
-
-        putLayoutDirectionIntoMap(substitutionMap, context);
-
-        final String data = HtmlLoader.loadResourceFile(context, R.raw.about, substitutionMap);
-
-        webView.loadData("file:///android_res/raw/about.html", data, "text/html", "UTF-8", URL_ABOUT);
-    }
-
-    /**
-     * Load the content for focus:rights
-     */
-    private static void loadRights(@NonNull final IWebView webView, Context context) {
-        final Resources resources = Locales.getLocalizedResources(context);
-
-        final Map<String, String> substitutionMap = new ArrayMap<>();
-
-        final String appName = context.getResources().getString(R.string.app_name);
-        final String mplUrl = "https://www.mozilla.org/en-US/MPL/";
-        final String trademarkPolicyUrl = "https://www.mozilla.org/foundation/trademarks/policy/";
-        final String gplUrl = "gpl.html";
-        final String trackingProtectionUrl = "https://wiki.mozilla.org/Security/Tracking_protection#Lists";
-        final String licensesUrl = "licenses.html";
-
-        final String content1 = resources.getString(R.string.your_rights_content1, appName);
-        substitutionMap.put("%your-rights-content1%", content1);
-
-        final String content2 = resources.getString(R.string.your_rights_content2, appName, mplUrl);
-        substitutionMap.put("%your-rights-content2%", content2);
-
-        final String content3 = resources.getString(R.string.your_rights_content3, appName, trademarkPolicyUrl);
-        substitutionMap.put("%your-rights-content3%", content3);
-
-        final String content4 = resources.getString(R.string.your_rights_content4, appName, licensesUrl);
-        substitutionMap.put("%your-rights-content4%", content4);
-
-        final String content5 = resources.getString(R.string.your_rights_content5, appName, gplUrl, trackingProtectionUrl);
-        substitutionMap.put("%your-rights-content5%", content5);
-
-        putLayoutDirectionIntoMap(substitutionMap, context);
-
-        final String data = HtmlLoader.loadResourceFile(context, R.raw.rights, substitutionMap);
-        webView.loadData("file:///android_asset/rights.html", data, "text/html", "UTF-8", URL_RIGHTS);
-    }
-
-    private static void putLayoutDirectionIntoMap(Map<String, String> substitutionMap, Context context) {
-        final int layoutDirection = context.getResources().getConfiguration().getLayoutDirection();
-        final String direction;
-
-        if (layoutDirection == View.LAYOUT_DIRECTION_LTR) {
-            direction = "ltr";
-        } else if (layoutDirection == View.LAYOUT_DIRECTION_RTL) {
-            direction = "rtl";
-        } else {
-            direction = "auto";
-        }
-
-        substitutionMap.put("%dir%", direction);
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.kt
new file mode 100644
index 000000000000..310a499cf866
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.kt
@@ -0,0 +1,100 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+package org.mozilla.focus.browser
+
+import android.content.Context
+import android.content.pm.PackageManager
+import android.view.View
+import androidx.collection.ArrayMap
+import org.mozilla.focus.R
+import org.mozilla.focus.locale.Locales
+import org.mozilla.focus.utils.HtmlLoader
+import org.mozilla.focus.utils.SupportUtils.manifestoURL
+import org.mozilla.geckoview.BuildConfig
+
+object LocalizedContent {
+    // We can't use "about:" because webview silently swallows about: pages, hence we use
+    // a custom scheme.
+    const val URL_ABOUT = "focus:about"
+    const val URL_RIGHTS = "focus:rights"
+    const val URL_GPL = "focus:gpl"
+    const val URL_LICENSES = "focus:licenses"
+
+    /**
+     * Load the content for focus:about
+     */
+    fun loadAbout(context: Context): String {
+        val resources = Locales.getLocalizedResources(context)
+        val substitutionMap: MutableMap<String, String> = ArrayMap()
+        val appName = context.resources.getString(R.string.app_name)
+        val learnMoreURL = manifestoURL
+        var aboutVersion = ""
+        try {
+            val engineIndicator = BuildConfig.MOZ_APP_VERSION + "-" + BuildConfig.MOZ_APP_BUILDID
+            val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
+            @Suppress("DEPRECATION")
+            aboutVersion = String.format(
+                "%s (Build #%s)",
+                packageInfo.versionName,
+                packageInfo.versionCode.toString() + engineIndicator
+            )
+        } catch (e: PackageManager.NameNotFoundException) {
+            // Nothing to do if we can't find the package name.
+        }
+        substitutionMap["%about-version%"] = aboutVersion
+        val aboutContent = resources.getString(R.string.about_content, appName, learnMoreURL)
+        substitutionMap["%about-content%"] = aboutContent
+        val wordmark = HtmlLoader.loadPngAsDataURI(context, R.drawable.wordmark)
+        substitutionMap["%wordmark%"] = wordmark
+        putLayoutDirectionIntoMap(substitutionMap, context)
+        return HtmlLoader.loadResourceFile(context, R.raw.about, substitutionMap)
+    }
+
+    /**
+     * Load the content for focus:rights
+     */
+    fun loadRights(context: Context): String {
+        val resources = Locales.getLocalizedResources(context)
+        val substitutionMap: MutableMap<String, String> = ArrayMap()
+        val appName = context.resources.getString(R.string.app_name)
+        val mplUrl = "https://www.mozilla.org/en-US/MPL/"
+        val trademarkPolicyUrl = "https://www.mozilla.org/foundation/trademarks/policy/"
+        val gplUrl = "focus:gpl"
+        val trackingProtectionUrl = "https://wiki.mozilla.org/Security/Tracking_protection#Lists"
+        val licensesUrl = "focus:licenses"
+        val content1 = resources.getString(R.string.your_rights_content1, appName)
+        substitutionMap["%your-rights-content1%"] = content1
+        val content2 = resources.getString(R.string.your_rights_content2, appName, mplUrl)
+        substitutionMap["%your-rights-content2%"] = content2
+        val content3 = resources.getString(R.string.your_rights_content3, appName, trademarkPolicyUrl)
+        substitutionMap["%your-rights-content3%"] = content3
+        val content4 = resources.getString(R.string.your_rights_content4, appName, licensesUrl)
+        substitutionMap["%your-rights-content4%"] = content4
+        val content5 = resources.getString(R.string.your_rights_content5, appName, gplUrl, trackingProtectionUrl)
+        substitutionMap["%your-rights-content5%"] = content5
+        putLayoutDirectionIntoMap(substitutionMap, context)
+        return HtmlLoader.loadResourceFile(context, R.raw.rights, substitutionMap)
+    }
+
+    fun loadLicenses(context: Context): String {
+        return HtmlLoader.loadResourceFile(context, R.raw.licenses, emptyMap())
+    }
+
+    fun loadGPL(context: Context): String {
+        return HtmlLoader.loadResourceFile(context, R.raw.gpl, emptyMap())
+    }
+
+    private fun putLayoutDirectionIntoMap(substitutionMap: MutableMap<String, String>, context: Context) {
+        val layoutDirection = context.resources.configuration.layoutDirection
+        val direction: String
+        direction = if (layoutDirection == View.LAYOUT_DIRECTION_LTR) {
+            "ltr"
+        } else if (layoutDirection == View.LAYOUT_DIRECTION_RTL) {
+            "rtl"
+        } else {
+            "auto"
+        }
+        substitutionMap["%dir%"] = direction
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/AbstractBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/AbstractBinding.kt
new file mode 100644
index 000000000000..6e1d34294e0e
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/AbstractBinding.kt
@@ -0,0 +1,35 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.Flow
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.lib.state.ext.flowScoped
+import mozilla.components.support.base.feature.LifecycleAwareFeature
+
+/**
+ * Helper class for creating small binding classes that are responsible for reacting to state
+ * changes.
+ */
+abstract class AbstractBinding(
+    private val store: BrowserStore
+) : LifecycleAwareFeature {
+    private var scope: CoroutineScope? = null
+
+    override fun start() {
+        scope = store.flowScoped { flow ->
+            onState(flow)
+        }
+    }
+
+    override fun stop() {
+        scope?.cancel()
+    }
+
+    abstract suspend fun onState(flow: Flow<BrowserState>)
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/BlockingThemeBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/BlockingThemeBinding.kt
new file mode 100644
index 000000000000..9421938131a8
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/BlockingThemeBinding.kt
@@ -0,0 +1,93 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import android.graphics.drawable.TransitionDrawable
+import android.view.View
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.session.Session
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.SessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifAnyChanged
+import org.mozilla.focus.R
+import org.mozilla.focus.animation.TransitionDrawableGroup
+
+private const val ANIMATION_DURATION = 300
+
+/**
+ * Binding responsible for updating the theme based on the loading state and whether
+ */
+class BlockingThemeBinding(
+    store: BrowserStore,
+    private val session: Session,
+    private val statusBar: View,
+    private val urlBar: View,
+    private val blockView: View
+) : AbstractBinding(store) {
+    private var backgroundTransitionGroup: TransitionDrawableGroup? = updateResources(
+        session.isCustomTabSession(), enabled = true
+    )
+    private var hasLoadedOnce = false
+    private var trackingProtectionDisabled = false
+
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(session.id) }
+            .ifAnyChanged { tab -> arrayOf(tab.trackingProtection.ignoredOnTrackingProtection, tab.content.loading) }
+            .collect { tab -> onLoadingStateChanged(tab) }
+    }
+
+    private fun onLoadingStateChanged(tab: SessionState) {
+        if (tab.trackingProtection.ignoredOnTrackingProtection != trackingProtectionDisabled) {
+            trackingProtectionDisabled = tab.trackingProtection.ignoredOnTrackingProtection
+            backgroundTransitionGroup = updateResources(session.isCustomTabSession(), trackingProtectionDisabled.not())
+        }
+
+        if (tab.content.loading) {
+            backgroundTransitionGroup?.resetTransition()
+        } else {
+            // We start a transition only if a page was just loading before allowing to avoid issue #1179
+            if (hasLoadedOnce) {
+                backgroundTransitionGroup?.startTransition(ANIMATION_DURATION)
+            }
+            hasLoadedOnce = true
+        }
+    }
+
+    private fun updateResources(
+        isCustomTab: Boolean,
+        enabled: Boolean
+    ): TransitionDrawableGroup {
+        blockView.visibility = if (enabled) View.GONE else View.VISIBLE
+
+        statusBar.setBackgroundResource(if (enabled) {
+            R.drawable.animated_background
+        } else {
+            R.drawable.animated_background_disabled
+        })
+
+        return if (!isCustomTab) {
+            // Only update the toolbar background if this is not a custom tab. Custom tabs set their
+            // own color and we do not want to override this here.
+            urlBar.setBackgroundResource(if (enabled) {
+                R.drawable.animated_background
+            } else {
+                R.drawable.animated_background_disabled
+            })
+
+            TransitionDrawableGroup(
+                urlBar.background as TransitionDrawable,
+                statusBar.background as TransitionDrawable
+            )
+        } else {
+            TransitionDrawableGroup(
+                statusBar.background as TransitionDrawable
+            )
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/LoadingBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/LoadingBinding.kt
new file mode 100644
index 000000000000..8b94691ebe35
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/LoadingBinding.kt
@@ -0,0 +1,41 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import android.view.View
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.SessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifChanged
+import org.mozilla.focus.widget.AnimatedProgressBar
+
+private const val INITIAL_PROGRESS = 5
+
+class LoadingBinding(
+    store: BrowserStore,
+    private val tabId: String,
+    private val progressBar: AnimatedProgressBar
+) : AbstractBinding(store) {
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .ifChanged { tab -> tab.content.loading }
+            .collect { tab -> onLoadingStateChanged(tab) }
+    }
+
+    private fun onLoadingStateChanged(tab: SessionState) {
+        if (tab.content.loading) {
+            progressBar.progress = INITIAL_PROGRESS
+            progressBar.visibility = View.VISIBLE
+        } else {
+            if (progressBar.visibility == View.VISIBLE) {
+                progressBar.visibility = View.GONE
+            }
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/MenuBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/MenuBinding.kt
new file mode 100644
index 000000000000..e59fad1f3b68
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/MenuBinding.kt
@@ -0,0 +1,70 @@
+package org.mozilla.focus.browser.binding
+
+import android.graphics.drawable.Drawable
+import android.view.View
+import android.widget.ImageButton
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.SessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifAnyChanged
+import org.mozilla.focus.fragment.BrowserFragment
+import org.mozilla.focus.menu.browser.BrowserMenu
+import java.lang.ref.WeakReference
+
+class MenuBinding(
+    private val fragment: BrowserFragment,
+    store: BrowserStore,
+    private val tabId: String?,
+    private val menuView: ImageButton
+) : AbstractBinding(store), View.OnClickListener {
+    private var menuReference: WeakReference<BrowserMenu> = WeakReference<BrowserMenu>(null)
+
+    init {
+        menuView.setOnClickListener(this)
+    }
+
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .ifAnyChanged { tab -> arrayOf(tab.trackingProtection.blockedTrackers, tab.content.loading) }
+            .collect { tab -> onStateChanged(tab) }
+    }
+
+    private fun onStateChanged(tab: SessionState) {
+        val menu = menuReference.get() ?: return
+
+        menu.updateTrackers(tab.trackingProtection.blockedTrackers.size)
+        menu.updateLoading(tab.content.loading)
+    }
+
+    // LifecycleAwareFeature does not tell us about pause/resume yet. So we pass that to the
+    // binding manually here.
+    fun pause() {
+        menuReference.get()?.let { menu ->
+            menu.dismiss()
+            menuReference.clear()
+        }
+    }
+
+    fun updateIcon(drawable: Drawable) {
+        menuView.setImageDrawable(drawable)
+    }
+
+    override fun onClick(view: View) {
+        val menu = BrowserMenu(fragment.requireContext(), fragment, fragment.session.customTabConfig)
+        menu.show(menuView)
+
+        menuReference = WeakReference(menu)
+    }
+
+    fun showMenuButton() {
+        menuView.visibility = View.VISIBLE
+    }
+
+    fun hideMenuButton() {
+        menuView.visibility = View.GONE
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ProgressBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ProgressBinding.kt
new file mode 100644
index 000000000000..ee481cb4243a
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ProgressBinding.kt
@@ -0,0 +1,28 @@
+package org.mozilla.focus.browser.binding
+
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifChanged
+import org.mozilla.focus.widget.AnimatedProgressBar
+
+class ProgressBinding(
+    store: BrowserStore,
+    private val tabId: String?,
+    private val progressView: AnimatedProgressBar
+) : AbstractBinding(store) {
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .map { tab -> tab.content.progress }
+            .ifChanged()
+            .collect { progress -> onProgressChanged(progress) }
+    }
+
+    private fun onProgressChanged(progress: Int) {
+        progressView.progress = progress
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/SecurityInfoBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/SecurityInfoBinding.kt
new file mode 100644
index 000000000000..6300a3f7dc03
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/SecurityInfoBinding.kt
@@ -0,0 +1,63 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import android.view.View
+import android.webkit.URLUtil
+import android.widget.ImageView
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.SessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifAnyChanged
+import org.mozilla.focus.R
+import org.mozilla.focus.fragment.BrowserFragment
+
+class SecurityInfoBinding(
+    private val fragment: BrowserFragment,
+    store: BrowserStore,
+    private val tabId: String,
+    private val securityView: ImageView
+) : AbstractBinding(store), View.OnClickListener {
+    init {
+        securityView.setImageResource(R.drawable.ic_internet)
+        securityView.setOnClickListener(this)
+    }
+
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .ifAnyChanged { tab -> arrayOf(tab.content.securityInfo, tab.content.loading) }
+            .collect { tab -> onSecurityStateChanged(tab) }
+    }
+
+    private fun onSecurityStateChanged(tab: SessionState) {
+        if (tab.content.securityInfo.secure) {
+            securityView.setImageResource(R.drawable.ic_lock)
+        } else {
+            if (URLUtil.isHttpUrl(tab.content.url)) {
+                // HTTP site
+                securityView.setImageResource(R.drawable.ic_internet)
+            } else {
+                // Certificate is bad
+                securityView.setImageResource(R.drawable.ic_warning)
+            }
+        }
+    }
+
+    fun updateColorFilter(textColor: Int) {
+        securityView.setColorFilter(textColor)
+    }
+
+    fun updateIcon(resource: Int) {
+        securityView.setImageResource(resource)
+    }
+
+    override fun onClick(view: View) {
+        fragment.showSecurityPopUp()
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ToolbarButtonBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ToolbarButtonBinding.kt
new file mode 100644
index 000000000000..357ebf5f6016
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/ToolbarButtonBinding.kt
@@ -0,0 +1,46 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import android.view.View
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifAnyChanged
+
+/**
+ * Binding that will update the navigation buttons (only on tablets) based on the navigation state
+ * in [BrowserStore].
+ */
+class ToolbarButtonBinding(
+    store: BrowserStore,
+    private val tabId: String,
+    private val forwardButton: View,
+    private val backButton: View,
+    private val refreshButton: View,
+    private val stopButton: View
+) : AbstractBinding(store) {
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .ifAnyChanged { tab -> arrayOf(tab.content.canGoBack, tab.content.canGoForward, tab.content.loading) }
+            .collect { tab ->
+                onTabChanged(tab.content.canGoBack, tab.content.canGoForward, tab.content.loading)
+            }
+    }
+
+    @Suppress("MagicNumber")
+    private fun onTabChanged(canGoBack: Boolean, canGoForward: Boolean, isLoading: Boolean) {
+        forwardButton.isEnabled = canGoForward
+        forwardButton.alpha = if (canGoForward) 1.0f else 0.5f
+        backButton.isEnabled = canGoBack
+        backButton.alpha = if (canGoBack) 1.0f else 0.5f
+
+        refreshButton.visibility = if (isLoading) View.GONE else View.VISIBLE
+        stopButton.visibility = if (isLoading) View.VISIBLE else View.GONE
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/UrlBinding.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/UrlBinding.kt
new file mode 100644
index 000000000000..fd6d0d27d465
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/binding/UrlBinding.kt
@@ -0,0 +1,33 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.binding
+
+import android.widget.TextView
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifChanged
+import org.mozilla.focus.utils.UrlUtils
+
+class UrlBinding(
+    store: BrowserStore,
+    val tabId: String,
+    val urlView: TextView
+) : AbstractBinding(store) {
+    override suspend fun onState(flow: Flow<BrowserState>) {
+        flow.mapNotNull { state -> state.findTabOrCustomTabOrSelectedTab(tabId) }
+            .map { tab -> tab.content.url }
+            .ifChanged()
+            .collect { url -> onUrlChanged(url) }
+    }
+
+    private fun onUrlChanged(url: String) {
+        urlView.text = UrlUtils.stripUserInfo(url)
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FindInPageIntegration.kt b/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FindInPageIntegration.kt
new file mode 100644
index 000000000000..518571fa0b3e
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/integration/FindInPageIntegration.kt
@@ -0,0 +1,48 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.browser.integration
+
+import android.view.View
+import mozilla.components.browser.state.state.SessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.concept.engine.EngineView
+import mozilla.components.feature.findinpage.FindInPageFeature
+import mozilla.components.feature.findinpage.view.FindInPageBar
+import mozilla.components.support.base.feature.LifecycleAwareFeature
+import mozilla.components.support.base.feature.UserInteractionHandler
+
+class FindInPageIntegration(
+    store: BrowserStore,
+    private val findInPageView: FindInPageBar,
+    engineView: EngineView
+) : LifecycleAwareFeature, UserInteractionHandler {
+    private val feature = FindInPageFeature(
+        store,
+        findInPageView,
+        engineView,
+        ::hide
+    )
+
+    override fun start() {
+        feature.start()
+    }
+
+    override fun stop() {
+        feature.stop()
+    }
+
+    override fun onBackPressed(): Boolean {
+        return feature.onBackPressed()
+    }
+
+    fun show(sessionState: SessionState) {
+        findInPageView.visibility = View.VISIBLE
+        feature.bind(sessionState)
+    }
+
+    fun hide() {
+        findInPageView.visibility = View.GONE
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/components/EngineProvider.kt b/focus-android/app/src/main/java/org/mozilla/focus/components/EngineProvider.kt
new file mode 100644
index 000000000000..819547d83562
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/components/EngineProvider.kt
@@ -0,0 +1,44 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.components
+
+import android.content.Context
+import mozilla.components.browser.engine.gecko.GeckoEngine
+import mozilla.components.browser.engine.gecko.fetch.GeckoViewFetchClient
+import mozilla.components.concept.engine.DefaultSettings
+import mozilla.components.concept.engine.Engine
+import mozilla.components.concept.fetch.Client
+import mozilla.components.lib.crash.handler.CrashHandlerService
+import org.mozilla.geckoview.GeckoRuntime
+import org.mozilla.geckoview.GeckoRuntimeSettings
+
+object EngineProvider {
+    private var runtime: GeckoRuntime? = null
+
+    @Synchronized
+    private fun getOrCreateRuntime(context: Context): GeckoRuntime {
+        if (runtime == null) {
+            val builder = GeckoRuntimeSettings.Builder()
+
+            builder.crashHandler(CrashHandlerService::class.java)
+            builder.aboutConfigEnabled(true)
+
+            runtime = GeckoRuntime.create(context, builder.build())
+        }
+
+        return runtime!!
+    }
+
+    fun createEngine(context: Context, defaultSettings: DefaultSettings): Engine {
+        val runtime = getOrCreateRuntime(context)
+
+        return GeckoEngine(context, defaultSettings, runtime)
+    }
+
+    fun createClient(context: Context): Client {
+        val runtime = getOrCreateRuntime(context)
+        return GeckoViewFetchClient(context, runtime)
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/downloads/DownloadService.kt b/focus-android/app/src/main/java/org/mozilla/focus/downloads/DownloadService.kt
new file mode 100644
index 000000000000..b96937a500f5
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/downloads/DownloadService.kt
@@ -0,0 +1,15 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.downloads
+
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.concept.fetch.Client
+import mozilla.components.feature.downloads.AbstractFetchDownloadService
+import org.mozilla.focus.ext.components
+
+class DownloadService : AbstractFetchDownloadService() {
+    override val httpClient: Client by lazy { components.client }
+    override val store: BrowserStore by lazy { components.store }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/engine/EngineSharedPreferencesListener.kt b/focus-android/app/src/main/java/org/mozilla/focus/engine/EngineSharedPreferencesListener.kt
new file mode 100644
index 000000000000..b2bb31d1ef0e
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/engine/EngineSharedPreferencesListener.kt
@@ -0,0 +1,73 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.engine
+
+import android.content.Context
+import android.content.SharedPreferences
+import org.mozilla.focus.R
+import org.mozilla.focus.ext.components
+import org.mozilla.focus.utils.Settings
+
+/**
+ * SharedPreference listener that will update the engine whenever the user changes settings.
+ */
+class EngineSharedPreferencesListener(
+    private val context: Context
+) : SharedPreferences.OnSharedPreferenceChangeListener {
+    override fun onSharedPreferenceChanged(preferences: SharedPreferences, key: String) {
+        when (key) {
+            context.getString(R.string.pref_key_privacy_block_social),
+            context.getString(R.string.pref_key_privacy_block_ads),
+            context.getString(R.string.pref_key_privacy_block_analytics),
+            context.getString(R.string.pref_key_privacy_block_other) ->
+                updateTrackingProtectionPolicy()
+
+            context.getString(R.string.pref_key_safe_browsing) ->
+                updateSafeBrowsingPolicy()
+
+            context.getString(R.string.pref_key_performance_block_javascript) ->
+                updateJavaScriptSetting()
+
+            context.getString(R.string.pref_key_remote_debugging) ->
+                updateRemoteDebugging()
+
+            context.getString(R.string.pref_key_performance_block_webfonts) ->
+                updateWebFontsBlocking()
+        }
+    }
+
+    private fun updateTrackingProtectionPolicy() {
+        val policy = Settings.getInstance(context).createTrackingProtectionPolicy()
+        val components = context.components
+
+        components.engineDefaultSettings.trackingProtectionPolicy = policy
+        components.settingsUseCases.updateTrackingProtection(policy)
+    }
+
+    private fun updateSafeBrowsingPolicy() {
+        Settings.getInstance(context).setupSafeBrowsing(context.components.engine)
+    }
+
+    private fun updateJavaScriptSetting() {
+        val settings = Settings.getInstance(context)
+        val components = context.components
+
+        components.engineDefaultSettings.javascriptEnabled = !settings.shouldBlockJavaScript()
+        components.engine.settings.javascriptEnabled = !settings.shouldBlockJavaScript()
+    }
+
+    private fun updateRemoteDebugging() {
+        context.components.engine.settings.remoteDebuggingEnabled =
+            Settings.getInstance(context).shouldEnableRemoteDebugging()
+    }
+
+    private fun updateWebFontsBlocking() {
+        val settings = Settings.getInstance(context)
+        val components = context.components
+
+        components.engineDefaultSettings.webFontsEnabled = !settings.shouldBlockWebFonts()
+        components.engine.settings.webFontsEnabled = !settings.shouldBlockWebFonts()
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/engine/LocalizedContentInterceptor.kt b/focus-android/app/src/main/java/org/mozilla/focus/engine/LocalizedContentInterceptor.kt
new file mode 100644
index 000000000000..f2bd060f2b6f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/engine/LocalizedContentInterceptor.kt
@@ -0,0 +1,58 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.engine
+
+import android.content.Context
+import mozilla.components.browser.errorpages.ErrorPages
+import mozilla.components.browser.errorpages.ErrorType
+import mozilla.components.concept.engine.EngineSession
+import mozilla.components.concept.engine.request.RequestInterceptor
+import org.mozilla.focus.browser.LocalizedContent
+
+class LocalizedContentInterceptor(
+    private val context: Context
+) : RequestInterceptor {
+    override fun onLoadRequest(
+        engineSession: EngineSession,
+        uri: String,
+        lastUri: String?,
+        hasUserGesture: Boolean,
+        isSameDomain: Boolean,
+        isRedirect: Boolean,
+        isDirectNavigation: Boolean,
+        isSubframeRequest: Boolean
+    ): RequestInterceptor.InterceptionResponse? {
+        return when (uri) {
+            LocalizedContent.URL_ABOUT -> RequestInterceptor.InterceptionResponse.Content(
+                LocalizedContent.loadAbout(context), encoding = "base64"
+            )
+
+            LocalizedContent.URL_RIGHTS -> RequestInterceptor.InterceptionResponse.Content(
+                LocalizedContent.loadRights(context), encoding = "base64"
+            )
+
+            LocalizedContent.URL_GPL -> RequestInterceptor.InterceptionResponse.Content(
+                LocalizedContent.loadGPL(context), encoding = "base64"
+            )
+
+            LocalizedContent.URL_LICENSES -> RequestInterceptor.InterceptionResponse.Content(
+                LocalizedContent.loadLicenses(context), encoding = "base64"
+            )
+
+            else -> null
+        }
+    }
+
+    override fun onErrorRequest(
+        session: EngineSession,
+        errorType: ErrorType,
+        uri: String?
+    ): RequestInterceptor.ErrorResponse {
+        val errorPage = ErrorPages.createUrlEncodedErrorPage(context, errorType, uri)
+        return RequestInterceptor.ErrorResponse(errorPage)
+    }
+
+    override fun interceptsAppInitiatedRequests() = true
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionDomains.kt b/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionDomains.kt
deleted file mode 100644
index 1f6487209390..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionDomains.kt
+++ /dev/null
@@ -1,78 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.exceptions
-
-import android.content.Context
-import android.content.SharedPreferences
-
-/**
- * Contains functionality to manage custom domains for allow-list.
- */
-object ExceptionDomains {
-    private const val PREFERENCE_NAME = "exceptions"
-    private const val KEY_DOMAINS = "exceptions_domains"
-    private const val SEPARATOR = "@<;>@"
-
-    private var exceptions: List<String>? = null
-
-    /**
-     * Loads the previously added/saved custom domains from preferences.
-     *
-     * @param context the application context
-     * @return list of custom domains
-     */
-    fun load(context: Context): List<String> {
-        if (exceptions == null) {
-            exceptions = (preferences(context)
-                    .getString(KEY_DOMAINS, "") ?: "")
-                    .split(SEPARATOR)
-                    .filter { !it.isEmpty() }
-        }
-
-        return exceptions ?: listOf()
-    }
-
-    /**
-     * Saves the provided domains to preferences.
-     *
-     * @param context the application context
-     * @param domains list of domains
-     */
-    fun save(context: Context, domains: List<String>) {
-        exceptions = domains
-
-        preferences(context)
-            .edit()
-            .putString(KEY_DOMAINS, domains.joinToString(separator = SEPARATOR))
-            .apply()
-    }
-
-    /**
-     * Adds the provided domain to preferences.
-     *
-     * @param context the application context
-     * @param domain the domain to add
-     */
-    fun add(context: Context, domain: String) {
-        val domains = mutableListOf<String>()
-        domains.addAll(load(context))
-        domains.add(domain)
-
-        save(context, domains)
-    }
-
-    /**
-     * Removes the provided domain from preferences.
-     *
-     * @param context the application context
-     * @param domains the domain to remove
-     */
-    fun remove(context: Context, domains: List<String>) {
-        save(context, load(context) - domains)
-    }
-
-    private fun preferences(context: Context): SharedPreferences =
-        context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_PRIVATE)
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsListFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsListFragment.kt
index f209db710816..73892b87d073 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsListFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsListFragment.kt
@@ -4,14 +4,9 @@
 
 package org.mozilla.focus.exceptions
 
-import androidx.fragment.app.Fragment
 import android.content.Context
 import android.graphics.Color
 import android.os.Bundle
-import androidx.recyclerview.widget.LinearLayoutManager
-import androidx.recyclerview.widget.RecyclerView
-import androidx.recyclerview.widget.ItemTouchHelper
-import androidx.recyclerview.widget.ItemTouchHelper.SimpleCallback
 import android.view.LayoutInflater
 import android.view.Menu
 import android.view.MenuInflater
@@ -22,20 +17,25 @@ import android.view.ViewGroup
 import android.widget.CheckBox
 import android.widget.CompoundButton
 import android.widget.TextView
+import androidx.fragment.app.Fragment
+import androidx.recyclerview.widget.ItemTouchHelper
+import androidx.recyclerview.widget.ItemTouchHelper.SimpleCallback
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
 import kotlinx.android.synthetic.main.fragment_exceptions_domains.*
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Dispatchers.IO
-import kotlinx.coroutines.Dispatchers.Main
 import kotlinx.coroutines.Job
-import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
+import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
 import org.mozilla.focus.R
 import org.mozilla.focus.autocomplete.AutocompleteDomainFormatter
+import org.mozilla.focus.ext.components
+import org.mozilla.focus.ext.requireComponents
 import org.mozilla.focus.settings.BaseSettingsFragment
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import java.util.Collections
 import org.mozilla.focus.utils.ViewUtils
+import java.util.Collections
 import kotlin.coroutines.CoroutineContext
 
 typealias DomainFormatter = (String) -> String
@@ -115,11 +115,12 @@ open class ExceptionsListFragment : Fragment(), CoroutineScope {
         }
 
         removeAllExceptions.setOnClickListener {
-            val domains = ExceptionDomains.load(context!!)
-            TelemetryWrapper.removeAllExceptionDomains(domains.size)
-            ExceptionDomains.remove(context!!, domains)
+            requireComponents.trackingProtectionUseCases.removeAllExceptions()
+
+            TelemetryWrapper.removeAllExceptionDomains()
+
             @Suppress("DEPRECATION")
-            requireFragmentManager().popBackStack()
+            fragmentManager!!.popBackStack()
         }
     }
 
@@ -179,19 +180,16 @@ open class ExceptionsListFragment : Fragment(), CoroutineScope {
      * Adapter implementation for the list of exception domains.
      */
     inner class DomainListAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
-        private val domains: MutableList<String> = mutableListOf()
-        private val selectedDomains: MutableList<String> = mutableListOf()
+        private var exceptions: List<TrackingProtectionException> = emptyList()
+        private val selectedExceptions: MutableList<TrackingProtectionException> = mutableListOf()
 
         fun refresh(context: Context, body: (() -> Unit)? = null) {
-            this@ExceptionsListFragment.launch(Main) {
-                val updatedDomains = async { ExceptionDomains.load(context) }.await()
-
-                domains.clear()
-                domains.addAll(updatedDomains)
-
-                notifyDataSetChanged()
-
-                body?.invoke()
+            this@ExceptionsListFragment.launch(Dispatchers.Main) {
+                context.components.trackingProtectionUseCases.fetchExceptions {
+                    exceptions = it
+                    notifyDataSetChanged()
+                    body?.invoke()
+                }
             }
         }
 
@@ -206,14 +204,14 @@ open class ExceptionsListFragment : Fragment(), CoroutineScope {
                 else -> throw IllegalArgumentException("Unknown view type: $viewType")
             }
 
-        override fun getItemCount(): Int = domains.size
+        override fun getItemCount(): Int = exceptions.size
 
         override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
             if (holder is DomainViewHolder) {
                 holder.bind(
-                    domains[position],
+                    exceptions[position],
                     isSelectionMode(),
-                    selectedDomains,
+                    selectedExceptions,
                     itemTouchHelper,
                     this@ExceptionsListFragment
                 )
@@ -226,15 +224,14 @@ open class ExceptionsListFragment : Fragment(), CoroutineScope {
             }
         }
 
-        fun selection(): List<String> = selectedDomains
+        fun selection(): List<TrackingProtectionException> = selectedExceptions
 
         fun move(from: Int, to: Int) {
-            Collections.swap(domains, from, to)
+            Collections.swap(exceptions, from, to)
             notifyItemMoved(from, to)
 
-            launch(IO) {
-                ExceptionDomains.save(activity!!.applicationContext, domains)
-            }
+            // The underlying storage in GeckoView doesn't support ordering - and ordering is also
+            // not necessary. We may just need to remove this feature from this list.
         }
     }
 
@@ -254,21 +251,21 @@ open class ExceptionsListFragment : Fragment(), CoroutineScope {
         }
 
         fun bind(
-            domain: String,
+            exception: TrackingProtectionException,
             isSelectionMode: Boolean,
-            selectedDomains: MutableList<String>,
+            selectedExceptions: MutableList<TrackingProtectionException>,
             itemTouchHelper: ItemTouchHelper,
             fragment: ExceptionsListFragment
         ) {
-            domainView.text = domainFormatter?.invoke(domain) ?: domain
+            domainView.text = domainFormatter?.invoke(exception.url) ?: exception.url
 
             checkBoxView.visibility = if (isSelectionMode) View.VISIBLE else View.GONE
-            checkBoxView.isChecked = selectedDomains.contains(domain)
+            checkBoxView.isChecked = selectedExceptions.contains(exception)
             checkBoxView.setOnCheckedChangeListener { _: CompoundButton, isChecked: Boolean ->
                 if (isChecked) {
-                    selectedDomains.add(domain)
+                    selectedExceptions.add(exception)
                 } else {
-                    selectedDomains.remove(domain)
+                    selectedExceptions.remove(exception)
                 }
 
                 fragment.activity?.invalidateOptionsMenu()
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsRemoveFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsRemoveFragment.kt
index 547d29939005..2b39e4642090 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsRemoveFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/exceptions/ExceptionsRemoveFragment.kt
@@ -10,9 +10,9 @@ import android.view.MenuInflater
 import android.view.MenuItem
 import kotlinx.android.synthetic.main.fragment_exceptions_domains.*
 import kotlinx.coroutines.Dispatchers.Main
-import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
 import org.mozilla.focus.R
+import org.mozilla.focus.ext.components
 import org.mozilla.focus.settings.BaseSettingsFragment
 import org.mozilla.focus.telemetry.TelemetryWrapper
 
@@ -31,13 +31,13 @@ class ExceptionsRemoveFragment : ExceptionsListFragment() {
     }
 
     private fun removeSelectedDomains(context: Context) {
-        val domains = (exceptionList.adapter as DomainListAdapter).selection()
-        TelemetryWrapper.removeExceptionDomains(domains.size)
-        if (domains.isNotEmpty()) {
+        val exceptions = (exceptionList.adapter as DomainListAdapter).selection()
+        TelemetryWrapper.removeExceptionDomains(exceptions.size)
+        if (exceptions.isNotEmpty()) {
             launch(Main) {
-                async {
-                    ExceptionDomains.remove(context, domains)
-                }.await()
+                exceptions.forEach { exception ->
+                    context.components.trackingProtectionUseCases.removeException(exception)
+                }
 
                 @Suppress("DEPRECATION")
                 requireFragmentManager().popBackStack()
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/ext/Session.kt b/focus-android/app/src/main/java/org/mozilla/focus/ext/Session.kt
deleted file mode 100644
index 822e5563c071..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/ext/Session.kt
+++ /dev/null
@@ -1,64 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.ext
-
-import android.os.Bundle
-import mozilla.components.browser.session.Session
-import org.mozilla.geckoview.GeckoSession
-import java.util.WeakHashMap
-
-// Extension methods on the Session class. This is used for additional session data that is not part
-// of the upstream browser-session component yet.
-
-private val extensions = WeakHashMap<Session, SessionExtension>()
-
-private fun getOrPutExtension(session: Session): SessionExtension {
-    extensions[session]?.let { return it }
-
-    return SessionExtension().also {
-        extensions[session] = it
-    }
-}
-
-private class SessionExtension {
-    var savedGeckoSession: GeckoSession? = null
-    var savedWebViewState: Bundle? = null
-    var shouldRequestDesktopSite: Boolean = false
-}
-
-/**
- * Saving the Gecko Session attached to the component session. We need this now because we can no
- * longer serialize a gecko session into a [Bundle] as we did before.
- *
- * Temporary solution until we can use the browser-engine component.
- *
- * Component upstream issue:
- * https://github.com/mozilla-mobile/android-components/issues/408
- */
-var Session.savedGeckoSession: GeckoSession?
-    get() = getOrPutExtension(this).savedGeckoSession
-    set(value) { getOrPutExtension(this).savedGeckoSession = value }
-
-/**
- * Saving the state attached ot a session.
- *
- * Temporary solution until we can use the browser-engine component.
- *
- * Component upstream issue:
- * https://github.com/mozilla-mobile/android-components/issues/408
- */
-var Session.savedWebViewState: Bundle?
-    get() = getOrPutExtension(this).savedWebViewState
-    set(value) { getOrPutExtension(this).savedWebViewState = value }
-
-/**
- * Whether to use desktop mode for this session.
- *
- * Component upstream issue:
- * https://github.com/mozilla-mobile/android-components/issues/701
- */
-var Session.shouldRequestDesktopSite: Boolean
-    get() = getOrPutExtension(this).shouldRequestDesktopSite
-    set(value) { getOrPutExtension(this).shouldRequestDesktopSite = value }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/findinpage/FindInPageCoordinator.kt b/focus-android/app/src/main/java/org/mozilla/focus/findinpage/FindInPageCoordinator.kt
deleted file mode 100644
index df9b5bbbeb92..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/findinpage/FindInPageCoordinator.kt
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.mozilla.focus.findinpage
-
-import androidx.lifecycle.MutableLiveData
-import org.mozilla.focus.web.IFindListener
-
-class FindInPageCoordinator : IFindListener {
-    val matches = MutableLiveData<Pair<Int, Int>>()
-
-    fun reset() = matches.postValue(Pair(0, 0))
-
-    override fun onFindResultReceived(activeMatchOrdinal: Int, numberOfMatches: Int, isDoneCounting: Boolean) {
-        matches.postValue(Pair(activeMatchOrdinal, numberOfMatches))
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
index bd1638067e45..3e96cd55c9de 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
@@ -4,35 +4,16 @@
 
 package org.mozilla.focus.fragment
 
-import android.Manifest
-import android.app.DownloadManager
 import android.app.PendingIntent
-import androidx.lifecycle.LifecycleObserver
-import androidx.lifecycle.Observer
-import androidx.lifecycle.ProcessLifecycleOwner
 import android.content.ClipData
 import android.content.ClipboardManager
 import android.content.Context
 import android.content.Intent
-import android.content.IntentFilter
-import android.content.pm.PackageManager
 import android.graphics.Color
 import android.graphics.drawable.ColorDrawable
-import android.graphics.drawable.TransitionDrawable
 import android.net.Uri
 import android.os.Build
 import android.os.Bundle
-import android.os.Environment
-import androidx.annotation.RequiresApi
-import com.google.android.material.appbar.AppBarLayout
-import androidx.coordinatorlayout.widget.CoordinatorLayout
-import androidx.core.app.ActivityCompat
-import androidx.core.content.ContextCompat
-import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
-import android.text.Editable
-import android.text.TextUtils
-import android.text.TextWatcher
-import android.util.Log
 import android.view.Gravity
 import android.view.LayoutInflater
 import android.view.View
@@ -40,127 +21,120 @@ import android.view.ViewGroup
 import android.view.WindowManager
 import android.view.accessibility.AccessibilityEvent
 import android.view.accessibility.AccessibilityManager
-import android.view.inputmethod.EditorInfo
-import android.webkit.CookieManager
-import android.webkit.URLUtil
+import android.webkit.MimeTypeMap
 import android.widget.FrameLayout
 import android.widget.ImageButton
 import android.widget.ImageView
 import android.widget.TextView
 import android.widget.Toast
+import androidx.annotation.RequiresApi
+import androidx.core.content.ContextCompat
+import androidx.lifecycle.LifecycleObserver
+import androidx.lifecycle.ProcessLifecycleOwner
 import androidx.preference.PreferenceManager
-import kotlinx.android.synthetic.main.browser_display_toolbar.*
+import com.google.android.material.appbar.AppBarLayout
+import com.google.android.material.snackbar.Snackbar
 import kotlinx.android.synthetic.main.fragment_browser.*
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.Job
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
+import mozilla.components.browser.state.selector.findTab
+import mozilla.components.browser.state.selector.findTabOrCustomTab
 import mozilla.components.browser.state.state.SessionState
-import mozilla.components.concept.engine.content.blocking.Tracker
+import mozilla.components.browser.state.state.content.DownloadState
+import mozilla.components.concept.engine.Engine
+import mozilla.components.concept.engine.EngineView
+import mozilla.components.feature.contextmenu.ContextMenuCandidate
+import mozilla.components.feature.contextmenu.ContextMenuFeature
+import mozilla.components.feature.downloads.AbstractFetchDownloadService
+import mozilla.components.feature.downloads.DownloadsFeature
+import mozilla.components.feature.downloads.manager.FetchDownloadManager
+import mozilla.components.feature.findinpage.view.FindInPageBar
+import mozilla.components.feature.prompts.PromptFeature
+import mozilla.components.feature.session.FullScreenFeature
+import mozilla.components.feature.session.SessionFeature
+import mozilla.components.feature.session.SessionUseCases
 import mozilla.components.lib.crash.Crash
+import mozilla.components.support.base.feature.PermissionsFeature
+import mozilla.components.support.base.feature.ViewBoundFeatureWrapper
 import mozilla.components.support.utils.ColorUtils
-import mozilla.components.support.utils.DownloadUtils
 import mozilla.components.support.utils.DrawableUtils
 import org.mozilla.focus.R
 import org.mozilla.focus.activity.InstallFirefoxActivity
 import org.mozilla.focus.activity.MainActivity
-import org.mozilla.focus.animation.TransitionDrawableGroup
 import org.mozilla.focus.biometrics.BiometricAuthenticationDialogFragment
 import org.mozilla.focus.biometrics.BiometricAuthenticationHandler
 import org.mozilla.focus.biometrics.Biometrics
-import org.mozilla.focus.broadcastreceiver.DownloadBroadcastReceiver
-import org.mozilla.focus.exceptions.ExceptionDomains
+import org.mozilla.focus.browser.DisplayToolbar
+import org.mozilla.focus.browser.binding.BlockingThemeBinding
+import org.mozilla.focus.browser.binding.LoadingBinding
+import org.mozilla.focus.browser.binding.MenuBinding
+import org.mozilla.focus.browser.binding.ProgressBinding
+import org.mozilla.focus.browser.binding.SecurityInfoBinding
+import org.mozilla.focus.browser.binding.ToolbarButtonBinding
+import org.mozilla.focus.browser.binding.UrlBinding
+import org.mozilla.focus.browser.integration.FindInPageIntegration
+import org.mozilla.focus.downloads.DownloadService
+import org.mozilla.focus.ext.components
 import org.mozilla.focus.ext.contentState
 import org.mozilla.focus.ext.isSearch
 import org.mozilla.focus.ext.requireComponents
-import org.mozilla.focus.ext.shouldRequestDesktopSite
-import org.mozilla.focus.findinpage.FindInPageCoordinator
-import org.mozilla.focus.gecko.NestedGeckoView
 import org.mozilla.focus.locale.LocaleAwareAppCompatActivity
-import org.mozilla.focus.menu.browser.BrowserMenu
-import org.mozilla.focus.menu.context.WebContextMenu
+import org.mozilla.focus.locale.LocaleAwareFragment
 import org.mozilla.focus.observer.LoadTimeObserver
 import org.mozilla.focus.open.OpenWithFragment
 import org.mozilla.focus.popup.PopupUtils
-import org.mozilla.focus.session.SessionCallbackProxy
-import org.mozilla.focus.session.removeAndCloseAllSessions
-import org.mozilla.focus.session.removeAndCloseSession
 import org.mozilla.focus.session.ui.SessionsSheetFragment
 import org.mozilla.focus.telemetry.CrashReporterWrapper
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
+import org.mozilla.focus.utils.AppPermissionCodes.REQUEST_CODE_DOWNLOAD_PERMISSIONS
+import org.mozilla.focus.utils.AppPermissionCodes.REQUEST_CODE_PROMPT_PERMISSIONS
 import org.mozilla.focus.utils.Browsers
-import org.mozilla.focus.utils.Features
 import org.mozilla.focus.utils.StatusBarUtils
 import org.mozilla.focus.utils.SupportUtils
-import org.mozilla.focus.utils.UrlUtils
-import org.mozilla.focus.utils.ViewUtils
-import org.mozilla.focus.web.Download
-import org.mozilla.focus.web.HttpAuthenticationDialogBuilder
-import org.mozilla.focus.web.IWebView
+import org.mozilla.focus.utils.createTab
 import org.mozilla.focus.widget.AnimatedProgressBar
 import org.mozilla.focus.widget.FloatingEraseButton
 import org.mozilla.focus.widget.FloatingSessionsButton
-import java.lang.ref.WeakReference
-import java.net.MalformedURLException
-import java.net.URL
 import kotlin.coroutines.CoroutineContext
 
 /**
  * Fragment for displaying the browser UI.
  */
 @Suppress("LargeClass", "TooManyFunctions")
-class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
-    DownloadDialogFragment.DownloadDialogListener, View.OnLongClickListener,
+class BrowserFragment :
+    LocaleAwareFragment(),
+    LifecycleObserver,
+    View.OnClickListener,
+    View.OnLongClickListener,
     BiometricAuthenticationDialogFragment.BiometricAuthenticationListener,
     CoroutineScope {
 
-    private var pendingDownload: Download? = null
-    private var backgroundTransitionGroup: TransitionDrawableGroup? = null
     private var urlView: TextView? = null
-    private var progressView: AnimatedProgressBar? = null
-    private var blockView: FrameLayout? = null
-    private var securityView: ImageView? = null
-    private var menuView: ImageButton? = null
     private var statusBar: View? = null
     private var urlBar: View? = null
     private var popupTint: FrameLayout? = null
-    private var swipeRefresh: SwipeRefreshLayout? = null
-    private var menuWeakReference: WeakReference<BrowserMenu>? = WeakReference<BrowserMenu>(null)
-
-    /**
-     * Container for custom video views shown in fullscreen mode.
-     */
-    private var videoContainer: ViewGroup? = null
-
-    private var isFullscreen: Boolean = false
-
-    /**
-     * Container containing the browser chrome and web content.
-     */
-    private var browserContainer: View? = null
-
-    private var forwardButton: View? = null
-    private var backButton: View? = null
-    private var refreshButton: View? = null
-    private var stopButton: View? = null
-
-    private var findInPageView: View? = null
-    private var findInPageViewHeight: Int = 0
-    private var findInPageQuery: TextView? = null
-    private var findInPageResultTextView: TextView? = null
-    private var findInPageNext: ImageButton? = null
-    private var findInPagePrevious: ImageButton? = null
-    private var closeFindInPage: ImageButton? = null
 
-    private var fullscreenCallback: IWebView.FullscreenCallback? = null
+    private var toolbarView: DisplayToolbar? = null
+    private var engineView: EngineView? = null
 
-    private var manager: DownloadManager? = null
+    private val findInPageIntegration = ViewBoundFeatureWrapper<FindInPageIntegration>()
 
-    private var downloadBroadcastReceiver: DownloadBroadcastReceiver? = null
+    private val sessionFeature = ViewBoundFeatureWrapper<SessionFeature>()
+    private val fullScreenFeature = ViewBoundFeatureWrapper<FullScreenFeature>()
+    private val promptFeature = ViewBoundFeatureWrapper<PromptFeature>()
+    private val contextMenuFeature = ViewBoundFeatureWrapper<ContextMenuFeature>()
+    private val downloadsFeature = ViewBoundFeatureWrapper<DownloadsFeature>()
 
-    private val findInPageCoordinator = FindInPageCoordinator()
+    private val urlBinding = ViewBoundFeatureWrapper<UrlBinding>()
+    private val securityInfoBinding = ViewBoundFeatureWrapper<SecurityInfoBinding>()
+    private val loadingBinding = ViewBoundFeatureWrapper<LoadingBinding>()
+    private val progressBinding = ViewBoundFeatureWrapper<ProgressBinding>()
+    private val menuBinding = ViewBoundFeatureWrapper<MenuBinding>()
+    private val toolbarButtonBinding = ViewBoundFeatureWrapper<ToolbarButtonBinding>()
+    private val blockingThemeBinding = ViewBoundFeatureWrapper<BlockingThemeBinding>()
 
     private var biometricController: BiometricAuthenticationHandler? = null
 
@@ -177,23 +151,16 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
 
     var openedFromExternalLink: Boolean = false
 
-    override lateinit var session: Session
+    lateinit var session: Session
         private set
 
-    override val initialUrl: String?
-        get() = session.url
-
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
         ProcessLifecycleOwner.get().lifecycle.addObserver(this)
 
         val sessionUUID = arguments!!.getString(ARGUMENT_SESSION_UUID) ?: throw IllegalAccessError("No session exists")
 
-        session = requireComponents.sessionManager.findSessionById(sessionUUID) ?: Session("about:blank")
-
-        findInPageCoordinator.matches.observe(
-            this,
-            Observer { matches -> updateFindInPageResult(matches!!.first, matches.second) })
+        session = requireComponents.sessionManager.findSessionById(sessionUUID) ?: createTab("about:blank")
     }
 
     override fun onPause() {
@@ -204,18 +171,7 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             view!!.alpha = 0f
         }
 
-        requireContext().unregisterReceiver(downloadBroadcastReceiver)
-
-        if (isFullscreen) {
-            getWebView()?.exitFullscreen()
-        }
-
-        val menu = menuWeakReference!!.get()
-        if (menu != null) {
-            menu.dismiss()
-
-            menuWeakReference!!.clear()
-        }
+        menuBinding.get()?.pause()
     }
 
     override fun onStop() {
@@ -224,18 +180,9 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     }
 
     @Suppress("LongMethod", "ComplexMethod")
-    override fun inflateLayout(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
-        if (savedInstanceState != null && savedInstanceState.containsKey(RESTORE_KEY_DOWNLOAD)) {
-            // If this activity was destroyed before we could start a download (e.g. because we were waiting for a
-            // permission) then restore the download object.
-            pendingDownload = savedInstanceState.getParcelable(RESTORE_KEY_DOWNLOAD)
-        }
-
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
         val view = inflater.inflate(R.layout.fragment_browser, container, false)
 
-        videoContainer = view.findViewById<View>(R.id.video_container) as ViewGroup
-        browserContainer = view.findViewById(R.id.browser_container)
-
         urlBar = view.findViewById(R.id.urlbar)
         statusBar = view.findViewById(R.id.status_bar_background)
 
@@ -244,110 +191,209 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         urlView = view.findViewById<View>(R.id.display_url) as TextView
         urlView!!.setOnLongClickListener(this)
 
-        progressView = view.findViewById<View>(R.id.progress) as AnimatedProgressBar
+        toolbarView = view.findViewById<DisplayToolbar>(R.id.appbar)
 
-        swipeRefresh = view.findViewById<View>(R.id.swipe_refresh) as SwipeRefreshLayout
-        swipeRefresh!!.setColorSchemeResources(R.color.colorAccent)
-        swipeRefresh!!.isEnabled = Features.SWIPE_TO_REFRESH
+        LoadTimeObserver.addObservers(session, this)
 
-        swipeRefresh!!.setOnRefreshListener {
-            reload()
+        val blockIcon = view.findViewById<View>(R.id.block_image) as ImageView
+        blockIcon.setImageResource(R.drawable.ic_tracking_protection_disabled)
 
-            TelemetryWrapper.swipeReloadEvent()
+        if (session.isCustomTabSession()) {
+            initialiseCustomTabUi(view)
+        } else {
+            initialiseNormalBrowserUi(view)
         }
 
-        findInPageView = view.findViewById(R.id.find_in_page)
-
-        findInPageQuery = view.findViewById(R.id.queryText)
-        findInPageResultTextView = view.findViewById(R.id.resultText)
-
-        findInPageQuery!!.addTextChangedListener(
-            object : TextWatcher {
-                override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
-
-                override fun afterTextChanged(s: Editable) {}
+        return view
+    }
 
-                override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
-                    if (!TextUtils.isEmpty(s)) {
-                        getWebView()?.findAllAsync(s.toString())
-                    }
-                }
+    @Suppress("ComplexCondition", "LongMethod")
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        val components = requireComponents
+
+        engineView = (view.findViewById<View>(R.id.webview) as EngineView)
+
+        val progressView = view.findViewById<View>(R.id.progress) as AnimatedProgressBar
+        val menuView = view.findViewById<View>(R.id.menuView) as ImageButton
+        val blockView = view.findViewById<View>(R.id.block) as FrameLayout
+        val securityView = view.findViewById<ImageView>(R.id.security_info)
+
+        findInPageIntegration.set(FindInPageIntegration(
+            components.store,
+            view.findViewById<FindInPageBar>(R.id.find_in_page),
+            engineView!!
+        ), this, view)
+
+        fullScreenFeature.set(FullScreenFeature(
+            components.store,
+            SessionUseCases(components.store, components.sessionManager),
+            session.id,
+            ::viewportFitChanged,
+            ::fullScreenChanged
+        ), this, view)
+
+        contextMenuFeature.set(ContextMenuFeature(
+            parentFragmentManager,
+            components.store,
+            ContextMenuCandidate.defaultCandidates(
+                    requireContext(),
+                    components.tabsUseCases,
+                    components.contextMenuUseCases,
+                    view
+            ),
+            engineView!!,
+            requireComponents.contextMenuUseCases
+        ), this, view)
+
+        sessionFeature.set(SessionFeature(
+            components.store,
+            components.sessionUseCases.goBack,
+            engineView!!,
+            session.id
+        ), this, view)
+
+        promptFeature.set(PromptFeature(
+            fragment = this,
+            store = components.store,
+            customTabId = session.id,
+            fragmentManager = parentFragmentManager,
+            onNeedToRequestPermissions = { permissions ->
+                requestPermissions(permissions, REQUEST_CODE_PROMPT_PERMISSIONS)
             }
+        ), this, view)
+
+        downloadsFeature.set(DownloadsFeature(
+            requireContext().applicationContext,
+            components.store,
+            components.downloadsUseCases,
+                fragmentManager = childFragmentManager,
+                downloadManager = FetchDownloadManager(
+                        requireContext().applicationContext,
+                        components.store,
+                        DownloadService::class
+                ),
+                onNeedToRequestPermissions = { permissions ->
+                    requestPermissions(permissions, REQUEST_CODE_DOWNLOAD_PERMISSIONS)
+                },
+                onDownloadStopped = { state, _, status ->
+                    showDownloadSnackbar(state, status)
+                }
+        ), this, view)
+
+        urlBinding.set(
+            UrlBinding(
+                components.store,
+                session.id,
+                urlView!!
+            ),
+            owner = this,
+            view = urlView!!
         )
-        findInPageQuery!!.setOnClickListener(this)
-        findInPageQuery!!.setOnEditorActionListener { _, actionId, _ ->
-            if (actionId == EditorInfo.IME_ACTION_DONE) {
-                ViewUtils.hideKeyboard(findInPageQuery!!)
-                findInPageQuery!!.isCursorVisible = false
-            }
-            false
-        }
 
-        findInPagePrevious = view.findViewById(R.id.previousResult)
-        findInPagePrevious!!.setOnClickListener(this)
-
-        findInPageNext = view.findViewById(R.id.nextResult)
-        findInPageNext!!.setOnClickListener(this)
-
-        closeFindInPage = view.findViewById(R.id.close_find_in_page)
-        closeFindInPage!!.setOnClickListener(this)
-
-        setShouldRequestDesktop(session.shouldRequestDesktopSite)
-
-        LoadTimeObserver.addObservers(session, this)
+        menuBinding.set(
+            MenuBinding(
+                this,
+                components.store,
+                session.id,
+                menuView
+            ),
+            owner = this,
+            view = view
+        )
 
-        refreshButton = view.findViewById(R.id.refresh)
-        refreshButton?.let { it.setOnClickListener(this) }
+        securityInfoBinding.set(
+            SecurityInfoBinding(
+                this,
+                components.store,
+                session.id,
+                securityView!!
+            ),
+            owner = this,
+            view = securityView
+        )
 
-        stopButton = view.findViewById(R.id.stop)
-        stopButton?.let { it.setOnClickListener(this) }
+        loadingBinding.set(
+            LoadingBinding(
+                components.store,
+                session.id,
+                progressView
+            ),
+            owner = this,
+            view = view
+        )
 
-        forwardButton = view.findViewById(R.id.forward)
-        forwardButton?.let { it.setOnClickListener(this) }
+        progressBinding.set(
+            ProgressBinding(
+                components.store,
+                session.id,
+                progressView
+            ),
+            owner = this,
+            view = progressView
+        )
 
-        backButton = view.findViewById(R.id.back)
-        backButton?.let { it.setOnClickListener(this) }
+        blockingThemeBinding.set(
+            BlockingThemeBinding(
+                components.store,
+                session,
+                statusBar!!,
+                urlBar!!,
+                blockView
+            ),
+            owner = this,
+            view = statusBar!!
+        )
 
-        val blockIcon = view.findViewById<View>(R.id.block_image) as ImageView
-        blockIcon.setImageResource(R.drawable.ic_tracking_protection_disabled)
+        val refreshButton: View? = view.findViewById(R.id.refresh)
+        val stopButton: View? = view.findViewById(R.id.stop)
+        val forwardButton: View? = view.findViewById(R.id.forward)
+        val backButton: View? = view.findViewById(R.id.back)
+
+        if (refreshButton != null && stopButton != null && forwardButton != null && backButton != null) {
+            toolbarButtonBinding.set(
+                ToolbarButtonBinding(
+                    components.store,
+                    session.id,
+                    forwardButton,
+                    backButton,
+                    refreshButton,
+                    stopButton
+                ),
+                owner = this,
+                view = forwardButton
+            )
 
-        blockView = view.findViewById<View>(R.id.block) as FrameLayout
+            refreshButton.setOnClickListener(this)
+            stopButton.setOnClickListener(this)
+            forwardButton.setOnClickListener(this)
+            backButton.setOnClickListener(this)
+        }
+    }
 
-        securityView = view.findViewById(R.id.security_info)
+    @RequiresApi(Build.VERSION_CODES.P)
+    private fun viewportFitChanged(viewportFit: Int) {
+        requireActivity().window.attributes.layoutInDisplayCutoutMode = viewportFit
+    }
 
-        securityView!!.setImageResource(R.drawable.ic_internet)
+    private fun fullScreenChanged(enabled: Boolean) {
+        if (enabled) {
+            toolbarView?.visibility = View.GONE
 
-        securityView!!.setOnClickListener(this)
+            toolbarView!!.setExpanded(false, true)
+            statusBar!!.visibility = View.GONE
 
-        menuView = view.findViewById<View>(R.id.menuView) as ImageButton
-        menuView!!.setOnClickListener(this)
+            engineView?.setDynamicToolbarMaxHeight(0)
 
-        if (session.isCustomTabSession()) {
-            initialiseCustomTabUi(view)
+            switchToImmersiveMode()
         } else {
-            initialiseNormalBrowserUi(view)
-        }
+            toolbarView?.visibility = View.VISIBLE
 
-        // Pre-calculate the height of the find in page UI so that we can accurately add padding
-        // to the WebView when we present it.
-        findInPageView!!.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED)
-        findInPageViewHeight = findInPageView!!.measuredHeight
+            toolbarView!!.setExpanded(true, true)
+            statusBar!!.visibility = View.VISIBLE
 
-        return view
-    }
+            engineView?.setDynamicToolbarMaxHeight(toolbarView?.measuredHeight ?: 0)
 
-    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
-        @Suppress("DEPRECATION")
-        session.register(sessionObserver, owner = this)
-
-        // We need to update the views with the initial values. Other than LiveData an Observer doesn't get the initial
-        // values automatically yet.
-        // We want to change that in Android Components: https://github.com/mozilla-mobile/android-components/issues/665
-        sessionObserver.apply {
-            onTrackerBlockingEnabledChanged(session, session.trackerBlockingEnabled)
-            onLoadingStateChanged(session, session.loading)
-            onUrlChanged(session, session.url)
-            onSecurityChanged(session, session.securityInfo)
+            exitImmersiveModeIfNeeded()
         }
     }
 
@@ -468,152 +514,10 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         }
 
         // We need to tint some icons.. We already tinted the close button above. Let's tint our other icons too.
-        securityView!!.setColorFilter(textColor)
+        securityInfoBinding.get()?.updateColorFilter(textColor)
 
         val menuIcon = DrawableUtils.loadAndTintDrawable(requireContext(), R.drawable.ic_menu, textColor)
-        menuView!!.setImageDrawable(menuIcon)
-    }
-
-    override fun onSaveInstanceState(outState: Bundle) {
-        super.onSaveInstanceState(outState)
-
-        if (pendingDownload != null) {
-            // We were not able to start this download yet (waiting for a permission). Save this download
-            // so that we can start it once we get restored and receive the permission.
-            outState.putParcelable(RESTORE_KEY_DOWNLOAD, pendingDownload)
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    override fun createCallback(): IWebView.Callback {
-        return SessionCallbackProxy(session, requireComponents.store, object : IWebView.Callback {
-            override fun onPageStarted(url: String) {}
-
-            override fun onPageFinished(isSecure: Boolean) {}
-
-            override fun onSecurityChanged(isSecure: Boolean, host: String, organization: String) {}
-
-            override fun onURLChanged(url: String) {}
-
-            override fun onTitleChanged(title: String) {}
-
-            override fun onRequest(isTriggeredByUserGesture: Boolean) {}
-
-            override fun onProgress(progress: Int) {}
-
-            override fun countBlockedTracker() {}
-
-            override fun resetBlockedTrackers() {}
-
-            override fun onBlockingStateChanged(isBlockingEnabled: Boolean) {}
-
-            override fun onHttpAuthRequest(callback: IWebView.HttpAuthCallback, host: String, realm: String) {
-                val builder = HttpAuthenticationDialogBuilder.Builder(activity, host, realm)
-                    .setOkListener { _, _, username, password -> callback.proceed(username, password) }
-                    .setCancelListener { callback.cancel() }
-                    .build()
-
-                builder.createDialog()
-                builder.show()
-            }
-
-            override fun onRequestDesktopStateChanged(shouldRequestDesktop: Boolean) {}
-
-            override fun onLongPress(hitTarget: IWebView.HitTarget) {
-                WebContextMenu.show(requireActivity(), this, hitTarget, session)
-            }
-
-            override fun onEnterFullScreen(callback: IWebView.FullscreenCallback, view: View?) {
-                fullscreenCallback = callback
-                isFullscreen = true
-
-                // View is passed in as null for GeckoView fullscreen
-                if (view != null) {
-                    // Hide browser UI and web content
-                    browserContainer!!.visibility = View.INVISIBLE
-
-                    // Add view to video container and make it visible
-                    val params = FrameLayout.LayoutParams(
-                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
-                    )
-                    videoContainer!!.addView(view, params)
-                    videoContainer!!.visibility = View.VISIBLE
-
-                    // Switch to immersive mode: Hide system bars other UI controls
-                    switchToImmersiveMode()
-                } else {
-                    appbar?.setExpanded(false, true)
-                    (getWebView() as? NestedGeckoView)?.isNestedScrollingEnabled = false
-                    // Hide status bar when entering fullscreen with GeckoView
-                    statusBar!!.visibility = View.GONE
-                    // Switch to immersive mode: Hide system bars other UI controls
-                    switchToImmersiveMode()
-                }
-            }
-
-            override fun onExitFullScreen() {
-                if (AppConstants.isGeckoBuild) {
-                    appbar?.setExpanded(true, true)
-                    (getWebView() as? NestedGeckoView)?.isNestedScrollingEnabled = true
-                }
-
-                isFullscreen = false
-
-                // Remove custom video views and hide container
-                videoContainer!!.removeAllViews()
-                videoContainer!!.visibility = View.GONE
-
-                // Show browser UI and web content again
-                browserContainer!!.visibility = View.VISIBLE
-
-                // Show status bar again (hidden in GeckoView versions)
-                statusBar!!.visibility = View.VISIBLE
-
-                exitImmersiveModeIfNeeded()
-
-                // Notify renderer that we left fullscreen mode.
-                if (fullscreenCallback != null) {
-                    fullscreenCallback!!.fullScreenExited()
-                    fullscreenCallback = null
-                }
-            }
-
-            override fun onDownloadStart(download: Download) {
-                if (PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(
-                        requireContext(),
-                        Manifest.permission.WRITE_EXTERNAL_STORAGE
-                    )
-                ) {
-                    // Long press image displays its own dialog and we handle other download cases here
-                    if (!isDownloadFromLongPressImage(download)) {
-                        showDownloadPromptDialog(download)
-                    } else {
-                        // Download dialog has already been shown from long press on image. Proceed with download.
-                        queueDownload(download)
-                    }
-                } else {
-                    // We do not have the permission to write to the external storage. Request the permission and start
-                    // the  download from onRequestPermissionsResult().
-                    val activity = activity ?: return
-
-                    pendingDownload = download
-
-                    ActivityCompat.requestPermissions(
-                        activity,
-                        arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
-                        REQUEST_CODE_STORAGE_PERMISSION
-                    )
-                }
-            }
-        })
-    }
-
-    /**
-     * Checks a download's destination directory to determine if it is being called from
-     * a long press on an image or otherwise.
-     */
-    private fun isDownloadFromLongPressImage(download: Download): Boolean {
-        return download.destinationDirectory == Environment.DIRECTORY_PICTURES
+        menuBinding.get()?.updateIcon(menuIcon)
     }
 
     /**
@@ -659,48 +563,22 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     }
 
     override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
-        if (requestCode != REQUEST_CODE_STORAGE_PERMISSION) {
-            return
-        }
-
-        if (grantResults.isEmpty() || grantResults[0] != PackageManager.PERMISSION_GRANTED) {
-            // We didn't get the storage permission: We are not able to start this download.
-            pendingDownload = null
+        val feature: PermissionsFeature? = when (requestCode) {
+            REQUEST_CODE_PROMPT_PERMISSIONS -> promptFeature.get()
+            REQUEST_CODE_DOWNLOAD_PERMISSIONS -> downloadsFeature.get()
+            else -> null
         }
 
-        // The actual download dialog will be shown from onResume(). If this activity/fragment is
-        // getting restored then we need to 'resume' first before we can show a dialog (attaching
-        // another fragment).
+        feature?.onPermissionsResult(permissions, grantResults)
     }
 
-    internal fun showDownloadPromptDialog(download: Download) {
-        val fragmentManager = childFragmentManager
-
-        if (fragmentManager.findFragmentByTag(DownloadDialogFragment.FRAGMENT_TAG) != null) {
-            // We are already displaying a download dialog fragment (Probably a restored fragment).
-            // No need to show another one.
-            return
-        }
-
-        val downloadDialogFragment = DownloadDialogFragment.newInstance(download)
-
-        try {
-            downloadDialogFragment.show(fragmentManager, DownloadDialogFragment.FRAGMENT_TAG)
-        } catch (e: IllegalStateException) {
-            // It can happen that at this point in time the activity is already in the background
-            // and onSaveInstanceState() has already been called. Fragment transactions are not
-            // allowed after that anymore. It's probably safe to guess that the user might not
-            // be interested in the download at this point. So we could just *not* show the dialog.
-            // Unfortunately we can't call commitAllowingStateLoss() because committing the
-            // transaction is happening inside the DialogFragment code. Therefore we just swallow
-            // the exception here. Gulp!
-        }
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        promptFeature.withFeature { it.onActivityResult(requestCode, data, resultCode) }
     }
 
     private fun showCrashReporter(crash: Crash) {
         val fragmentManager = requireActivity().supportFragmentManager
 
-        Log.e("crash:", crash.toString())
         if (crashReporterIsVisible()) {
             // We are already displaying the crash reporter
             // No need to show another one.
@@ -724,8 +602,8 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         crash_container.visibility = View.VISIBLE
         tabs.hide()
         erase.hide()
-        securityView?.setImageResource(R.drawable.ic_firefox)
-        menuView?.visibility = View.GONE
+        securityInfoBinding.get()?.updateIcon(R.drawable.ic_firefox)
+        menuBinding.get()?.hideMenuButton()
         urlView?.text = requireContext().getString(R.string.tab_crash_report_title)
     }
 
@@ -742,8 +620,8 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         crash_container.visibility = View.GONE
         tabs.show()
         erase.show()
-        securityView?.setImageResource(R.drawable.ic_internet)
-        menuView?.visibility = View.VISIBLE
+        securityInfoBinding.get()?.updateIcon(R.drawable.ic_internet)
+        menuBinding.get()?.showMenuButton()
         urlView?.text = session.let {
             val contentState = requireComponents.store.contentState(it.id)
             if (contentState?.isSearch == true) contentState.searchTerms else contentState?.url
@@ -754,6 +632,47 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         it.findFragmentByTag(CrashReporterFragment.FRAGMENT_TAG)?.isVisible ?: false
     }
 
+    private fun showDownloadSnackbar(
+        state: DownloadState,
+        status: DownloadState.Status
+    ) {
+        if (status != DownloadState.Status.COMPLETED) {
+            // We currently only show an in-app snackbar for completed downloads.
+            return
+        }
+
+        val snackbar = Snackbar.make(
+            requireView(),
+            String.format(requireContext().getString(R.string.download_snackbar_finished), state.fileName),
+            Snackbar.LENGTH_LONG
+        )
+
+        snackbar.setAction(getString(R.string.download_snackbar_open)) {
+            val opened = AbstractFetchDownloadService.openFile(
+                context = requireContext(),
+                contentType = state.contentType,
+                filePath = state.filePath
+            )
+
+            if (!opened) {
+                val extension = MimeTypeMap.getFileExtensionFromUrl(state.filePath)
+
+                Toast.makeText(
+                    context,
+                    getString(
+                        mozilla.components.feature.downloads.R.string.mozac_feature_downloads_open_not_supported1,
+                        extension
+                    ),
+                    Toast.LENGTH_LONG
+                ).show()
+            }
+        }
+
+        snackbar.setActionTextColor(ContextCompat.getColor(requireContext(), R.color.snackbarActionText))
+
+        snackbar.show()
+    }
+
     internal fun showAddToHomescreenDialog(url: String, title: String) {
         val fragmentManager = childFragmentManager
 
@@ -763,11 +682,14 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             return
         }
 
+        val tab = requireComponents.store.state.findTabOrCustomTab(session.id)
+        val requestDesktop = tab?.content?.desktopMode ?: false
+
         val addToHomescreenDialogFragment = AddToHomescreenDialogFragment.newInstance(
             url,
             title,
             session.trackerBlockingEnabled,
-            session.shouldRequestDesktopSite
+            requestDesktop = requestDesktop
         )
 
         try {
@@ -783,12 +705,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         }
     }
 
-    override fun onFinishDownloadDialog(download: Download?, shouldDownload: Boolean) {
-        if (shouldDownload) {
-            queueDownload(download)
-        }
-    }
-
     override fun biometricCreateNewSessionWithLink() {
         for (session in requireComponents.sessionManager.sessions) {
             if (session != requireComponents.sessionManager.selectedSession) {
@@ -801,21 +717,13 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     }
 
     override fun biometricCreateNewSession() {
-        requireComponents.sessionManager.removeAndCloseAllSessions()
+        requireComponents.sessionManager.removeSessions()
     }
 
     override fun onAuthSuccess() {
         view!!.alpha = 1f
     }
 
-    override fun onCreateViewCalled() {
-        manager = requireContext().getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
-        downloadBroadcastReceiver = DownloadBroadcastReceiver(browserContainer, manager)
-
-        val webView = getWebView()
-        webView?.setFindListener(findInPageCoordinator)
-    }
-
     override fun onResume() {
         super.onResume()
 
@@ -823,21 +731,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             job = Job()
         }
 
-        val filter = IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)
-        requireContext().registerReceiver(downloadBroadcastReceiver, filter)
-
-        if (pendingDownload != null && PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(
-                requireContext(),
-                Manifest.permission.WRITE_EXTERNAL_STORAGE
-            )
-        ) {
-            // There's a pending download (waiting for the storage permission) and now we have the
-            // missing permission: Show the dialog to ask whether the user wants to actually proceed
-            // with downloading this file.
-            showDownloadPromptDialog(pendingDownload!!)
-            pendingDownload = null
-        }
-
         StatusBarUtils.getStatusBarHeight(statusBar) { statusBarHeight ->
             statusBar!!.layoutParams.height = statusBarHeight
         }
@@ -888,64 +781,14 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         }
     }
 
-    /**
-     * Use Android's Download Manager to queue this download.
-     */
-    private fun queueDownload(download: Download?) {
-        if (download == null) {
-            return
-        }
-
-        val fileName = if (!TextUtils.isEmpty(download.fileName))
-            download.fileName
-        else
-            DownloadUtils.guessFileName(
-                download.contentDisposition,
-                null,
-                download.url,
-                download.mimeType
-            )
-
-        val request = DownloadManager.Request(Uri.parse(download.url))
-            .addRequestHeader("Referer", url)
-            .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
-            .setMimeType(download.mimeType)
-
-        if (!AppConstants.isGeckoBuild) {
-            val cookie = CookieManager.getInstance().getCookie(download.url)
-            request.addRequestHeader("Cookie", cookie)
-                .addRequestHeader("User-Agent", download.userAgent)
-        }
-
-        try {
-            request.setDestinationInExternalPublicDir(download.destinationDirectory, fileName)
-        } catch (e: IllegalStateException) {
-            Log.e(FRAGMENT_TAG, "Cannot create download directory")
-            return
-        }
-
-        @Suppress("DEPRECATION")
-        request.allowScanningByMediaScanner()
-
-        @Suppress("TooGenericExceptionCaught")
-        try {
-            val downloadReference = manager!!.enqueue(request)
-            downloadBroadcastReceiver!!.addQueuedDownload(downloadReference)
-        } catch (e: RuntimeException) {
-            Log.e(FRAGMENT_TAG, "Download failed: $e")
-        }
-    }
-
-    @Suppress("ComplexMethod")
+    @Suppress("ComplexMethod", "ReturnCount")
     fun onBackPressed(): Boolean {
-        if (findInPageView!!.visibility == View.VISIBLE) {
-            hideFindInPage()
-        } else if (isFullscreen) {
-            val webView = getWebView()
-            webView?.exitFullscreen()
-        } else if (canGoBack()) {
-            // Go back in web history
-            goBack()
+        if (findInPageIntegration.onBackPressed()) {
+            return true
+        } else if (fullScreenFeature.onBackPressed()) {
+            return true
+        } else if (sessionFeature.get()?.onBackPressed() == true) {
+            return true
         } else {
             if (session.source == SessionState.Source.ACTION_VIEW || session.isCustomTabSession()) {
                 TelemetryWrapper.eraseBackToAppEvent()
@@ -975,7 +818,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     }
 
     fun erase() {
-        val webView = getWebView()
         val context = context
 
         // Notify the user their session has been erased if Talk Back is enabled:
@@ -990,26 +832,21 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             }
         }
 
-        webView?.cleanup()
+        requireComponents.sessionManager.remove(session)
 
-        requireComponents.sessionManager.removeAndCloseSession(session)
+        // Temporary workaround until we get https://bugzilla.mozilla.org/show_bug.cgi?id=1644156
+        // See comment in TabUtils.createTab().
+        requireComponents.engine.clearData(Engine.BrowsingData.all())
     }
 
     private fun shareCurrentUrl() {
-        val url = url
-
         val shareIntent = Intent(Intent.ACTION_SEND)
         shareIntent.type = "text/plain"
-        shareIntent.putExtra(Intent.EXTRA_TEXT, url)
-
-        // Use title from webView if it's content matches the url
-        val webView = getWebView()
-        if (webView != null) {
-            val contentUrl = webView.url
-            if (contentUrl != null && contentUrl == url) {
-                val contentTitle = webView.title
-                shareIntent.putExtra(Intent.EXTRA_SUBJECT, contentTitle)
-            }
+        shareIntent.putExtra(Intent.EXTRA_TEXT, session.url)
+
+        val title = session.title
+        if (title.isNotEmpty()) {
+            shareIntent.putExtra(Intent.EXTRA_SUBJECT, title)
         }
 
         startActivity(Intent.createChooser(shareIntent, getString(R.string.share_dialog_title)))
@@ -1020,13 +857,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     @Suppress("ComplexMethod")
     override fun onClick(view: View) {
         when (view.id) {
-            R.id.menuView -> {
-                val menu = BrowserMenu(activity, this, session.customTabConfig)
-                menu.show(menuView)
-
-                menuWeakReference = WeakReference(menu)
-            }
-
             R.id.display_url -> if (
                     !crashReporterIsVisible() &&
                     requireComponents.sessionManager.findSessionById(session.id) != null) {
@@ -1055,34 +885,31 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             }
 
             R.id.back -> {
-                goBack()
+                requireComponents.sessionUseCases.goBack(session)
             }
 
             R.id.forward -> {
-                val webView = getWebView()
-                webView?.goForward()
+                requireComponents.sessionUseCases.goForward(session)
             }
 
             R.id.refresh -> {
-                reload()
+                requireComponents.sessionUseCases.reload(session)
 
                 TelemetryWrapper.menuReloadEvent()
             }
 
             R.id.stop -> {
-                val webView = getWebView()
-                webView?.stopLoading()
+                requireComponents.sessionUseCases.stopLoading(session)
             }
 
             R.id.open_in_firefox_focus -> {
-                session.customTabConfig = null
+                // Release the session from this view so that it can immediately be rendered by a different view
+                engineView!!.release()
 
+                // Strip the CustomTabConfig to turn this Session into a regular tab and then select it
+                session.customTabConfig = null
                 requireComponents.sessionManager.select(session)
 
-                val webView = getWebView()
-                webView?.releaseGeckoSession()
-                webView?.saveWebViewState(session)
-
                 val intent = Intent(context, MainActivity::class.java)
                 intent.action = Intent.ACTION_MAIN
                 intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
@@ -1147,130 +974,43 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             }
 
             R.id.help -> {
-                val session = Session(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
+                val session = createTab(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
                 requireComponents.sessionManager.add(session, selected = true)
             }
 
             R.id.help_trackers -> {
                 val url = SupportUtils.getSumoURLForTopic(context!!, SupportUtils.SumoTopic.TRACKERS)
-                val session = Session(url, source = SessionState.Source.MENU)
+                val session = createTab(url, source = SessionState.Source.MENU)
 
                 requireComponents.sessionManager.add(session, selected = true)
             }
 
             R.id.add_to_homescreen -> {
-                val webView = getWebView() ?: return
-
-                val url = webView.url
-                val title = webView.title
-                showAddToHomescreenDialog(url, title)
+                showAddToHomescreenDialog(
+                    session.url, session.title
+                )
             }
 
-            R.id.security_info -> if (!crashReporterIsVisible()) { showSecurityPopUp() }
-
             R.id.report_site_issue -> {
                 val reportUrl = String.format(SupportUtils.REPORT_SITE_ISSUE_URL, url)
-                val session = Session(reportUrl, source = SessionState.Source.MENU)
+                val session = createTab(reportUrl, source = SessionState.Source.MENU)
                 requireComponents.sessionManager.add(session, selected = true)
 
                 TelemetryWrapper.reportSiteIssueEvent()
             }
 
             R.id.find_in_page -> {
-                showFindInPage()
-                ViewUtils.showKeyboard(findInPageQuery)
+                val sessionState = requireComponents.store.state.findTab(session.id)
+                if (sessionState != null) {
+                    findInPageIntegration.get()?.show(sessionState)
+                }
                 TelemetryWrapper.findInPageMenuEvent()
             }
 
-            R.id.queryText -> findInPageQuery!!.isCursorVisible = true
-
-            R.id.nextResult -> {
-                ViewUtils.hideKeyboard(findInPageQuery!!)
-                findInPageQuery!!.isCursorVisible = false
-
-                getWebView()?.findNext(true)
-            }
-
-            R.id.previousResult -> {
-                ViewUtils.hideKeyboard(findInPageQuery!!)
-                findInPageQuery!!.isCursorVisible = false
-
-                getWebView()?.findNext(false)
-            }
-
-            R.id.close_find_in_page -> {
-                hideFindInPage()
-            }
-
             else -> throw IllegalArgumentException("Unhandled menu item in BrowserFragment")
         }
     }
 
-    @Suppress("MagicNumber")
-    private fun updateToolbarButtonStates(isLoading: Boolean) {
-        @Suppress("ComplexCondition")
-        if (forwardButton == null || backButton == null || refreshButton == null || stopButton == null) {
-            return
-        }
-
-        val webView = getWebView() ?: return
-
-        val canGoForward = webView.canGoForward()
-        val canGoBack = webView.canGoBack()
-
-        forwardButton!!.isEnabled = canGoForward
-        forwardButton!!.alpha = if (canGoForward) 1.0f else 0.5f
-        backButton!!.isEnabled = canGoBack
-        backButton!!.alpha = if (canGoBack) 1.0f else 0.5f
-
-        refreshButton!!.visibility = if (isLoading) View.GONE else View.VISIBLE
-        stopButton!!.visibility = if (isLoading) View.VISIBLE else View.GONE
-    }
-
-    fun canGoForward(): Boolean = getWebView()?.canGoForward() ?: false
-
-    fun canGoBack(): Boolean = getWebView()?.canGoBack() ?: false
-
-    fun goBack() = getWebView()?.goBack()
-
-    fun loadUrl(url: String) {
-        val webView = getWebView()
-        if (webView != null && !TextUtils.isEmpty(url)) {
-            webView.loadUrl(url)
-        }
-    }
-
-    fun reload() = getWebView()?.reload()
-
-    fun setBlockingUI(enabled: Boolean) {
-        val webView = getWebView()
-        webView?.setBlockingEnabled(enabled)
-
-        statusBar!!.setBackgroundResource(if (enabled)
-                R.drawable.animated_background
-            else
-                R.drawable.animated_background_disabled
-        )
-
-        backgroundTransitionGroup = if (!session.isCustomTabSession()) {
-            // Only update the toolbar background if this is not a custom tab. Custom tabs set their
-            // own color and we do not want to override this here.
-            urlBar!!.setBackgroundResource(if (enabled)
-                    R.drawable.animated_background
-                else
-                    R.drawable.animated_background_disabled)
-
-            TransitionDrawableGroup(
-                urlBar!!.background as TransitionDrawable,
-                statusBar!!.background as TransitionDrawable
-            )
-        } else {
-            TransitionDrawableGroup(
-                statusBar!!.background as TransitionDrawable
-            )
-        }
-    }
-
     fun setShouldRequestDesktop(enabled: Boolean) {
         if (enabled) {
             PreferenceManager.getDefaultSharedPreferences(context).edit()
@@ -1280,10 +1020,14 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
                 ).apply()
         }
 
-        getWebView()?.setRequestDesktop(enabled)
+        requireComponents.sessionUseCases.requestDesktopSite(enabled, session)
     }
 
-    private fun showSecurityPopUp() {
+    fun showSecurityPopUp() {
+        if (crashReporterIsVisible()) {
+            return
+        }
+
         // Don't show Security Popup if the page is loading
         if (session.loading) {
             return
@@ -1302,11 +1046,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         }
     }
 
-    // In the future, if more badging icons are needed, this should be abstracted
-    fun updateBlockingBadging(enabled: Boolean) {
-        blockView!!.visibility = if (enabled) View.GONE else View.VISIBLE
-    }
-
     override fun onLongClick(view: View): Boolean {
         // Detect long clicks on display_url
         if (view.id == R.id.display_url) {
@@ -1323,30 +1062,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
         return false
     }
 
-    private fun showFindInPage() {
-        findInPageView!!.visibility = View.VISIBLE
-        findInPageQuery!!.requestFocus()
-
-        val params = swipeRefresh!!.layoutParams as CoordinatorLayout.LayoutParams
-        params.bottomMargin = findInPageViewHeight
-        swipeRefresh!!.layoutParams = params
-    }
-
-    private fun hideFindInPage() {
-        val webView = getWebView() ?: return
-
-        webView.clearMatches()
-        findInPageCoordinator.reset()
-        findInPageView!!.visibility = View.GONE
-        findInPageQuery!!.text = ""
-        findInPageQuery!!.clearFocus()
-
-        val params = swipeRefresh!!.layoutParams as CoordinatorLayout.LayoutParams
-        params.bottomMargin = 0
-        swipeRefresh!!.layoutParams = params
-        ViewUtils.hideKeyboard(findInPageQuery!!)
-    }
-
     override fun applyLocale() {
         activity?.supportFragmentManager
             ?.beginTransaction()
@@ -1358,133 +1073,6 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
             ?.commit()
     }
 
-    private fun updateSecurityIcon(session: Session, securityInfo: Session.SecurityInfo = session.securityInfo) {
-        if (crashReporterIsVisible()) return
-        val securityView = securityView ?: return
-
-        if (!session.loading) {
-            if (securityInfo.secure) {
-                securityView.setImageResource(R.drawable.ic_lock)
-            } else {
-                if (URLUtil.isHttpUrl(url)) {
-                    // HTTP site
-                    securityView.setImageResource(R.drawable.ic_internet)
-                } else {
-                    // Certificate is bad
-                    securityView.setImageResource(R.drawable.ic_warning)
-                }
-            }
-        } else {
-            securityView.setImageResource(R.drawable.ic_internet)
-        }
-    }
-
-    @Suppress("DEPRECATION", "MagicNumber")
-    private fun updateFindInPageResult(activeMatchOrdinal: Int, numberOfMatches: Int) {
-        var actualActiveMatchOrdinal = activeMatchOrdinal
-        val context = context ?: return
-
-        if (numberOfMatches > 0) {
-            findInPageNext!!.setColorFilter(resources.getColor(R.color.photonWhite))
-            findInPageNext!!.alpha = 1.0f
-            findInPagePrevious!!.setColorFilter(resources.getColor(R.color.photonWhite))
-            findInPagePrevious!!.alpha = 1.0f
-            // We don't want the presentation of the activeMatchOrdinal to be zero indexed. So let's
-            // increment it by one for WebView.
-            if (!AppConstants.isGeckoBuild) {
-                actualActiveMatchOrdinal++
-            }
-
-            val visibleString = String.format(
-                context.getString(R.string.find_in_page_result),
-                actualActiveMatchOrdinal,
-                numberOfMatches)
-
-            val accessibleString = String.format(
-                context.getString(R.string.find_in_page_result),
-                actualActiveMatchOrdinal,
-                numberOfMatches)
-
-            findInPageResultTextView!!.text = visibleString
-            findInPageResultTextView!!.contentDescription = accessibleString
-        } else {
-            findInPageNext!!.setColorFilter(resources.getColor(R.color.photonGrey10))
-            findInPageNext!!.alpha = 0.4f
-            findInPagePrevious!!.setColorFilter(resources.getColor(R.color.photonWhite))
-            findInPagePrevious!!.alpha = 0.4f
-            findInPageResultTextView!!.text = ""
-            findInPageResultTextView!!.contentDescription = ""
-        }
-    }
-
-    private val sessionObserver = object : Session.Observer {
-        override fun onLoadingStateChanged(session: Session, loading: Boolean) {
-            if (loading) {
-                backgroundTransitionGroup!!.resetTransition()
-
-                progressView!!.progress = INITIAL_PROGRESS
-                progressView!!.visibility = View.VISIBLE
-            } else {
-                if (progressView!!.visibility == View.VISIBLE) {
-                    // We start a transition only if a page was just loading before
-                    // allowing to avoid issue #1179
-                    backgroundTransitionGroup!!.startTransition(ANIMATION_DURATION)
-                    progressView!!.visibility = View.GONE
-                }
-                swipeRefresh!!.isRefreshing = false
-
-                updateSecurityIcon(session)
-            }
-
-            updateBlockingBadging(loading || session.trackerBlockingEnabled)
-
-            updateToolbarButtonStates(loading)
-
-            val menu = menuWeakReference!!.get()
-            menu?.updateLoading(loading)
-
-            if (findInPageView?.visibility == View.VISIBLE) {
-                hideFindInPage()
-            }
-        }
-
-        override fun onUrlChanged(session: Session, url: String) {
-            if (crashReporterIsVisible()) return
-
-            val host = try {
-                URL(url).host
-            } catch (_: MalformedURLException) {
-                url
-            }
-
-            val isException =
-                host != null && ExceptionDomains.load(requireContext()).contains(host)
-            getWebView()?.setBlockingEnabled(!isException)
-
-            urlView?.text = UrlUtils.stripUserInfo(url)
-        }
-
-        override fun onProgress(session: Session, progress: Int) {
-            progressView?.progress = progress
-        }
-
-        override fun onTrackerBlocked(session: Session, tracker: Tracker, all: List<Tracker>) {
-            menuWeakReference?.let {
-                val menu = it.get()
-
-                menu?.updateTrackers(all.size)
-            }
-        }
-
-        override fun onTrackerBlockingEnabledChanged(session: Session, blockingEnabled: Boolean) {
-            setBlockingUI(blockingEnabled)
-        }
-
-        override fun onSecurityChanged(session: Session, securityInfo: Session.SecurityInfo) {
-            updateSecurityIcon(session, securityInfo)
-        }
-    }
-
     fun handleTabCrash(crash: Crash) {
         showCrashReporter(crash)
     }
@@ -1492,13 +1080,7 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
     companion object {
         const val FRAGMENT_TAG = "browser"
 
-        private const val REQUEST_CODE_STORAGE_PERMISSION = 101
-        private const val ANIMATION_DURATION = 300
-
         private const val ARGUMENT_SESSION_UUID = "sessionUUID"
-        private const val RESTORE_KEY_DOWNLOAD = "download"
-
-        private const val INITIAL_PROGRESS = 5
 
         @JvmStatic
         fun createForSession(session: Session): BrowserFragment {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/DownloadDialogFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/DownloadDialogFragment.kt
deleted file mode 100644
index b6fb2e4b71ab..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/DownloadDialogFragment.kt
+++ /dev/null
@@ -1,114 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.fragment
-
-import android.os.Build
-import android.os.Bundle
-import androidx.fragment.app.DialogFragment
-import androidx.appcompat.app.AlertDialog
-import android.text.Html
-import android.text.Spanned
-import android.widget.Button
-import kotlinx.android.synthetic.main.download_dialog.view.*
-import mozilla.components.support.utils.DownloadUtils
-import org.mozilla.focus.R
-import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.web.Download
-
-/**
- * Fragment displaying a download dialog
- */
-class DownloadDialogFragment : DialogFragment() {
-
-    override fun onCreateDialog(bundle: Bundle?): AlertDialog {
-        val fileName = arguments!!.getString("fileName")
-        val pendingDownload = arguments!!.getParcelable<Download>("download")
-
-        val builder = AlertDialog.Builder(requireContext(), R.style.DialogStyle)
-        builder.setCancelable(true)
-        builder.setTitle(getString(R.string.download_dialog_title))
-
-        val inflater = activity!!.layoutInflater
-        val dialogView = inflater.inflate(R.layout.download_dialog, null)
-        builder.setView(dialogView)
-
-        dialogView.download_dialog_icon.setImageResource(R.drawable.ic_download)
-        dialogView.download_dialog_file_name.text = fileName
-        dialogView.download_dialog_cancel.text = getString(R.string.download_dialog_action_cancel)
-        dialogView.download_dialog_download.text =
-                getString(R.string.download_dialog_action_download)
-        dialogView.download_dialog_warning.text =
-                getSpannedTextFromHtml(R.string.download_dialog_warning, R.string.app_name)
-
-        setButtonOnClickListener(dialogView.download_dialog_cancel, pendingDownload, false)
-        setButtonOnClickListener(dialogView.download_dialog_download, pendingDownload, true)
-
-        return builder.create()
-    }
-
-    private fun setButtonOnClickListener(
-        button: Button,
-        pendingDownload: Download?,
-        shouldDownload: Boolean
-    ) {
-        button.setOnClickListener {
-            sendDownloadDialogButtonClicked(pendingDownload, shouldDownload)
-            TelemetryWrapper.downloadDialogDownloadEvent(shouldDownload)
-            dismiss()
-        }
-    }
-
-    private fun sendDownloadDialogButtonClicked(download: Download?, shouldDownload: Boolean) {
-        val listener = parentFragment as DownloadDialogListener?
-        listener?.onFinishDownloadDialog(download, shouldDownload)
-        dismiss()
-    }
-
-    @Suppress("DEPRECATION")
-    private fun getSpannedTextFromHtml(text: Int, replaceString: Int): Spanned {
-        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-            Html.fromHtml(
-                String
-                    .format(
-                        getText(text)
-                            .toString(), getString(replaceString)
-                    ), Html.FROM_HTML_MODE_LEGACY
-            )
-        } else {
-            Html.fromHtml(
-                String
-                    .format(
-                        getText(text)
-                            .toString(), getString(replaceString)
-                    )
-            )
-        }
-    }
-
-    interface DownloadDialogListener {
-        fun onFinishDownloadDialog(download: Download?, shouldDownload: Boolean)
-    }
-
-    companion object {
-        val FRAGMENT_TAG = "should-download-prompt-dialog"
-
-        fun newInstance(download: Download): DownloadDialogFragment {
-            val frag = DownloadDialogFragment()
-            val args = Bundle()
-
-            val fileName = download.fileName ?: DownloadUtils.guessFileName(
-                download.contentDisposition,
-                null,
-                download.url,
-                download.mimeType
-            )
-
-            args.putString("fileName", fileName)
-            args.putParcelable("download", download)
-            frag.arguments = args
-            return frag
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/InfoFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/InfoFragment.kt
deleted file mode 100644
index 98551cfe7f8c..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/InfoFragment.kt
+++ /dev/null
@@ -1,117 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.fragment
-
-import android.os.Bundle
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import android.widget.ProgressBar
-import mozilla.components.browser.session.Session
-
-import org.mozilla.focus.R
-import org.mozilla.focus.web.Download
-import org.mozilla.focus.web.IWebView
-
-class InfoFragment : WebFragment() {
-    private var progressView: ProgressBar? = null
-    private var webView: View? = null
-
-    override val session: Session?
-        get() = null
-
-    override val initialUrl: String?
-        get() = arguments?.getString(ARGUMENT_URL)
-
-    override fun inflateLayout(
-        inflater: LayoutInflater,
-        container: ViewGroup?,
-        savedInstanceState: Bundle?
-    ): View {
-        val view = inflater.inflate(R.layout.fragment_info, container, false)
-        progressView = view.findViewById(R.id.progress)
-        webView = view.findViewById(R.id.webview)
-        val url = initialUrl
-        if (url != null && !(url.startsWith("http://") || url.startsWith("https://"))) {
-            // Hide webview until content has loaded, if we're loading built in about/rights/etc
-            // pages: this avoid a white flash (on slower devices) between the screen appearing,
-            // and the about/right/etc content appearing. We don't do this for SUMO and other
-            // external pages, because they are both light-coloured, and significantly slower loading.
-            webView?.visibility = View.INVISIBLE
-        }
-        applyLocale()
-        return view
-    }
-
-    override fun onCreateViewCalled() {}
-
-    @Suppress("ComplexMethod")
-    override fun createCallback(): IWebView.Callback {
-        return object : IWebView.Callback {
-            override fun onPageStarted(url: String) {
-                progressView?.announceForAccessibility(getString(R.string.accessibility_announcement_loading))
-                progressView?.visibility = View.VISIBLE
-            }
-
-            override fun onPageFinished(isSecure: Boolean) {
-                progressView?.announceForAccessibility(getString(R.string.accessibility_announcement_loading_finished))
-                progressView?.visibility = View.INVISIBLE
-                if (webView?.visibility != View.VISIBLE) {
-                    webView?.visibility = View.VISIBLE
-                }
-            }
-
-            override fun onSecurityChanged(
-                isSecure: Boolean,
-                host: String?,
-                organization: String?
-            ) {
-            }
-
-            override fun onProgress(progress: Int) {
-                progressView?.progress = progress
-            }
-
-            override fun onDownloadStart(download: Download) {}
-
-            override fun onLongPress(hitTarget: IWebView.HitTarget) {}
-
-            override fun onURLChanged(url: String) {}
-
-            override fun onTitleChanged(title: String) {}
-
-            override fun onRequest(isTriggeredByUserGesture: Boolean) {}
-
-            override fun onEnterFullScreen(callback: IWebView.FullscreenCallback, view: View?) {}
-
-            override fun onExitFullScreen() {}
-
-            override fun countBlockedTracker() {}
-
-            override fun resetBlockedTrackers() {}
-
-            override fun onBlockingStateChanged(isBlockingEnabled: Boolean) {}
-
-            override fun onHttpAuthRequest(
-                callback: IWebView.HttpAuthCallback,
-                host: String,
-                realm: String
-            ) {}
-
-            override fun onRequestDesktopStateChanged(shouldRequestDesktop: Boolean) {}
-        }
-    }
-
-    companion object {
-        private const val ARGUMENT_URL = "url"
-
-        fun create(url: String?): InfoFragment {
-            val arguments = Bundle()
-            arguments.putString(ARGUMENT_URL, url)
-            val fragment = InfoFragment()
-            fragment.arguments = arguments
-            return fragment
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
index 5dbd18ec347f..bbc143186b67 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
@@ -61,6 +61,7 @@ import org.mozilla.focus.utils.StatusBarUtils
 import org.mozilla.focus.utils.SupportUtils
 import org.mozilla.focus.utils.UrlUtils
 import org.mozilla.focus.utils.ViewUtils
+import org.mozilla.focus.utils.createTab
 import org.mozilla.focus.whatsnew.WhatsNew
 import java.util.Objects
 import kotlin.coroutines.CoroutineContext
@@ -321,15 +322,14 @@ class UrlInputFragment :
 
         urlView?.setOnCommitListener(::onCommit)
 
-        val geckoViewAndDDG: Boolean =
-            Settings.getInstance(requireContext()).defaultSearchEngineName == duckDuckGo &&
-                    AppConstants.isGeckoBuild
+        val isDDG: Boolean =
+            Settings.getInstance(requireContext()).defaultSearchEngineName == duckDuckGo
 
         session?.let {
             val contentState = requireComponents.store.contentState(it.id)
             urlView?.setText(
                 if (contentState?.isSearch == true &&
-                    !geckoViewAndDDG &&
+                    !isDDG &&
                     Features.SEARCH_TERMS_OR_URL
                 ) {
                     contentState.searchTerms
@@ -436,7 +436,7 @@ class UrlInputFragment :
                 WhatsNew.userViewedWhatsNew(it)
 
                 val url = SupportUtils.getSumoURLForTopic(it, SupportUtils.SumoTopic.WHATS_NEW)
-                val session = Session(url, source = SessionState.Source.MENU)
+                val session = createTab(url, source = SessionState.Source.MENU)
 
                 requireComponents.sessionManager.add(session, selected = true)
             }
@@ -444,7 +444,7 @@ class UrlInputFragment :
             R.id.settings -> (activity as LocaleAwareAppCompatActivity).openPreferences()
 
             R.id.help -> {
-                val session = Session(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
+                val session = createTab(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
                 requireComponents.sessionManager.add(session, selected = true)
             }
 
@@ -670,7 +670,7 @@ class UrlInputFragment :
             }
         }
 
-        if (!input.trim { it <= ' ' }.isEmpty()) {
+        if (input.trim { it <= ' ' }.isNotEmpty()) {
             handleCrashTrigger(input)
 
             ViewUtils.hideKeyboard(urlView)
@@ -753,23 +753,14 @@ class UrlInputFragment :
 
         val fragmentManager = requireActivity().supportFragmentManager
 
-        // Replace all fragments with a fresh browser fragment. This means we either remove the
-        // HomeFragment with an UrlInputFragment on top or an old BrowserFragment with an
-        // UrlInputFragment.
-        val browserFragment = fragmentManager.findFragmentByTag(BrowserFragment.FRAGMENT_TAG)
+        if (session != null) {
+            requireComponents.sessionUseCases.loadUrl(url, session?.id)
 
-        if (browserFragment != null && browserFragment is BrowserFragment && browserFragment.isVisible) {
-            // Reuse existing visible fragment - in this case we know the user is already browsing.
-            // The fragment might exist if we "erased" a browsing session, hence we need to check
-            // for visibility in addition to existence.
-            browserFragment.loadUrl(url)
-
-            // And this fragment can be removed again.
             fragmentManager.beginTransaction()
                 .remove(this)
                 .commit()
         } else {
-            val session = Session(url, source = SessionState.Source.USER_ENTERED)
+            val session = createTab(url, source = SessionState.Source.USER_ENTERED)
             if (!searchTerms.isNullOrEmpty()) {
                 requireComponents.store.dispatch(ContentAction.UpdateSearchTermsAction(session.id, searchTerms))
             }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt
deleted file mode 100644
index af75eeb410bd..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/WebFragment.kt
+++ /dev/null
@@ -1,163 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.fragment
-
-import android.os.Bundle
-import android.text.TextUtils
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import android.webkit.WebView
-import mozilla.components.browser.session.Session
-
-import org.mozilla.focus.R
-import org.mozilla.focus.ext.savedGeckoSession
-import org.mozilla.focus.ext.savedWebViewState
-import org.mozilla.focus.ext.shouldRequestDesktopSite
-import org.mozilla.focus.locale.LocaleAwareFragment
-import org.mozilla.focus.locale.LocaleManager
-import org.mozilla.focus.utils.AppConstants
-import org.mozilla.focus.web.IWebView
-
-import java.util.Locale
-
-/**
- * Base implementation for fragments that use an IWebView instance. Based on Android's WebViewFragment.
- */
-@Suppress("TooManyFunctions")
-abstract class WebFragment : LocaleAwareFragment() {
-    private var webViewInstance: IWebView? = null
-    private var isWebViewAvailable: Boolean = false
-
-    abstract val session: Session?
-
-    /**
-     * Get the initial URL to load after the view has been created.
-     */
-    abstract val initialUrl: String?
-
-    /**
-     * Inflate a layout for this fragment. The layout needs to contain a view implementing IWebView
-     * with the id set to "webview".
-     */
-    abstract fun inflateLayout(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View
-
-    abstract fun createCallback(): IWebView.Callback
-
-    /**
-     * Adds ability to add methods to onCreateView without override because onCreateView is final.
-     */
-    abstract fun onCreateViewCalled()
-
-    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
-        val view = inflateLayout(inflater, container, savedInstanceState)
-
-        val actualWebView = view.findViewById<View>(R.id.webview)
-        webViewInstance = actualWebView as IWebView
-
-        isWebViewAvailable = true
-        webViewInstance!!.setCallback(createCallback())
-
-        session?.let {
-            webViewInstance!!.setRequestDesktop(it.shouldRequestDesktopSite)
-        }
-
-        if (!AppConstants.isGeckoBuild) {
-            restoreStateOrLoadUrl()
-        } else {
-            loadInitialUrl()
-        }
-
-        onCreateViewCalled()
-        return view
-    }
-
-    override fun applyLocale() {
-        val context = context ?: return
-        val localeManager = LocaleManager.getInstance()
-        if (!localeManager.isMirroringSystemLocale(context)) {
-            val currentLocale = localeManager.getCurrentLocale(context)
-            Locale.setDefault(currentLocale)
-            val resources = context.resources
-            val config = resources.configuration
-            config.setLocale(currentLocale)
-
-            @Suppress("DEPRECATION")
-            context.resources.updateConfiguration(config, null)
-        }
-        // We create and destroy a new WebView here to force the internal state of WebView to know
-        // about the new language. See issue #666.
-        val unneeded = WebView(getContext())
-        unneeded.destroy()
-    }
-
-    override fun onPause() {
-        val session = session
-        if (session != null) {
-            webViewInstance!!.saveWebViewState(session)
-        }
-
-        webViewInstance!!.onPause()
-
-        super.onPause()
-    }
-
-    override fun onResume() {
-        webViewInstance!!.onResume()
-
-        if (AppConstants.isGeckoBuild) {
-            restoreStateOrLoadUrl()
-        }
-
-        super.onResume()
-    }
-
-    override fun onDestroy() {
-        if (webViewInstance != null) {
-            webViewInstance!!.setCallback(null)
-            webViewInstance!!.destroy()
-            webViewInstance = null
-        }
-
-        super.onDestroy()
-    }
-
-    override fun onDestroyView() {
-        isWebViewAvailable = false
-
-        super.onDestroyView()
-    }
-
-    protected fun getWebView(): IWebView? {
-        return if (isWebViewAvailable) webViewInstance else null
-    }
-
-    private fun loadInitialUrl() {
-        val session = session
-        if (session == null ||
-            session.savedWebViewState == null ||
-            session.savedGeckoSession == null) {
-            val url = initialUrl
-            if (!TextUtils.isEmpty(url)) {
-                webViewInstance!!.loadUrl(url)
-            }
-        }
-    }
-
-    private fun restoreStateOrLoadUrl() {
-        val session = session
-        if (session == null ||
-            session.savedWebViewState == null ||
-            session.savedGeckoSession == null) {
-            val url = initialUrl
-            if (!TextUtils.isEmpty(url)) {
-                webViewInstance!!.loadUrl(url)
-            }
-        } else {
-            webViewInstance!!.restoreWebViewState(session)
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/gecko/GeckoViewPrompt.java b/focus-android/app/src/main/java/org/mozilla/focus/gecko/GeckoViewPrompt.java
deleted file mode 100644
index 43ac84eb6520..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/gecko/GeckoViewPrompt.java
+++ /dev/null
@@ -1,681 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.gecko;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.res.TypedArray;
-import android.graphics.Color;
-import android.graphics.PorterDuff;
-import android.os.Build;
-import android.text.InputType;
-import android.text.format.DateFormat;
-import android.util.Log;
-import android.view.InflateException;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.CheckedTextView;
-import android.widget.DatePicker;
-import android.widget.EditText;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.ListView;
-import android.widget.ScrollView;
-import android.widget.TextView;
-import android.widget.TimePicker;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.Locale;
-
-import org.jetbrains.annotations.NotNull;
-import org.mozilla.focus.R;
-import org.mozilla.geckoview.AllowOrDeny;
-import org.mozilla.geckoview.GeckoResult;
-import org.mozilla.geckoview.GeckoSession;
-
-/**
- * Based on BasicGeckoViewPrompt from GeckoView Example, the prompt delegate
- * implementation for basic "input" types.
- * <p>
- * Implementation notes: We disable file prompt support since Focus never seemed to have it,
- * and there is larger work required to get it working here.
- */
-final public class GeckoViewPrompt implements GeckoSession.PromptDelegate {
-    private static final String LOGTAG = "BasicGeckoViewPrompt";
-
-    private final Activity mActivity;
-
-    public GeckoViewPrompt(final Activity activity) {
-        mActivity = activity;
-    }
-
-    @Override
-    public GeckoResult<PromptResponse> onAlertPrompt(@NotNull final GeckoSession session,
-                                                     @NotNull final AlertPrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity)
-                .setTitle(prompt.title)
-                .setMessage(prompt.message)
-                .setPositiveButton(android.R.string.ok, /* onClickListener */ null);
-        GeckoResult<PromptResponse> res = new GeckoResult<PromptResponse>();
-        createStandardDialog(builder, prompt, res).show();
-        return res;
-    }
-
-    @Override
-    public GeckoResult<PromptResponse> onButtonPrompt(@NotNull final GeckoSession session,
-                                                      @NotNull final ButtonPrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity)
-                .setTitle(prompt.title)
-                .setMessage(prompt.message);
-
-        GeckoResult<PromptResponse> res = new GeckoResult<PromptResponse>();
-
-        final DialogInterface.OnClickListener listener = (dialog, which) -> {
-            if (which == DialogInterface.BUTTON_POSITIVE) {
-                res.complete(prompt.confirm(ButtonPrompt.Type.POSITIVE));
-            } else if (which == DialogInterface.BUTTON_NEGATIVE) {
-                res.complete(prompt.confirm(ButtonPrompt.Type.NEGATIVE));
-            } else {
-                res.complete(prompt.dismiss());
-            }
-        };
-
-        builder.setPositiveButton(android.R.string.ok, listener);
-        builder.setNegativeButton(android.R.string.cancel, listener);
-
-        createStandardDialog(builder, prompt, res).show();
-        return res;
-    }
-
-    private int getViewPadding(final AlertDialog.Builder builder) {
-        final TypedArray attr = builder.getContext().obtainStyledAttributes(
-                new int[]{android.R.attr.listPreferredItemPaddingLeft});
-        final int padding = attr.getDimensionPixelSize(0, 1);
-        attr.recycle();
-        return padding;
-    }
-
-    private LinearLayout addStandardLayout(final AlertDialog.Builder builder,
-                                           final String title, final String msg) {
-        final ScrollView scrollView = new ScrollView(builder.getContext());
-        final LinearLayout container = new LinearLayout(builder.getContext());
-        final int horizontalPadding = getViewPadding(builder);
-        final int verticalPadding = (msg == null || msg.isEmpty()) ? horizontalPadding : 0;
-        container.setOrientation(LinearLayout.VERTICAL);
-        container.setPadding(/* left */ horizontalPadding, /* top */ verticalPadding,
-                /* right */ horizontalPadding, /* bottom */ verticalPadding);
-        scrollView.addView(container);
-        builder.setTitle(title)
-                .setMessage(msg)
-                .setView(scrollView);
-        return container;
-    }
-
-    private AlertDialog createStandardDialog(final AlertDialog.Builder builder,
-                                             final BasePrompt prompt,
-                                             final GeckoResult<PromptResponse> response) {
-        final AlertDialog dialog = builder.create();
-        dialog.setOnDismissListener(dialog1 -> {
-            if (!prompt.isComplete()) {
-                response.complete(prompt.dismiss());
-            }
-        });
-        return dialog;
-    }
-
-    @NotNull
-    @Override
-    public GeckoResult<PromptResponse> onTextPrompt(@NotNull final GeckoSession session,
-                                                    @NotNull final TextPrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        final LinearLayout container = addStandardLayout(builder, prompt.title, prompt.message);
-        final EditText editText = new EditText(builder.getContext());
-        editText.setText(prompt.defaultValue);
-        container.addView(editText);
-
-        GeckoResult<PromptResponse> res = new GeckoResult<>();
-
-        builder.setNegativeButton(android.R.string.cancel, /* listener */ null)
-                .setPositiveButton(android.R.string.ok, (dialog, which) ->
-                        res.complete(prompt.confirm(editText.getText().toString()))
-                );
-
-        createStandardDialog(builder, prompt, res).show();
-        return res;
-    }
-
-    @NotNull
-    @Override
-    public GeckoResult<PromptResponse> onAuthPrompt(@NotNull final GeckoSession session,
-                                                    @NotNull final AuthPrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        final LinearLayout container = addStandardLayout(builder, prompt.title, prompt.message);
-
-        final int flags = prompt.authOptions.flags;
-        final int level = prompt.authOptions.level;
-        final EditText username;
-        if ((flags & AuthPrompt.AuthOptions.Flags.ONLY_PASSWORD) == 0) {
-            username = new EditText(builder.getContext());
-            username.setHint(R.string.gv_prompt_username_hint);
-            username.setText(prompt.authOptions.username);
-            container.addView(username);
-        } else {
-            username = null;
-        }
-
-        final EditText password = new EditText(builder.getContext());
-        password.setHint(R.string.gv_prompt_password_hint);
-        password.setText(prompt.authOptions.password);
-        password.setInputType(InputType.TYPE_CLASS_TEXT |
-                InputType.TYPE_TEXT_VARIATION_PASSWORD);
-        container.addView(password);
-
-        if (level != AuthPrompt.AuthOptions.Level.NONE) {
-            final ImageView secure = new ImageView(builder.getContext());
-            secure.setImageResource(android.R.drawable.ic_lock_lock);
-            container.addView(secure);
-        }
-
-        GeckoResult<PromptResponse> res = new GeckoResult<>();
-
-        builder.setNegativeButton(android.R.string.cancel, /* listener */ null)
-                .setPositiveButton(android.R.string.ok, (dialog, which) -> {
-                    if ((flags & AuthPrompt.AuthOptions.Flags.ONLY_PASSWORD) == 0) {
-                        res.complete(prompt.confirm(username.getText().toString(),
-                                password.getText().toString()));
-                    } else {
-                        res.complete(prompt.confirm(password.getText().toString()));
-                    }
-                });
-        createStandardDialog(builder, prompt, res).show();
-
-        return res;
-    }
-
-    private static class ModifiableChoice {
-        boolean modifiableSelected;
-        String modifiableLabel;
-        final ChoicePrompt.Choice choice;
-
-        ModifiableChoice(ChoicePrompt.Choice c) {
-            choice = c;
-            modifiableSelected = choice.selected;
-            modifiableLabel = choice.label;
-        }
-    }
-
-    private void addChoiceItems(final int type, final ArrayAdapter<ModifiableChoice> list,
-                                final ChoicePrompt.Choice[] items, final String indent) {
-        if (type == ChoicePrompt.Type.MENU) {
-            for (final ChoicePrompt.Choice item : items) {
-                list.add(new ModifiableChoice(item));
-            }
-            return;
-        }
-
-        for (final ChoicePrompt.Choice item : items) {
-            final ModifiableChoice modItem = new ModifiableChoice(item);
-
-            final ChoicePrompt.Choice[] children = item.items;
-
-            if (indent != null && children == null) {
-                modItem.modifiableLabel = indent + modItem.modifiableLabel;
-            }
-            list.add(modItem);
-
-            if (children != null) {
-                final String newIndent;
-                if (type == ChoicePrompt.Type.SINGLE || type == ChoicePrompt.Type.MULTIPLE) {
-                    newIndent = (indent != null) ? indent + '\t' : "\t";
-                } else {
-                    newIndent = null;
-                }
-                addChoiceItems(type, list, children, newIndent);
-            }
-        }
-    }
-
-    private void onChoicePromptImpl(final GeckoSession session, final String title,
-                                    final String message, final int type,
-                                    final ChoicePrompt.Choice[] choices, final ChoicePrompt prompt,
-                                    final GeckoResult<PromptResponse> res) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            res.complete(prompt.dismiss());
-            return;
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        addStandardLayout(builder, title, message);
-
-        final ListView list = new ListView(builder.getContext());
-        if (type == ChoicePrompt.Type.MULTIPLE) {
-            list.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
-        }
-
-        final ArrayAdapter<ModifiableChoice> adapter = new ArrayAdapter<ModifiableChoice>(
-                builder.getContext(), android.R.layout.simple_list_item_1) {
-            private static final int TYPE_MENU_ITEM = 0;
-            private static final int TYPE_MENU_CHECK = 1;
-            private static final int TYPE_SEPARATOR = 2;
-            private static final int TYPE_GROUP = 3;
-            private static final int TYPE_SINGLE = 4;
-            private static final int TYPE_MULTIPLE = 5;
-            private static final int TYPE_COUNT = 6;
-
-            private LayoutInflater mInflater;
-            private View mSeparator;
-
-            @Override
-            public int getViewTypeCount() {
-                return TYPE_COUNT;
-            }
-
-            @Override
-            public int getItemViewType(final int position) {
-                final ModifiableChoice item = getItem(position);
-                if (item.choice.separator) {
-                    return TYPE_SEPARATOR;
-                } else if (type == ChoicePrompt.Type.MENU) {
-                    return item.modifiableSelected ? TYPE_MENU_CHECK : TYPE_MENU_ITEM;
-                } else if (item.choice.items != null) {
-                    return TYPE_GROUP;
-                } else if (type == ChoicePrompt.Type.SINGLE) {
-                    return TYPE_SINGLE;
-                } else if (type == ChoicePrompt.Type.MULTIPLE) {
-                    return TYPE_MULTIPLE;
-                } else {
-                    throw new UnsupportedOperationException();
-                }
-            }
-
-            @Override
-            public boolean isEnabled(final int position) {
-                final ModifiableChoice item = getItem(position);
-                return !item.choice.separator && !item.choice.disabled &&
-                        ((type != ChoicePrompt.Type.SINGLE &&
-                                type != ChoicePrompt.Type.MULTIPLE) ||
-                                item.choice.items == null);
-            }
-
-            @NotNull
-            @Override
-            public View getView(final int position, View view,
-                                @NotNull final ViewGroup parent) {
-                final int itemType = getItemViewType(position);
-                final int layoutId;
-                if (itemType == TYPE_SEPARATOR) {
-                    if (mSeparator == null) {
-                        mSeparator = new View(getContext());
-                        mSeparator.setLayoutParams(new ListView.LayoutParams(
-                                ViewGroup.LayoutParams.MATCH_PARENT, 2, itemType));
-                        final TypedArray attr = getContext().obtainStyledAttributes(
-                                new int[]{android.R.attr.listDivider});
-                        mSeparator.setBackgroundResource(attr.getResourceId(0, 0));
-                        attr.recycle();
-                    }
-                    return mSeparator;
-                } else if (itemType == TYPE_MENU_ITEM) {
-                    layoutId = android.R.layout.simple_list_item_1;
-                } else if (itemType == TYPE_MENU_CHECK) {
-                    layoutId = android.R.layout.simple_list_item_checked;
-                } else if (itemType == TYPE_GROUP) {
-                    layoutId = android.R.layout.preference_category;
-                } else if (itemType == TYPE_SINGLE) {
-                    layoutId = android.R.layout.simple_list_item_single_choice;
-                } else if (itemType == TYPE_MULTIPLE) {
-                    layoutId = android.R.layout.simple_list_item_multiple_choice;
-                } else {
-                    throw new UnsupportedOperationException();
-                }
-
-                if (view == null) {
-                    if (mInflater == null) {
-                        mInflater = LayoutInflater.from(builder.getContext());
-                    }
-                    view = mInflater.inflate(layoutId, parent, false);
-                }
-
-                final ModifiableChoice item = getItem(position);
-                final TextView text = (TextView) view;
-                text.setEnabled(!item.choice.disabled);
-                text.setText(item.modifiableLabel);
-                if (view instanceof CheckedTextView) {
-                    final boolean selected = item.modifiableSelected;
-                    if (itemType == TYPE_MULTIPLE) {
-                        list.setItemChecked(position, selected);
-                    } else {
-                        ((CheckedTextView) view).setChecked(selected);
-                    }
-                }
-                return view;
-            }
-        };
-        addChoiceItems(type, adapter, choices, /* indent */ null);
-
-        list.setAdapter(adapter);
-        builder.setView(list);
-
-        final AlertDialog dialog;
-        if (type == ChoicePrompt.Type.SINGLE || type == ChoicePrompt.Type.MENU) {
-            dialog = createStandardDialog(builder, prompt, res);
-            list.setOnItemClickListener((parent, v, position, id) -> {
-                final ModifiableChoice item = adapter.getItem(position);
-                if (type == ChoicePrompt.Type.MENU) {
-                    final ChoicePrompt.Choice[] children = item.choice.items;
-                    if (children != null) {
-                        // Show sub-menu.
-                        dialog.setOnDismissListener(null);
-                        dialog.dismiss();
-                        onChoicePromptImpl(session, item.modifiableLabel, /* msg */ null,
-                                type, children, prompt, res);
-                        return;
-                    }
-                }
-                res.complete(prompt.confirm(item.choice));
-                dialog.dismiss();
-            });
-        } else if (type == ChoicePrompt.Type.MULTIPLE) {
-            list.setOnItemClickListener((parent, v, position, id) -> {
-                final ModifiableChoice item = adapter.getItem(position);
-                item.modifiableSelected = ((CheckedTextView) v).isChecked();
-            });
-            builder.setNegativeButton(android.R.string.cancel, /* listener */ null)
-                    .setPositiveButton(android.R.string.ok, (dialog1, which) -> {
-                        final int len = adapter.getCount();
-                        ArrayList<String> items = new ArrayList<>(len);
-                        for (int i = 0; i < len; i++) {
-                            final ModifiableChoice item = adapter.getItem(i);
-                            if (item.modifiableSelected) {
-                                items.add(item.choice.id);
-                            }
-                        }
-                        res.complete(prompt.confirm(items.toArray(new String[items.size()])));
-                    });
-            dialog = createStandardDialog(builder, prompt, res);
-        } else {
-            throw new UnsupportedOperationException();
-        }
-        dialog.show();
-    }
-
-    @Override
-    public GeckoResult<PromptResponse> onChoicePrompt(@NotNull final GeckoSession session,
-                                                      @NotNull final ChoicePrompt prompt) {
-        final GeckoResult<PromptResponse> res = new GeckoResult<>();
-        onChoicePromptImpl(session, prompt.title, prompt.message, prompt.type, prompt.choices,
-                prompt, res);
-        return res;
-    }
-
-    private static int parseColor(final String value, final int def) {
-        try {
-            return Color.parseColor(value);
-        } catch (final IllegalArgumentException e) {
-            return def;
-        }
-    }
-
-    @NotNull
-    @Override
-    public GeckoResult<PromptResponse> onColorPrompt(@NotNull final GeckoSession session,
-                                                     @NotNull final ColorPrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        addStandardLayout(builder, prompt.title, /* msg */ null);
-
-        final int initial = parseColor(prompt.defaultValue, /* def */ 0);
-        final ArrayAdapter<Integer> adapter = new ArrayAdapter<Integer>(
-                builder.getContext(), android.R.layout.simple_list_item_1) {
-            private LayoutInflater mInflater;
-
-            @Override
-            public int getViewTypeCount() {
-                return 2;
-            }
-
-            @Override
-            public int getItemViewType(final int position) {
-                return (getItem(position) == initial) ? 1 : 0;
-            }
-
-            @Override
-            public View getView(final int position, View view,
-                                @NotNull final ViewGroup parent) {
-                if (mInflater == null) {
-                    mInflater = LayoutInflater.from(builder.getContext());
-                }
-                final int color = getItem(position);
-                if (view == null) {
-                    view = mInflater.inflate((color == initial) ?
-                            android.R.layout.simple_list_item_checked :
-                            android.R.layout.simple_list_item_1, parent, false);
-                }
-                view.setBackgroundResource(android.R.drawable.editbox_background);
-                view.getBackground().setColorFilter(color, PorterDuff.Mode.MULTIPLY);
-                return view;
-            }
-        };
-
-        adapter.addAll(0xffff4444 /* holo_red_light */,
-                0xffcc0000 /* holo_red_dark */,
-                0xffffbb33 /* holo_orange_light */,
-                0xffff8800 /* holo_orange_dark */,
-                0xff99cc00 /* holo_green_light */,
-                0xff669900 /* holo_green_dark */,
-                0xff33b5e5 /* holo_blue_light */,
-                0xff0099cc /* holo_blue_dark */,
-                0xffaa66cc /* holo_purple */,
-                0xffffffff /* white */,
-                0xffaaaaaa /* lighter_gray */,
-                0xff555555 /* darker_gray */,
-                0xff000000 /* black */);
-
-        final ListView list = new ListView(builder.getContext());
-        list.setAdapter(adapter);
-        builder.setView(list);
-
-        GeckoResult<PromptResponse> res = new GeckoResult<>();
-
-        final AlertDialog dialog = createStandardDialog(builder, prompt, res);
-        list.setOnItemClickListener((parent, v, position, id) -> {
-            res.complete(prompt.confirm(String.format("#%06x", 0xffffff & adapter.getItem(position))));
-            dialog.dismiss();
-        });
-        dialog.show();
-
-        return res;
-    }
-
-    private static Date parseDate(final SimpleDateFormat formatter,
-                                  final String value,
-                                  final boolean defaultToNow) {
-        try {
-            if (value != null && !value.isEmpty()) {
-                return formatter.parse(value);
-            }
-        } catch (final ParseException e) {
-        }
-        return defaultToNow ? new Date() : null;
-    }
-
-    @SuppressWarnings("deprecation")
-    private static void setTimePickerTime(final TimePicker picker, final Calendar cal) {
-        if (Build.VERSION.SDK_INT >= 23) {
-            picker.setHour(cal.get(Calendar.HOUR_OF_DAY));
-            picker.setMinute(cal.get(Calendar.MINUTE));
-        } else {
-            picker.setCurrentHour(cal.get(Calendar.HOUR_OF_DAY));
-            picker.setCurrentMinute(cal.get(Calendar.MINUTE));
-        }
-    }
-
-    @SuppressWarnings("deprecation")
-    private static void setCalendarTime(final Calendar cal, final TimePicker picker) {
-        if (Build.VERSION.SDK_INT >= 23) {
-            cal.set(Calendar.HOUR_OF_DAY, picker.getHour());
-            cal.set(Calendar.MINUTE, picker.getMinute());
-        } else {
-            cal.set(Calendar.HOUR_OF_DAY, picker.getCurrentHour());
-            cal.set(Calendar.MINUTE, picker.getCurrentMinute());
-        }
-    }
-
-    @Override
-    public GeckoResult<PromptResponse> onDateTimePrompt(@NotNull final GeckoSession session,
-                                                        @NotNull final DateTimePrompt prompt) {
-        final Activity activity = mActivity;
-        if (activity == null) {
-            return GeckoResult.fromValue(prompt.dismiss());
-        }
-        final String format;
-        if (prompt.type == DateTimePrompt.Type.DATE) {
-            format = "yyyy-MM-dd";
-        } else if (prompt.type == DateTimePrompt.Type.MONTH) {
-            format = "yyyy-MM";
-        } else if (prompt.type == DateTimePrompt.Type.WEEK) {
-            format = "yyyy-'W'ww";
-        } else if (prompt.type == DateTimePrompt.Type.TIME) {
-            format = "HH:mm";
-        } else if (prompt.type == DateTimePrompt.Type.DATETIME_LOCAL) {
-            format = "yyyy-MM-dd'T'HH:mm";
-        } else {
-            throw new UnsupportedOperationException();
-        }
-
-        final SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ROOT);
-        final Date minDate = parseDate(formatter, prompt.minValue, /* defaultToNow */ false);
-        final Date maxDate = parseDate(formatter, prompt.maxValue, /* defaultToNow */ false);
-        final Date date = parseDate(formatter, prompt.defaultValue, /* defaultToNow */ true);
-        final Calendar cal = formatter.getCalendar();
-        cal.setTime(date);
-
-        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        final LayoutInflater inflater = LayoutInflater.from(builder.getContext());
-        final DatePicker datePicker;
-        if (prompt.type == DateTimePrompt.Type.DATE || prompt.type == DateTimePrompt.Type.MONTH ||
-                prompt.type == DateTimePrompt.Type.WEEK || prompt.type == DateTimePrompt.Type.DATETIME_LOCAL) {
-            final int resId = builder.getContext().getResources().getIdentifier(
-                    "date_picker_dialog", "layout", "android");
-            DatePicker picker = null;
-            if (resId != 0) {
-                try {
-                    picker = (DatePicker) inflater.inflate(resId, /* root */ null);
-                } catch (final ClassCastException | InflateException e) {
-                    Log.e(LOGTAG, "Unable to inflate DatePicker:\n " + e.toString());
-                }
-            }
-            if (picker == null) {
-                picker = new DatePicker(builder.getContext());
-            }
-            picker.init(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH),
-                    cal.get(Calendar.DAY_OF_MONTH), /* listener */ null);
-            if (minDate != null) {
-                picker.setMinDate(minDate.getTime());
-            }
-            if (maxDate != null) {
-                picker.setMaxDate(maxDate.getTime());
-            }
-            datePicker = picker;
-        } else {
-            datePicker = null;
-        }
-
-        final TimePicker timePicker;
-        if (prompt.type == DateTimePrompt.Type.TIME || prompt.type == DateTimePrompt.Type.DATETIME_LOCAL) {
-            final int resId = builder.getContext().getResources().getIdentifier(
-                    "time_picker_dialog", "layout", "android");
-            TimePicker picker = null;
-            if (resId != 0) {
-                try {
-                    picker = (TimePicker) inflater.inflate(resId, /* root */ null);
-                } catch (final ClassCastException | InflateException e) {
-                    Log.e(LOGTAG, "Unable to inflate TimePicker:\n " + e.toString());
-                }
-            }
-            if (picker == null) {
-                picker = new TimePicker(builder.getContext());
-            }
-            setTimePickerTime(picker, cal);
-            picker.setIs24HourView(DateFormat.is24HourFormat(builder.getContext()));
-            timePicker = picker;
-        } else {
-            timePicker = null;
-        }
-
-        final LinearLayout container = addStandardLayout(builder, prompt.title, /* msg */ null);
-        container.setPadding(/* left */ 0, /* top */ 0, /* right */ 0, /* bottom */ 0);
-        if (datePicker != null) {
-            container.addView(datePicker);
-        }
-        if (timePicker != null) {
-            container.addView(timePicker);
-        }
-
-        GeckoResult<PromptResponse> res = new GeckoResult<>();
-
-        final DialogInterface.OnClickListener listener = (dialog, which) -> {
-            if (which == DialogInterface.BUTTON_NEUTRAL) {
-                // Clear
-                res.complete(prompt.confirm(""));
-                return;
-            }
-            if (datePicker != null) {
-                cal.set(datePicker.getYear(), datePicker.getMonth(),
-                        datePicker.getDayOfMonth());
-            }
-            if (timePicker != null) {
-                setCalendarTime(cal, timePicker);
-            }
-            res.complete(prompt.confirm(formatter.format(cal.getTime())));
-        };
-        builder.setNegativeButton(android.R.string.cancel, /* listener */ null)
-                .setNeutralButton(R.string.gv_prompt_clear, listener)
-                .setPositiveButton(android.R.string.ok, listener);
-        createStandardDialog(builder, prompt, res).show();
-
-        return res;
-    }
-
-    @Override
-    @TargetApi(19)
-    public GeckoResult<PromptResponse> onFilePrompt(@NotNull GeckoSession session,
-                                                    @NotNull FilePrompt prompt) {
-        return GeckoResult.fromValue(prompt.dismiss());
-    }
-
-    @Override
-    public GeckoResult<PromptResponse> onPopupPrompt(@NotNull final GeckoSession session,
-                                                     final PopupPrompt prompt) {
-        return GeckoResult.fromValue(prompt.confirm(AllowOrDeny.ALLOW));
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/gecko/NestedGeckoView.java b/focus-android/app/src/main/java/org/mozilla/focus/gecko/NestedGeckoView.java
deleted file mode 100644
index 6f14af60bad3..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/gecko/NestedGeckoView.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.gecko;
-
-import android.content.Context;
-import androidx.core.view.NestedScrollingChild;
-import androidx.core.view.NestedScrollingChildHelper;
-import androidx.core.view.ViewCompat;
-import android.util.AttributeSet;
-import android.view.MotionEvent;
-
-import org.mozilla.geckoview.GeckoView;
-
-public class NestedGeckoView extends GeckoView implements NestedScrollingChild {
-    private int mLastY;
-    private final int[] mScrollOffset = new int[2];
-    private final int[] mScrollConsumed = new int[2];
-    private int mNestedOffsetY;
-    private final NestedScrollingChildHelper mChildHelper;
-
-    public NestedGeckoView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        mChildHelper = new NestedScrollingChildHelper(this);
-        setNestedScrollingEnabled(true);
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        final MotionEvent event = MotionEvent.obtain(ev);
-        final int action = ev.getActionMasked();
-
-        if (action == MotionEvent.ACTION_DOWN) {
-            mNestedOffsetY = 0;
-        }
-
-        final int eventY = (int) event.getY();
-        event.offsetLocation(0, mNestedOffsetY);
-
-        switch (action) {
-            case MotionEvent.ACTION_MOVE:
-                final boolean allowScroll = !shouldPinOnScreen();
-                int deltaY = mLastY - eventY;
-
-                if (allowScroll && dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
-                    deltaY -= mScrollConsumed[1];
-                    event.offsetLocation(0, -mScrollOffset[1]);
-                    mNestedOffsetY += mScrollOffset[1];
-                }
-
-                mLastY = eventY - mScrollOffset[1];
-
-                if (allowScroll && dispatchNestedScroll(0, mScrollOffset[1], 0, deltaY, mScrollOffset)) {
-                    mLastY -= mScrollOffset[1];
-                    event.offsetLocation(0, mScrollOffset[1]);
-                    mNestedOffsetY += mScrollOffset[1];
-                }
-                break;
-
-            case MotionEvent.ACTION_DOWN:
-                mLastY = eventY;
-                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);
-                break;
-
-            case MotionEvent.ACTION_UP:
-            case MotionEvent.ACTION_CANCEL:
-                stopNestedScroll();
-                break;
-
-            default:
-                // We don't care about other touch events
-        }
-
-        // Execute event handler from parent class in all cases
-        boolean eventHandled = super.onTouchEvent(event);
-
-        // Recycle previously obtained event
-        event.recycle();
-
-        return eventHandled;
-    }
-
-    @Override
-    public void setNestedScrollingEnabled(boolean enabled) {
-        mChildHelper.setNestedScrollingEnabled(enabled);
-    }
-
-    @Override
-    public boolean isNestedScrollingEnabled() {
-        return mChildHelper.isNestedScrollingEnabled();
-    }
-
-    @Override
-    public boolean startNestedScroll(int axes) {
-        return mChildHelper.startNestedScroll(axes);
-    }
-
-    @Override
-    public void stopNestedScroll() {
-        mChildHelper.stopNestedScroll();
-    }
-
-    @Override
-    public boolean hasNestedScrollingParent() {
-        return mChildHelper.hasNestedScrollingParent();
-    }
-
-    @Override
-    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) {
-        return mChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow);
-    }
-
-    @Override
-    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) {
-        return mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);
-    }
-
-    @Override
-    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) {
-        return mChildHelper.dispatchNestedFling(velocityX, velocityY, consumed);
-    }
-
-    @Override
-    public boolean dispatchNestedPreFling(float velocityX, float velocityY) {
-        return mChildHelper.dispatchNestedPreFling(velocityX, velocityY);
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BlockingItemViewHolder.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BlockingItemViewHolder.kt
index 8c02bbe09956..3e41a3b7f90e 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BlockingItemViewHolder.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BlockingItemViewHolder.kt
@@ -1,5 +1,4 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
+/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
@@ -9,24 +8,28 @@ import android.view.View
 import android.widget.CompoundButton
 import android.widget.Switch
 import android.widget.TextView
-import kotlinx.coroutines.Dispatchers.IO
-import kotlinx.coroutines.launch
+import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
 import mozilla.components.support.utils.ThreadUtils
 import org.mozilla.focus.R
-import org.mozilla.focus.exceptions.ExceptionDomains
+import org.mozilla.focus.ext.components
 import org.mozilla.focus.fragment.BrowserFragment
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import java.net.MalformedURLException
-import java.net.URL
 
-internal class BlockingItemViewHolder(itemView: View, private val fragment: BrowserFragment) :
-    BrowserMenuViewHolder(itemView), CompoundButton.OnCheckedChangeListener {
+private const val THUMB_ANIMATION_DURATION = 250L
 
+internal class BlockingItemViewHolder(
+    itemView: View,
+    private val fragment: BrowserFragment
+) : BrowserMenuViewHolder(itemView), CompoundButton.OnCheckedChangeListener {
     private val trackerCounter: TextView
 
     init {
         val switchView = itemView.findViewById<Switch>(R.id.blocking_switch)
-        switchView.isChecked = fragment.session.trackerBlockingEnabled
+
+        switchView.isChecked = fragment.requireContext().components.store.state.findTabOrCustomTabOrSelectedTab(
+            fragment.session.id
+        )!!.trackingProtection.ignoredOnTrackingProtection.not()
+
         switchView.setOnCheckedChangeListener(this)
 
         val helpView = itemView.findViewById<View>(R.id.help_trackers)
@@ -58,21 +61,6 @@ internal class BlockingItemViewHolder(itemView: View, private val fragment: Brow
     }
 
     override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
-        fragment.setBlockingUI(isChecked)
-
-        val url = fragment.url
-        val host = try {
-            URL(url).host
-        } catch (e: MalformedURLException) {
-            url
-        } ?: url
-
-        if (!isChecked) {
-            addUrlToExceptionsList(host = host)
-        } else {
-            removeUrlFromExceptionsList(host = host)
-        }
-
         TelemetryWrapper.blockingSwitchEvent(isChecked)
 
         // Delay closing the menu and reloading the website a bit so that the user can actually see
@@ -80,30 +68,19 @@ internal class BlockingItemViewHolder(itemView: View, private val fragment: Brow
         ThreadUtils.postToMainThreadDelayed(Runnable {
             menu.dismiss()
 
-            fragment.reload()
-        }, Switch_THUMB_ANIMATION_DURATION)
-    }
-
-    private fun addUrlToExceptionsList(host: String) {
-        fragment.launch(IO) {
-            val duplicateURL = ExceptionDomains.load(fragment.requireContext()).contains(host)
-
-            if (duplicateURL) return@launch
-            ExceptionDomains.add(fragment.requireContext(), host)
-        }
-    }
+            buttonView.context.components.apply {
+                if (isChecked) {
+                    trackingProtectionUseCases.removeException(fragment.session.id)
+                } else {
+                    trackingProtectionUseCases.addException(fragment.session.id)
+                }
 
-    private fun removeUrlFromExceptionsList(host: String) {
-        fragment.launch(IO) {
-            if (ExceptionDomains.load(fragment.requireContext()).contains(host)) {
-                TelemetryWrapper.removeExceptionDomains(1)
-                ExceptionDomains.remove(fragment.requireContext(), listOf(host))
+                sessionUseCases.reload(fragment.session)
             }
-        }
+        }, THUMB_ANIMATION_DURATION)
     }
 
     companion object {
-        val LAYOUT_ID = R.layout.menu_blocking_switch
-        val Switch_THUMB_ANIMATION_DURATION = 250L
+        const val LAYOUT_ID = R.layout.menu_blocking_switch
     }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.java
deleted file mode 100644
index 77708650fe5b..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.menu.browser;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import androidx.annotation.Nullable;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.PopupWindow;
-import android.widget.TextView;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.fragment.BrowserFragment;
-import org.mozilla.focus.utils.ViewUtils;
-
-import mozilla.components.browser.state.state.CustomTabConfig;
-
-/**
- * The overflow menu shown in the BrowserFragment containing page actions like "Refresh", "Share" etc.
- */
-public class BrowserMenu extends PopupWindow {
-    private final BrowserMenuAdapter adapter;
-
-    public BrowserMenu(Context context, BrowserFragment fragment, final @Nullable CustomTabConfig customTabConfig) {
-        @SuppressLint("InflateParams") // This View will have it's params ignored anyway:
-        final View view = LayoutInflater.from(context).inflate(R.layout.menu, null);
-        setContentView(view);
-
-        adapter = new BrowserMenuAdapter(context, this, fragment, customTabConfig);
-
-        final RecyclerView menuList = view.findViewById(R.id.list);
-        menuList.setLayoutManager(new LinearLayoutManager(context, RecyclerView.VERTICAL, false));
-        menuList.setAdapter(adapter);
-
-        if (customTabConfig != null) {
-            final TextView brandingView = view.findViewById(R.id.branding);
-            brandingView.setText(context.getString(R.string.menu_custom_tab_branding, context.getString(R.string.app_name)));
-            brandingView.setVisibility(View.VISIBLE);
-        }
-
-        setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
-
-        setFocusable(true);
-
-        setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
-        setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);
-
-        setElevation(context.getResources().getDimension(R.dimen.menu_elevation));
-    }
-
-    public void updateTrackers(int trackers) {
-        adapter.updateTrackers(trackers);
-    }
-
-    public void updateLoading(boolean loading) {
-        adapter.updateLoading(loading);
-    }
-
-    public void show(View anchor) {
-        final int xOffset = ViewUtils.INSTANCE.isRTL(anchor) ? -anchor.getWidth() : 0;
-
-        super.showAsDropDown(anchor, xOffset, -(anchor.getHeight() + anchor.getPaddingBottom()));
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.kt
new file mode 100644
index 000000000000..d794a6541cb4
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenu.kt
@@ -0,0 +1,73 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+package org.mozilla.focus.menu.browser
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.graphics.Color
+import android.graphics.drawable.ColorDrawable
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.PopupWindow
+import android.widget.TextView
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import mozilla.components.browser.state.state.CustomTabConfig
+import org.mozilla.focus.R
+import org.mozilla.focus.fragment.BrowserFragment
+import org.mozilla.focus.utils.ViewUtils.isRTL
+
+/**
+ * The overflow menu shown in the BrowserFragment containing page actions like "Refresh", "Share" etc.
+ */
+class BrowserMenu(
+    context: Context,
+    fragment: BrowserFragment,
+    customTabConfig: CustomTabConfig?
+) : PopupWindow() {
+    private val adapter: BrowserMenuAdapter
+
+    init {
+        @SuppressLint("InflateParams") // This View will have it's params ignored anyway:
+        val view = LayoutInflater.from(context).inflate(R.layout.menu, null)
+
+        contentView = view
+        adapter = BrowserMenuAdapter(context, this, fragment, customTabConfig)
+
+        val menuList: RecyclerView = view.findViewById(R.id.list)
+        menuList.layoutManager = LinearLayoutManager(context, RecyclerView.VERTICAL, false)
+        menuList.adapter = adapter
+
+        if (customTabConfig != null) {
+            val brandingView = view.findViewById<TextView>(R.id.branding)
+            brandingView.text = context.getString(
+                R.string.menu_custom_tab_branding,
+                context.getString(R.string.app_name)
+            )
+            brandingView.visibility = View.VISIBLE
+        }
+
+        setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
+
+        isFocusable = true
+        height = ViewGroup.LayoutParams.WRAP_CONTENT
+        width = ViewGroup.LayoutParams.WRAP_CONTENT
+        elevation = context.resources.getDimension(R.dimen.menu_elevation)
+    }
+
+    fun updateTrackers(trackers: Int) {
+        adapter.updateTrackers(trackers)
+    }
+
+    fun updateLoading(loading: Boolean) {
+        adapter.updateLoading(loading)
+    }
+
+    fun show(anchor: View) {
+        val xOffset = if (isRTL(anchor)) -anchor.width else 0
+        super.showAsDropDown(anchor, xOffset, -(anchor.height + anchor.paddingBottom))
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenuAdapter.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenuAdapter.kt
index 68b00b883264..46b17a0074e1 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenuAdapter.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/BrowserMenuAdapter.kt
@@ -14,7 +14,6 @@ import mozilla.components.browser.state.state.CustomTabConfig
 
 import org.mozilla.focus.R
 import org.mozilla.focus.fragment.BrowserFragment
-import org.mozilla.focus.utils.AppConstants
 import org.mozilla.focus.utils.Browsers
 import org.mozilla.focus.utils.HardwareUtils
 
@@ -142,16 +141,14 @@ class BrowserMenuAdapter(
             )
         }
 
-        if (AppConstants.isGeckoBuild) {
-            // "Report Site Issue" is available for builds using GeckoView only
-            items.add(
-                MenuItem.Default(
-                    R.id.report_site_issue,
-                    resources.getString(R.string.menu_report_site_issue),
-                    0
-                )
+        // "Report Site Issue" is available for builds using GeckoView only
+        items.add(
+            MenuItem.Default(
+                R.id.report_site_issue,
+                resources.getString(R.string.menu_report_site_issue),
+                0
             )
-        }
+        )
 
         if (customTabConfig != null) {
             val customTabItems = customTabConfig.menuItems
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/NavigationItemViewHolder.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/NavigationItemViewHolder.java
index b20ab0c0736e..3e2223defa99 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/NavigationItemViewHolder.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/NavigationItemViewHolder.java
@@ -28,7 +28,7 @@ public NavigationItemViewHolder(View itemView, BrowserFragment fragment) {
         updateLoading(fragment.getSession().getLoading());
 
         final View forwardView = itemView.findViewById(R.id.forward);
-        if (!fragment.canGoForward()) {
+        if (!fragment.getSession().getCanGoForward()) {
             forwardView.setEnabled(false);
             forwardView.setAlpha(0.5f);
         } else {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt
index f6e7547e08f4..37da41df03ff 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt
@@ -7,6 +7,7 @@ package org.mozilla.focus.menu.browser
 import android.view.View
 import android.widget.CheckBox
 import android.widget.CompoundButton
+import mozilla.components.browser.state.selector.findTabOrCustomTab
 
 import org.mozilla.focus.R
 import org.mozilla.focus.fragment.BrowserFragment
@@ -14,7 +15,8 @@ import org.mozilla.focus.telemetry.TelemetryWrapper
 import org.mozilla.focus.utils.UrlUtils
 
 import mozilla.components.support.utils.ThreadUtils
-import org.mozilla.focus.ext.shouldRequestDesktopSite
+import org.mozilla.focus.ext.components
+import org.mozilla.focus.ext.requireComponents
 
 internal class RequestDesktopCheckItemViewHolder/* package */(
     itemView: View,
@@ -23,7 +25,8 @@ internal class RequestDesktopCheckItemViewHolder/* package */(
     private val checkbox: CheckBox = itemView.findViewById(R.id.check_menu_item_checkbox)
 
     init {
-        checkbox.isChecked = fragment.session.shouldRequestDesktopSite
+        val tab = itemView.context.components.store.state.findTabOrCustomTab(fragment.session.id)
+        checkbox.isChecked = tab?.content?.desktopMode ?: false
         checkbox.setOnCheckedChangeListener(this)
     }
 
@@ -35,7 +38,9 @@ internal class RequestDesktopCheckItemViewHolder/* package */(
         // the switch change its state.
         ThreadUtils.postToMainThreadDelayed(Runnable {
             menu.dismiss()
-            fragment.loadUrl(UrlUtils.stripSchemeAndSubDomain(fragment.url))
+
+            val url = UrlUtils.stripSchemeAndSubDomain(fragment.url)
+            fragment.requireComponents.sessionUseCases.loadUrl(url)
         }, ANIMATION_DURATION)
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt
deleted file mode 100644
index 4fdbeb63202c..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt
+++ /dev/null
@@ -1,282 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.menu.context
-
-import android.app.Activity
-import android.app.Dialog
-import android.content.ClipData
-import android.content.ClipboardManager
-import android.content.Context
-import android.content.Intent
-import android.content.pm.ActivityInfo
-import android.content.pm.PackageManager
-import android.content.pm.ResolveInfo
-import android.graphics.Color
-import android.graphics.drawable.ColorDrawable
-import android.net.Uri
-import android.os.Environment
-import com.google.android.material.internal.NavigationMenuView
-import com.google.android.material.navigation.NavigationView
-import androidx.appcompat.app.AlertDialog
-import android.text.Html
-import android.view.LayoutInflater
-import android.view.View
-import android.widget.TextView
-import androidx.preference.PreferenceManager
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.state.state.SessionState
-import org.mozilla.focus.R
-import org.mozilla.focus.activity.MainActivity
-import org.mozilla.focus.open.OpenWithFragment
-import org.mozilla.focus.ext.components
-import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.telemetry.TelemetryWrapper.BrowserContextMenuValue
-import org.mozilla.focus.utils.Browsers
-import org.mozilla.focus.utils.Settings
-import org.mozilla.focus.utils.UrlUtils
-import org.mozilla.focus.utils.ViewUtils
-import org.mozilla.focus.utils.asFragmentActivity
-import org.mozilla.focus.web.Download
-import org.mozilla.focus.web.IWebView
-
-/**
- * The context menu shown when long pressing a URL or an image inside the WebView.
- */
-object WebContextMenu {
-    private fun createTitleView(context: Context, title: String): View {
-        val titleView = LayoutInflater.from(context).inflate(R.layout.context_menu_title, null) as TextView
-        titleView.text = title
-        return titleView
-    }
-
-    @Suppress("ComplexMethod")
-    fun show(
-        context: Context,
-        callback: IWebView.Callback,
-        hitTarget: IWebView.HitTarget,
-        session: Session
-    ) {
-        if (!(hitTarget.isLink || hitTarget.isImage)) {
-            // We don't support any other classes yet:
-            throw IllegalStateException("WebContextMenu can only handle long-press on images and/or links.")
-        }
-
-        TelemetryWrapper.openWebContextMenuEvent()
-
-        val builder = AlertDialog.Builder(context)
-
-        builder.setCustomTitle(when {
-            hitTarget.isLink -> createTitleView(context, hitTarget.linkURL)
-            hitTarget.isImage -> createTitleView(context, hitTarget.imageURL)
-            else -> throw IllegalStateException("Unhandled long press target type")
-        })
-
-        val view = LayoutInflater.from(context).inflate(R.layout.context_menu, null)
-        builder.setView(view)
-
-        builder.setOnCancelListener {
-            // What type of element was long-pressed
-            val value: BrowserContextMenuValue = if (hitTarget.isImage && hitTarget.isLink) {
-                BrowserContextMenuValue.ImageWithLink
-            } else if (hitTarget.isImage) {
-                BrowserContextMenuValue.Image
-            } else {
-                BrowserContextMenuValue.Link
-            }
-
-            // This even is only sent when the back button is pressed, or when a user
-            // taps outside of the dialog:
-            TelemetryWrapper.cancelWebContextMenuEvent(value)
-        }
-
-        val dialog = builder.create()
-        dialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
-
-        val menu = view.findViewById<View>(R.id.context_menu) as NavigationView
-        menu.elevation = 0f
-        val navigationMenuView = menu.getChildAt(0) as? NavigationMenuView
-        if (navigationMenuView != null) {
-            navigationMenuView.isVerticalScrollBarEnabled = false
-        }
-
-        setupMenuForHitTarget(dialog, menu, callback, hitTarget, context, session)
-
-        val warningView = view.findViewById<View>(R.id.warning) as TextView
-        if (hitTarget.isImage) {
-            menu.setBackgroundResource(R.drawable.no_corners_context_menu_navigation_view_background)
-
-            @Suppress("DEPRECATION")
-            warningView.text = Html.fromHtml(
-                context.getString(R.string.contextmenu_image_warning, context.getString(R.string.app_name))
-            )
-        } else {
-            warningView.visibility = View.GONE
-        }
-
-        dialog.show()
-    }
-
-    private fun getAppDataForLink(context: Context, url: String): Array<ActivityInfo>? {
-        val intent = Intent(Intent.ACTION_VIEW)
-        intent.data = Uri.parse(url)
-
-        val browsers = Browsers(context, url)
-
-        val resolveInfos: List<ResolveInfo> = context.packageManager
-                .queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY)
-                .filter {
-                    !browsers.installedBrowsers.contains(it.activityInfo) &&
-                            it.activityInfo.packageName != context.packageName
-                }
-
-        return if (resolveInfos.isEmpty()) null
-            else resolveInfos.map { it.activityInfo }.toTypedArray()
-    }
-
-    /**
-     * Set up the correct menu contents. Note: this method can only be called once the Dialog
-     * has already been created - we need the dialog in order to be able to dismiss it in the
-     * menu callbacks.
-     */
-    @Suppress("ComplexMethod", "LongParameterList")
-    private fun setupMenuForHitTarget(
-        dialog: Dialog,
-        navigationView: NavigationView,
-        callback: IWebView.Callback,
-        hitTarget: IWebView.HitTarget,
-        context: Context,
-        session: Session
-    ) = with(navigationView) {
-        val appLinkData =
-            if (hitTarget.linkURL != null) getAppDataForLink(context, hitTarget.linkURL) else null
-        inflateMenu(R.menu.menu_browser_context)
-
-        menu.findItem(R.id.menu_open_with_app).isVisible = appLinkData != null
-        menu.findItem(R.id.menu_new_tab).isVisible = hitTarget.isLink &&
-                !session.isCustomTabSession()
-        menu.findItem(R.id.menu_open_in_focus).title = resources.getString(
-            R.string.menu_open_with_default_browser2,
-            resources.getString(R.string.app_name)
-        )
-        menu.findItem(R.id.menu_open_in_focus).isVisible = hitTarget.isLink &&
-                session.isCustomTabSession()
-        menu.findItem(R.id.menu_link_share).isVisible = hitTarget.isLink
-        menu.findItem(R.id.menu_link_copy).isVisible = hitTarget.isLink
-        menu.findItem(R.id.menu_image_share).isVisible = hitTarget.isImage
-        menu.findItem(R.id.menu_image_copy).isVisible = hitTarget.isImage
-
-        menu.findItem(R.id.menu_image_save).isVisible = hitTarget.isImage &&
-                UrlUtils.isHttpOrHttps(hitTarget.imageURL)
-
-        setNavigationItemSelectedListener { item ->
-            dialog.dismiss()
-
-            when (item.itemId) {
-                R.id.menu_open_with_app -> {
-                    val fragment =
-                        OpenWithFragment.newInstance(appLinkData!!, hitTarget.linkURL, null)
-                    fragment.show(
-                        context.asFragmentActivity()!!.supportFragmentManager,
-                        OpenWithFragment.FRAGMENT_TAG
-                    )
-
-                    true
-                }
-                R.id.menu_open_in_focus -> {
-                    // Open selected link in Focus and navigate there
-                    val newSession = Session(hitTarget.linkURL, source = SessionState.Source.MENU)
-                    context.components.sessionManager.add(newSession, selected = true)
-
-                    val intent = Intent(context, MainActivity::class.java)
-                    intent.action = Intent.ACTION_MAIN
-                    intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
-                    context.startActivity(intent)
-
-                    TelemetryWrapper.openLinkInFullBrowserFromCustomTabEvent()
-                    true
-                }
-                R.id.menu_new_tab -> {
-                    val newSession = Session(hitTarget.linkURL, source = SessionState.Source.MENU)
-                    context.components.sessionManager.add(
-                        newSession,
-                        selected = Settings.getInstance(context).shouldOpenNewTabs()
-                    )
-
-                    if (!Settings.getInstance(context).shouldOpenNewTabs()) {
-                        // Show Snackbar to allow users to switch to tab they just opened
-                        val snackbar = ViewUtils.getBrandedSnackbar(
-                                (context as Activity).findViewById(android.R.id.content),
-                                R.string.new_tab_opened_snackbar)
-                        snackbar.setAction(R.string.open_new_tab_snackbar) {
-                            context.components.sessionManager.select(newSession)
-                        }
-                        snackbar.show()
-                    }
-
-                    TelemetryWrapper.openLinkInNewTabEvent()
-                    PreferenceManager.getDefaultSharedPreferences(context).edit()
-                            .putBoolean(
-                                    context.getString(R.string.has_opened_new_tab),
-                                    true
-                            ).apply()
-
-                    true
-                }
-                R.id.menu_link_share -> {
-                    TelemetryWrapper.shareLinkEvent()
-                    val shareIntent = Intent(Intent.ACTION_SEND)
-                    shareIntent.type = "text/plain"
-                    shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.linkURL)
-                    dialog.context.startActivity(
-                            Intent.createChooser(
-                                    shareIntent,
-                                    dialog.context.getString(R.string.share_dialog_title)
-                            )
-                    )
-                    true
-                }
-                R.id.menu_image_share -> {
-                    TelemetryWrapper.shareImageEvent()
-                    val shareIntent = Intent(Intent.ACTION_SEND)
-                    shareIntent.type = "text/plain"
-                    shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.imageURL)
-                    dialog.context.startActivity(
-                            Intent.createChooser(
-                                    shareIntent,
-                                    dialog.context.getString(R.string.share_dialog_title)
-                            )
-                    )
-                    true
-                }
-                R.id.menu_image_save -> {
-                    val download =
-                            Download(hitTarget.imageURL, null, null, null, -1, Environment.DIRECTORY_PICTURES, null)
-                    callback.onDownloadStart(download)
-                    TelemetryWrapper.saveImageEvent()
-                    true
-                }
-                R.id.menu_link_copy, R.id.menu_image_copy -> {
-                    val clipboard = dialog.context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
-                    val uri: Uri = when {
-                        item.itemId == R.id.menu_link_copy -> {
-                            TelemetryWrapper.copyLinkEvent()
-                            Uri.parse(hitTarget.linkURL)
-                        }
-                        item.itemId == R.id.menu_image_copy -> {
-                            TelemetryWrapper.copyImageEvent()
-                            Uri.parse(hitTarget.imageURL)
-                        }
-                        else -> throw IllegalStateException("Unknown hitTarget type - cannot copy to clipboard")
-                    }
-
-                    val clip = ClipData.newUri(dialog.context.contentResolver, "URI", uri)
-                    clipboard.setPrimaryClip(clip)
-                    true
-                }
-                else -> throw IllegalArgumentException("Unhandled menu item id=" + item.itemId)
-            }
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
index d65f75fbf804..b368caed81e5 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
@@ -32,7 +32,6 @@ import kotlinx.coroutines.Dispatchers.Main
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.coroutineScope
 import kotlinx.coroutines.launch
-import mozilla.components.browser.session.Session
 import mozilla.components.browser.state.state.SessionState
 import org.mozilla.focus.R
 import org.mozilla.focus.ext.components
@@ -40,6 +39,7 @@ import org.mozilla.focus.searchsuggestions.SearchSuggestionsViewModel
 import org.mozilla.focus.searchsuggestions.State
 import org.mozilla.focus.utils.SupportUtils
 import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.utils.createTab
 import kotlin.coroutines.CoroutineContext
 
 class SearchSuggestionsFragment : Fragment(), CoroutineScope {
@@ -160,7 +160,7 @@ class SearchSuggestionsFragment : Fragment(), CoroutineScope {
             override fun onClick(textView: View) {
                 val context = textView.context
                 val url = SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.SEARCH_SUGGESTIONS)
-                val session = Session(url, source = SessionState.Source.MENU)
+                val session = createTab(url, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
             }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/IntentProcessor.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/IntentProcessor.kt
index e1ab8dc37ada..57be13ecc55c 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/IntentProcessor.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/IntentProcessor.kt
@@ -18,9 +18,9 @@ import mozilla.components.support.utils.SafeIntent
 import mozilla.components.support.utils.WebURLFinder
 import org.mozilla.focus.activity.TextActionActivity
 import org.mozilla.focus.ext.components
-import org.mozilla.focus.ext.shouldRequestDesktopSite
 import org.mozilla.focus.shortcut.HomeScreen
 import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.utils.createTab
 
 /**
  * Implementation moved from Focus SessionManager. To be replaced with SessionIntentProcessor from feature-session
@@ -123,26 +123,30 @@ class IntentProcessor(
     }
 
     private fun createSession(source: SessionState.Source, url: String): Session {
-        return Session(url, source = source).apply {
+        return createTab(url, source = source).apply {
             sessionManager.add(this, selected = true)
         }
     }
 
     private fun createSearchSession(source: SessionState.Source, url: String, searchTerms: String): Session {
-        return Session(url, source = source).apply {
-            context.components.store.dispatch(ContentAction.UpdateSearchTermsAction(id, searchTerms))
+        return createTab(url, source = source).apply {
             sessionManager.add(this, selected = true)
+
+            context.components.store.dispatch(ContentAction.UpdateSearchTermsAction(
+                id,
+                searchTerms
+            ))
         }
     }
 
     private fun createSession(source: SessionState.Source, intent: SafeIntent, url: String): Session {
         return if (isCustomTabIntent(intent.unsafe)) {
-            Session(url, source = SessionState.Source.CUSTOM_TAB).apply {
+            createTab(url, source = SessionState.Source.CUSTOM_TAB).apply {
                 customTabConfig = createCustomTabConfigFromIntent(intent.unsafe, context.resources)
                 sessionManager.add(this, selected = false)
             }
         } else {
-            Session(url, source = source).apply {
+            createTab(url, source = source).apply {
                 sessionManager.add(this, selected = true)
             }
         }
@@ -156,17 +160,20 @@ class IntentProcessor(
         requestDesktop: Boolean
     ): Session {
         val session = if (isCustomTabIntent(intent)) {
-            Session(url, source = SessionState.Source.CUSTOM_TAB).apply {
+            createTab(url, source = SessionState.Source.CUSTOM_TAB).apply {
                 customTabConfig = createCustomTabConfigFromIntent(intent.unsafe, context.resources)
             }
         } else {
-            Session(url, source = source)
+            createTab(url, source = source)
         }
         session.trackerBlockingEnabled = blockingEnabled
-        session.shouldRequestDesktopSite = requestDesktop
 
         sessionManager.add(session, selected = !session.isCustomTabSession())
 
+        if (requestDesktop) {
+            context.components.sessionUseCases.requestDesktopSite(requestDesktop, session)
+        }
+
         return session
     }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionCallbackProxy.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionCallbackProxy.kt
deleted file mode 100644
index bbb31abde71a..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionCallbackProxy.kt
+++ /dev/null
@@ -1,142 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session
-
-import android.view.View
-
-import org.mozilla.focus.web.Download
-import org.mozilla.focus.web.IWebView
-
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.state.action.ContentAction
-import mozilla.components.browser.state.store.BrowserStore
-import mozilla.components.concept.engine.content.blocking.Tracker
-import org.mozilla.focus.ext.contentState
-import org.mozilla.focus.ext.isSearch
-import org.mozilla.focus.ext.shouldRequestDesktopSite
-import org.mozilla.focus.utils.AppConstants
-
-@Suppress("TooManyFunctions")
-class SessionCallbackProxy(
-    private val session: Session,
-    private val store: BrowserStore,
-    private val delegate: IWebView.Callback
-) : IWebView.Callback {
-
-    var isDownload = false
-
-    override fun onPageStarted(url: String) {
-        session.loading = true
-
-        // We are always setting the progress to 5% when a new page starts loading. Otherwise it might
-        // look like the browser is doing nothing (on a slow network) until we receive a progress
-        // from the WebView.
-        session.progress = MINIMUM_PROGRESS
-
-        if (!AppConstants.isGeckoBuild) {
-            session.securityInfo = Session.SecurityInfo(false)
-            session.url = url
-        }
-    }
-
-    override fun onPageFinished(isSecure: Boolean) {
-        session.progress = MAXIMUM_PROGRESS
-        session.loading = false
-        if (!isDownload && !AppConstants.isGeckoBuild) {
-            session.securityInfo = Session.SecurityInfo(
-                isSecure,
-                session.securityInfo.host,
-                session.securityInfo.issuer
-            )
-        } else {
-            isDownload = false
-        }
-    }
-
-    override fun onSecurityChanged(isSecure: Boolean, host: String?, organization: String?) {
-        if (isSecure) {
-            session.securityInfo = Session.SecurityInfo(isSecure, host ?: "", organization ?: "")
-        } else {
-            session.securityInfo = Session.SecurityInfo(false)
-        }
-    }
-
-    override fun onProgress(progress: Int) {
-        var actualProgress = progress
-        // We do not want the progress to go backwards - so we always set it to at least the minimum.
-        actualProgress = Math.max(MINIMUM_PROGRESS, actualProgress)
-
-        // We do not want to show to show a progress that 100% because this will make the progress
-        // bar disappear.
-        actualProgress = Math.min(MAXIMUM_PROGRESS, actualProgress)
-
-        session.progress = actualProgress
-    }
-
-    override fun onURLChanged(url: String) {
-        session.url = url
-    }
-
-    override fun onTitleChanged(title: String) {
-        session.title = title
-    }
-
-    override fun onRequest(isTriggeredByUserGesture: Boolean) {
-        val contentState = store.contentState(session.id)
-        if (isTriggeredByUserGesture && contentState?.isSearch == true) {
-            // The user actively navigated away (no redirect) from the search page. Clear the
-            // search terms.
-            store.dispatch(ContentAction.UpdateSearchTermsAction(session.id, ""))
-        }
-    }
-
-    override fun countBlockedTracker() {
-        // The browser-engine component will fill "trackersBlocked" with blocked URLs. Until we use
-        // this component we just add a random string because we only display the count currently.
-        session.trackersBlocked = session.trackersBlocked + listOf(Tracker(session.url))
-    }
-
-    override fun resetBlockedTrackers() {
-        session.trackersBlocked = emptyList()
-    }
-
-    override fun onBlockingStateChanged(isBlockingEnabled: Boolean) {
-        session.trackerBlockingEnabled = isBlockingEnabled
-    }
-
-    override fun onHttpAuthRequest(callback: IWebView.HttpAuthCallback, host: String, realm: String) {
-        delegate.onHttpAuthRequest(callback, host, realm)
-    }
-
-    override fun onRequestDesktopStateChanged(shouldRequestDesktop: Boolean) {
-        session.shouldRequestDesktopSite = shouldRequestDesktop
-    }
-
-    override fun onDownloadStart(download: Download) {
-        // To be replaced with session property
-        isDownload = true
-        delegate.onDownloadStart(download)
-    }
-
-    override fun onLongPress(hitTarget: IWebView.HitTarget) {
-        // To be replaced with session property
-        delegate.onLongPress(hitTarget)
-    }
-
-    override fun onEnterFullScreen(callback: IWebView.FullscreenCallback, view: View?) {
-        // To be replaced with session property
-        delegate.onEnterFullScreen(callback, view)
-    }
-
-    override fun onExitFullScreen() {
-        // To be replaced with session property
-        delegate.onExitFullScreen()
-    }
-
-    companion object {
-        internal const val MINIMUM_PROGRESS = 5
-        internal const val MAXIMUM_PROGRESS = 99
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionManagerExtension.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionManagerExtension.kt
deleted file mode 100644
index 398c2b8b20b7..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionManagerExtension.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session
-
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.session.SessionManager
-import org.mozilla.focus.ext.savedGeckoSession
-import org.mozilla.focus.utils.AppConstants
-
-fun SessionManager.removeAndCloseSession(session: Session) {
-    if (AppConstants.isGeckoBuild) {
-        val geckoSession = session.savedGeckoSession
-        if (geckoSession != null && geckoSession.isOpen) {
-            geckoSession.close()
-        }
-    }
-    remove(session)
-}
-
-fun SessionManager.removeAndCloseAllSessions() {
-    if (AppConstants.isGeckoBuild) {
-        sessions.forEach { session ->
-            val geckoSession = session.savedGeckoSession
-            if (geckoSession != null && geckoSession.isOpen) {
-                geckoSession.close()
-            }
-        }
-    }
-    removeSessions()
-}
-
-fun SessionManager.removeAllAndCloseAllSessions() {
-    if (AppConstants.isGeckoBuild) {
-        all.forEach { session ->
-            val geckoSession = session.savedGeckoSession
-            if (geckoSession != null && geckoSession.isOpen) {
-                geckoSession.close()
-            }
-        }
-    }
-    removeAll()
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt
index 823393894e59..1e573483c4ba 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt
@@ -67,7 +67,7 @@ class SessionNotificationService : Service() {
             TelemetryWrapper.eraseTaskRemoved()
         }
 
-        components.sessionManager.removeAndCloseAllSessions()
+        components.sessionManager.removeSessions()
 
         stopForeground(true)
         stopSelf()
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt
index 4b4e12ab2e24..a8cbd239fd9e 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/EraseViewHolder.kt
@@ -12,7 +12,6 @@ import android.view.View
 import android.widget.TextView
 import org.mozilla.focus.R
 import org.mozilla.focus.ext.requireComponents
-import org.mozilla.focus.session.removeAndCloseAllSessions
 import org.mozilla.focus.telemetry.TelemetryWrapper
 
 class EraseViewHolder(
@@ -32,7 +31,7 @@ class EraseViewHolder(
 
         fragment.animateAndDismiss().addListener(object : AnimatorListenerAdapter() {
             override fun onAnimationEnd(animation: Animator) {
-                fragment.requireComponents.sessionManager.removeAndCloseAllSessions()
+                fragment.requireComponents.sessionManager.removeSessions()
             }
         })
     }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/LearnMoreSwitchPreference.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/LearnMoreSwitchPreference.kt
index a8a1d043f52b..a252858ecde7 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/LearnMoreSwitchPreference.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/LearnMoreSwitchPreference.kt
@@ -10,10 +10,10 @@ import android.util.AttributeSet
 import android.view.ContextThemeWrapper
 import android.view.View
 import android.widget.TextView
-import mozilla.components.browser.session.Session
 import mozilla.components.browser.state.state.SessionState
 import org.mozilla.focus.R
 import org.mozilla.focus.ext.components
+import org.mozilla.focus.utils.createTab
 
 abstract class LearnMoreSwitchPreference(context: Context?, attrs: AttributeSet?) :
     SwitchPreferenceCompat(context, attrs) {
@@ -37,7 +37,7 @@ abstract class LearnMoreSwitchPreference(context: Context?, attrs: AttributeSet?
         learnMoreLink.setOnClickListener {
             // This is a hardcoded link: if we ever end up needing more of these links, we should
             // move the link into an xml parameter, but there's no advantage to making it configurable now.
-            val session = Session(getLearnMoreUrl(), source = SessionState.Source.MENU)
+            val session = createTab(getLearnMoreUrl(), source = SessionState.Source.MENU)
             context.components.sessionManager.add(session, selected = true)
             if (context is ContextThemeWrapper) {
                 if ((context as ContextThemeWrapper).baseContext is Activity) {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
index 31068a1893d2..649b198d31ef 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
@@ -8,18 +8,17 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.os.Bundle
 import android.os.Handler
-import androidx.annotation.VisibleForTesting
-import androidx.annotation.WorkerThread
-import com.google.android.material.snackbar.Snackbar
 import android.util.Log
 import android.view.Menu
 import android.view.MenuInflater
 import android.view.MenuItem
 import android.view.ViewGroup
 import android.widget.EditText
+import androidx.annotation.VisibleForTesting
+import androidx.annotation.WorkerThread
+import com.google.android.material.snackbar.Snackbar
 import org.mozilla.focus.R
-import org.mozilla.focus.R.string.action_option_add_search_engine
-import org.mozilla.focus.activity.InfoActivity
+import org.mozilla.focus.ext.components
 import org.mozilla.focus.search.CustomSearchEngineStore
 import org.mozilla.focus.search.ManualAddSearchEnginePreference
 import org.mozilla.focus.telemetry.TelemetryWrapper
@@ -27,6 +26,7 @@ import org.mozilla.focus.utils.Settings
 import org.mozilla.focus.utils.SupportUtils
 import org.mozilla.focus.utils.UrlUtils
 import org.mozilla.focus.utils.ViewUtils
+import org.mozilla.focus.utils.createTab
 import java.io.IOException
 import java.lang.ref.WeakReference
 import java.net.HttpURLConnection
@@ -84,12 +84,15 @@ class ManualAddSearchEngineSettingsFragment : BaseSettingsFragment() {
 
     override fun onOptionsItemSelected(item: MenuItem): Boolean {
         val openLearnMore = {
-            val url = SupportUtils.getSumoURLForTopic(context!!,
-                    SupportUtils.SumoTopic.ADD_SEARCH_ENGINE)
-            val intent = InfoActivity.getIntentFor(context!!,
-                    url, getString(action_option_add_search_engine))
-            startActivity(intent)
+            val session = createTab(
+                SupportUtils.getSumoURLForTopic(requireContext(), SupportUtils.SumoTopic.ADD_SEARCH_ENGINE)
+            )
+
+            components?.sessionManager?.add(session, selected = true)
+
             TelemetryWrapper.addSearchEngineLearnMoreEvent()
+
+            activity?.finish()
         }
 
         val saveSearchEngine = {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/MozillaSettingsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/MozillaSettingsFragment.kt
index 38e53cf29d8c..f3818fa3477e 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/MozillaSettingsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/MozillaSettingsFragment.kt
@@ -7,14 +7,14 @@ package org.mozilla.focus.settings
 import android.content.SharedPreferences
 import android.os.Bundle
 import androidx.preference.Preference
-import mozilla.components.browser.session.Session
 import mozilla.components.browser.state.state.SessionState
 import org.mozilla.focus.R
-import org.mozilla.focus.activity.InfoActivity
+import org.mozilla.focus.browser.LocalizedContent
 import org.mozilla.focus.ext.components
 import org.mozilla.focus.telemetry.TelemetryWrapper
 import org.mozilla.focus.utils.AppConstants
 import org.mozilla.focus.utils.SupportUtils
+import org.mozilla.focus.utils.createTab
 
 class MozillaSettingsFragment : BaseSettingsFragment(),
     SharedPreferences.OnSharedPreferenceChangeListener {
@@ -46,17 +46,19 @@ class MozillaSettingsFragment : BaseSettingsFragment(),
 
         when (preference.key) {
             resources.getString(R.string.pref_key_about) -> run {
-                val intent = InfoActivity.getAboutIntent(requireContext())
-                startActivity(intent)
+                val session = createTab(LocalizedContent.URL_ABOUT, source = SessionState.Source.MENU)
+                activity.components.sessionManager.add(session, true)
+                activity.finish()
             }
             resources.getString(R.string.pref_key_help) -> run {
-                val session = Session(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
+                val session = createTab(SupportUtils.HELP_URL, source = SessionState.Source.MENU)
                 activity.components.sessionManager.add(session, true)
                 activity.finish()
             }
             resources.getString(R.string.pref_key_rights) -> run {
-                val intent = InfoActivity.getRightsIntent(requireContext())
-                startActivity(intent)
+                val session = createTab(LocalizedContent.URL_RIGHTS, source = SessionState.Source.MENU)
+                activity.components.sessionManager.add(session, true)
+                activity.finish()
             }
             resources.getString(R.string.pref_key_privacy_notice) -> {
                 val url = if (AppConstants.isKlarBuild)
@@ -64,7 +66,7 @@ class MozillaSettingsFragment : BaseSettingsFragment(),
                 else
                     SupportUtils.PRIVACY_NOTICE_URL
 
-                val session = Session(url, source = SessionState.Source.MENU)
+                val session = createTab(url, source = SessionState.Source.MENU)
                 activity.components.sessionManager.add(session, true)
                 activity.finish()
             }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/PrivacySecuritySettingsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/PrivacySecuritySettingsFragment.kt
index 35963e7a3f01..901fb5b949ef 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/PrivacySecuritySettingsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/PrivacySecuritySettingsFragment.kt
@@ -11,10 +11,9 @@ import androidx.preference.Preference
 import androidx.preference.SwitchPreferenceCompat
 import org.mozilla.focus.R
 import org.mozilla.focus.biometrics.Biometrics
-import org.mozilla.focus.exceptions.ExceptionDomains
 import org.mozilla.focus.exceptions.ExceptionsListFragment
+import org.mozilla.focus.ext.requireComponents
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
 import org.mozilla.focus.widget.CookiesPreference
 
 class PrivacySecuritySettingsFragment : BaseSettingsFragment(),
@@ -35,30 +34,12 @@ class PrivacySecuritySettingsFragment : BaseSettingsFragment(),
             preferenceScreen.removePreference(biometricPreference)
         }
 
-        val safeBrowsingPreference =
-            findPreference(getString(R.string.pref_key_category_safe_browsing))
-        preferenceScreen.removePreference(safeBrowsingPreference)
         val cookiesPreference =
             findPreference(getString(R.string.pref_key_performance_enable_cookies)) as CookiesPreference
-        if (!AppConstants.isGeckoBuild) {
-            val cookiesStringsWV =
-                requireContext().resources.getStringArray(R.array.preference_privacy_cookies_options)
-                    .filter {
-                        it != getString(
-                            R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option
-                        )
-                    }
-            cookiesPreference.entries = cookiesStringsWV.toTypedArray()
-            cookiesPreference.entryValues = cookiesStringsWV.toTypedArray()
-
-            cookiesPreference.setDefaultValue(
-                getString(R.string.preference_privacy_should_block_cookies_no_option)
-            )
-        } else {
-            cookiesPreference.setDefaultValue(
-                getString(R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option)
-            )
-        }
+
+        cookiesPreference.setDefaultValue(
+            getString(R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option)
+        )
         cookiesPreference.updateSummary()
     }
 
@@ -104,8 +85,10 @@ class PrivacySecuritySettingsFragment : BaseSettingsFragment(),
 
     private fun updateExceptionSettingAvailability() {
         val exceptionsPreference = findPreference(getString(R.string.pref_key_screen_exceptions))
-        if (ExceptionDomains.load(requireContext()).isEmpty()) {
-            exceptionsPreference.isEnabled = false
+        exceptionsPreference.isEnabled = false
+
+        requireComponents.trackingProtectionUseCases.fetchExceptions.invoke { exceptions ->
+            exceptionsPreference.isEnabled = exceptions.isNotEmpty()
         }
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/SettingsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/SettingsFragment.kt
index a9f3a1c80337..a6ac2387d412 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/SettingsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/SettingsFragment.kt
@@ -9,15 +9,11 @@ import android.content.SharedPreferences
 import android.os.Bundle
 import org.mozilla.focus.R
 import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
 
 class SettingsFragment : BaseSettingsFragment(), SharedPreferences.OnSharedPreferenceChangeListener {
 
     override fun onCreatePreferences(bundle: Bundle?, s: String?) {
         addPreferencesFromResource(R.xml.settings)
-        if (!AppConstants.isGeckoBuild && !AppConstants.isDevBuild) {
-            preferenceScreen.removePreference(findPreference(getString(R.string.pref_key_advanced_screen)))
-        }
     }
 
     override fun onResume() {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/telemetry/CrashReporterWrapper.kt b/focus-android/app/src/main/java/org/mozilla/focus/telemetry/CrashReporterWrapper.kt
index 575c5d4cfa90..e4a4667a3d96 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/telemetry/CrashReporterWrapper.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/telemetry/CrashReporterWrapper.kt
@@ -12,12 +12,17 @@ import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.launch
 import mozilla.components.lib.crash.Crash
 import mozilla.components.lib.crash.CrashReporter
+import mozilla.components.lib.crash.service.CrashReporterService
 import mozilla.components.lib.crash.service.MozillaSocorroService
 import mozilla.components.lib.crash.service.SentryService
 import org.mozilla.focus.BuildConfig
 import org.mozilla.focus.R
 import org.mozilla.focus.activity.MainActivity
 import org.mozilla.focus.locale.LocaleManager
+import org.mozilla.geckoview.BuildConfig.MOZ_APP_BUILDID
+import org.mozilla.geckoview.BuildConfig.MOZ_APP_VENDOR
+import org.mozilla.geckoview.BuildConfig.MOZ_APP_VERSION
+import org.mozilla.geckoview.BuildConfig.MOZ_UPDATE_CHANNEL
 import java.util.Locale
 
 /**
@@ -41,9 +46,31 @@ object CrashReporterWrapper {
         // The BuildConfig value is populated from a file at compile time.
         // If the file did not exist, the value will be null.
         val supportedBuild = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
-        if (!supportedBuild || BuildConfig.SENTRY_TOKEN.isEmpty()) return
+        if (!supportedBuild) return
 
-        val sentryDsn = BuildConfig.SENTRY_TOKEN
+        val services = mutableListOf<CrashReporterService>()
+
+        if (isSentryEnabled()) {
+            val sentryService = SentryService(
+                context,
+                BuildConfig.SENTRY_TOKEN,
+                tags = createTags(context),
+                environment = BuildConfig.BUILD_TYPE,
+                sendEventForNativeCrashes = false // Do not send native crashes to Sentry
+            )
+
+            services.add(sentryService)
+        }
+
+        val socorroService = MozillaSocorroService(
+            context,
+            appName = SOCORRO_APP_NAME,
+            version = MOZ_APP_VERSION,
+            buildId = MOZ_APP_BUILDID,
+            vendor = MOZ_APP_VENDOR,
+            releaseChannel = MOZ_UPDATE_CHANNEL
+        )
+        services.add(socorroService)
 
         val intent = Intent(context, MainActivity::class.java).apply {
             flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
@@ -57,14 +84,7 @@ object CrashReporterWrapper {
 
         crashReporter = CrashReporter(
                 context = context,
-                services = listOf(
-                    SentryService(
-                        context,
-                        sentryDsn,
-                        tags = createTags(context),
-                        sendEventForNativeCrashes = true),
-                    MozillaSocorroService(context, SOCORRO_APP_NAME)
-                ),
+                services = services,
                 promptConfiguration = CrashReporter.PromptConfiguration(
                         appName = context.resources.getString(R.string.app_name)
                 ),
@@ -74,6 +94,8 @@ object CrashReporterWrapper {
         onIsEnabledChanged(context)
     }
 
+    fun isSentryEnabled() = !BuildConfig.SENTRY_TOKEN.isNullOrEmpty()
+
     fun onIsEnabledChanged(context: Context, isEnabled: Boolean = TelemetryWrapper.isTelemetryEnabled(context)) {
         crashReporter?.enabled = isEnabled
     }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/telemetry/TelemetryWrapper.kt b/focus-android/app/src/main/java/org/mozilla/focus/telemetry/TelemetryWrapper.kt
index 59fbe1c93b28..d784ce7a8c4a 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/telemetry/TelemetryWrapper.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/telemetry/TelemetryWrapper.kt
@@ -733,9 +733,8 @@ object TelemetryWrapper {
             .queue()
     }
 
-    fun removeAllExceptionDomains(count: Int) {
+    fun removeAllExceptionDomains() {
         TelemetryEvent.create(Category.ACTION, Method.REMOVE_ALL, Object.ALLOWLIST)
-            .extra(Extra.TOTAL, count.toString())
             .queue()
     }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/tips/TipManager.kt b/focus-android/app/src/main/java/org/mozilla/focus/tips/TipManager.kt
index 2443dd017539..4defa3a7086a 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/tips/TipManager.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/tips/TipManager.kt
@@ -9,19 +9,8 @@ import android.content.Context
 import android.content.Intent
 import android.net.Uri
 import android.os.Build
-import mozilla.components.browser.session.Session
 import mozilla.components.browser.state.state.SessionState
-import org.mozilla.focus.R.string.app_name
-import org.mozilla.focus.R.string.tip_add_to_homescreen
-import org.mozilla.focus.R.string.tip_autocomplete_url
-import org.mozilla.focus.R.string.tip_disable_tips2
-import org.mozilla.focus.R.string.tip_disable_tracking_protection
-import org.mozilla.focus.R.string.tip_explain_allowlist
-import org.mozilla.focus.R.string.tip_open_in_new_tab
-import org.mozilla.focus.R.string.tip_request_desktop
-import org.mozilla.focus.R.string.tip_set_default_browser
-import org.mozilla.focus.R.string.tip_take_survey
-import org.mozilla.focus.exceptions.ExceptionDomains
+import org.mozilla.focus.R
 import org.mozilla.focus.ext.components
 import org.mozilla.focus.locale.LocaleAwareAppCompatActivity
 import org.mozilla.focus.locale.LocaleManager
@@ -29,6 +18,7 @@ import org.mozilla.focus.telemetry.TelemetryWrapper
 import org.mozilla.focus.utils.Browsers
 import org.mozilla.focus.utils.Settings
 import org.mozilla.focus.utils.SupportUtils
+import org.mozilla.focus.utils.createTab
 import java.util.Locale
 import java.util.Random
 
@@ -38,25 +28,32 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         private const val FORCE_SHOW_DISABLE_TIPS_INTERVAL = 30
 
         fun createAllowlistTip(context: Context): Tip {
-            val id = tip_explain_allowlist
+            val id = R.string.tip_explain_allowlist
             val name = context.resources.getString(id)
             val url = SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.ALLOWLIST)
 
             val deepLink = {
-                val session = Session(url, source = SessionState.Source.MENU)
+                val session = createTab(url, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
                 TelemetryWrapper.pressTipEvent(id)
             }
 
             val shouldDisplayAllowListTip = {
-                ExceptionDomains.load(context).isEmpty()
+                // Since the refactoring from a custom exception list to using the
+                // exceotion list in Gecko, this method always returns false. To
+                // determine whether we would like to show it, we'd need to query
+                // Gecko asynchronously. But since the TipManager calls all those
+                // methods synchronously, this is not really possible wihtout
+                // refactoring TipManager. At this time it is easier to just not
+                // show this tip.
+                false
             }
 
             return Tip(id, name, shouldDisplayAllowListTip, deepLink)
         }
 
         fun createTrackingProtectionTip(context: Context): Tip {
-            val id = tip_disable_tracking_protection
+            val id = R.string.tip_disable_tracking_protection
             val name = context.resources.getString(id)
 
             val shouldDisplayTrackingProtection = {
@@ -69,13 +66,13 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createHomescreenTip(context: Context): Tip {
-            val id = tip_add_to_homescreen
+            val id = R.string.tip_add_to_homescreen
             val name = context.resources.getString(id)
             val homescreenURL =
                     "https://support.mozilla.org/en-US/kb/add-web-page-shortcuts-your-home-screen"
 
             val deepLinkAddToHomescreen = {
-                val session = Session(homescreenURL, source = SessionState.Source.MENU)
+                val session = createTab(homescreenURL, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
                 TelemetryWrapper.pressTipEvent(id)
             }
@@ -86,8 +83,8 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createDefaultBrowserTip(context: Context): Tip {
-            val appName = context.resources.getString(app_name)
-            val id = tip_set_default_browser
+            val appName = context.resources.getString(R.string.app_name)
+            val id = R.string.tip_set_default_browser
             val name = context.resources.getString(id, appName)
             val browsers = Browsers(context, Browsers.TRADITIONAL_BROWSER_URL)
 
@@ -112,7 +109,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createAutocompleteURLTip(context: Context): Tip {
-            val id = tip_autocomplete_url
+            val id = R.string.tip_autocomplete_url
             val name = context.resources.getString(id)
             val autocompleteURL =
                     "https://support.mozilla.org/en-US/kb/autocomplete-settings-firefox-focus-address-bar"
@@ -122,7 +119,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
             }
 
             val deepLinkAutocompleteUrl = {
-                val session = Session(autocompleteURL, source = SessionState.Source.MENU)
+                val session = createTab(autocompleteURL, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
                 TelemetryWrapper.pressTipEvent(id)
             }
@@ -131,7 +128,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createOpenInNewTabTip(context: Context): Tip {
-            val id = tip_open_in_new_tab
+            val id = R.string.tip_open_in_new_tab
             val name = context.resources.getString(id)
             val newTabURL =
                     "https://support.mozilla.org/en-US/kb/open-new-tab-firefox-focus-android"
@@ -141,7 +138,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
             }
 
             val deepLinkOpenInNewTab = {
-                val session = Session(newTabURL, source = SessionState.Source.MENU)
+                val session = createTab(newTabURL, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
                 TelemetryWrapper.pressTipEvent(id)
             }
@@ -150,7 +147,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createRequestDesktopTip(context: Context): Tip {
-            val id = tip_request_desktop
+            val id = R.string.tip_request_desktop
             val name = context.resources.getString(id)
             val requestDesktopURL =
                     "https://support.mozilla.org/en-US/kb/switch-desktop-view-firefox-focus-android"
@@ -160,7 +157,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
             }
 
             val deepLinkRequestDesktop = {
-                val session = Session(requestDesktopURL, source = SessionState.Source.MENU)
+                val session = createTab(requestDesktopURL, source = SessionState.Source.MENU)
                 context.components.sessionManager.add(session, selected = true)
                 TelemetryWrapper.pressTipEvent(id)
             }
@@ -169,7 +166,7 @@ class Tip(val id: Int, val text: String, val shouldDisplay: () -> Boolean, val d
         }
 
         fun createDisableTipsTip(context: Context): Tip {
-            val id = tip_disable_tips2
+            val id = R.string.tip_disable_tips2
             val name = context.resources.getString(id)
 
             val shouldDisplayDisableTips = {
@@ -237,7 +234,7 @@ object TipManager {
 
         // Show the survey tip first
         for (tip in listOfTips) {
-            if (tip.id == tip_take_survey && tip.shouldDisplay()) {
+            if (tip.id == R.string.tip_take_survey && tip.shouldDisplay()) {
                 listOfTips.remove(tip)
                 return tip
             }
@@ -245,7 +242,7 @@ object TipManager {
 
         // Always show the disable tip if it's ready to be displayed
         for (tip in listOfTips) {
-            if (tip.id == tip_disable_tips2 && tip.shouldDisplay()) {
+            if (tip.id == R.string.tip_disable_tips2 && tip.shouldDisplay()) {
                 listOfTips.remove(tip)
                 return tip
             }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/AppConstants.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/AppConstants.kt
index 8f26a7f71755..22e790e0da86 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/AppConstants.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/AppConstants.kt
@@ -18,13 +18,6 @@ object AppConstants {
     val isReleaseBuild: Boolean
         get() = BUILD_TYPE_RELEASE == BuildConfig.BUILD_TYPE
 
-    val isGeckoBuild: Boolean
-        get() = true
-
     val isDevBuild: Boolean
         get() = BUILD_TYPE_DEBUG == BuildConfig.BUILD_TYPE
-
-    fun supportsDownloadingFiles(): Boolean {
-        return true
-    }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/AppPermissionCodes.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/AppPermissionCodes.kt
new file mode 100644
index 000000000000..5b2090d4e6b7
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/AppPermissionCodes.kt
@@ -0,0 +1,13 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.utils
+
+object AppPermissionCodes {
+    const val REQUEST_CODE_DOWNLOAD_PERMISSIONS = 1
+    const val REQUEST_CODE_PROMPT_PERMISSIONS = 2
+    const val REQUEST_CODE_APP_PERMISSIONS = 3
+    const val REQUEST_CODE_CAMERA_PERMISSIONS = 4
+    const val REQUEST_CODE_STORAGE_PERMISSION = 5
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/Features.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/Features.kt
index 981f6f10548a..839caa0b2882 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/Features.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/Features.kt
@@ -9,12 +9,6 @@ package org.mozilla.focus.utils
  */
 class Features {
     companion object {
-        /**
-         * Swipe-to-refresh: Currently disabled due to various UX issues: #1776
-         */
-        @JvmField
-        val SWIPE_TO_REFRESH: Boolean = false
-
         val SEARCH_TERMS_OR_URL: Boolean = true
     }
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.kt
index 820759f8b30b..37213afe8966 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/IntentUtils.kt
@@ -11,7 +11,6 @@ import androidx.annotation.StringRes
 import androidx.appcompat.app.AlertDialog
 
 import org.mozilla.focus.R
-import org.mozilla.focus.web.IWebView
 
 import java.net.URISyntaxException
 
@@ -30,7 +29,7 @@ object IntentUtils {
      * want to use an external app to open the uri. Ultimately the OS can spy on anything we're
      * doing in the app, so this isn't an actual "bug".
      */
-    fun handleExternalUri(context: Context, webView: IWebView, uri: String): Boolean {
+    fun handleExternalUri(context: Context, uri: String): Boolean {
         // This code is largely based on Fennec's ExternalIntentDuringPrivateBrowsingPromptFragment.java
         val intent = try { Intent.parseUri(uri, 0) } catch (e: URISyntaxException) { return false }
 
@@ -44,7 +43,7 @@ object IntentUtils {
         val matchingActivities = packageManager.queryIntentActivities(intent, 0)
 
         when (matchingActivities.size) {
-            0 -> handleUnsupportedLink(context, webView, intent)
+            0 -> handleUnsupportedLink(context, intent)
             1 -> {
                 val info = matchingActivities[0]
                 val externalAppTitle = info?.loadLabel(packageManager) ?: "(null)"
@@ -66,10 +65,10 @@ object IntentUtils {
         return true
     }
 
-    private fun handleUnsupportedLink(context: Context, webView: IWebView, intent: Intent): Boolean {
+    private fun handleUnsupportedLink(context: Context, intent: Intent): Boolean {
         val fallbackUrl = intent.getStringExtra(EXTRA_BROWSER_FALLBACK_URL)
         if (fallbackUrl != null) {
-            webView.loadUrl(fallbackUrl)
+            // webView.loadUrl(fallbackUrl)
             return true
         }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/Settings.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/Settings.kt
index 2727beed113b..0589f5176a94 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/Settings.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/Settings.kt
@@ -8,16 +8,20 @@ import android.content.Context
 import android.content.SharedPreferences
 import android.content.res.Resources
 import androidx.preference.PreferenceManager
+import mozilla.components.concept.engine.Engine
+import mozilla.components.concept.engine.EngineSession
 import org.mozilla.focus.R
+import org.mozilla.focus.engine.EngineSharedPreferencesListener
 import org.mozilla.focus.fragment.FirstrunFragment
 import org.mozilla.focus.searchsuggestions.SearchSuggestionsPreferences
-import org.mozilla.focus.web.GeckoWebViewProvider
 
 /**
  * A simple wrapper for SharedPreferences that makes reading preference a little bit easier.
  */
 @Suppress("TooManyFunctions") // This class is designed to have a lot of (simple) functions
-class Settings private constructor(context: Context) {
+class Settings private constructor(
+    private val context: Context
+) {
     companion object {
         private var instance: Settings? = null
 
@@ -31,7 +35,56 @@ class Settings private constructor(context: Context) {
         }
     }
 
-    private val preferences: SharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)
+    private val preferencesListener = EngineSharedPreferencesListener(context)
+
+    private val preferences: SharedPreferences = PreferenceManager.getDefaultSharedPreferences(context).apply {
+        registerOnSharedPreferenceChangeListener(preferencesListener)
+    }
+
+    fun createTrackingProtectionPolicy(): EngineSession.TrackingProtectionPolicy {
+        val trackingCategories: MutableList<EngineSession.TrackingProtectionPolicy.TrackingCategory> = mutableListOf()
+
+        if (shouldBlockSocialTrackers()) {
+            trackingCategories.add(EngineSession.TrackingProtectionPolicy.TrackingCategory.SOCIAL)
+        }
+        if (shouldBlockAdTrackers()) {
+            trackingCategories.add(EngineSession.TrackingProtectionPolicy.TrackingCategory.AD)
+        }
+        if (shouldBlockAnalyticTrackers()) {
+            trackingCategories.add(EngineSession.TrackingProtectionPolicy.TrackingCategory.ANALYTICS)
+        }
+        if (shouldBlockOtherTrackers()) {
+            trackingCategories.add(EngineSession.TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)
+        }
+
+        val cookiePolicy = when (shouldBlockCookiesValue()) {
+            context.getString(R.string.preference_privacy_should_block_cookies_yes_option) ->
+                EngineSession.TrackingProtectionPolicy.CookiePolicy.ACCEPT_NONE
+
+            context.getString(R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option) ->
+                EngineSession.TrackingProtectionPolicy.CookiePolicy.ACCEPT_NON_TRACKERS
+
+            context.getString(R.string.preference_privacy_should_block_cookies_third_party_only_option) ->
+                EngineSession.TrackingProtectionPolicy.CookiePolicy.ACCEPT_ONLY_FIRST_PARTY
+
+            else -> EngineSession.TrackingProtectionPolicy.CookiePolicy.ACCEPT_ALL
+        }
+
+        return EngineSession.TrackingProtectionPolicy.select(
+            cookiePolicy = cookiePolicy,
+            trackingCategories = trackingCategories.toTypedArray(),
+            strictSocialTrackingProtection = shouldBlockSocialTrackers()
+        )
+    }
+
+    fun setupSafeBrowsing(engine: Engine) {
+        if (shouldUseSafeBrowsing()) {
+            engine.settings.safeBrowsingPolicy = arrayOf(EngineSession.SafeBrowsingPolicy.RECOMMENDED)
+        } else {
+            engine.settings.safeBrowsingPolicy = arrayOf(EngineSession.SafeBrowsingPolicy.NONE)
+        }
+    }
+
     private val resources: Resources = context.resources
     val hasAddedToHomeScreen: Boolean
         get() = preferences.getBoolean(getPreferenceKey(R.string.has_added_to_home_screen), false)
@@ -72,23 +125,13 @@ class Settings private constructor(context: Context) {
                 false)
 
     fun shouldBlockCookiesValue(): String =
-        if (AppConstants.isGeckoBuild) {
-            preferences.getString(
-                getPreferenceKey(
-                    R.string
-                        .pref_key_performance_enable_cookies
-                ),
-                resources.getString(R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option)
-            )!!
-        } else {
-            preferences.getString(
-                getPreferenceKey(
-                    R.string
-                        .pref_key_performance_enable_cookies
-                ),
-                resources.getString(R.string.preference_privacy_should_block_cookies_no_option)
-            )!!
-        }
+        preferences.getString(
+            getPreferenceKey(
+                R.string
+                    .pref_key_performance_enable_cookies
+            ),
+            resources.getString(R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option)
+        )!!
 
     fun shouldBlockCookies(): Boolean =
             shouldBlockCookiesValue() == resources.getString(
@@ -103,9 +146,6 @@ class Settings private constructor(context: Context) {
     fun shouldShowFirstrun(): Boolean =
             !preferences.getBoolean(FirstrunFragment.FIRSTRUN_PREF, false)
 
-    fun isFirstGeckoRun(): Boolean =
-            preferences.getBoolean(GeckoWebViewProvider.PREF_FIRST_GECKO_RUN, true)
-
     fun shouldUseBiometrics(): Boolean =
             preferences.getBoolean(getPreferenceKey(R.string.pref_key_biometric), false)
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt
index 1439f8784e72..d16912ef2a7f 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt
@@ -14,7 +14,6 @@ import android.content.Intent
 import android.content.pm.PackageManager
 import android.os.Build
 import android.provider.Settings
-import mozilla.components.browser.session.Session
 import mozilla.components.browser.state.state.SessionState
 import org.mozilla.focus.ext.components
 import org.mozilla.focus.locale.Locales
@@ -81,7 +80,7 @@ object SupportUtils {
     }
 
     fun openDefaultBrowserSumoPage(context: Context) {
-        val session = Session(SupportUtils.DEFAULT_BROWSER_URL, source = SessionState.Source.MENU)
+        val session = createTab(SupportUtils.DEFAULT_BROWSER_URL, source = SessionState.Source.MENU)
         context.components.sessionManager.add(session, selected = true)
 
         if (context is Activity) {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/TabUtils.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/TabUtils.kt
new file mode 100644
index 000000000000..7732999d7168
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/TabUtils.kt
@@ -0,0 +1,21 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.utils
+
+import mozilla.components.browser.session.Session
+import mozilla.components.browser.state.state.SessionState
+
+fun createTab(
+    url: String,
+    source: SessionState.Source = SessionState.Source.NONE
+): Session {
+    // Creating a non-private Session as a workaround here. This needs to be an actual private
+    // session before we can land this. With a private session we are currently not able to save
+    // any tracking protection exceptions, see:
+    // https://bugzilla.mozilla.org/show_bug.cgi?id=1644156
+    // As a workaround we are currently removing all data manually, using Engine.clearData(), once
+    // a browsing session ends.
+    return Session(url, source = source, private = false)
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java b/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java
deleted file mode 100644
index 84f3517b2714..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.os.Build;
-import android.os.StrictMode;
-import androidx.annotation.NonNull;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.view.View;
-import android.webkit.CookieManager;
-import android.webkit.WebSettings;
-import android.webkit.WebStorage;
-import android.webkit.WebView;
-
-import org.jetbrains.annotations.NotNull;
-import org.mozilla.focus.R;
-import org.mozilla.focus.utils.Settings;
-import org.mozilla.focus.webview.SystemWebView;
-import org.mozilla.focus.webview.TrackingProtectionWebViewClient;
-
-/**
- * WebViewProvider for creating a WebView based IWebView implementation.
- */
-public class ClassicWebViewProvider implements IWebViewProvider {
-    /**
-     * Preload webview data. This allows the webview implementation to load resources and other data
-     * it might need, in advance of intialising the view (at which time we are probably wanting to
-     * show a website immediately).
-     */
-    public void preload(@NonNull final Context context) {
-        TrackingProtectionWebViewClient.triggerPreload(context);
-    }
-
-    public void performCleanup(@NonNull final Context context) {
-        SystemWebView.Companion.deleteContentFromKnownLocations(context);
-    }
-
-    /**
-     * A cleanup that should occur when a new browser session starts. This might be able to be merged with
-     * {@link #performCleanup(Context)}, but I didn't want to do it now to avoid unforeseen side effects. We can do this
-     * when we rethink our erase strategy: #1472.
-     *
-     * This function must be called before WebView.loadUrl to avoid erasing current session data.
-     */
-    public void performNewBrowserSessionCleanup() {
-        // If the app is closed in certain ways, WebView.cleanup will not get called and we don't clear cookies.
-        CookieManager.getInstance().removeAllCookies(null);
-
-        // We run this on the main thread to guarantee it occurs before loadUrl so we don't erase current session data.
-        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
-
-        // When left open on erase, some pages, like the google search results, will asynchronously write LocalStorage
-        // files to disk after we erase them. To work-around this, we delete this data again when starting a new browser session.
-        WebStorage.getInstance().deleteAllData();
-
-        StrictMode.setThreadPolicy(oldPolicy);
-    }
-
-    @NonNull
-    public View create(@NonNull Context context, AttributeSet attrs) {
-        final SystemWebView webkitView = new SystemWebView(context, attrs);
-        final WebSettings settings = webkitView.getSettings();
-
-        setupView(webkitView);
-        configureDefaultSettings(context, settings);
-        applyAppSettings(context, settings, webkitView);
-
-        return webkitView;
-    }
-
-    private static void setupView(WebView webView) {
-        webView.setVerticalScrollBarEnabled(true);
-        webView.setHorizontalScrollBarEnabled(true);
-    }
-
-    @SuppressLint("SetJavaScriptEnabled") // We explicitly want to enable JavaScript
-    private void configureDefaultSettings(Context context, WebSettings settings) {
-        settings.setJavaScriptEnabled(true);
-
-        // Needs to be enabled to display some HTML5 sites that use local storage
-        settings.setDomStorageEnabled(true);
-
-        // Enabling built in zooming shows the controls by default
-        settings.setBuiltInZoomControls(true);
-
-        // So we hide the controls after enabling zooming
-        settings.setDisplayZoomControls(false);
-
-        // To respect the html viewport:
-        settings.setLoadWithOverviewMode(true);
-
-        // Also increase text size to fill the viewport (this mirrors the behaviour of Firefox,
-        // Chrome does this in the current Chrome Dev, but not Chrome release).
-        settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.TEXT_AUTOSIZING);
-
-        // Disable access to arbitrary local files by webpages - assets can still be loaded
-        // via file:///android_asset/res, so at least error page images won't be blocked.
-        settings.setAllowFileAccess(false);
-        settings.setAllowFileAccessFromFileURLs(false);
-        settings.setAllowUniversalAccessFromFileURLs(false);
-
-        final String appName = context.getResources().getString(R.string.useragent_appname);
-        settings.setUserAgentString(buildUserAgentString(context, settings, appName));
-
-        // Right now I do not know why we should allow loading content from a content provider
-        settings.setAllowContentAccess(false);
-
-        // The default for those settings should be "false" - But we want to be explicit.
-        settings.setAppCacheEnabled(false);
-        settings.setDatabaseEnabled(false);
-        settings.setJavaScriptCanOpenWindowsAutomatically(false);
-
-        // We do not implement the callbacks - So let's disable it.
-        settings.setGeolocationEnabled(false);
-
-        // We do not want to save any data...
-        settings.setSaveFormData(false);
-        //noinspection deprecation - This method is deprecated but let's call it in case WebView implementations still obey it.
-        settings.setSavePassword(false);
-    }
-
-    @Override
-    public void applyAppSettings(@NotNull Context context, @NotNull WebSettings webSettings, @NotNull SystemWebView systemWebView) {
-
-        // Clear the cache so trackers previously loaded are removed
-        systemWebView.clearCache(true);
-
-        // We could consider calling setLoadsImagesAutomatically() here too (This will block images not loaded over the network too)
-        webSettings.setBlockNetworkImage(Settings.getInstance(context).shouldBlockImages());
-        webSettings.setJavaScriptEnabled(!Settings.getInstance(context).shouldBlockJavaScript());
-        CookieManager.getInstance().setAcceptThirdPartyCookies(systemWebView, !Settings.getInstance
-                (context).shouldBlockThirdPartyCookies());
-        CookieManager.getInstance().setAcceptCookie(!Settings.getInstance(context)
-                .shouldBlockCookies());
-    }
-
-    @Override
-    @SuppressLint("SetJavaScriptEnabled") // We explicitly want to enable JavaScript
-    public void disableBlocking(@NotNull WebSettings webSettings, @NotNull SystemWebView systemWebView) {
-        webSettings.setBlockNetworkImage(false);
-        webSettings.setJavaScriptEnabled(true);
-        CookieManager.getInstance().setAcceptThirdPartyCookies(systemWebView, true);
-        CookieManager.getInstance().setAcceptCookie(true);
-    }
-
-    public void requestDesktopSite(@NonNull WebSettings settings) {
-        settings.setUserAgentString(toggleDesktopUA(settings, true));
-        settings.setUseWideViewPort(true);
-    }
-
-    public void requestMobileSite(@NonNull Context context, @NonNull WebSettings settings) {
-        settings.setUserAgentString(toggleDesktopUA(settings, false));
-        settings.setUseWideViewPort(false);
-    }
-
-    /**
-     * Build the browser specific portion of the UA String, based on the webview's existing UA String.
-     */
-    @NonNull
-    public String getUABrowserString(@NonNull final String existingUAString, @NonNull final String focusToken) {
-        // Use the default WebView agent string here for everything after the platform, but insert
-        // Focus in front of Chrome.
-        // E.g. a default webview UA string might be:
-        // Mozilla/5.0 (Linux; Android 7.1.1; Pixel XL Build/NOF26V; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/56.0.2924.87 Mobile Safari/537.36
-        // And we reuse everything from AppleWebKit onwards, except for adding Focus.
-        int start = existingUAString.indexOf("AppleWebKit");
-        if (start == -1) {
-            // I don't know if any devices don't include AppleWebKit, but given the diversity of Android
-            // devices we should have a fallback: we search for the end of the platform String, and
-            // treat the next token as the start:
-            start = existingUAString.indexOf(")") + 2;
-
-            // If this was located at the very end, then there's nothing we can do, so let's just
-            // return focus:
-            if (start >= existingUAString.length()) {
-                return focusToken;
-            }
-        }
-
-        final String[] tokens = existingUAString.substring(start).split(" ");
-
-        for (int i = 0; i < tokens.length; i++) {
-            if (tokens[i].startsWith("Chrome")) {
-                tokens[i] = focusToken + " " + tokens[i];
-
-                return TextUtils.join(" ", tokens);
-            }
-        }
-
-        // If we didn't find a chrome token, we just append the focus token at the end:
-        return TextUtils.join(" ", tokens) + " " + focusToken;
-    }
-
-    private String buildUserAgentString(final Context context, final WebSettings settings, final String appName) {
-        final StringBuilder uaBuilder = new StringBuilder();
-
-        uaBuilder.append("Mozilla/5.0");
-
-        // WebView by default includes "; wv" as part of the platform string, but we're a full browser
-        // so we shouldn't include that.
-        // Most webview based browsers (and chrome), include the device name AND build ID, e.g.
-        // "Pixel XL Build/NOF26V", that seems unnecessary (and not great from a privacy perspective),
-        // so we skip that too.
-        uaBuilder.append(" (Linux; Android ").append(Build.VERSION.RELEASE).append(") ");
-
-        final String existingWebViewUA = settings.getUserAgentString();
-
-        final String appVersion;
-        try {
-            appVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
-        } catch (PackageManager.NameNotFoundException e) {
-            // This should be impossible - we should always be able to get information about ourselves:
-            throw new IllegalStateException("Unable find package details for Focus", e);
-        }
-
-        final String focusToken = appName + "/" + appVersion;
-        uaBuilder.append(getUABrowserString(existingWebViewUA, focusToken));
-
-        return uaBuilder.toString();
-    }
-
-    private static String toggleDesktopUA(final WebSettings settings, final boolean requestDesktop) {
-        final String existingUAString = settings.getUserAgentString();
-        if (requestDesktop) {
-            return existingUAString.replace("Mobile", "eliboM").replace("Android", "diordnA");
-        } else {
-            return existingUAString.replace("eliboM", "Mobile").replace("diordnA", "Android");
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/CleanupSessionObserver.kt b/focus-android/app/src/main/java/org/mozilla/focus/web/CleanupSessionObserver.kt
deleted file mode 100644
index 3280f2b18a62..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/CleanupSessionObserver.kt
+++ /dev/null
@@ -1,25 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web
-
-import android.content.Context
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.session.SessionManager
-import org.mozilla.focus.ext.components
-
-class CleanupSessionObserver(
-    private val context: Context
-) : SessionManager.Observer {
-
-    override fun onSessionRemoved(session: Session) {
-        if (context.components.sessionManager.sessions.isEmpty()) {
-            WebViewProvider.performCleanup(context)
-        }
-    }
-
-    override fun onAllSessionsRemoved() {
-        WebViewProvider.performCleanup(context)
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt b/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt
deleted file mode 100644
index 80314d182a10..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/GeckoWebViewProvider.kt
+++ /dev/null
@@ -1,788 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web
-
-import android.app.Activity
-import android.content.Context
-import android.content.SharedPreferences
-import android.net.Uri
-import android.os.Bundle
-import android.os.Environment
-import android.os.Parcelable
-import android.text.TextUtils
-import android.util.AttributeSet
-import android.util.Log
-import android.view.View
-import android.webkit.WebSettings
-import androidx.preference.PreferenceManager
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import mozilla.components.browser.errorpages.ErrorPages
-import mozilla.components.browser.errorpages.ErrorType
-import mozilla.components.browser.session.Session
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_DISPOSITION
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_LENGTH
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_TYPE
-import mozilla.components.lib.crash.handler.CrashHandlerService
-import mozilla.components.support.utils.DownloadUtils
-import org.mozilla.focus.R
-import org.mozilla.focus.browser.LocalizedContent
-import org.mozilla.focus.ext.savedGeckoSession
-import org.mozilla.focus.ext.savedWebViewState
-import org.mozilla.focus.gecko.GeckoViewPrompt
-import org.mozilla.focus.gecko.NestedGeckoView
-import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
-import org.mozilla.focus.utils.IntentUtils
-import org.mozilla.focus.utils.Settings
-import org.mozilla.focus.utils.UrlUtils
-import org.mozilla.focus.webview.SystemWebView
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoRuntimeSettings
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.NavigationDelegate
-import org.mozilla.geckoview.GeckoSessionSettings
-import org.mozilla.geckoview.SessionFinder
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebResponse
-import kotlin.coroutines.CoroutineContext
-
-/**
- * WebViewProvider implementation for creating a Gecko based implementation of IWebView.
- */
-@Suppress("TooManyFunctions")
-class GeckoWebViewProvider : IWebViewProvider {
-    override fun preload(context: Context) {
-        sendTelemetryEventOnSwitchToGecko(context)
-        createGeckoRuntime(context)
-    }
-
-    private fun sendTelemetryEventOnSwitchToGecko(context: Context) {
-        val settings = Settings.getInstance(context)
-        if (!settings.shouldShowFirstrun() && settings.isFirstGeckoRun()) {
-            PreferenceManager.getDefaultSharedPreferences(context)
-                .edit().putBoolean(PREF_FIRST_GECKO_RUN, false).apply()
-            Log.d(javaClass.simpleName, "Sending change to Gecko ping")
-            TelemetryWrapper.changeToGeckoEngineEvent()
-        }
-    }
-
-    override fun create(context: Context, attributeSet: AttributeSet?): View {
-        return GeckoWebView(context, attributeSet)
-    }
-
-    override fun performCleanup(context: Context) {
-        // Nothing: a WebKit work-around.
-    }
-
-    override fun performNewBrowserSessionCleanup() {
-        // Nothing: a WebKit work-around.
-    }
-
-    private fun createGeckoRuntime(context: Context) {
-        if (geckoRuntime == null) {
-            val runtimeSettingsBuilder = GeckoRuntimeSettings.Builder()
-            runtimeSettingsBuilder.contentBlocking(ContentBlocking.Settings.Builder()
-                    .safeBrowsing(ContentBlocking.SafeBrowsing.MALWARE or ContentBlocking.SafeBrowsing.PHISHING)
-                    .build())
-            val contentBlockingBuilder = ContentBlocking.Settings.Builder()
-            if (Settings.getInstance(context).shouldUseSafeBrowsing()) {
-                contentBlockingBuilder.safeBrowsing(ContentBlocking.SafeBrowsing.MALWARE or
-                        ContentBlocking.SafeBrowsing.PHISHING)
-            }
-            runtimeSettingsBuilder.contentBlocking(contentBlockingBuilder.build())
-            runtimeSettingsBuilder.crashHandler(CrashHandlerService::class.java)
-            runtimeSettingsBuilder.consoleOutput(false)
-            runtimeSettingsBuilder.debugLogging(false)
-
-            geckoRuntime =
-                    GeckoRuntime.create(context.applicationContext, runtimeSettingsBuilder.build())
-        }
-    }
-
-    override fun requestMobileSite(context: Context, webSettings: WebSettings) {
-    }
-
-    override fun requestDesktopSite(webSettings: WebSettings) {
-    }
-
-    override fun applyAppSettings(
-        context: Context,
-        webSettings: WebSettings,
-        systemWebView: SystemWebView
-    ) {
-    }
-
-    override fun disableBlocking(webSettings: WebSettings, systemWebView: SystemWebView) {
-    }
-
-    override fun getUABrowserString(existingUAString: String, focusToken: String): String {
-        return ""
-    }
-
-    @Suppress("LargeClass", "TooManyFunctions")
-    class GeckoWebView(context: Context, attrs: AttributeSet?) :
-        NestedGeckoView(context, attrs),
-        IWebView,
-        SharedPreferences.OnSharedPreferenceChangeListener,
-        CoroutineScope {
-        private var callback: IWebView.Callback? = null
-        private var findListener: IFindListener? = null
-        private var currentUrl: String = ABOUT_BLANK
-        private var canGoBack: Boolean = false
-        private var canGoForward: Boolean = false
-        private var isSecure: Boolean = false
-        private var geckoSession: GeckoSession
-        private var webViewTitle: String? = null
-        private var isLoadingInternalUrl = false
-        private lateinit var finder: SessionFinder
-        private var restored = false
-        private var job = Job()
-        override val coroutineContext: CoroutineContext
-            get() = job + Dispatchers.Main
-
-        init {
-            PreferenceManager.getDefaultSharedPreferences(context)
-                .registerOnSharedPreferenceChangeListener(this)
-            geckoSession = createGeckoSession()
-            applySettingsAndSetDelegates()
-            geckoSession.open(geckoRuntime!!)
-            setSession(geckoSession)
-        }
-
-        private fun applySettingsAndSetDelegates() {
-            applyAppSettings()
-            updateBlocking()
-
-            geckoSession.contentDelegate = createContentDelegate()
-            geckoSession.progressDelegate = createProgressDelegate()
-            geckoSession.navigationDelegate = createNavigationDelegate()
-            geckoSession.contentBlockingDelegate = createTrackingProtectionDelegate()
-            geckoSession.promptDelegate = createPromptDelegate()
-            finder = geckoSession.finder
-            finder.displayFlags = GeckoSession.FINDER_DISPLAY_HIGHLIGHT_ALL
-        }
-
-        private fun createGeckoSession(): GeckoSession {
-            val builder = GeckoSessionSettings.Builder()
-            builder.usePrivateMode(true)
-            builder.suspendMediaWhenInactive(true)
-            return GeckoSession(builder.build())
-        }
-
-        override fun setCallback(callback: IWebView.Callback?) {
-            this.callback = callback
-        }
-
-        override fun onPause() {
-            job.cancel()
-        }
-
-        override fun goBack() {
-            geckoSession.goBack()
-        }
-
-        override fun goForward() {
-            geckoSession.goForward()
-        }
-
-        override fun reload() {
-            geckoSession.reload()
-        }
-
-        override fun destroy() {
-        }
-
-        override fun onResume() {
-            if (job.isCancelled) {
-                job = Job()
-            }
-        }
-
-        override fun stopLoading() {
-            geckoSession.stop()
-            callback?.onPageFinished(isSecure)
-        }
-
-        override fun getUrl(): String? {
-            return currentUrl
-        }
-
-        override fun loadUrl(url: String) {
-            currentUrl = url
-            geckoSession.loadUri(currentUrl)
-        }
-
-        override fun cleanup() {
-            if (geckoSession.isOpen) {
-                geckoSession.close()
-            }
-        }
-
-        override fun setBlockingEnabled(enabled: Boolean) {
-            geckoSession.settings.useTrackingProtection = enabled
-            if (enabled) {
-                updateBlocking()
-                applyAppSettings()
-            } else {
-                geckoRuntime!!.settings.javaScriptEnabled = true
-                geckoRuntime!!.settings.webFontsEnabled = true
-                geckoRuntime!!.settings.contentBlocking.cookieBehavior = ContentBlocking.CookieBehavior.ACCEPT_ALL
-            }
-            callback?.onBlockingStateChanged(enabled)
-        }
-
-        override fun setRequestDesktop(shouldRequestDesktop: Boolean) {
-            geckoSession.settings.userAgentMode =
-                    if (shouldRequestDesktop) GeckoSessionSettings.USER_AGENT_MODE_DESKTOP
-                    else GeckoSessionSettings.USER_AGENT_MODE_MOBILE
-            geckoSession.settings.viewportMode =
-                    if (shouldRequestDesktop) GeckoSessionSettings.VIEWPORT_MODE_DESKTOP
-                    else GeckoSessionSettings.VIEWPORT_MODE_MOBILE
-            callback?.onRequestDesktopStateChanged(shouldRequestDesktop)
-        }
-
-        @Suppress("ComplexMethod")
-        override fun onSharedPreferenceChanged(
-            sharedPreferences: SharedPreferences,
-            key: String
-        ) {
-            when (key) {
-                context.getString(R.string.pref_key_privacy_block_social),
-                context.getString(R.string.pref_key_privacy_block_ads),
-                context.getString(R.string.pref_key_privacy_block_analytics),
-                context.getString(R.string.pref_key_privacy_block_other) -> updateBlocking()
-                context.getString(R.string.pref_key_performance_block_javascript)
-                -> geckoRuntime!!.settings.javaScriptEnabled =
-                        !Settings.getInstance(context).shouldBlockJavaScript()
-                context.getString(R.string.pref_key_performance_block_webfonts)
-                -> geckoRuntime!!.settings.webFontsEnabled =
-                        !Settings.getInstance(context).shouldBlockWebFonts()
-                context.getString(R.string.pref_key_remote_debugging) ->
-                    geckoRuntime!!.settings.remoteDebuggingEnabled =
-                            Settings.getInstance(context).shouldEnableRemoteDebugging()
-                context.getString(R.string.pref_key_performance_enable_cookies) -> {
-                    updateCookieSettings()
-                }
-                context.getString(R.string.pref_key_safe_browsing) -> {
-                    val shouldUseSafeBrowsing =
-                        Settings.getInstance(context).shouldUseSafeBrowsing()
-                    var cats = geckoRuntime!!.settings.contentBlocking.safeBrowsingCategories
-                    if (shouldUseSafeBrowsing) {
-                        cats = cats or ContentBlocking.SafeBrowsing.MALWARE or
-                                ContentBlocking.SafeBrowsing.PHISHING
-                    } else {
-                        cats = cats and ContentBlocking.SafeBrowsing.MALWARE.inv() and
-                                ContentBlocking.SafeBrowsing.PHISHING.inv()
-                    }
-                    geckoRuntime!!.settings.contentBlocking.setSafeBrowsing(cats)
-                }
-                else -> return
-            }
-            reload()
-        }
-
-        private fun applyAppSettings() {
-            geckoRuntime!!.settings.javaScriptEnabled =
-                    !Settings.getInstance(context).shouldBlockJavaScript()
-            geckoRuntime!!.settings.webFontsEnabled =
-                    !Settings.getInstance(context).shouldBlockWebFonts()
-            geckoRuntime!!.settings.remoteDebuggingEnabled = false
-            updateCookieSettings()
-        }
-
-        private fun updateCookieSettings() {
-            geckoRuntime!!.settings.contentBlocking.cookieBehavior =
-                    when (Settings.getInstance(context).shouldBlockCookiesValue()) {
-                        context.getString(
-                            R.string.preference_privacy_should_block_cookies_yes_option
-                        ) ->
-                            ContentBlocking.CookieBehavior.ACCEPT_NONE
-                        context.getString(
-                            R.string.preference_privacy_should_block_cookies_third_party_tracker_cookies_option
-                        ) ->
-                            ContentBlocking.CookieBehavior.ACCEPT_NON_TRACKERS
-                        context.getString(
-                            R.string.preference_privacy_should_block_cookies_third_party_only_option
-                        ) ->
-                            ContentBlocking.CookieBehavior.ACCEPT_FIRST_PARTY
-                        else -> ContentBlocking.CookieBehavior.ACCEPT_ALL
-                    }
-        }
-
-        private fun updateBlocking() {
-            val settings = Settings.getInstance(context)
-
-            var categories = geckoRuntime!!.settings.contentBlocking.antiTrackingCategories
-            if (settings.shouldBlockSocialTrackers()) {
-                categories = categories or ContentBlocking.AntiTracking.SOCIAL
-            } else {
-                categories = categories and ContentBlocking.AntiTracking.SOCIAL.inv()
-            }
-            if (settings.shouldBlockAdTrackers()) {
-                categories = categories or ContentBlocking.AntiTracking.AD
-            } else {
-                categories = categories and ContentBlocking.AntiTracking.AD.inv()
-            }
-            if (settings.shouldBlockAnalyticTrackers()) {
-                categories = categories or ContentBlocking.AntiTracking.ANALYTIC
-            } else {
-                categories = categories and ContentBlocking.AntiTracking.ANALYTIC.inv()
-            }
-            if (settings.shouldBlockOtherTrackers()) {
-                categories = categories or ContentBlocking.AntiTracking.CONTENT
-            } else {
-                categories = categories and ContentBlocking.AntiTracking.CONTENT.inv()
-            }
-
-            geckoRuntime!!.settings.contentBlocking.setAntiTracking(categories)
-        }
-
-        @Suppress("ComplexMethod", "ReturnCount")
-        private fun createContentDelegate(): GeckoSession.ContentDelegate {
-            return object : GeckoSession.ContentDelegate {
-                override fun onTitleChange(session: GeckoSession, title: String?) {
-                    webViewTitle = title
-                    callback?.onTitleChanged(title)
-                }
-
-                override fun onFullScreen(session: GeckoSession, fullScreen: Boolean) {
-                    if (fullScreen) {
-                        callback?.onEnterFullScreen({ geckoSession.exitFullScreen() }, null)
-                    } else {
-                        callback?.onExitFullScreen()
-                    }
-                }
-
-                override fun onContextMenu(
-                    session: GeckoSession,
-                    screenX: Int,
-                    screenY: Int,
-                    contextElement: GeckoSession.ContentDelegate.ContextElement
-                ) {
-                    val elementSrc = contextElement.srcUri
-                    val uri = contextElement.linkUri
-                    val elementType = contextElement.type
-                    if (elementSrc != null && uri != null &&
-                        elementType == GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE
-                    ) {
-                        callback?.onLongPress(IWebView.HitTarget(true, uri, true, elementSrc))
-                    } else if (elementSrc != null &&
-                        elementType == GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE) {
-                        callback?.onLongPress(IWebView.HitTarget(false, null, true, elementSrc))
-                    } else if (uri != null) {
-                        callback?.onLongPress(IWebView.HitTarget(true, uri, false, null))
-                    }
-                }
-
-                override fun onExternalResponse(session: GeckoSession, response: WebResponse) {
-                    if (!AppConstants.supportsDownloadingFiles()) {
-                        return
-                    }
-
-                    val scheme = Uri.parse(response.uri).scheme
-                    if (scheme == null || scheme != "http" && scheme != "https") {
-                        // We are ignoring everything that is not http or https. This is a limitation of
-                        // Android's download manager. There's no reason to show a download dialog for
-                        // something we can't download anyways.
-                        Log.w(TAG, "Ignoring download from non http(s) URL: " + response.uri)
-                        return
-                    }
-
-                    val contentType = response.headers[CONTENT_TYPE]?.trim()
-                    val contentLength = response.headers[CONTENT_LENGTH]?.trim()?.toLong() ?: 0
-                    val contentDisposition = response.headers[CONTENT_DISPOSITION]?.trim()
-                    val url = response.uri
-                    val fileName = DownloadUtils.guessFileName(
-                        contentDisposition,
-                        destinationDirectory = null,
-                        url = url,
-                        mimeType = contentType
-                    )
-
-                    val download = Download(
-                        response.uri, USER_AGENT,
-                        fileName, contentType, contentLength,
-                        Environment.DIRECTORY_DOWNLOADS, fileName
-                    )
-                    callback?.onDownloadStart(download)
-                }
-
-                override fun onCrash(session: GeckoSession) {
-                    geckoSession.close()
-                    geckoSession = createGeckoSession()
-                    applySettingsAndSetDelegates()
-                    geckoSession.open(geckoRuntime!!)
-                    setSession(geckoSession)
-                    currentUrl = ABOUT_BLANK
-                    geckoSession.loadUri(currentUrl)
-                }
-
-                override fun onKill(session: GeckoSession) {
-                    // Ensure the session that was killed is the same session we act on.
-                    geckoSession = session
-                    geckoSession.open(geckoRuntime!!)
-                    geckoSession.loadUri(currentUrl)
-                }
-
-                override fun onFocusRequest(geckoSession: GeckoSession) {}
-
-                override fun onCloseRequest(geckoSession: GeckoSession) {
-                    // Ignore this callback
-                }
-
-                override fun onFirstComposite(geckoSession: GeckoSession) {}
-            }
-        }
-
-        @Suppress("ComplexMethod")
-        private fun createProgressDelegate(): GeckoSession.ProgressDelegate {
-            return object : GeckoSession.ProgressDelegate {
-                override fun onProgressChange(session: GeckoSession, progress: Int) {
-                    if (progress == PROGRESS_100) {
-                        if (UrlUtils.isLocalizedContent(url)) {
-                            // When the url is a localized content, then the page is secure
-                            isSecure = true
-                        }
-                        callback?.onPageFinished(isSecure)
-                    } else {
-                        callback?.onProgress(progress)
-                    }
-                }
-
-                override fun onPageStart(session: GeckoSession, url: String) {
-                    callback?.onPageStarted(url)
-                    callback?.resetBlockedTrackers()
-                    isSecure = false
-                }
-
-                override fun onPageStop(session: GeckoSession, success: Boolean) {
-                    if (success) {
-                        if (UrlUtils.isLocalizedContent(url)) {
-                            // When the url is a localized content, then the page is secure
-                            isSecure = true
-                        }
-
-                        callback?.onPageFinished(isSecure)
-                    }
-                }
-
-                override fun onSecurityChange(
-                    session: GeckoSession,
-                    securityInfo: GeckoSession.ProgressDelegate.SecurityInformation
-                ) {
-                    isSecure = securityInfo.isSecure
-
-                    if (UrlUtils.isLocalizedContent(url)) {
-                        // When the url is a localized content, then the page is secure
-                        isSecure = true
-                    }
-
-                    callback?.onSecurityChanged(
-                        isSecure,
-                        securityInfo.host,
-                        securityInfo.certificate?.issuerDN?.name
-                    )
-                }
-            }
-        }
-
-        @Suppress("ComplexMethod")
-        private fun createNavigationDelegate(): GeckoSession.NavigationDelegate {
-            return object : GeckoSession.NavigationDelegate {
-                override fun onLoadRequest(
-                    session: GeckoSession,
-                    request: NavigationDelegate.LoadRequest
-                ): GeckoResult<AllowOrDeny>? {
-                    val uri = Uri.parse(request.uri)
-
-                    val complete = when {
-                        request.target == GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW -> {
-                            geckoSession.loadUri(request.uri)
-                            AllowOrDeny.DENY
-                        }
-                        LocalizedContent.handleInternalContent(
-                            request.uri,
-                            this@GeckoWebView,
-                            context
-                        ) -> {
-                            AllowOrDeny.DENY
-                        }
-                        !UrlUtils.isSupportedProtocol(uri.scheme) && callback != null &&
-                                IntentUtils.handleExternalUri(
-                                    context,
-                                    this@GeckoWebView,
-                                    request.uri
-                                ) -> {
-                            AllowOrDeny.DENY
-                        }
-                        else -> {
-                            callback?.onRequest(!request.isRedirect)
-                            AllowOrDeny.ALLOW
-                        }
-                    }
-
-                    return GeckoResult.fromValue(complete)
-                }
-
-                override fun onLoadError(
-                    session: GeckoSession,
-                    uri: String?,
-                    webRequestError: WebRequestError
-                ): GeckoResult<String> {
-                    val errorPage = ErrorPages.createUrlEncodedErrorPage(
-                        context,
-                        geckoErrorToErrorType(webRequestError.code),
-                        uri
-                    )
-                    return GeckoResult.fromValue(errorPage)
-                }
-
-                override fun onNewSession(
-                    session: GeckoSession,
-                    uri: String
-                ): GeckoResult<GeckoSession>? {
-                    // Prevent new sessions to be created from onLoadRequest
-                    throw IllegalStateException()
-                }
-
-                override fun onLocationChange(session: GeckoSession, url: String?) {
-                    if (url == "about:blank") {
-                        // When we get about:blank from GV, our session observer had already updated
-                        // the toolbar to correct url and we incorrectly show the page url.
-                        // See also https://github.com/mozilla-mobile/android-components/issues/403
-                        Log.i(javaClass.simpleName, "Ignoring about:blank in onLocationChange")
-                        return
-                    }
-                    var desiredUrl = url
-                    // Save internal data: urls we should override to present focus:about, focus:rights
-                    if (isLoadingInternalUrl) {
-                        if (currentUrl == LocalizedContent.URL_ABOUT) {
-                            internalAboutData = desiredUrl
-                        } else if (currentUrl == LocalizedContent.URL_RIGHTS) {
-                            internalRightsData = desiredUrl
-                        }
-                        isLoadingInternalUrl = false
-                        desiredUrl = currentUrl
-                    }
-
-                    // Check for internal data: urls to instead present focus:rights, focus:about
-                    if (!TextUtils.isEmpty(internalAboutData) && internalAboutData == desiredUrl) {
-                        desiredUrl = LocalizedContent.URL_ABOUT
-                    } else if (!TextUtils.isEmpty(internalRightsData) && internalRightsData == desiredUrl) {
-                        desiredUrl = LocalizedContent.URL_RIGHTS
-                    }
-
-                    currentUrl = desiredUrl!!
-                    callback?.onURLChanged(desiredUrl)
-                }
-
-                override fun onCanGoBack(session: GeckoSession, canGoBack: Boolean) {
-                    this@GeckoWebView.canGoBack = canGoBack
-                }
-
-                override fun onCanGoForward(session: GeckoSession, canGoForward: Boolean) {
-                    this@GeckoWebView.canGoForward = canGoForward
-                }
-            }
-        }
-
-        private fun createTrackingProtectionDelegate(): ContentBlocking.Delegate {
-            return object : ContentBlocking.Delegate {
-                override fun onContentBlocked(session: GeckoSession, event: ContentBlocking.BlockEvent) {
-                    callback?.countBlockedTracker()
-                }
-            }
-        }
-
-        private fun createPromptDelegate(): GeckoSession.PromptDelegate {
-            return GeckoViewPrompt(context as Activity)
-        }
-
-        override fun canGoForward(): Boolean {
-            return canGoForward
-        }
-
-        override fun canGoBack(): Boolean {
-            return canGoBack
-        }
-
-        override fun restoreWebViewState(session: Session) {
-            val stateData = session.savedWebViewState!!
-            val savedSession = session.savedGeckoSession!!
-
-            if (geckoSession != savedSession && !restored) {
-                // Tab changed, we need to close the default session and restore our saved session
-                geckoSession.close()
-
-                geckoSession = savedSession
-                canGoBack = stateData.getBoolean(CAN_GO_BACK, false)
-                canGoForward = stateData.getBoolean(CAN_GO_FORWARD, false)
-                isSecure = stateData.getBoolean(IS_SECURE, false)
-                webViewTitle = stateData.getString(WEBVIEW_TITLE, null)
-                currentUrl = stateData.getString(CURRENT_URL, ABOUT_BLANK)
-                applySettingsAndSetDelegates()
-                if (!geckoSession.isOpen) {
-                    geckoSession.open(geckoRuntime!!)
-                }
-                setSession(geckoSession)
-            } else if (restored) {
-                // App was backgrounded and restored;
-                geckoSession = savedSession
-                setSession(geckoSession)
-                canGoBack = stateData.getBoolean(CAN_GO_BACK, false)
-                canGoForward = stateData.getBoolean(CAN_GO_FORWARD, false)
-                isSecure = stateData.getBoolean(IS_SECURE, false)
-                webViewTitle = stateData.getString(WEBVIEW_TITLE, null)
-                currentUrl = stateData.getString(CURRENT_URL, ABOUT_BLANK)
-                applySettingsAndSetDelegates()
-                restored = false
-            }
-        }
-
-        override fun onRestoreInstanceState(state: Parcelable?) {
-            if (geckoSession.isOpen) {
-                geckoSession.close()
-            }
-            restored = true
-            super.onRestoreInstanceState(state)
-        }
-
-        override fun saveWebViewState(session: Session) {
-            val sessionBundle = Bundle()
-            sessionBundle.putBoolean(CAN_GO_BACK, canGoBack)
-            sessionBundle.putBoolean(CAN_GO_FORWARD, canGoForward)
-            sessionBundle.putBoolean(IS_SECURE, isSecure)
-            sessionBundle.putString(WEBVIEW_TITLE, webViewTitle)
-            sessionBundle.putString(CURRENT_URL, currentUrl)
-            session.savedWebViewState = sessionBundle
-            session.savedGeckoSession = geckoSession
-        }
-
-        override fun getTitle(): String? {
-            return webViewTitle
-        }
-
-        override fun exitFullscreen() {
-            geckoSession.exitFullScreen()
-        }
-
-        override fun findAllAsync(find: String) {
-            finder.find(find, 0).then({ result ->
-                if (result != null) {
-                    findListener?.onFindResultReceived(result.current, result.total, true)
-                }
-                GeckoResult<Void>()
-            }, { _ ->
-                GeckoResult<Void>()
-            })
-        }
-
-        override fun findNext(forward: Boolean) {
-            finder.find(null, if (forward) 0 else GeckoSession.FINDER_FIND_BACKWARDS)
-                .then({ result ->
-                    if (result != null) {
-                        findListener?.onFindResultReceived(result.current, result.total, true)
-                    }
-                    GeckoResult<Void>()
-                }, { _ ->
-                    GeckoResult<Void>()
-                })
-        }
-
-        override fun clearMatches() {
-            finder.clear()
-        }
-
-        override fun setFindListener(findListener: IFindListener) {
-            this.findListener = findListener
-        }
-
-        override fun loadData(
-            baseURL: String,
-            data: String,
-            mimeType: String,
-            encoding: String,
-            historyURL: String
-        ) {
-            isLoadingInternalUrl = historyURL == LocalizedContent.URL_RIGHTS || historyURL ==
-                    LocalizedContent.URL_ABOUT
-            geckoSession.load(GeckoSession.Loader().data(data.toByteArray(Charsets.UTF_8), mimeType))
-            currentUrl = historyURL
-        }
-
-        override fun releaseGeckoSession() {
-            releaseSession()
-        }
-
-        override fun onDetachedFromWindow() {
-            PreferenceManager.getDefaultSharedPreferences(context)
-                .unregisterOnSharedPreferenceChangeListener(this)
-            releaseSession()
-            super.onDetachedFromWindow()
-        }
-
-        companion object {
-            private const val TAG = "GeckoWebView"
-        }
-    }
-
-    companion object {
-        @Volatile
-        private var geckoRuntime: GeckoRuntime? = null
-        private var internalAboutData: String? = null
-        private var internalRightsData: String? = null
-        private const val USER_AGENT =
-            "Mozilla/5.0 (Android 8.1.0; Mobile; rv:60.0) Gecko/60.0 Firefox/60.0"
-        const val PREF_FIRST_GECKO_RUN: String = "first_gecko_run"
-        const val PROGRESS_100 = 100
-        const val CAN_GO_BACK = "canGoBack"
-        const val CAN_GO_FORWARD = "canGoForward"
-        const val IS_SECURE = "isSecure"
-        const val WEBVIEW_TITLE = "webViewTitle"
-        const val CURRENT_URL = "currentUrl"
-        const val ABOUT_BLANK = "about:blank"
-
-        /**
-         * Provides an ErrorType corresponding to the error code provided.
-         */
-        @Suppress("ComplexMethod")
-        internal fun geckoErrorToErrorType(errorCode: Int) =
-            when (errorCode) {
-                WebRequestError.ERROR_UNKNOWN -> ErrorType.UNKNOWN
-                WebRequestError.ERROR_SECURITY_SSL -> ErrorType.ERROR_SECURITY_SSL
-                WebRequestError.ERROR_SECURITY_BAD_CERT -> ErrorType.ERROR_SECURITY_BAD_CERT
-                WebRequestError.ERROR_NET_INTERRUPT -> ErrorType.ERROR_NET_INTERRUPT
-                WebRequestError.ERROR_NET_TIMEOUT -> ErrorType.ERROR_NET_TIMEOUT
-                WebRequestError.ERROR_CONNECTION_REFUSED -> ErrorType.ERROR_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_SOCKET_TYPE -> ErrorType.ERROR_UNKNOWN_SOCKET_TYPE
-                WebRequestError.ERROR_REDIRECT_LOOP -> ErrorType.ERROR_REDIRECT_LOOP
-                WebRequestError.ERROR_OFFLINE -> ErrorType.ERROR_OFFLINE
-                WebRequestError.ERROR_PORT_BLOCKED -> ErrorType.ERROR_PORT_BLOCKED
-                WebRequestError.ERROR_NET_RESET -> ErrorType.ERROR_NET_RESET
-                WebRequestError.ERROR_UNSAFE_CONTENT_TYPE -> ErrorType.ERROR_UNSAFE_CONTENT_TYPE
-                WebRequestError.ERROR_CORRUPTED_CONTENT -> ErrorType.ERROR_CORRUPTED_CONTENT
-                WebRequestError.ERROR_CONTENT_CRASHED -> ErrorType.ERROR_CONTENT_CRASHED
-                WebRequestError.ERROR_INVALID_CONTENT_ENCODING -> ErrorType.ERROR_INVALID_CONTENT_ENCODING
-                WebRequestError.ERROR_UNKNOWN_HOST -> ErrorType.ERROR_UNKNOWN_HOST
-                WebRequestError.ERROR_MALFORMED_URI -> ErrorType.ERROR_MALFORMED_URI
-                WebRequestError.ERROR_UNKNOWN_PROTOCOL -> ErrorType.ERROR_UNKNOWN_PROTOCOL
-                WebRequestError.ERROR_FILE_NOT_FOUND -> ErrorType.ERROR_FILE_NOT_FOUND
-                WebRequestError.ERROR_FILE_ACCESS_DENIED -> ErrorType.ERROR_FILE_ACCESS_DENIED
-                WebRequestError.ERROR_PROXY_CONNECTION_REFUSED -> ErrorType.ERROR_PROXY_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_PROXY_HOST -> ErrorType.ERROR_UNKNOWN_PROXY_HOST
-                WebRequestError.ERROR_SAFEBROWSING_MALWARE_URI -> ErrorType.ERROR_SAFEBROWSING_MALWARE_URI
-                WebRequestError.ERROR_SAFEBROWSING_UNWANTED_URI -> ErrorType.ERROR_SAFEBROWSING_UNWANTED_URI
-                WebRequestError.ERROR_SAFEBROWSING_HARMFUL_URI -> ErrorType.ERROR_SAFEBROWSING_HARMFUL_URI
-                WebRequestError.ERROR_SAFEBROWSING_PHISHING_URI -> ErrorType.ERROR_SAFEBROWSING_PHISHING_URI
-                else -> ErrorType.UNKNOWN
-            }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java b/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java
deleted file mode 100644
index 78d285382027..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebView.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import android.view.View;
-
-import mozilla.components.browser.session.Session;
-
-public interface IWebView {
-    class HitTarget {
-        public final boolean isLink;
-        public final String linkURL;
-
-        public final boolean isImage;
-        public final String imageURL;
-
-        public HitTarget(final boolean isLink, final String linkURL, final boolean isImage, final String imageURL) {
-            if (isLink && linkURL == null) {
-                throw new IllegalStateException("link hittarget must contain URL");
-            }
-
-            if (isImage && imageURL == null) {
-                throw new IllegalStateException("image hittarget must contain URL");
-            }
-
-            this.isLink = isLink;
-            this.linkURL = linkURL;
-            this.isImage = isImage;
-            this.imageURL = imageURL;
-        }
-    }
-
-    interface Callback {
-        void onPageStarted(String url);
-
-        void onPageFinished(boolean isSecure);
-
-        void onSecurityChanged(boolean isSecure, String host, String organization);
-
-        void onProgress(int progress);
-
-        void onURLChanged(final String url);
-
-        void onTitleChanged(final String title);
-
-        void onRequest(final boolean isTriggeredByUserGesture);
-
-        void onDownloadStart(Download download);
-
-        void onLongPress(final HitTarget hitTarget);
-
-        /**
-         * Notify the host application that the current page has entered full screen mode.
-         *
-         * The callback needs to be invoked to request the page to exit full screen mode.
-         *
-         * Some IWebView implementations may pass a custom View which contains the web contents in
-         * full screen mode.
-         */
-        void onEnterFullScreen(@NonNull  FullscreenCallback callback, @Nullable View view);
-
-        /**
-         * Notify the host application that the current page has exited full screen mode.
-         *
-         * If a View was passed when the application entered full screen mode then this view must
-         * be hidden now.
-         */
-        void onExitFullScreen();
-
-        void countBlockedTracker();
-
-        void resetBlockedTrackers();
-
-        void onBlockingStateChanged(boolean isBlockingEnabled);
-
-        void onHttpAuthRequest(@NonNull HttpAuthCallback callback, String host, String realm);
-
-        void onRequestDesktopStateChanged(boolean shouldRequestDesktop);
-    }
-
-    interface FullscreenCallback {
-        void fullScreenExited();
-    }
-
-    interface HttpAuthCallback {
-        void proceed(String username, String password);
-
-        void cancel();
-    }
-
-    /**
-     * Enable/Disable content blocking for this session (Only the blockers that are enabled in the app's settings will be turned on/off).
-     */
-    void setBlockingEnabled(boolean enabled);
-
-    void setRequestDesktop(boolean shouldRequestDesktop);
-
-    void setCallback(Callback callback);
-
-    void onPause();
-
-    void onResume();
-
-    void destroy();
-
-    void reload();
-
-    void stopLoading();
-
-    String getUrl();
-
-    void loadUrl(String url);
-
-    void cleanup();
-
-    void goForward();
-
-    void goBack();
-
-    boolean canGoForward();
-
-    boolean canGoBack();
-
-    void restoreWebViewState(Session session);
-
-    void saveWebViewState(@NonNull Session session);
-
-    void exitFullscreen();
-
-    void findAllAsync(String find);
-
-    void findNext(boolean forward);
-
-    void clearMatches();
-
-    void setFindListener(IFindListener findListener);
-
-    void loadData(String baseURL, String data, String mimeType, String encoding, String historyURL);
-
-    void releaseGeckoSession();
-
-    /**
-     * Get the title of the currently displayed website.
-     */
-    String getTitle();
-}
\ No newline at end of file
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebViewProvider.kt b/focus-android/app/src/main/java/org/mozilla/focus/web/IWebViewProvider.kt
deleted file mode 100644
index 2c8af16b5baa..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/IWebViewProvider.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web
-
-import android.content.Context
-import android.util.AttributeSet
-import android.view.View
-import android.webkit.WebSettings
-import org.mozilla.focus.webview.SystemWebView
-
-interface IWebViewProvider {
-    fun preload(context: Context)
-    fun create(context: Context, attributeSet: AttributeSet?): View
-    fun performCleanup(context: Context)
-    fun performNewBrowserSessionCleanup()
-    fun requestMobileSite(context: Context, webSettings: WebSettings)
-    fun requestDesktopSite(webSettings: WebSettings)
-    fun applyAppSettings(context: Context, webSettings: WebSettings, systemWebView: SystemWebView)
-    fun disableBlocking(webSettings: WebSettings, systemWebView: SystemWebView)
-    fun getUABrowserString(existingUAString: String, focusToken: String): String
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/WebViewProvider.kt b/focus-android/app/src/main/java/org/mozilla/focus/web/WebViewProvider.kt
deleted file mode 100644
index 054b6efbc833..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/WebViewProvider.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.web
-
-import android.content.Context
-import android.util.AttributeSet
-import android.view.View
-import android.webkit.WebSettings
-import org.mozilla.focus.webview.SystemWebView
-
-object WebViewProvider : IWebViewProvider {
-
-    var engine: IWebViewProvider? = GeckoWebViewProvider()
-
-    override fun preload(context: Context) {
-        engine!!.preload(context)
-    }
-
-    override fun create(context: Context, attributeSet: AttributeSet?): View {
-        return engine!!.create(context, attributeSet)
-    }
-
-    override fun performCleanup(context: Context) {
-        engine!!.performCleanup(context)
-    }
-
-    override fun performNewBrowserSessionCleanup() {
-        engine!!.performNewBrowserSessionCleanup()
-    }
-
-    override fun requestMobileSite(context: Context, webSettings: WebSettings) {
-        engine!!.requestMobileSite(context, webSettings)
-    }
-
-    override fun requestDesktopSite(webSettings: WebSettings) {
-        engine!!.requestDesktopSite(webSettings)
-    }
-
-    override fun getUABrowserString(existingUAString: String, focusToken: String): String {
-        return engine!!.getUABrowserString(existingUAString, focusToken)
-    }
-
-    override fun applyAppSettings(context: Context, webSettings: WebSettings, systemWebView: SystemWebView) {
-        engine!!.applyAppSettings(context, webSettings, systemWebView)
-    }
-
-    override fun disableBlocking(webSettings: WebSettings, systemWebView: SystemWebView) {
-        engine!!.disableBlocking(webSettings, systemWebView)
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/FocusWebViewClient.java b/focus-android/app/src/main/java/org/mozilla/focus/webview/FocusWebViewClient.java
deleted file mode 100644
index 3971ec71771d..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/webview/FocusWebViewClient.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.webview;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.net.http.SslCertificate;
-import android.net.http.SslError;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.webkit.SslErrorHandler;
-import android.webkit.WebResourceRequest;
-import android.webkit.WebResourceResponse;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-
-import org.mozilla.focus.browser.LocalizedContent;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.IntentUtils;
-import org.mozilla.focus.utils.UrlUtils;
-import org.mozilla.focus.web.IWebView;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import static android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO;
-import static android.view.View.IMPORTANT_FOR_ACCESSIBILITY_YES;
-
-/**
- * WebViewClient layer that handles browser specific WebViewClient functionality, such as error pages
- * and external URL handling.
- */
-/* package */ class FocusWebViewClient extends TrackingProtectionWebViewClient {
-    private static final String ERROR_PROTOCOL = "error:";
-    private static final String STATE_KEY_URL = "client_last_url";
-    private static final String STATE_KEY_CERTIFICATE = "client_last_certificate";
-
-    private String restoredUrl;
-    private SslCertificate restoredCertificate;
-    private boolean errorReceived;
-    private boolean shouldReadURL = true; // Flag to ensure URL is only read once per load
-
-    /* package */ FocusWebViewClient(Context context) {
-        super(context);
-    }
-
-    /**
-     * Always ensure the following is wrapped in an anonymous function before execution.
-     * (We don't wrap here, since this code might be run as part of a larger function, see
-     * e.g. onLoadResource().)
-     */
-    private static final String CLEAR_VISITED_CSS =
-            "var nSheets = document.styleSheets.length;" +
-            "for (s=0; s < nSheets; s++) {" +
-            "  var stylesheet = document.styleSheets[s];" +
-            "  var nRules = stylesheet.cssRules ? stylesheet.cssRules.length : 0;" +
-            // rules need to be removed by index. That modifies the whole list - it's easiest
-            // to therefore process the list from the back, so that we don't need to care about
-            // indexes changing after deletion (all indexes before the removed item are unchanged,
-            // so by moving towards the start we'll always process all previously unprocessed items -
-            // moving in the other direction we'd need to remember to process a given index
-            // again which is more complicated).
-            "  for (i = nRules - 1; i >= 0; i--) {" +
-            "    var cssRule = stylesheet.cssRules[i];" +
-            // Depending on style type, there might be no selector
-            "    if (cssRule.selectorText && cssRule.selectorText.includes(':visited')) {" +
-            "      var tokens = cssRule.selectorText.split(',');" +
-            "      var j = tokens.length;" +
-            "      while (j--) {" +
-            "        if (tokens[j].includes(':visited')) {" +
-            "          tokens.splice(j, 1);" +
-            "        }" +
-            "      }" +
-            "      if (tokens.length == 0) {" +
-            "        stylesheet.deleteRule(i);" +
-            "      } else {" +
-            "        cssRule.selectorText = tokens.join(',');" +
-            "      }" +
-            "    }" +
-            "  }" +
-            "}";
-
-    @Override
-    public void onLoadResource(WebView view, String url) {
-        // We can't access the webview during shouldInterceptRequest(), however onLoadResource()
-        // is called on the UI thread so we're allowed to do this now:
-        view.evaluateJavascript(
-                "(function() {" +
-
-                "function cleanupVisited() {" +
-                CLEAR_VISITED_CSS +
-                "}" +
-
-                // Add an onLoad() listener so that we run the cleanup script every time
-                // a <link>'d css stylesheet is loaded:
-                "var links = document.getElementsByTagName('link');" +
-                "for (i = 0; i < links.length; i++) {" +
-                "  link = links[i];" +
-                "  if (link.rel == 'stylesheet') {" +
-                "    link.addEventListener('load', cleanupVisited, false);" +
-                "  }" +
-                "}" +
-
-                "})();",
-
-                null);
-
-        super.onLoadResource(view, url);
-    }
-
-    @Override
-    public WebResourceResponse shouldInterceptRequest(WebView view, final WebResourceRequest request) {
-        // Only update the user visible URL if:
-        // 1. The purported site URL has actually been requested
-        // 2. And it's being loaded for the main frame (and not a fake/hidden/iframe request)
-        // Note also: shouldInterceptRequest() runs on a background thread, so we can't actually
-        // query WebView.getURL().
-        // We update the URL when loading has finished too (redirects can happen after a request has been
-        // made in which case we don't get shouldInterceptRequest with the final URL), but this
-        // allows us to update the URL during loading.
-        if (request.isForMainFrame()) {
-
-            // WebView will always add a trailing / to the request URL, but currentPageURL may or may
-            // not have a trailing URL (usually no trailing / when a link is entered via UrlInputFragment),
-            // hence we do a somewhat convoluted test:
-            final String requestURL = request.getUrl().toString();
-            final String currentURL = currentPageURL;
-
-            if (UrlUtils.urlsMatchExceptForTrailingSlash(currentURL, requestURL)) {
-                view.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (callback != null) {
-                            callback.onURLChanged(currentURL);
-                        }
-                    }
-                });
-            }
-
-            if (callback != null) {
-                callback.onRequest(request.hasGesture());
-            }
-        }
-
-        return super.shouldInterceptRequest(view, request);
-    }
-
-    @Override
-    public void onPageStarted(WebView view, String url, Bitmap favicon) {
-
-        /* Temporarily disable TalkBack on WebView so it doesn't grab the focus before we can
-        read out the URL. */
-        view.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
-
-        if (errorReceived) {
-            // When dealing with error pages, WebView sometimes sends onPageStarted()
-            // without a matching onPageFinished(). We hack around that by using
-            // a flag to ignore the first onPageStarted() after onReceivedError() has
-            // been called. (The usual chain is: onPageStarted(url), onReceivedError(url),
-            // onPageFinished(url), onPageStarted(url), finally and only sometimes: onPageFinished().
-            // Since the final onPageFinished isn't guaranteed (and we know we're showing an error
-            // page already), we don't need to send the onPageStarted() callback a second time anyway.
-            errorReceived = false;
-        } else if (callback != null) {
-            callback.onPageStarted(url);
-
-            if (shouldReadURL) {
-                view.announceForAccessibility("Loading " + url);
-                shouldReadURL = false;
-            }
-        }
-
-        // Enable TalkBack again for WebView now that we've announced the URL
-        view.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
-
-        super.onPageStarted(view, url, favicon);
-    }
-
-    /* package */ void saveState(WebView view, Bundle bundle) {
-        final SslCertificate certificate = view.getCertificate();
-        if (certificate != null) {
-            bundle.putString(STATE_KEY_URL, view.getUrl());
-            bundle.putBundle(STATE_KEY_CERTIFICATE, SslCertificate.saveState(certificate));
-        }
-    }
-
-    /* package */ void restoreState(Bundle bundle) {
-        if (bundle != null && bundle.containsKey(STATE_KEY_CERTIFICATE)) {
-            restoredUrl = bundle.getString(STATE_KEY_URL);
-            restoredCertificate = SslCertificate.restoreState(bundle.getBundle("client_last_certificate"));
-        }
-    }
-
-    @Override
-    public void onPageFinished(WebView view, final String url) {
-        SslCertificate certificate = view.getCertificate();
-        shouldReadURL = true;
-
-        if (!TextUtils.isEmpty(restoredUrl)) {
-            if (restoredUrl.equals(url) && certificate == null) {
-                // We just restored the previous state. Let's re-use the certificate we restored.
-                // The reason for that is that WebView doesn't restore the certificate itself.
-                // Without restoring the certificate manually we'd lose the certificate when
-                // switching tabs or restoring a previous session for other reasons.
-                certificate = restoredCertificate;
-            } else {
-                // The URL has changed since we restored the last state. Let's just clear all
-                // restored data because we do not need it anymore.
-                restoredUrl = null;
-                restoredCertificate = null;
-            }
-        }
-
-        if (callback != null) {
-            // The page is secure when the url is a localized content or when the certificate isn't null
-            final boolean isSecure = certificate != null || UrlUtils.isLocalizedContent(view.getUrl());
-
-            callback.onPageFinished(isSecure);
-
-            String host = null;
-            try {
-                host = new URI(url).getHost();
-            } catch (URISyntaxException e) {
-                e.printStackTrace();
-            }
-            callback.onSecurityChanged(isSecure, host, (certificate != null) ? certificate.getIssuedBy().getOName() : null);
-            // The URL which is supplied in onPageFinished() could be fake (see #301), but webview's
-            // URL is always correct _except_ for error pages
-            final String viewURL = view.getUrl();
-            if (!UrlUtils.isInternalErrorURL(viewURL) && viewURL != null) {
-                callback.onURLChanged(viewURL);
-            }
-        }
-        super.onPageFinished(view, url);
-
-        view.evaluateJavascript(
-                "(function() {" +
-
-                CLEAR_VISITED_CSS +
-
-                "})();",
-
-                null);
-    }
-
-    @Override
-    public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        // If this is an internal URL like focus:about then we load the content ourselves here.
-        if (LocalizedContent.handleInternalContent(url, (IWebView) view, view.getContext())) {
-            return true;
-        }
-
-        // Allow pages to blank themselves by loading about:blank. While it's a little incorrect to let pages
-        // access our internal URLs, Chrome allows loads to about:blank and, to ensure our behavior conforms
-        // to the behavior that most of the web is developed against, we do too.
-        if (url.equals("about:blank")) {
-            return false;
-        }
-
-        // shouldOverrideUrlLoading() is called for both the main frame, and iframes.
-        // That can get problematic if an iframe tries to load an unsupported URL.
-        // We then try to either handle that URL (ask to open relevant app), or extract
-        // a fallback URL from the intent (or worst case fall back to an error page). In the
-        // latter 2 cases, we explicitly open the fallback/error page in the main view.
-        // Websites probably shouldn't use unsupported URLs in iframes, but we do need to
-        // be careful to handle all valid schemes here to avoid redirecting due to such an iframe
-        // (e.g. we don't want to redirect to a data: URI just because an iframe shows such
-        // a URI).
-        // (The API 24+ version of shouldOverrideUrlLoading() lets us determine whether
-        // the request is for the main frame, and if it's not we could then completely
-        // skip the external URL handling.)
-        final Uri uri = Uri.parse(url);
-        return !UrlUtils.isSupportedProtocol(uri.getScheme()) && callback != null && IntentUtils.INSTANCE.handleExternalUri(view.getContext(), (IWebView) view, url) || super.shouldOverrideUrlLoading(view, url);
-
-    }
-
-    @Override
-    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
-        handler.cancel();
-
-        if (callback != null) {
-            callback.onSecurityChanged(error.getCertificate() != null, null, (error.getCertificate() != null) ? error.getCertificate().getIssuedBy().getOName() : null);
-        }
-        // WebView can try to load the favicon for a bad page when you set a new URL. If we then
-        // loadErrorPage() again, WebView tries to load the favicon again. We end up in onReceivedSSlError()
-        // again, and we get an infinite loop of reloads (we also erroneously show the favicon URL
-        // in the toolbar, but that's less noticeable). Hence we check whether this error is from
-        // the desired page, or a page resource:
-        if (error.getUrl().equals(currentPageURL)) {
-            TelemetryWrapper.sslErrorEvent(true, error);
-            ErrorPage.loadErrorPage(view, error.getUrl(), WebViewClient.ERROR_FAILED_SSL_HANDSHAKE);
-        } else {
-            TelemetryWrapper.sslErrorEvent(false, error);
-        }
-    }
-
-    @Override
-    public void onReceivedError(final WebView webView, int errorCode, final String description, String failingUrl) {
-        errorReceived = true;
-
-        // This is a hack: onReceivedError(WebView, WebResourceRequest, WebResourceError) is API 23+ only,
-        // - the WebResourceRequest would let us know if the error affects the main frame or not. As a workaround
-        // we just check whether the failing URL is the current URL, which is enough to detect an error
-        // in the main frame.
-
-        // WebView swallows odd pages and only sends an error (i.e. it doesn't go through the usual
-        // shouldOverrideUrlLoading), so we need to handle special pages here:
-        // about: urls are even more odd: webview doesn't tell us _anything_, hence the use of
-        // a different prefix:
-        if (failingUrl.startsWith(ERROR_PROTOCOL)) {
-            // format: error:<error_code>
-            final int errorCodePosition = ERROR_PROTOCOL.length();
-            final String errorCodeString = failingUrl.substring(errorCodePosition);
-
-            int desiredErrorCode;
-            try {
-                desiredErrorCode = Integer.parseInt(errorCodeString);
-
-                if (!ErrorPage.supportsErrorCode(desiredErrorCode)) {
-                    // I don't think there's any good way of showing an error if there's an error
-                    // in requesting an error page?
-                    desiredErrorCode = WebViewClient.ERROR_BAD_URL;
-                }
-            } catch (final NumberFormatException e) {
-                desiredErrorCode = WebViewClient.ERROR_BAD_URL;
-            }
-            ErrorPage.loadErrorPage(webView, failingUrl, desiredErrorCode);
-            return;
-        }
-
-
-        // The API 23+ version also return a *slightly* more usable description, via WebResourceError.getError();
-        // e.g.. "There was a network error.", whereas this version provides things like "net::ERR_NAME_NOT_RESOLVED"
-        if (failingUrl.equals(currentPageURL) &&
-                ErrorPage.supportsErrorCode(errorCode)) {
-            ErrorPage.loadErrorPage(webView, currentPageURL, errorCode);
-            return;
-        }
-
-        super.onReceivedError(webView, errorCode, description, failingUrl);
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/LinkHandler.java b/focus-android/app/src/main/java/org/mozilla/focus/webview/LinkHandler.java
deleted file mode 100644
index 8338bf8a3997..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/webview/LinkHandler.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.webview;
-
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import androidx.annotation.Nullable;
-import android.view.View;
-import android.webkit.WebView;
-
-import org.mozilla.focus.web.IWebView;
-
-/* package */ class LinkHandler implements View.OnLongClickListener {
-    private final WebView webView;
-    private @Nullable
-    IWebView.Callback callback = null;
-
-    public LinkHandler(final WebView webView) {
-        this.webView = webView;
-    }
-
-    public void setCallback(final @Nullable IWebView.Callback callback) {
-        this.callback = callback;
-    }
-
-    @Override
-    public boolean onLongClick(View v) {
-        if (callback == null) {
-            return false;
-        }
-
-        final WebView.HitTestResult hitTestResult = webView.getHitTestResult();
-
-        switch (hitTestResult.getType()) {
-            case WebView.HitTestResult.SRC_ANCHOR_TYPE:
-                final String linkURL = hitTestResult.getExtra();
-                callback.onLongPress(new IWebView.HitTarget(true, linkURL, false, null));
-                return true;
-
-            case WebView.HitTestResult.IMAGE_TYPE:
-                final String imageURL = hitTestResult.getExtra();
-                callback.onLongPress(new IWebView.HitTarget(false, null, true, imageURL));
-                return true;
-
-            case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
-                // hitTestResult.getExtra() contains only the image URL, and not the link
-                // URL. Internally, WebView's HitTestData contains both, but they only
-                // make it available via requestFocusNodeHref...
-                final Message message = new Message();
-                message.setTarget(new Handler() {
-                    @Override
-                    public void handleMessage(Message msg) {
-                        final Bundle data = msg.getData();
-                        final String url = data.getString("url");
-                        final String src = data.getString("src");
-
-                        if (url == null || src == null) {
-                            throw new IllegalStateException("WebView did not supply url or src for image link");
-                        }
-
-                        if (callback != null) {
-                            callback.onLongPress(new IWebView.HitTarget(true, url, true, src));
-                        }
-                    }
-                });
-
-                webView.requestFocusNodeHref(message);
-                return true;
-
-            default:
-                return false;
-        }
-    }
-}
\ No newline at end of file
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt b/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt
deleted file mode 100644
index 6a542235ab13..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt
+++ /dev/null
@@ -1,325 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.webview
-
-import android.content.Context
-import android.content.SharedPreferences
-import android.net.Uri
-import android.os.Build
-import android.os.Bundle
-import android.os.Environment
-import androidx.annotation.VisibleForTesting
-import android.util.AttributeSet
-import android.util.Log
-import android.util.SparseArray
-import android.view.View
-import android.view.autofill.AutofillValue
-import android.view.inputmethod.EditorInfo
-import android.view.inputmethod.InputConnection
-import android.webkit.CookieManager
-import android.webkit.DownloadListener
-import android.webkit.WebChromeClient
-import android.webkit.WebStorage
-import android.webkit.WebView
-import android.webkit.WebViewDatabase
-import androidx.preference.PreferenceManager
-import mozilla.components.browser.session.Session
-import mozilla.components.support.utils.ThreadUtils
-import org.mozilla.focus.BuildConfig
-import org.mozilla.focus.ext.savedWebViewState
-import org.mozilla.focus.telemetry.TelemetryWrapper
-import org.mozilla.focus.utils.AppConstants
-import org.mozilla.focus.utils.FileUtils
-import org.mozilla.focus.utils.UrlUtils
-import org.mozilla.focus.utils.ViewUtils
-import org.mozilla.focus.web.Download
-import org.mozilla.focus.web.IFindListener
-import org.mozilla.focus.web.IWebView
-import org.mozilla.focus.web.WebViewProvider
-import java.util.HashMap
-
-@Suppress("TooManyFunctions")
-class SystemWebView(context: Context, attrs: AttributeSet) : NestedWebView(context, attrs), IWebView,
-    SharedPreferences.OnSharedPreferenceChangeListener {
-
-    private var callback: IWebView.Callback? = null
-    private val client: FocusWebViewClient = FocusWebViewClient(getContext().applicationContext)
-    private val linkHandler: LinkHandler
-
-    init {
-
-        webViewClient = client
-        webChromeClient = createWebChromeClient()
-        setDownloadListener(createDownloadListener())
-
-        if (BuildConfig.DEBUG) {
-            WebView.setWebContentsDebuggingEnabled(true)
-        }
-
-        isLongClickable = true
-
-        linkHandler = LinkHandler(this)
-        setOnLongClickListener(linkHandler)
-    }
-
-    @VisibleForTesting
-    fun getCallback(): IWebView.Callback? {
-        return callback
-    }
-
-    override fun onAttachedToWindow() {
-        super.onAttachedToWindow()
-
-        PreferenceManager.getDefaultSharedPreferences(context).registerOnSharedPreferenceChangeListener(this)
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            TelemetryAutofillCallback.register(context)
-        }
-    }
-
-    override fun onDetachedFromWindow() {
-        super.onDetachedFromWindow()
-
-        PreferenceManager.getDefaultSharedPreferences(context).unregisterOnSharedPreferenceChangeListener(this)
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            TelemetryAutofillCallback.unregister(context)
-        }
-    }
-
-    override fun onCreateInputConnection(outAttrs: EditorInfo): InputConnection? {
-        val connection: InputConnection? = super.onCreateInputConnection(outAttrs)
-        outAttrs.imeOptions = outAttrs.imeOptions or ViewUtils.IME_FLAG_NO_PERSONALIZED_LEARNING
-        return connection
-    }
-
-    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences, key: String) {
-        WebViewProvider.applyAppSettings(context, settings, this)
-        reload()
-    }
-
-    override fun onPause() {
-        super.onPause()
-        pauseTimers()
-    }
-
-    override fun onResume() {
-        super.onResume()
-        resumeTimers()
-    }
-
-    override fun restoreWebViewState(session: Session) {
-        val stateData = session.savedWebViewState
-
-        val backForwardList = if (stateData != null)
-            super.restoreState(stateData)
-        else
-            null
-
-        val desiredURL = session.url
-
-        client.restoreState(stateData)
-        client.notifyCurrentURL(desiredURL)
-
-        // Pages are only added to the back/forward list when loading finishes. If a new page is
-        // loading when the Activity is paused/killed, then that page won't be in the list,
-        // and needs to be restored separately to the history list. We detect this by checking
-        // whether the last fully loaded page (getCurrentItem()) matches the last page that the
-        // WebView was actively loading (which was retrieved during onSaveInstanceState():
-        // WebView.getUrl() always returns the currently loading or loaded page).
-        // If the app is paused/killed before the initial page finished loading, then the entire
-        // list will be null - so we need to additionally check whether the list even exists.
-
-        if (backForwardList != null && backForwardList.currentItem!!.url == desiredURL) {
-            // restoreState doesn't actually load the current page, it just restores navigation history,
-            // so we also need to explicitly reload in this case:
-            reload()
-        } else {
-            loadUrl(desiredURL)
-        }
-    }
-
-    override fun saveWebViewState(session: Session) {
-        // We store the actual state into another bundle that we will keep in memory as long as this
-        // browsing session is active. The data that WebView stores in this bundle is too large for
-        // Android to save and restore as part of the state bundle.
-        val stateData = Bundle()
-
-        super.saveState(stateData)
-        client.saveState(this, stateData)
-
-        session.savedWebViewState = stateData
-    }
-
-    override fun setBlockingEnabled(enabled: Boolean) {
-        client.isBlockingEnabled = enabled
-        if (enabled) {
-            WebViewProvider.applyAppSettings(context, settings, this)
-        } else {
-            WebViewProvider.disableBlocking(settings, this)
-        }
-
-        if (callback != null) {
-            callback!!.onBlockingStateChanged(enabled)
-        }
-    }
-
-    override fun setRequestDesktop(shouldRequestDesktop: Boolean) {
-        if (shouldRequestDesktop) {
-            WebViewProvider.requestDesktopSite(settings)
-        } else {
-            WebViewProvider.requestMobileSite(context, settings)
-        }
-
-        if (callback != null) {
-            callback!!.onRequestDesktopStateChanged(shouldRequestDesktop)
-        }
-    }
-
-    override fun setCallback(callback: IWebView.Callback?) {
-        this.callback = callback
-        client.setCallback(callback)
-        linkHandler.setCallback(callback)
-    }
-
-    override fun setFindListener(findListener: IFindListener) {
-        this.setFindListener(findListener as WebView.FindListener)
-    }
-
-    override fun loadUrl(url: String?) {
-        // We need to check external URL handling here - shouldOverrideUrlLoading() is only
-        // called by webview when clicking on a link, and not when opening a new page for the
-        // first time using loadUrl().
-        @Suppress("DEPRECATION")
-        if (!client.shouldOverrideUrlLoading(this, url)) {
-            val additionalHeaders = HashMap<String, String>()
-            additionalHeaders["X-Requested-With"] = ""
-
-            super.loadUrl(url, additionalHeaders)
-        }
-
-        client.notifyCurrentURL(url)
-    }
-
-    override fun exitFullscreen() {}
-
-    override fun loadData(baseURL: String, data: String, mimeType: String, encoding: String, historyURL: String) {
-        loadDataWithBaseURL(baseURL, data, mimeType, encoding, historyURL)
-    }
-
-    override fun destroy() {
-        super.destroy()
-
-        // WebView might save data to disk once it gets destroyed. In this case our cleanup call
-        // might not have been able to see this data. Let's do it again.
-        deleteContentFromKnownLocations(context)
-    }
-
-    override fun cleanup() {
-        clearFormData()
-        clearHistory()
-        clearMatches()
-        clearSslPreferences()
-        clearCache(true)
-
-        // We don't care about the callback - we just want to make sure cookies are gone
-        CookieManager.getInstance().removeAllCookies(null)
-
-        WebStorage.getInstance().deleteAllData()
-
-        val webViewDatabase = WebViewDatabase.getInstance(context)
-        // It isn't entirely clear how this differs from WebView.clearFormData()
-        @Suppress("DEPRECATION")
-        webViewDatabase.clearFormData()
-        webViewDatabase.clearHttpAuthUsernamePassword()
-
-        deleteContentFromKnownLocations(context)
-    }
-
-    override fun autofill(values: SparseArray<AutofillValue>) {
-        super.autofill(values)
-
-        TelemetryWrapper.autofillPerformedEvent()
-    }
-
-    private fun createWebChromeClient(): WebChromeClient {
-        return object : WebChromeClient() {
-            override fun onProgressChanged(view: WebView, newProgress: Int) {
-                if (callback != null) {
-                    // This is the earliest point where we might be able to confirm a redirected
-                    // URL: we don't necessarily get a shouldInterceptRequest() after a redirect,
-                    // so we can only check the updated url in onProgressChanges(), or in onPageFinished()
-                    // (which is even later).
-                    val viewURL = view.url
-                    if (!UrlUtils.isInternalErrorURL(viewURL) && viewURL != null) {
-                        callback!!.onURLChanged(viewURL)
-                        callback!!.onTitleChanged(title)
-                    }
-                    callback!!.onProgress(newProgress)
-                }
-            }
-
-            override fun onShowCustomView(view: View, webviewCallback: WebChromeClient.CustomViewCallback) {
-                val fullscreenCallback = IWebView.FullscreenCallback { webviewCallback.onCustomViewHidden() }
-
-                callback?.onEnterFullScreen(fullscreenCallback, view)
-            }
-
-            override fun onHideCustomView() {
-                callback?.onExitFullScreen()
-            }
-        }
-    }
-
-    override fun releaseGeckoSession() {
-        // Do nothing, only for GV
-    }
-
-    private fun createDownloadListener(): DownloadListener {
-        return DownloadListener { url, userAgent, contentDisposition, mimetype, contentLength ->
-            if (!AppConstants.supportsDownloadingFiles()) {
-                return@DownloadListener
-            }
-
-            val scheme = Uri.parse(url).scheme
-            if (scheme == null || scheme != "http" && scheme != "https") {
-                // We are ignoring everything that is not http or https. This is a limitation of
-                // Android's download manager. There's no reason to show a download dialog for
-                // something we can't download anyways.
-                Log.w(TAG, "Ignoring download from non http(s) URL: $url")
-                return@DownloadListener
-            }
-
-            if (callback != null) {
-                val download = Download(
-                    url,
-                    userAgent,
-                    contentDisposition,
-                    mimetype,
-                    contentLength,
-                    Environment.DIRECTORY_DOWNLOADS,
-                    null
-                )
-                callback!!.onDownloadStart(download)
-            }
-        }
-    }
-
-    companion object {
-        private const val TAG = "WebkitView"
-
-        fun deleteContentFromKnownLocations(context: Context) {
-            ThreadUtils.postToBackgroundThread(Runnable {
-                // We call all methods on WebView to delete data. But some traces still remain
-                // on disk. This will wipe the whole webview directory.
-                FileUtils.deleteWebViewDirectory(context)
-
-                // WebView stores some files in the cache directory. We do not use it ourselves
-                // so let's truncate it.
-                FileUtils.truncateCacheDirectory(context)
-            })
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/TrackingProtectionWebViewClient.java b/focus-android/app/src/main/java/org/mozilla/focus/webview/TrackingProtectionWebViewClient.java
deleted file mode 100644
index abbb0d755a41..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/webview/TrackingProtectionWebViewClient.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.webview;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.os.AsyncTask;
-import androidx.annotation.WorkerThread;
-import android.webkit.HttpAuthHandler;
-import android.webkit.WebResourceRequest;
-import android.webkit.WebResourceResponse;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.web.IWebView;
-import org.mozilla.focus.webview.matcher.UrlMatcher;
-
-public class TrackingProtectionWebViewClient extends WebViewClient {
-    private static volatile UrlMatcher MATCHER;
-
-    public static void triggerPreload(final Context context) {
-        // Only trigger loading if MATCHER is null. (If it's null, MATCHER could already be loading,
-        // but we don't have any way of being certain - and there's no real harm since we're not
-        // blocking anything else.)
-        if (MATCHER == null) {
-            new AsyncTask<Void, Void, Void>() {
-                @Override
-                protected Void doInBackground(Void... voids) {
-                    // We don't need the result here - we just want to trigger loading
-                    getMatcher(context);
-                    return null;
-                }
-            }.execute();
-        }
-    }
-
-    @WorkerThread private static synchronized UrlMatcher getMatcher(final Context context) {
-        if (MATCHER == null) {
-            MATCHER = UrlMatcher.loadMatcher(context, R.raw.blocklist, new int[] { R.raw.google_mapping }, R.raw.entitylist);
-        }
-        return MATCHER;
-    }
-
-    private boolean blockingEnabled;
-    /* package */ String currentPageURL;
-    protected IWebView.Callback callback;
-
-    /* package */ TrackingProtectionWebViewClient(final Context context) {
-        // Hopefully we have loaded background data already. We call triggerPreload() to try to trigger
-        // background loading of the lists as early as possible.
-        triggerPreload(context);
-
-        this.blockingEnabled = true;
-    }
-
-    public void setCallback(IWebView.Callback callback) {
-        this.callback = callback;
-    }
-
-    public void setBlockingEnabled(boolean enabled) {
-        this.blockingEnabled = enabled;
-    }
-
-    public boolean isBlockingEnabled() {
-        return blockingEnabled;
-    }
-
-    @Override
-    public WebResourceResponse shouldInterceptRequest(final WebView view, final WebResourceRequest request) {
-        if (!blockingEnabled) {
-            return super.shouldInterceptRequest(view, request);
-        }
-
-        final Uri resourceUri = request.getUrl();
-
-        // shouldInterceptRequest() might be called _before_ onPageStarted or shouldOverrideUrlLoading
-        // are called (this happens when the webview is first shown). However we are notified of the URL
-        // via notifyCurrentURL in that case.
-        final String scheme = resourceUri.getScheme();
-
-        if (!request.isForMainFrame() &&
-                !scheme.equals("http") && !scheme.equals("https")) {
-            // Block any malformed non-http(s) URIs. WebView will already ignore things like market: URLs,
-            // but not in all cases (malformed market: URIs, such as market:://... will still end up here).
-            // (Note: data: URIs are automatically handled by WebView, and won't end up here either.)
-            // file:// URIs are disabled separately by setting WebSettings.setAllowFileAccess()
-            return new WebResourceResponse(null, null, null);
-        }
-
-        // WebView always requests a favicon, even though it won't be used anywhere. This check
-        // isn't able to block all favicons (some of them will be loaded using <link rel="shortcut icon">
-        // with a custom URL which we can't match or detect), but reduces the amount of unnecessary
-        // favicon loading that's performed.
-        final String path = resourceUri.getPath();
-        if (path != null && path.endsWith("/favicon.ico")) {
-            return new WebResourceResponse(null, null, null);
-        }
-
-        final UrlMatcher matcher = getMatcher(view.getContext());
-
-        // Don't block the main frame from being loaded. This also protects against cases where we
-        // open a link that redirects to another app (e.g. to the play store).
-        if ((!request.isForMainFrame()) &&
-                currentPageURL != null &&
-                matcher.matches(resourceUri, Uri.parse(currentPageURL))) {
-                // Bandaid for issue #26: currentPageUrl can still be null, and needs to be investigated further.
-            if (callback != null) {
-                callback.countBlockedTracker();
-            }
-            return new WebResourceResponse(null, null, null);
-        }
-
-        return super.shouldInterceptRequest(view, request);
-    }
-
-    /**
-     * Notify that the user has requested a new URL. This MUST be called before loading a new URL
-     * into the webview: sometimes content requests might begin before the WebView itself notifies
-     * the WebViewClient via onpageStarted/shouldOverrideUrlLoading. If we don't know the current page
-     * URL then the entitylist whitelists might not work if we're trying to load an explicitly whitelisted
-     * page.
-     */
-    public void notifyCurrentURL(final String url) {
-        currentPageURL = url;
-    }
-
-    @Override
-    public void onPageStarted(WebView view, String url, Bitmap favicon) {
-        if (callback != null) {
-            callback.resetBlockedTrackers();
-        }
-
-        currentPageURL = url;
-
-        super.onPageStarted(view, url, favicon);
-    }
-
-    @Override
-    public void onReceivedHttpAuthRequest(WebView view, final HttpAuthHandler handler, String host, String realm) {
-        final IWebView.HttpAuthCallback httpAuthCallback = new IWebView.HttpAuthCallback() {
-            @Override
-            public void proceed(String username, String password) {
-                handler.proceed(username, password);
-            }
-
-            @Override
-            public void cancel() {
-                handler.cancel();
-            }
-        };
-
-        if (callback != null) {
-            callback.onHttpAuthRequest(httpAuthCallback, host, realm);
-        }
-    }
-}
diff --git a/focus-android/app/src/main/res/anim/erase_animation.xml b/focus-android/app/src/main/res/anim/erase_animation.xml
index e4d11ab6c818..120df0a9b6f2 100644
--- a/focus-android/app/src/main/res/anim/erase_animation.xml
+++ b/focus-android/app/src/main/res/anim/erase_animation.xml
@@ -17,8 +17,4 @@
         android:fromYDelta="0"
         android:toYDelta="100%p"
         android:startOffset="@integer/erase_animation_translate_offset" />
-    <alpha
-        android:duration="@integer/erase_animation_alpha_duration"
-        android:fromAlpha="1.0"
-        android:toAlpha="0.0" />
 </set>
diff --git a/focus-android/app/src/main/res/anim/erase_animation_gv.xml b/focus-android/app/src/main/res/anim/erase_animation_gv.xml
deleted file mode 100644
index 120df0a9b6f2..000000000000
--- a/focus-android/app/src/main/res/anim/erase_animation_gv.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-<set xmlns:android="http://schemas.android.com/apk/res/android"
-    android:interpolator="@android:anim/accelerate_interpolator">
-    <scale
-        android:duration="@integer/erase_animation_scale_duration"
-        android:fromXScale="100%p"
-        android:toXScale="95%p"
-        android:fromYScale="100%p"
-        android:toYScale="95%p"
-        android:pivotX="50%p"
-        android:pivotY="50%p" />
-    <translate
-        android:duration="@integer/erase_animation_translate_duration"
-        android:fromYDelta="0"
-        android:toYDelta="100%p"
-        android:startOffset="@integer/erase_animation_translate_offset" />
-</set>
diff --git a/focus-android/app/src/main/res/layout/find_in_page.xml b/focus-android/app/src/main/res/layout/find_in_page.xml
deleted file mode 100644
index b46fdfbafc73..000000000000
--- a/focus-android/app/src/main/res/layout/find_in_page.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    android:id="@+id/constraintLayout"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:background="@drawable/find_in_page_background"
-    android:clickable="true"
-    android:focusable="true"
-    android:orientation="horizontal">
-
-    <EditText
-        android:id="@+id/queryText"
-        android:layout_width="0dp"
-        android:layout_height="48dp"
-        android:layout_marginStart="12dp"
-        android:background="@android:color/transparent"
-        android:ems="10"
-        android:gravity="center_vertical"
-        android:hint="@string/find_in_page_input"
-        android:imeOptions="flagNoPersonalizedLearning"
-        android:inputType="textNoSuggestions"
-        android:lines="1"
-        android:maxLines="1"
-        android:textCursorDrawable="@drawable/cursor"
-        android:textSize="14sp"
-        app:layout_constraintEnd_toStartOf="@id/resultText"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintBottom_toBottomOf="parent"
-        android:importantForAutofill="no" />
-
-    <TextView
-        android:id="@+id/resultText"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginEnd="16dp"
-        android:layout_marginStart="16dp"
-        android:alpha="0.6"
-        android:textColor="@color/photonGrey10"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toStartOf="@id/previousResult"
-        app:layout_constraintStart_toEndOf="@+id/queryText"
-        app:layout_constraintTop_toTopOf="parent" />
-
-    <ImageButton
-        android:id="@+id/previousResult"
-        android:layout_width="48dp"
-        android:layout_height="48dp"
-        android:alpha=".6"
-        android:background="?android:attr/selectableItemBackgroundBorderless"
-        android:contentDescription="@string/accessibility_previous_result"
-        android:src="@drawable/ic_arrowhead_up"
-        android:tint="@color/photonGrey10"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toStartOf="@id/nextResult"
-        app:layout_constraintStart_toEndOf="@+id/resultText"
-        app:layout_constraintTop_toTopOf="parent" />
-
-    <ImageButton
-        android:id="@+id/nextResult"
-        android:layout_width="48dp"
-        android:layout_height="48dp"
-        android:alpha=".6"
-        android:background="?android:attr/selectableItemBackgroundBorderless"
-        android:contentDescription="@string/accessibility_next_result"
-        android:src="@drawable/ic_arrowhead_down"
-        android:tint="@color/photonGrey10"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toStartOf="@id/close_find_in_page"
-        app:layout_constraintStart_toEndOf="@+id/previousResult"
-        app:layout_constraintTop_toTopOf="parent" />
-
-    <ImageButton
-        android:id="@+id/close_find_in_page"
-        android:layout_width="48dp"
-        android:layout_height="48dp"
-        android:background="?android:attr/selectableItemBackgroundBorderless"
-        android:contentDescription="@string/accessibility_dismiss_find_in_page"
-        android:src="@drawable/ic_close"
-        android:tint="@color/photonWhite"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toEndOf="@+id/nextResult"
-        app:layout_constraintTop_toTopOf="parent" />
-
-</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/focus-android/app/src/main/res/layout/fragment_browser.xml b/focus-android/app/src/main/res/layout/fragment_browser.xml
index 340c40be23a5..2a1d01aede81 100644
--- a/focus-android/app/src/main/res/layout/fragment_browser.xml
+++ b/focus-android/app/src/main/res/layout/fragment_browser.xml
@@ -5,7 +5,8 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    xmlns:app="http://schemas.android.com/apk/res-auto">
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:mozac="http://schemas.android.com/apk/res-auto">
 
     <LinearLayout
         android:id="@+id/browser_container"
@@ -28,22 +29,15 @@
             android:orientation="vertical"
             android:clipChildren="false">
 
-            <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
-                android:id="@+id/swipe_refresh"
+            <mozilla.components.concept.engine.EngineView
+                android:id="@+id/webview"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
-                app:layout_behavior="@string/appbar_scrolling_view_behavior">
+                android:focusable="true"
+                android:focusableInTouchMode="true"
+                android:scrollbarThumbVertical="@drawable/scrollbar_thumb"
+                app:layout_behavior="@string/appbar_scrolling_view_behavior" />
 
-                <org.mozilla.focus.web.IWebView
-                    android:id="@+id/webview"
-                    android:layout_width="match_parent"
-                    android:layout_height="match_parent"
-                    android:focusable="true"
-                    android:focusableInTouchMode="true"
-                    android:scrollbarThumbVertical="@drawable/scrollbar_thumb"
-                    app:layout_behavior="@string/appbar_scrolling_view_behavior" />
-
-            </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
 
             <FrameLayout
                 android:id="@+id/crash_container"
@@ -87,15 +81,19 @@
                 android:contentDescription="@string/content_description_erase"
                 app:layout_dodgeInsetEdges="bottom"/>
 
-            <include
+            <mozilla.components.feature.findinpage.view.FindInPageBar
                 android:id="@+id/find_in_page"
-                layout="@layout/find_in_page"
-                android:layout_height="wrap_content"
                 android:layout_width="match_parent"
-                android:layout_gravity="bottom"
-                android:visibility="gone"
-                app:layout_behavior="@string/appbar_scrolling_view_behavior"
-                app:layout_insetEdge="bottom"/>
+                android:background="#FFFFFFFF"
+                android:elevation="10dp"
+                android:layout_height="56dp"
+                android:padding="4dp"
+                mozac:findInPageNoMatchesTextColor="#ff000000"
+                mozac:findInPageQueryTextColor="#ff000000"
+                mozac:findInPageQueryHintTextColor="#ff000000"
+                mozac:findInPageResultCountTextColor="#ff000000"
+                android:visibility="gone" />
+
         </org.mozilla.focus.widget.ResizableKeyboardCoordinatorLayout>
     </LinearLayout>
 
diff --git a/focus-android/app/src/main/res/layout/fragment_info.xml b/focus-android/app/src/main/res/layout/fragment_info.xml
index 542aa364b78c..c35e97520561 100644
--- a/focus-android/app/src/main/res/layout/fragment_info.xml
+++ b/focus-android/app/src/main/res/layout/fragment_info.xml
@@ -5,7 +5,7 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent">
-    <org.mozilla.focus.web.IWebView
+    <mozilla.components.concept.engine.EngineView
         android:id="@+id/webview"
         android:layout_width="match_parent"
         android:layout_height="match_parent"/>
diff --git a/focus-android/app/src/main/assets/gpl.html b/focus-android/app/src/main/res/raw/gpl.html
similarity index 100%
rename from focus-android/app/src/main/assets/gpl.html
rename to focus-android/app/src/main/res/raw/gpl.html
diff --git a/focus-android/app/src/main/assets/licenses.html b/focus-android/app/src/main/res/raw/licenses.html
similarity index 100%
rename from focus-android/app/src/main/assets/licenses.html
rename to focus-android/app/src/main/res/raw/licenses.html
diff --git a/focus-android/app/src/main/res/xml/mozilla_settings.xml b/focus-android/app/src/main/res/xml/mozilla_settings.xml
index a14b86b17af7..cdd96f9ad824 100644
--- a/focus-android/app/src/main/res/xml/mozilla_settings.xml
+++ b/focus-android/app/src/main/res/xml/mozilla_settings.xml
@@ -14,6 +14,7 @@
         android:title="@string/preference_homescreen_tips" />
 
     <org.mozilla.focus.widget.AboutPreference
+        android:icon="@drawable/ic_tab_new"
         android:key="@string/pref_key_about"
         android:layout="@layout/focus_preference_new_tab"
         android:title="@string/menu_about" />
@@ -25,6 +26,7 @@
         android:title="@string/menu_help" />
 
     <androidx.preference.Preference
+        android:icon="@drawable/ic_tab_new"
         android:key="@string/pref_key_rights"
         android:layout="@layout/focus_preference_new_tab"
         android:title="@string/menu_rights" />
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/utils/InfoActivityIntentTest.kt b/focus-android/app/src/test/java/org/mozilla/focus/utils/InfoActivityIntentTest.kt
deleted file mode 100644
index f9fe87bc0e40..000000000000
--- a/focus-android/app/src/test/java/org/mozilla/focus/utils/InfoActivityIntentTest.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.mozilla.focus.utils
-
-import android.app.Application
-import androidx.test.core.app.ApplicationProvider
-import org.junit.Assert.assertEquals
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mozilla.focus.R
-import org.mozilla.focus.activity.InfoActivity
-import org.robolectric.RobolectricTestRunner
-
-@RunWith(RobolectricTestRunner::class)
-class InfoActivityIntentTest {
-
-    @Test
-    fun getIntentFor() {
-        val context = ApplicationProvider.getApplicationContext() as Application
-        val intent = InfoActivity.getIntentFor(context, "https://www.mozilla.org", "Mozilla")
-        val extras = intent.extras
-        assertEquals("https://www.mozilla.org", extras?.getString("extra_url"))
-        assertEquals("Mozilla", extras?.getString("extra_title"))
-    }
-
-    @Test
-    fun getAboutIntent() {
-        val context = ApplicationProvider.getApplicationContext() as Application
-        val intent = InfoActivity.getAboutIntent(context)
-        val extras = intent.extras
-        assertEquals("focus:about", extras?.getString("extra_url"))
-        assertEquals(
-            context.resources.getString(R.string.menu_about),
-            extras?.getString("extra_title")
-        )
-    }
-
-    @Test
-    fun getRightsIntent() {
-        val context = ApplicationProvider.getApplicationContext() as Application
-        val intent = InfoActivity.getRightsIntent(context)
-        val extras = intent.extras
-        assertEquals("focus:rights", extras?.getString("extra_url"))
-        assertEquals(
-            context.resources.getString(R.string.menu_rights),
-            extras?.getString("extra_title")
-        )
-    }
-}
diff --git a/focus-android/build.gradle b/focus-android/build.gradle
index 2a24aefbc562..ae7ef130f0bf 100644
--- a/focus-android/build.gradle
+++ b/focus-android/build.gradle
@@ -6,7 +6,6 @@ buildscript {
     ext.espresso_version = '3.1.0-alpha4'
     ext.kotlin_version = '1.3.61'
     ext.coroutines_version = '1.3.0'
-    ext.gecko_release_version = '86.0.20210222142601'
     ext.mozilla_components_version = '72.0.15'
     // Pinning the last working version of the service-telemetry component until we decide
     // what we want to do with telemetry in the app.
diff --git a/focus-android/docs/Telemetry.md b/focus-android/docs/Telemetry.md
index bea8c81d97af..85cbddd1c09f 100644
--- a/focus-android/docs/Telemetry.md
+++ b/focus-android/docs/Telemetry.md
@@ -234,7 +234,7 @@ The event ping contains a list of events ([see event format on readthedocs.io](h
 | Autocomplete domain reordered  | action   | reorder  | autocomplete_domain     |       | `options*`
 | Open Exceptions Setting        | action   | open     | allowlist               |       |
 | Remove Exceptions Domains      | action   | remove   | allowlist               |       |`{ "total": 5 }`
-| Remove All Exceptions Domains  | action   | remove_all |allowlist              |       |`{ "total": 5 }`
+| Remove All Exceptions Domains  | action   | remove_all |allowlist              |       |
 | Default search engine clicked  | action   | open     | search_engine_setting   |       |
 | Change default search engine   | action   | save     | search_engine_setting   |       | `{"source": src* }`
 | Select "Remove" engines screen | action   | remove   | search_engine_setting   |       |
