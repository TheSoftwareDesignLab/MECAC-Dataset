diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
index 2959e1735684..1280cd03ab88 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
@@ -28,6 +28,9 @@ private const val SMALL_ELEVATION_CHANGE = 0.01f
 /**
  * A [CoordinatorLayout.Behavior] implementation to be used when placing [BrowserToolbar] at the bottom of the screen.
  *
+ * This is safe to use even if the [BrowserToolbar] may be added / removed from a parent layout later
+ * or if it could have Visibility.GONE set.
+ *
  * This implementation will:
  * - Show/Hide the [BrowserToolbar] automatically when scrolling vertically.
  * - On showing a [Snackbar] position it above the [BrowserToolbar].
@@ -65,7 +68,7 @@ class BrowserToolbarBottomBehavior(
      * Reference to the actual [BrowserToolbar] that we'll animate.
      */
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal lateinit var browserToolbar: BrowserToolbar
+    internal var browserToolbar: BrowserToolbar? = null
 
     /**
      * Depending on how user's touch was consumed by EngineView / current website,
@@ -92,19 +95,10 @@ class BrowserToolbarBottomBehavior(
         axes: Int,
         type: Int
     ): Boolean {
-        return if (shouldScroll && axes == ViewCompat.SCROLL_AXIS_VERTICAL) {
-            startedScroll = true
-            shouldSnapAfterScroll = type == ViewCompat.TYPE_TOUCH
-            snapAnimator.cancel()
-            true
-        } else if (engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_UNHANDLED) {
-            // Force expand the toolbar if event is unhandled, otherwise user could get stuck in a
-            // state where they cannot show the toolbar
-            snapAnimator.cancel()
-            forceExpand(child)
-            false
+        return if (browserToolbar != null) {
+            startNestedScroll(axes, type, child)
         } else {
-            false
+            return false // not interested in subsequent scroll events
         }
     }
 
@@ -114,13 +108,8 @@ class BrowserToolbarBottomBehavior(
         target: View,
         type: Int
     ) {
-        startedScroll = false
-        if (shouldSnapAfterScroll || type == ViewCompat.TYPE_NON_TOUCH) {
-            if (child.translationY >= (child.height / 2f)) {
-                animateSnap(child, SnapDirection.DOWN)
-            } else {
-                animateSnap(child, SnapDirection.UP)
-            }
+        if (browserToolbar != null) {
+            stopNestedScroll(type, child)
         }
     }
 
@@ -129,7 +118,9 @@ class BrowserToolbarBottomBehavior(
         child: BrowserToolbar,
         ev: MotionEvent
     ): Boolean {
-        gesturesDetector.handleTouchEvent(ev)
+        if (browserToolbar != null) {
+            gesturesDetector.handleTouchEvent(ev)
+        }
         return false // allow events to be passed to below listeners
     }
 
@@ -172,12 +163,13 @@ class BrowserToolbarBottomBehavior(
         if (snapAnimator.isStarted) {
             snapAnimator.end()
         } else {
-            browserToolbar.translationY =
-                if (browserToolbar.translationY >= browserToolbar.height / 2) {
-                    browserToolbar.height.toFloat()
+            browserToolbar?.apply {
+                translationY = if (translationY >= height / 2) {
+                    height.toFloat()
                 } else {
                     0f
                 }
+            }
         }
     }
 
@@ -200,17 +192,19 @@ class BrowserToolbarBottomBehavior(
 
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal fun tryToScrollVertically(distance: Float) {
-        if (shouldScroll && startedScroll) {
-            browserToolbar.translationY =
-                max(0f, min(browserToolbar.height.toFloat(), browserToolbar.translationY + distance))
-        } else {
-            // Force expand the toolbar if the user scrolled up, it is not already expanded and
-            // an animation to expand it is not already in progress,
-            // otherwise the user could get stuck in a state where they cannot show the toolbar
-            val isAnimatingUp = snapAnimator.isStarted && lastSnapStartedWasUp
-            if (distance < 0 && browserToolbar.translationY != 0f && !isAnimatingUp) {
-                snapAnimator.cancel()
-                forceExpand(browserToolbar)
+        browserToolbar?.let { toolbar ->
+            if (shouldScroll && startedScroll) {
+                toolbar.translationY =
+                    max(0f, min(toolbar.height.toFloat(), toolbar.translationY + distance))
+            } else {
+                // Force expand the toolbar if the user scrolled up, it is not already expanded and
+                // an animation to expand it is not already in progress,
+                // otherwise the user could get stuck in a state where they cannot show the toolbar
+                val isAnimatingUp = snapAnimator.isStarted && lastSnapStartedWasUp
+                if (distance < 0 && toolbar.translationY != 0f && !isAnimatingUp) {
+                    snapAnimator.cancel()
+                    forceExpand(toolbar)
+                }
             }
         }
     }
@@ -237,6 +231,36 @@ class BrowserToolbarBottomBehavior(
                 snapToolbarVertically()
             }
         ))
+
+    @VisibleForTesting
+    internal fun startNestedScroll(axes: Int, type: Int, toolbar: BrowserToolbar): Boolean {
+        return if (shouldScroll && axes == ViewCompat.SCROLL_AXIS_VERTICAL) {
+            startedScroll = true
+            shouldSnapAfterScroll = type == ViewCompat.TYPE_TOUCH
+            snapAnimator.cancel()
+            true
+        } else if (engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_UNHANDLED) {
+            // Force expand the toolbar if event is unhandled, otherwise user could get stuck in a
+            // state where they cannot show the toolbar
+            snapAnimator.cancel()
+            forceExpand(toolbar)
+            false
+        } else {
+            false
+        }
+    }
+
+    @VisibleForTesting
+    internal fun stopNestedScroll(type: Int, toolbar: BrowserToolbar) {
+        startedScroll = false
+        if (shouldSnapAfterScroll || type == ViewCompat.TYPE_NON_TOUCH) {
+            if (toolbar.translationY >= (toolbar.height / 2f)) {
+                animateSnap(toolbar, SnapDirection.DOWN)
+            } else {
+                animateSnap(toolbar, SnapDirection.UP)
+            }
+        }
+    }
 }
 
 @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
index ff7ced634b6d..3872d538f2ad 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
@@ -19,6 +19,7 @@ import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.engine.EngineSession
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.concept.engine.selection.SelectionActionDelegate
+import mozilla.components.support.test.any
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
 import org.junit.Assert.assertEquals
@@ -27,6 +28,7 @@ import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.anyFloat
+import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.Mockito.`when`
 import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.never
@@ -35,46 +37,163 @@ import org.mockito.Mockito.verify
 
 @RunWith(AndroidJUnit4::class)
 class BrowserToolbarBottomBehaviorTest {
-
     @Test
-    fun `Starting a nested scroll should cancel an ongoing snap animation`() {
+    fun `onStartNestedScroll should attempt scrolling only if browserToolbar is valid`() {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
         doReturn(true).`when`(behavior).shouldScroll
 
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
+        behavior.browserToolbar = null
+        var acceptsNestedScroll = behavior.onStartNestedScroll(
+            coordinatorLayout = mock(),
+            child = mock(),
+            directTargetChild = mock(),
+            target = mock(),
+            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
+            type = ViewCompat.TYPE_TOUCH
+        )
+        assertFalse(acceptsNestedScroll)
+        verify(behavior, never()).startNestedScroll(anyInt(), anyInt(), any())
 
-        val acceptsNestedScroll = behavior.onStartNestedScroll(
+        behavior.browserToolbar = mock()
+        acceptsNestedScroll = behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
             directTargetChild = mock(),
             target = mock(),
             axes = ViewCompat.SCROLL_AXIS_VERTICAL,
-            type = ViewCompat.TYPE_TOUCH)
+            type = ViewCompat.TYPE_TOUCH
+        )
+        assertTrue(acceptsNestedScroll)
+        verify(behavior).startNestedScroll(anyInt(), anyInt(), any())
+    }
+
+    @Test
+    fun `startNestedScroll should cancel an ongoing snap animation`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        doReturn(true).`when`(behavior).shouldScroll
+
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+
+        val acceptsNestedScroll = behavior.startNestedScroll(
+            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
+            type = ViewCompat.TYPE_TOUCH,
+            toolbar = mock()
+        )
 
         assertTrue(acceptsNestedScroll)
 
         verify(animator).cancel()
     }
 
+    @Test
+    fun `startNestedScroll should not accept nested scrolls on the horizontal axis`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        doReturn(true).`when`(behavior).shouldScroll
+
+        var acceptsNestedScroll = behavior.startNestedScroll(
+            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
+            type = ViewCompat.TYPE_TOUCH,
+            toolbar = mock()
+        )
+        assertTrue(acceptsNestedScroll)
+
+        acceptsNestedScroll = behavior.startNestedScroll(
+            axes = ViewCompat.SCROLL_AXIS_HORIZONTAL,
+            type = ViewCompat.TYPE_TOUCH,
+            toolbar = mock()
+        )
+        assertFalse(acceptsNestedScroll)
+    }
+
     @Test
     fun `Behavior should not accept nested scrolls on the horizontal axis`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        behavior.browserToolbar = mock()
+        doReturn(true).`when`(behavior).shouldScroll
 
-        val acceptsNestedScroll = behavior.onStartNestedScroll(
+        var acceptsNestedScroll = behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
             directTargetChild = mock(),
             target = mock(),
-            axes = ViewCompat.SCROLL_AXIS_HORIZONTAL,
+            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
             type = ViewCompat.TYPE_TOUCH)
+        assertTrue(acceptsNestedScroll)
 
+        acceptsNestedScroll = behavior.onStartNestedScroll(
+            coordinatorLayout = mock(),
+            child = mock(),
+            directTargetChild = mock(),
+            target = mock(),
+            axes = ViewCompat.SCROLL_AXIS_HORIZONTAL,
+            type = ViewCompat.TYPE_TOUCH)
         assertFalse(acceptsNestedScroll)
     }
 
     @Test
-    fun `Behavior will snap toolbar up if toolbar is more than 50% visible`() {
+    fun `Behavior should delegate the onStartNestedScroll logic`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val toolbar: BrowserToolbar = mock()
+        behavior.browserToolbar = toolbar
+        val inputType = ViewCompat.TYPE_TOUCH
+        val axes = ViewCompat.SCROLL_AXIS_VERTICAL
+
+        behavior.onStartNestedScroll(
+            coordinatorLayout = mock(),
+            child = toolbar,
+            directTargetChild = mock(),
+            target = mock(),
+            axes = axes,
+            type = inputType
+        )
+
+        verify(behavior).startNestedScroll(axes, inputType, toolbar)
+    }
+
+    @Test
+    fun `onStopNestedScroll should attempt stopping nested scrolling only if browserToolbar is valid`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+
+        behavior.browserToolbar = null
+        behavior.onStopNestedScroll(
+            coordinatorLayout = mock(),
+            child = mock(),
+            target = mock(),
+            type = 0
+        )
+        verify(behavior, never()).stopNestedScroll(anyInt(), any())
+
+        behavior.browserToolbar = mock()
+        behavior.onStopNestedScroll(
+            coordinatorLayout = mock(),
+            child = mock(),
+            target = mock(),
+            type = 0
+        )
+        verify(behavior).stopNestedScroll(anyInt(), any())
+    }
+
+    @Test
+    fun `Behavior should delegate the onStopNestedScroll logic`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val inputType = ViewCompat.TYPE_TOUCH
+        val toolbar: BrowserToolbar = mock()
+
+        behavior.browserToolbar = null
+        behavior.onStopNestedScroll(
+            coordinatorLayout = mock(),
+            child = toolbar,
+            target = mock(),
+            type = inputType
+        )
+        verify(behavior, never()).stopNestedScroll(inputType, toolbar)
+    }
+
+    @Test
+    fun `stopNestedScroll will snap toolbar up if toolbar is more than 50% visible`() {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        behavior.browserToolbar = mock()
         doReturn(true).`when`(behavior).shouldScroll
 
         val animator: ValueAnimator = mock()
@@ -96,11 +215,7 @@ class BrowserToolbarBottomBehaviorTest {
 
         verify(animator, never()).start()
 
-        behavior.onStopNestedScroll(
-            coordinatorLayout = mock(),
-            child = child,
-            target = mock(),
-            type = 0)
+        behavior.stopNestedScroll(0, child)
 
         verify(behavior).animateSnap(child, SnapDirection.UP)
 
@@ -108,7 +223,7 @@ class BrowserToolbarBottomBehaviorTest {
     }
 
     @Test
-    fun `Behavior will snap toolbar down if toolbar is less than 50% visible`() {
+    fun `stopNestedScroll will snap toolbar down if toolbar is less than 50% visible`() {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
         doReturn(true).`when`(behavior).shouldScroll
 
@@ -116,6 +231,7 @@ class BrowserToolbarBottomBehaviorTest {
         behavior.snapAnimator = animator
 
         val child = mock<BrowserToolbar>()
+        behavior.browserToolbar = child
         doReturn(100).`when`(child).height
         doReturn(90f).`when`(child).translationY
 
@@ -131,15 +247,44 @@ class BrowserToolbarBottomBehaviorTest {
 
         verify(animator, never()).start()
 
-        behavior.onStopNestedScroll(
+        behavior.stopNestedScroll(0, child)
+
+        verify(behavior).animateSnap(child, SnapDirection.DOWN)
+
+        verify(animator).start()
+    }
+
+    @Test
+    fun `stopNestedScroll should snap the toolbar only if browserToolbar is valid`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        behavior.browserToolbar = null
+        doReturn(true).`when`(behavior).shouldScroll
+
+        val animator: ValueAnimator = mock()
+        behavior.snapAnimator = animator
+
+        val child = mock<BrowserToolbar>()
+        doReturn(100).`when`(child).height
+        doReturn(90f).`when`(child).translationY
+
+        behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
             child = child,
+            directTargetChild = mock(),
             target = mock(),
-            type = 0)
+            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
+            type = ViewCompat.TYPE_TOUCH)
 
-        verify(behavior).animateSnap(child, SnapDirection.DOWN)
+        // shouldSnapAfterScroll should not have a different value than the initial "false"
+        assertFalse(behavior.shouldSnapAfterScroll)
 
-        verify(animator).start()
+        verify(animator, never()).start()
+
+        behavior.stopNestedScroll(0, child)
+
+        verify(behavior, never()).animateSnap(child, SnapDirection.DOWN)
+
+        verify(animator, never()).start()
     }
 
     @Test
@@ -147,6 +292,7 @@ class BrowserToolbarBottomBehaviorTest {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
         val gestureDetector: BrowserGestureDetector = mock()
         behavior.initGesturesDetector(gestureDetector)
+        behavior.browserToolbar = mock()
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
 
         behavior.onInterceptTouchEvent(mock(), mock(), downEvent)
@@ -154,6 +300,18 @@ class BrowserToolbarBottomBehaviorTest {
         verify(gestureDetector).handleTouchEvent(downEvent)
     }
 
+    @Test
+    fun `Behavior should only dispatch MotionEvents to the gesture detector only if browserToolbar is valid`() {
+        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val gestureDetector: BrowserGestureDetector = mock()
+        behavior.initGesturesDetector(gestureDetector)
+        val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
+
+        behavior.onInterceptTouchEvent(mock(), mock(), downEvent)
+
+        verify(gestureDetector, never()).handleTouchEvent(downEvent)
+    }
+
     @Test
     fun `Behavior will apply translation to toolbar only for vertical scrolls`() {
         val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
