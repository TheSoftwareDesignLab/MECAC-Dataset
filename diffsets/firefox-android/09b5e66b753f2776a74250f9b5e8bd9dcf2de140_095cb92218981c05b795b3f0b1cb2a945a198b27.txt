diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index f7b90668106f..dfe36d0943ee 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -191,14 +191,6 @@ projects:
     path: components/browser/engine-gecko
     description: 'Engine implementation based on GeckoView.'
     publish: true
-  browser-engine-gecko-beta:
-    path: components/browser/engine-gecko-beta
-    description: 'Engine implementation based on GeckoView (Beta channel).'
-    publish: true
-  browser-engine-gecko-nightly:
-    path: components/browser/engine-gecko-nightly
-    description: 'Engine implementation based on GeckoView (Nightly).'
-    publish: true
   browser-engine-system:
     path: components/browser/engine-system
     description: 'Engine implementation based on the system WebView.'
diff --git a/android-components/build.gradle b/android-components/build.gradle
index c81aea91290c..51eaf38e2266 100644
--- a/android-components/build.gradle
+++ b/android-components/build.gradle
@@ -407,7 +407,6 @@ tasks.register("ktlint", JavaExec) {
     args "components/**/*.kt" , "samples/**/*.kt", "!**/build", "buildSrc/**/*.kt"
 }
 
-apply plugin: GVVersionVerifierPlugin
 apply plugin: GitHubPlugin
 
 
diff --git a/android-components/buildSrc/src/main/java/Dependencies.kt b/android-components/buildSrc/src/main/java/Dependencies.kt
index 71cf89f29bfd..8313fafdc84f 100644
--- a/android-components/buildSrc/src/main/java/Dependencies.kt
+++ b/android-components/buildSrc/src/main/java/Dependencies.kt
@@ -134,21 +134,16 @@ object Dependencies {
     const val tools_detekt_api = "io.gitlab.arturbosch.detekt:detekt-api:${Versions.detekt}"
     const val tools_detekt_test = "io.gitlab.arturbosch.detekt:detekt-test:${Versions.detekt}"
 
+    val mozilla_geckoview = "org.mozilla.geckoview:${Gecko.channel.artifactName}:${Gecko.version}"
     const val mozilla_fxa = "org.mozilla.appservices:fxaclient:${Versions.mozilla_appservices}"
-
     const val mozilla_nimbus = "org.mozilla.appservices:nimbus:${Versions.mozilla_appservices}"
-
     const val mozilla_glean_forUnitTests = "org.mozilla.telemetry:glean-forUnitTests:${Versions.mozilla_glean}"
-
     const val mozilla_sync_autofill = "org.mozilla.appservices:autofill:${Versions.mozilla_appservices}"
     const val mozilla_sync_logins = "org.mozilla.appservices:logins:${Versions.mozilla_appservices}"
     const val mozilla_places = "org.mozilla.appservices:places:${Versions.mozilla_appservices}"
     const val mozilla_sync_manager = "org.mozilla.appservices:syncmanager:${Versions.mozilla_appservices}"
-
     const val mozilla_push = "org.mozilla.appservices:push:${Versions.mozilla_appservices}"
-
     const val mozilla_remote_tabs = "org.mozilla.appservices:tabs:${Versions.mozilla_appservices}"
-
     const val mozilla_httpconfig = "org.mozilla.appservices:httpconfig:${Versions.mozilla_appservices}"
     const val mozilla_full_megazord = "org.mozilla.appservices:full-megazord:${Versions.mozilla_appservices}"
     const val mozilla_full_megazord_forUnitTests = "org.mozilla.appservices:full-megazord-forUnitTests:${Versions.mozilla_appservices}"
diff --git a/android-components/buildSrc/src/main/java/GVVersionVerifierPlugin.kt b/android-components/buildSrc/src/main/java/GVVersionVerifierPlugin.kt
deleted file mode 100644
index 5a3833bbdbd5..000000000000
--- a/android-components/buildSrc/src/main/java/GVVersionVerifierPlugin.kt
+++ /dev/null
@@ -1,118 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-import GeckoVersions.beta_version
-import GeckoVersions.nightly_version
-import GeckoVersions.release_version
-import groovy.util.Node
-import groovy.util.NodeList
-import groovy.util.XmlParser
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import java.io.File
-
-open class GVVersionVerifierPlugin : Plugin<Project> {
-
-    companion object {
-        private const val GV_VERSION_PATH_FILE = "buildSrc/src/main/java/Gecko.kt"
-        private const val MAVEN_MOZILLA_NIGHTLY_GV_URL =
-            "https://maven.mozilla.org/maven2/org/mozilla/geckoview/geckoview-nightly-armeabi-v7a/maven-metadata.xml"
-        private const val MAVEN_MOZILLA_BETA_GV_URL =
-            "https://maven.mozilla.org/maven2/org/mozilla/geckoview/geckoview-beta-armeabi-v7a/maven-metadata.xml"
-        private const val MAVEN_MOZILLA_STABLE_GV_URL =
-            "https://maven.mozilla.org/maven2/org/mozilla/geckoview/geckoview-armeabi-v7a/maven-metadata.xml"
-    }
-
-    override fun apply(project: Project) {
-
-        project.tasks.register("updateGVNightlyVersion") {
-
-            doLast {
-                val configuration = GVConfiguration(
-                    actualVersionMajor = nightly_version.extractMajor(),
-                    variableName = "nightly_version",
-                    mavenURL = project.getNightlyMavenURL()
-                )
-                updateGVVersion(project, configuration)
-            }
-        }
-
-        project.tasks.register("updateGVBetaVersion") {
-
-            doLast {
-                val configuration = GVConfiguration(
-                    actualVersionMajor = beta_version.extractMajor(),
-                    variableName = "beta_version",
-                    mavenURL = project.getBetaMavenURL()
-                )
-                updateGVVersion(project, configuration)
-            }
-        }
-
-        project.tasks.register("updateGVStableVersion") {
-
-            doLast {
-                val configuration = GVConfiguration(
-                    actualVersionMajor = release_version.extractMajor(),
-                    variableName = "release_version",
-                    mavenURL = project.getStableMavenURL()
-                )
-                updateGVVersion(project, configuration)
-            }
-        }
-    }
-
-    @Suppress("TooGenericExceptionThrown")
-    private fun updateGVVersion(project: Project, config: GVConfiguration) {
-
-        val newVersion = getLastGeckoViewVersion(config)
-
-        if (newVersion.isNotEmpty()) {
-            val filePath = project.property("gvVersionFile", GV_VERSION_PATH_FILE)
-            updateConfigFileWithNewGVVersion(filePath, newVersion, config.variableName)
-        } else {
-            throw Exception("Unable to find a new version of GeckoViewNightly")
-        }
-    }
-
-    @Suppress("UNCHECKED_CAST")
-    private fun getLastGeckoViewVersion(config: GVConfiguration): String {
-        val versioning = (XmlParser().parse(config.mavenURL)["versioning"] as List<Node>)
-        val latest = versioning[0]["latest"] as List<Node>
-        val value = ((latest.first().value() as NodeList)[0]).toString()
-
-        val lastVersion = if (value.isNotEmpty()) value else ""
-
-        val lastVersionMajor = lastVersion.extractMajor()
-
-        return if (config.actualVersionMajor == lastVersionMajor) lastVersion else ""
-    }
-
-    private fun updateConfigFileWithNewGVVersion(path: String, newVersion: String, variableName: String) {
-        val file = File(path)
-        var fileContent = file.readText()
-        fileContent = fileContent.replace(
-            Regex("$variableName.*=.*"),
-            "$variableName = \"$newVersion\""
-        )
-        file.writeText(fileContent)
-        println("${file.name} file updated")
-    }
-
-    private class GVConfiguration(val actualVersionMajor: String, val variableName: String, val mavenURL: String)
-
-    private fun String.extractMajor() = this.split(".").first()
-
-    private fun Project.getNightlyMavenURL(): String {
-        return project.property("gvMavenNightlyVersionURL", MAVEN_MOZILLA_NIGHTLY_GV_URL)
-    }
-
-    private fun Project.getBetaMavenURL(): String {
-        return project.property("gvMavenBetaVersionURL", MAVEN_MOZILLA_BETA_GV_URL)
-    }
-
-    private fun Project.getStableMavenURL(): String {
-        return project.property("gvMavenStableVersionURL", MAVEN_MOZILLA_STABLE_GV_URL)
-    }
-}
diff --git a/android-components/buildSrc/src/main/java/Gecko.kt b/android-components/buildSrc/src/main/java/Gecko.kt
index fef599807c3f..0202dc79fe6c 100644
--- a/android-components/buildSrc/src/main/java/Gecko.kt
+++ b/android-components/buildSrc/src/main/java/Gecko.kt
@@ -2,26 +2,28 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-internal object GeckoVersions {
-    /**
-     * GeckoView Nightly Version.
-     */
-    const val nightly_version = "90.0.20210420095122"
-
+/**
+ * Gecko version and release channel constants used by this version of Android Components.
+ */
+object Gecko {
     /**
-     * GeckoView Beta Version.
+     * GeckoView Version.
      */
-    const val beta_version = "89.0.20210419195043"
+    const val version = "90.0.20210420095122"
 
     /**
-     * GeckoView Release Version.
+     * GeckoView channel
      */
-    const val release_version = "88.0.20210415204500"
+    val channel = GeckoChannel.NIGHTLY
 }
 
-@Suppress("Unused", "MaxLineLength")
-object Gecko {
-    const val geckoview_nightly = "org.mozilla.geckoview:geckoview-nightly:${GeckoVersions.nightly_version}"
-    const val geckoview_beta = "org.mozilla.geckoview:geckoview-beta:${GeckoVersions.beta_version}"
-    const val geckoview_release = "org.mozilla.geckoview:geckoview:${GeckoVersions.release_version}"
+/**
+ * Enum for GeckoView release channels.
+ */
+enum class GeckoChannel(
+    val artifactName: String
+) {
+    NIGHTLY("geckoview-nightly"),
+    BETA("geckoview-beta"),
+    RELEASE("geckoview")
 }
diff --git a/android-components/components/browser/engine-gecko-beta/README.md b/android-components/components/browser/engine-gecko-beta/README.md
deleted file mode 100644
index 0d67fed59774..000000000000
--- a/android-components/components/browser/engine-gecko-beta/README.md
+++ /dev/null
@@ -1,61 +0,0 @@
-# [Android Components](../../../README.md) > Browser > Engine-Gecko
-
-[*Engine*](../../concept/engine/README.md) implementation based on [GeckoView](https://wiki.mozilla.org/Mobile/GeckoView) (Beta channel).
-
-## Usage
-
-See [concept-engine](../../concept/engine/README.md) for a documentation of the abstract engine API this component implements.
-
-### Setting up the dependency
-
-Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
-
-```Groovy
-implementation "org.mozilla.components:browser-engine-gecko-beta:{latest-version}"
-```
-
-### Initializing
-
-It is recommended to create only one `GeckoEngine` instance per app. To create a `GeckoEngine` a `GeckoRuntime` and optionally `DefaultSettings` are needed.
-
-```Kotlin
-// Create default settings (optional) and enable tracking protection for all future sessions.
-val defaultSettings = DefaultSettings().apply {
-    trackingProtectionPolicy = EngineSession.TrackingProtectionPolicy.all()
-}
-
-// Create and initialize a Gecko runtime with the default settings.
-val runtime = GeckoRuntime.getDefault(applicationContext)
-
-// Create an engine instance to be used by other components.
-val engine = GeckoEngine(runtime, defaultSettings)
-```
-
-### Integration
-
-Usually it is not needed to interact with the `Engine` component directly. The [browser-session](../session/README.md) component will take care of making the state accessible and link a `Session` to an `EngineSession` internally. The [feature-session](../../feature/session/README.md) component will provide "use cases" to perform actions like loading URLs and takes care of rendering the selected `Session` on an `EngineView`.
-
-### View
-
-`GeckoEngineView` is the Gecko-based implementation of `EngineView` in order to render web content.
-
-```XML
-<mozilla.components.browser.engine.gecko.GeckoEngineView
-    android:id="@+id/engineView"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" />
-```
-
-`GeckoEngineView` can render any `GeckoEngineSession` using the `render()` method.
-
-```Kotlin
-val engineSession = engine.createSession()
-val engineView = view.findViewById<GeckoEngineView>(R.id.engineView)
-engineView.render(engineSession)
-```
-
-## License
-
-    This Source Code Form is subject to the terms of the Mozilla Public
-    License, v. 2.0. If a copy of the MPL was not distributed with this
-    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/browser/engine-gecko-beta/build.gradle b/android-components/components/browser/engine-gecko-beta/build.gradle
deleted file mode 100644
index 3b6fc7b0b352..000000000000
--- a/android-components/components/browser/engine-gecko-beta/build.gradle
+++ /dev/null
@@ -1,86 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-buildscript {
-    repositories {
-        maven {
-            url "https://maven.mozilla.org/maven2"
-        }
-
-        dependencies {
-            classpath "org.mozilla.telemetry:glean-gradle-plugin:${Versions.mozilla_glean}"
-        }
-    }
-}
-
-plugins {
-    id "com.jetbrains.python.envs" version "0.0.26"
-}
-
-apply plugin: 'com.android.library'
-apply plugin: 'kotlin-android'
-
-android {
-    compileSdkVersion config.compileSdkVersion
-
-    defaultConfig {
-        minSdkVersion config.minSdkVersion
-        targetSdkVersion config.targetSdkVersion
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-
-    packagingOptions {
-        exclude 'META-INF/proguard/androidx-annotations.pro'
-    }
-}
-
-// Set configuration for the Glean parser to extract metrics.yaml
-// file from AAR dependencies of this project rather than look
-// for it into the project directory.
-ext.allowMetricsFromAAR = true
-// Generate markdown docs for the collected Gecko metrics.
-ext.gleanGenerateMarkdownDocs = true
-
-dependencies {
-    implementation project(':concept-engine')
-    implementation project(':concept-fetch')
-    implementation project(':support-ktx')
-    implementation project(':support-utils')
-
-    implementation Dependencies.kotlin_stdlib
-    implementation Dependencies.kotlin_coroutines
-
-    api Gecko.geckoview_beta
-
-    testImplementation Dependencies.androidx_test_core
-    testImplementation Dependencies.androidx_test_junit
-    testImplementation Dependencies.testing_robolectric
-    testImplementation Dependencies.testing_coroutines
-    testImplementation Dependencies.testing_mockito
-    testImplementation Dependencies.testing_mockwebserver
-    testImplementation project(':support-test')
-    testImplementation project(':tooling-fetch-tests')
-
-    // We only compile against Glean. It's up to the app to add those dependencies
-    // if it wants to collect GeckoView telemetry through the Glean SDK.
-    compileOnly project(":service-glean")
-    testImplementation project(":service-glean")
-    testImplementation Dependencies.androidx_work_testing
-
-    androidTestImplementation Dependencies.androidx_test_core
-    androidTestImplementation Dependencies.androidx_test_runner
-    androidTestImplementation Dependencies.androidx_test_rules
-    androidTestImplementation project(':tooling-fetch-tests')
-}
-
-apply plugin: "org.mozilla.telemetry.glean-gradle-plugin"
-apply from: '../../../publish.gradle'
-ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
diff --git a/android-components/components/browser/engine-gecko-beta/docs/metrics.md b/android-components/components/browser/engine-gecko-beta/docs/metrics.md
deleted file mode 100644
index 684a4e89638c..000000000000
--- a/android-components/components/browser/engine-gecko-beta/docs/metrics.md
+++ /dev/null
@@ -1,118 +0,0 @@
-<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
-
-# Metrics
-
-This document enumerates the metrics collected by this project using the [Glean SDK](https://mozilla.github.io/glean/book/index.html).
-This project may depend on other projects which also collect metrics.
-This means you might have to go searching through the dependency tree to get a full picture of everything collected by this project.
-
-# Pings
-
-- [metrics](#metrics)
-
-## metrics
-
-This is a built-in ping that is assembled out of the box by the Glean SDK.
-
-See the Glean SDK documentation for the [`metrics` ping](https://mozilla.github.io/glean/book/user/pings/metrics.html).
-
-All Glean pings contain built-in metrics in the [`ping_info`](https://mozilla.github.io/glean/book/user/pings/index.html#the-ping_info-section) and [`client_info`](https://mozilla.github.io/glean/book/user/pings/index.html#the-client_info-section) sections.
-
-In addition to those built-in metrics, the following metrics are added to the ping:
-
-| Name | Type | Description | Data reviews | Extras | Expiration | [Data Sensitivity](https://wiki.mozilla.org/Firefox/Data_Collection) |
-| --- | --- | --- | --- | --- | --- | --- |
-| avif.aom_decode_error |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Image-decode Error from AOM decoder  |[Bug 1690406](https://bugzilla.mozilla.org/show_bug.cgi?id=1690406#c3)|<ul><li>error</li><li>mem_error</li><li>abi_mismatch</li><li>incapable</li><li>unsup_bitstream</li><li>unsup_feature</li><li>corrupt_frame</li><li>invalid_param</li></ul>|never | |
-| avif.bit_depth |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Bits per pixel of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>color_8</li><li>color_10</li><li>color_12</li><li>color_16</li><li>unknown</li></ul>|never | |
-| avif.decode_result |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Decode result of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>success</li><li>parse_error</li><li>no_primary_item</li><li>decode_error</li><li>size_overflow</li><li>out_of_memory</li><li>pipe_init_error</li><li>write_buffer_error</li><li>alpha_y_sz_mismatch</li><li>alpha_y_bpc_mismatch</li></ul>|never | |
-| avif.decoder |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Decoder of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>dav1d</li><li>aom</li></ul>|never | |
-| avif.yuv_color_space |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |YUV color space of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>bt601</li><li>bt709</li><li>bt2020</li><li>identity</li><li>unknown</li></ul>|never | |
-| geckoview.build_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |The Buildid of the Gecko engine, example: 20200205124310  |[Bug 1611240](https://bugzilla.mozilla.org/show_bug.cgi?id=1611240#c2)||never | |
-| geckoview.content_process_lifetime |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The uptime of content processes in ms  |[Bug 1625325](https://bugzilla.mozilla.org/show_bug.cgi?id=1625325#c2)||never | |
-| geckoview.document_site_origins |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |When a document is loaded, report the number of [site origins](https://searchfox.org/ mozilla-central/rev/ 3300072e993ae05d50d5c63d815260367eaf9179/ caps/nsIPrincipal.idl#264) of the entire browser if it has been at least 5 minutes since last time we collect this data.  |[Bug 1589700](https://bugzilla.mozilla.org/show_bug.cgi?id=1589700#c5)||never | |
-| geckoview.page_load_progress_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between page load progress starts (0) and completion (100).  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| geckoview.page_load_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to load a page. This includes all static contents, no dynamic content. Loading of about: pages is not counted. Back back navigation (sometimes via BFCache) is included which is a source of bimodality due to the <50ms load times.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| geckoview.page_reload_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time taken to reload a page. This includes all static contents, no dynamic content. Loading of about: pages is not counted.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| geckoview.per_document_site_origins |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |When a document is unloaded, report the highest number of [site origins](https://searchfox.org/ mozilla-central/rev/ 3300072e993ae05d50d5c63d815260367eaf9179/ caps/nsIPrincipal.idl#264) loaded simultaneously in that document.  |[Bug 1603185](https://bugzilla.mozilla.org/show_bug.cgi?id=1603185#c13)||never | |
-| geckoview.startup_runtime |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to initialize GeckoRuntime.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| geckoview.version |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |The version of the Gecko engine, example: 74.0a1  |[Bug 1611240](https://bugzilla.mozilla.org/show_bug.cgi?id=1611240#c2)||never | |
-| gfx.adapter.primary.description |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Long form description of the Graphics adapter  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.device_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter device identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_date |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver date  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_files |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |List of graphics adapter driver files  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_vendor |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver vendor identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_version |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver version  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.ram |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Graphics adapter dedicated memory  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Megabytes</li></ul>|never | |
-| gfx.adapter.primary.subsystem_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter subsystem identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.vendor_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter vendor identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.checkerboard.duration |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The duration of a checkerboard event. Checkerboarding is when painting has not kept up with asynchronous panning and zooming so the compositor has to display a "checkerboard pattern" (or in practice, the background color) rather than the actual page content.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.peak_pixel_count |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The peak number of CSS pixels that checkerboarded during a checkerboard event. The minimum value of the largest histogram bucket is the size of a 4k display with maximum APZ zooming.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.potential_duration |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The total amount of time that we could reasonably be checkerboarding. This is the union of two possibly-intersecting sets of time periods: The first set is that in which checkerboarding was actually happening, since by definition it could potentially be happening. The second set is that in which the APZC is actively transforming content in the compositor, since it could potentially transform it so as to display checkerboarding to the user. Combined with other information, this allows us to meaningfully say how frequently users actually enncounters checkerboarding.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.severity |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |An opaque measurement of the severity of a checkerboard event. This doesn't have units, it's just useful for comparing two checkerboard events to see which one is worse, for some implementation-specific definition of "worse". The larger the value, the worse the checkerboarding.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.composite_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to composite a frame. On non-webrender this is the time taken in `CompositorBridgeParent::CompositeToTarget()`. On webrender, this is the time taken from the start of `WebRenderBridgeParent::CompositeToTarget()`, until the render thread has rendered the frame (in `RenderThread::HandleFrameOneDoc()`).  |[Bug 1580129](https://bugzilla.mozilla.org/show_bug.cgi?id=1580129#c7)||never | |
-| gfx.content.frame_time.from_paint |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.from_vsync |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from the vsync that started a paint in the content process until that frame is presented in the compositor.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.reason |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |The reason that `gfx.content.frame_time.from_paint` recorded a slow (>200ms) result, if any.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)|<ul><li>on_time</li><li>no_vsync</li><li>missed_composite</li><li>slow_composite</li><li>missed_composite_mid</li><li>missed_composite_long</li><li>missed_composite_low</li><li>no_vsync_no_id</li></ul>|never | |
-| gfx.content.frame_time.with_svg |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor, for frames that contained an SVG to be drawn by webrender.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.without_resource_upload |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor by webrender, excluding time spent uploading resources.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.without_upload |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor by webrender, excluding time spent uploading any content.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.full_paint_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in the full paint pipeline for content until it's ready for composition. For non-webrender this includes `paint_time`, plus rasterization if OMTP is enabled. For webrender, this includes `paint_time`, plus scene building time.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.paint_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in the main-thread paint pipeline for content. For non-webrender, this includes display list building, layer building, and when OMTP is disabled, rasterization. For webrender, this includes display list building, and webrender display list building.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.display.count |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Amount of displays connected to the device  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Display count</li></ul>|never | |
-| gfx.display.primary_height |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Height of the primary display, takes device rotation into account.  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Pixels</li></ul>|never | |
-| gfx.display.primary_width |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Width of the primary display, takes device rotation into account.  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Pixels</li></ul>|never | |
-| gfx.feature.webrender |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Whether webrender is enabled or disabled, and why. |[Bug 1687312](https://bugzilla.mozilla.org/show_bug.cgi?id=1687312#c5)||never | |
-| gfx.scroll_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a scroll event on the event loop and compositing its result onto the screen (ms).  |[Bug 1604818](https://bugzilla.mozilla.org/show_bug.cgi?id=1604818#c4)||never | |
-| gfx.status.compositor |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Name of the graphics compositor in use. Possible values are "opengl, d3d11, client, webrender or basic"  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.status.headless |[boolean](https://mozilla.github.io/glean/book/user/metrics/boolean.html) |Boolean indicated whether graphics is running in headless (no display) mode  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.webrender.framebuild_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to build a webrender frame. This involves calculating the visibility of primitives, requesting resources, and building the render passes which will be used to render the frame.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.webrender.scenebuild_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to build a webrender scene. This occurs each time webrender receives a new display list. This additionally includes blob rasterization time.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.webrender.sceneswap_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to do a webrender scene swap. This is book-keeping that APZ must perform once webrender has built a new scene.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| javascript.gc.compact_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the compact phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.mark_roots_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent marking GC roots.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.mark_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the mark phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.minor_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taked by a minor (nursery) collection.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.prepare_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the preparation phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.slice_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent running a GC slice.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.sweep_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the sweep phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.total_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The total time taken by a major collection.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c8)||never | |
-| js.baseline_compile_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during Baseline compilation for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.bytecode_caching_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent caching JS bytecode for scripts executed during a page load.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.delazification_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during delazification for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.execution_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of page load time spent executing Javascript.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.xdr_encode_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during XDR encoding for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| media.audio.backend |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |The operating system audio backend  |[Bug 1671714](https://bugzilla.mozilla.org/show_bug.cgi?id=1671714#c10)|<ul><li>unknown</li><li>audiounit</li><li>audiounit_rust</li><li>aaudio</li><li>opensl</li><li>wasapi</li><li>winmm</li><li>alsa</li><li>jack</li><li>oss</li><li>pulse</li><li>pulse_rust</li><li>sndio</li><li>sun</li></ul>|never | |
-| media.audio.init_failure |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Failure occurs when initializing the audio stream.  |[Bug 1671714](https://bugzilla.mozilla.org/show_bug.cgi?id=1671714#c10)|<ul><li>first</li><li>other</li></ul>|never | |
-| network.cache_hit_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time to open existing cache entry file.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.dns_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from the DNS request being issued to the response.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.dns_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from connection open to the DNS request being issued.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.first_from_cache |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from connection open to cache read start.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.font_download_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time after navigationStart that all webfont downloads are completed.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.tcp_connection |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from the TCP SYN packet is received to the connection is established and ready for HTTP.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.tls_handshake |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from after the TCP SYN packet is received to the secure connection is established and ready for HTTP.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.interaction.keypress_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a keypress event in the event loop and compositing its result onto the screen.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.interaction.mouseup_click_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a mouseup which follow by a mouseclick on the event loop and compositing its result onto the screen.  |[Bug 1698643](https://bugzilla.mozilla.org/show_bug.cgi?id=1698643#c3)||never | |
-| performance.interaction.tab_switch_composite |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between tab selection and first composite of the tab content onto the screen.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.page.non_blank_paint |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between navigationStart and the first non-blank paint of a foreground root content document, in milliseconds. This only records documents that were in an active docshell throughout the whole time between navigation start and non-blank paint. The non-blank paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.page.total_content_page_load |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time to load all of a page's resources and render.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.pageload.dcl |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from navigationStart to domContentLoaded for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.dcl_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from responseStart to domContentLoaded for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.fcp |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between navigationStart and the first contentful paint of a foreground http or https root content document, in milliseconds. The contentful paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.fcp_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between responseStart and the first contentful paint of a foreground http or https root content document, in milliseconds. The contentful paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.load_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from navigationStart to loadEventStart for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.load_time_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from responseStart to loadEventStart for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.req_anim_frame_callback |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in milliseconds calling all request animation frame callbacks for a document before it has reached readystate complete.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.responsiveness.req_anim_frame_callback |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in milliseconds calling all request animation frame callbacks for a document after it has reached readystate complete.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.time.dom_complete |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domComplete as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_content_loaded_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domContentLoadedEventEnd as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_content_loaded_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domContentLoadedEventStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_interactive |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domInteractive as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.load_event_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to loadEventEnd as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.load_event_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to loadEventStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.response_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to responseStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| test.glean.geckoview.streaming |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |A test-only, disabled metric. This is required to guarantee that a `GleanGeckoHistogramMapping` is always generated, even though the GeckoView AAR exports no metric. Please note that the data-review field below contains no review, since this metric is disabled and not allowed to collect any data.  |[Review 1](https://bugzilla.mozilla.org/1566374)||never | |
-
-Data categories are [defined here](https://wiki.mozilla.org/Firefox/Data_Collection).
-
-<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
-
diff --git a/android-components/components/browser/engine-gecko-beta/metrics.yaml b/android-components/components/browser/engine-gecko-beta/metrics.yaml
deleted file mode 100644
index 4775ce544de8..000000000000
--- a/android-components/components/browser/engine-gecko-beta/metrics.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-# IMPORTANT NOTE: this file is here only as a safety measure, to make
-# sure the correct code is generated even though the GeckoView AAR file
-# reports an empty metrics.yaml file. The metric in this file is currently
-# disabled and not supposed to collect any data.
----
-
-$schema: moz://mozilla.org/schemas/glean/metrics/2-0-0
-
-test.glean.geckoview:
-  streaming:
-    type: timing_distribution
-    gecko_datapoint: TELEMETRY_TEST_STREAMING
-    disabled: true
-    description: |
-      A test-only, disabled metric. This is required to guarantee
-      that a `GleanGeckoHistogramMapping` is always generated, even
-      though the GeckoView AAR exports no metric. Please note that
-      the data-review field below contains no review, since this
-      metric is disabled and not allowed to collect any data.
-    bugs:
-      - https://bugzilla.mozilla.org/1566374
-    data_reviews:
-      - https://bugzilla.mozilla.org/1566374
-    notification_emails:
-      - glean-team@mozilla.com
-    expires: never
diff --git a/android-components/components/browser/engine-gecko-beta/proguard-rules.pro b/android-components/components/browser/engine-gecko-beta/proguard-rules.pro
deleted file mode 100644
index f1b424510da5..000000000000
--- a/android-components/components/browser/engine-gecko-beta/proguard-rules.pro
+++ /dev/null
@@ -1,21 +0,0 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/browser/engine-gecko-beta/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt b/android-components/components/browser/engine-gecko-beta/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt
deleted file mode 100644
index 38e0a1586fb8..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt
+++ /dev/null
@@ -1,126 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch.geckoview
-
-import androidx.test.annotation.UiThreadTest
-import androidx.test.core.app.ApplicationProvider
-import androidx.test.filters.MediumTest
-import mozilla.components.browser.engine.gecko.fetch.GeckoViewFetchClient
-import mozilla.components.concept.fetch.Client
-import org.junit.Assert.assertTrue
-import org.junit.Test
-
-@MediumTest
-class GeckoViewFetchTestCases : mozilla.components.tooling.fetch.tests.FetchTestCases() {
-    override fun createNewClient(): Client = GeckoViewFetchClient(ApplicationProvider.getApplicationContext())
-
-    @Test
-    @UiThreadTest
-    fun clientInstance() {
-        assertTrue(createNewClient() is GeckoViewFetchClient)
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithGzippedBody() {
-        super.get200WithGzippedBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200OverridingDefaultHeaders() {
-        super.get200OverridingDefaultHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithDuplicatedCacheControlRequestHeaders() {
-        super.get200WithDuplicatedCacheControlRequestHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithDuplicatedCacheControlResponseHeaders() {
-        super.get200WithDuplicatedCacheControlResponseHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithHeaders() {
-        super.get200WithHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithReadTimeout() {
-        super.get200WithReadTimeout()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithStringBody() {
-        super.get200WithStringBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get302FollowRedirects() {
-        super.get302FollowRedirects()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get302FollowRedirectsDisabled() {
-        super.get302FollowRedirectsDisabled()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get404WithBody() {
-        super.get404WithBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun post200WithBody() {
-        super.post200WithBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun put201FileUpload() {
-        super.put201FileUpload()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithCookiePolicy() {
-        super.get200WithCookiePolicy()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithContentTypeCharset() {
-        super.get200WithContentTypeCharset()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithCacheControl() {
-        super.get200WithCacheControl()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun getThrowsIOExceptionWhenHostNotReachable() {
-        super.getThrowsIOExceptionWhenHostNotReachable()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun getDataUri() {
-        super.getDataUri()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/AndroidManifest.xml b/android-components/components/browser/engine-gecko-beta/src/main/AndroidManifest.xml
deleted file mode 100644
index 5012ce552616..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="mozilla.components.browser.engine.gecko" />
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt
deleted file mode 100644
index bba8c952775f..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt
+++ /dev/null
@@ -1,773 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.annotation.SuppressLint
-import android.content.Context
-import android.util.AttributeSet
-import android.util.JsonReader
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.activity.GeckoActivityDelegate
-import mozilla.components.browser.engine.gecko.ext.getAntiTrackingPolicy
-import mozilla.components.browser.engine.gecko.ext.getEtpLevel
-import mozilla.components.browser.engine.gecko.ext.getStrictSocialTrackingProtection
-import mozilla.components.browser.engine.gecko.integration.LocaleSettingUpdater
-import mozilla.components.browser.engine.gecko.mediaquery.from
-import mozilla.components.browser.engine.gecko.mediaquery.toGeckoValue
-import mozilla.components.browser.engine.gecko.profiler.Profiler
-import mozilla.components.browser.engine.gecko.util.SpeculativeSessionFactory
-import mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-import mozilla.components.browser.engine.gecko.webextension.GeckoWebExtensionException
-import mozilla.components.browser.engine.gecko.webnotifications.GeckoWebNotificationDelegate
-import mozilla.components.browser.engine.gecko.webpush.GeckoWebPushDelegate
-import mozilla.components.browser.engine.gecko.webpush.GeckoWebPushHandler
-import mozilla.components.concept.engine.CancellableOperation
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.concept.engine.content.blocking.TrackerLog
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.utils.EngineVersion
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.EnableSource
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.concept.engine.webextension.WebExtensionDelegate
-import mozilla.components.concept.engine.webextension.WebExtensionRuntime
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushHandler
-import mozilla.components.support.ktx.kotlin.isResourceUrl
-import mozilla.components.support.utils.ThreadUtils
-import org.json.JSONObject
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.Event
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebExtensionController
-import java.lang.ref.WeakReference
-
-/**
- * Gecko-based implementation of Engine interface.
- */
-@Suppress("LargeClass")
-class GeckoEngine(
-    context: Context,
-    private val defaultSettings: Settings? = null,
-    private val runtime: GeckoRuntime = GeckoRuntime.getDefault(context),
-    executorProvider: () -> GeckoWebExecutor = { GeckoWebExecutor(runtime) },
-    override val trackingProtectionExceptionStore: TrackingProtectionExceptionStorage =
-        TrackingProtectionExceptionFileStorage(context, runtime)
-) : Engine, WebExtensionRuntime {
-    private val executor by lazy { executorProvider.invoke() }
-    private val localeUpdater = LocaleSettingUpdater(context, runtime)
-    @VisibleForTesting internal val speculativeConnectionFactory = SpeculativeSessionFactory()
-    private var webExtensionDelegate: WebExtensionDelegate? = null
-    private val webExtensionActionHandler = object : ActionHandler {
-        override fun onBrowserAction(extension: WebExtension, session: EngineSession?, action: Action) {
-            webExtensionDelegate?.onBrowserActionDefined(extension, action)
-        }
-
-        override fun onPageAction(extension: WebExtension, session: EngineSession?, action: Action) {
-            webExtensionDelegate?.onPageActionDefined(extension, action)
-        }
-
-        override fun onToggleActionPopup(extension: WebExtension, action: Action): EngineSession? {
-            return webExtensionDelegate?.onToggleActionPopup(extension, GeckoEngineSession(runtime,
-                defaultSettings = defaultSettings), action)
-        }
-    }
-    private val webExtensionTabHandler = object : TabHandler {
-        override fun onNewTab(webExtension: WebExtension, engineSession: EngineSession, active: Boolean, url: String) {
-            webExtensionDelegate?.onNewTab(webExtension, engineSession, active, url)
-        }
-    }
-
-    private var webPushHandler: WebPushHandler? = null
-
-    init {
-        runtime.delegate = GeckoRuntime.Delegate {
-            // On shutdown: The runtime is shutting down (possibly because of an unrecoverable error state). We crash
-            // the app here for two reasons:
-            //  - We want to know about those unsolicited shutdowns and fix those issues.
-            //  - We can't recover easily from this situation. Just continuing will leave us with an engine that
-            //    doesn't do anything anymore.
-            @Suppress("TooGenericExceptionThrown")
-            throw RuntimeException("GeckoRuntime is shutting down")
-        }
-        trackingProtectionExceptionStore.restore()
-    }
-
-    /**
-     * Fetch a list of trackers logged for a given [session] .
-     *
-     * @param session the session where the trackers were logged.
-     * @param onSuccess callback invoked if the data was fetched successfully.
-     * @param onError (optional) callback invoked if fetching the data caused an exception.
-     */
-    override fun getTrackersLog(
-        session: EngineSession,
-        onSuccess: (List<TrackerLog>) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        runtime.contentBlockingController.getLog(geckoSession).then({ contentLogList ->
-            val list = contentLogList ?: emptyList()
-            val logs = list.map { logEntry ->
-                logEntry.toTrackerLog()
-            }.filterNot {
-                !it.cookiesHasBeenBlocked &&
-                    it.blockedCategories.isEmpty() &&
-                    it.loadedCategories.isEmpty()
-            }
-
-            onSuccess(logs)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * Creates a new Gecko-based EngineView.
-     */
-    override fun createView(context: Context, attrs: AttributeSet?): EngineView {
-        return GeckoEngineView(context, attrs).apply {
-            setColorScheme(settings.preferredColorScheme)
-        }
-    }
-
-    /**
-     * See [Engine.createSession].
-     */
-    override fun createSession(private: Boolean, contextId: String?): EngineSession {
-        ThreadUtils.assertOnUiThread()
-        val speculativeSession = speculativeConnectionFactory.get(private, contextId)
-        return speculativeSession ?: GeckoEngineSession(runtime, private, defaultSettings, contextId)
-    }
-
-    /**
-     * See [Engine.createSessionState].
-     */
-    override fun createSessionState(json: JSONObject): EngineSessionState {
-        return GeckoEngineSessionState.fromJSON(json)
-    }
-
-    /**
-     * See [Engine.createSessionStateFrom].
-     */
-    override fun createSessionStateFrom(reader: JsonReader): EngineSessionState {
-        return GeckoEngineSessionState.from(reader)
-    }
-
-    /**
-     * See [Engine.speculativeCreateSession].
-     */
-    override fun speculativeCreateSession(private: Boolean, contextId: String?) {
-        ThreadUtils.assertOnUiThread()
-        speculativeConnectionFactory.create(runtime, private, contextId, defaultSettings)
-    }
-
-    /**
-     * See [Engine.clearSpeculativeSession].
-     */
-    override fun clearSpeculativeSession() {
-        speculativeConnectionFactory.clear()
-    }
-
-    /**
-     * Opens a speculative connection to the host of [url].
-     *
-     * This is useful if an app thinks it may be making a request to that host in the near future. If no request
-     * is made, the connection will be cleaned up after an unspecified.
-     */
-    override fun speculativeConnect(url: String) {
-        executor.speculativeConnect(url)
-    }
-
-    /**
-     * See [Engine.installWebExtension].
-     */
-    override fun installWebExtension(
-        id: String,
-        url: String,
-        onSuccess: ((WebExtension) -> Unit),
-        onError: ((String, Throwable) -> Unit)
-    ): CancellableOperation {
-
-        val onInstallSuccess: ((org.mozilla.geckoview.WebExtension) -> Unit) = {
-            val installedExtension = GeckoWebExtension(it, runtime)
-            webExtensionDelegate?.onInstalled(installedExtension)
-            installedExtension.registerActionHandler(webExtensionActionHandler)
-            installedExtension.registerTabHandler(webExtensionTabHandler, defaultSettings)
-            onSuccess(installedExtension)
-        }
-
-        val geckoResult = if (url.isResourceUrl()) {
-            runtime.webExtensionController.ensureBuiltIn(url, id).apply {
-                then({
-                    onInstallSuccess(it!!)
-                    GeckoResult<Void>()
-                }, { throwable ->
-                    onError(id, throwable)
-                    GeckoResult<Void>()
-                })
-            }
-        } else {
-            runtime.webExtensionController.install(url).apply {
-                then({
-                    onInstallSuccess(it!!)
-                    GeckoResult<Void>()
-                }, { throwable ->
-                    onError(id, throwable)
-                    GeckoResult<Void>()
-                })
-            }
-        }
-        return geckoResult.asCancellableOperation()
-    }
-
-    /**
-     * See [Engine.uninstallWebExtension].
-     */
-    override fun uninstallWebExtension(
-        ext: WebExtension,
-        onSuccess: () -> Unit,
-        onError: (String, Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.uninstall((ext as GeckoWebExtension).nativeExtension).then({
-            webExtensionDelegate?.onUninstalled(ext)
-            onSuccess()
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(ext.id, throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.updateWebExtension].
-     */
-    override fun updateWebExtension(
-        extension: WebExtension,
-        onSuccess: (WebExtension?) -> Unit,
-        onError: (String, Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.update((extension as GeckoWebExtension).nativeExtension).then({ geckoExtension ->
-            val updatedExtension = if (geckoExtension != null) {
-                GeckoWebExtension(geckoExtension, runtime).also {
-                    it.registerActionHandler(webExtensionActionHandler)
-                    it.registerTabHandler(webExtensionTabHandler, defaultSettings)
-                }
-            } else {
-                null
-            }
-            onSuccess(updatedExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(extension.id, GeckoWebExtensionException(throwable))
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.registerWebExtensionDelegate].
-     */
-    @Suppress("Deprecation")
-    override fun registerWebExtensionDelegate(
-        webExtensionDelegate: WebExtensionDelegate
-    ) {
-        this.webExtensionDelegate = webExtensionDelegate
-
-        val promptDelegate = object : WebExtensionController.PromptDelegate {
-            override fun onInstallPrompt(ext: org.mozilla.geckoview.WebExtension): GeckoResult<AllowOrDeny>? {
-                val extension = GeckoWebExtension(ext, runtime)
-                return if (webExtensionDelegate.onInstallPermissionRequest(extension)) {
-                    GeckoResult.allow()
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-
-            override fun onUpdatePrompt(
-                current: org.mozilla.geckoview.WebExtension,
-                updated: org.mozilla.geckoview.WebExtension,
-                newPermissions: Array<out String>,
-                newOrigins: Array<out String>
-            ): GeckoResult<AllowOrDeny>? {
-                val result = GeckoResult<AllowOrDeny>()
-                webExtensionDelegate.onUpdatePermissionRequest(
-                    GeckoWebExtension(current, runtime),
-                    GeckoWebExtension(updated, runtime),
-                    newPermissions.toList() + newOrigins.toList()
-                ) {
-                    allow -> if (allow) result.complete(AllowOrDeny.ALLOW) else result.complete(AllowOrDeny.DENY)
-                }
-                return result
-            }
-        }
-
-        val debuggerDelegate = object : WebExtensionController.DebuggerDelegate {
-            override fun onExtensionListUpdated() {
-                webExtensionDelegate.onExtensionListUpdated()
-            }
-        }
-
-        runtime.webExtensionController.promptDelegate = promptDelegate
-        runtime.webExtensionController.setDebuggerDelegate(debuggerDelegate)
-    }
-
-    /**
-     * See [Engine.listInstalledWebExtensions].
-     */
-    override fun listInstalledWebExtensions(onSuccess: (List<WebExtension>) -> Unit, onError: (Throwable) -> Unit) {
-        runtime.webExtensionController.list().then({
-            val extensions = it?.map {
-                extension -> GeckoWebExtension(extension, runtime)
-            } ?: emptyList()
-
-            extensions.forEach { extension ->
-                extension.registerActionHandler(webExtensionActionHandler)
-                extension.registerTabHandler(webExtensionTabHandler, defaultSettings)
-            }
-
-            onSuccess(extensions)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.enableWebExtension].
-     */
-    override fun enableWebExtension(
-        extension: WebExtension,
-        source: EnableSource,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.enable((extension as GeckoWebExtension).nativeExtension, source.id).then({
-            val enabledExtension = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onEnabled(enabledExtension)
-            onSuccess(enabledExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.disableWebExtension].
-     */
-    override fun disableWebExtension(
-        extension: WebExtension,
-        source: EnableSource,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.disable((extension as GeckoWebExtension).nativeExtension, source.id).then({
-            val disabledExtension = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onDisabled(disabledExtension)
-            onSuccess(disabledExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.setAllowedInPrivateBrowsing].
-     */
-    override fun setAllowedInPrivateBrowsing(
-        extension: WebExtension,
-        allowed: Boolean,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.setAllowedInPrivateBrowsing(
-            (extension as GeckoWebExtension).nativeExtension,
-            allowed
-        ).then({
-            val ext = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onAllowedInPrivateBrowsingChanged(ext)
-            onSuccess(ext)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.registerWebNotificationDelegate].
-     */
-    override fun registerWebNotificationDelegate(
-        webNotificationDelegate: WebNotificationDelegate
-    ) {
-        runtime.webNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-    }
-
-    /**
-     * See [Engine.registerWebPushDelegate].
-     */
-    override fun registerWebPushDelegate(
-        webPushDelegate: WebPushDelegate
-    ): WebPushHandler {
-        runtime.webPushController.setDelegate(GeckoWebPushDelegate(webPushDelegate))
-
-        if (webPushHandler == null) {
-            webPushHandler = GeckoWebPushHandler(runtime)
-        }
-
-        return requireNotNull(webPushHandler)
-    }
-
-    /**
-     * See [Engine.registerActivityDelegate].
-     */
-    override fun registerActivityDelegate(
-        activityDelegate: ActivityDelegate
-    ) {
-        /**
-         * Having the activity delegate on the engine can cause issues with resolving multiple requests to the delegate
-         * from different sessions. Ideally, this should be moved to the [EngineView].
-         *
-         * See: https://bugzilla.mozilla.org/show_bug.cgi?id=1672195
-         *
-         * Attaching the delegate to the Gecko [Engine] implicitly assumes we have WebAuthn support. When a feature
-         * implements the ActivityDelegate today, we need to make sure that it has full support for WebAuthn. This
-         * needs to be fixed in GeckoView.
-         *
-         * See: https://bugzilla.mozilla.org/show_bug.cgi?id=1671988
-         */
-        runtime.activityDelegate = GeckoActivityDelegate(WeakReference(activityDelegate))
-    }
-
-    /**
-     * See [Engine.unregisterActivityDelegate].
-     */
-    override fun unregisterActivityDelegate() {
-        runtime.activityDelegate = null
-    }
-
-    /**
-     * See [Engine.clearData].
-     */
-    override fun clearData(
-        data: Engine.BrowsingData,
-        host: String?,
-        onSuccess: () -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        val flags = data.types.toLong()
-        if (host != null) {
-            runtime.storageController.clearDataFromHost(host, flags)
-        } else {
-            runtime.storageController.clearData(flags)
-        }.then({
-            onSuccess()
-            GeckoResult<Void>()
-        }, {
-            throwable -> onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.profiler].
-     */
-    override val profiler: Profiler? = Profiler(runtime)
-
-    override fun name(): String = "Gecko"
-
-    override val version: EngineVersion = EngineVersion.parse(org.mozilla.geckoview.BuildConfig.MOZILLA_VERSION)
-        ?: throw IllegalStateException("Could not determine engine version")
-
-    /**
-     * See [Engine.settings]
-     */
-    override val settings: Settings = object : Settings() {
-        override var javascriptEnabled: Boolean
-            get() = runtime.settings.javaScriptEnabled
-            set(value) { runtime.settings.javaScriptEnabled = value }
-
-        override var webFontsEnabled: Boolean
-            get() = runtime.settings.webFontsEnabled
-            set(value) { runtime.settings.webFontsEnabled = value }
-
-        override var automaticFontSizeAdjustment: Boolean
-            get() = runtime.settings.automaticFontSizeAdjustment
-            set(value) { runtime.settings.automaticFontSizeAdjustment = value }
-
-        override var automaticLanguageAdjustment: Boolean
-            get() = localeUpdater.enabled
-            set(value) {
-                localeUpdater.enabled = value
-                defaultSettings?.automaticLanguageAdjustment = value
-            }
-
-        override var safeBrowsingPolicy: Array<SafeBrowsingPolicy> =
-            arrayOf(SafeBrowsingPolicy.RECOMMENDED)
-            set(value) {
-                val policy = value.sumBy { it.id }
-                runtime.settings.contentBlocking.setSafeBrowsing(policy)
-                field = value
-            }
-
-        override var trackingProtectionPolicy: TrackingProtectionPolicy? = null
-            set(value) {
-                value?.let { policy ->
-                    with(runtime.settings.contentBlocking) {
-                        if (enhancedTrackingProtectionLevel != value.getEtpLevel()) {
-                            enhancedTrackingProtectionLevel = value.getEtpLevel()
-                        }
-
-                        if (strictSocialTrackingProtection != value.getStrictSocialTrackingProtection()) {
-                            strictSocialTrackingProtection = policy.getStrictSocialTrackingProtection()
-                        }
-
-                        if (antiTrackingCategories != value.getAntiTrackingPolicy()) {
-                            setAntiTracking(policy.getAntiTrackingPolicy())
-                        }
-
-                        if (cookieBehavior != value.cookiePolicy.id) {
-                            cookieBehavior = value.cookiePolicy.id
-                        }
-
-                        if (cookiePurging != value.cookiePurging) {
-                            setCookiePurging(value.cookiePurging)
-                        }
-                    }
-
-                    defaultSettings?.trackingProtectionPolicy = value
-                    field = value
-                }
-            }
-
-        override var remoteDebuggingEnabled: Boolean
-            get() = runtime.settings.remoteDebuggingEnabled
-            set(value) { runtime.settings.remoteDebuggingEnabled = value }
-
-        override var historyTrackingDelegate: HistoryTrackingDelegate?
-            get() = defaultSettings?.historyTrackingDelegate
-            set(value) { defaultSettings?.historyTrackingDelegate = value }
-
-        override var testingModeEnabled: Boolean
-            get() = defaultSettings?.testingModeEnabled ?: false
-            set(value) { defaultSettings?.testingModeEnabled = value }
-
-        override var userAgentString: String?
-            get() = defaultSettings?.userAgentString ?: GeckoSession.getDefaultUserAgent()
-            set(value) { defaultSettings?.userAgentString = value }
-
-        override var preferredColorScheme: PreferredColorScheme
-            get() = PreferredColorScheme.from(runtime.settings.preferredColorScheme)
-            set(value) { runtime.settings.preferredColorScheme = value.toGeckoValue() }
-
-        override var suspendMediaWhenInactive: Boolean
-            get() = defaultSettings?.suspendMediaWhenInactive ?: false
-            set(value) { defaultSettings?.suspendMediaWhenInactive = value }
-
-        override var clearColor: Int?
-            get() = defaultSettings?.clearColor
-            set(value) { defaultSettings?.clearColor = value }
-
-        override var fontInflationEnabled: Boolean?
-            get() = runtime.settings.fontInflationEnabled
-            set(value) {
-                // automaticFontSizeAdjustment is set to true by default, which
-                // will cause an exception if fontInflationEnabled is set
-                // (to either true or false). We therefore need to be able to
-                // set our built-in default value to null so that the exception
-                // is only thrown if an app is configured incorrectly but not
-                // if it uses default values.
-                value?.let {
-                    runtime.settings.fontInflationEnabled = it
-                }
-            }
-
-        override var fontSizeFactor: Float?
-            get() = runtime.settings.fontSizeFactor
-            set(value) {
-                // automaticFontSizeAdjustment is set to true by default, which
-                // will cause an exception if fontSizeFactor is set as well.
-                // We therefore need to be able to set our built-in default value
-                // to null so that the exception is only thrown if an app is
-                // configured incorrectly but not if it uses default values.
-                value?.let {
-                    runtime.settings.fontSizeFactor = it
-                }
-            }
-
-        override var loginAutofillEnabled: Boolean
-            get() = runtime.settings.loginAutofillEnabled
-            set(value) { runtime.settings.loginAutofillEnabled = value }
-
-        override var forceUserScalableContent: Boolean
-            get() = runtime.settings.forceUserScalableEnabled
-            set(value) { runtime.settings.forceUserScalableEnabled = value }
-    }.apply {
-        defaultSettings?.let {
-            this.javascriptEnabled = it.javascriptEnabled
-            this.webFontsEnabled = it.webFontsEnabled
-            this.automaticFontSizeAdjustment = it.automaticFontSizeAdjustment
-            this.automaticLanguageAdjustment = it.automaticLanguageAdjustment
-            this.trackingProtectionPolicy = it.trackingProtectionPolicy
-            this.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.RECOMMENDED)
-            this.remoteDebuggingEnabled = it.remoteDebuggingEnabled
-            this.testingModeEnabled = it.testingModeEnabled
-            this.userAgentString = it.userAgentString
-            this.preferredColorScheme = it.preferredColorScheme
-            this.fontInflationEnabled = it.fontInflationEnabled
-            this.fontSizeFactor = it.fontSizeFactor
-            this.forceUserScalableContent = it.forceUserScalableContent
-            this.clearColor = it.clearColor
-            this.loginAutofillEnabled = it.loginAutofillEnabled
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun ContentBlockingController.LogEntry.BlockingData.getLoadedCategory(): TrackingCategory {
-        val socialTrackingProtectionEnabled = settings.trackingProtectionPolicy?.strictSocialTrackingProtection
-                ?: false
-
-        return when (category) {
-            Event.LOADED_FINGERPRINTING_CONTENT -> TrackingCategory.FINGERPRINTING
-            Event.LOADED_CRYPTOMINING_CONTENT -> TrackingCategory.CRYPTOMINING
-            Event.LOADED_SOCIALTRACKING_CONTENT -> {
-                if (socialTrackingProtectionEnabled) TrackingCategory.MOZILLA_SOCIAL else TrackingCategory.NONE
-            }
-            Event.COOKIES_LOADED_SOCIALTRACKER -> {
-                if (!socialTrackingProtectionEnabled) TrackingCategory.MOZILLA_SOCIAL else TrackingCategory.NONE
-            }
-            Event.LOADED_LEVEL_1_TRACKING_CONTENT -> TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-            Event.LOADED_LEVEL_2_TRACKING_CONTENT -> {
-
-                // We are making sure that we are only showing trackers that our settings are
-                // taking into consideration.
-                val isContentListActive =
-                    settings.trackingProtectionPolicy?.contains(TrackingCategory.CONTENT)
-                        ?: false
-                val isStrictLevelActive =
-                    runtime.settings
-                        .contentBlocking
-                        .getEnhancedTrackingProtectionLevel() == ContentBlocking.EtpLevel.STRICT
-
-                if (isStrictLevelActive && isContentListActive) {
-                    TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-                } else {
-                    TrackingCategory.NONE
-                }
-            }
-            else -> TrackingCategory.NONE
-        }
-    }
-
-    private fun isCategoryActive(category: TrackingCategory) = settings.trackingProtectionPolicy?.contains(category)
-        ?: false
-
-    /**
-     * Mimics the behavior for categorizing trackers from desktop, they should be kept in sync,
-     * as differences will result in improper categorization for trackers.
-     * https://dxr.mozilla.org/mozilla-central/source/browser/base/content/browser-siteProtections.js
-     */
-    internal fun ContentBlockingController.LogEntry.toTrackerLog(): TrackerLog {
-        val cookiesHasBeenBlocked = this.blockingData.any { it.hasBlockedCookies() }
-        val blockedCategories = blockingData.map { it.getBlockedCategory() }
-            .filterNot { it == TrackingCategory.NONE }
-            .distinct()
-        val loadedCategories = blockingData.map { it.getLoadedCategory() }
-            .filterNot { it == TrackingCategory.NONE }
-            .distinct()
-        /**
-         *  When a resource is shimmed we'll received a [REPLACED_UNSAFE_CONTENT] event with
-         *  the quantity [BlockingData.count] of categories that were shimmed, but it doesn't
-         *  specify which ones, it only tells us how many. For example:
-         *     {
-         *      "category": REPLACED_TRACKING_CONTENT,
-         *      "count": 2
-         *     }
-         *
-         *  This indicates that there are 2 categories that were shimmed, as a result
-         *  we have to infer based on the categories that are active vs the amount of
-         *  shimmed categories, for example:
-         *
-         *     "blockData": [
-         *      {
-         *          "category": LOADED_LEVEL_1_TRACKING_CONTENT,
-         *          "count": 1
-         *      },
-         *      {
-         *          "category": LOADED_SOCIALTRACKING_CONTENT,
-         *          "count": 1
-         *      },
-         *      {
-         *          "category": REPLACED_TRACKING_CONTENT,
-         *          "count": 2
-         *      }
-         *     ]
-         *  This indicates that categories [LOADED_LEVEL_1_TRACKING_CONTENT] and
-         *  [LOADED_SOCIALTRACKING_CONTENT] were loaded but shimmed and we should display them
-         *  as blocked instead of loaded.
-         */
-        val shimmedCount = blockingData.find {
-            it.category == Event.REPLACED_TRACKING_CONTENT
-        }?.count ?: 0
-
-        // If we find blocked categories that are loaded it means they were shimmed.
-        val shimmedCategories = loadedCategories.filter { isCategoryActive(it) }
-            .take(shimmedCount)
-
-        // We have to remove the categories that are shimmed from the loaded list and
-        // put them back in the blocked list.
-        return TrackerLog(
-            url = origin,
-            loadedCategories = loadedCategories.filterNot { it in shimmedCategories },
-            blockedCategories = (blockedCategories + shimmedCategories).distinct(),
-            cookiesHasBeenBlocked = cookiesHasBeenBlocked
-        )
-    }
-}
-
-internal fun ContentBlockingController.LogEntry.BlockingData.hasBlockedCookies(): Boolean {
-    return category == Event.COOKIES_BLOCKED_BY_PERMISSION ||
-        category == Event.COOKIES_BLOCKED_TRACKER ||
-        category == Event.COOKIES_BLOCKED_ALL ||
-        category == Event.COOKIES_PARTITIONED_FOREIGN ||
-        category == Event.COOKIES_BLOCKED_FOREIGN ||
-        category == Event.COOKIES_BLOCKED_SOCIALTRACKER
-}
-
-// There is going to be a patch from GV for adding [REPLACED_UNSAFE_CONTENT] as
-// a valid option for [BlockingData.category]
-// https://bugzilla.mozilla.org/show_bug.cgi?id=1669577
-@SuppressLint("SwitchIntDef")
-internal fun ContentBlockingController.LogEntry.BlockingData.getBlockedCategory(): TrackingCategory {
-    return when (category) {
-        Event.BLOCKED_FINGERPRINTING_CONTENT -> TrackingCategory.FINGERPRINTING
-        Event.BLOCKED_CRYPTOMINING_CONTENT -> TrackingCategory.CRYPTOMINING
-        Event.BLOCKED_SOCIALTRACKING_CONTENT, Event.COOKIES_BLOCKED_SOCIALTRACKER -> TrackingCategory.MOZILLA_SOCIAL
-        Event.BLOCKED_TRACKING_CONTENT -> TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-        else -> TrackingCategory.NONE
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt
deleted file mode 100644
index 60a883261c66..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt
+++ /dev/null
@@ -1,1118 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.annotation.SuppressLint
-import android.net.Uri
-import android.os.Build
-import android.view.WindowManager
-import androidx.annotation.VisibleForTesting
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.MainScope
-import kotlinx.coroutines.launch
-import mozilla.components.browser.engine.gecko.fetch.toResponse
-import mozilla.components.browser.engine.gecko.mediasession.GeckoMediaSessionDelegate
-import mozilla.components.browser.engine.gecko.permission.GeckoPermissionRequest
-import mozilla.components.browser.engine.gecko.prompt.GeckoPromptDelegate
-import mozilla.components.browser.engine.gecko.window.GeckoWindowRequest
-import mozilla.components.browser.errorpages.ErrorType
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.HitResult
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.content.blocking.Tracker
-import mozilla.components.concept.engine.history.HistoryItem
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.manifest.WebAppManifestParser
-import mozilla.components.concept.engine.request.RequestInterceptor
-import mozilla.components.concept.engine.request.RequestInterceptor.InterceptionResponse
-import mozilla.components.concept.engine.window.WindowRequest
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_DISPOSITION
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_LENGTH
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_TYPE
-import mozilla.components.concept.storage.PageVisit
-import mozilla.components.concept.storage.RedirectSource
-import mozilla.components.concept.storage.VisitType
-import mozilla.components.support.base.Component
-import mozilla.components.support.base.facts.Action
-import mozilla.components.support.base.facts.Fact
-import mozilla.components.support.base.facts.collect
-import mozilla.components.support.base.log.logger.Logger
-import mozilla.components.support.ktx.kotlin.isEmail
-import mozilla.components.support.ktx.kotlin.isExtensionUrl
-import mozilla.components.support.ktx.kotlin.isGeoLocation
-import mozilla.components.support.ktx.kotlin.isPhone
-import mozilla.components.support.ktx.kotlin.sanitizeFileName
-import mozilla.components.support.ktx.kotlin.tryGetHostFromUrl
-import mozilla.components.support.utils.DownloadUtils
-import org.json.JSONObject
-import org.mozilla.geckoview.WebResponse
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.NavigationDelegate
-import org.mozilla.geckoview.GeckoSessionSettings
-import org.mozilla.geckoview.WebRequestError
-import java.util.Locale
-import kotlin.coroutines.CoroutineContext
-
-/**
- * Gecko-based EngineSession implementation.
- */
-@Suppress("TooManyFunctions", "LargeClass")
-class GeckoEngineSession(
-    private val runtime: GeckoRuntime,
-    private val privateMode: Boolean = false,
-    private val defaultSettings: Settings? = null,
-    contextId: String? = null,
-    private val geckoSessionProvider: () -> GeckoSession = {
-        val settings = GeckoSessionSettings.Builder()
-            .usePrivateMode(privateMode)
-            .contextId(contextId)
-            .build()
-        GeckoSession(settings)
-    },
-    private val context: CoroutineContext = Dispatchers.IO,
-    openGeckoSession: Boolean = true
-) : CoroutineScope, EngineSession() {
-
-    // This logger is temporary and parsed by FNPRMS for performance measurements. It can be
-    // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-    // It mimics GeckoView debug log statements, hence the unintuitive tag and messages.
-    private val fnprmsLogger = Logger("GeckoSession")
-
-    private val logger = Logger("GeckoEngineSession")
-
-    internal lateinit var geckoSession: GeckoSession
-    internal var currentUrl: String? = null
-    internal var lastLoadRequestUri: String? = null
-    internal var pageLoadingUrl: String? = null
-    internal var scrollY: Int = 0
-
-    internal var job: Job = Job()
-    private var canGoBack: Boolean = false
-
-    /**
-     * See [EngineSession.settings]
-     */
-    override val settings: Settings = object : Settings() {
-        override var requestInterceptor: RequestInterceptor? = null
-        override var historyTrackingDelegate: HistoryTrackingDelegate? = null
-        override var userAgentString: String?
-            get() = geckoSession.settings.userAgentOverride
-            set(value) { geckoSession.settings.userAgentOverride = value }
-        override var suspendMediaWhenInactive: Boolean
-            get() = geckoSession.settings.suspendMediaWhenInactive
-            set(value) { geckoSession.settings.suspendMediaWhenInactive = value }
-    }
-
-    internal var initialLoad = true
-
-    override val coroutineContext: CoroutineContext
-        get() = context + job
-
-    init {
-        createGeckoSession(shouldOpen = openGeckoSession)
-    }
-
-    /**
-     * Represents a request to load a [url].
-     *
-     * @param url the url to load.
-     * @param parent the parent (referring) [EngineSession] i.e. the session that
-     * triggered creating this one.
-     * @param flags the [LoadUrlFlags] to use when loading the provided url.
-     * @param additionalHeaders the extra headers to use when loading the provided url.
-     **/
-    data class LoadRequest(
-        val url: String,
-        val parent: EngineSession?,
-        val flags: LoadUrlFlags,
-        val additionalHeaders: Map<String, String>?
-    )
-    @VisibleForTesting
-    internal var initialLoadRequest: LoadRequest? = null
-
-    /**
-     * See [EngineSession.loadUrl]
-     */
-    override fun loadUrl(
-        url: String,
-        parent: EngineSession?,
-        flags: LoadUrlFlags,
-        additionalHeaders: Map<String, String>?
-    ) {
-        val scheme = Uri.parse(url).normalizeScheme().scheme
-        if (BLOCKED_SCHEMES.contains(scheme)) {
-            logger.error("URL scheme not allowed. Aborting load.")
-            return
-        }
-
-        if (initialLoad) {
-            initialLoadRequest = LoadRequest(url, parent, flags, additionalHeaders)
-        }
-
-        val loader = GeckoSession.Loader()
-            .uri(url)
-            .flags(flags.value)
-
-        if (additionalHeaders != null) {
-            loader.additionalHeaders(additionalHeaders)
-                .headerFilter(GeckoSession.HEADER_FILTER_CORS_SAFELISTED)
-        }
-
-        if (parent != null) {
-            loader.referrer((parent as GeckoEngineSession).geckoSession)
-        }
-
-        geckoSession.load(loader)
-        Fact(Component.BROWSER_ENGINE_GECKO_BETA, Action.IMPLEMENTATION_DETAIL, "GeckoSession.load").collect()
-    }
-
-    /**
-     * See [EngineSession.loadData]
-     */
-    override fun loadData(data: String, mimeType: String, encoding: String) {
-        when (encoding) {
-            "base64" -> geckoSession.load(GeckoSession.Loader().data(data.toByteArray(), mimeType))
-            else -> geckoSession.load(GeckoSession.Loader().data(data, mimeType))
-        }
-    }
-
-    /**
-     * See [EngineSession.stopLoading]
-     */
-    override fun stopLoading() {
-        geckoSession.stop()
-    }
-
-    /**
-     * See [EngineSession.reload]
-     */
-    override fun reload(flags: LoadUrlFlags) {
-        initialLoadRequest?.let {
-            // We have a pending initial load request, which means we never
-            // successfully loaded a page. Calling reload now would just reload
-            // about:blank. To prevent that we trigger the initial load again.
-            loadUrl(it.url, it.parent, it.flags, it.additionalHeaders)
-        } ?: geckoSession.reload(flags.value)
-    }
-
-    /**
-     * See [EngineSession.goBack]
-     */
-    override fun goBack() {
-        geckoSession.goBack()
-        if (canGoBack) {
-            notifyObservers { onNavigateBack() }
-        }
-    }
-    /**
-     * See [EngineSession.goForward]
-     */
-    override fun goForward() {
-        geckoSession.goForward()
-    }
-
-    /**
-     * See [EngineSession.goToHistoryIndex]
-     */
-    override fun goToHistoryIndex(index: Int) {
-        geckoSession.gotoHistoryIndex(index)
-    }
-
-    /**
-     * See [EngineSession.restoreState]
-     */
-    override fun restoreState(state: EngineSessionState): Boolean {
-        if (state !is GeckoEngineSessionState) {
-            throw IllegalStateException("Can only restore from GeckoEngineSessionState")
-        }
-        // Also checking if SessionState is empty as a workaround for:
-        // https://bugzilla.mozilla.org/show_bug.cgi?id=1687523
-        if (state.actualState.isNullOrEmpty()) {
-            return false
-        }
-
-        geckoSession.restoreState(state.actualState)
-        return true
-    }
-
-    /**
-     * See [EngineSession.updateTrackingProtection]
-     */
-    override fun updateTrackingProtection(policy: TrackingProtectionPolicy) {
-        updateContentBlocking(policy)
-        val enabled = policy != TrackingProtectionPolicy.none()
-        etpEnabled = enabled
-        notifyObservers {
-            onTrackerBlockingEnabledChange(this, enabled)
-        }
-    }
-
-    @VisibleForTesting
-    internal fun updateContentBlocking(policy: TrackingProtectionPolicy) {
-        /**
-         * As described on https://bugzilla.mozilla.org/show_bug.cgi?id=1579264,useTrackingProtection
-         * is a misleading setting. When is set to true is blocking content (scripts/sub-resources).
-         * Instead of just turn on/off tracking protection. Until, this issue is fixed consumers need
-         * a way to indicate, if they want to block content or not, this is why we use
-         * [TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES].
-         */
-        val shouldBlockContent =
-            policy.contains(TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)
-
-        val enabledInBrowsingMode = if (privateMode) {
-            policy.useForPrivateSessions
-        } else {
-            policy.useForRegularSessions
-        }
-        geckoSession.settings.useTrackingProtection = enabledInBrowsingMode && shouldBlockContent
-    }
-
-    // This is a temporary solution to address
-    // https://github.com/mozilla-mobile/android-components/issues/8431
-    // until we eventually delete [EngineObserver] then this will not be needed.
-    @VisibleForTesting internal var etpEnabled: Boolean? = null
-
-    override fun register(observer: Observer) {
-        super.register(observer)
-        etpEnabled?.let { enabled ->
-            onTrackerBlockingEnabledChange(observer, enabled)
-        }
-    }
-
-    private fun onTrackerBlockingEnabledChange(observer: Observer, enabled: Boolean) {
-        // We now register engine observers in a middleware using a dedicated
-        // store thread. Since this notification can be delayed until an observer
-        // is registered we switch to the main scope to make sure we're not notifying
-        // on the store thread.
-        MainScope().launch {
-            observer.onTrackerBlockingEnabledChange(enabled)
-        }
-    }
-
-    /**
-     * Indicates if this [EngineSession] should be ignored the tracking protection policies.
-     * @param onResult A callback to inform if this [EngineSession] is in
-     * the exception list, true if it is in, otherwise false.
-     */
-    internal fun isIgnoredForTrackingProtection(onResult: (Boolean) -> Unit) {
-        runtime.contentBlockingController.checkException(geckoSession).accept {
-            if (it != null) {
-                onResult(it)
-            } else {
-                onResult(false)
-            }
-        }
-    }
-
-    /**
-     * See [EngineSession.settings]
-     */
-    override fun toggleDesktopMode(enable: Boolean, reload: Boolean) {
-        val currentMode = geckoSession.settings.userAgentMode
-        val currentViewPortMode = geckoSession.settings.viewportMode
-        var overrideUrl: String? = null
-
-        val newMode = if (enable) {
-            GeckoSessionSettings.USER_AGENT_MODE_DESKTOP
-        } else {
-            GeckoSessionSettings.USER_AGENT_MODE_MOBILE
-        }
-
-        val newViewportMode = if (enable) {
-            overrideUrl = currentUrl?.let { checkForMobileSite(it) }
-            GeckoSessionSettings.VIEWPORT_MODE_DESKTOP
-        } else {
-            GeckoSessionSettings.VIEWPORT_MODE_MOBILE
-        }
-
-        if (newMode != currentMode || newViewportMode != currentViewPortMode) {
-            geckoSession.settings.userAgentMode = newMode
-            geckoSession.settings.viewportMode = newViewportMode
-            notifyObservers { onDesktopModeChange(enable) }
-        }
-
-        if (reload) {
-            if (overrideUrl == null) {
-                this.reload()
-            } else {
-                loadUrl(overrideUrl, flags = LoadUrlFlags.select(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY))
-            }
-        }
-    }
-
-    /**
-     * Checks and returns a non-mobile version of the url.
-     */
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun checkForMobileSite(url: String): String? {
-        var overrideUrl: String? = null
-        val mPrefix = "m."
-        val mobilePrefix = "mobile."
-
-        val uri = Uri.parse(url)
-        val authority = uri.authority?.toLowerCase(Locale.ROOT) ?: return null
-
-        val foundPrefix = when {
-            authority.startsWith(mPrefix) -> mPrefix
-            authority.startsWith(mobilePrefix) -> mobilePrefix
-            else -> null
-        }
-
-        foundPrefix?.let {
-            val mobileUri = Uri.parse(url).buildUpon().authority(authority.substring(it.length))
-            overrideUrl = mobileUri.toString()
-        }
-
-        return overrideUrl
-    }
-
-    /**
-     * See [EngineSession.findAll]
-     */
-    override fun findAll(text: String) {
-        notifyObservers { onFind(text) }
-        geckoSession.finder.find(text, 0).then { result: GeckoSession.FinderResult? ->
-            result?.let {
-                val activeMatchOrdinal = if (it.current > 0) it.current - 1 else it.current
-                notifyObservers { onFindResult(activeMatchOrdinal, it.total, true) }
-            }
-            GeckoResult<Void>()
-        }
-    }
-
-    /**
-     * See [EngineSession.findNext]
-     */
-    @SuppressLint("WrongConstant") // FinderFindFlags annotation doesn't include a 0 value.
-    override fun findNext(forward: Boolean) {
-        val findFlags = if (forward) 0 else GeckoSession.FINDER_FIND_BACKWARDS
-        geckoSession.finder.find(null, findFlags).then { result: GeckoSession.FinderResult? ->
-            result?.let {
-                val activeMatchOrdinal = if (it.current > 0) it.current - 1 else it.current
-                notifyObservers { onFindResult(activeMatchOrdinal, it.total, true) }
-            }
-            GeckoResult<Void>()
-        }
-    }
-
-    /**
-     * See [EngineSession.clearFindMatches]
-     */
-    override fun clearFindMatches() {
-        geckoSession.finder.clear()
-    }
-
-    /**
-     * See [EngineSession.exitFullScreenMode]
-     */
-    override fun exitFullScreenMode() {
-        geckoSession.exitFullScreen()
-    }
-
-    /**
-     * See [EngineSession.markActiveForWebExtensions].
-     */
-    override fun markActiveForWebExtensions(active: Boolean) {
-        runtime.webExtensionController.setTabActive(geckoSession, active)
-    }
-
-    /**
-     * Purges the history for the session (back and forward history).
-     */
-    override fun purgeHistory() {
-        geckoSession.purgeHistory()
-    }
-
-    /**
-     * See [EngineSession.close].
-     */
-    override fun close() {
-        super.close()
-        job.cancel()
-        geckoSession.close()
-    }
-
-    /**
-     * NavigationDelegate implementation for forwarding callbacks to observers of the session.
-     */
-    @Suppress("ComplexMethod")
-    private fun createNavigationDelegate() = object : GeckoSession.NavigationDelegate {
-        override fun onLocationChange(session: GeckoSession, url: String?) {
-            if (url == null) {
-                return // \_()_/
-            }
-
-            // Ignore initial loads of about:blank, see:
-            // https://github.com/mozilla-mobile/android-components/issues/403
-            // https://github.com/mozilla-mobile/android-components/issues/6832
-            if (initialLoad && url == ABOUT_BLANK) {
-                return
-            }
-
-            currentUrl = url
-            initialLoad = false
-            initialLoadRequest = null
-
-            isIgnoredForTrackingProtection { ignored ->
-                notifyObservers {
-                    onExcludedOnTrackingProtectionChange(ignored)
-                }
-            }
-            notifyObservers { onLocationChange(url) }
-        }
-
-        override fun onLoadRequest(
-            session: GeckoSession,
-            request: NavigationDelegate.LoadRequest
-        ): GeckoResult<AllowOrDeny> {
-            // The process switch involved when loading extension pages will
-            // trigger an initial load of about:blank which we want to
-            // avoid:
-            // https://github.com/mozilla-mobile/android-components/issues/6832
-            // https://github.com/mozilla-mobile/android-components/issues/403
-            if (currentUrl?.isExtensionUrl() != request.uri.isExtensionUrl()) {
-                initialLoad = true
-            }
-
-            return when {
-                maybeInterceptRequest(request, false) != null ->
-                    GeckoResult.fromValue(AllowOrDeny.DENY)
-                request.target == NavigationDelegate.TARGET_WINDOW_NEW ->
-                    GeckoResult.fromValue(AllowOrDeny.ALLOW)
-                else -> {
-                    notifyObservers {
-                        onLoadRequest(
-                            url = request.uri,
-                            triggeredByRedirect = request.isRedirect,
-                            triggeredByWebContent = request.hasUserGesture
-                        )
-                    }
-
-                    GeckoResult.fromValue(AllowOrDeny.ALLOW)
-                }
-            }
-        }
-
-        override fun onSubframeLoadRequest(
-            session: GeckoSession,
-            request: NavigationDelegate.LoadRequest
-        ): GeckoResult<AllowOrDeny> {
-            if (request.target == NavigationDelegate.TARGET_WINDOW_NEW) {
-                return GeckoResult.fromValue(AllowOrDeny.ALLOW)
-            }
-
-            return if (maybeInterceptRequest(request, true) != null) {
-                GeckoResult.fromValue(AllowOrDeny.DENY)
-            } else {
-                // Not notifying session observer because of performance concern and currently there
-                // is no use case.
-                GeckoResult.fromValue(AllowOrDeny.ALLOW)
-            }
-        }
-
-        override fun onCanGoForward(session: GeckoSession, canGoForward: Boolean) {
-            notifyObservers { onNavigationStateChange(canGoForward = canGoForward) }
-        }
-
-        override fun onCanGoBack(session: GeckoSession, canGoBack: Boolean) {
-            notifyObservers { onNavigationStateChange(canGoBack = canGoBack) }
-            this@GeckoEngineSession.canGoBack = canGoBack
-        }
-
-        override fun onNewSession(
-            session: GeckoSession,
-            uri: String
-        ): GeckoResult<GeckoSession> {
-            val newEngineSession = GeckoEngineSession(runtime, privateMode, defaultSettings, openGeckoSession = false)
-            notifyObservers {
-                MainScope().launch {
-                    onWindowRequest(GeckoWindowRequest(uri, newEngineSession))
-                }
-            }
-            return GeckoResult.fromValue(newEngineSession.geckoSession)
-        }
-
-        override fun onLoadError(
-            session: GeckoSession,
-            uri: String?,
-            error: WebRequestError
-        ): GeckoResult<String> {
-            val response = settings.requestInterceptor?.onErrorRequest(
-                this@GeckoEngineSession,
-                geckoErrorToErrorType(error.code),
-                uri
-            )
-            return GeckoResult.fromValue(response?.uri)
-        }
-
-        private fun maybeInterceptRequest(
-            request: NavigationDelegate.LoadRequest,
-            isSubframeRequest: Boolean
-        ): InterceptionResponse? {
-            val interceptor = settings.requestInterceptor
-            val interceptionResponse = if (
-                interceptor != null && (!request.isDirectNavigation || interceptor.interceptsAppInitiatedRequests())
-            ) {
-                val engineSession = this@GeckoEngineSession
-                val isSameDomain = engineSession.currentUrl?.tryGetHostFromUrl() == request.uri.tryGetHostFromUrl()
-                interceptor.onLoadRequest(
-                    engineSession,
-                    request.uri,
-                    lastLoadRequestUri,
-                    request.hasUserGesture,
-                    isSameDomain,
-                    request.isRedirect,
-                    request.isDirectNavigation,
-                    isSubframeRequest
-                )?.apply {
-                    when (this) {
-                        is InterceptionResponse.Content -> loadData(data, mimeType, encoding)
-                        is InterceptionResponse.Url -> loadUrl(url)
-                        is InterceptionResponse.AppIntent -> {
-                            notifyObservers {
-                                onLaunchIntentRequest(url = url, appIntent = appIntent)
-                            }
-                        }
-                    }
-                }
-            } else {
-                null
-            }
-
-            lastLoadRequestUri = request.uri
-            return interceptionResponse
-        }
-    }
-
-    /**
-     * ProgressDelegate implementation for forwarding callbacks to observers of the session.
-     */
-    private fun createProgressDelegate() = object : GeckoSession.ProgressDelegate {
-        override fun onProgressChange(session: GeckoSession, progress: Int) {
-            notifyObservers { onProgress(progress) }
-        }
-
-        override fun onSecurityChange(
-            session: GeckoSession,
-            securityInfo: GeckoSession.ProgressDelegate.SecurityInformation
-        ) {
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && securityInfo.origin?.startsWith(MOZ_NULL_PRINCIPAL) == true) {
-                return
-            }
-
-            notifyObservers {
-                // TODO provide full certificate info: https://github.com/mozilla-mobile/android-components/issues/5557
-                onSecurityChange(securityInfo.isSecure, securityInfo.host, securityInfo.getIssuerName())
-            }
-        }
-
-        override fun onPageStart(session: GeckoSession, url: String) {
-            // This log statement is temporary and parsed by FNPRMS for performance measurements. It can be
-            // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-            fnprmsLogger.info("handleMessage GeckoView:PageStart uri=") // uri intentionally blank
-
-            pageLoadingUrl = url
-
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && url == ABOUT_BLANK) {
-                return
-            }
-
-            notifyObservers {
-                onProgress(PROGRESS_START)
-                onLoadingStateChange(true)
-            }
-        }
-
-        override fun onPageStop(session: GeckoSession, success: Boolean) {
-            // This log statement is temporary and parsed by FNPRMS for performance measurements. It can be
-            // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-            fnprmsLogger.info("handleMessage GeckoView:PageStop uri=null") // uri intentionally hard-coded to null
-            // by the time we reach here, any new request will come from web content.
-            // If it comes from the chrome, loadUrl(url) or loadData(string) will set it to
-            // false.
-
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && pageLoadingUrl == ABOUT_BLANK) {
-                return
-            }
-
-            notifyObservers {
-                onProgress(PROGRESS_STOP)
-                onLoadingStateChange(false)
-            }
-        }
-
-        override fun onSessionStateChange(session: GeckoSession, sessionState: GeckoSession.SessionState) {
-            notifyObservers {
-                onStateUpdated(GeckoEngineSessionState(sessionState))
-            }
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun createHistoryDelegate() = object : GeckoSession.HistoryDelegate {
-        @SuppressWarnings("ReturnCount")
-        override fun onVisited(
-            session: GeckoSession,
-            url: String,
-            lastVisitedURL: String?,
-            flags: Int
-        ): GeckoResult<Boolean>? {
-            // Don't track:
-            // - private visits
-            // - error pages
-            // - non-top level visits (i.e. iframes).
-            if (privateMode ||
-                (flags and GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL) == 0 ||
-                (flags and GeckoSession.HistoryDelegate.VISIT_UNRECOVERABLE_ERROR) != 0) {
-                return GeckoResult.fromValue(false)
-            }
-
-            val isReload = lastVisitedURL?.let { it == url } ?: false
-
-            val visitType = if (isReload) {
-                VisitType.RELOAD
-            } else {
-                // Note the difference between `VISIT_REDIRECT_PERMANENT`,
-                // `VISIT_REDIRECT_TEMPORARY`, `VISIT_REDIRECT_SOURCE`, and
-                // `VISIT_REDIRECT_SOURCE_PERMANENT`.
-                //
-                // The former two indicate if the visited page is the *target*
-                // of a redirect; that is, another page redirected to it.
-                //
-                // The latter two indicate if the visited page is the *source*
-                // of a redirect: it's redirecting to another page, because the
-                // server returned an HTTP 3xy status code.
-                if (flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_PERMANENT != 0) {
-                    VisitType.REDIRECT_PERMANENT
-                } else if (flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY != 0) {
-                    VisitType.REDIRECT_TEMPORARY
-                } else {
-                    VisitType.LINK
-                }
-            }
-            val redirectSource = when {
-                flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE_PERMANENT != 0 ->
-                    RedirectSource.PERMANENT
-                flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE != 0 ->
-                    RedirectSource.TEMPORARY
-                else -> RedirectSource.NOT_A_SOURCE
-            }
-
-            val delegate = settings.historyTrackingDelegate ?: return GeckoResult.fromValue(false)
-
-            // Check if the delegate wants this type of url.
-            if (!delegate.shouldStoreUri(url)) {
-                return GeckoResult.fromValue(false)
-            }
-
-            return launchGeckoResult {
-                delegate.onVisited(url, PageVisit(visitType, redirectSource))
-                true
-            }
-        }
-
-        override fun getVisited(
-            session: GeckoSession,
-            urls: Array<out String>
-        ): GeckoResult<BooleanArray>? {
-            if (privateMode) {
-                return GeckoResult.fromValue(null)
-            }
-
-            val delegate = settings.historyTrackingDelegate ?: return GeckoResult.fromValue(null)
-
-            return launchGeckoResult {
-                val visits = delegate.getVisited(urls.toList())
-                visits.toBooleanArray()
-            }
-        }
-
-        override fun onHistoryStateChange(
-            session: GeckoSession,
-            historyList: GeckoSession.HistoryDelegate.HistoryList
-        ) {
-            val items = historyList.map {
-                // title is sometimes null despite the @NotNull annotation
-                // https://bugzilla.mozilla.org/show_bug.cgi?id=1660286
-                val title: String? = it.title
-                HistoryItem(
-                    title = title ?: it.uri,
-                    uri = it.uri
-                )
-            }
-            notifyObservers { onHistoryStateChanged(items, historyList.currentIndex) }
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun createContentDelegate() = object : GeckoSession.ContentDelegate {
-        override fun onFirstComposite(session: GeckoSession) = Unit
-
-        override fun onFirstContentfulPaint(session: GeckoSession) {
-            notifyObservers { onFirstContentfulPaint() }
-        }
-
-        override fun onPaintStatusReset(session: GeckoSession) {
-            notifyObservers { onPaintStatusReset() }
-        }
-
-        override fun onContextMenu(
-            session: GeckoSession,
-            screenX: Int,
-            screenY: Int,
-            element: GeckoSession.ContentDelegate.ContextElement
-        ) {
-            val hitResult = handleLongClick(element.srcUri, element.type, element.linkUri, element.title)
-            hitResult?.let {
-                notifyObservers { onLongPress(it) }
-            }
-        }
-
-        override fun onCrash(session: GeckoSession) {
-            notifyObservers { onCrash() }
-        }
-
-        override fun onKill(session: GeckoSession) {
-            notifyObservers {
-                onProcessKilled()
-            }
-        }
-
-        private fun recoverGeckoSession() {
-            // Recover the GeckoSession after the process getting killed or crashing. We create a
-            // new underlying GeckoSession.
-            // Eventually we may be able to re-use the same GeckoSession by re-opening it. However
-            // that seems to have caused issues:
-            // https://github.com/mozilla-mobile/android-components/issues/3640
-
-            geckoSession.close()
-            createGeckoSession()
-        }
-
-        override fun onFullScreen(session: GeckoSession, fullScreen: Boolean) {
-            notifyObservers { onFullScreenChange(fullScreen) }
-        }
-
-        override fun onExternalResponse(session: GeckoSession, webResponse: WebResponse) {
-            with(webResponse) {
-                val contentType = headers[CONTENT_TYPE]?.trim()
-                val contentLength = headers[CONTENT_LENGTH]?.trim()?.toLong()
-                val contentDisposition = headers[CONTENT_DISPOSITION]?.trim()
-                val url = uri
-                val fileName = DownloadUtils.guessFileName(
-                    contentDisposition,
-                    destinationDirectory = null,
-                    url = url,
-                    mimeType = contentType
-                )
-                val response = webResponse.toResponse()
-
-                notifyObservers {
-                    onExternalResource(
-                            url = url,
-                            contentLength = contentLength,
-                            contentType = DownloadUtils.sanitizeMimeType(contentType),
-                            fileName = fileName.sanitizeFileName(),
-                            response = response,
-                            isPrivate = privateMode
-                    )
-                }
-            }
-        }
-
-        override fun onCloseRequest(session: GeckoSession) {
-            notifyObservers {
-                onWindowRequest(GeckoWindowRequest(
-                        engineSession = this@GeckoEngineSession,
-                        type = WindowRequest.Type.CLOSE
-                    )
-                )
-            }
-        }
-
-        override fun onTitleChange(session: GeckoSession, title: String?) {
-            if (!privateMode) {
-                currentUrl?.let { url ->
-                    settings.historyTrackingDelegate?.let { delegate ->
-                        // NB: There's no guarantee that the title change will be processed by the
-                        // delegate before the session is closed (and the corresponding coroutine
-                        // job is cancelled). Observers will always be notified of the title
-                        // change though.
-                        launch(coroutineContext) {
-                            delegate.onTitleChanged(url, title ?: "")
-                        }
-                    }
-                }
-            }
-            notifyObservers { onTitleChange(title ?: "") }
-        }
-
-        override fun onFocusRequest(session: GeckoSession) = Unit
-
-        override fun onWebAppManifest(session: GeckoSession, manifest: JSONObject) {
-            val parsed = WebAppManifestParser().parse(manifest)
-            if (parsed is WebAppManifestParser.Result.Success) {
-                notifyObservers { onWebAppManifestLoaded(parsed.manifest) }
-            }
-        }
-
-        override fun onMetaViewportFitChange(session: GeckoSession, viewportFit: String) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-                val layoutInDisplayCutoutMode = when (viewportFit) {
-                    "cover" -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
-                    "contain" -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
-                    else -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
-                }
-
-                notifyObservers { onMetaViewportFitChanged(layoutInDisplayCutoutMode) }
-            }
-        }
-    }
-
-    private fun createContentBlockingDelegate() = object : ContentBlocking.Delegate {
-        override fun onContentBlocked(session: GeckoSession, event: ContentBlocking.BlockEvent) {
-            notifyObservers {
-                onTrackerBlocked(event.toTracker())
-            }
-        }
-
-        override fun onContentLoaded(session: GeckoSession, event: ContentBlocking.BlockEvent) {
-            notifyObservers {
-                onTrackerLoaded(event.toTracker())
-            }
-        }
-    }
-
-    private fun ContentBlocking.BlockEvent.toTracker(): Tracker {
-        val blockedContentCategories = mutableListOf<TrackingProtectionPolicy.TrackingCategory>()
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.AD)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.AD)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.ANALYTIC)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.ANALYTICS)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.SOCIAL)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.SOCIAL)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.FINGERPRINTING)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.FINGERPRINTING)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.CRYPTOMINING)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.CRYPTOMINING)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.CONTENT)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.CONTENT)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.TEST)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.TEST)
-        }
-
-        return Tracker(
-            url = uri,
-            trackingCategories = blockedContentCategories,
-            cookiePolicies = getCookiePolicies()
-        )
-    }
-
-    private fun ContentBlocking.BlockEvent.getCookiePolicies(): List<TrackingProtectionPolicy.CookiePolicy> {
-        val cookiesPolicies = mutableListOf<TrackingProtectionPolicy.CookiePolicy>()
-
-        if (cookieBehaviorCategory == ContentBlocking.CookieBehavior.ACCEPT_ALL) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_ALL)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_FIRST_PARTY)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_ONLY_FIRST_PARTY)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_NONE)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_NONE)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_NON_TRACKERS)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_NON_TRACKERS)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_VISITED)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_VISITED)
-        }
-
-        return cookiesPolicies
-    }
-
-    internal fun GeckoSession.ProgressDelegate.SecurityInformation.getIssuerName(): String? {
-        return certificate?.issuerDN?.name?.substringAfterLast("O=")?.substringBeforeLast(",C=")
-    }
-
-    private operator fun Int.contains(mask: Int): Boolean {
-        return (this and mask) != 0
-    }
-
-    private fun createPermissionDelegate() = object : GeckoSession.PermissionDelegate {
-        override fun onContentPermissionRequest(
-            session: GeckoSession,
-            uri: String?,
-            type: Int,
-            callback: GeckoSession.PermissionDelegate.Callback
-        ) {
-            val request = GeckoPermissionRequest.Content(uri ?: "", type, callback)
-            notifyObservers { onContentPermissionRequest(request) }
-        }
-
-        override fun onMediaPermissionRequest(
-            session: GeckoSession,
-            uri: String,
-            video: Array<out GeckoSession.PermissionDelegate.MediaSource>?,
-            audio: Array<out GeckoSession.PermissionDelegate.MediaSource>?,
-            callback: GeckoSession.PermissionDelegate.MediaCallback
-        ) {
-            val request = GeckoPermissionRequest.Media(
-                    uri,
-                    video?.toList() ?: emptyList(),
-                    audio?.toList() ?: emptyList(),
-                    callback)
-            notifyObservers { onContentPermissionRequest(request) }
-        }
-
-        override fun onAndroidPermissionsRequest(
-            session: GeckoSession,
-            permissions: Array<out String>?,
-            callback: GeckoSession.PermissionDelegate.Callback
-        ) {
-            val request = GeckoPermissionRequest.App(
-                    permissions?.toList() ?: emptyList(),
-                    callback)
-            notifyObservers { onAppPermissionRequest(request) }
-        }
-    }
-
-    private fun createScrollDelegate() = object : GeckoSession.ScrollDelegate {
-        override fun onScrollChanged(session: GeckoSession, scrollX: Int, scrollY: Int) {
-            this@GeckoEngineSession.scrollY = scrollY
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    fun handleLongClick(elementSrc: String?, elementType: Int, uri: String? = null, title: String? = null): HitResult? {
-        return when (elementType) {
-            GeckoSession.ContentDelegate.ContextElement.TYPE_AUDIO ->
-                elementSrc?.let {
-                    HitResult.AUDIO(it, title)
-                }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_VIDEO ->
-                elementSrc?.let {
-                    HitResult.VIDEO(it, title)
-                }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE -> {
-                when {
-                    elementSrc != null && uri != null ->
-                        HitResult.IMAGE_SRC(elementSrc, uri)
-                    elementSrc != null ->
-                        HitResult.IMAGE(elementSrc, title)
-                    else -> HitResult.UNKNOWN("")
-                }
-            }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_NONE -> {
-                elementSrc?.let {
-                    when {
-                        it.isPhone() -> HitResult.PHONE(it)
-                        it.isEmail() -> HitResult.EMAIL(it)
-                        it.isGeoLocation() -> HitResult.GEO(it)
-                        else -> HitResult.UNKNOWN(it)
-                    }
-                } ?: uri?.let {
-                    HitResult.UNKNOWN(it)
-                }
-            }
-            else -> HitResult.UNKNOWN("")
-        }
-    }
-
-    private fun createGeckoSession(shouldOpen: Boolean = true) {
-        this.geckoSession = geckoSessionProvider()
-
-        defaultSettings?.trackingProtectionPolicy?.let { updateTrackingProtection(it) }
-        defaultSettings?.requestInterceptor?.let { settings.requestInterceptor = it }
-        defaultSettings?.historyTrackingDelegate?.let { settings.historyTrackingDelegate = it }
-        defaultSettings?.testingModeEnabled?.let { geckoSession.settings.fullAccessibilityTree = it }
-        defaultSettings?.userAgentString?.let { geckoSession.settings.userAgentOverride = it }
-        defaultSettings?.suspendMediaWhenInactive?.let { geckoSession.settings.suspendMediaWhenInactive = it }
-        defaultSettings?.clearColor?.let { geckoSession.compositorController.clearColor = it }
-
-        if (shouldOpen) {
-            geckoSession.open(runtime)
-        }
-
-        geckoSession.navigationDelegate = createNavigationDelegate()
-        geckoSession.progressDelegate = createProgressDelegate()
-        geckoSession.contentDelegate = createContentDelegate()
-        geckoSession.contentBlockingDelegate = createContentBlockingDelegate()
-        geckoSession.permissionDelegate = createPermissionDelegate()
-        geckoSession.promptDelegate = GeckoPromptDelegate(this)
-        geckoSession.historyDelegate = createHistoryDelegate()
-        geckoSession.mediaSessionDelegate = GeckoMediaSessionDelegate(this)
-        geckoSession.scrollDelegate = createScrollDelegate()
-    }
-
-    companion object {
-        internal const val PROGRESS_START = 25
-        internal const val PROGRESS_STOP = 100
-        internal const val MOZ_NULL_PRINCIPAL = "moz-nullprincipal:"
-        internal const val ABOUT_BLANK = "about:blank"
-        internal val BLOCKED_SCHEMES = listOf("content", "file", "resource") // See 1684761 and 1684947
-
-        /**
-         * Provides an ErrorType corresponding to the error code provided.
-         */
-        @Suppress("ComplexMethod")
-        internal fun geckoErrorToErrorType(errorCode: Int) =
-            when (errorCode) {
-                WebRequestError.ERROR_UNKNOWN -> ErrorType.UNKNOWN
-                WebRequestError.ERROR_SECURITY_SSL -> ErrorType.ERROR_SECURITY_SSL
-                WebRequestError.ERROR_SECURITY_BAD_CERT -> ErrorType.ERROR_SECURITY_BAD_CERT
-                WebRequestError.ERROR_NET_INTERRUPT -> ErrorType.ERROR_NET_INTERRUPT
-                WebRequestError.ERROR_NET_TIMEOUT -> ErrorType.ERROR_NET_TIMEOUT
-                WebRequestError.ERROR_CONNECTION_REFUSED -> ErrorType.ERROR_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_SOCKET_TYPE -> ErrorType.ERROR_UNKNOWN_SOCKET_TYPE
-                WebRequestError.ERROR_REDIRECT_LOOP -> ErrorType.ERROR_REDIRECT_LOOP
-                WebRequestError.ERROR_OFFLINE -> ErrorType.ERROR_OFFLINE
-                WebRequestError.ERROR_PORT_BLOCKED -> ErrorType.ERROR_PORT_BLOCKED
-                WebRequestError.ERROR_NET_RESET -> ErrorType.ERROR_NET_RESET
-                WebRequestError.ERROR_UNSAFE_CONTENT_TYPE -> ErrorType.ERROR_UNSAFE_CONTENT_TYPE
-                WebRequestError.ERROR_CORRUPTED_CONTENT -> ErrorType.ERROR_CORRUPTED_CONTENT
-                WebRequestError.ERROR_CONTENT_CRASHED -> ErrorType.ERROR_CONTENT_CRASHED
-                WebRequestError.ERROR_INVALID_CONTENT_ENCODING -> ErrorType.ERROR_INVALID_CONTENT_ENCODING
-                WebRequestError.ERROR_UNKNOWN_HOST -> ErrorType.ERROR_UNKNOWN_HOST
-                WebRequestError.ERROR_MALFORMED_URI -> ErrorType.ERROR_MALFORMED_URI
-                WebRequestError.ERROR_UNKNOWN_PROTOCOL -> ErrorType.ERROR_UNKNOWN_PROTOCOL
-                WebRequestError.ERROR_FILE_NOT_FOUND -> ErrorType.ERROR_FILE_NOT_FOUND
-                WebRequestError.ERROR_FILE_ACCESS_DENIED -> ErrorType.ERROR_FILE_ACCESS_DENIED
-                WebRequestError.ERROR_PROXY_CONNECTION_REFUSED -> ErrorType.ERROR_PROXY_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_PROXY_HOST -> ErrorType.ERROR_UNKNOWN_PROXY_HOST
-                WebRequestError.ERROR_SAFEBROWSING_MALWARE_URI -> ErrorType.ERROR_SAFEBROWSING_MALWARE_URI
-                WebRequestError.ERROR_SAFEBROWSING_UNWANTED_URI -> ErrorType.ERROR_SAFEBROWSING_UNWANTED_URI
-                WebRequestError.ERROR_SAFEBROWSING_HARMFUL_URI -> ErrorType.ERROR_SAFEBROWSING_HARMFUL_URI
-                WebRequestError.ERROR_SAFEBROWSING_PHISHING_URI -> ErrorType.ERROR_SAFEBROWSING_PHISHING_URI
-                else -> ErrorType.UNKNOWN
-            }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt
deleted file mode 100644
index f6f3501ef2b3..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.util.JsonReader
-import android.util.JsonWriter
-import mozilla.components.concept.engine.EngineSessionState
-import org.json.JSONException
-import org.json.JSONObject
-import org.mozilla.geckoview.GeckoSession
-import java.io.IOException
-
-private const val GECKO_STATE_KEY = "GECKO_STATE"
-
-class GeckoEngineSessionState internal constructor(
-    internal val actualState: GeckoSession.SessionState?
-) : EngineSessionState {
-    override fun writeTo(writer: JsonWriter) {
-        with(writer) {
-            beginObject()
-
-            name(GECKO_STATE_KEY)
-            value(actualState.toString())
-
-            endObject()
-            flush()
-        }
-    }
-
-    companion object {
-        fun fromJSON(json: JSONObject): GeckoEngineSessionState = try {
-            val state = json.getString(GECKO_STATE_KEY)
-
-            GeckoEngineSessionState(
-                GeckoSession.SessionState.fromString(state)
-            )
-        } catch (e: JSONException) {
-            GeckoEngineSessionState(null)
-        }
-
-        /**
-         * Creates a [GeckoEngineSessionState] from the given [JsonReader].
-         */
-        fun from(reader: JsonReader): GeckoEngineSessionState = try {
-            reader.beginObject()
-
-            val rawState = if (reader.hasNext()) {
-                val key = reader.nextName()
-                if (key != GECKO_STATE_KEY) {
-                    throw AssertionError("Unknown state key: $key")
-                }
-
-                reader.nextString()
-            } else {
-                null
-            }
-
-            reader.endObject()
-
-            GeckoEngineSessionState(
-                rawState?.let { GeckoSession.SessionState.fromString(it) }
-            )
-        } catch (e: IOException) {
-            GeckoEngineSessionState(null)
-        } catch (e: JSONException) {
-            // Internally GeckoView uses org.json and currently may throw JSONException in certain cases
-            // https://github.com/mozilla-mobile/android-components/issues/9332
-            GeckoEngineSessionState(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
deleted file mode 100644
index 14f06596c125..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
+++ /dev/null
@@ -1,219 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.content.res.Configuration
-import android.graphics.Bitmap
-import android.graphics.Color
-import android.util.AttributeSet
-import android.widget.FrameLayout
-import androidx.annotation.VisibleForTesting
-import androidx.core.view.ViewCompat
-import mozilla.components.browser.engine.gecko.selection.GeckoSelectionActionDelegate
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import org.mozilla.geckoview.BasicSelectionActionDelegate
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-
-/**
- * Gecko-based EngineView implementation.
- */
-class GeckoEngineView @JvmOverloads constructor(
-    context: Context,
-    attrs: AttributeSet? = null,
-    defStyleAttr: Int = 0
-) : FrameLayout(context, attrs, defStyleAttr), EngineView {
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var geckoView = object : NestedGeckoView(context) {
-
-        override fun onAttachedToWindow() {
-            try {
-                super.onAttachedToWindow()
-            } catch (e: IllegalStateException) {
-                // This is to debug "display already acquired" crashes
-                val otherActivityClassName =
-                    this.session?.accessibility?.view?.context?.javaClass?.simpleName
-                val otherActivityClassHashcode =
-                    this.session?.accessibility?.view?.context?.hashCode()
-                val activityClassName = context.javaClass.simpleName
-                val activityClassHashCode = context.hashCode()
-                val msg = "ATTACH VIEW: Current activity: $activityClassName hashcode " +
-                        "$activityClassHashCode Other activity: $otherActivityClassName " +
-                        "hashcode $otherActivityClassHashcode"
-                throw IllegalStateException(msg, e)
-            }
-        }
-
-        override fun onDetachedFromWindow() {
-            // We are releasing the session before GeckoView gets detached from the window. Otherwise
-            // GeckoView will close the session automatically and we do not want that.
-            releaseSession()
-
-            super.onDetachedFromWindow()
-        }
-    }.apply {
-        // Explicitly mark this view as important for autofill. The default "auto" doesn't seem to trigger any
-        // autofill behavior for us here.
-        @Suppress("WrongConstant")
-        ViewCompat.setImportantForAutofill(this, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES)
-    }
-
-    internal fun setColorScheme(preferredColorScheme: PreferredColorScheme) {
-        var colorScheme = preferredColorScheme
-        if (preferredColorScheme == PreferredColorScheme.System) {
-            colorScheme =
-                if (context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
-                    == Configuration.UI_MODE_NIGHT_YES
-                ) {
-                    PreferredColorScheme.Dark
-                } else {
-                    PreferredColorScheme.Light
-                }
-        }
-
-        if (colorScheme == PreferredColorScheme.Dark) {
-            geckoView.coverUntilFirstPaint(DARK_COVER)
-        } else {
-            geckoView.coverUntilFirstPaint(Color.WHITE)
-        }
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var currentSession: GeckoEngineSession? = null
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var currentSelection: BasicSelectionActionDelegate? = null
-
-    override var selectionActionDelegate: SelectionActionDelegate? = null
-
-    init {
-        addView(geckoView)
-    }
-
-    /**
-     * Render the content of the given session.
-     */
-    @Synchronized
-    override fun render(session: EngineSession) {
-        val internalSession = session as GeckoEngineSession
-        currentSession = session
-
-        if (geckoView.session != internalSession.geckoSession) {
-            geckoView.session?.let {
-                // Release a previously assigned session. Otherwise GeckoView will close it
-                // automatically.
-                detachSelectionActionDelegate(it)
-                geckoView.releaseSession()
-            }
-
-            try {
-                geckoView.setSession(internalSession.geckoSession)
-                attachSelectionActionDelegate(internalSession.geckoSession)
-            } catch (e: IllegalStateException) {
-                // This is to debug "display already acquired" crashes
-                val otherActivityClassName =
-                    internalSession.geckoSession.accessibility.view?.context?.javaClass?.simpleName
-                val otherActivityClassHashcode =
-                    internalSession.geckoSession.accessibility.view?.context?.hashCode()
-                val activityClassName = context.javaClass.simpleName
-                val activityClassHashCode = context.hashCode()
-                val msg = "SET SESSION: Current activity: $activityClassName hashcode " +
-                        "$activityClassHashCode Other activity: $otherActivityClassName " +
-                        "hashcode $otherActivityClassHashcode"
-                throw IllegalStateException(msg, e)
-            }
-        }
-    }
-
-    private fun attachSelectionActionDelegate(session: GeckoSession) {
-        val delegate = GeckoSelectionActionDelegate.maybeCreate(context, selectionActionDelegate)
-        if (delegate != null) {
-            session.selectionActionDelegate = delegate
-            currentSelection = delegate
-        }
-    }
-
-    private fun detachSelectionActionDelegate(session: GeckoSession?) {
-        if (currentSelection != null) {
-            session?.selectionActionDelegate = null
-            currentSelection = null
-        }
-    }
-
-    @Synchronized
-    override fun release() {
-        detachSelectionActionDelegate(currentSession?.geckoSession)
-
-        currentSession = null
-
-        geckoView.releaseSession()
-    }
-
-    override fun onDetachedFromWindow() {
-        super.onDetachedFromWindow()
-
-        release()
-    }
-
-    override fun canClearSelection() = !currentSelection?.selection?.text.isNullOrEmpty()
-
-    override fun canScrollVerticallyUp() = currentSession?.let { it.scrollY > 0 } != false
-
-    override fun canScrollVerticallyDown() =
-        true // waiting for this issue https://bugzilla.mozilla.org/show_bug.cgi?id=1507569
-
-    override fun getInputResultDetail() = geckoView.inputResultDetail
-
-    override fun setVerticalClipping(clippingHeight: Int) {
-        geckoView.setVerticalClipping(clippingHeight)
-    }
-
-    override fun setDynamicToolbarMaxHeight(height: Int) {
-        geckoView.setDynamicToolbarMaxHeight(height)
-    }
-
-    @Suppress("TooGenericExceptionCaught")
-    override fun captureThumbnail(onFinish: (Bitmap?) -> Unit) {
-        try {
-            val geckoResult = geckoView.capturePixels()
-            geckoResult.then({ bitmap ->
-                onFinish(bitmap)
-                GeckoResult<Void>()
-            }, {
-                onFinish(null)
-                GeckoResult<Void>()
-            })
-        } catch (e: Exception) {
-            // There's currently no reliable way for consumers of GeckoView to
-            // know whether or not the compositor is ready. So we have to add
-            // a catch-all here. In the future, GeckoView will invoke our error
-            // callback instead and this block can be removed:
-            // https://bugzilla.mozilla.org/show_bug.cgi?id=1645114
-            // https://github.com/mozilla-mobile/android-components/issues/6680
-            onFinish(null)
-        }
-    }
-
-    override fun clearSelection() {
-        currentSelection?.clearSelection()
-    }
-
-    override fun setVisibility(visibility: Int) {
-        // GeckoView doesn't react to onVisibilityChanged so we need to propagate ourselves for now:
-        // https://bugzilla.mozilla.org/show_bug.cgi?id=1630775
-        // We do this to prevent the content from resizing when the view is not visible:
-        // https://github.com/mozilla-mobile/android-components/issues/6664
-        geckoView.visibility = visibility
-        super.setVisibility(visibility)
-    }
-
-    companion object {
-        internal const val DARK_COVER = 0xFF2A2A2E.toInt()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt
deleted file mode 100644
index 7ae791694b73..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.CoroutineStart
-import kotlinx.coroutines.Deferred
-import kotlinx.coroutines.launch
-import mozilla.components.concept.engine.CancellableOperation
-import org.mozilla.geckoview.GeckoResult
-import kotlin.coroutines.CoroutineContext
-import kotlin.coroutines.EmptyCoroutineContext
-import kotlin.coroutines.resume
-import kotlin.coroutines.resumeWithException
-import kotlin.coroutines.suspendCoroutine
-
-/**
- * Wait for a GeckoResult to be complete in a co-routine.
- */
-suspend fun <T> GeckoResult<T>.await() = suspendCoroutine<T?> { continuation ->
-    then({
-        continuation.resume(it)
-        GeckoResult<Void>()
-    }, {
-        continuation.resumeWithException(it)
-        GeckoResult<Void>()
-    })
-}
-
-/**
- * Converts a [GeckoResult] to a [CancellableOperation].
- */
-fun <T> GeckoResult<T>.asCancellableOperation(): CancellableOperation {
-    val geckoResult = this
-    return object : CancellableOperation {
-        override fun cancel(): Deferred<Boolean> {
-            val result = CompletableDeferred<Boolean>()
-            geckoResult.cancel().then({
-                result.complete(it ?: false)
-                GeckoResult<Void>()
-            }, { throwable ->
-                result.completeExceptionally(throwable)
-                GeckoResult<Void>()
-            })
-            return result
-        }
-    }
-}
-
-/**
- * Create a GeckoResult from a co-routine.
- */
-@Suppress("TooGenericExceptionCaught")
-fun <T> CoroutineScope.launchGeckoResult(
-    context: CoroutineContext = EmptyCoroutineContext,
-    start: CoroutineStart = CoroutineStart.DEFAULT,
-    block: suspend CoroutineScope.() -> T
-) = GeckoResult<T>().apply {
-    launch(context, start) {
-        try {
-            val value = block()
-            complete(value)
-        } catch (exception: Throwable) {
-            completeExceptionally(exception)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
deleted file mode 100644
index 25b32c6963e4..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
+++ /dev/null
@@ -1,171 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.view.MotionEvent
-import androidx.annotation.VisibleForTesting
-import androidx.core.view.NestedScrollingChild
-import androidx.core.view.NestedScrollingChildHelper
-import androidx.core.view.ViewCompat
-import mozilla.components.concept.engine.InputResultDetail
-import org.mozilla.geckoview.GeckoView
-
-/**
- * geckoView that supports nested scrolls (for using in a CoordinatorLayout).
- *
- * This code is a simplified version of the NestedScrollView implementation
- * which can be found in the support library:
- * [android.support.v4.widget.NestedScrollView]
- *
- * Based on:
- * https://github.com/takahirom/webview-in-coordinatorlayout
- */
-
-@Suppress("ClickableViewAccessibility")
-open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrollingChild {
-
-    @VisibleForTesting
-    internal var lastY: Int = 0
-
-    @VisibleForTesting
-    internal val scrollOffset = IntArray(2)
-
-    private val scrollConsumed = IntArray(2)
-
-    @VisibleForTesting
-    internal var nestedOffsetY: Int = 0
-
-    @VisibleForTesting
-    internal var childHelper: NestedScrollingChildHelper = NestedScrollingChildHelper(this)
-
-    /**
-     * How user's MotionEvent will be handled.
-     *
-     * @see InputResultDetail
-     */
-    internal var inputResultDetail = InputResultDetail.newInstance(true)
-
-    init {
-        isNestedScrollingEnabled = true
-    }
-
-    @Suppress("ComplexMethod")
-    override fun onTouchEvent(ev: MotionEvent): Boolean {
-        val event = MotionEvent.obtain(ev)
-        val action = ev.actionMasked
-        val eventY = event.y.toInt()
-
-        when (action) {
-            MotionEvent.ACTION_MOVE -> {
-                val allowScroll = !shouldPinOnScreen() && inputResultDetail.isTouchHandledByBrowser()
-
-                var deltaY = lastY - eventY
-
-                if (allowScroll && dispatchNestedPreScroll(0, deltaY, scrollConsumed, scrollOffset)) {
-                    deltaY -= scrollConsumed[1]
-                    event.offsetLocation(0f, (-scrollOffset[1]).toFloat())
-                    nestedOffsetY += scrollOffset[1]
-                }
-
-                lastY = eventY - scrollOffset[1]
-
-                if (allowScroll && dispatchNestedScroll(0, scrollOffset[1], 0, deltaY, scrollOffset)) {
-                    lastY -= scrollOffset[1]
-                    event.offsetLocation(0f, scrollOffset[1].toFloat())
-                    nestedOffsetY += scrollOffset[1]
-                }
-            }
-
-            MotionEvent.ACTION_DOWN -> {
-                // A new gesture started. Ask GV if it can handle this.
-                updateInputResult(event)
-
-                nestedOffsetY = 0
-                lastY = eventY
-
-                // The event should be handled either by onTouchEvent,
-                // either by onTouchEventForResult, never by both.
-                // Early return if we sent it to updateInputResult(..) which calls onTouchEventForResult.
-                event.recycle()
-                return true
-            }
-
-            // We don't care about other touch events
-            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
-                stopNestedScroll()
-                // Reset handled status so that parents of this View would not get the old value
-                // when querying it for a newly started touch event.
-                inputResultDetail = InputResultDetail.newInstance(true)
-            }
-        }
-
-        // Execute event handler from parent class in all cases
-        val eventHandled = callSuperOnTouchEvent(event)
-
-        // Recycle previously obtained event
-        event.recycle()
-
-        return eventHandled
-    }
-
-    @VisibleForTesting
-    internal fun callSuperOnTouchEvent(event: MotionEvent): Boolean {
-        return super.onTouchEvent(event)
-    }
-
-    @VisibleForTesting
-    internal fun updateInputResult(event: MotionEvent) {
-        super.onTouchEventForDetailResult(event)
-            .accept {
-                inputResultDetail = inputResultDetail.copy(
-                    it?.handledResult(), it?.scrollableDirections(), it?.overscrollDirections()
-                )
-                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL)
-            }
-    }
-
-    override fun setNestedScrollingEnabled(enabled: Boolean) {
-        childHelper.isNestedScrollingEnabled = enabled
-    }
-
-    override fun isNestedScrollingEnabled(): Boolean {
-        return childHelper.isNestedScrollingEnabled
-    }
-
-    override fun startNestedScroll(axes: Int): Boolean {
-        return childHelper.startNestedScroll(axes)
-    }
-
-    override fun stopNestedScroll() {
-        childHelper.stopNestedScroll()
-    }
-
-    override fun hasNestedScrollingParent(): Boolean {
-        return childHelper.hasNestedScrollingParent()
-    }
-
-    override fun dispatchNestedScroll(
-        dxConsumed: Int,
-        dyConsumed: Int,
-        dxUnconsumed: Int,
-        dyUnconsumed: Int,
-        offsetInWindow: IntArray?
-    ): Boolean {
-        return childHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow)
-    }
-
-    override fun dispatchNestedPreScroll(dx: Int, dy: Int, consumed: IntArray?, offsetInWindow: IntArray?): Boolean {
-        return childHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow)
-    }
-
-    override fun dispatchNestedFling(velocityX: Float, velocityY: Float, consumed: Boolean): Boolean {
-        return childHelper.dispatchNestedFling(velocityX, velocityY, consumed)
-    }
-
-    override fun dispatchNestedPreFling(velocityX: Float, velocityY: Float): Boolean {
-        return childHelper.dispatchNestedPreFling(velocityX, velocityY)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt
deleted file mode 100644
index bb0114f0904e..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt
+++ /dev/null
@@ -1,171 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.util.AtomicFile
-import androidx.annotation.VisibleForTesting
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.launch
-import mozilla.components.browser.engine.gecko.content.blocking.GeckoTrackingProtectionException
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.support.ktx.util.readAndDeserialize
-import mozilla.components.support.ktx.util.writeString
-import org.json.JSONArray
-import org.json.JSONObject
-import org.mozilla.geckoview.ContentBlockingController.ContentBlockingException
-import org.mozilla.geckoview.GeckoRuntime
-import java.io.File
-
-private const val STORE_FILE_NAME_FORMAT =
-    "mozilla_components_tracking_protection_storage_gecko.json"
-
-/**
- * A [TrackingProtectionExceptionStorage] implementation to store tracking protection exceptions.
- */
-internal class TrackingProtectionExceptionFileStorage(
-    private val context: Context,
-    private val runtime: GeckoRuntime
-) : TrackingProtectionExceptionStorage {
-    private val fileLock = Any()
-    internal var scope = CoroutineScope(Dispatchers.IO)
-
-    /**
-     * Restore all exceptions from the [STORE_FILE_NAME_FORMAT] file,
-     * and provides them to the gecko [runtime].
-     */
-    override fun restore() {
-        scope.launch {
-            synchronized(fileLock) {
-                getFile(context).readAndDeserialize { json ->
-                    if (json.isNotEmpty()) {
-                        val jsonArray = JSONArray(json)
-                        val exceptionList = (0 until jsonArray.length()).map { index ->
-                            val jsonObject = jsonArray.getJSONObject(index)
-                            ContentBlockingException.fromJson(jsonObject)
-                        }
-                        runtime.contentBlockingController.restoreExceptionList(exceptionList)
-                    }
-                }
-            }
-        }
-    }
-
-    override fun contains(session: EngineSession, onResult: (Boolean) -> Unit) {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        runtime.contentBlockingController.checkException(geckoSession).accept {
-            if (it != null) {
-                onResult(it)
-            } else {
-                onResult(false)
-            }
-        }
-    }
-
-    override fun fetchAll(onResult: (List<TrackingProtectionException>) -> Unit) {
-        runtime.contentBlockingController.saveExceptionList().accept { exceptionList ->
-            val exceptions = if (exceptionList != null) {
-                val exceptions = exceptionList.map { it.toTrackingProtectionException() }
-                exceptions
-            } else {
-                emptyList()
-            }
-            onResult(exceptions)
-        }
-    }
-
-    override fun add(session: EngineSession) {
-        val geckoEngineSession = (session as GeckoEngineSession)
-        runtime.contentBlockingController.addException(geckoEngineSession.geckoSession)
-        geckoEngineSession.notifyObservers {
-            onExcludedOnTrackingProtectionChange(true)
-        }
-        persist()
-    }
-
-    override fun remove(session: EngineSession) {
-        val geckoEngineSession = (session as GeckoEngineSession)
-        runtime.contentBlockingController.removeException(geckoEngineSession.geckoSession)
-        geckoEngineSession.notifyObservers {
-            onExcludedOnTrackingProtectionChange(false)
-        }
-        persist()
-    }
-
-    override fun remove(exception: TrackingProtectionException) {
-        val geckoException = (exception as GeckoTrackingProtectionException)
-        runtime.contentBlockingController.removeException(geckoException.toContentBlockingException())
-        persist()
-    }
-
-    override fun removeAll(activeSessions: List<EngineSession>?) {
-        runtime.contentBlockingController.clearExceptionList()
-        activeSessions?.forEach { engineSession ->
-            engineSession.notifyObservers {
-                onExcludedOnTrackingProtectionChange(false)
-            }
-        }
-        removeFileFromDisk(context)
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun getFile(context: Context): AtomicFile {
-        return AtomicFile(
-            File(
-                context.filesDir,
-                STORE_FILE_NAME_FORMAT
-            )
-        )
-    }
-
-    /**
-     * Take all the exception from the gecko [runtime] and saves them into the
-     * [STORE_FILE_NAME_FORMAT] file.
-     */
-    private fun persist() {
-        runtime.contentBlockingController.saveExceptionList().accept { exceptionList ->
-            if (exceptionList != null) {
-                scope.launch {
-                    synchronized(fileLock) {
-                        getFile(context).writeString {
-                            val jsonList = exceptionList.map { item ->
-                                item.toJson()
-                            }
-                            JSONArray(jsonList).toString()
-                        }
-                    }
-                }
-            } else {
-                removeFileFromDisk(context)
-            }
-        }
-    }
-
-    private fun removeFileFromDisk(context: Context) {
-        scope.launch {
-            synchronized(fileLock) {
-                getFile(context)
-                    .delete()
-            }
-        }
-    }
-}
-
-private fun ContentBlockingException.toTrackingProtectionException(): GeckoTrackingProtectionException {
-    val json = toJson()
-    val principal = json.getString("principal")
-    val uri = json.getString("uri")
-    return GeckoTrackingProtectionException(uri, principal)
-}
-
-private fun GeckoTrackingProtectionException.toContentBlockingException(): ContentBlockingException {
-    val json = JSONObject()
-    json.put("principal", principal)
-    json.put("uri", url)
-    return ContentBlockingException.fromJson(json)
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt
deleted file mode 100644
index cc93f915fc52..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.activity
-
-import android.app.PendingIntent
-import android.content.Intent
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.support.base.log.logger.Logger
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import java.lang.ref.WeakReference
-
-/**
- * A wrapper for the [ActivityDelegate] to communicate with the Gecko-based delegate.
- */
-internal class GeckoActivityDelegate(
-    private val delegateRef: WeakReference<ActivityDelegate>
-) : GeckoRuntime.ActivityDelegate {
-
-    private val logger = Logger(GeckoActivityDelegate::javaClass.name)
-
-    override fun onStartActivityForResult(intent: PendingIntent): GeckoResult<Intent> {
-        val result: GeckoResult<Intent> = GeckoResult()
-        val delegate = delegateRef.get()
-
-        if (delegate == null) {
-            logger.warn("No activity delegate attached. Cannot request FIDO auth.")
-
-            result.completeExceptionally(RuntimeException("Activity for result failed; no delegate attached."))
-
-            return result
-        }
-
-        delegate.startIntentSenderForResult(intent.intentSender) { data ->
-            if (data != null) {
-                result.complete(data)
-            } else {
-                result.completeExceptionally(RuntimeException("Activity for result failed."))
-            }
-        }
-        return result
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
deleted file mode 100644
index 71288f44b210..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.autofill
-
-import kotlinx.coroutines.Dispatchers.IO
-import kotlinx.coroutines.GlobalScope
-import kotlinx.coroutines.launch
-import mozilla.components.concept.storage.Login
-import mozilla.components.concept.storage.LoginStorageDelegate
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-
-/**
- * This class exists only to convert incoming [LoginEntry] arguments into [Login]s, then forward
- * them to [storageDelegate]. This allows us to avoid duplicating [LoginStorageDelegate] code
- * between different versions of GeckoView, by duplicating this wrapper instead.
- */
-@Suppress("Deprecation")
-// This will be addressed in https://github.com/mozilla-mobile/android-components/issues/10093
-class GeckoLoginDelegateWrapper(private val storageDelegate: LoginStorageDelegate) :
-    Autocomplete.LoginStorageDelegate {
-
-    override fun onLoginSave(login: Autocomplete.LoginEntry) {
-        storageDelegate.onLoginSave(login.toLogin())
-    }
-
-    override fun onLoginFetch(domain: String): GeckoResult<Array<Autocomplete.LoginEntry>>? {
-        val result = GeckoResult<Array<Autocomplete.LoginEntry>>()
-
-        GlobalScope.launch(IO) {
-            val storedLogins = storageDelegate.onLoginFetch(domain)
-
-            val logins = storedLogins.await()
-                .map { it.toLoginEntry() }
-                .toTypedArray()
-
-            result.complete(logins)
-        }
-
-        return result
-    }
-}
-
-/**
- * Converts a GeckoView [LoginStorage.LoginEntry] to an Android Components [Login]
- */
-private fun Autocomplete.LoginEntry.toLogin() = Login(
-    guid = guid,
-    origin = origin,
-    formActionOrigin = formActionOrigin,
-    httpRealm = httpRealm,
-    username = username,
-    password = password
-)
-
-/**
- * Converts an Android Components [Login] to a GeckoView [LoginStorage.LoginEntry]
- */
-private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-    .guid(guid)
-    .origin(origin)
-    .formActionOrigin(formActionOrigin)
-    .httpRealm(httpRealm)
-    .username(username)
-    .password(password)
-    .build()
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt
deleted file mode 100644
index eb5ed61a9a5b..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt
+++ /dev/null
@@ -1,15 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.content.blocking
-
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-
-/**
- * Represents a site that will be ignored by the tracking protection policies.
- * @property url The url of the site to be ignored.
- * @property principal Internal gecko identifier of an URI.
- */
-data class GeckoTrackingProtectionException(override val url: String, val principal: String = "") :
-    TrackingProtectionException
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt
deleted file mode 100644
index 3e8f4db2676c..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.ext
-
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-/**
- * Converts a [TrackingProtectionPolicy] into a GeckoView setting that can be used with [GeckoRuntimeSettings.Builder].
- */
-fun TrackingProtectionPolicy.toContentBlockingSetting(
-    safeBrowsingPolicy: Array<EngineSession.SafeBrowsingPolicy> = arrayOf(EngineSession.SafeBrowsingPolicy.RECOMMENDED)
-) = ContentBlocking.Settings.Builder().apply {
-    enhancedTrackingProtectionLevel(getEtpLevel())
-    antiTracking(getAntiTrackingPolicy())
-    cookieBehavior(cookiePolicy.id)
-    cookiePurging(cookiePurging)
-    safeBrowsing(safeBrowsingPolicy.sumBy { it.id })
-    strictSocialTrackingProtection(getStrictSocialTrackingProtection())
-}.build()
-
-/**
- * Returns whether [TrackingCategory.STRICT] is enabled in the [TrackingProtectionPolicy].
- */
-internal fun TrackingProtectionPolicy.getStrictSocialTrackingProtection(): Boolean {
-    return strictSocialTrackingProtection ?: trackingCategories.contains(TrackingCategory.STRICT)
-}
-
-/**
- * Returns the [TrackingProtectionPolicy] categories as an Enhanced Tracking Protection level for GeckoView.
- */
-internal fun TrackingProtectionPolicy.getEtpLevel(): Int {
-    return when {
-        trackingCategories.contains(TrackingCategory.NONE) -> ContentBlocking.EtpLevel.NONE
-        else -> ContentBlocking.EtpLevel.STRICT
-    }
-}
-
-/**
- * Returns the [TrackingProtectionPolicy] as a tracking policy for GeckoView.
- */
-internal fun TrackingProtectionPolicy.getAntiTrackingPolicy(): Int {
-    /**
-     * The [TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES] is an
-     * artificial category, created with the sole purpose of going around this bug
-     * https://bugzilla.mozilla.org/show_bug.cgi?id=1579264, for this reason we have to
-     * remove its value from the valid anti tracking categories, when is present.
-     */
-    val total = trackingCategories.sumBy { it.id }
-    return if (contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)) {
-        total - TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-    } else {
-        total
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt
deleted file mode 100644
index d2cadff58668..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt
+++ /dev/null
@@ -1,138 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch
-
-import android.content.Context
-import androidx.annotation.VisibleForTesting
-import mozilla.components.concept.fetch.Client
-import mozilla.components.concept.fetch.Headers
-import mozilla.components.concept.fetch.MutableHeaders
-import mozilla.components.concept.fetch.Request
-import mozilla.components.concept.fetch.Response
-import mozilla.components.concept.fetch.isDataUri
-import mozilla.components.concept.fetch.isBlobUri
-import mozilla.components.concept.fetch.Response.Companion.SUCCESS
-
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebRequest
-import org.mozilla.geckoview.WebRequest.CACHE_MODE_DEFAULT
-import org.mozilla.geckoview.WebRequest.CACHE_MODE_RELOAD
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebResponse
-import java.io.IOException
-import java.net.SocketTimeoutException
-import java.nio.ByteBuffer
-import java.util.concurrent.TimeUnit
-import java.util.concurrent.TimeoutException
-
-/**
- * GeckoView ([GeckoWebExecutor]) based implementation of [Client].
- */
-class GeckoViewFetchClient(
-    context: Context,
-    runtime: GeckoRuntime = GeckoRuntime.getDefault(context),
-    private val maxReadTimeOut: Pair<Long, TimeUnit> = Pair(MAX_READ_TIMEOUT_MINUTES, TimeUnit.MINUTES)
-) : Client() {
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var executor: GeckoWebExecutor = GeckoWebExecutor(runtime)
-
-    @Throws(IOException::class)
-    override fun fetch(request: Request): Response {
-        if (request.isDataUri()) {
-            return fetchDataUri(request)
-        }
-
-        val webRequest = request.toWebRequest()
-
-        val readTimeOut = request.readTimeout ?: maxReadTimeOut
-        val readTimeOutMillis = readTimeOut.let { (timeout, unit) ->
-            unit.toMillis(timeout)
-        }
-
-        return try {
-            val webResponse = executor.fetch(webRequest, request.fetchFlags).poll(readTimeOutMillis)
-            webResponse?.toResponse() ?: throw IOException("Fetch failed with null response")
-        } catch (e: TimeoutException) {
-            throw SocketTimeoutException()
-        } catch (e: WebRequestError) {
-            throw IOException(e)
-        }
-    }
-
-    private val Request.fetchFlags: Int
-        get() {
-            var fetchFlags = 0
-            if (cookiePolicy == Request.CookiePolicy.OMIT) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_ANONYMOUS
-            }
-            if (private) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_PRIVATE
-            }
-            if (redirect == Request.Redirect.MANUAL) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_NO_REDIRECTS
-            }
-            return fetchFlags
-        }
-
-    companion object {
-        const val MAX_READ_TIMEOUT_MINUTES = 5L
-    }
-}
-
-private fun Request.toWebRequest(): WebRequest = WebRequest.Builder(url)
-    .method(method.name)
-    .addHeadersFrom(this)
-    .addBodyFrom(this)
-    .cacheMode(if (useCaches) CACHE_MODE_DEFAULT else CACHE_MODE_RELOAD)
-    .build()
-
-private fun WebRequest.Builder.addHeadersFrom(request: Request): WebRequest.Builder {
-    request.headers?.forEach { header ->
-        addHeader(header.name, header.value)
-    }
-
-    return this
-}
-
-private fun WebRequest.Builder.addBodyFrom(request: Request): WebRequest.Builder {
-    request.body?.let { body ->
-        body.useStream { inStream ->
-            val bytes = inStream.readBytes()
-            val buffer = ByteBuffer.allocateDirect(bytes.size)
-            buffer.put(bytes)
-            this.body(buffer)
-        }
-    }
-
-    return this
-}
-
-internal fun WebResponse.toResponse(): Response {
-    val isDataUri = uri.startsWith("data:")
-    val isBlobUri = uri.startsWith("blob:")
-    val headers = translateHeaders(this)
-    // We use the same API for blobs, data URLs and HTTP requests, but blobs won't receive a status code.
-    // If no exception is thrown we assume success.
-    val status = if (isBlobUri || isDataUri) SUCCESS else statusCode
-    return Response(
-        uri,
-        status,
-        headers,
-            body?.let {
-                Response.Body(it, headers["Content-Type"])
-            } ?: Response.Body.empty()
-    )
-}
-
-private fun translateHeaders(webResponse: WebResponse): Headers {
-    val headers = MutableHeaders()
-    webResponse.headers.forEach { (k, v) ->
-        v.split(",").forEach { headers.append(k, it.trim()) }
-    }
-
-    return headers
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt
deleted file mode 100644
index 9630faf81c98..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.glean
-
-import mozilla.components.browser.engine.gecko.GleanMetrics.GleanGeckoMetricsMapping
-import org.mozilla.geckoview.RuntimeTelemetry
-
-/**
- * This implements a [RuntimeTelemetry.Delegate] that dispatches Gecko runtime
- * telemetry to the Glean SDK.
- *
- * Metrics defined in the `metrics.yaml` file in Gecko's mozilla-central repository
- * will be automatically dispatched to the Glean SDK and sent through the requested
- * pings.
- *
- * This can be used, in products collecting data through the Glean SDK, by
- * providing an instance to `GeckoRuntimeSettings.Builder().telemetryDelegate`.
- */
-class GeckoAdapter : RuntimeTelemetry.Delegate {
-    // Note that the `GleanGeckoMetricsMapping` is automatically generated at
-    // build time by the Glean SDK parsers.
-
-    override fun onHistogram(metric: RuntimeTelemetry.Histogram) {
-        if (metric.isCategorical) {
-            // Gecko categorical histograms are a bit special: their value indicates
-            // the index of the label they want to accumulate 1 unit to. Moreover,
-            // Gecko batches them up before sending: each value in `metric.value` is
-            // the index of a potentially different label.
-            GleanGeckoMetricsMapping.getCategoricalMetric(metric.name)?.let { categorical ->
-                metric.value.forEach { labelIndex -> categorical[labelIndex.toInt()].add(1) }
-            }
-        } else {
-            GleanGeckoMetricsMapping.getHistogram(metric.name)?.accumulateSamples(metric.value)
-        }
-    }
-
-    override fun onBooleanScalar(metric: RuntimeTelemetry.Metric<Boolean>) {
-        GleanGeckoMetricsMapping.getBooleanScalar(metric.name)?.set(metric.value)
-    }
-
-    override fun onStringScalar(metric: RuntimeTelemetry.Metric<String>) {
-        GleanGeckoMetricsMapping.getStringScalar(metric.name)?.set(metric.value)
-    }
-
-    override fun onLongScalar(metric: RuntimeTelemetry.Metric<Long>) {
-        GleanGeckoMetricsMapping.getQuantityScalar(metric.name)?.set(metric.value)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt
deleted file mode 100644
index ac16867ea835..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-import android.content.BroadcastReceiver
-import android.content.Context
-import android.content.Intent
-import android.content.IntentFilter
-import androidx.core.os.LocaleListCompat as LocaleList
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Class to set the locales setting for geckoview, updating from the locale of the device.
- */
-class LocaleSettingUpdater(
-    private val context: Context,
-    private val runtime: GeckoRuntime
-) : SettingUpdater<Array<String>>() {
-
-    override var value: Array<String> = findValue()
-        set(value) {
-            runtime.settings.locales = value
-            field = value
-        }
-
-    private val localeChangedReceiver by lazy {
-        object : BroadcastReceiver() {
-            override fun onReceive(context: Context, intent: Intent?) {
-                updateValue()
-            }
-        }
-    }
-
-    override fun registerForUpdates() {
-        context.registerReceiver(localeChangedReceiver, IntentFilter(Intent.ACTION_LOCALE_CHANGED))
-    }
-
-    override fun unregisterForUpdates() {
-        context.unregisterReceiver(localeChangedReceiver)
-    }
-
-    override fun findValue(): Array<String> {
-        val localeList = LocaleList.getAdjustedDefault()
-        return arrayOfNulls<Unit>(localeList.size())
-            .mapIndexedNotNull { i, _ -> localeList.get(i).toLanguageTag() }
-            .toTypedArray()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt
deleted file mode 100644
index af4d455a791d..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-abstract class SettingUpdater<T> {
-    /**
-     * Toggle the automatic tracking of a setting derived from the device state.
-     */
-    var enabled: Boolean = false
-        set(value) {
-            if (value) {
-                updateValue()
-                registerForUpdates()
-            } else {
-                unregisterForUpdates()
-            }
-            field = value
-        }
-
-    /**
-     * The setter for this property should change the GeckoView setting.
-     */
-    abstract var value: T
-
-    internal fun updateValue() {
-        value = findValue()
-    }
-
-    /**
-     * Register for updates from the device state. This is setting specific.
-     */
-    abstract fun registerForUpdates()
-
-    /**
-     * Unregister for updates from the device state.
-     */
-    abstract fun unregisterForUpdates()
-
-    /**
-     * Find the value of the setting from the device state. This is setting specific.
-     */
-    abstract fun findValue(): T
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt
deleted file mode 100644
index 919cde564afd..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt
+++ /dev/null
@@ -1,22 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package mozilla.components.browser.engine.gecko.mediaquery
-
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-internal fun PreferredColorScheme.Companion.from(geckoValue: Int) =
-        when (geckoValue) {
-            GeckoRuntimeSettings.COLOR_SCHEME_DARK -> PreferredColorScheme.Dark
-            GeckoRuntimeSettings.COLOR_SCHEME_LIGHT -> PreferredColorScheme.Light
-            GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM -> PreferredColorScheme.System
-            else -> PreferredColorScheme.System
-        }
-
-internal fun PreferredColorScheme.toGeckoValue() =
-    when (this) {
-        is PreferredColorScheme.Dark -> GeckoRuntimeSettings.COLOR_SCHEME_DARK
-        is PreferredColorScheme.Light -> GeckoRuntimeSettings.COLOR_SCHEME_LIGHT
-        is PreferredColorScheme.System -> GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM
-    }
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt
deleted file mode 100644
index 931135eb41d5..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import mozilla.components.concept.engine.mediasession.MediaSession
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-/**
- * [MediaSession.Controller] (`concept-engine`) implementation for GeckoView.
- */
-internal class GeckoMediaSessionController(
-    private val mediaSession: GeckoViewMediaSession
-) : MediaSession.Controller {
-
-    override fun pause() {
-        mediaSession.pause()
-    }
-
-    override fun stop() {
-        mediaSession.stop()
-    }
-
-    override fun play() {
-        mediaSession.play()
-    }
-
-    override fun seekTo(time: Double, fast: Boolean) {
-        mediaSession.seekTo(time, fast)
-    }
-
-    override fun seekForward() {
-        mediaSession.seekForward()
-    }
-
-    override fun seekBackward() {
-        mediaSession.seekBackward()
-    }
-
-    override fun nextTrack() {
-        mediaSession.nextTrack()
-    }
-
-    override fun previousTrack() {
-        mediaSession.previousTrack()
-    }
-
-    override fun skipAd() {
-        mediaSession.skipAd()
-    }
-
-    override fun muteAudio(mute: Boolean) {
-        mediaSession.muteAudio(mute)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt
deleted file mode 100644
index 5c66f956c640..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import android.graphics.Bitmap
-import kotlinx.coroutines.withTimeoutOrNull
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.browser.engine.gecko.await
-import mozilla.components.concept.engine.mediasession.MediaSession
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.Image.ImageProcessingException
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-private const val ARTWORK_RETRIEVE_TIMEOUT = 1000L
-private const val ARTWORK_IMAGE_SIZE = 48
-private const val ARTWORK_ERROR_SIZE = 1
-
-internal class GeckoMediaSessionDelegate(
-    private val engineSession: GeckoEngineSession
-) : GeckoViewMediaSession.Delegate {
-
-    override fun onActivated(geckoSession: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaActivated(GeckoMediaSessionController(mediaSession))
-        }
-    }
-
-    override fun onDeactivated(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaDeactivated()
-        }
-    }
-
-    override fun onMetadata(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        metaData: GeckoViewMediaSession.Metadata
-    ) {
-        val getArtwork: (suspend () -> Bitmap?)? = metaData.artwork?.let {
-            {
-                try {
-                    var bitmap = withTimeoutOrNull(ARTWORK_RETRIEVE_TIMEOUT) {
-                        it.getBitmap(ARTWORK_IMAGE_SIZE).await()
-                    }
-
-                    /* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1697255 */
-                    if (bitmap != null &&
-                        (bitmap.height <= ARTWORK_ERROR_SIZE || bitmap.width <= ARTWORK_ERROR_SIZE)) {
-                        bitmap = null
-                    }
-
-                    bitmap
-                } catch (e: ImageProcessingException) {
-                    null
-                }
-            }
-        }
-
-        engineSession.notifyObservers {
-            onMediaMetadataChanged(
-                MediaSession.Metadata(metaData.title, metaData.artist, metaData.album, getArtwork)
-            )
-        }
-    }
-
-    override fun onFeatures(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        features: Long
-    ) {
-        engineSession.notifyObservers {
-            onMediaFeatureChanged(MediaSession.Feature(features))
-        }
-    }
-
-    override fun onPlay(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.PLAYING)
-        }
-    }
-
-    override fun onPause(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.PAUSED)
-        }
-    }
-
-    override fun onStop(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.STOPPED)
-        }
-    }
-
-    override fun onPositionState(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        positionState: GeckoViewMediaSession.PositionState
-    ) {
-        engineSession.notifyObservers {
-            onMediaPositionStateChanged(
-                MediaSession.PositionState(positionState.duration, positionState.position,
-                    positionState.playbackRate)
-            )
-        }
-    }
-
-    override fun onFullscreen(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        enabled: Boolean,
-        elementMetaData: GeckoViewMediaSession.ElementMetadata?
-    ) {
-        val sessionElementMetaData =
-            elementMetaData?.let {
-                MediaSession.ElementMetadata(
-                    elementMetaData.source,
-                    elementMetaData.duration,
-                    elementMetaData.width,
-                    elementMetaData.height,
-                    elementMetaData.audioTrackCount,
-                    elementMetaData.videoTrackCount
-                )
-            }
-
-        engineSession.notifyObservers {
-            onMediaFullscreenChanged(enabled, sessionElementMetaData)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt
deleted file mode 100644
index bf8f84d52e9a..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt
+++ /dev/null
@@ -1,161 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.permission
-
-import android.Manifest.permission.ACCESS_COARSE_LOCATION
-import android.Manifest.permission.ACCESS_FINE_LOCATION
-import android.Manifest.permission.CAMERA
-import android.Manifest.permission.RECORD_AUDIO
-import mozilla.components.concept.engine.permission.Permission
-import mozilla.components.concept.engine.permission.PermissionRequest
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_AUDIOCAPTURE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_CAMERA
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_MICROPHONE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_OTHER
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_SCREEN
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_AUDIBLE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_INAUDIBLE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_DESKTOP_NOTIFICATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_MEDIA_KEY_SYSTEM_ACCESS
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_PERSISTENT_STORAGE
-import java.util.UUID
-
-/**
- * Gecko-based implementation of [PermissionRequest].
- *
- * @property permissions the list of requested permissions.
- * @property callback the callback to grant/reject the requested permissions.
- * @property id a unique identifier for the request.
- */
-sealed class GeckoPermissionRequest constructor(
-    override val permissions: List<Permission>,
-    private val callback: PermissionDelegate.Callback? = null,
-    override val id: String = UUID.randomUUID().toString()
-) : PermissionRequest {
-
-    /**
-     * Represents a gecko-based content permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property type the type of the requested content permission (will be
-     * mapped to corresponding [Permission]).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class Content(
-        override val uri: String,
-        private val type: Int,
-        private val callback: PermissionDelegate.Callback
-    ) : GeckoPermissionRequest(
-            listOf(permissionsMap.getOrElse(type) { Permission.Generic("$type", "Gecko permission type = $type") }),
-            callback
-    ) {
-        companion object {
-            val permissionsMap = mapOf(
-                PERMISSION_DESKTOP_NOTIFICATION to Permission.ContentNotification(),
-                PERMISSION_GEOLOCATION to Permission.ContentGeoLocation(),
-                PERMISSION_AUTOPLAY_AUDIBLE to Permission.ContentAutoPlayAudible(),
-                PERMISSION_AUTOPLAY_INAUDIBLE to Permission.ContentAutoPlayInaudible(),
-                PERMISSION_PERSISTENT_STORAGE to Permission.ContentPersistentStorage(),
-                PERMISSION_MEDIA_KEY_SYSTEM_ACCESS to Permission.ContentMediaKeySystemAccess()
-            )
-        }
-    }
-
-    /**
-     * Represents a gecko-based application permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property nativePermissions the list of requested app permissions (will be
-     * mapped to corresponding [Permission]s).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class App(
-        private val nativePermissions: List<String>,
-        private val callback: PermissionDelegate.Callback
-    ) : GeckoPermissionRequest(
-            nativePermissions.map { permissionsMap.getOrElse(it) { Permission.Generic(it) } },
-            callback
-    ) {
-        override val uri: String? = null
-
-        companion object {
-            val permissionsMap = mapOf(
-                ACCESS_COARSE_LOCATION to Permission.AppLocationCoarse(ACCESS_COARSE_LOCATION),
-                ACCESS_FINE_LOCATION to Permission.AppLocationFine(ACCESS_FINE_LOCATION),
-                CAMERA to Permission.AppCamera(CAMERA),
-                RECORD_AUDIO to Permission.AppAudio(RECORD_AUDIO)
-            )
-        }
-    }
-
-    /**
-     * Represents a gecko-based media permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property videoSources the list of requested video sources (will be
-     * mapped to the corresponding [Permission]).
-     * @property audioSources the list of requested audio sources (will be
-     * mapped to corresponding [Permission]).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class Media(
-        override val uri: String,
-        private val videoSources: List<MediaSource>,
-        private val audioSources: List<MediaSource>,
-        private val callback: PermissionDelegate.MediaCallback
-    ) : GeckoPermissionRequest(
-            videoSources.map { mapPermission(it) } + audioSources.map { mapPermission(it) }
-    ) {
-        override fun grant(permissions: List<Permission>) {
-            val videos = permissions.mapNotNull { permission -> videoSources.find { it.id == permission.id } }
-            val audios = permissions.mapNotNull { permission -> audioSources.find { it.id == permission.id } }
-            callback.grant(videos.firstOrNull(), audios.firstOrNull())
-        }
-
-        override fun containsVideoAndAudioSources(): Boolean {
-            return videoSources.isNotEmpty() && audioSources.isNotEmpty()
-        }
-
-        override fun reject() {
-            callback.reject()
-        }
-
-        companion object {
-            fun mapPermission(mediaSource: MediaSource): Permission =
-                if (mediaSource.type == MediaSource.TYPE_AUDIO) {
-                    mapAudioPermission(mediaSource)
-                } else {
-                    mapVideoPermission(mediaSource)
-                }
-
-            @Suppress("SwitchIntDef")
-            private fun mapAudioPermission(mediaSource: MediaSource) = when (mediaSource.source) {
-                SOURCE_AUDIOCAPTURE -> Permission.ContentAudioCapture(mediaSource.id, mediaSource.name)
-                SOURCE_MICROPHONE -> Permission.ContentAudioMicrophone(mediaSource.id, mediaSource.name)
-                SOURCE_OTHER -> Permission.ContentAudioOther(mediaSource.id, mediaSource.name)
-                else -> Permission.Generic(mediaSource.id, mediaSource.name)
-            }
-
-            @Suppress("ComplexMethod", "SwitchIntDef")
-            private fun mapVideoPermission(mediaSource: MediaSource) = when (mediaSource.source) {
-                SOURCE_CAMERA -> Permission.ContentVideoCamera(mediaSource.id, mediaSource.name)
-                SOURCE_SCREEN -> Permission.ContentVideoScreen(mediaSource.id, mediaSource.name)
-                SOURCE_OTHER -> Permission.ContentVideoOther(mediaSource.id, mediaSource.name)
-                else -> Permission.Generic(mediaSource.id, mediaSource.name)
-            }
-        }
-    }
-
-    override fun grant(permissions: List<Permission>) {
-        callback?.grant()
-    }
-
-    override fun reject() {
-        callback?.reject()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt
deleted file mode 100644
index 98fd12f20372..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.profiler
-
-import mozilla.components.concept.base.profiler.Profiler
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Gecko-based implementation of [Profiler], wrapping the
- * ProfilerController object provided by GeckoView.
- */
-class Profiler(
-    private val runtime: GeckoRuntime
-) : Profiler {
-
-    /**
-     * See [Profiler.isProfilerActive].
-     */
-    override fun isProfilerActive(): Boolean {
-        return runtime.profilerController.isProfilerActive
-    }
-
-    /**
-     * See [Profiler.getProfilerTime].
-     */
-    override fun getProfilerTime(): Double? {
-        return runtime.profilerController.profilerTime
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?, endTime: Double?, text: String?) {
-        runtime.profilerController.addMarker(markerName, startTime, endTime, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?, text: String?) {
-        runtime.profilerController.addMarker(markerName, startTime, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?) {
-        runtime.profilerController.addMarker(markerName, startTime)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, text: String?) {
-        runtime.profilerController.addMarker(markerName, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String) {
-        runtime.profilerController.addMarker(markerName)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt
deleted file mode 100644
index fc5d38bb6d8d..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt
+++ /dev/null
@@ -1,667 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.prompt
-
-import android.content.Context
-import android.net.Uri
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.prompt.Choice
-import mozilla.components.concept.engine.prompt.PromptRequest
-import mozilla.components.concept.engine.prompt.PromptRequest.MenuChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.MultipleChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.SingleChoice
-import mozilla.components.concept.engine.prompt.ShareData
-import mozilla.components.concept.storage.Login
-import mozilla.components.support.base.log.logger.Logger
-import mozilla.components.support.ktx.android.net.getFileName
-import mozilla.components.support.ktx.kotlin.toDate
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PromptDelegate
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.BeforeUnloadPrompt
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATETIME_LOCAL
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.MONTH
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.TIME
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.WEEK
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.PromptResponse
-import java.io.File
-import java.io.FileOutputStream
-import java.io.IOException
-import java.io.InputStream
-import java.security.InvalidParameterException
-import java.text.SimpleDateFormat
-import java.util.Date
-import java.util.Locale
-
-typealias GeckoAuthOptions = PromptDelegate.AuthPrompt.AuthOptions
-typealias GeckoChoice = PromptDelegate.ChoicePrompt.Choice
-typealias GECKO_AUTH_FLAGS = PromptDelegate.AuthPrompt.AuthOptions.Flags
-typealias GECKO_AUTH_LEVEL = PromptDelegate.AuthPrompt.AuthOptions.Level
-typealias GECKO_PROMPT_FILE_TYPE = PromptDelegate.FilePrompt.Type
-typealias GECKO_PROMPT_CHOICE_TYPE = PromptDelegate.ChoicePrompt.Type
-typealias GECKO_PROMPT_FILE_CAPTURE = PromptDelegate.FilePrompt.Capture
-typealias GECKO_PROMPT_SHARE_RESULT = PromptDelegate.SharePrompt.Result
-typealias AC_AUTH_LEVEL = PromptRequest.Authentication.Level
-typealias AC_AUTH_METHOD = PromptRequest.Authentication.Method
-typealias AC_FILE_FACING_MODE = PromptRequest.File.FacingMode
-
-/**
- * Gecko-based PromptDelegate implementation.
- */
-internal class GeckoPromptDelegate(private val geckoEngineSession: GeckoEngineSession) :
-    PromptDelegate {
-
-    private fun Autocomplete.LoginEntry.toLogin() = Login(
-        guid = guid,
-        origin = origin,
-        formActionOrigin = formActionOrigin,
-        httpRealm = httpRealm,
-        username = username,
-        password = password
-    )
-
-    private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-        .guid(guid)
-        .origin(origin)
-        .formActionOrigin(formActionOrigin)
-        .httpRealm(httpRealm)
-        .username(username)
-        .password(password)
-        .build()
-
-    override fun onLoginSave(
-        session: GeckoSession,
-        prompt: PromptDelegate.AutocompleteRequest<Autocomplete.LoginSaveOption>
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirmSave: (Login) -> Unit = { login ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(Autocomplete.LoginSelectOption(login.toLoginEntry())))
-            }
-        }
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.SaveLoginPrompt(
-                    hint = prompt.options[0].hint,
-                    logins = prompt.options.map { it.value.toLogin() },
-                    onConfirm = onConfirmSave,
-                    onDismiss = onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onLoginSelect(
-        session: GeckoSession,
-        prompt: PromptDelegate.AutocompleteRequest<Autocomplete.LoginSelectOption>
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirmSelect: (Login) -> Unit = { login ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(Autocomplete.LoginSelectOption(login.toLoginEntry())))
-            }
-        }
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        // Exactly one of `httpRealm` and `formSubmitURL` must be present to be a valid login entry.
-        val loginList = prompt.options.filter { option ->
-            option.value.formActionOrigin != null || option.value.httpRealm != null
-        }.map { option ->
-            option.value.toLogin()
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.SelectLoginPrompt(
-                    logins = loginList,
-                    onConfirm = onConfirmSelect,
-                    onDismiss = onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onChoicePrompt(
-        session: GeckoSession,
-        geckoPrompt: PromptDelegate.ChoicePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val choices = convertToChoices(geckoPrompt.choices)
-        val onConfirmSingleChoice: (Choice) -> Unit = { selectedChoice ->
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(selectedChoice.id))
-            }
-        }
-        val onConfirmMultipleSelection: (Array<Choice>) -> Unit = { selectedChoices ->
-            if (!geckoPrompt.isComplete) {
-                val ids = selectedChoices.toIdsArray()
-                geckoResult.complete(geckoPrompt.confirm(ids))
-            }
-        }
-
-        val promptRequest = when (geckoPrompt.type) {
-            GECKO_PROMPT_CHOICE_TYPE.SINGLE -> SingleChoice(
-                choices,
-                onConfirmSingleChoice
-            )
-            GECKO_PROMPT_CHOICE_TYPE.MENU -> MenuChoice(
-                choices,
-                onConfirmSingleChoice
-            )
-            GECKO_PROMPT_CHOICE_TYPE.MULTIPLE -> MultipleChoice(
-                choices,
-                onConfirmMultipleSelection
-            )
-            else -> throw InvalidParameterException("${geckoPrompt.type} is not a valid Gecko @Choice.ChoiceType")
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(promptRequest)
-        }
-
-        return geckoResult
-    }
-
-    override fun onAlertPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.AlertPrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: () -> Unit = { prompt.dismissSafely(geckoResult) }
-        val title = prompt.title ?: ""
-        val message = prompt.message ?: ""
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Alert(
-                    title,
-                    message,
-                    false,
-                    onConfirm
-                ) { _ ->
-                    onConfirm()
-                })
-        }
-        return geckoResult
-    }
-
-    override fun onFilePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.FilePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val isMultipleFilesSelection = prompt.type == GECKO_PROMPT_FILE_TYPE.MULTIPLE
-
-        val captureMode = when (prompt.capture) {
-            GECKO_PROMPT_FILE_CAPTURE.ANY -> AC_FILE_FACING_MODE.ANY
-            GECKO_PROMPT_FILE_CAPTURE.USER -> AC_FILE_FACING_MODE.FRONT_CAMERA
-            GECKO_PROMPT_FILE_CAPTURE.ENVIRONMENT -> AC_FILE_FACING_MODE.BACK_CAMERA
-            else -> AC_FILE_FACING_MODE.NONE
-        }
-
-        val onSelectMultiple: (Context, Array<Uri>) -> Unit = { context, uris ->
-            val filesUris = uris.map {
-                it.toFileUri(context)
-            }.toTypedArray()
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(context, filesUris))
-            }
-        }
-
-        val onSelectSingle: (Context, Uri) -> Unit = { context, uri ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(context, uri.toFileUri(context)))
-            }
-        }
-
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.File(
-                    prompt.mimeTypes ?: emptyArray(),
-                    isMultipleFilesSelection,
-                    captureMode,
-                    onSelectSingle,
-                    onSelectMultiple,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    @Suppress("ComplexMethod")
-    override fun onDateTimePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.DateTimePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: (String) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(it))
-            }
-        }
-        val onClear: () -> Unit = {
-            onConfirm("")
-        }
-        val initialDateString = prompt.defaultValue ?: ""
-
-        val format = when (prompt.type) {
-            DATE -> "yyyy-MM-dd"
-            MONTH -> "yyyy-MM"
-            WEEK -> "yyyy-'W'ww"
-            TIME -> "HH:mm"
-            DATETIME_LOCAL -> "yyyy-MM-dd'T'HH:mm"
-            else -> {
-                throw InvalidParameterException("${prompt.type} is not a valid DatetimeType")
-            }
-        }
-
-        notifyDatePromptRequest(
-            prompt.title ?: "",
-            initialDateString,
-            prompt.minValue,
-            prompt.maxValue,
-            onClear,
-            format,
-            onConfirm
-        )
-
-        return geckoResult
-    }
-
-    override fun onAuthPrompt(
-        session: GeckoSession,
-        geckoPrompt: PromptDelegate.AuthPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = geckoPrompt.title ?: ""
-        val message = geckoPrompt.message ?: ""
-        val flags = geckoPrompt.authOptions.flags
-        val userName = geckoPrompt.authOptions.username ?: ""
-        val password = geckoPrompt.authOptions.password ?: ""
-        val method =
-            if (flags in GECKO_AUTH_FLAGS.HOST) AC_AUTH_METHOD.HOST else AC_AUTH_METHOD.PROXY
-        val level = geckoPrompt.authOptions.toACLevel()
-        val onlyShowPassword = flags in GECKO_AUTH_FLAGS.ONLY_PASSWORD
-        val previousFailed = flags in GECKO_AUTH_FLAGS.PREVIOUS_FAILED
-        val isCrossOrigin = flags in GECKO_AUTH_FLAGS.CROSS_ORIGIN_SUB_RESOURCE
-
-        val onConfirm: (String, String) -> Unit =
-            { user, pass ->
-                if (!geckoPrompt.isComplete) {
-                    if (onlyShowPassword) {
-                        geckoResult.complete(geckoPrompt.confirm(pass))
-                    } else {
-                        geckoResult.complete(geckoPrompt.confirm(user, pass))
-                    }
-                }
-            }
-
-        val onDismiss: () -> Unit = { geckoPrompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Authentication(
-                    title,
-                    message,
-                    userName,
-                    password,
-                    method,
-                    level,
-                    onlyShowPassword,
-                    previousFailed,
-                    isCrossOrigin,
-                    onConfirm,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onTextPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.TextPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = prompt.title ?: ""
-        val inputLabel = prompt.message ?: ""
-        val inputValue = prompt.defaultValue ?: ""
-        val onDismiss: () -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.TextPrompt(
-                    title,
-                    inputLabel,
-                    inputValue,
-                    false,
-                    onDismiss
-                ) { _, valueInput ->
-                    if (!prompt.isComplete) {
-                        geckoResult.complete(prompt.confirm(valueInput))
-                    }
-                })
-        }
-
-        return geckoResult
-    }
-
-    override fun onColorPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.ColorPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: (String) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(it))
-            }
-        }
-        val onDismiss: () -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        val defaultColor = prompt.defaultValue ?: ""
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Color(defaultColor, onConfirm, onDismiss)
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onPopupPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.PopupPrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onAllow: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onDeny: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.DENY))
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Popup(prompt.targetUri ?: "", onAllow, onDeny)
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onBeforeUnloadPrompt(
-        session: GeckoSession,
-        geckoPrompt: BeforeUnloadPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = geckoPrompt.title ?: ""
-        val onAllow: () -> Unit = {
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onDeny: () -> Unit = {
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(AllowOrDeny.DENY))
-                geckoEngineSession.notifyObservers { onBeforeUnloadPromptDenied() }
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(PromptRequest.BeforeUnload(title, onAllow, onDeny))
-        }
-
-        return geckoResult
-    }
-
-    override fun onSharePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.SharePrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onSuccess = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(GECKO_PROMPT_SHARE_RESULT.SUCCESS))
-            }
-        }
-        val onFailure = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(GECKO_PROMPT_SHARE_RESULT.FAILURE))
-            }
-        }
-        val onDismiss = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Share(
-                    ShareData(
-                        title = prompt.title,
-                        text = prompt.text,
-                        url = prompt.uri
-                    ),
-                    onSuccess,
-                    onFailure,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onButtonPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.ButtonPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = prompt.title ?: ""
-        val message = prompt.message ?: ""
-
-        val onConfirmPositiveButton: (Boolean) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(PromptDelegate.ButtonPrompt.Type.POSITIVE))
-            }
-        }
-        val onConfirmNegativeButton: (Boolean) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(PromptDelegate.ButtonPrompt.Type.NEGATIVE))
-            }
-        }
-
-        val onDismiss: (Boolean) -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Confirm(
-                    title,
-                    message,
-                    false,
-                    "",
-                    "",
-                    "",
-                    onConfirmPositiveButton,
-                    onConfirmNegativeButton,
-                    onDismiss
-                ) {
-                    onDismiss(false)
-                }
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onRepostConfirmPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.RepostConfirmPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-
-        val onConfirm: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onCancel: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.DENY))
-                geckoEngineSession.notifyObservers { onRepostPromptCancelled() }
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Repost(
-                    onConfirm,
-                    onCancel
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    private fun GeckoChoice.toChoice(): Choice {
-        val choiceChildren = items?.map { it.toChoice() }?.toTypedArray()
-        // On the GeckoView docs states that label is a @NonNull, but on run-time
-        // we are getting null values
-        @Suppress("USELESS_ELVIS")
-        return Choice(id, !disabled, label ?: "", selected, separator, choiceChildren)
-    }
-
-    /**
-     * Convert an array of [GeckoChoice] to Choice array.
-     * @return array of Choice
-     */
-    private fun convertToChoices(
-        geckoChoices: Array<out GeckoChoice>
-    ): Array<Choice> {
-
-        return geckoChoices.map { geckoChoice ->
-            val choice = geckoChoice.toChoice()
-            choice
-        }.toTypedArray()
-    }
-
-    @Suppress("LongParameterList")
-    private fun notifyDatePromptRequest(
-        title: String,
-        initialDateString: String,
-        minDateString: String?,
-        maxDateString: String?,
-        onClear: () -> Unit,
-        format: String,
-        onConfirm: (String) -> Unit
-    ) {
-        val initialDate = initialDateString.toDate(format)
-        val minDate = if (minDateString.isNullOrEmpty()) null else minDateString.toDate()
-        val maxDate = if (maxDateString.isNullOrEmpty()) null else maxDateString.toDate()
-        val onSelect: (Date) -> Unit = {
-            val stringDate = it.toString(format)
-            onConfirm(stringDate)
-        }
-
-        val selectionType = when (format) {
-            "HH:mm" -> PromptRequest.TimeSelection.Type.TIME
-            "yyyy-MM" -> PromptRequest.TimeSelection.Type.MONTH
-            "yyyy-MM-dd'T'HH:mm" -> PromptRequest.TimeSelection.Type.DATE_AND_TIME
-            else -> PromptRequest.TimeSelection.Type.DATE
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.TimeSelection(
-                    title,
-                    initialDate,
-                    minDate,
-                    maxDate,
-                    selectionType,
-                    onSelect,
-                    onClear
-                )
-            )
-        }
-    }
-
-    private fun GeckoAuthOptions.toACLevel(): AC_AUTH_LEVEL {
-        return when (level) {
-            GECKO_AUTH_LEVEL.NONE -> AC_AUTH_LEVEL.NONE
-            GECKO_AUTH_LEVEL.PW_ENCRYPTED -> AC_AUTH_LEVEL.PASSWORD_ENCRYPTED
-            GECKO_AUTH_LEVEL.SECURE -> AC_AUTH_LEVEL.SECURED
-            else -> {
-                AC_AUTH_LEVEL.NONE
-            }
-        }
-    }
-
-    private operator fun Int.contains(mask: Int): Boolean {
-        return (this and mask) != 0
-    }
-
-    private fun Uri.toFileUri(context: Context): Uri {
-        val contentResolver = context.contentResolver
-        val cacheUploadDirectory = java.io.File(context.cacheDir, "/uploads")
-
-        if (!cacheUploadDirectory.exists()) {
-            cacheUploadDirectory.mkdir()
-        }
-
-        val temporalFile = java.io.File(cacheUploadDirectory, getFileName(contentResolver))
-        try {
-            contentResolver.openInputStream(this)!!.use { inStream ->
-                copyFile(temporalFile, inStream)
-            }
-        } catch (e: IOException) {
-            Logger("GeckoPromptDelegate").warn("Could not convert uri to file uri", e)
-        }
-        return Uri.parse("file:///${temporalFile.absolutePath}")
-    }
-
-    @VisibleForTesting
-    internal fun copyFile(temporalFile: File, inStream: InputStream): Long {
-        return FileOutputStream(temporalFile).use { outStream ->
-            inStream.copyTo(outStream)
-        }
-    }
-}
-
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-internal fun Array<Choice>.toIdsArray(): Array<String> {
-    return this.map { it.id }.toTypedArray()
-}
-
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-internal fun Date.toString(format: String): String {
-    val formatter = SimpleDateFormat(format, Locale.ROOT)
-    return formatter.format(this) ?: ""
-}
-
-/**
- * Only dismiss if the prompt is not already dismissed.
- */
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-
-internal fun PromptDelegate.BasePrompt.dismissSafely(geckoResult: GeckoResult<PromptResponse>) {
-    if (!this.isComplete) {
-        geckoResult.complete(dismiss())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt
deleted file mode 100644
index 781430af630c..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.selection
-
-import android.app.Activity
-import android.content.Context
-import android.view.MenuItem
-import androidx.annotation.VisibleForTesting
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import org.mozilla.geckoview.BasicSelectionActionDelegate
-
-/**
- * An adapter between the GV [BasicSelectionActionDelegate] and a generic [SelectionActionDelegate].
- *
- * @param customDelegate handles as much of this logic as possible.
- */
-open class GeckoSelectionActionDelegate(
-    activity: Activity,
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal val customDelegate: SelectionActionDelegate
-) : BasicSelectionActionDelegate(activity) {
-
-    companion object {
-        /**
-         * @returns a [GeckoSelectionActionDelegate] if [customDelegate] is non-null and [context]
-         * is an instance of [Activity]. Otherwise, returns null.
-         */
-        fun maybeCreate(context: Context, customDelegate: SelectionActionDelegate?): GeckoSelectionActionDelegate? {
-            return if (context is Activity && customDelegate != null) {
-                GeckoSelectionActionDelegate(context, customDelegate)
-            } else {
-                null
-            }
-        }
-    }
-
-    override fun getAllActions(): Array<String> {
-        return customDelegate.sortedActions(super.getAllActions() + customDelegate.getAllActions())
-    }
-
-    override fun isActionAvailable(id: String): Boolean {
-        val selectedText = mSelection?.text
-
-        val customActionIsAvailable = !selectedText.isNullOrEmpty() &&
-        customDelegate.isActionAvailable(id, selectedText)
-
-        return customActionIsAvailable ||
-            super.isActionAvailable(id)
-    }
-
-    override fun prepareAction(id: String, item: MenuItem) {
-        val title = customDelegate.getActionTitle(id)
-            ?: return super.prepareAction(id, item)
-
-        item.title = title
-    }
-
-    override fun performAction(id: String, item: MenuItem): Boolean {
-        /* Temporary, removed once https://bugzilla.mozilla.org/show_bug.cgi?id=1694983 is fixed */
-        try {
-            val selectedText = mSelection?.text ?: return super.performAction(id, item)
-
-            return customDelegate.performAction(id, selectedText) || super.performAction(id, item)
-        } catch (e: SecurityException) {
-            return false
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt
deleted file mode 100644
index 202e78abe940..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt
+++ /dev/null
@@ -1,154 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.util
-
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.Settings
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Helper factory for creating and maintaining a speculative [EngineSession].
- */
-internal class SpeculativeSessionFactory {
-    @VisibleForTesting
-    internal var speculativeEngineSession: SpeculativeEngineSession? = null
-
-    /**
-     * Creates a speculative [EngineSession] using the provided [contextId] and [defaultSettings].
-     * Creates a private session if [private] is set to true.
-     *
-     * The speculative [EngineSession] is kept internally until explicitly needed and access via [get].
-     */
-    @Synchronized
-    fun create(
-        runtime: GeckoRuntime,
-        private: Boolean,
-        contextId: String?,
-        defaultSettings: Settings?
-    ) {
-        if (speculativeEngineSession?.matches(private, contextId) == true) {
-            // We already have a speculative engine session for this configuration. Nothing to do here.
-            return
-        }
-
-        // Clear any potentially non-matching engine session
-        clear()
-
-        speculativeEngineSession = SpeculativeEngineSession.create(
-            this,
-            runtime,
-            private,
-            contextId,
-            defaultSettings
-        )
-    }
-
-    /**
-     * Clears the internal speculative [EngineSession].
-     */
-    @Synchronized
-    fun clear() {
-        speculativeEngineSession?.cleanUp()
-        speculativeEngineSession = null
-    }
-
-    /**
-     * Returns and consumes a previously created [private] speculative [EngineSession] if it uses
-     * the same [contextId]. Returns `null` if no speculative [EngineSession] for that
-     * configuration is available.
-     */
-    @Synchronized
-    fun get(
-        private: Boolean,
-        contextId: String?
-    ): GeckoEngineSession? {
-        val speculativeEngineSession = speculativeEngineSession ?: return null
-
-        return if (speculativeEngineSession.matches(private, contextId)) {
-            this.speculativeEngineSession = null
-            speculativeEngineSession.unwrap()
-        } else {
-            clear()
-            null
-        }
-    }
-
-    @VisibleForTesting
-    internal fun hasSpeculativeSession(): Boolean {
-        return speculativeEngineSession != null
-    }
-}
-
-/**
- * Internal wrapper for [GeckoEngineSession] that takes care of registering and unregistering an
- * observer for handling content process crashes/kills.
- */
-internal class SpeculativeEngineSession constructor(
-    @VisibleForTesting internal val engineSession: GeckoEngineSession,
-    @VisibleForTesting internal val observer: SpeculativeSessionObserver
-) {
-    /**
-     * Checks whether the [SpeculativeEngineSession] matches the given configuration.
-     */
-    fun matches(private: Boolean, contextId: String?): Boolean {
-        return engineSession.geckoSession.settings.usePrivateMode == private &&
-            engineSession.geckoSession.settings.contextId == contextId
-    }
-
-    /**
-     * Unwraps the internal [GeckoEngineSession].
-     *
-     * After calling [unwrap] the wrapper will no longer observe the [GeckoEngineSession] and further
-     * crash handling is left to the application.
-     */
-    fun unwrap(): GeckoEngineSession {
-        engineSession.unregister(observer)
-        return engineSession
-    }
-
-    /**
-     * Cleans up the internal state of this [SpeculativeEngineSession]. After calling this method
-     * his [SpeculativeEngineSession] cannot be used anymore.
-     */
-    fun cleanUp() {
-        engineSession.unregister(observer)
-        engineSession.close()
-    }
-
-    companion object {
-        fun create(
-            factory: SpeculativeSessionFactory,
-            runtime: GeckoRuntime,
-            private: Boolean,
-            contextId: String?,
-            defaultSettings: Settings?
-        ): SpeculativeEngineSession {
-            val engineSession = GeckoEngineSession(runtime, private, defaultSettings, contextId)
-            val observer = SpeculativeSessionObserver(factory)
-            engineSession.register(observer)
-
-            return SpeculativeEngineSession(engineSession, observer)
-        }
-    }
-}
-
-/**
- * [EngineSession.Observer] implementation that will notify the [SpeculativeSessionFactory] if an
- * [GeckoEngineSession] can no longer be used after a crash.
- */
-internal class SpeculativeSessionObserver(
-    private val factory: SpeculativeSessionFactory
-
-) : EngineSession.Observer {
-    override fun onCrash() {
-        factory.clear()
-    }
-
-    override fun onProcessKilled() {
-        factory.clear()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt
deleted file mode 100644
index 0f24dab354dd..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt
+++ /dev/null
@@ -1,427 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import android.graphics.Bitmap
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.browser.engine.gecko.await
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.DisabledFlags
-import mozilla.components.concept.engine.webextension.MessageHandler
-import mozilla.components.concept.engine.webextension.Metadata
-import mozilla.components.concept.engine.webextension.Port
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.support.base.log.logger.Logger
-import org.json.JSONObject
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.WebExtension as GeckoNativeWebExtension
-import org.mozilla.geckoview.WebExtension.Action as GeckoNativeWebExtensionAction
-
-/**
- * Gecko-based implementation of [WebExtension], wrapping the native web
- * extension object provided by GeckoView.
- */
-class GeckoWebExtension(
-    val nativeExtension: GeckoNativeWebExtension,
-    val runtime: GeckoRuntime
-) : WebExtension(nativeExtension.id, nativeExtension.location, true) {
-
-    private val connectedPorts: MutableMap<PortId, GeckoPort> = mutableMapOf()
-    private val logger = Logger("GeckoWebExtension")
-
-    /**
-     * Uniquely identifies a port using its name and the session it
-     * was opened for. Ports connected from background scripts will
-     * have a null session.
-     */
-    data class PortId(val name: String, val session: EngineSession? = null)
-
-    /**
-     * See [WebExtension.registerBackgroundMessageHandler].
-     */
-    override fun registerBackgroundMessageHandler(name: String, messageHandler: MessageHandler) {
-        val portDelegate = object : GeckoNativeWebExtension.PortDelegate {
-
-            override fun onPortMessage(message: Any, port: GeckoNativeWebExtension.Port) {
-                messageHandler.onPortMessage(message, GeckoPort(port))
-            }
-
-            override fun onDisconnect(port: GeckoNativeWebExtension.Port) {
-                val connectedPort = connectedPorts[PortId(name)]
-                if (connectedPort != null && connectedPort.nativePort == port) {
-                    connectedPorts.remove(PortId(name))
-                    messageHandler.onPortDisconnected(GeckoPort(port))
-                }
-            }
-        }
-
-        val messageDelegate = object : GeckoNativeWebExtension.MessageDelegate {
-
-            override fun onConnect(port: GeckoNativeWebExtension.Port) {
-                port.setDelegate(portDelegate)
-                val geckoPort = GeckoPort(port)
-                connectedPorts[PortId(name)] = geckoPort
-                messageHandler.onPortConnected(geckoPort)
-            }
-
-            override fun onMessage(
-                // We don't use the same delegate instance for multiple apps so we don't need to verify the name.
-                name: String,
-                message: Any,
-                sender: GeckoNativeWebExtension.MessageSender
-            ): GeckoResult<Any>? {
-                val response = messageHandler.onMessage(message, null)
-                return response?.let { GeckoResult.fromValue(it) }
-            }
-        }
-
-        nativeExtension.setMessageDelegate(messageDelegate, name)
-    }
-
-    /**
-     * See [WebExtension.registerContentMessageHandler].
-     */
-    override fun registerContentMessageHandler(session: EngineSession, name: String, messageHandler: MessageHandler) {
-        val portDelegate = object : GeckoNativeWebExtension.PortDelegate {
-
-            override fun onPortMessage(message: Any, port: GeckoNativeWebExtension.Port) {
-                messageHandler.onPortMessage(message, GeckoPort(port, session))
-            }
-
-            override fun onDisconnect(port: GeckoNativeWebExtension.Port) {
-                val connectedPort = connectedPorts[PortId(name, session)]
-                if (connectedPort != null && connectedPort.nativePort == port) {
-                    connectedPorts.remove(PortId(name, session))
-                    messageHandler.onPortDisconnected(connectedPort)
-                }
-            }
-        }
-
-        val messageDelegate = object : GeckoNativeWebExtension.MessageDelegate {
-
-            override fun onConnect(port: GeckoNativeWebExtension.Port) {
-                port.setDelegate(portDelegate)
-                val geckoPort = GeckoPort(port, session)
-                connectedPorts[PortId(name, session)] = geckoPort
-                messageHandler.onPortConnected(geckoPort)
-            }
-
-            override fun onMessage(
-                // We don't use the same delegate instance for multiple apps so we don't need to verify the name.
-                name: String,
-                message: Any,
-                sender: GeckoNativeWebExtension.MessageSender
-            ): GeckoResult<Any>? {
-                val response = messageHandler.onMessage(message, session)
-                return response?.let { GeckoResult.fromValue(it) }
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setMessageDelegate(nativeExtension, messageDelegate, name)
-    }
-
-    /**
-     * See [WebExtension.hasContentMessageHandler].
-     */
-    override fun hasContentMessageHandler(session: EngineSession, name: String): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getMessageDelegate(nativeExtension, name) != null
-    }
-
-    /**
-     * See [WebExtension.getConnectedPort].
-     */
-    override fun getConnectedPort(name: String, session: EngineSession?): Port? {
-        return connectedPorts[PortId(name, session)]
-    }
-
-    /**
-     * See [WebExtension.disconnectPort].
-     */
-    override fun disconnectPort(name: String, session: EngineSession?) {
-        val portId = PortId(name, session)
-        val port = connectedPorts[portId]
-        port?.let {
-            it.disconnect()
-            connectedPorts.remove(portId)
-        }
-    }
-
-    /**
-     * See [WebExtension.registerActionHandler].
-     */
-    override fun registerActionHandler(actionHandler: ActionHandler) {
-        if (!supportActions) {
-            logger.error("Attempt to register default action handler but browser and page " +
-                "action support is turned off for this extension: $id")
-            return
-        }
-
-        val actionDelegate = object : GeckoNativeWebExtension.ActionDelegate {
-
-            override fun onBrowserAction(
-                ext: GeckoNativeWebExtension,
-                // Session will always be null here for the global default delegate
-                session: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onBrowserAction(this@GeckoWebExtension, null, action.convert())
-            }
-
-            override fun onPageAction(
-                ext: GeckoNativeWebExtension,
-                // Session will always be null here for the global default delegate
-                session: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onPageAction(this@GeckoWebExtension, null, action.convert())
-            }
-
-            override fun onTogglePopup(
-                ext: GeckoNativeWebExtension,
-                action: GeckoNativeWebExtensionAction
-            ): GeckoResult<GeckoSession>? {
-                val session = actionHandler.onToggleActionPopup(this@GeckoWebExtension, action.convert())
-                return session?.let { GeckoResult.fromValue((session as GeckoEngineSession).geckoSession) }
-            }
-        }
-
-        nativeExtension.setActionDelegate(actionDelegate)
-    }
-
-    /**
-     * See [WebExtension.registerActionHandler].
-     */
-    override fun registerActionHandler(session: EngineSession, actionHandler: ActionHandler) {
-        if (!supportActions) {
-            logger.error("Attempt to register action handler on session but browser and page " +
-                "action support is turned off for this extension: $id")
-            return
-        }
-
-        val actionDelegate = object : GeckoNativeWebExtension.ActionDelegate {
-
-            override fun onBrowserAction(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onBrowserAction(this@GeckoWebExtension, session, action.convert())
-            }
-
-            override fun onPageAction(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onPageAction(this@GeckoWebExtension, session, action.convert())
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setActionDelegate(nativeExtension, actionDelegate)
-    }
-
-    /**
-     * See [WebExtension.hasActionHandler].
-     */
-    override fun hasActionHandler(session: EngineSession): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getActionDelegate(nativeExtension) != null
-    }
-
-    /**
-     * See [WebExtension.registerTabHandler].
-     */
-    override fun registerTabHandler(tabHandler: TabHandler, defaultSettings: Settings?) {
-
-        val tabDelegate = object : GeckoNativeWebExtension.TabDelegate {
-
-            override fun onNewTab(
-                ext: GeckoNativeWebExtension,
-                tabDetails: GeckoNativeWebExtension.CreateTabDetails
-            ): GeckoResult<GeckoSession>? {
-                val geckoEngineSession = GeckoEngineSession(
-                    runtime,
-                    defaultSettings = defaultSettings,
-                    openGeckoSession = false
-                )
-
-                tabHandler.onNewTab(
-                    this@GeckoWebExtension,
-                    geckoEngineSession,
-                    tabDetails.active == true,
-                    tabDetails.url ?: ""
-                )
-                return GeckoResult.fromValue(geckoEngineSession.geckoSession)
-            }
-
-            override fun onOpenOptionsPage(ext: GeckoNativeWebExtension) {
-                ext.metaData.optionsPageUrl?.let { optionsPageUrl ->
-                    tabHandler.onNewTab(
-                        this@GeckoWebExtension,
-                        GeckoEngineSession(runtime,
-                            defaultSettings = defaultSettings),
-                        false,
-                        optionsPageUrl
-                    )
-                }
-            }
-        }
-
-        nativeExtension.tabDelegate = tabDelegate
-    }
-
-    /**
-     * See [WebExtension.registerTabHandler].
-     */
-    override fun registerTabHandler(session: EngineSession, tabHandler: TabHandler) {
-
-        val tabDelegate = object : GeckoNativeWebExtension.SessionTabDelegate {
-
-            override fun onUpdateTab(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession,
-                tabDetails: GeckoNativeWebExtension.UpdateTabDetails
-            ): GeckoResult<AllowOrDeny> {
-
-                return if (tabHandler.onUpdateTab(
-                    this@GeckoWebExtension,
-                    session,
-                    tabDetails.active == true,
-                    tabDetails.url)
-                ) {
-                    GeckoResult.allow()
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-
-            override fun onCloseTab(
-                ext: GeckoNativeWebExtension?,
-                geckoSession: GeckoSession
-            ): GeckoResult<AllowOrDeny> {
-
-                return if (ext != null) {
-                    if (tabHandler.onCloseTab(this@GeckoWebExtension, session)) {
-                        GeckoResult.allow()
-                    } else {
-                        GeckoResult.deny()
-                    }
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setTabDelegate(nativeExtension, tabDelegate)
-    }
-
-    /**
-     * See [WebExtension.hasTabHandler].
-     */
-    override fun hasTabHandler(session: EngineSession): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getTabDelegate(nativeExtension) != null
-    }
-
-    /**
-     * See [WebExtension.getMetadata].
-     */
-    override fun getMetadata(): Metadata? {
-        return nativeExtension.metaData.let {
-            Metadata(
-                name = it.name,
-                description = it.description,
-                developerName = it.creatorName,
-                developerUrl = it.creatorUrl,
-                homePageUrl = it.homepageUrl,
-                version = it.version,
-                permissions = it.permissions.toList(),
-                // Origins is marked as @NonNull but may be null: https://bugzilla.mozilla.org/show_bug.cgi?id=1629957
-                hostPermissions = it.origins.orEmpty().toList(),
-                disabledFlags = DisabledFlags.select(it.disabledFlags),
-                optionsPageUrl = it.optionsPageUrl,
-                openOptionsPageInTab = it.openOptionsPageInTab,
-                baseUrl = it.baseUrl,
-                temporary = it.temporary
-            )
-        }
-    }
-
-    override fun isBuiltIn(): Boolean {
-        return nativeExtension.isBuiltIn
-    }
-
-    override fun isEnabled(): Boolean {
-        return nativeExtension.metaData.enabled
-    }
-
-    override fun isAllowedInPrivateBrowsing(): Boolean {
-        return isBuiltIn() || nativeExtension.metaData.allowedInPrivateBrowsing
-    }
-
-    override suspend fun loadIcon(size: Int): Bitmap? {
-        return getIcon(size).await()
-    }
-
-    @VisibleForTesting
-    internal fun getIcon(size: Int): GeckoResult<Bitmap> {
-        return nativeExtension.metaData.icon.getBitmap(size)
-    }
-}
-
-/**
- * Gecko-based implementation of [Port], wrapping the native port provided by GeckoView.
- */
-class GeckoPort(
-    internal val nativePort: GeckoNativeWebExtension.Port,
-    engineSession: EngineSession? = null
-) : Port(engineSession) {
-
-    override fun postMessage(message: JSONObject) {
-        nativePort.postMessage(message)
-    }
-
-    override fun name(): String {
-        return nativePort.name
-    }
-
-    override fun senderUrl(): String {
-        return nativePort.sender.url
-    }
-
-    override fun disconnect() {
-        nativePort.disconnect()
-    }
-}
-
-private fun GeckoNativeWebExtensionAction.convert(): Action {
-    val loadIcon: (suspend (Int) -> Bitmap?)? = icon?.let {
-        { size -> icon?.getBitmap(size)?.await() }
-    }
-
-    val onClick = { click() }
-
-    return Action(
-        title,
-        enabled,
-        loadIcon,
-        badgeText,
-        badgeTextColor,
-        badgeBackgroundColor,
-        onClick
-    )
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt
deleted file mode 100644
index c7aca040271a..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import mozilla.components.concept.engine.webextension.WebExtensionException
-import org.mozilla.geckoview.WebExtension.InstallException
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_USER_CANCELED
-
-/**
- * An unexpected gecko exception that occurs when trying to perform an action on the extension like
- * (but not exclusively) installing/uninstalling, removing or updating..
- */
-class GeckoWebExtensionException(throwable: Throwable) : WebExtensionException(throwable) {
-    override val isRecoverable: Boolean = throwable is InstallException &&
-            throwable.code == ERROR_USER_CANCELED
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt
deleted file mode 100644
index f65277ac7f6c..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webnotifications
-
-import mozilla.components.concept.engine.webnotifications.WebNotification
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import org.mozilla.geckoview.WebNotification as GeckoViewWebNotification
-import org.mozilla.geckoview.WebNotificationDelegate as GeckoViewWebNotificationDelegate
-
-internal class GeckoWebNotificationDelegate(
-    private val webNotificationDelegate: WebNotificationDelegate
-) : GeckoViewWebNotificationDelegate {
-    override fun onShowNotification(webNotification: GeckoViewWebNotification) {
-        webNotificationDelegate.onShowNotification(webNotification.toWebNotification())
-    }
-
-    override fun onCloseNotification(webNotification: GeckoViewWebNotification) {
-        webNotificationDelegate.onCloseNotification(webNotification.toWebNotification())
-    }
-
-    private fun GeckoViewWebNotification.toWebNotification(): WebNotification {
-        return WebNotification(
-            title = title,
-            tag = tag,
-            body = text,
-            sourceUrl = source,
-            iconUrl = imageUrl,
-            direction = textDirection,
-            lang = lang,
-            requireInteraction = requireInteraction,
-            triggeredByWebExtension = source == null
-        )
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt
deleted file mode 100644
index 3facfc2de16a..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushSubscription
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.WebPushDelegate as GeckoViewWebPushDelegate
-import org.mozilla.geckoview.WebPushSubscription as GeckoWebPushSubscription
-
-/**
- * A wrapper for the [WebPushDelegate] to communicate with the Gecko-based delegate.
- */
-internal class GeckoWebPushDelegate(private val delegate: WebPushDelegate) : GeckoViewWebPushDelegate {
-
-    /**
-     * See [GeckoViewWebPushDelegate.onGetSubscription].
-     */
-    override fun onGetSubscription(scope: String): GeckoResult<GeckoWebPushSubscription>? {
-        val result: GeckoResult<GeckoWebPushSubscription> = GeckoResult()
-
-        delegate.onGetSubscription(scope) { subscription ->
-            result.complete(subscription?.toGeckoSubscription())
-        }
-
-        return result
-    }
-
-    /**
-     * See [GeckoViewWebPushDelegate.onSubscribe].
-     */
-    override fun onSubscribe(scope: String, appServerKey: ByteArray?): GeckoResult<GeckoWebPushSubscription>? {
-        val result: GeckoResult<GeckoWebPushSubscription> = GeckoResult()
-
-        delegate.onSubscribe(scope, appServerKey) { subscription ->
-            result.complete(subscription?.toGeckoSubscription())
-        }
-
-        return result
-    }
-
-    /**
-     * See [GeckoViewWebPushDelegate.onUnsubscribe].
-     */
-    override fun onUnsubscribe(scope: String): GeckoResult<Void>? {
-        val result: GeckoResult<Void> = GeckoResult()
-
-        delegate.onUnsubscribe(scope) { success ->
-            if (success) {
-                result.complete(null)
-            } else {
-                result.completeExceptionally(WebPushException("Un-subscribing from subscription failed."))
-            }
-        }
-
-        return result
-    }
-}
-
-/**
- * A helper extension to convert the subscription data class to the Gecko-based implementation.
- */
-internal fun WebPushSubscription.toGeckoSubscription() = GeckoWebPushSubscription(
-    scope,
-    endpoint,
-    appServerKey,
-    publicKey,
-    authSecret
-)
-
-internal class WebPushException(message: String) : IllegalStateException(message)
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt
deleted file mode 100644
index 413c1cc90629..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import mozilla.components.concept.engine.webpush.WebPushHandler
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Gecko-based implementation of [WebPushHandler], wrapping the
- * controller object provided by GeckoView.
- */
-internal class GeckoWebPushHandler(
-    private val runtime: GeckoRuntime
-) : WebPushHandler {
-
-    /**
-     * See [WebPushHandler].
-     */
-    override fun onPushMessage(scope: String, message: ByteArray?) {
-        runtime.webPushController.onPushEvent(scope, message)
-    }
-
-    /**
-     * See [WebPushHandler].
-     */
-    override fun onSubscriptionChanged(scope: String) {
-        runtime.webPushController.onSubscriptionChanged(scope)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt b/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt
deleted file mode 100644
index d5ca91901a79..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.window
-
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.window.WindowRequest
-
-/**
- * Gecko-based implementation of [WindowRequest].
- */
-class GeckoWindowRequest(
-    override val url: String = "",
-    private val engineSession: GeckoEngineSession,
-    override val type: WindowRequest.Type = WindowRequest.Type.OPEN
-) : WindowRequest {
-
-    override fun prepare(): EngineSession {
-        return this.engineSession
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt
deleted file mode 100644
index 3b6f5eb427aa..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt
+++ /dev/null
@@ -1,61 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.util.JsonWriter
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.mock
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.doReturn
-import org.mozilla.geckoview.GeckoSession
-import java.io.ByteArrayOutputStream
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineSessionStateTest {
-
-    @Test
-    fun writeTo() {
-        val geckoState: GeckoSession.SessionState = mock()
-        doReturn("<state>").`when`(geckoState).toString()
-
-        val state = GeckoEngineSessionState(geckoState)
-
-        val stream = ByteArrayOutputStream()
-        val writer = JsonWriter(stream.writer())
-        state.writeTo(writer)
-        val json = JSONObject(stream.toString())
-
-        assertEquals(1, json.length())
-        assertTrue(json.has("GECKO_STATE"))
-        assertEquals("<state>", json.getString("GECKO_STATE"))
-    }
-
-    @Test
-    fun fromJSON() {
-        val json = JSONObject().apply {
-            put("GECKO_STATE", "{ 'foo': 'bar' }")
-        }
-
-        val state = GeckoEngineSessionState.fromJSON(json)
-
-        assertEquals("""{"foo":"bar"}""", state.actualState.toString())
-    }
-
-    @Test
-    fun `fromJSON with invalid JSON returns empty State`() {
-        val json = JSONObject().apply {
-            put("nothing", "helpful")
-        }
-
-        val state = GeckoEngineSessionState.fromJSON(json)
-
-        assertNull(state.actualState)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt
deleted file mode 100644
index faab2e9b5ad5..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt
+++ /dev/null
@@ -1,3008 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Intent
-import android.graphics.Color
-import android.os.Handler
-import android.os.Message
-import android.view.WindowManager
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runBlockingTest
-import mozilla.components.browser.errorpages.ErrorType
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.LoadUrlFlags
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.CookiePolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.HitResult
-import mozilla.components.concept.engine.UnsupportedSettingException
-import mozilla.components.concept.engine.content.blocking.Tracker
-import mozilla.components.concept.engine.history.HistoryItem
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.manifest.WebAppManifest
-import mozilla.components.concept.engine.permission.PermissionRequest
-import mozilla.components.concept.engine.request.RequestInterceptor
-import mozilla.components.concept.engine.window.WindowRequest
-import mozilla.components.concept.fetch.Headers
-import mozilla.components.concept.fetch.Response
-import mozilla.components.concept.storage.PageVisit
-import mozilla.components.concept.storage.RedirectSource
-import mozilla.components.concept.storage.VisitType
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.expectException
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import mozilla.components.support.utils.ThreadUtils
-import mozilla.components.test.ReflectionUtils
-import mozilla.components.support.test.argumentCaptor
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentCaptor
-import org.mockito.ArgumentMatchers.anyBoolean
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.ArgumentMatchers.anyList
-import org.mockito.ArgumentMatchers.anyString
-import org.mockito.Mockito.atLeastOnce
-import org.mockito.Mockito.never
-import org.mockito.Mockito.reset
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.verifyZeroInteractions
-import org.mozilla.geckoview.WebResponse
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_AUDIO
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_NONE
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_VIDEO
-import org.mozilla.geckoview.GeckoSession.ProgressDelegate.SecurityInformation
-import org.mozilla.geckoview.GeckoSessionSettings
-import org.mozilla.geckoview.SessionFinder
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebRequestError.ERROR_CATEGORY_UNKNOWN
-import org.mozilla.geckoview.WebRequestError.ERROR_MALFORMED_URI
-import org.mozilla.geckoview.WebRequestError.ERROR_UNKNOWN
-import java.security.Principal
-import java.security.cert.X509Certificate
-typealias GeckoAntiTracking = ContentBlocking.AntiTracking
-typealias GeckoSafeBrowsing = ContentBlocking.SafeBrowsing
-typealias GeckoCookieBehavior = ContentBlocking.CookieBehavior
-
-@ExperimentalCoroutinesApi
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineSessionTest {
-
-    private lateinit var runtime: GeckoRuntime
-    private lateinit var geckoSession: GeckoSession
-    private lateinit var geckoSessionProvider: () -> GeckoSession
-
-    private lateinit var navigationDelegate: ArgumentCaptor<GeckoSession.NavigationDelegate>
-    private lateinit var progressDelegate: ArgumentCaptor<GeckoSession.ProgressDelegate>
-    private lateinit var contentDelegate: ArgumentCaptor<GeckoSession.ContentDelegate>
-    private lateinit var permissionDelegate: ArgumentCaptor<GeckoSession.PermissionDelegate>
-    private lateinit var contentBlockingDelegate: ArgumentCaptor<ContentBlocking.Delegate>
-    private lateinit var historyDelegate: ArgumentCaptor<GeckoSession.HistoryDelegate>
-
-    @Suppress("DEPRECATION")
-    // Deprecation will be handled in https://github.com/mozilla-mobile/android-components/issues/8514
-    @Before
-    fun setup() {
-        ThreadUtils.setHandlerForTest(object : Handler() {
-            override fun sendMessageAtTime(msg: Message, uptimeMillis: Long): Boolean {
-                val wrappedRunnable = Runnable {
-                    try {
-                        msg.callback?.run()
-                    } catch (t: Throwable) {
-                        // We ignore this in the test as the runnable could be calling
-                        // a native method (disposeNative) which won't work in Robolectric
-                    }
-                }
-                return super.sendMessageAtTime(Message.obtain(this, wrappedRunnable), uptimeMillis)
-            }
-        })
-
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        navigationDelegate = ArgumentCaptor.forClass(GeckoSession.NavigationDelegate::class.java)
-        progressDelegate = ArgumentCaptor.forClass(GeckoSession.ProgressDelegate::class.java)
-        contentDelegate = ArgumentCaptor.forClass(GeckoSession.ContentDelegate::class.java)
-        permissionDelegate = ArgumentCaptor.forClass(GeckoSession.PermissionDelegate::class.java)
-        contentBlockingDelegate = ArgumentCaptor.forClass(ContentBlocking.Delegate::class.java)
-        historyDelegate = ArgumentCaptor.forClass(GeckoSession.HistoryDelegate::class.java)
-
-        geckoSession = mockGeckoSession()
-        geckoSessionProvider = { geckoSession }
-    }
-
-    private fun captureDelegates() {
-        verify(geckoSession).navigationDelegate = navigationDelegate.capture()
-        verify(geckoSession).progressDelegate = progressDelegate.capture()
-        verify(geckoSession).contentDelegate = contentDelegate.capture()
-        verify(geckoSession).permissionDelegate = permissionDelegate.capture()
-        verify(geckoSession).contentBlockingDelegate = contentBlockingDelegate.capture()
-        verify(geckoSession).historyDelegate = historyDelegate.capture()
-    }
-
-    @Test
-    fun engineSessionInitialization() {
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        verify(geckoSession).open(any())
-
-        captureDelegates()
-
-        assertNotNull(navigationDelegate.value)
-        assertNotNull(progressDelegate.value)
-    }
-
-    @Test
-    fun isIgnoredForTrackingProtection() {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        var geckoResult = GeckoResult<Boolean?>()
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        var wasExecuted = false
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        session.isIgnoredForTrackingProtection {
-            wasExecuted = it
-        }
-
-        geckoResult.complete(true)
-        assertTrue(wasExecuted)
-
-        geckoResult = GeckoResult()
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        session.isIgnoredForTrackingProtection {
-            wasExecuted = it
-        }
-
-        geckoResult.complete(null)
-        assertFalse(wasExecuted)
-    }
-
-    @Test
-    fun progressDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var observedProgress = 0
-        var observedLoadingState = false
-        var observedSecurityChange = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadingStateChange(loading: Boolean) { observedLoadingState = loading }
-            override fun onProgress(progress: Int) { observedProgress = progress }
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                // We cannot assert on actual parameters as SecurityInfo's fields can't be set
-                // from the outside and its constructor isn't accessible either.
-                observedSecurityChange = true
-            }
-        })
-
-        captureDelegates()
-
-        progressDelegate.value.onPageStart(mock(), "http://mozilla.org")
-        assertEquals(GeckoEngineSession.PROGRESS_START, observedProgress)
-        assertEquals(true, observedLoadingState)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertEquals(GeckoEngineSession.PROGRESS_STOP, observedProgress)
-        assertEquals(false, observedLoadingState)
-
-        // Stop will update the loading state and progress observers even when
-        // we haven't completed been successful.
-        progressDelegate.value.onPageStart(mock(), "http://mozilla.org")
-        assertEquals(GeckoEngineSession.PROGRESS_START, observedProgress)
-        assertEquals(true, observedLoadingState)
-
-        progressDelegate.value.onPageStop(mock(), false)
-        assertEquals(GeckoEngineSession.PROGRESS_STOP, observedProgress)
-        assertEquals(false, observedLoadingState)
-
-        val securityInfo = mock<SecurityInformation>()
-        progressDelegate.value.onSecurityChange(mock(), securityInfo)
-        assertTrue(observedSecurityChange)
-
-        observedSecurityChange = false
-
-        progressDelegate.value.onSecurityChange(mock(), mock())
-        assertTrue(observedSecurityChange)
-    }
-
-    @Test
-    fun navigationDelegateNotifiesObservers() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var observedUrl = ""
-        var observedCanGoBack = false
-        var observedCanGoForward = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-            override fun onNavigationStateChange(canGoBack: Boolean?, canGoForward: Boolean?) {
-                canGoBack?.let { observedCanGoBack = canGoBack }
-                canGoForward?.let { observedCanGoForward = canGoForward }
-            }
-        })
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-
-        geckoResult.complete(true)
-
-        navigationDelegate.value.onLocationChange(mock(), "http://mozilla.org")
-        assertEquals("http://mozilla.org", observedUrl)
-        verify(mockedContentBlockingController).checkException(any())
-
-        navigationDelegate.value.onCanGoBack(mock(), true)
-        assertEquals(true, observedCanGoBack)
-
-        navigationDelegate.value.onCanGoForward(mock(), true)
-        assertEquals(true, observedCanGoForward)
-    }
-
-    // This will be addressed on https://github.com/mozilla-mobile/android-components/issues/8312
-    @Suppress("deprecation")
-    @Test
-    fun contentDelegateNotifiesObserverAboutDownloads() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider, privateMode = true)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        val response = WebResponse.Builder("https://download.mozilla.org/image.png")
-            .addHeader(Headers.Names.CONTENT_TYPE, "image/png")
-            .addHeader(Headers.Names.CONTENT_LENGTH, "42")
-            .body(mock())
-            .build()
-
-        val captor = argumentCaptor<Response>()
-        captureDelegates()
-        contentDelegate.value.onExternalResponse(mock(), response)
-
-        verify(observer).onExternalResource(
-            url = eq("https://download.mozilla.org/image.png"),
-            fileName = eq("image.png"),
-            contentLength = eq(42),
-            contentType = eq("image/png"),
-            userAgent = eq(null),
-            cookie = eq(null),
-            isPrivate = eq(true),
-            response = captor.capture()
-        )
-        assertNotNull(captor.value)
-    }
-
-    @Test
-    fun contentDelegateNotifiesObserverAboutWebAppManifest() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        val json = JSONObject().apply {
-            put("name", "Minimal")
-            put("start_url", "/")
-        }
-        val manifest = WebAppManifest(
-            name = "Minimal",
-            startUrl = "/"
-        )
-
-        captureDelegates()
-        contentDelegate.value.onWebAppManifest(mock(), json)
-
-        verify(observer).onWebAppManifestLoaded(manifest)
-    }
-
-    @Test
-    fun permissionDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val observedContentPermissionRequests: MutableList<PermissionRequest> = mutableListOf()
-        val observedAppPermissionRequests: MutableList<PermissionRequest> = mutableListOf()
-        engineSession.register(object : EngineSession.Observer {
-            override fun onContentPermissionRequest(permissionRequest: PermissionRequest) {
-                observedContentPermissionRequests.add(permissionRequest)
-            }
-
-            override fun onAppPermissionRequest(permissionRequest: PermissionRequest) {
-                observedAppPermissionRequests.add(permissionRequest)
-            }
-        })
-
-        captureDelegates()
-
-        permissionDelegate.value.onContentPermissionRequest(
-            geckoSession,
-            "originContent",
-            GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION,
-            mock()
-        )
-
-        permissionDelegate.value.onContentPermissionRequest(
-            geckoSession,
-            null,
-            GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION,
-            mock()
-        )
-
-        permissionDelegate.value.onMediaPermissionRequest(
-            geckoSession,
-            "originMedia",
-            emptyArray(),
-            emptyArray(),
-            mock()
-        )
-
-        permissionDelegate.value.onMediaPermissionRequest(
-            geckoSession,
-            "about:blank",
-            null,
-            null,
-            mock()
-        )
-
-        permissionDelegate.value.onAndroidPermissionsRequest(
-            geckoSession,
-            emptyArray(),
-            mock()
-        )
-
-        permissionDelegate.value.onAndroidPermissionsRequest(
-            geckoSession,
-            null,
-            mock()
-        )
-
-        assertEquals(4, observedContentPermissionRequests.size)
-        assertEquals("originContent", observedContentPermissionRequests[0].uri)
-        assertEquals("", observedContentPermissionRequests[1].uri)
-        assertEquals("originMedia", observedContentPermissionRequests[2].uri)
-        assertEquals("about:blank", observedContentPermissionRequests[3].uri)
-        assertEquals(2, observedAppPermissionRequests.size)
-    }
-
-    @Test
-    fun loadUrl() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        val parentEngineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadUrl("http://mozilla.org")
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://mozilla.org")
-        )
-
-        engineSession.loadUrl("http://www.mozilla.org", flags = LoadUrlFlags.select(LoadUrlFlags.EXTERNAL))
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").flags(LoadUrlFlags.EXTERNAL)
-        )
-
-        engineSession.loadUrl("http://www.mozilla.org", parent = parentEngineSession)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").referrer(parentEngineSession.geckoSession)
-        )
-
-        val extraHeaders = mapOf("X-Extra-Header" to "true")
-        engineSession.loadUrl("http://www.mozilla.org", additionalHeaders = extraHeaders)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").additionalHeaders(extraHeaders)
-        )
-    }
-
-    @Test
-    fun `loadUrl doesn't load URLs with blocked schemes`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadUrl("file://test.txt")
-        engineSession.loadUrl("FILE://test.txt")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("file://test.txt"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("FILE://test.txt"))
-
-        engineSession.loadUrl("content://authority/path/id")
-        engineSession.loadUrl("CoNtEnT://authority/path/id")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("content://authority/path/id"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("CoNtEnT://authority/path/id"))
-
-        engineSession.loadUrl("resource://package/test.text")
-        engineSession.loadUrl("RESOURCE://package/test.text")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("resource://package/test.text"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("RESOURCE://package/test.text"))
-    }
-
-    @Test
-    fun loadData() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadData("<html><body>Hello!</body></html>")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("<html><body>Hello!</body></html>", "text/html")
-        )
-
-        engineSession.loadData("Hello!", "text/plain", "UTF-8")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("Hello!", "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", "text/plain", "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", encoding = "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/html")
-        )
-    }
-
-    @Test
-    fun loadDataBase64() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadData("Hello!", "text/plain", "UTF-8")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("Hello!", "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", "text/plain", "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", encoding = "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-    }
-
-    @Test
-    fun stopLoading() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.stopLoading()
-
-        verify(geckoSession).stop()
-    }
-
-    @Test
-    fun reload() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        engineSession.loadUrl("http://mozilla.org")
-
-        // Initial load is still in progress so reload should not be called.
-        // Instead we should have called loadUrl again to prevent reloading
-        // about:blank.
-        engineSession.reload()
-        verify(geckoSession, never()).reload(GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-        verify(geckoSession, times(2)).load(
-            GeckoSession.Loader().uri("http://mozilla.org")
-        )
-
-        // Subsequent reloads should simply call reload on the gecko session.
-        engineSession.initialLoadRequest = null
-        engineSession.reload()
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_NONE)
-
-        engineSession.reload(flags = LoadUrlFlags.select(LoadUrlFlags.BYPASS_CACHE))
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-    }
-
-    @Test
-    fun goBack() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goBack()
-
-        verify(geckoSession).goBack()
-    }
-
-    @Test
-    fun goForward() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goForward()
-
-        verify(geckoSession).goForward()
-    }
-
-    @Test
-    fun goToHistoryIndex() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goToHistoryIndex(0)
-
-        verify(geckoSession).gotoHistoryIndex(0)
-    }
-
-    @Test
-    fun restoreState() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val actualState: GeckoSession.SessionState = mock()
-        val state = GeckoEngineSessionState(actualState)
-
-        assertTrue(engineSession.restoreState(state))
-        verify(geckoSession).restoreState(any())
-    }
-
-    @Test
-    fun `restoreState returns false for null state`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        val state = GeckoEngineSessionState(null)
-
-        assertFalse(engineSession.restoreState(state))
-        verify(geckoSession, never()).restoreState(any())
-    }
-
-    @Test
-    fun progressDelegateIgnoresInitialLoadOfAboutBlank() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var observedSecurityChange = false
-        var progressObserved = false
-        var loadingStateChangeObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedSecurityChange = true
-            }
-
-            override fun onProgress(progress: Int) {
-                progressObserved = true
-            }
-
-            override fun onLoadingStateChange(loading: Boolean) {
-                loadingStateChangeObserved = true
-            }
-        })
-
-        captureDelegates()
-
-        progressDelegate.value.onSecurityChange(mock(),
-                MockSecurityInformation("moz-nullprincipal:{uuid}"))
-        assertFalse(observedSecurityChange)
-
-        progressDelegate.value.onSecurityChange(mock(),
-                MockSecurityInformation("https://www.mozilla.org"))
-        assertTrue(observedSecurityChange)
-
-        progressDelegate.value.onPageStart(mock(), "about:blank")
-        assertFalse(progressObserved)
-        assertFalse(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertFalse(progressObserved)
-        assertFalse(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStart(mock(), "https://www.mozilla.org")
-        assertTrue(progressObserved)
-        assertTrue(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertTrue(progressObserved)
-        assertTrue(loadingStateChangeObserved)
-    }
-
-    @Test
-    fun navigationDelegateIgnoresInitialLoadOfAboutBlank() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var observedUrl = ""
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-        })
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-
-        geckoResult.complete(true)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", observedUrl)
-        verify(mockedContentBlockingController).checkException(any())
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("about:blank", observedUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will reset initial load flag on process switch to ignore about blank loads`() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        captureDelegates()
-        assertTrue(session.initialLoad)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://mozilla.org")
-        assertFalse(session.initialLoad)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("moz-extension://1234-test"))
-        assertTrue(session.initialLoad)
-
-        var observedUrl = ""
-        session.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-        })
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("about:blank", observedUrl)
-    }
-
-    @Test
-    fun `do not keep track of current url via onPageStart events`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        assertNull(engineSession.currentUrl)
-        progressDelegate.value.onPageStart(geckoSession, "https://www.mozilla.org")
-        assertNull(engineSession.currentUrl)
-
-        progressDelegate.value.onPageStart(geckoSession, "https://www.firefox.com")
-        assertNull(engineSession.currentUrl)
-    }
-
-    @Test
-    fun `keeps track of current url via onLocationChange events`() {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        var geckoResult = GeckoResult<Boolean?>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-        geckoResult.complete(true)
-
-        assertNull(engineSession.currentUrl)
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", engineSession.currentUrl)
-
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.firefox.com")
-        assertEquals("https://www.firefox.com", engineSession.currentUrl)
-    }
-
-    @Test
-    fun `notifies configured history delegate of title changes`() = runBlockingTest {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-        var geckoResult = GeckoResult<Boolean?>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-        geckoResult.complete(true)
-
-        // Nothing breaks if history delegate isn't configured.
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-
-        // This sets the currentUrl.
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.mozilla.com")
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate).onTitleChanged(eq("https://www.mozilla.com"), eq("Hello World!"))
-    }
-
-    @Test
-    fun `does not notify configured history delegate of title changes for private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-        verify(observer).onTitleChange("Hello World!")
-
-        // This sets the currentUrl.
-        progressDelegate.value.onPageStart(geckoSession, "https://www.mozilla.com")
-
-        contentDelegate.value.onTitleChange(geckoSession, "Mozilla")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-        verify(observer).onTitleChange("Mozilla")
-    }
-
-    @Test
-    fun `does not notify configured history delegate for redirects`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `does not notify configured history delegate for top-level visits to error pages`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "about:neterror", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL or GeckoSession.HistoryDelegate.VISIT_UNRECOVERABLE_ERROR)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `notifies configured history delegate of visits`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com")).thenReturn(true)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com"), eq(PageVisit(VisitType.LINK, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `notifies configured history delegate of reloads`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com")).thenReturn(true)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", "https://www.mozilla.com", GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com"), eq(PageVisit(VisitType.RELOAD, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `checks with the delegate before trying to record a visit`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com/allowed")).thenReturn(true)
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com/not-allowed")).thenReturn(false)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com/allowed", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).shouldStoreUri("https://www.mozilla.com/allowed")
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/allowed"), eq(PageVisit(VisitType.LINK, RedirectSource.NOT_A_SOURCE)))
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com/not-allowed", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).shouldStoreUri("https://www.mozilla.com/not-allowed")
-        verify(historyTrackingDelegate, never()).onVisited(eq("https://www.mozilla.com/not-allowed"), any())
-    }
-
-    @Test
-    fun `correctly processes redirect visit flags`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri(any())).thenReturn(true)
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/tempredirect",
-                null,
-                // bitwise 'or'
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/tempredirect"), eq(PageVisit(VisitType.LINK, RedirectSource.TEMPORARY)))
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/permredirect",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE_PERMANENT
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/permredirect"), eq(PageVisit(VisitType.LINK, RedirectSource.PERMANENT)))
-
-        // Visits below are targets of redirects, not redirects themselves.
-        // Check that they're mapped to "link".
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/targettemp",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/targettemp"), eq(PageVisit(VisitType.REDIRECT_TEMPORARY, RedirectSource.NOT_A_SOURCE)))
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/targetperm",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_PERMANENT
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/targetperm"), eq(PageVisit(VisitType.REDIRECT_PERMANENT, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `does not notify configured history delegate of visits for private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", "https://www.mozilla.com", GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `requests visited URLs from configured history delegate`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).getVisited(eq(listOf("https://www.mozilla.com", "https://www.mozilla.org")))
-    }
-
-    @Test
-    fun `does not request visited URLs from configured history delegate in private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).getVisited(anyList())
-    }
-
-    @Test
-    fun `notifies configured history delegate of state changes`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val observer = mock<EngineSession.Observer>()
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        class MockHistoryList(
-            items: List<GeckoSession.HistoryDelegate.HistoryItem>,
-            private val currentIndex: Int
-        ) : ArrayList<GeckoSession.HistoryDelegate.HistoryItem>(items), GeckoSession.HistoryDelegate.HistoryList {
-            override fun getCurrentIndex() = currentIndex
-        }
-
-        fun mockHistoryItem(title: String?, uri: String): GeckoSession.HistoryDelegate.HistoryItem {
-            val item = mock<GeckoSession.HistoryDelegate.HistoryItem>()
-            whenever(item.title).thenReturn(title)
-            whenever(item.uri).thenReturn(uri)
-            return item
-        }
-
-        historyDelegate.value.onHistoryStateChange(mock(), MockHistoryList(emptyList(), 0))
-        verify(observer).onHistoryStateChanged(emptyList(), 0)
-
-        historyDelegate.value.onHistoryStateChange(mock(), MockHistoryList(listOf(
-            mockHistoryItem("Firefox", "https://firefox.com"),
-            mockHistoryItem("Mozilla", "http://mozilla.org"),
-            mockHistoryItem(null, "https://example.com")
-        ), 1))
-        verify(observer).onHistoryStateChanged(listOf(
-            HistoryItem("Firefox", "https://firefox.com"),
-            HistoryItem("Mozilla", "http://mozilla.org"),
-            HistoryItem("https://example.com", "https://example.com")
-        ), 1)
-    }
-
-    @Test
-    fun websiteTitleUpdates() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        verify(observer).onTitleChange("Hello World!")
-    }
-
-    @Test
-    fun trackingProtectionDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(
-            mock(),
-            geckoSessionProvider = geckoSessionProvider
-        )
-
-        var trackerBlocked: Tracker? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onTrackerBlocked(tracker: Tracker) {
-                trackerBlocked = tracker
-            }
-        })
-
-        captureDelegates()
-        var geckoCategories = 0
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.AD)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.ANALYTIC)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.SOCIAL)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.CRYPTOMINING)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.FINGERPRINTING)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.CONTENT)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.TEST)
-
-        contentBlockingDelegate.value.onContentBlocked(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", geckoCategories, 0, 0, false)
-        )
-
-        assertEquals("tracker1", trackerBlocked!!.url)
-
-        val expectedBlockedCategories = listOf(
-            TrackingCategory.AD,
-            TrackingCategory.ANALYTICS,
-            TrackingCategory.SOCIAL,
-            TrackingCategory.CRYPTOMINING,
-            TrackingCategory.FINGERPRINTING,
-            TrackingCategory.CONTENT,
-            TrackingCategory.TEST
-        )
-
-        assertTrue(trackerBlocked!!.trackingCategories.containsAll(expectedBlockedCategories))
-
-        var trackerLoaded: Tracker? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onTrackerLoaded(tracker: Tracker) {
-                trackerLoaded = tracker
-            }
-        })
-
-        var geckoCookieCategories = 0
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_ALL)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_VISITED)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_NON_TRACKERS)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_NONE)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_FIRST_PARTY)
-
-        contentBlockingDelegate.value.onContentLoaded(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", 0, 0, geckoCookieCategories, false)
-        )
-
-        val expectedCookieCategories = listOf(
-            CookiePolicy.ACCEPT_ONLY_FIRST_PARTY,
-            CookiePolicy.ACCEPT_NONE,
-            CookiePolicy.ACCEPT_VISITED,
-            CookiePolicy.ACCEPT_NON_TRACKERS
-        )
-
-        assertEquals("tracker1", trackerLoaded!!.url)
-        assertTrue(trackerLoaded!!.cookiePolicies.containsAll(expectedCookieCategories))
-
-        contentBlockingDelegate.value.onContentLoaded(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", 0, 0, GeckoCookieBehavior.ACCEPT_ALL, false)
-        )
-
-        assertTrue(
-            trackerLoaded!!.cookiePolicies.containsAll(
-                listOf(
-                    CookiePolicy.ACCEPT_ALL
-                )
-            )
-        )
-    }
-
-    @Test
-    fun `WHEN updateing tracking protection with a recommended policy THEN etpEnabled should be enabled`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-
-        val session = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        var trackerBlockingObserved = false
-
-        session.register(object : EngineSession.Observer {
-            override fun onTrackerBlockingEnabledChange(enabled: Boolean) {
-                trackerBlockingObserved = enabled
-            }
-        })
-
-        val policy = TrackingProtectionPolicy.recommended()
-        session.updateTrackingProtection(policy)
-
-        verify(session).updateContentBlocking(policy)
-        assertTrue(session.etpEnabled!!)
-        assertTrue(trackerBlockingObserved)
-    }
-
-    @Test
-    fun `WHEN calling updateTrackingProtection with a none policy THEN etpEnabled should be disabled`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-
-        val session = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        var trackerBlockingObserved = false
-
-        session.register(object : EngineSession.Observer {
-            override fun onTrackerBlockingEnabledChange(enabled: Boolean) {
-                trackerBlockingObserved = enabled
-            }
-        })
-
-        val policy = TrackingProtectionPolicy.none()
-        session.updateTrackingProtection(policy)
-
-        verify(session).updateContentBlocking(policy)
-        assertFalse(session.etpEnabled!!)
-        assertFalse(trackerBlockingObserved)
-    }
-
-    @Test
-    fun `WHEN updating the contentBlocking with a policy SCRIPTS_AND_SUB_RESOURCES useForPrivateSessions being in privateMode THEN useTrackingProtection should be true`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        val session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = true
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.select(trackingCategories = arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)).forPrivateSessionsOnly()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN calling updateContentBlocking with a policy SCRIPTS_AND_SUB_RESOURCES useForRegularSessions being in privateMode THEN useTrackingProtection should be true`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        val session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = false
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.select(trackingCategories = arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)).forRegularSessionsOnly()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN updating content blocking without a policy SCRIPTS_AND_SUB_RESOURCES for any browsing mode THEN useTrackingProtection should be false`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        var session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = false
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.none()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = false
-
-        session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = true
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-        session.geckoSession = geckoSession
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting, times(2)).useTrackingProtection = false
-    }
-
-    @Test
-    fun `changes to updateTrackingProtection will be notified to all new observers`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        val observers = mutableListOf<EngineSession.Observer>()
-        val policy = TrackingProtectionPolicy.strict()
-
-        for (x in 1..5) {
-            observers.add(spy(object : EngineSession.Observer {}))
-        }
-
-        session.updateTrackingProtection(policy)
-
-        observers.forEach { session.register(it) }
-
-        observers.forEach {
-            verify(it).onTrackerBlockingEnabledChange(true)
-        }
-
-        observers.forEach { session.unregister(it) }
-
-        session.updateTrackingProtection(TrackingProtectionPolicy.none())
-
-        observers.forEach { session.register(it) }
-
-        observers.forEach {
-            verify(it).onTrackerBlockingEnabledChange(false)
-        }
-    }
-
-    @Test
-    fun safeBrowsingCategoriesAreAligned() {
-        assertEquals(GeckoSafeBrowsing.NONE, SafeBrowsingPolicy.NONE.id)
-        assertEquals(GeckoSafeBrowsing.MALWARE, SafeBrowsingPolicy.MALWARE.id)
-        assertEquals(GeckoSafeBrowsing.UNWANTED, SafeBrowsingPolicy.UNWANTED.id)
-        assertEquals(GeckoSafeBrowsing.HARMFUL, SafeBrowsingPolicy.HARMFUL.id)
-        assertEquals(GeckoSafeBrowsing.PHISHING, SafeBrowsingPolicy.PHISHING.id)
-        assertEquals(GeckoSafeBrowsing.DEFAULT, SafeBrowsingPolicy.RECOMMENDED.id)
-    }
-
-    @Test
-    fun trackingProtectionCategoriesAreAligned() {
-
-        assertEquals(GeckoAntiTracking.NONE, TrackingCategory.NONE.id)
-        assertEquals(GeckoAntiTracking.AD, TrackingCategory.AD.id)
-        assertEquals(GeckoAntiTracking.CONTENT, TrackingCategory.CONTENT.id)
-        assertEquals(GeckoAntiTracking.SOCIAL, TrackingCategory.SOCIAL.id)
-        assertEquals(GeckoAntiTracking.TEST, TrackingCategory.TEST.id)
-        assertEquals(GeckoAntiTracking.CRYPTOMINING, TrackingCategory.CRYPTOMINING.id)
-        assertEquals(GeckoAntiTracking.FINGERPRINTING, TrackingCategory.FINGERPRINTING.id)
-        assertEquals(GeckoAntiTracking.STP, TrackingCategory.MOZILLA_SOCIAL.id)
-
-        assertEquals(GeckoCookieBehavior.ACCEPT_ALL, CookiePolicy.ACCEPT_ALL.id)
-        assertEquals(
-            GeckoCookieBehavior.ACCEPT_NON_TRACKERS,
-            CookiePolicy.ACCEPT_NON_TRACKERS.id
-        )
-        assertEquals(GeckoCookieBehavior.ACCEPT_NONE, CookiePolicy.ACCEPT_NONE.id)
-        assertEquals(
-            GeckoCookieBehavior.ACCEPT_FIRST_PARTY, CookiePolicy.ACCEPT_ONLY_FIRST_PARTY.id
-
-        )
-        assertEquals(GeckoCookieBehavior.ACCEPT_VISITED, CookiePolicy.ACCEPT_VISITED.id)
-    }
-
-    @Test
-    fun settingTestingMode() {
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings())
-        verify(geckoSession.settings).fullAccessibilityTree = false
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings(testingModeEnabled = true))
-        verify(geckoSession.settings).fullAccessibilityTree = true
-    }
-
-    @Test
-    fun settingUserAgent() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        engineSession.settings.userAgentString
-
-        verify(geckoSession.settings).userAgentOverride
-
-        engineSession.settings.userAgentString = "test-ua"
-
-        verify(geckoSession.settings).userAgentOverride = "test-ua"
-    }
-
-    @Test
-    fun settingUserAgentDefault() {
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings(userAgentString = "test-ua"))
-
-        verify(geckoSession.settings).userAgentOverride = "test-ua"
-    }
-
-    @Test
-    fun settingSuspendMediaWhenInactive() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        verify(geckoSession.settings, never()).suspendMediaWhenInactive = anyBoolean()
-
-        assertFalse(engineSession.settings.suspendMediaWhenInactive)
-        verify(geckoSession.settings).suspendMediaWhenInactive
-
-        engineSession.settings.suspendMediaWhenInactive = true
-        verify(geckoSession.settings).suspendMediaWhenInactive = true
-    }
-
-    @Test
-    fun settingSuspendMediaWhenInactiveDefault() {
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        verify(geckoSession.settings, never()).suspendMediaWhenInactive = anyBoolean()
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings())
-        verify(geckoSession.settings).suspendMediaWhenInactive = false
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings(suspendMediaWhenInactive = true))
-        verify(geckoSession.settings).suspendMediaWhenInactive = true
-    }
-
-    @Test
-    fun settingClearColorDefault() {
-        whenever(geckoSession.compositorController).thenReturn(mock())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        verify(geckoSession.compositorController, never()).clearColor = anyInt()
-
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings())
-        verify(geckoSession.compositorController, never()).clearColor = anyInt()
-
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings(clearColor = Color.BLUE))
-        verify(geckoSession.compositorController).clearColor = Color.BLUE
-    }
-
-    @Test
-    fun unsupportedSettings() {
-        val settings = GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider).settings
-
-        expectException(UnsupportedSettingException::class) {
-            settings.javascriptEnabled = true
-        }
-
-        expectException(UnsupportedSettingException::class) {
-            settings.domStorageEnabled = false
-        }
-
-        expectException(UnsupportedSettingException::class) {
-            settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-        }
-    }
-
-    @Test
-    fun settingInterceptorToProvideAlternativeContent() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return RequestInterceptor.InterceptionResponse.Content("<h1>Hello World</h1>")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        assertEquals("sample:about", interceptorCalledWithUri)
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("<h1>Hello World</h1>", "text/html")
-        )
-    }
-
-    @Test
-    fun settingInterceptorToProvideAlternativeUrl() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return RequestInterceptor.InterceptionResponse.Url("https://mozilla.org")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", "trigger:uri"))
-
-        assertEquals("sample:about", interceptorCalledWithUri)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("https://mozilla.org")
-        )
-    }
-
-    @Test
-    fun settingInterceptorCanIgnoreAppInitiatedRequests() {
-        var interceptorCalled = false
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = false
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalled = true
-                return RequestInterceptor.InterceptionResponse.Url("https://mozilla.org")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", isDirectNavigation = true))
-        assertFalse(interceptorCalled)
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", isDirectNavigation = false))
-        assertTrue(interceptorCalled)
-    }
-
-    @Test
-    fun onLoadRequestWithoutInterceptor() {
-        val defaultSettings = DefaultSettings()
-
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        verify(geckoSession, never()).load(any())
-    }
-
-    @Test
-    fun onLoadRequestWithInterceptorThatDoesNotIntercept() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return null
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        assertEquals("sample:about", interceptorCalledWithUri!!)
-        verify(geckoSession, never()).load(any())
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithNull() {
-        var interceptedUri: String? = null
-        val requestInterceptor: RequestInterceptor = mock()
-        var defaultSettings = DefaultSettings()
-        var engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        // Interceptor is not called when there is none attached.
-        var onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-        verify(requestInterceptor, never()).onErrorRequest(engineSession, ErrorType.UNKNOWN, "")
-        onLoadError!!.then { value: String? ->
-            interceptedUri = value
-            GeckoResult.fromValue(null)
-        }
-        assertNull(interceptedUri)
-
-        // Interceptor is called correctly
-        defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        geckoSession = mockGeckoSession()
-        engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-
-        verify(requestInterceptor).onErrorRequest(engineSession, ErrorType.UNKNOWN, "")
-        onLoadError!!.then { value: String? ->
-            interceptedUri = value
-            GeckoResult.fromValue(null)
-        }
-        assertNull(interceptedUri)
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithErrorPage() {
-        val requestInterceptor: RequestInterceptor = object : RequestInterceptor {
-            override fun onErrorRequest(
-                session: EngineSession,
-                errorType: ErrorType,
-                uri: String?
-            ): RequestInterceptor.ErrorResponse? =
-                RequestInterceptor.ErrorResponse("nonNullData")
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        val onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "about:failed",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-
-        onLoadError!!.then { value: String? ->
-            GeckoResult.fromValue(value)
-        }
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithInvalidUri() {
-        val requestInterceptor: RequestInterceptor = mock()
-        val defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        val engineSession = GeckoEngineSession(runtime, defaultSettings = defaultSettings)
-
-        engineSession.geckoSession.navigationDelegate!!.onLoadError(
-            engineSession.geckoSession,
-            null,
-            WebRequestError(ERROR_MALFORMED_URI, ERROR_CATEGORY_UNKNOWN)
-        )
-        verify(requestInterceptor).onErrorRequest(engineSession, ErrorType.ERROR_MALFORMED_URI, null)
-    }
-
-    @Test
-    fun geckoErrorMappingToErrorType() {
-        assertEquals(
-            ErrorType.ERROR_SECURITY_SSL,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SECURITY_SSL)
-        )
-        assertEquals(
-            ErrorType.ERROR_SECURITY_BAD_CERT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SECURITY_BAD_CERT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_INTERRUPT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_INTERRUPT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_TIMEOUT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_TIMEOUT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_RESET,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_RESET)
-        )
-        assertEquals(
-            ErrorType.ERROR_CONNECTION_REFUSED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CONNECTION_REFUSED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_SOCKET_TYPE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_SOCKET_TYPE)
-        )
-        assertEquals(
-            ErrorType.ERROR_REDIRECT_LOOP,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_REDIRECT_LOOP)
-        )
-        assertEquals(
-            ErrorType.ERROR_OFFLINE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_OFFLINE)
-        )
-        assertEquals(
-            ErrorType.ERROR_PORT_BLOCKED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_PORT_BLOCKED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNSAFE_CONTENT_TYPE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNSAFE_CONTENT_TYPE)
-        )
-        assertEquals(
-            ErrorType.ERROR_CORRUPTED_CONTENT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CORRUPTED_CONTENT)
-        )
-        assertEquals(
-            ErrorType.ERROR_CONTENT_CRASHED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CONTENT_CRASHED)
-        )
-        assertEquals(
-            ErrorType.ERROR_INVALID_CONTENT_ENCODING,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_INVALID_CONTENT_ENCODING)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_HOST,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_HOST)
-        )
-        assertEquals(
-            ErrorType.ERROR_MALFORMED_URI,
-            GeckoEngineSession.geckoErrorToErrorType(ERROR_MALFORMED_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_PROTOCOL,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_PROTOCOL)
-        )
-        assertEquals(
-            ErrorType.ERROR_FILE_NOT_FOUND,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_FILE_NOT_FOUND)
-        )
-        assertEquals(
-            ErrorType.ERROR_FILE_ACCESS_DENIED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_FILE_ACCESS_DENIED)
-        )
-        assertEquals(
-            ErrorType.ERROR_PROXY_CONNECTION_REFUSED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_PROXY_CONNECTION_REFUSED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_PROXY_HOST,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_PROXY_HOST)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_MALWARE_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_MALWARE_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_HARMFUL_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_HARMFUL_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_PHISHING_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_PHISHING_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_UNWANTED_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_UNWANTED_URI)
-        )
-        assertEquals(
-            ErrorType.UNKNOWN,
-            GeckoEngineSession.geckoErrorToErrorType(-500)
-        )
-    }
-
-    @Test
-    fun defaultSettings() {
-        val runtime = mock<GeckoRuntime>()
-        whenever(runtime.settings).thenReturn(mock())
-
-        val defaultSettings =
-            DefaultSettings(trackingProtectionPolicy = TrackingProtectionPolicy.strict())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-                privateMode = false, defaultSettings = defaultSettings)
-
-        assertFalse(geckoSession.settings.usePrivateMode)
-        verify(geckoSession.settings).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN TrackingCategory do not includes content then useTrackingProtection must be set to false`() {
-        val defaultSettings =
-            DefaultSettings(trackingProtectionPolicy = TrackingProtectionPolicy.recommended())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-            privateMode = false, defaultSettings = defaultSettings)
-
-        verify(geckoSession.settings).useTrackingProtection = false
-    }
-
-    @Test
-    fun contentDelegate() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        val delegate = engineSession.createContentDelegate()
-
-        var observedChanged = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLongPress(hitResult: HitResult) {
-                observedChanged = true
-            }
-        })
-
-        class MockContextElement(
-            baseUri: String?,
-            linkUri: String?,
-            title: String?,
-            altText: String?,
-            typeStr: String,
-            srcUri: String?
-        ) : GeckoSession.ContentDelegate.ContextElement(baseUri, linkUri, title, altText, typeStr, srcUri)
-
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "HTMLAudioElement", "file.mp3"))
-        assertTrue(observedChanged)
-
-        observedChanged = false
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "HTMLAudioElement", null))
-        assertFalse(observedChanged)
-
-        observedChanged = false
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "foobar", null))
-        assertFalse(observedChanged)
-    }
-
-    @Test
-    fun handleLongClick() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var result = engineSession.handleLongClick("file.mp3", TYPE_AUDIO)
-        assertNotNull(result)
-        assertTrue(result is HitResult.AUDIO && result.src == "file.mp3")
-
-        result = engineSession.handleLongClick("file.mp4", TYPE_VIDEO)
-        assertNotNull(result)
-        assertTrue(result is HitResult.VIDEO && result.src == "file.mp4")
-
-        result = engineSession.handleLongClick("file.png", TYPE_IMAGE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.IMAGE && result.src == "file.png")
-
-        result = engineSession.handleLongClick("file.png", TYPE_IMAGE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.IMAGE_SRC && result.src == "file.png" && result.uri == "https://mozilla.org")
-
-        result = engineSession.handleLongClick(null, TYPE_IMAGE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "")
-
-        result = engineSession.handleLongClick("tel:+1234567890", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.PHONE && result.src == "tel:+1234567890")
-
-        result = engineSession.handleLongClick("geo:1,-1", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.GEO && result.src == "geo:1,-1")
-
-        result = engineSession.handleLongClick("mailto:asa@mozilla.com", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.EMAIL && result.src == "mailto:asa@mozilla.com")
-
-        result = engineSession.handleLongClick(null, TYPE_NONE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "https://mozilla.org")
-
-        result = engineSession.handleLongClick("data://foobar", TYPE_NONE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "data://foobar")
-
-        result = engineSession.handleLongClick(null, TYPE_NONE, null)
-        assertNull(result)
-    }
-
-    @Test
-    fun setDesktopMode() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var desktopModeToggled = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onDesktopModeChange(enabled: Boolean) {
-                desktopModeToggled = true
-            }
-        })
-        engineSession.toggleDesktopMode(true)
-        assertTrue(desktopModeToggled)
-
-        desktopModeToggled = false
-        whenever(geckoSession.settings.userAgentMode)
-                .thenReturn(GeckoSessionSettings.USER_AGENT_MODE_DESKTOP)
-        whenever(geckoSession.settings.viewportMode)
-                .thenReturn(GeckoSessionSettings.VIEWPORT_MODE_DESKTOP)
-
-        engineSession.toggleDesktopMode(true)
-        assertFalse(desktopModeToggled)
-
-        engineSession.toggleDesktopMode(true)
-        assertFalse(desktopModeToggled)
-
-        engineSession.toggleDesktopMode(false)
-        assertTrue(desktopModeToggled)
-    }
-
-    @Test
-    fun `toggleDesktopMode should reload a non-mobile url when set to desktop mode`() {
-        val mobileUrl = "https://m.example.com"
-        val nonMobileUrl = "https://example.com"
-        val engineSession = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        engineSession.currentUrl = mobileUrl
-
-        engineSession.toggleDesktopMode(true, reload = true)
-        verify(engineSession, atLeastOnce()).loadUrl(nonMobileUrl, null, LoadUrlFlags.select(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY), null)
-
-        engineSession.toggleDesktopMode(false, reload = true)
-        verify(engineSession, atLeastOnce()).reload()
-    }
-
-    @Test
-    fun checkForMobileSite() {
-        val mUrl = "https://m.example.com"
-        val mobileUrl = "https://mobile.example.com"
-        val nonAuthorityUrl = "mobile.example.com"
-        val unrecognizedMobilePrefixUrl = "https://phone.example.com"
-        val nonMobileUrl = "https://example.com"
-
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        assertNull(engineSession.checkForMobileSite(nonAuthorityUrl))
-        assertNull(engineSession.checkForMobileSite(unrecognizedMobilePrefixUrl))
-        assertEquals(nonMobileUrl, engineSession.checkForMobileSite(mUrl))
-        assertEquals(nonMobileUrl, engineSession.checkForMobileSite(mobileUrl))
-    }
-
-    @Test
-    fun findAll() {
-        val finderResult = mock<GeckoSession.FinderResult>()
-        val sessionFinder = mock<SessionFinder>()
-        whenever(sessionFinder.find("mozilla", 0))
-                .thenReturn(GeckoResult.fromValue(finderResult))
-
-        whenever(geckoSession.finder).thenReturn(sessionFinder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var findObserved: String? = null
-        var findResultObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFind(text: String) {
-                findObserved = text
-            }
-
-            override fun onFindResult(activeMatchOrdinal: Int, numberOfMatches: Int, isDoneCounting: Boolean) {
-                assertEquals(0, activeMatchOrdinal)
-                assertEquals(0, numberOfMatches)
-                assertTrue(isDoneCounting)
-                findResultObserved = true
-            }
-        })
-
-        engineSession.findAll("mozilla")
-
-        assertEquals("mozilla", findObserved)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find("mozilla", 0)
-    }
-
-    @Test
-    fun findNext() {
-        val finderResult = mock<GeckoSession.FinderResult>()
-        val sessionFinder = mock<SessionFinder>()
-        whenever(sessionFinder.find(eq(null), anyInt()))
-                .thenReturn(GeckoResult.fromValue(finderResult))
-
-        whenever(geckoSession.finder).thenReturn(sessionFinder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var findResultObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFindResult(activeMatchOrdinal: Int, numberOfMatches: Int, isDoneCounting: Boolean) {
-                assertEquals(0, activeMatchOrdinal)
-                assertEquals(0, numberOfMatches)
-                assertTrue(isDoneCounting)
-                findResultObserved = true
-            }
-        })
-
-        engineSession.findNext(true)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find(null, 0)
-
-        engineSession.findNext(false)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find(null, GeckoSession.FINDER_FIND_BACKWARDS)
-    }
-
-    @Test
-    fun clearFindMatches() {
-        val finder = mock<SessionFinder>()
-        whenever(geckoSession.finder).thenReturn(finder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.clearFindMatches()
-
-        verify(finder).clear()
-    }
-
-    @Test
-    fun exitFullScreenModeTriggersExitEvent() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        // Verify the event is triggered for exiting fullscreen mode and GeckoView is called.
-        engineSession.exitFullScreenMode()
-        verify(geckoSession).exitFullScreen()
-
-        // Verify the call to the observer.
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        contentDelegate.value.onFullScreen(geckoSession, true)
-
-        verify(observer).onFullScreenChange(true)
-    }
-
-    @Test
-    fun exitFullscreenTrueHasNoInteraction() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.exitFullScreenMode()
-        verify(geckoSession).exitFullScreen()
-    }
-
-    @Test
-    fun viewportFitChangeTranslateValuesCorrectly() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        // Verify the call to the observer.
-        engineSession.register(observer)
-        captureDelegates()
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "test")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "auto")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "cover")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "contain")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER)
-        reset(observer)
-    }
-
-    @Test
-    fun clearData() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        engineSession.register(observer)
-
-        engineSession.clearData()
-
-        verifyZeroInteractions(observer)
-    }
-
-    @Test
-    fun `Closing engine session should close underlying gecko session`() {
-        val geckoSession = mockGeckoSession()
-
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = { geckoSession })
-
-        engineSession.close()
-
-        verify(geckoSession).close()
-    }
-
-    @Test
-    fun `onLoadRequest will try to intercept new window load requests`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        var result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.DENY)
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-
-        result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = false)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.DENY)
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `onLoadRequest allows new window requests if not intercepted`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        var result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("about:blank", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertNull(observedIntent)
-        assertNull(observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-
-        result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("https://www.example.com", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertNull(observedIntent)
-        assertNull(observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `onLoadRequest not intercepted and not new window will notify observer`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        val result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("https://www.example.com", null, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertEquals("https://www.example.com", observedLoadUrl)
-        assertEquals(true, observedTriggeredByRedirect)
-        assertEquals(false, observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `State provided through delegate will be returned from saveState`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        val state: GeckoSession.SessionState = mock()
-
-        var observedState: EngineSessionState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onStateUpdated(state: EngineSessionState) {
-                observedState = state
-            }
-        })
-
-        progressDelegate.value.onSessionStateChange(mock(), state)
-
-        assertNotNull(observedState)
-        assertTrue(observedState is GeckoEngineSessionState)
-
-        val actualState = (observedState as GeckoEngineSessionState).actualState
-        assertEquals(state, actualState)
-    }
-
-    @Test
-    fun `onFirstContentfulPaint notifies observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observed = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFirstContentfulPaint() {
-                observed = true
-            }
-        })
-
-        contentDelegate.value.onFirstContentfulPaint(mock())
-        assertTrue(observed)
-    }
-
-    @Test
-    fun `onPaintStatusReset notifies observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observed = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onPaintStatusReset() {
-                observed = true
-            }
-        })
-
-        contentDelegate.value.onPaintStatusReset(mock())
-        assertTrue(observed)
-    }
-
-    @Test
-    fun `onCrash notifies observers about crash`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var crashedState = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onCrash() {
-                crashedState = true
-            }
-        })
-
-        contentDelegate.value.onCrash(mock())
-
-        assertEquals(true, crashedState)
-    }
-
-    @Test
-    fun `onLoadRequest will notify onLaunchIntent observers if request was intercepted with app intent`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-    }
-
-    @Test
-    fun `onLoadRequest keep track of the last onLoadRequest uri correctly`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                observedUrl = lastUri
-                return null
-            }
-        }
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test1"))
-        assertEquals(null, observedUrl)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test2"))
-        assertEquals("test1", observedUrl)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test3"))
-        assertEquals("test2", observedUrl)
-    }
-
-    @Test
-    fun `onSubframeLoadRequest will notify onLaunchIntent observers if request was intercepted with app intent`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-        var observedIsSubframe = false
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                observedIsSubframe = isSubframeRequest
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-        })
-
-        navigationDelegate.value.onSubframeLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertEquals(true, observedIsSubframe)
-
-        navigationDelegate.value.onSubframeLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertEquals(true, observedIsSubframe)
-    }
-
-    @Test
-    fun `onLoadRequest will notify any observers if request was intercepted as url`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLaunchIntentUrl: String? = null
-        var observedLaunchIntent: Intent? = null
-        var observedOnLoadRequestUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.Url("result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedLaunchIntentUrl = url
-                observedLaunchIntent = appIntent
-            }
-
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedOnLoadRequestUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(mock(),
-            mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-        assertNull(observedOnLoadRequestUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-        assertNull(observedOnLoadRequestUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will notify onLoadRequest observers if request was not intercepted`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLaunchIntentUrl: String? = null
-        var observedLaunchIntent: Intent? = null
-        var observedOnLoadRequestUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedLaunchIntentUrl = url
-                observedLaunchIntent = appIntent
-            }
-
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedOnLoadRequestUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(mock(),
-            mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNotNull(observedTriggeredByRedirect)
-        assertTrue(observedTriggeredByRedirect!!)
-        assertNotNull(observedTriggeredByWebContent)
-        assertFalse(observedTriggeredByWebContent!!)
-        assertEquals("sample:about", observedOnLoadRequestUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNotNull(observedTriggeredByRedirect)
-        assertFalse(observedTriggeredByRedirect!!)
-        assertNotNull(observedTriggeredByWebContent)
-        assertFalse(observedTriggeredByWebContent!!)
-        assertEquals("sample:about", observedOnLoadRequestUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will notify observers if the url is loaded from the user interacting with chrome`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        val fakeUrl = "https://example.com"
-        var observedUrl: String?
-        var observedTriggeredByWebContent: Boolean?
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    fakeUrl -> null
-                    else -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), fakeUrl)
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedTriggeredByWebContent = triggeredByWebContent
-                observedUrl = url
-            }
-        })
-
-        fun fakePageLoad(expectedTriggeredByWebContent: Boolean) {
-            observedTriggeredByWebContent = null
-            observedUrl = null
-            navigationDelegate.value.onLoadRequest(
-                mock(), mockLoadRequest(fakeUrl, triggeredByRedirect = true,
-                hasUserGesture = expectedTriggeredByWebContent))
-            progressDelegate.value.onPageStop(mock(), true)
-            assertNotNull(observedTriggeredByWebContent)
-            assertEquals(expectedTriggeredByWebContent, observedTriggeredByWebContent!!)
-            assertNotNull(observedUrl)
-            assertEquals(fakeUrl, observedUrl)
-        }
-
-        // loadUrl(url: String)
-        engineSession.loadUrl(fakeUrl)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri(fakeUrl)
-        )
-        fakePageLoad(false)
-
-        // subsequent page loads _are_ from web content
-        fakePageLoad(true)
-
-        // loadData(data: String, mimeType: String, encoding: String)
-        val fakeData = "data://"
-        val fakeMimeType = ""
-        val fakeEncoding = ""
-        engineSession.loadData(data = fakeData, mimeType = fakeMimeType, encoding = fakeEncoding)
-        verify(geckoSession).load(
-            GeckoSession.Loader().data(fakeData, fakeMimeType)
-        )
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // reload()
-        engineSession.initialLoadRequest = null
-        engineSession.reload()
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_NONE)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goBack()
-        engineSession.goBack()
-        verify(geckoSession).goBack()
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goForward()
-        engineSession.goForward()
-        verify(geckoSession).goForward()
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // toggleDesktopMode()
-        engineSession.toggleDesktopMode(false, reload = true)
-        // This is the second time in this test, so we actually want two invocations.
-        verify(geckoSession, times(2)).reload(GeckoSession.LOAD_FLAGS_NONE)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goToHistoryIndex(index: Int)
-        engineSession.goToHistoryIndex(0)
-        verify(geckoSession).gotoHistoryIndex(0)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-    }
-
-    @Test
-    fun `onLoadRequest will return correct GeckoResult if no observer is available`() {
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        captureDelegates()
-
-        val geckoResult = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertEquals(geckoResult!!, GeckoResult.fromValue(AllowOrDeny.ALLOW))
-    }
-
-    @Test
-    fun loadFlagsAreAligned() {
-        assertEquals(LoadUrlFlags.BYPASS_CACHE, GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-        assertEquals(LoadUrlFlags.BYPASS_PROXY, GeckoSession.LOAD_FLAGS_BYPASS_PROXY)
-        assertEquals(LoadUrlFlags.EXTERNAL, GeckoSession.LOAD_FLAGS_EXTERNAL)
-        assertEquals(LoadUrlFlags.ALLOW_POPUPS, GeckoSession.LOAD_FLAGS_ALLOW_POPUPS)
-        assertEquals(LoadUrlFlags.BYPASS_CLASSIFIER, GeckoSession.LOAD_FLAGS_BYPASS_CLASSIFIER)
-        assertEquals(LoadUrlFlags.LOAD_FLAGS_FORCE_ALLOW_DATA_URI, GeckoSession.LOAD_FLAGS_FORCE_ALLOW_DATA_URI)
-        assertEquals(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY, GeckoSession.LOAD_FLAGS_REPLACE_HISTORY)
-    }
-
-    @Test
-    fun `onKill will notify observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observerNotified = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onProcessKilled() {
-                observerNotified = true
-            }
-        })
-
-        val mockedState: GeckoSession.SessionState = mock()
-        progressDelegate.value.onSessionStateChange(geckoSession, mockedState)
-
-        contentDelegate.value.onKill(geckoSession)
-
-        assertTrue(observerNotified)
-    }
-
-    @Test
-    fun `onNewSession creates window request`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var receivedWindowRequest: WindowRequest? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onWindowRequest(windowRequest: WindowRequest) {
-                receivedWindowRequest = windowRequest
-            }
-        })
-
-        navigationDelegate.value.onNewSession(mock(), "mozilla.org")
-
-        assertNotNull(receivedWindowRequest)
-        assertEquals("mozilla.org", receivedWindowRequest!!.url)
-        assertEquals(WindowRequest.Type.OPEN, receivedWindowRequest!!.type)
-    }
-
-    @Test
-    fun `onCloseRequest creates window request`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var receivedWindowRequest: WindowRequest? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onWindowRequest(windowRequest: WindowRequest) {
-                receivedWindowRequest = windowRequest
-            }
-        })
-
-        contentDelegate.value.onCloseRequest(geckoSession)
-
-        assertNotNull(receivedWindowRequest)
-        assertSame(engineSession, receivedWindowRequest!!.prepare())
-        assertEquals(WindowRequest.Type.CLOSE, receivedWindowRequest!!.type)
-    }
-
-    class MockSecurityInformation(
-        origin: String? = null,
-        certificate: X509Certificate? = null
-    ) : SecurityInformation() {
-        init {
-            origin?.let {
-                ReflectionUtils.setField(this, "origin", origin)
-            }
-            certificate?.let {
-                ReflectionUtils.setField(this, "certificate", certificate)
-            }
-        }
-    }
-
-    @Test
-    fun `certificate issuer is parsed and provided onSecurityChange`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = "Verified By: CN=Digicert SHA2 Extended Validation Server CA,OU=www.digicert.com,O=DigiCert Inc,C=US"
-        val parsedIssuerName = "DigiCert Inc"
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `certificate issuer is parsed and provided onSecurityChange with null arg`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = null
-        val parsedIssuerName = null
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `pattern-breaking certificate issuer isnt parsed and returns original name `() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = "pattern breaking cert"
-        val parsedIssuerName = "pattern breaking cert"
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `GIVEN canGoBack true WHEN goBack() is called THEN verify EngineObserver onNavigateBack() is triggered`() {
-        var observedOnNavigateBack = false
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        engineSession.register(object : EngineSession.Observer {
-            override fun onNavigateBack() {
-                observedOnNavigateBack = true
-            }
-        })
-
-        captureDelegates()
-        navigationDelegate.value.onCanGoBack(mock(), true)
-        engineSession.goBack()
-        assertTrue(observedOnNavigateBack)
-    }
-
-    @Test
-    fun `GIVEN canGoBack false WHEN goBack() is called THEN verify EngineObserver onNavigateBack() is not triggered`() {
-        var observedOnNavigateBack = false
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        engineSession.register(object : EngineSession.Observer {
-            override fun onNavigateBack() {
-                observedOnNavigateBack = true
-            }
-        })
-
-        captureDelegates()
-        navigationDelegate.value.onCanGoBack(mock(), false)
-        engineSession.goBack()
-        assertFalse(observedOnNavigateBack)
-    }
-
-    private fun mockGeckoSession(): GeckoSession {
-        val session = mock<GeckoSession>()
-        whenever(session.settings).thenReturn(
-            mock())
-        return session
-    }
-
-    private fun mockLoadRequest(
-        uri: String,
-        triggerUri: String? = null,
-        target: Int = 0,
-        triggeredByRedirect: Boolean = false,
-        hasUserGesture: Boolean = false,
-        isDirectNavigation: Boolean = false
-    ): GeckoSession.NavigationDelegate.LoadRequest {
-        var flags = 0
-        if (triggeredByRedirect) {
-            flags = flags or 0x800000
-        }
-
-        val constructor = GeckoSession.NavigationDelegate.LoadRequest::class.java.getDeclaredConstructor(
-            String::class.java,
-            String::class.java,
-            Int::class.java,
-            Int::class.java,
-            Boolean::class.java,
-            Boolean::class.java)
-        constructor.isAccessible = true
-
-        return constructor.newInstance(uri, triggerUri, target, flags, hasUserGesture, isDirectNavigation)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt
deleted file mode 100644
index eb9bdb294ca4..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt
+++ /dev/null
@@ -1,2064 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.graphics.Color
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.ext.getAntiTrackingPolicy
-import mozilla.components.browser.engine.gecko.mediaquery.toGeckoValue
-import mozilla.components.browser.engine.gecko.util.SpeculativeEngineSession
-import mozilla.components.browser.engine.gecko.util.SpeculativeSessionObserver
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.CookiePolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.UnsupportedSettingException
-import mozilla.components.concept.engine.content.blocking.TrackerLog
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.concept.engine.webextension.WebExtensionDelegate
-import mozilla.components.concept.engine.webextension.WebExtensionException
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNotSame
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentMatchers.anyBoolean
-import org.mockito.ArgumentMatchers.anyFloat
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.Mockito.never
-import org.mockito.Mockito.reset
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlocking.CookieBehavior
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.Event
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoRuntimeSettings
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.MockWebExtension
-import org.mozilla.geckoview.StorageController
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_CORRUPT_FILE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_FILE_ACCESS
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_INCORRECT_HASH
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_INCORRECT_ID
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_NETWORK_FAILURE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_POSTPONED
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_SIGNEDSTATE_REQUIRED
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_UNEXPECTED_ADDON_TYPE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_USER_CANCELED
-import org.mozilla.geckoview.WebExtensionController
-import org.mozilla.geckoview.WebPushController
-import org.robolectric.Robolectric
-import java.io.IOException
-import org.mozilla.geckoview.WebExtension as GeckoWebExtension
-
-typealias GeckoInstallException = org.mozilla.geckoview.WebExtension.InstallException
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineTest {
-
-    private lateinit var runtime: GeckoRuntime
-    private lateinit var context: Context
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        context = mock()
-    }
-
-    @Test
-    fun createView() {
-        assertTrue(GeckoEngine(context, runtime = runtime).createView(
-            Robolectric.buildActivity(Activity::class.java).get()
-        ) is GeckoEngineView)
-    }
-
-    @Test
-    fun createSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertTrue(engine.createSession() is GeckoEngineSession)
-
-        // Create a private speculative session and consume it
-        engine.speculativeCreateSession(private = true)
-        assertTrue(engine.speculativeConnectionFactory.hasSpeculativeSession())
-        var privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertSame(privateSpeculativeSession, engine.createSession(private = true))
-        assertFalse(engine.speculativeConnectionFactory.hasSpeculativeSession())
-
-        // Create a regular speculative session and make sure it is not returned
-        // if a private session is requested instead.
-        engine.speculativeCreateSession(private = false)
-        assertTrue(engine.speculativeConnectionFactory.hasSpeculativeSession())
-        privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertNotSame(privateSpeculativeSession, engine.createSession(private = true))
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(privateSpeculativeSession.geckoSession.isOpen)
-        assertFalse(engine.speculativeConnectionFactory.hasSpeculativeSession())
-    }
-
-    @Test
-    fun speculativeCreateSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        // Create a private speculative session
-        engine.speculativeCreateSession(private = true)
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        val privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!
-        assertTrue(privateSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-
-        // Creating another private speculative session should have no effect as
-        // session hasn't been "consumed".
-        engine.speculativeCreateSession(private = true)
-        assertSame(privateSpeculativeSession, engine.speculativeConnectionFactory.speculativeEngineSession)
-        assertTrue(privateSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-
-        // Creating a non-private speculative session should affect prepared session
-        engine.speculativeCreateSession(private = false)
-        assertNotSame(privateSpeculativeSession, engine.speculativeConnectionFactory.speculativeEngineSession)
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(privateSpeculativeSession.engineSession.geckoSession.isOpen)
-        val regularSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!
-        assertFalse(regularSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-    }
-
-    @Test
-    fun clearSpeculativeSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        val mockEngineSession: GeckoEngineSession = mock()
-        val mockEngineSessionObserver: SpeculativeSessionObserver = mock()
-        engine.speculativeConnectionFactory.speculativeEngineSession =
-            SpeculativeEngineSession(mockEngineSession, mockEngineSessionObserver)
-        engine.clearSpeculativeSession()
-
-        verify(mockEngineSession).unregister(mockEngineSessionObserver)
-        verify(mockEngineSession).close()
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `createSession with contextId`() {
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        // Create a speculative session with a context id and consume it
-        engine.speculativeCreateSession(private = false, contextId = "1")
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        var newSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertSame(newSpeculativeSession, engine.createSession(private = false, contextId = "1"))
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        // Create a regular speculative session and make sure it is not returned
-        // if a session with a context id is requested instead.
-        engine.speculativeCreateSession(private = false)
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        newSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertNotSame(newSpeculativeSession, engine.createSession(private = false, contextId = "1"))
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(newSpeculativeSession.geckoSession.isOpen)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-    }
-
-    @Test
-    fun name() {
-        assertEquals("Gecko", GeckoEngine(context, runtime = runtime).name())
-    }
-
-    @Test
-    fun settings() {
-        val defaultSettings = DefaultSettings()
-        val contentBlockingSettings = ContentBlocking.Settings.Builder().build()
-        val runtime = mock<GeckoRuntime>()
-        val runtimeSettings = mock<GeckoRuntimeSettings>()
-        whenever(runtimeSettings.javaScriptEnabled).thenReturn(true)
-        whenever(runtimeSettings.webFontsEnabled).thenReturn(true)
-        whenever(runtimeSettings.automaticFontSizeAdjustment).thenReturn(true)
-        whenever(runtimeSettings.fontInflationEnabled).thenReturn(true)
-        whenever(runtimeSettings.fontSizeFactor).thenReturn(1.0F)
-        whenever(runtimeSettings.forceUserScalableEnabled).thenReturn(false)
-        whenever(runtimeSettings.loginAutofillEnabled).thenReturn(false)
-        whenever(runtimeSettings.contentBlocking).thenReturn(contentBlockingSettings)
-        whenever(runtimeSettings.preferredColorScheme).thenReturn(GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM)
-        whenever(runtime.settings).thenReturn(runtimeSettings)
-        val engine = GeckoEngine(context, runtime = runtime, defaultSettings = defaultSettings)
-
-        assertTrue(engine.settings.javascriptEnabled)
-        engine.settings.javascriptEnabled = false
-        verify(runtimeSettings).javaScriptEnabled = false
-
-        assertFalse(engine.settings.loginAutofillEnabled)
-        engine.settings.loginAutofillEnabled = true
-        verify(runtimeSettings).loginAutofillEnabled = true
-
-        assertTrue(engine.settings.webFontsEnabled)
-        engine.settings.webFontsEnabled = false
-        verify(runtimeSettings).webFontsEnabled = false
-
-        assertTrue(engine.settings.automaticFontSizeAdjustment)
-        engine.settings.automaticFontSizeAdjustment = false
-        verify(runtimeSettings).automaticFontSizeAdjustment = false
-
-        assertTrue(engine.settings.fontInflationEnabled!!)
-        engine.settings.fontInflationEnabled = null
-        verify(runtimeSettings, never()).fontInflationEnabled = anyBoolean()
-        engine.settings.fontInflationEnabled = false
-        verify(runtimeSettings).fontInflationEnabled = false
-
-        assertEquals(1.0F, engine.settings.fontSizeFactor)
-        engine.settings.fontSizeFactor = null
-        verify(runtimeSettings, never()).fontSizeFactor = anyFloat()
-        engine.settings.fontSizeFactor = 2.0F
-        verify(runtimeSettings).fontSizeFactor = 2.0F
-
-        assertFalse(engine.settings.forceUserScalableContent)
-        engine.settings.forceUserScalableContent = true
-        verify(runtimeSettings).forceUserScalableEnabled = true
-
-        assertFalse(engine.settings.remoteDebuggingEnabled)
-        engine.settings.remoteDebuggingEnabled = true
-        verify(runtimeSettings).remoteDebuggingEnabled = true
-
-        assertFalse(engine.settings.testingModeEnabled)
-        engine.settings.testingModeEnabled = true
-        assertTrue(engine.settings.testingModeEnabled)
-
-        assertEquals(PreferredColorScheme.System, engine.settings.preferredColorScheme)
-        engine.settings.preferredColorScheme = PreferredColorScheme.Dark
-        verify(runtimeSettings).preferredColorScheme = PreferredColorScheme.Dark.toGeckoValue()
-
-        assertFalse(engine.settings.suspendMediaWhenInactive)
-        engine.settings.suspendMediaWhenInactive = true
-        assertEquals(true, engine.settings.suspendMediaWhenInactive)
-
-        assertNull(engine.settings.clearColor)
-        engine.settings.clearColor = Color.BLUE
-        assertEquals(Color.BLUE, engine.settings.clearColor)
-
-        // Specifying no ua-string default should result in GeckoView's default.
-        assertEquals(GeckoSession.getDefaultUserAgent(), engine.settings.userAgentString)
-        // It also should be possible to read and set a new default.
-        engine.settings.userAgentString = engine.settings.userAgentString + "-test"
-        assertEquals(GeckoSession.getDefaultUserAgent() + "-test", engine.settings.userAgentString)
-
-        assertEquals(null, engine.settings.trackingProtectionPolicy)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory =
-            TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        val safeStrictBrowsingCategories = SafeBrowsingPolicy.RECOMMENDED.id
-        assertEquals(safeStrictBrowsingCategories, contentBlockingSettings.safeBrowsingCategories)
-
-        engine.settings.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.PHISHING)
-        assertEquals(SafeBrowsingPolicy.PHISHING.id, contentBlockingSettings.safeBrowsingCategories)
-
-        assertEquals(defaultSettings.trackingProtectionPolicy, TrackingProtectionPolicy.strict())
-        assertEquals(contentBlockingSettings.cookieBehavior, CookiePolicy.ACCEPT_NON_TRACKERS.id)
-
-        try {
-            engine.settings.domStorageEnabled
-            fail("Expected UnsupportedOperationException")
-        } catch (e: UnsupportedSettingException) { }
-
-        try {
-            engine.settings.domStorageEnabled = false
-            fail("Expected UnsupportedOperationException")
-        } catch (e: UnsupportedSettingException) { }
-    }
-
-    @Test
-    fun `the SCRIPTS_AND_SUB_RESOURCES tracking protection category must not be passed to gecko view`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory = TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            mockRuntime.settings.contentBlocking.antiTrackingCategories
-        )
-
-        mockRuntime.settings.contentBlocking.setAntiTracking(0)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)
-        )
-
-        assertEquals(0, mockRuntime.settings.contentBlocking.antiTrackingCategories)
-    }
-
-    @Test
-    fun `WHEN a strict tracking protection policy is set THEN the strict social list must be activated`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(true)
-    }
-
-    @Test
-    fun `WHEN a strict tracking protection policy is set THEN the setEnhancedTrackingProtectionLevel must be STRICT`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-    }
-
-    @Test
-    fun `setAntiTracking is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setAntiTracking(
-            policy.getAntiTrackingPolicy()
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setAntiTracking(
-            policy.getAntiTrackingPolicy()
-        )
-    }
-
-    @Test
-    fun `cookiePurging is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setCookiePurging(policy.cookiePurging)
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setCookiePurging(policy.cookiePurging)
-    }
-
-    @Test
-    fun `setCookieBehavior is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-        whenever(mockRuntime.settings.contentBlocking.cookieBehavior).thenReturn(CookieBehavior.ACCEPT_NONE)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setCookieBehavior(
-            policy.cookiePolicy.id
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setCookieBehavior(
-            policy.cookiePolicy.id
-        )
-    }
-
-    @Test
-    fun `setEnhancedTrackingProtectionLevel MUST always be set to STRICT unless the tracking protection policy is none`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.NONE
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.NONE
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-    }
-
-    @Test
-    fun `WHEN a non strict tracking protection policy is set THEN the strict social list must be disabled`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking.strictSocialTrackingProtection).thenReturn(true)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(false)
-    }
-
-    @Test
-    fun `WHEN strict social tracking protection is set to true THEN the strict social list must be activated`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            strictSocialTrackingProtection = true
-        )
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(true)
-    }
-
-    @Test
-    fun `WHEN strict social tracking protection is set to false THEN the strict social list must be disabled`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking.strictSocialTrackingProtection).thenReturn(true)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            strictSocialTrackingProtection = false
-        )
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(false)
-    }
-
-    @Test
-    fun defaultSettings() {
-        val runtime = mock<GeckoRuntime>()
-        val runtimeSettings = mock<GeckoRuntimeSettings>()
-        val contentBlockingSettings = ContentBlocking.Settings.Builder().build()
-        whenever(runtimeSettings.javaScriptEnabled).thenReturn(true)
-        whenever(runtime.settings).thenReturn(runtimeSettings)
-        whenever(runtimeSettings.contentBlocking).thenReturn(contentBlockingSettings)
-        whenever(runtimeSettings.fontInflationEnabled).thenReturn(true)
-
-        val engine = GeckoEngine(context,
-            DefaultSettings(
-                trackingProtectionPolicy = TrackingProtectionPolicy.strict(),
-                javascriptEnabled = false,
-                webFontsEnabled = false,
-                automaticFontSizeAdjustment = false,
-                fontInflationEnabled = false,
-                fontSizeFactor = 2.0F,
-                remoteDebuggingEnabled = true,
-                testingModeEnabled = true,
-                userAgentString = "test-ua",
-                preferredColorScheme = PreferredColorScheme.Light,
-                suspendMediaWhenInactive = true,
-                forceUserScalableContent = false
-            ), runtime)
-
-        verify(runtimeSettings).javaScriptEnabled = false
-        verify(runtimeSettings).webFontsEnabled = false
-        verify(runtimeSettings).automaticFontSizeAdjustment = false
-        verify(runtimeSettings).fontInflationEnabled = false
-        verify(runtimeSettings).fontSizeFactor = 2.0F
-        verify(runtimeSettings).remoteDebuggingEnabled = true
-        verify(runtimeSettings).forceUserScalableEnabled = false
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory =
-            TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        assertEquals(SafeBrowsingPolicy.RECOMMENDED.id, contentBlockingSettings.safeBrowsingCategories)
-
-        assertEquals(CookiePolicy.ACCEPT_NON_TRACKERS.id, contentBlockingSettings.cookieBehavior)
-        assertTrue(engine.settings.testingModeEnabled)
-        assertEquals("test-ua", engine.settings.userAgentString)
-        assertEquals(PreferredColorScheme.Light, engine.settings.preferredColorScheme)
-        assertTrue(engine.settings.suspendMediaWhenInactive)
-
-        engine.settings.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.PHISHING)
-        engine.settings.trackingProtectionPolicy =
-            TrackingProtectionPolicy.select(
-                trackingCategories = arrayOf(TrackingProtectionPolicy.TrackingCategory.AD),
-                cookiePolicy = CookiePolicy.ACCEPT_ONLY_FIRST_PARTY
-            )
-
-        assertEquals(
-            TrackingProtectionPolicy.TrackingCategory.AD.id,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        assertEquals(
-            SafeBrowsingPolicy.PHISHING.id,
-            contentBlockingSettings.safeBrowsingCategories
-        )
-
-        assertEquals(
-            CookiePolicy.ACCEPT_ONLY_FIRST_PARTY.id,
-            contentBlockingSettings.cookieBehavior
-        )
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-
-        assertEquals(CookiePolicy.ACCEPT_ALL.id, contentBlockingSettings.cookieBehavior)
-    }
-
-    @Test
-    fun `speculativeConnect forwards call to executor`() {
-        val executor: GeckoWebExecutor = mock()
-
-        val engine = GeckoEngine(context, runtime = runtime, executorProvider = { executor })
-
-        engine.speculativeConnect("https://www.mozilla.org")
-
-        verify(executor).speculativeConnect("https://www.mozilla.org")
-    }
-
-    @Test
-    fun `install built-in web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<GeckoWebExtension>()
-
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(
-            extId,
-            extUrl,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extUrlCaptor = argumentCaptor<String>()
-        val extIdCaptor = argumentCaptor<String>()
-        verify(extensionController).ensureBuiltIn(extUrlCaptor.capture(), extIdCaptor.capture())
-        assertEquals(extUrl, extUrlCaptor.value)
-        assertEquals(extId, extIdCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `install external web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<GeckoWebExtension>()
-
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(
-            extId,
-            extUrl,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<String>()
-        verify(extensionController).install(extCaptor.capture())
-        assertEquals(extUrl, extCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `install built-in web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<GeckoWebExtension>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `install external web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<GeckoWebExtension>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `uninstall web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val nativeExtension = mockNativeExtension("test-webext", "https://addons.mozilla.org/1/some_web_ext.xpi")
-        val ext = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            nativeExtension,
-            runtime
-        )
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<Void>()
-
-        whenever(extensionController.uninstall(any())).thenReturn(result)
-        engine.uninstallWebExtension(
-            ext,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(null)
-        verify(webExtensionsDelegate).onUninstalled(ext)
-
-        val extCaptor = argumentCaptor<GeckoWebExtension>()
-        verify(extensionController).uninstall(extCaptor.capture())
-        assertSame(nativeExtension, extCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `uninstall web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val nativeExtension = mockNativeExtension(
-            "test-webext",
-            "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-        )
-        val ext = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            nativeExtension,
-            runtime
-        )
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<Void>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.uninstall(any())).thenReturn(result)
-        engine.uninstallWebExtension(ext) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-        verify(webExtensionsDelegate, never()).onUninstalled(ext)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `web extension delegate handles installation of built-in extensions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(webExtensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstalled(extCaptor.capture())
-        assertEquals(extId, extCaptor.value.id)
-        assertEquals(extUrl, extCaptor.value.url)
-    }
-
-    @Test
-    fun `web extension delegate handles installation of external extensions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/123/some_web_ext.xpi"
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(webExtensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstalled(extCaptor.capture())
-        assertEquals(extId, extCaptor.value.id)
-        assertEquals(extUrl, extCaptor.value.url)
-    }
-
-    @Test
-    fun `web extension delegate handles install prompt`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val extension = mockNativeExtension("test", "uri")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        assertEquals(GeckoResult.deny(), geckoDelegateCaptor.value.onInstallPrompt(extension))
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstallPermissionRequest(extensionCaptor.capture())
-        val capturedExtension =
-                extensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(extension, capturedExtension.nativeExtension)
-
-        whenever(webExtensionsDelegate.onInstallPermissionRequest(any())).thenReturn(true)
-        assertEquals(GeckoResult.allow(), geckoDelegateCaptor.value.onInstallPrompt(extension))
-    }
-
-    @Test
-    fun `web extension delegate handles update prompt`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val currentExtension = mockNativeExtension("test", "uri")
-        val updatedExtension = mockNativeExtension("testUpdated", "uri")
-        val updatedPermissions = arrayOf("p1", "p2")
-        val hostPermissions = arrayOf("p3", "p4")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        val result = geckoDelegateCaptor.value.onUpdatePrompt(
-            currentExtension, updatedExtension, updatedPermissions, hostPermissions
-        )
-        assertNotNull(result)
-
-        val currentExtensionCaptor = argumentCaptor<WebExtension>()
-        val updatedExtensionCaptor = argumentCaptor<WebExtension>()
-        val onPermissionsGrantedCaptor = argumentCaptor<((Boolean) -> Unit)>()
-        verify(webExtensionsDelegate).onUpdatePermissionRequest(
-            currentExtensionCaptor.capture(),
-            updatedExtensionCaptor.capture(),
-            eq(updatedPermissions.toList() + hostPermissions.toList()),
-            onPermissionsGrantedCaptor.capture()
-        )
-        val current =
-            currentExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(currentExtension, current.nativeExtension)
-        val updated =
-            updatedExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(updatedExtension, updated.nativeExtension)
-
-        onPermissionsGrantedCaptor.value.invoke(true)
-        assertEquals(GeckoResult.allow(), result)
-    }
-
-    @Test
-    fun `web extension delegate handles update prompt with empty host permissions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val currentExtension = mockNativeExtension("test", "uri")
-        val updatedExtension = mockNativeExtension("testUpdated", "uri")
-        val updatedPermissions = arrayOf("p1", "p2")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        val result = geckoDelegateCaptor.value.onUpdatePrompt(
-                currentExtension, updatedExtension, updatedPermissions, emptyArray()
-        )
-        assertNotNull(result)
-
-        val currentExtensionCaptor = argumentCaptor<WebExtension>()
-        val updatedExtensionCaptor = argumentCaptor<WebExtension>()
-        val onPermissionsGrantedCaptor = argumentCaptor<((Boolean) -> Unit)>()
-        verify(webExtensionsDelegate).onUpdatePermissionRequest(
-            currentExtensionCaptor.capture(),
-            updatedExtensionCaptor.capture(),
-            eq(updatedPermissions.toList()),
-            onPermissionsGrantedCaptor.capture()
-        )
-        val current =
-                currentExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(currentExtension, current.nativeExtension)
-        val updated =
-                updatedExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(updatedExtension, updated.nativeExtension)
-
-        onPermissionsGrantedCaptor.value.invoke(true)
-        assertEquals(GeckoResult.allow(), result)
-    }
-
-    @Test
-    fun `web extension delegate notified of browser actions from built-in extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val browserAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onBrowserAction(extension, null, browserAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onBrowserActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(browserAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified of page actions from built-in extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val pageAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onPageAction(extension, null, pageAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onPageActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(pageAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified when built-in extension wants to open tab`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val tabDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.TabDelegate>()
-        verify(extension).tabDelegate = tabDelegateCaptor.capture()
-
-        val createTabDetails: org.mozilla.geckoview.WebExtension.CreateTabDetails = mock()
-        tabDelegateCaptor.value.onNewTab(extension, createTabDetails)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onNewTab(extensionCaptor.capture(), any(), eq(false), eq(""))
-        assertEquals(extId, extensionCaptor.value.id)
-    }
-
-    @Test
-    fun `web extension delegate notified of browser actions from external extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val browserAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onBrowserAction(extension, null, browserAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onBrowserActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(browserAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified of page actions from external extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val pageAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onPageAction(extension, null, pageAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onPageActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(pageAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified when external extension wants to open tab`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val tabDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.TabDelegate>()
-        verify(extension).tabDelegate = tabDelegateCaptor.capture()
-
-        val createTabDetails: org.mozilla.geckoview.WebExtension.CreateTabDetails = mock()
-        tabDelegateCaptor.value.onNewTab(extension, createTabDetails)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onNewTab(extensionCaptor.capture(), any(), eq(false), eq(""))
-        assertEquals(extId, extensionCaptor.value.id)
-    }
-
-    @Test
-    fun `web extension delegate notified of extension list change`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val debuggerDelegateCaptor = argumentCaptor<WebExtensionController.DebuggerDelegate>()
-        verify(webExtensionController).setDebuggerDelegate(debuggerDelegateCaptor.capture())
-
-        debuggerDelegateCaptor.value.onExtensionListUpdated()
-        verify(webExtensionsDelegate).onExtensionListUpdated()
-    }
-
-    @Test
-    fun `update web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val updatedExtension = MockWebExtension(bundle)
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        updateExtensionResult.complete(updatedExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-    }
-
-    @Test
-    fun `try to update a web extension without a new update available`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        updateExtensionResult.complete(null)
-
-        assertFalse(onErrorCalled)
-        assertNull(result)
-    }
-
-    @Test
-    fun `update web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, e -> throwable = e }
-        )
-        updateExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable!!.cause)
-        assertNull(result)
-    }
-
-    @Test
-    fun `failures when updating MUST indicate if they are recoverable`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        val performUpdate: (GeckoInstallException) -> WebExtensionException = { exception ->
-            val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-            whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-            whenever(runtime.webExtensionController).thenReturn(extensionController)
-            var throwable: WebExtensionException? = null
-
-            engine.updateWebExtension(
-                extension,
-                onError = { _, e -> throwable = e as WebExtensionException
-                }
-            )
-
-            updateExtensionResult.completeExceptionally(exception)
-            throwable!!
-        }
-
-        val unrecoverableExceptions = listOf(
-            mockGeckoInstallException(ERROR_NETWORK_FAILURE),
-            mockGeckoInstallException(ERROR_INCORRECT_HASH),
-            mockGeckoInstallException(ERROR_CORRUPT_FILE),
-            mockGeckoInstallException(ERROR_FILE_ACCESS),
-            mockGeckoInstallException(ERROR_SIGNEDSTATE_REQUIRED),
-            mockGeckoInstallException(ERROR_UNEXPECTED_ADDON_TYPE),
-            mockGeckoInstallException(ERROR_INCORRECT_ID),
-            mockGeckoInstallException(ERROR_POSTPONED)
-        )
-
-        unrecoverableExceptions.forEach { exception ->
-            assertFalse(performUpdate(exception).isRecoverable)
-        }
-
-        val recoverableExceptions = listOf(mockGeckoInstallException(ERROR_USER_CANCELED))
-
-        recoverableExceptions.forEach { exception ->
-            assertTrue(performUpdate(exception).isRecoverable)
-        }
-    }
-
-    @Test
-    fun `list web extensions successfully`() {
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putBoolean("privateBrowsingAllowed", false)
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val installedExtension = MockWebExtension(bundle)
-
-        val installedExtensions = listOf<GeckoWebExtension>(installedExtension)
-        val installedExtensionResult = GeckoResult<List<GeckoWebExtension>>()
-
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(extensionController.list()).thenReturn(installedExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(testContext, runtime = runtime)
-        var extensions: List<WebExtension>? = null
-        var onErrorCalled = false
-
-        engine.listInstalledWebExtensions(
-            onSuccess = { extensions = it },
-            onError = { onErrorCalled = true }
-        )
-        installedExtensionResult.complete(installedExtensions)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(extensions)
-    }
-
-    @Test
-    fun `list web extensions failure`() {
-        val installedExtensionResult = GeckoResult<List<GeckoWebExtension>>()
-
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(extensionController.list()).thenReturn(installedExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var extensions: List<WebExtension>? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.listInstalledWebExtensions(
-            onSuccess = { extensions = it },
-            onError = { throwable = it }
-        )
-        installedExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(extensions)
-    }
-
-    @Test
-    fun `enable web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val enabledExtension = MockWebExtension(bundle)
-        val enableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.enable(any(), anyInt())).thenReturn(enableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.enableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { onErrorCalled = true }
-        )
-        enableExtensionResult.complete(enabledExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onEnabled(result!!)
-    }
-
-    @Test
-    fun `enable web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val enableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.enable(any(), anyInt())).thenReturn(enableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.enableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { throwable = it }
-        )
-        enableExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onEnabled(any())
-    }
-
-    @Test
-    fun `disable web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val disabledExtension = MockWebExtension(bundle)
-        val disableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.disable(any(), anyInt())).thenReturn(disableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.disableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { onErrorCalled = true }
-        )
-        disableExtensionResult.complete(disabledExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onDisabled(result!!)
-    }
-
-    @Test
-    fun `disable web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val disableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.disable(any(), anyInt())).thenReturn(disableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.disableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { throwable = it }
-        )
-        disableExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onEnabled(any())
-    }
-
-    @Test
-    fun `set allowedInPrivateBrowsing successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val allowedInPrivateBrowsing = MockWebExtension(bundle)
-        val allowedInPrivateBrowsingExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.setAllowedInPrivateBrowsing(any(), anyBoolean())).thenReturn(allowedInPrivateBrowsingExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.setAllowedInPrivateBrowsing(
-            extension,
-            true,
-            onSuccess = { ext -> result = ext },
-            onError = { onErrorCalled = true }
-        )
-        allowedInPrivateBrowsingExtensionResult.complete(allowedInPrivateBrowsing)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onAllowedInPrivateBrowsingChanged(result!!)
-    }
-
-    @Test
-    fun `set allowedInPrivateBrowsing failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val allowedInPrivateBrowsingExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.setAllowedInPrivateBrowsing(any(), anyBoolean())).thenReturn(allowedInPrivateBrowsingExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.setAllowedInPrivateBrowsing(
-            extension,
-            true,
-            onSuccess = { ext -> result = ext },
-            onError = { throwable = it }
-        )
-        allowedInPrivateBrowsingExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onAllowedInPrivateBrowsingChanged(any())
-    }
-
-    @Test(expected = RuntimeException::class)
-    fun `WHEN GeckoRuntime is shutting down THEN GeckoEngine throws runtime exception`() {
-        val runtime: GeckoRuntime = mock()
-
-        GeckoEngine(context, runtime = runtime)
-
-        val captor = argumentCaptor<GeckoRuntime.Delegate>()
-        verify(runtime).delegate = captor.capture()
-
-        assertNotNull(captor.value)
-
-        captor.value.onShutdown()
-    }
-
-    @Test
-    fun `clear browsing data for all hosts`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var onSuccessCalled = false
-
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearData(eq(Engine.BrowsingData.all().types.toLong()))).thenReturn(result)
-        result.complete(null)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), onSuccess = { onSuccessCalled = true })
-        assertTrue(onSuccessCalled)
-    }
-
-    @Test
-    fun `error handler invoked when clearing browsing data for all hosts fails`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var throwable: Throwable? = null
-        var onErrorCalled = false
-
-        val exception = IOException()
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearData(eq(Engine.BrowsingData.all().types.toLong()))).thenReturn(result)
-        result.completeExceptionally(exception)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), onError = {
-            onErrorCalled = true
-            throwable = it
-        })
-        assertTrue(onErrorCalled)
-        assertSame(exception, throwable)
-    }
-
-    @Test
-    fun `clear browsing data for specified host`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var onSuccessCalled = false
-
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearDataFromHost(
-                eq("mozilla.org"),
-                eq(Engine.BrowsingData.all().types.toLong()))
-        ).thenReturn(result)
-        result.complete(null)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), host = "mozilla.org", onSuccess = { onSuccessCalled = true })
-        assertTrue(onSuccessCalled)
-    }
-
-    @Test
-    fun `error handler invoked when clearing browsing data for specified hosts fails`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var throwable: Throwable? = null
-        var onErrorCalled = false
-
-        val exception = IOException()
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearDataFromHost(
-                eq("mozilla.org"),
-                eq(Engine.BrowsingData.all().types.toLong()))
-        ).thenReturn(result)
-        result.completeExceptionally(exception)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), host = "mozilla.org", onError = {
-            onErrorCalled = true
-            throwable = it
-        })
-        assertTrue(onErrorCalled)
-        assertSame(exception, throwable)
-    }
-
-    @Test
-    fun `test parsing engine version`() {
-        val runtime: GeckoRuntime = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val version = engine.version
-
-        println(version)
-
-        assertTrue(version.major >= 69)
-        assertTrue(version.isAtLeast(69, 0, 0))
-    }
-
-    @Test
-    fun `after init is called the trackingProtectionExceptionStore must be restored`() {
-        val mockStore: TrackingProtectionExceptionStorage = mock()
-        val runtime: GeckoRuntime = mock()
-        GeckoEngine(context, runtime = runtime, trackingProtectionExceptionStore = mockStore)
-
-        verify(mockStore).restore()
-    }
-
-    @Test
-    fun `fetch trackers logged successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(mockGeckoContentBlockingSetting.enhancedTrackingProtectionLevel).thenReturn(
-            ContentBlocking.EtpLevel.STRICT
-        )
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-                onSuccessCalled = true
-            },
-            onError = { onErrorCalled = true }
-        )
-
-        logEntriesResult.complete(createDummyLogEntryList())
-
-        val trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.FINGERPRINTING))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.CRYPTOMINING))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.FINGERPRINTING))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.CRYPTOMINING))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-
-        logEntriesResult = GeckoResult()
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-        logEntriesResult.completeExceptionally(Exception())
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-                onSuccessCalled = true
-            },
-            onError = { onErrorCalled = true }
-        )
-
-        assertTrue(onErrorCalled)
-    }
-
-    @Test
-    fun `shimmed content MUST be categorized as blocked`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = spy(GeckoEngine(context, runtime = runtime))
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        val logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        val engineSetting = DefaultSettings()
-        engineSetting.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        whenever(engine.settings).thenReturn(engineSetting)
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-
-        logEntriesResult.complete(createShimmedEntryList())
-
-        val trackerLog = trackersLog!!.first()
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-        assertTrue(trackerLog.loadedCategories.isEmpty())
-    }
-
-    @Test
-    fun `fetch site with social trackers`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-        logEntriesResult.complete(createSocialTrackersLogEntryList())
-
-        var trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        var trackerLog2 = trackersLog!![1]
-        assertFalse(trackerLog2.cookiesHasBeenBlocked)
-        assertEquals("www.tracker2.com", trackerLog2.url)
-        assertTrue(trackerLog2.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        logEntriesResult = GeckoResult()
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-        logEntriesResult.complete(createSocialTrackersLogEntryList())
-
-        trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        trackerLog2 = trackersLog!![1]
-        assertFalse(trackerLog2.cookiesHasBeenBlocked)
-        assertEquals("www.tracker2.com", trackerLog2.url)
-        assertTrue(trackerLog2.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-    }
-
-    @Test
-    fun `fetch trackers logged of the level 2 list`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(mockGeckoContentBlockingSetting.enhancedTrackingProtectionLevel).thenReturn(
-            ContentBlocking.EtpLevel.STRICT
-        )
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            arrayOf(
-                TrackingCategory.STRICT,
-                TrackingCategory.CONTENT
-            )
-        )
-
-        logEntriesResult = GeckoResult()
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-            },
-            onError = { }
-        )
-        logEntriesResult.complete(createDummyLogEntryList())
-
-        val trackerLog = trackersLog!![1]
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-    }
-
-    @Test
-    fun `registerWebNotificationDelegate sets delegate`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerWebNotificationDelegate(mock())
-
-        verify(runtime).webNotificationDelegate = any()
-    }
-
-    @Test
-    fun `registerWebPushDelegate sets delegate and returns same handler`() {
-        val runtime = mock<GeckoRuntime>()
-        val controller: WebPushController = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        whenever(runtime.webPushController).thenReturn(controller)
-
-        val handler1 = engine.registerWebPushDelegate(mock())
-        val handler2 = engine.registerWebPushDelegate(mock())
-
-        verify(controller, times(2)).setDelegate(any())
-
-        assert(handler1 == handler2)
-    }
-
-    @Test
-    fun `registerActivityDelegate sets delegate`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerActivityDelegate(mock())
-
-        verify(runtime).activityDelegate = any()
-    }
-
-    @Test
-    fun `unregisterActivityDelegate sets delegate to null`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerActivityDelegate(mock())
-
-        verify(runtime).activityDelegate = any()
-
-        engine.unregisterActivityDelegate()
-
-        verify(runtime).activityDelegate = null
-    }
-
-    private fun createSocialTrackersLogEntryList(): List<ContentBlockingController.LogEntry> {
-        val blockedLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(blockedLogEntry, "origin", "www.tracker.com")
-        val blockedCookieSocialTracker = createBlockingData(Event.COOKIES_BLOCKED_SOCIALTRACKER)
-        val blockedSocialContent = createBlockingData(Event.BLOCKED_SOCIALTRACKING_CONTENT)
-
-        ReflectionUtils.setField(blockedLogEntry, "blockingData", listOf(blockedSocialContent, blockedCookieSocialTracker))
-
-        val loadedLogEntry = object : ContentBlockingController.LogEntry() {}
-        ReflectionUtils.setField(loadedLogEntry, "origin", "www.tracker2.com")
-
-        val loadedCookieSocialTracker = createBlockingData(Event.COOKIES_LOADED_SOCIALTRACKER)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        ReflectionUtils.setField(loadedLogEntry, "blockingData", listOf(loadedCookieSocialTracker, loadedSocialContent))
-
-        return listOf(blockedLogEntry, loadedLogEntry)
-    }
-
-    private fun createDummyLogEntryList(): List<ContentBlockingController.LogEntry> {
-        val addLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(addLogEntry, "origin", "www.tracker.com")
-        val blockedCookiePermission = createBlockingData(Event.COOKIES_BLOCKED_BY_PERMISSION)
-        val loadedCookieSocialTracker = createBlockingData(Event.COOKIES_LOADED_SOCIALTRACKER)
-        val blockedCookieSocialTracker = createBlockingData(Event.COOKIES_BLOCKED_SOCIALTRACKER)
-
-        val blockedTrackingContent = createBlockingData(Event.BLOCKED_TRACKING_CONTENT)
-        val blockedFingerprintingContent = createBlockingData(Event.BLOCKED_FINGERPRINTING_CONTENT)
-        val blockedCyptominingContent = createBlockingData(Event.BLOCKED_CRYPTOMINING_CONTENT)
-        val blockedSocialContent = createBlockingData(Event.BLOCKED_SOCIALTRACKING_CONTENT)
-
-        val loadedTrackingLevel1Content = createBlockingData(Event.LOADED_LEVEL_1_TRACKING_CONTENT)
-        val loadedTrackingLevel2Content = createBlockingData(Event.LOADED_LEVEL_2_TRACKING_CONTENT)
-        val loadedFingerprintingContent = createBlockingData(Event.LOADED_FINGERPRINTING_CONTENT)
-        val loadedCyptominingContent = createBlockingData(Event.LOADED_CRYPTOMINING_CONTENT)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        val contentBlockingList = listOf(
-            blockedTrackingContent,
-            loadedTrackingLevel1Content,
-            loadedTrackingLevel2Content,
-            blockedFingerprintingContent,
-            loadedFingerprintingContent,
-            blockedCyptominingContent,
-            loadedCyptominingContent,
-            blockedCookiePermission,
-            blockedSocialContent,
-            loadedSocialContent,
-            loadedCookieSocialTracker,
-            blockedCookieSocialTracker
-        )
-
-        val addLogSecondEntry = object : ContentBlockingController.LogEntry() {}
-        ReflectionUtils.setField(addLogSecondEntry, "origin", "www.tracker2.com")
-        val contentBlockingSecondEntryList = listOf(loadedTrackingLevel2Content)
-
-        ReflectionUtils.setField(addLogEntry, "blockingData", contentBlockingList)
-        ReflectionUtils.setField(addLogSecondEntry, "blockingData", contentBlockingSecondEntryList)
-
-        return listOf(addLogEntry, addLogSecondEntry)
-    }
-
-    private fun createShimmedEntryList(): List<ContentBlockingController.LogEntry> {
-        val addLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(addLogEntry, "origin", "www.tracker.com")
-        val shimmedContent = createBlockingData(Event.REPLACED_TRACKING_CONTENT, 2)
-        val loadedTrackingLevel1Content = createBlockingData(Event.LOADED_LEVEL_1_TRACKING_CONTENT)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        val contentBlockingList = listOf(
-            loadedTrackingLevel1Content,
-            loadedSocialContent,
-            shimmedContent
-        )
-
-        ReflectionUtils.setField(addLogEntry, "blockingData", contentBlockingList)
-
-        return listOf(addLogEntry)
-    }
-
-    private fun createBlockingData(category: Int, count: Int = 0): ContentBlockingController.LogEntry.BlockingData {
-        val blockingData = object : ContentBlockingController.LogEntry.BlockingData() {}
-        ReflectionUtils.setField(blockingData, "category", category)
-        ReflectionUtils.setField(blockingData, "count", count)
-        return blockingData
-    }
-
-    private fun mockNativeExtension(useBundle: GeckoBundle? = null): GeckoWebExtension {
-        val bundle = useBundle ?: GeckoBundle().apply {
-            putString("webExtensionId", "id")
-            putString("locationURI", "uri")
-        }
-        return spy(MockWebExtension(bundle))
-    }
-
-    private fun mockNativeExtension(id: String, location: String): GeckoWebExtension {
-        val bundle = GeckoBundle().apply {
-            putString("webExtensionId", id)
-            putString("locationURI", location)
-        }
-        return spy(MockWebExtension(bundle))
-    }
-
-    private fun mockGeckoInstallException(errorCode: Int): GeckoInstallException {
-        val exception = object : GeckoInstallException() {}
-        ReflectionUtils.setField(exception, "code", errorCode)
-        return exception
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
deleted file mode 100644
index 6d99f123e351..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
+++ /dev/null
@@ -1,288 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.graphics.Bitmap
-import android.graphics.Color
-import android.view.View
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineView.Companion.DARK_COVER
-import mozilla.components.browser.engine.gecko.selection.GeckoSelectionActionDelegate
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.never
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.MockSelection
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineViewTest {
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Test
-    fun render() {
-        val engineView = GeckoEngineView(context)
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-        verify(geckoView, times(1)).setSession(geckoSession)
-
-        whenever(geckoView.session).thenReturn(geckoSession)
-        engineView.render(engineSession)
-        verify(geckoView, times(1)).setSession(geckoSession)
-    }
-
-    @Test
-    fun captureThumbnail() {
-        val engineView = GeckoEngineView(context)
-        val mockGeckoView = mock<NestedGeckoView>()
-        var thumbnail: Bitmap? = null
-
-        var geckoResult = GeckoResult<Bitmap>()
-        whenever(mockGeckoView.capturePixels()).thenReturn(geckoResult)
-        engineView.geckoView = mockGeckoView
-
-        // Test GeckoResult resolves successfuly
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        verify(mockGeckoView).capturePixels()
-        geckoResult.complete(mock())
-        assertNotNull(thumbnail)
-
-        geckoResult = GeckoResult()
-        whenever(mockGeckoView.capturePixels()).thenReturn(geckoResult)
-
-        // Test GeckoResult resolves in error
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        geckoResult.completeExceptionally(mock())
-        assertNull(thumbnail)
-
-        // Test GeckoView throwing an exception
-        whenever(mockGeckoView.capturePixels()).thenThrow(IllegalStateException("Compositor not ready"))
-
-        thumbnail = mock()
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        assertNull(thumbnail)
-    }
-
-    @Test
-    fun `clearSelection is forwarded to BasicSelectionAction instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-        engineView.currentSelection = mock()
-
-        engineView.clearSelection()
-
-        verify(engineView.currentSelection)?.clearSelection()
-    }
-
-    @Test
-    fun `setColorScheme uses preferred color scheme to set correct cover color`() {
-        val engineView = GeckoEngineView(context)
-
-        engineView.geckoView = mock()
-
-        var preferredColorScheme: PreferredColorScheme = PreferredColorScheme.Light
-
-        engineView.setColorScheme(preferredColorScheme)
-
-        verify(engineView.geckoView)?.coverUntilFirstPaint(Color.WHITE)
-
-        preferredColorScheme = PreferredColorScheme.Dark
-        engineView.setColorScheme(preferredColorScheme)
-        verify(engineView.geckoView)?.coverUntilFirstPaint(DARK_COVER)
-    }
-
-    @Test
-    fun `setVerticalClipping is forwarded to GeckoView instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.setVerticalClipping(-42)
-
-        verify(engineView.geckoView).setVerticalClipping(-42)
-    }
-
-    @Test
-    fun `setDynamicToolbarMaxHeight is forwarded to GeckoView instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.setDynamicToolbarMaxHeight(42)
-
-        verify(engineView.geckoView).setDynamicToolbarMaxHeight(42)
-    }
-
-    @Test
-    fun `release method releases session from GeckoView`() {
-        val engineView = GeckoEngineView(context)
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        verify(geckoView, never()).releaseSession()
-
-        engineView.release()
-
-        verify(geckoView).releaseSession()
-    }
-
-    @Test
-    fun `after rendering currentSelection should be a GeckoSelectionActionDelegate`() {
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = mock()
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        assertTrue(engineView.currentSelection is GeckoSelectionActionDelegate)
-    }
-
-    @Test
-    fun `will attach and detach selection action delegate when rendering and releasing`() {
-        val delegate: SelectionActionDelegate = mock()
-
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = delegate
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        val captor = argumentCaptor<GeckoSession.SelectionActionDelegate>()
-        verify(geckoSession).selectionActionDelegate = captor.capture()
-
-        assertTrue(captor.value is GeckoSelectionActionDelegate)
-        val capturedDelegate = captor.value as GeckoSelectionActionDelegate
-
-        assertEquals(delegate, capturedDelegate.customDelegate)
-
-        verify(geckoSession, never()).selectionActionDelegate = null
-
-        engineView.release()
-
-        verify(geckoSession).selectionActionDelegate = null
-    }
-
-    @Test
-    fun `will attach and detach selection action delegate when rendering new session`() {
-        val delegate: SelectionActionDelegate = mock()
-
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = delegate
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        val captor = argumentCaptor<GeckoSession.SelectionActionDelegate>()
-        verify(geckoSession).selectionActionDelegate = captor.capture()
-
-        assertTrue(captor.value is GeckoSelectionActionDelegate)
-        val capturedDelegate = captor.value as GeckoSelectionActionDelegate
-
-        assertEquals(delegate, capturedDelegate.customDelegate)
-
-        verify(geckoSession, never()).selectionActionDelegate = null
-
-        whenever(geckoView.session).thenReturn(geckoSession)
-
-        engineView.render(mock<GeckoEngineSession>().apply {
-            whenever(this.geckoSession).thenReturn(mock())
-        })
-
-        verify(geckoSession).selectionActionDelegate = null
-    }
-
-    @Test
-    fun `setVisibility is propagated to gecko view`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.visibility = View.GONE
-        verify(engineView.geckoView)?.visibility = View.GONE
-    }
-
-    @Test
-    fun `canClearSelection should return false for null selection, null and empty selection text`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-        engineView.currentSelection = mock()
-
-        // null selection returns false
-        whenever(engineView.currentSelection?.selection).thenReturn(null)
-        assertFalse(engineView.canClearSelection())
-
-        // selection with null text returns false
-        val selectionWthNullText: GeckoSession.SelectionActionDelegate.Selection = mock()
-        whenever(engineView.currentSelection?.selection).thenReturn(selectionWthNullText)
-        assertFalse(engineView.canClearSelection())
-
-        // selection with empty text returns false
-        val bundle = GeckoBundle()
-        bundle.putString("selection", "")
-        val selectionWthEmptyText: GeckoSession.SelectionActionDelegate.Selection = MockSelection(bundle)
-        whenever(engineView.currentSelection?.selection).thenReturn(selectionWthEmptyText)
-        assertFalse(engineView.canClearSelection())
-    }
-
-    @Test
-    fun `GIVEN a GeckoView WHEN EngineView returns the InputResultDetail THEN the value from the GeckoView is used`() {
-        val engineView = GeckoEngineView(context)
-        val geckoview = engineView.geckoView
-
-        assertSame(geckoview.inputResultDetail, engineView.getInputResultDetail())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt
deleted file mode 100644
index 9f4822f7a549..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt
+++ /dev/null
@@ -1,80 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runBlockingTest
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mozilla.geckoview.GeckoResult
-
-@ExperimentalCoroutinesApi
-@RunWith(AndroidJUnit4::class)
-class GeckoResultTest {
-
-    @Test
-    fun awaitWithResult() = runBlockingTest {
-        val result = GeckoResult.fromValue(42).await()
-        assertEquals(42, result)
-    }
-
-    @Test(expected = IllegalStateException::class)
-    fun awaitWithException() = runBlockingTest {
-        GeckoResult.fromException<Unit>(IllegalStateException()).await()
-    }
-
-    @Test
-    fun fromResult() = runBlockingTest {
-        val result = launchGeckoResult { 42 }
-
-        result.then {
-            assertEquals(42, it)
-            GeckoResult.fromValue(null)
-        }.await()
-    }
-
-    @Test
-    fun fromException() = runBlockingTest {
-        val result = launchGeckoResult { throw IllegalStateException() }
-
-        result.then({
-            assertTrue("Invalid branch", false)
-            GeckoResult.fromValue(null)
-        }, {
-            assertTrue(it is IllegalStateException)
-            GeckoResult.fromValue(null)
-        }).await()
-    }
-
-    @Test
-    fun asCancellableOperation() = runBlockingTest {
-        val geckoResult: GeckoResult<Int> = mock()
-        val op = geckoResult.asCancellableOperation()
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(false))
-        assertFalse(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(null))
-        assertFalse(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(true))
-        assertTrue(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromException(IllegalStateException()))
-        try {
-            op.cancel().await()
-            fail("Expected IllegalStateException")
-        } catch (e: IllegalStateException) {
-            // expected
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
deleted file mode 100644
index b5d95681bc17..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
+++ /dev/null
@@ -1,151 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.view.MotionEvent
-import android.view.MotionEvent.ACTION_CANCEL
-import android.view.MotionEvent.ACTION_DOWN
-import android.view.MotionEvent.ACTION_MOVE
-import android.view.MotionEvent.ACTION_UP
-import androidx.core.view.NestedScrollingChildHelper
-import androidx.core.view.ViewCompat.SCROLL_AXIS_VERTICAL
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.mockMotionEvent
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.anyInt
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_HANDLED
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class NestedGeckoViewTest {
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Test
-    fun `NestedGeckoView must delegate NestedScrollingChild implementation to childHelper`() {
-        val nestedWebView = NestedGeckoView(context)
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-
-        doReturn(true).`when`(mockChildHelper).isNestedScrollingEnabled
-        doReturn(true).`when`(mockChildHelper).hasNestedScrollingParent()
-
-        nestedWebView.isNestedScrollingEnabled = true
-        verify(mockChildHelper).isNestedScrollingEnabled = true
-
-        assertTrue(nestedWebView.isNestedScrollingEnabled)
-        verify(mockChildHelper).isNestedScrollingEnabled
-
-        nestedWebView.startNestedScroll(1)
-        verify(mockChildHelper).startNestedScroll(1)
-
-        nestedWebView.stopNestedScroll()
-        verify(mockChildHelper).stopNestedScroll()
-
-        assertTrue(nestedWebView.hasNestedScrollingParent())
-        verify(mockChildHelper).hasNestedScrollingParent()
-
-        nestedWebView.dispatchNestedScroll(0, 0, 0, 0, null)
-        verify(mockChildHelper).dispatchNestedScroll(0, 0, 0, 0, null)
-
-        nestedWebView.dispatchNestedPreScroll(0, 0, null, null)
-        verify(mockChildHelper).dispatchNestedPreScroll(0, 0, null, null)
-
-        nestedWebView.dispatchNestedFling(0f, 0f, true)
-        verify(mockChildHelper).dispatchNestedFling(0f, 0f, true)
-
-        nestedWebView.dispatchNestedPreFling(0f, 0f)
-        verify(mockChildHelper).dispatchNestedPreFling(0f, 0f)
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_DOWN`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        val downEvent = mockMotionEvent(ACTION_DOWN)
-        val eventCaptor = argumentCaptor<MotionEvent>()
-        nestedWebView.childHelper = mockChildHelper
-
-        nestedWebView.onTouchEvent(downEvent)
-
-        // We pass a deep copy to `updateInputResult`.
-        // Can't easily check for equality, `eventTime` should be good enough.
-        verify(nestedWebView).updateInputResult(eventCaptor.capture())
-        assertEquals(downEvent.eventTime, eventCaptor.value.eventTime)
-        verify(mockChildHelper).startNestedScroll(SCROLL_AXIS_VERTICAL)
-        verify(nestedWebView, times(0)).callSuperOnTouchEvent(any())
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_MOVE`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
-
-        doReturn(true).`when`(mockChildHelper).dispatchNestedPreScroll(
-            anyInt(), anyInt(), any(),
-            any()
-        )
-
-        nestedWebView.scrollOffset[0] = 1
-        nestedWebView.scrollOffset[1] = 2
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_MOVE, y = 10f))
-        assertEquals(nestedWebView.nestedOffsetY, 2)
-        assertEquals(nestedWebView.lastY, 8)
-
-        doReturn(true).`when`(mockChildHelper).dispatchNestedScroll(
-            anyInt(), anyInt(), anyInt(), anyInt(), any()
-        )
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_MOVE, y = 10f))
-        assertEquals(nestedWebView.nestedOffsetY, 6)
-        assertEquals(nestedWebView.lastY, 6)
-
-        // onTouchEventForResult should be called only for ACTION_DOWN
-        verify(nestedWebView, times(0)).updateInputResult(any())
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_UP or ACTION_CANCEL`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-        doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_UP))
-        verify(mockChildHelper).stopNestedScroll()
-        // ACTION_UP should call "inputResultDetail.reset()". Test that call's effect.
-        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
-        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
-
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_CANCEL))
-        verify(mockChildHelper, times(2)).stopNestedScroll()
-        // ACTION_CANCEL should call "inputResultDetail.reset()". Test that call's effect.
-        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
-        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
-
-        // onTouchEventForResult should be called only for ACTION_DOWN
-        verify(nestedWebView, times(0)).updateInputResult(any())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt
deleted file mode 100644
index 30b3ea651345..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt
+++ /dev/null
@@ -1,292 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import mozilla.components.browser.engine.gecko.content.blocking.GeckoTrackingProtectionException
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-import mozilla.components.support.ktx.util.readAndDeserialize
-import mozilla.components.support.test.any
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.ContentBlockingException
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class TrackingProtectionExceptionFileStorageTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `restoreAsync exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        storage.restore()
-
-        verify(mockContentBlocking).restoreExceptionList(any<List<ContentBlockingException>>())
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `add exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        var excludedOnTrackingProtection = false
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        session.register(object : EngineSession.Observer {
-            override fun onExcludedOnTrackingProtectionChange(excluded: Boolean) {
-                excludedOnTrackingProtection = excluded
-            }
-        })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertTrue(excludedOnTrackingProtection)
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `remove all exceptions`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        val engineSession: EngineSession = mock()
-        val activeSessions: List<EngineSession> = listOf(engineSession)
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-
-        // Removing exceptions
-        storage.removeAll(activeSessions)
-        verify(mockContentBlocking).clearExceptionList()
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        verify(engineSession).notifyObservers(any())
-    }
-
-    @Test
-    fun `remove exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        var excludedOnTrackingProtection = false
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        session.register(object : EngineSession.Observer {
-            override fun onExcludedOnTrackingProtectionChange(excluded: Boolean) {
-                excludedOnTrackingProtection = excluded
-            }
-        })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-        assertTrue(excludedOnTrackingProtection)
-
-        // Removing exception
-        geckoResult = GeckoResult<List<ContentBlockingException>>()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-        storage.remove(session)
-        verify(mockContentBlocking).removeException(mockGeckoSession)
-        geckoResult.complete(null)
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        assertFalse(excludedOnTrackingProtection)
-    }
-
-    @Test
-    fun `remove a TrackingProtectionException`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-
-        // Removing exception
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-        storage.remove(
-            GeckoTrackingProtectionException(
-                "https://www.cnn.com/",
-                "eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ"
-            )
-        )
-        verify(mockContentBlocking).removeException(any<ContentBlockingException>())
-        geckoResult.complete(null)
-        assertNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `contains exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        var geckoResult = GeckoResult<Boolean>()
-        val mockGeckoSession = mock<GeckoSession>()
-        var containsException = false
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.checkException(mockGeckoSession)).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-
-        storage.contains(session) { contains ->
-            containsException = contains
-        }
-        geckoResult.complete(true)
-
-        verify(mockContentBlocking).checkException(mockGeckoSession)
-        assertTrue(containsException)
-
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.checkException(mockGeckoSession)).thenReturn(geckoResult)
-
-        storage.contains(session) { contains ->
-            containsException = contains
-        }
-        geckoResult.complete(null)
-        assertFalse(containsException)
-    }
-
-    @Test
-    fun `getAll exceptions`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.mozilla.com\\/\"}")))
-        var exceptionList: List<TrackingProtectionException>? = null
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-
-        storage.fetchAll { exceptions ->
-            exceptionList = exceptions
-        }
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).saveExceptionList()
-        assertTrue(exceptionList!!.isNotEmpty())
-        assertEquals("https://www.mozilla.com/", exceptionList!!.first().url)
-        assertEquals("eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==", (exceptionList!!.first() as GeckoTrackingProtectionException).principal)
-
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        storage.fetchAll { exceptions ->
-            exceptionList = exceptions
-        }
-
-        geckoResult.complete(null)
-        assertTrue(exceptionList!!.isEmpty())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt
deleted file mode 100644
index 461b0f4df5aa..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt
+++ /dev/null
@@ -1,75 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.activity
-
-import android.app.PendingIntent
-import android.content.Intent
-import android.content.IntentSender
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNotNull
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.`when`
-import org.mozilla.geckoview.GeckoResult
-import java.lang.ref.WeakReference
-
-@RunWith(AndroidJUnit4::class)
-class GeckoActivityDelegateTest {
-    lateinit var pendingIntent: PendingIntent
-
-    @Before
-    fun setup() {
-        pendingIntent = mock()
-        `when`(pendingIntent.intentSender).thenReturn(mock())
-    }
-
-    @Test
-    fun `onStartActivityForResult is completed successfully`() {
-        val delegate: ActivityDelegate = object : ActivityDelegate {
-            override fun startIntentSenderForResult(intent: IntentSender, onResult: (Intent?) -> Unit) {
-                onResult(mock())
-            }
-        }
-
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(delegate))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.accept {
-            assertNotNull(it)
-        }
-    }
-
-    @Test
-    fun `onStartActivityForResult completes exceptionally on null response`() {
-        val delegate: ActivityDelegate = object : ActivityDelegate {
-            override fun startIntentSenderForResult(intent: IntentSender, onResult: (Intent?) -> Unit) {
-                onResult(null)
-            }
-        }
-
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(delegate))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.exceptionally { throwable ->
-            assertEquals("Activity for result failed.", throwable.localizedMessage)
-            GeckoResult.fromValue(null)
-        }
-    }
-
-    @Test
-    fun `onStartActivityForResult completes exceptionally when there is no object attached to the weak reference`() {
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(null))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.exceptionally { throwable ->
-            assertEquals("Activity for result failed; no delegate attached.", throwable.localizedMessage)
-            GeckoResult.fromValue(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt
deleted file mode 100644
index a3f8b58a1b50..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- *  License, v. 2.0. If a copy of the MPL was not distributed with this
- *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-package mozilla.components.browser.engine.gecko.ext
-
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.mozilla.geckoview.ContentBlocking.EtpLevel
-
-class TrackingProtectionPolicyKtTest {
-
-    private val defaultSafeBrowsing = arrayOf(EngineSession.SafeBrowsingPolicy.RECOMMENDED)
-
-    @Test
-    fun `transform the policy to a GeckoView ContentBlockingSetting`() {
-        val policy = TrackingProtectionPolicy.recommended()
-        val setting = policy.toContentBlockingSetting()
-
-        assertEquals(policy.getEtpLevel(), setting.enhancedTrackingProtectionLevel)
-        assertEquals(policy.getAntiTrackingPolicy(), setting.antiTrackingCategories)
-        assertEquals(policy.cookiePolicy.id, setting.cookieBehavior)
-        assertEquals(defaultSafeBrowsing.sumBy { it.id }, setting.safeBrowsingCategories)
-        assertEquals(setting.strictSocialTrackingProtection, policy.strictSocialTrackingProtection)
-        assertEquals(setting.cookiePurging, policy.cookiePurging)
-
-        val policyWithSafeBrowsing = TrackingProtectionPolicy.recommended().toContentBlockingSetting(emptyArray())
-        assertEquals(0, policyWithSafeBrowsing.safeBrowsingCategories)
-    }
-
-    @Test
-    fun `getEtpLevel is always Strict unless None`() {
-        assertEquals(EtpLevel.STRICT, TrackingProtectionPolicy.recommended().getEtpLevel())
-        assertEquals(EtpLevel.STRICT, TrackingProtectionPolicy.strict().getEtpLevel())
-        assertEquals(EtpLevel.NONE, TrackingProtectionPolicy.none().getEtpLevel())
-    }
-
-    @Test
-    fun `getStrictSocialTrackingProtection is true if category is STRICT`() {
-        val recommendedPolicy = TrackingProtectionPolicy.recommended()
-        val strictPolicy = TrackingProtectionPolicy.strict()
-
-        assertFalse(recommendedPolicy.toContentBlockingSetting().strictSocialTrackingProtection)
-        assertTrue(strictPolicy.toContentBlockingSetting().strictSocialTrackingProtection)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt
deleted file mode 100644
index 90ca218805ad..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt
+++ /dev/null
@@ -1,332 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.fetch.Client
-import mozilla.components.concept.fetch.Request
-import mozilla.components.concept.fetch.Response
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.tooling.fetch.tests.FetchTestCases
-import okhttp3.Headers
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.mockwebserver.RecordedRequest
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentCaptor
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.ArgumentMatchers.anyLong
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebRequest
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebResponse
-import java.io.IOException
-import java.nio.charset.Charset
-import java.util.concurrent.TimeoutException
-
-/**
- * We can't run standard JVM unit tests for GWE. Therefore, we provide both
- * instrumented tests as well as these unit tests which mock both requests
- * and responses. While these tests guard our logic to map responses to our
- * concept-fetch abstractions, they are not sufficient to guard the full
- * functionality of [GeckoViewFetchClient]. That's why end-to-end tests are
- * provided in instrumented tests.
- */
-@RunWith(AndroidJUnit4::class)
-class GeckoViewFetchUnitTestCases : FetchTestCases() {
-
-    override fun createNewClient(): Client {
-        val client = GeckoViewFetchClient(testContext, mock())
-        geckoWebExecutor?.let { client.executor = it }
-        return client
-    }
-
-    override fun createWebServer(): MockWebServer {
-        return mockWebServer ?: super.createWebServer()
-    }
-
-    private var geckoWebExecutor: GeckoWebExecutor? = null
-    private var mockWebServer: MockWebServer? = null
-
-    @Before
-    fun setup() {
-        geckoWebExecutor = null
-    }
-
-    @Test
-    fun clientInstance() {
-        assertTrue(createNewClient() is GeckoViewFetchClient)
-    }
-
-    @Test
-    override fun get200WithDuplicatedCacheControlRequestHeaders() {
-        val headerMap = mapOf("Cache-Control" to "no-cache, no-store")
-        mockRequest(headerMap)
-        mockResponse(200)
-
-        super.get200WithDuplicatedCacheControlRequestHeaders()
-    }
-
-    @Test
-    override fun get200WithDuplicatedCacheControlResponseHeaders() {
-        val responseHeaderMap = mapOf(
-            "Cache-Control" to "no-cache, no-store",
-            "Content-Length" to "16"
-        )
-        mockResponse(200, responseHeaderMap)
-
-        super.get200WithDuplicatedCacheControlResponseHeaders()
-    }
-
-    @Test
-    override fun get200OverridingDefaultHeaders() {
-        val headerMap = mapOf(
-            "Accept" to "text/html",
-            "Accept-Encoding" to "deflate",
-            "User-Agent" to "SuperBrowser/1.0",
-            "Connection" to "close")
-        mockRequest(headerMap)
-        mockResponse(200)
-
-        super.get200OverridingDefaultHeaders()
-    }
-
-    @Test
-    override fun get200WithGzippedBody() {
-        val responseHeaderMap = mapOf("Content-Encoding" to "gzip")
-        mockRequest()
-        mockResponse(200, responseHeaderMap, "This is compressed")
-
-        super.get200WithGzippedBody()
-    }
-
-    @Test
-    override fun get200WithHeaders() {
-        val requestHeaders = mapOf(
-            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
-            "Accept-Encoding" to "gzip, deflate",
-            "Accept-Language" to "en-US,en;q=0.5",
-            "Connection" to "keep-alive",
-            "User-Agent" to "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0"
-        )
-        mockRequest(requestHeaders)
-        mockResponse(200)
-
-        super.get200WithHeaders()
-    }
-
-    @Test
-    override fun get200WithReadTimeout() {
-        mockRequest()
-        mockResponse(200)
-
-        val geckoResult = mock<GeckoResult<*>>()
-        whenever(geckoResult.poll(anyLong())).thenThrow(TimeoutException::class.java)
-        @Suppress("UNCHECKED_CAST")
-        whenever(geckoWebExecutor!!.fetch(any(), anyInt())).thenReturn(geckoResult as GeckoResult<WebResponse>)
-
-        super.get200WithReadTimeout()
-    }
-
-    @Test
-    override fun get200WithStringBody() {
-        mockRequest()
-        mockResponse(200, body = "Hello World")
-
-        super.get200WithStringBody()
-    }
-
-    @Test
-    override fun get302FollowRedirects() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.redirect).thenReturn(Request.Redirect.FOLLOW)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_NONE))
-    }
-
-    @Test
-    override fun get302FollowRedirectsDisabled() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.redirect).thenReturn(Request.Redirect.MANUAL)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_NO_REDIRECTS))
-    }
-
-    @Test
-    override fun get404WithBody() {
-        mockRequest()
-        mockResponse(404, body = "Error")
-        super.get404WithBody()
-    }
-
-    @Test
-    override fun post200WithBody() {
-        mockRequest(method = "POST", body = "Hello World")
-        mockResponse(200)
-        super.post200WithBody()
-    }
-
-    @Test
-    override fun put201FileUpload() {
-        mockRequest(method = "PUT", headerMap = mapOf("Content-Type" to "image/png"), body = "I am an image file!")
-        mockResponse(201, headerMap = mapOf("Location" to "/your-image.png"), body = "Thank you!")
-        super.put201FileUpload()
-    }
-
-    @Test(expected = IOException::class)
-    fun pollReturningNull() {
-        mockResponse(200)
-
-        val geckoResult = mock<GeckoResult<*>>()
-        whenever(geckoResult.poll(anyLong())).thenReturn(null)
-        @Suppress("UNCHECKED_CAST")
-        whenever(geckoWebExecutor!!.fetch(any(), anyInt())).thenReturn(geckoResult as GeckoResult<WebResponse>)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        createNewClient().fetch(request)
-    }
-
-    @Test
-    override fun get200WithCookiePolicy() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.cookiePolicy).thenReturn(Request.CookiePolicy.OMIT)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_ANONYMOUS))
-    }
-
-    @Test
-    fun performPrivateRequest() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.private).thenReturn(true)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_PRIVATE))
-    }
-
-    @Test
-    override fun get200WithContentTypeCharset() {
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-
-        mockResponse(200,
-                headerMap = mapOf("Content-Type" to "text/html; charset=ISO-8859-1"),
-                body = "",
-                charset = Charsets.ISO_8859_1)
-
-        val response = createNewClient().fetch(request)
-        assertEquals("", response.body.string())
-    }
-
-    @Test
-    override fun get200WithCacheControl() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.useCaches).thenReturn(false)
-        createNewClient().fetch(request)
-
-        val captor = ArgumentCaptor.forClass(WebRequest::class.java)
-
-        verify(geckoWebExecutor)!!.fetch(captor.capture(), eq(GeckoWebExecutor.FETCH_FLAGS_NONE))
-        assertEquals(WebRequest.CACHE_MODE_RELOAD, captor.value.cacheMode)
-    }
-
-    @Test(expected = IOException::class)
-    override fun getThrowsIOExceptionWhenHostNotReachable() {
-        val executor = mock<GeckoWebExecutor>()
-        whenever(executor.fetch(any(), anyInt())).thenAnswer { throw WebRequestError(0, 0) }
-        geckoWebExecutor = executor
-
-        createNewClient().fetch(Request(""))
-    }
-
-    @Test
-    fun toResponseMustReturn200ForBlobUrls() {
-        val builder = WebResponse.Builder("blob:https://mdn.mozillademos.org/d518464c-5075-9046-aef2-9c313214ed53").statusCode(0).build()
-        assertEquals(Response.SUCCESS, builder.toResponse().status)
-    }
-
-    @Test
-    fun toResponseMustReturn200ForDataUrls() {
-        val builder = WebResponse.Builder("data:,Hello%2C%20World!").statusCode(0).build()
-        assertEquals(Response.SUCCESS, builder.toResponse().status)
-    }
-
-    private fun mockRequest(headerMap: Map<String, String>? = null, body: String? = null, method: String = "GET") {
-        val server = mock<MockWebServer>()
-        whenever(server.url(any())).thenReturn(mock())
-        val request = mock<RecordedRequest>()
-        whenever(request.method).thenReturn(method)
-
-        headerMap?.let {
-            whenever(request.headers).thenReturn(Headers.of(headerMap))
-            whenever(request.getHeader(any())).thenAnswer { inv -> it[inv.getArgument(0)] }
-        }
-
-        body?.let {
-            val buffer = okio.Buffer()
-            buffer.write(body.toByteArray())
-            whenever(request.body).thenReturn(buffer)
-        }
-
-        whenever(server.takeRequest()).thenReturn(request)
-        mockWebServer = server
-    }
-
-    private fun mockResponse(
-        statusCode: Int,
-        headerMap: Map<String, String>? = null,
-        body: String? = null,
-        charset: Charset = Charsets.UTF_8
-    ) {
-        val executor = mock<GeckoWebExecutor>()
-        val builder = WebResponse.Builder("").statusCode(statusCode)
-        headerMap?.let {
-            headerMap.forEach { (k, v) -> builder.addHeader(k, v) }
-        }
-
-        body?.let {
-            builder.body(it.byteInputStream(charset))
-        }
-
-        val response = builder.build()
-
-        whenever(executor.fetch(any(), anyInt())).thenReturn(GeckoResult.fromValue(response))
-        geckoWebExecutor = executor
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt
deleted file mode 100644
index 5d6b14100cd1..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt
+++ /dev/null
@@ -1,72 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-
-@RunWith(AndroidJUnit4::class)
-class SettingUpdaterTest {
-
-    @Test
-    fun `test updateValue`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertEquals("current", subject.value)
-
-        subject.updateValue()
-        assertEquals("new", subject.value)
-    }
-
-    @Test
-    fun `test enabled updates value`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertEquals("current", subject.value)
-
-        subject.enabled = true
-        assertEquals("new", subject.value)
-
-        // disabling doesn't update the value.
-        subject.nextValue = "disabled"
-        subject.enabled = false
-        assertEquals("new", subject.value)
-    }
-
-    @Test
-    fun `test registering and deregistering for updates`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertFalse("Initialized not registering for updates", subject.registered)
-
-        subject.updateValue()
-        assertFalse("updateValue not registering for updates", subject.registered)
-
-        subject.enabled = true
-        assertTrue("enabled = true registering for updates", subject.registered)
-
-        subject.enabled = false
-        assertFalse("enabled = false deregistering for updates", subject.registered)
-    }
-}
-
-class DummySettingUpdater(
-    override var value: String = "",
-    var nextValue: String
-) : SettingUpdater<String>() {
-
-    var registered = false
-
-    override fun registerForUpdates() {
-        registered = true
-    }
-
-    override fun unregisterForUpdates() {
-        registered = false
-    }
-
-    override fun findValue() = nextValue
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt
deleted file mode 100644
index 433e3e3af7f7..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import mozilla.components.support.test.mock
-import org.junit.Test
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-class GeckoMediaSessionControllerTest {
-    @Test
-    fun `GeckoMediaSessionController works correctly with GeckoView MediaSession`() {
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-        val controller = GeckoMediaSessionController(geckoViewMediaSession)
-
-        controller.pause()
-        verify(geckoViewMediaSession, times(1)).pause()
-
-        controller.stop()
-        verify(geckoViewMediaSession, times(1)).stop()
-
-        controller.play()
-        verify(geckoViewMediaSession, times(1)).play()
-
-        controller.seekTo(123.0, true)
-        verify(geckoViewMediaSession, times(1)).seekTo(123.0, true)
-
-        controller.seekForward()
-        verify(geckoViewMediaSession, times(1)).seekForward()
-
-        controller.seekBackward()
-        verify(geckoViewMediaSession, times(1)).seekBackward()
-
-        controller.nextTrack()
-        verify(geckoViewMediaSession, times(1)).nextTrack()
-
-        controller.previousTrack()
-        verify(geckoViewMediaSession, times(1)).previousTrack()
-
-        controller.skipAd()
-        verify(geckoViewMediaSession, times(1)).skipAd()
-
-        controller.muteAudio(true)
-        verify(geckoViewMediaSession, times(1)).muteAudio(true)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt
deleted file mode 100644
index 16edbd74cc3c..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt
+++ /dev/null
@@ -1,201 +0,0 @@
-package mozilla.components.browser.engine.gecko.mediasession
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.mediasession.MediaSession
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-@RunWith(AndroidJUnit4::class)
-class GeckoMediaSessionDelegateTest {
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `media session activated is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedController: MediaSession.Controller? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaActivated(mediaSessionController: MediaSession.Controller) {
-                observedController = mediaSessionController
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onActivated(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedController)
-        observedController!!.play()
-        verify(geckoViewMediaSession).play()
-    }
-
-    @Test
-    fun `media session deactivated is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedActivated = true
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaDeactivated() {
-                observedActivated = false
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onDeactivated(mock(), geckoViewMediaSession)
-
-        assertFalse(observedActivated)
-    }
-
-    @Test
-    fun `media session metadata is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedMetadata: MediaSession.Metadata? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaMetadataChanged(
-                metadata: MediaSession.Metadata
-            ) {
-                observedMetadata = metadata
-            }
-        })
-
-        val metadata: GeckoViewMediaSession.Metadata = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onMetadata(mock(), geckoViewMediaSession, metadata)
-
-        assertNotNull(observedMetadata)
-        assertEquals(observedMetadata?.title, metadata.title)
-        assertEquals(observedMetadata?.artist, metadata.artist)
-        assertEquals(observedMetadata?.album, metadata.album)
-        assertEquals(observedMetadata?.getArtwork, metadata.artwork)
-    }
-
-    @Test
-    fun `media session feature is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedFeature: MediaSession.Feature? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaFeatureChanged(
-                features: MediaSession.Feature
-            ) {
-                observedFeature = features
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onFeatures(mock(), geckoViewMediaSession, 123)
-
-        assertNotNull(observedFeature)
-        assertEquals(observedFeature, MediaSession.Feature(123))
-    }
-
-    @Test
-    fun `media session play state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedPlaybackState: MediaSession.PlaybackState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaPlaybackStateChanged(
-                playbackState: MediaSession.PlaybackState
-            ) {
-                observedPlaybackState = playbackState
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onPlay(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.PLAYING)
-
-        observedPlaybackState = null
-        engineSession.geckoSession.mediaSessionDelegate!!.onPause(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.PAUSED)
-
-        observedPlaybackState = null
-        engineSession.geckoSession.mediaSessionDelegate!!.onStop(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.STOPPED)
-    }
-
-    @Test
-    fun `media session position state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedPositionState: MediaSession.PositionState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaPositionStateChanged(
-                positionState: MediaSession.PositionState
-            ) {
-                observedPositionState = positionState
-            }
-        })
-
-        val positionState: GeckoViewMediaSession.PositionState = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onPositionState(mock(), geckoViewMediaSession, positionState)
-
-        assertNotNull(observedPositionState)
-        assertEquals(observedPositionState?.duration, positionState.duration)
-        assertEquals(observedPositionState?.position, positionState.position)
-        assertEquals(observedPositionState?.playbackRate, positionState.playbackRate)
-    }
-
-    @Test
-    fun `media session fullscreen state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedFullscreen: Boolean? = null
-        var observedElementMetadata: MediaSession.ElementMetadata? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaFullscreenChanged(
-                fullscreen: Boolean,
-                elementMetadata: MediaSession.ElementMetadata?
-            ) {
-                observedFullscreen = fullscreen
-                observedElementMetadata = elementMetadata
-            }
-        })
-
-        val elementMetadata: GeckoViewMediaSession.ElementMetadata = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onFullscreen(mock(), geckoViewMediaSession, true, elementMetadata)
-
-        assertNotNull(observedFullscreen)
-        assertNotNull(observedElementMetadata)
-        assertEquals(observedFullscreen, true)
-        assertEquals(observedElementMetadata?.source, elementMetadata.source)
-        assertEquals(observedElementMetadata?.duration, elementMetadata.duration)
-        assertEquals(observedElementMetadata?.width, elementMetadata.width)
-        assertEquals(observedElementMetadata?.height, elementMetadata.height)
-        assertEquals(observedElementMetadata?.audioTrackCount, elementMetadata.audioTrackCount)
-        assertEquals(observedElementMetadata?.videoTrackCount, elementMetadata.videoTrackCount)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt
deleted file mode 100644
index bdaaf578b403..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt
+++ /dev/null
@@ -1,192 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.permission
-
-import android.Manifest
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.permission.Permission
-import mozilla.components.support.test.mock
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_DESKTOP_NOTIFICATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION
-
-@RunWith(AndroidJUnit4::class)
-class GeckoPermissionRequestTest {
-
-    @Test
-    fun `create content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        var request = GeckoPermissionRequest.Content(uri, PERMISSION_DESKTOP_NOTIFICATION, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentNotification()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentGeoLocation()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_AUDIBLE, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentAutoPlayAudible()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_INAUDIBLE, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentAutoPlayInaudible()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, 1234, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.Generic("1234", "Gecko permission type = 1234")), request.permissions)
-    }
-
-    @Test
-    fun `grant content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        val request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        request.grant()
-        verify(callback).grant()
-    }
-
-    @Test
-    fun `reject content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        val request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    @Test
-    fun `create app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val permissions = listOf(
-                Manifest.permission.ACCESS_COARSE_LOCATION,
-                Manifest.permission.ACCESS_FINE_LOCATION,
-                Manifest.permission.CAMERA,
-                Manifest.permission.RECORD_AUDIO,
-                "unknown app permission")
-
-        val mappedPermissions = listOf(
-                Permission.AppLocationCoarse(Manifest.permission.ACCESS_COARSE_LOCATION),
-                Permission.AppLocationFine(Manifest.permission.ACCESS_FINE_LOCATION),
-                Permission.AppCamera(Manifest.permission.CAMERA),
-                Permission.AppAudio(Manifest.permission.RECORD_AUDIO),
-                Permission.Generic("unknown app permission")
-        )
-
-        val request = GeckoPermissionRequest.App(permissions, callback)
-        assertEquals(mappedPermissions, request.permissions)
-    }
-
-    @Test
-    fun `grant app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-
-        val request = GeckoPermissionRequest.App(listOf(Manifest.permission.CAMERA), callback)
-        request.grant()
-        verify(callback).grant()
-    }
-
-    @Test
-    fun `reject app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-
-        val request = GeckoPermissionRequest.App(listOf(Manifest.permission.CAMERA), callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    @Test
-    fun `create media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val audioCapture = MockMediaSource("audioCapture", "audioCapture",
-                MediaSource.SOURCE_AUDIOCAPTURE, MediaSource.TYPE_AUDIO)
-        val audioOther = MockMediaSource("audioOther", "audioOther",
-                MediaSource.SOURCE_OTHER, MediaSource.TYPE_AUDIO)
-
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-        val videoScreen = MockMediaSource("videoScreen", "videoScreen",
-                MediaSource.SOURCE_SCREEN, MediaSource.TYPE_VIDEO)
-        val videoOther = MockMediaSource("videoOther", "videoOther",
-                MediaSource.SOURCE_OTHER, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioCapture, audioMicrophone, audioOther)
-        val videoSources = listOf(videoCamera, videoOther, videoScreen)
-
-        val mappedPermissions = listOf(
-                Permission.ContentVideoCamera("videoCamera", "videoCamera"),
-                Permission.ContentVideoScreen("videoScreen", "videoScreen"),
-                Permission.ContentVideoOther("videoOther", "videoOther"),
-                Permission.ContentAudioMicrophone("audioMicrophone", "audioMicrophone"),
-                Permission.ContentAudioCapture("audioCapture", "audioCapture"),
-                Permission.ContentAudioOther("audioOther", "audioOther")
-        )
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(mappedPermissions.size, request.permissions.size)
-        assertTrue(request.permissions.containsAll(mappedPermissions))
-    }
-
-    @Test
-    fun `grant media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioMicrophone)
-        val videoSources = listOf(videoCamera)
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        request.grant(request.permissions)
-        verify(callback).grant(videoCamera, audioMicrophone)
-    }
-
-    @Test
-    fun `reject media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioMicrophone)
-        val videoSources = listOf(videoCamera)
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    class MockMediaSource(id: String, name: String, source: Int, type: Int) : MediaSource() {
-        init {
-            ReflectionUtils.setField(this, "id", id)
-            ReflectionUtils.setField(this, "name", name)
-            ReflectionUtils.setField(this, "source", source)
-            ReflectionUtils.setField(this, "type", type)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt
deleted file mode 100644
index c14c3d456f9b..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt
+++ /dev/null
@@ -1,1409 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.prompt
-
-import android.net.Uri
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.prompt.Choice
-import mozilla.components.concept.engine.prompt.PromptRequest
-import mozilla.components.concept.engine.prompt.PromptRequest.MultipleChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.SingleChoice
-import mozilla.components.concept.storage.Login
-import mozilla.components.support.ktx.kotlin.toDate
-import mozilla.components.support.test.any
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.never
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATETIME_LOCAL
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.MONTH
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.TIME
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.WEEK
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.ANY
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.NONE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.USER
-import java.io.FileInputStream
-import java.security.InvalidParameterException
-import java.util.Calendar
-import java.util.Calendar.YEAR
-import java.util.Date
-
-typealias GeckoChoice = GeckoSession.PromptDelegate.ChoicePrompt.Choice
-typealias GECKO_AUTH_LEVEL = GeckoSession.PromptDelegate.AuthPrompt.AuthOptions.Level
-typealias GECKO_PROMPT_CHOICE_TYPE = GeckoSession.PromptDelegate.ChoicePrompt.Type
-typealias GECKO_AUTH_FLAGS = GeckoSession.PromptDelegate.AuthPrompt.AuthOptions.Flags
-typealias GECKO_PROMPT_FILE_TYPE = GeckoSession.PromptDelegate.FilePrompt.Type
-typealias AC_AUTH_METHOD = PromptRequest.Authentication.Method
-typealias AC_AUTH_LEVEL = PromptRequest.Authentication.Level
-
-@RunWith(AndroidJUnit4::class)
-class GeckoPromptDelegateTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_SINGLE must provide a SingleChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = MultipleChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val geckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.SINGLE,
-            arrayOf(geckoChoice)
-        )
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                promptRequestSingleChoice = promptRequest
-            }
-        })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is SingleChoice)
-        val request = promptRequestSingleChoice as SingleChoice
-
-        request.onConfirm(request.choices.first())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(request.choices.first())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_MULTIPLE must provide a MultipleChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = SingleChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val mockGeckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.MULTIPLE,
-            arrayOf(mockGeckoChoice)
-        )
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                promptRequestSingleChoice = promptRequest
-            }
-        })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is MultipleChoice)
-
-        (promptRequestSingleChoice as MultipleChoice).onConfirm(arrayOf())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        (promptRequestSingleChoice as MultipleChoice).onConfirm(arrayOf())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_MENU must provide a MenuChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = PromptRequest.MenuChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val geckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.MENU,
-            arrayOf(geckoChoice)
-        )
-
-        mockSession.register(
-            object : EngineSession.Observer {
-                override fun onPromptRequest(promptRequest: PromptRequest) {
-                    promptRequestSingleChoice = promptRequest
-                }
-            })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is PromptRequest.MenuChoice)
-        val request = promptRequestSingleChoice as PromptRequest.MenuChoice
-
-        request.onConfirm(request.choices.first())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(request.choices.first())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test(expected = InvalidParameterException::class)
-    fun `calling onChoicePrompt with not valid Gecko ChoiceType will throw an exception`() {
-        val promptDelegate = GeckoPromptDelegate(mock())
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            -1,
-            arrayOf()
-        )
-        promptDelegate.onChoicePrompt(mock(), geckoPrompt)
-    }
-
-    @Test
-    fun `onAlertPrompt must provide an alert PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var alertRequest: PromptRequest? = null
-        var dismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                alertRequest = promptRequest
-            }
-        })
-
-        val geckoResult = promptDelegate.onAlertPrompt(mock(), GeckoAlertPrompt())
-        geckoResult.accept {
-            dismissWasCalled = true
-        }
-        assertTrue(alertRequest is PromptRequest.Alert)
-
-        (alertRequest as PromptRequest.Alert).onDismiss()
-        assertTrue(dismissWasCalled)
-
-        assertEquals((alertRequest as PromptRequest.Alert).title, "title")
-        assertEquals((alertRequest as PromptRequest.Alert).message, "message")
-    }
-
-    @Test
-    fun `toIdsArray must convert an list of choices to array of id strings`() {
-        val choices = arrayOf(Choice(id = "0", label = ""), Choice(id = "1", label = ""))
-        val ids = choices.toIdsArray()
-        ids.forEachIndexed { index, item ->
-            assertEquals("$index", item)
-        }
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_DATE must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-        var onClearPicker = false
-        var geckoPrompt = GeckoDateTimePrompt("title", DATE, "", "", "")
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-
-        var geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-
-        confirmCalled = false
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-
-        assertFalse(confirmCalled)
-
-        geckoPrompt = GeckoDateTimePrompt("title", DATE, "", "", "")
-        geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onClearPicker = true
-        }
-
-        (dateRequest as PromptRequest.TimeSelection).onClear()
-        assertTrue(onClearPicker)
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_DATE with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val geckoPrompt =
-            GeckoDateTimePrompt(
-                title = "title",
-                type = DATE,
-                defaultValue = "2019-11-29",
-                minValue = "2019-11-28",
-                maxValue = "2019-11-30"
-            )
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2019-11-29".toDate("yyyy-MM-dd"))
-            assertEquals(minimumDate, "2019-11-28".toDate("yyyy-MM-dd"))
-            assertEquals(maximumDate, "2019-11-30".toDate("yyyy-MM-dd"))
-        }
-        val selectedDate = "2019-11-28".toDate("yyyy-MM-dd")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM-dd")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_MONTH must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = MONTH)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_MONTH with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = MONTH,
-            defaultValue = "2019-11",
-            minValue = "2019-11",
-            maxValue = "2019-11"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2019-11".toDate("yyyy-MM"))
-            assertEquals(minimumDate, "2019-11".toDate("yyyy-MM"))
-            assertEquals(maximumDate, "2019-11".toDate("yyyy-MM"))
-        }
-        val selectedDate = "2019-11".toDate("yyyy-MM")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_WEEK must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = WEEK)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_WEEK with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = WEEK,
-            defaultValue = "2018-W18",
-            minValue = "2018-W18",
-            maxValue = "2018-W26"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2018-W18".toDate("yyyy-'W'ww"))
-            assertEquals(minimumDate, "2018-W18".toDate("yyyy-'W'ww"))
-            assertEquals(maximumDate, "2018-W26".toDate("yyyy-'W'ww"))
-        }
-        val selectedDate = "2018-W26".toDate("yyyy-'W'ww")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-'W'ww")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_TIME must provide a TimeSelection PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = TIME)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_TIME with time parameters must format time correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = TIME,
-            defaultValue = "17:00",
-            minValue = "9:00",
-            maxValue = "18:00"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "17:00".toDate("HH:mm"))
-            assertEquals(minimumDate, "9:00".toDate("HH:mm"))
-            assertEquals(maximumDate, "18:00".toDate("HH:mm"))
-        }
-        val selectedDate = "17:00".toDate("HH:mm")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("HH:mm")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_DATETIME_LOCAL must provide a TimeSelection PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoResult =
-            promptDelegate.onDateTimePrompt(mock(), GeckoDateTimePrompt(type = DATETIME_LOCAL))
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_DATETIME_LOCAL with date parameters must format time correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = DATETIME_LOCAL,
-            defaultValue = "2018-06-12T19:30",
-            minValue = "2018-06-07T00:00",
-            maxValue = "2018-06-14T00:00"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2018-06-12T19:30".toDate("yyyy-MM-dd'T'HH:mm"))
-            assertEquals(minimumDate, "2018-06-07T00:00".toDate("yyyy-MM-dd'T'HH:mm"))
-            assertEquals(maximumDate, "2018-06-14T00:00".toDate("yyyy-MM-dd'T'HH:mm"))
-        }
-        val selectedDate = "2018-06-12T19:30".toDate("yyyy-MM-dd'T'HH:mm")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM-dd'T'HH:mm")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test(expected = InvalidParameterException::class)
-    fun `Calling onDateTimePrompt with invalid DatetimeType will throw an exception`() {
-        val promptDelegate = GeckoPromptDelegate(mock())
-        promptDelegate.onDateTimePrompt(
-            mock(),
-            GeckoDateTimePrompt(
-                type = 13223,
-                defaultValue = "17:00",
-                minValue = "9:00",
-                maxValue = "18:00"
-            )
-        )
-    }
-
-    @Test
-    fun `date to string`() {
-        val date = Date()
-
-        var dateString = date.toString()
-        assertNotNull(dateString.isEmpty())
-
-        dateString = date.toString("yyyy")
-        val calendar = Calendar.getInstance()
-        calendar.time = date
-        val year = calendar[YEAR].toString()
-        assertEquals(dateString, year)
-    }
-
-    @Test
-    fun `Calling onFilePrompt must provide a FilePicker PromptRequest`() {
-        val context = spy(testContext)
-        val contentResolver = spy(context.contentResolver)
-        val mockSession = GeckoEngineSession(runtime)
-        var onSingleFileSelectedWasCalled = false
-        var onMultipleFilesSelectedWasCalled = false
-        var onDismissWasCalled = false
-        val mockUri: Uri = mock()
-
-        doReturn(contentResolver).`when`(context).contentResolver
-        doReturn(mock<FileInputStream>()).`when`(contentResolver).openInputStream(any())
-
-        var filePickerRequest: PromptRequest.File = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        // Prevent the file from being copied
-        doReturn(0L).`when`(promptDelegate).copyFile(any(), any())
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                filePickerRequest = promptRequest as PromptRequest.File
-            }
-        })
-        var geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.SINGLE, capture = NONE)
-
-        var geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onSingleFileSelectedWasCalled = true
-        }
-
-        filePickerRequest.onSingleFileSelected(context, mockUri)
-        assertTrue(onSingleFileSelectedWasCalled)
-
-        onSingleFileSelectedWasCalled = false
-        filePickerRequest.onSingleFileSelected(context, mockUri)
-
-        assertFalse(onSingleFileSelectedWasCalled)
-
-        geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.MULTIPLE, capture = ANY)
-        geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onMultipleFilesSelectedWasCalled = true
-        }
-
-        filePickerRequest.onMultipleFilesSelected(context, arrayOf(mockUri))
-        assertTrue(onMultipleFilesSelectedWasCalled)
-
-        onMultipleFilesSelectedWasCalled = false
-        filePickerRequest.onMultipleFilesSelected(context, arrayOf(mockUri))
-
-        assertFalse(onMultipleFilesSelectedWasCalled)
-
-        geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.SINGLE, capture = NONE)
-        geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        filePickerRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        assertTrue(filePickerRequest.mimeTypes.isEmpty())
-        assertFalse(filePickerRequest.isMultipleFilesSelection)
-        assertEquals(PromptRequest.File.FacingMode.NONE, filePickerRequest.captureMode)
-
-        promptDelegate.onFilePrompt(
-            mock(),
-            GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.MULTIPLE, capture = USER)
-        )
-
-        assertTrue(filePickerRequest.isMultipleFilesSelection)
-        assertEquals(
-            PromptRequest.File.FacingMode.FRONT_CAMERA,
-            filePickerRequest.captureMode
-        )
-    }
-
-    @Test
-    fun `Calling onLoginSave must provide an SaveLoginPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onLoginSaved = false
-        var onDismissWasCalled = false
-
-        var loginSaveRequest: PromptRequest.SaveLoginPrompt = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                loginSaveRequest = promptRequest as PromptRequest.SaveLoginPrompt
-            }
-        })
-
-        val login = createLogin()
-        val saveOption = Autocomplete.LoginSaveOption(login.toLoginEntry())
-
-        var geckoResult =
-            promptDelegate.onLoginSave(mock(), GeckoLoginSavePrompt(arrayOf(saveOption)))
-
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        loginSaveRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        geckoResult = promptDelegate.onLoginSave(mock(), GeckoLoginSavePrompt(arrayOf(saveOption)))
-
-        geckoResult!!.accept {
-            onLoginSaved = true
-        }
-
-        loginSaveRequest.onConfirm(login)
-        assertTrue(onLoginSaved)
-
-        onLoginSaved = false
-
-        loginSaveRequest.onConfirm(login)
-
-        assertFalse(onLoginSaved)
-    }
-
-    @Test
-    fun `Calling onLoginSelect must provide an SelectLoginPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onLoginSelected = false
-        var onDismissWasCalled = false
-
-        var loginSelectRequest: PromptRequest.SelectLoginPrompt = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                loginSelectRequest = promptRequest as PromptRequest.SelectLoginPrompt
-            }
-        })
-
-        val login = createLogin()
-        val loginSelectOption = Autocomplete.LoginSelectOption(login.toLoginEntry())
-
-        val secondLogin = createLogin(username = "username2")
-        val secondLoginSelectOption = Autocomplete.LoginSelectOption(secondLogin.toLoginEntry())
-
-        var geckoResult =
-            promptDelegate.onLoginSelect(
-                mock(),
-                GeckoLoginSelectPrompt(arrayOf(loginSelectOption, secondLoginSelectOption))
-            )
-
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        loginSelectRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        geckoResult = promptDelegate.onLoginSelect(
-            mock(),
-            GeckoLoginSelectPrompt(arrayOf(loginSelectOption, secondLoginSelectOption))
-        )
-
-        geckoResult!!.accept {
-            onLoginSelected = true
-        }
-
-        loginSelectRequest.onConfirm(login)
-        assertTrue(onLoginSelected)
-
-        onLoginSelected = false
-        loginSelectRequest.onConfirm(login)
-
-        assertFalse(onLoginSelected)
-    }
-
-    fun createLogin(
-        guid: String = "id",
-        password: String = "password",
-        username: String = "username",
-        origin: String = "https://www.origin.com",
-        httpRealm: String = "httpRealm",
-        formActionOrigin: String = "https://www.origin.com",
-        usernameField: String = "usernameField",
-        passwordField: String = "passwordField"
-    ) = Login(
-        guid = guid,
-        origin = origin,
-        password = password,
-        username = username,
-        httpRealm = httpRealm,
-        formActionOrigin = formActionOrigin,
-        usernameField = usernameField,
-        passwordField = passwordField
-    )
-
-    /**
-     * Converts an Android Components [Login] to a GeckoView [LoginStorage.LoginEntry]
-     */
-    private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-        .guid(guid)
-        .origin(origin)
-        .formActionOrigin(formActionOrigin)
-        .httpRealm(httpRealm)
-        .username(username)
-        .password(password)
-        .build()
-
-    @Test
-    fun `Calling onAuthPrompt must provide an Authentication PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var authRequest: PromptRequest.Authentication = mock()
-        var onConfirmWasCalled = false
-        var onConfirmOnlyPasswordWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                authRequest = promptRequest as PromptRequest.Authentication
-            }
-        })
-
-        var geckoResult =
-            promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = mock()))
-        geckoResult!!.accept {
-            onConfirmWasCalled = true
-        }
-
-        authRequest.onConfirm("", "")
-        assertTrue(onConfirmWasCalled)
-
-        onConfirmWasCalled = false
-        authRequest.onConfirm("", "")
-
-        assertFalse(onConfirmWasCalled)
-
-        geckoResult =
-            promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = mock()))
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        authRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        val authOptions = GeckoAuthOptions()
-        ReflectionUtils.setField(authOptions, "level", GECKO_AUTH_LEVEL.SECURE)
-
-        var flags = 0
-        flags = flags.or(GECKO_AUTH_FLAGS.ONLY_PASSWORD)
-        flags = flags.or(GECKO_AUTH_FLAGS.PREVIOUS_FAILED)
-        flags = flags.or(GECKO_AUTH_FLAGS.CROSS_ORIGIN_SUB_RESOURCE)
-        flags = flags.or(GECKO_AUTH_FLAGS.HOST)
-        ReflectionUtils.setField(authOptions, "flags", flags)
-
-        val geckoPrompt = GeckoAuthPrompt(authOptions = authOptions)
-        geckoResult = promptDelegate.onAuthPrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            val hasPassword = geckoPrompt.getGeckoResult().containsKey("password")
-            val hasUser = geckoPrompt.getGeckoResult().containsKey("username")
-            onConfirmOnlyPasswordWasCalled = hasPassword && hasUser == false
-        }
-
-        authRequest.onConfirm("", "")
-
-        with(authRequest) {
-            assertTrue(onlyShowPassword)
-            assertTrue(previousFailed)
-            assertTrue(isCrossOrigin)
-
-            assertEquals(method, AC_AUTH_METHOD.HOST)
-            assertEquals(level, AC_AUTH_LEVEL.SECURED)
-            assertTrue(onConfirmOnlyPasswordWasCalled)
-        }
-
-        ReflectionUtils.setField(authOptions, "level", GECKO_AUTH_LEVEL.PW_ENCRYPTED)
-
-        promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = authOptions))
-
-        assertEquals(authRequest.level, AC_AUTH_LEVEL.PASSWORD_ENCRYPTED)
-
-        ReflectionUtils.setField(authOptions, "level", -2423)
-
-        promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = authOptions))
-
-        assertEquals(authRequest.level, AC_AUTH_LEVEL.NONE)
-    }
-
-    @Test
-    fun `Calling onColorPrompt must provide a Color PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var colorRequest: PromptRequest.Color = mock()
-        var onConfirmWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                colorRequest = promptRequest as PromptRequest.Color
-            }
-        })
-
-        var geckoResult =
-            promptDelegate.onColorPrompt(mock(), GeckoColorPrompt(defaultValue = "#e66465"))
-        geckoResult!!.accept {
-            onConfirmWasCalled = true
-        }
-
-        with(colorRequest) {
-
-            assertEquals(defaultColor, "#e66465")
-
-            onConfirm("#f6b73c")
-            assertTrue(onConfirmWasCalled)
-
-            onConfirmWasCalled = false
-            onConfirm("#f6b73c")
-
-            assertFalse(onConfirmWasCalled)
-        }
-
-        geckoResult = promptDelegate.onColorPrompt(mock(), GeckoColorPrompt())
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        colorRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        with(colorRequest) {
-            assertEquals(defaultColor, "defaultValue")
-        }
-    }
-
-    @Test
-    fun `onTextPrompt must provide an TextPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.TextPrompt = mock()
-        var dismissWasCalled = false
-        var confirmWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.TextPrompt
-            }
-        })
-
-        var geckoResult = promptDelegate.onTextPrompt(mock(), GeckoTextPrompt())
-        geckoResult!!.accept {
-            dismissWasCalled = true
-        }
-
-        with(request) {
-            assertEquals(title, "title")
-            assertEquals(inputLabel, "message")
-            assertEquals(inputValue, "defaultValue")
-
-            onDismiss()
-            assertTrue(dismissWasCalled)
-        }
-
-        geckoResult = promptDelegate.onTextPrompt(mock(), GeckoTextPrompt())
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        request.onConfirm(true, "newInput")
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(true, "newInput")
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onPopupRequest must provide a Popup PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Popup? = null
-        var onAllowWasCalled = false
-        var onDenyWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Popup
-            }
-        })
-
-        var geckoPrompt = GeckoPopupPrompt(targetUri = "www.popuptest.com/")
-        var geckoResult = promptDelegate.onPopupPrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onAllowWasCalled = geckoPrompt.getGeckoResult()["response"] == true
-        }
-
-        with(request!!) {
-            assertEquals(targetUri, "www.popuptest.com/")
-
-            onAllow()
-            assertTrue(onAllowWasCalled)
-
-            onAllowWasCalled = false
-            onAllow()
-
-            assertFalse(onAllowWasCalled)
-        }
-
-        geckoPrompt = GeckoPopupPrompt()
-        geckoResult = promptDelegate.onPopupPrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onDenyWasCalled = geckoPrompt.getGeckoResult()["response"] == false
-        }
-
-        request!!.onDeny()
-        assertTrue(onDenyWasCalled)
-
-        onDenyWasCalled = false
-        request!!.onDeny()
-
-        assertFalse(onDenyWasCalled)
-    }
-
-    @Test
-    fun `onBeforeUnloadPrompt must provide a BeforeUnload PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.BeforeUnload? = null
-        var onAllowWasCalled = false
-        var onDenyWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.BeforeUnload
-            }
-        })
-
-        var geckoPrompt = GeckoBeforeUnloadPrompt()
-        var geckoResult = promptDelegate.onBeforeUnloadPrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            onAllowWasCalled = geckoPrompt.getGeckoResult()["allow"] == true
-        }
-
-        with(request!!) {
-            assertEquals(title, "")
-
-            onLeave()
-            assertTrue(onAllowWasCalled)
-
-            onAllowWasCalled = false
-            onLeave()
-
-            assertFalse(onAllowWasCalled)
-        }
-
-        geckoPrompt = GeckoBeforeUnloadPrompt()
-        geckoResult = promptDelegate.onBeforeUnloadPrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onDenyWasCalled = geckoPrompt.getGeckoResult()["allow"] == false
-        }
-
-        request!!.onStay()
-        assertTrue(onDenyWasCalled)
-
-        onDenyWasCalled = false
-        request!!.onStay()
-
-        assertFalse(onDenyWasCalled)
-    }
-
-    @Test
-    fun `onBeforeUnloadPrompt will inform listeners when if navigation is cancelled`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onBeforeUnloadPromptCancelledCalled = false
-        var request: PromptRequest.BeforeUnload = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.BeforeUnload
-            }
-
-            override fun onBeforeUnloadPromptDenied() {
-                onBeforeUnloadPromptCancelledCalled = true
-            }
-        })
-        val prompt = mock<GeckoBeforeUnloadPrompt>()
-        doReturn(false).`when`(prompt).isComplete
-
-        GeckoPromptDelegate(mockSession).onBeforeUnloadPrompt(mock(), prompt)
-        request.onStay()
-
-        assertTrue(onBeforeUnloadPromptCancelledCalled)
-    }
-
-    @Test
-    fun `onSharePrompt must provide a Share PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Share? = null
-        var onSuccessWasCalled = false
-        var onFailureWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Share
-            }
-        })
-
-        var geckoPrompt = GeckoSharePrompt()
-        var geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onSuccessWasCalled = true
-        }
-
-        with(request!!) {
-            assertEquals(data.title, "title")
-            assertEquals(data.text, "text")
-            assertEquals(data.url, "https://example.com")
-
-            onSuccess()
-            assertTrue(onSuccessWasCalled)
-
-            onSuccessWasCalled = false
-            onSuccess()
-
-            assertFalse(onSuccessWasCalled)
-        }
-
-        geckoPrompt = GeckoSharePrompt()
-        geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onFailureWasCalled = true
-        }
-
-        request!!.onFailure()
-        assertTrue(onFailureWasCalled)
-
-        onFailureWasCalled = false
-        request!!.onFailure()
-
-        assertFalse(onFailureWasCalled)
-
-        geckoPrompt = GeckoSharePrompt()
-        geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onDismissWasCalled = true
-        }
-
-        request!!.onDismiss()
-        assertTrue(onDismissWasCalled)
-    }
-
-    @Test
-    fun `onButtonPrompt must provide a Confirm PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Confirm = mock()
-        var onPositiveButtonWasCalled = false
-        var onNegativeButtonWasCalled = false
-        var onNeutralButtonWasCalled = false
-        var dismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Confirm
-            }
-        })
-
-        var geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onPositiveButtonWasCalled = true
-        }
-
-        with(request) {
-
-            assertNotNull(request)
-            assertEquals(title, "title")
-            assertEquals(message, "message")
-
-            onConfirmPositiveButton(false)
-            assertTrue(onPositiveButtonWasCalled)
-
-            onPositiveButtonWasCalled = false
-            onConfirmPositiveButton(false)
-
-            assertFalse(onPositiveButtonWasCalled)
-        }
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onNeutralButtonWasCalled = true
-        }
-
-        request.onConfirmNeutralButton(false)
-        assertTrue(onNeutralButtonWasCalled)
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onNegativeButtonWasCalled = true
-        }
-
-        request.onConfirmNegativeButton(false)
-        assertTrue(onNegativeButtonWasCalled)
-
-        onNegativeButtonWasCalled = false
-        request.onConfirmNegativeButton(false)
-
-        assertFalse(onNegativeButtonWasCalled)
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            dismissWasCalled = true
-        }
-
-        request.onDismiss()
-        assertTrue(dismissWasCalled)
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt must provide a Repost PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Repost = mock()
-        var onPositiveButtonWasCalled = false
-        var onNegativeButtonWasCalled = false
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-        })
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        var geckoResult = promptDelegate.onRepostConfirmPrompt(mock(), GeckoRepostPrompt())
-        geckoResult!!.accept {
-            onPositiveButtonWasCalled = true
-        }
-        request.onConfirm()
-        assertTrue(onPositiveButtonWasCalled)
-
-        onPositiveButtonWasCalled = false
-        request.onConfirm()
-
-        assertFalse(onPositiveButtonWasCalled)
-
-        geckoResult = promptDelegate.onRepostConfirmPrompt(mock(), GeckoRepostPrompt())
-        geckoResult!!.accept {
-            onNegativeButtonWasCalled = true
-        }
-        request.onDismiss()
-        assertTrue(onNegativeButtonWasCalled)
-
-        onNegativeButtonWasCalled = false
-        request.onDismiss()
-
-        assertFalse(onNegativeButtonWasCalled)
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt will not be able to complete multiple times`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Repost = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-        })
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        var prompt = mock<GeckoRepostPrompt>()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(false).`when`(prompt).isComplete
-        request.onConfirm()
-        verify(prompt).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(true).`when`(prompt).isComplete
-        request.onConfirm()
-        verify(prompt, never()).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(false).`when`(prompt).isComplete
-        request.onDismiss()
-        verify(prompt).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(true).`when`(prompt).isComplete
-        request.onDismiss()
-        verify(prompt, never()).confirm(any())
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt will inform listeners when it is being dismissed`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onRepostPromptCancelledCalled = false
-        var request: PromptRequest.Repost = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-
-            override fun onRepostPromptCancelled() {
-                onRepostPromptCancelledCalled = true
-            }
-        })
-        val prompt = mock<GeckoRepostPrompt>()
-        doReturn(false).`when`(prompt).isComplete
-
-        GeckoPromptDelegate(mockSession).onRepostConfirmPrompt(mock(), prompt)
-        request.onDismiss()
-
-        assertTrue(onRepostPromptCancelledCalled)
-    }
-
-    @Test
-    fun `dismissSafely only dismiss if the prompt is NOT already dismissed`() {
-        val prompt = spy(GeckoAlertPrompt())
-        val geckoResult = mock<GeckoResult<GeckoSession.PromptDelegate.PromptResponse>>()
-
-        doReturn(false).`when`(prompt).isComplete
-
-        prompt.dismissSafely(geckoResult)
-
-        verify(geckoResult).complete(any())
-    }
-
-    @Test
-    fun `dismissSafely do nothing if the prompt is already dismissed`() {
-        val prompt = spy(GeckoAlertPrompt())
-        val geckoResult = mock<GeckoResult<GeckoSession.PromptDelegate.PromptResponse>>()
-
-        doReturn(true).`when`(prompt).isComplete
-
-        prompt.dismissSafely(geckoResult)
-
-        verify(geckoResult, never()).complete(any())
-    }
-
-    class GeckoChoicePrompt(
-        title: String,
-        message: String,
-        type: Int,
-        choices: Array<out GeckoChoice>
-    ) : GeckoSession.PromptDelegate.ChoicePrompt(title, message, type, choices)
-
-    class GeckoAlertPrompt(title: String = "title", message: String = "message") :
-        GeckoSession.PromptDelegate.AlertPrompt(title, message)
-
-    class GeckoDateTimePrompt(
-        title: String = "title",
-        type: Int,
-        defaultValue: String = "",
-        minValue: String = "",
-        maxValue: String = ""
-    ) : GeckoSession.PromptDelegate.DateTimePrompt(title, type, defaultValue, minValue, maxValue)
-
-    class GeckoFilePrompt(
-        title: String = "title",
-        type: Int,
-        capture: Int = 0,
-        mimeTypes: Array<out String> = emptyArray()
-    ) : GeckoSession.PromptDelegate.FilePrompt(title, type, capture, mimeTypes)
-
-    class GeckoAuthPrompt(
-        title: String = "title",
-        message: String = "message",
-        authOptions: AuthOptions
-    ) : GeckoSession.PromptDelegate.AuthPrompt(title, message, authOptions)
-
-    class GeckoColorPrompt(
-        title: String = "title",
-        defaultValue: String = "defaultValue"
-    ) : GeckoSession.PromptDelegate.ColorPrompt(title, defaultValue)
-
-    class GeckoTextPrompt(
-        title: String = "title",
-        message: String = "message",
-        defaultValue: String = "defaultValue"
-    ) : GeckoSession.PromptDelegate.TextPrompt(title, message, defaultValue)
-
-    class GeckoPopupPrompt(
-        targetUri: String = "targetUri"
-    ) : GeckoSession.PromptDelegate.PopupPrompt(targetUri)
-
-    class GeckoBeforeUnloadPrompt : GeckoSession.PromptDelegate.BeforeUnloadPrompt()
-
-    class GeckoSharePrompt(
-        title: String? = "title",
-        text: String? = "text",
-        url: String? = "https://example.com"
-    ) : GeckoSession.PromptDelegate.SharePrompt(title, text, url)
-
-    class GeckoPromptPrompt(
-        title: String = "title",
-        message: String = "message"
-    ) : GeckoSession.PromptDelegate.ButtonPrompt(title, message)
-
-    class GeckoLoginSelectPrompt(
-        loginArray: Array<Autocomplete.LoginSelectOption>
-    ) : GeckoSession.PromptDelegate.AutocompleteRequest<Autocomplete.LoginSelectOption>(loginArray)
-
-    class GeckoLoginSavePrompt(
-        login: Array<Autocomplete.LoginSaveOption>
-    ) : GeckoSession.PromptDelegate.AutocompleteRequest<Autocomplete.LoginSaveOption>(login)
-
-    class GeckoAuthOptions : GeckoSession.PromptDelegate.AuthPrompt.AuthOptions()
-
-    class GeckoRepostPrompt : GeckoSession.PromptDelegate.RepostConfirmPrompt()
-
-    private fun GeckoSession.PromptDelegate.BasePrompt.getGeckoResult(): GeckoBundle {
-        val javaClass = GeckoSession.PromptDelegate.BasePrompt::class.java
-        val method = javaClass.getDeclaredMethod("ensureResult")
-        method.isAccessible = true
-        return (method.invoke(this) as GeckoBundle)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt
deleted file mode 100644
index 9d73baae3c74..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt
+++ /dev/null
@@ -1,92 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.selection
-
-import android.app.Activity
-import android.app.Application
-import android.app.Service
-import android.view.MenuItem
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import mozilla.components.support.test.mock
-import org.junit.Assert
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Test
-
-class GeckoSelectionActionDelegateTest {
-
-    @Test
-    fun `maybe create with non-activity context should return null`() {
-        val customDelegate = mock<SelectionActionDelegate>()
-
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Application>(), customDelegate))
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Service>(), customDelegate))
-    }
-
-    @Test
-    fun `maybe create with null delegate context should return null`() {
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Activity>(), null))
-    }
-
-    @Test
-    fun `maybe create with expected inputs should return non-null`() {
-        assertNotNull(GeckoSelectionActionDelegate.maybeCreate(mock<Activity>(), mock()))
-    }
-
-    @Test
-    fun `getAllActions should contain all actions from the custom delegate`() {
-        val customActions = arrayOf("1", "2", "3")
-        val customDelegate = object : SelectionActionDelegate {
-            override fun getAllActions(): Array<String> = customActions
-            override fun isActionAvailable(id: String, selectedText: String): Boolean = false
-            override fun getActionTitle(id: String): CharSequence? = ""
-            override fun performAction(id: String, selectedText: String): Boolean = false
-            override fun sortedActions(actions: Array<String>): Array<String> {
-                return actions
-            }
-        }
-
-        val geckoDelegate = TestGeckoSelectionActionDelegate(mock(), customDelegate)
-
-        val actualActions = geckoDelegate.allActions
-
-        customActions.forEach {
-            Assert.assertTrue(actualActions.contains(it))
-        }
-    }
-
-    @Test
-    fun `WHEN perform action triggers a security exception THEN false is returned`() {
-        val customActions = arrayOf("1", "2", "3")
-        val customDelegate = object : SelectionActionDelegate {
-            override fun getAllActions(): Array<String> = customActions
-            override fun isActionAvailable(id: String, selectedText: String): Boolean = false
-            override fun getActionTitle(id: String): CharSequence? = ""
-            override fun performAction(id: String, selectedText: String): Boolean {
-                throw SecurityException("test")
-            }
-            override fun sortedActions(actions: Array<String>): Array<String> {
-                return actions
-            }
-        }
-
-        val geckoDelegate = TestGeckoSelectionActionDelegate(mock(), customDelegate)
-        assertFalse(geckoDelegate.performAction("test", mock()))
-    }
-}
-
-/**
- * Test object that overrides visibility for [getAllActions]
- */
-class TestGeckoSelectionActionDelegate(
-    activity: Activity,
-    customDelegate: SelectionActionDelegate
-) : GeckoSelectionActionDelegate(activity, customDelegate) {
-    public override fun getAllActions() = super.getAllActions()
-    public override fun performAction(id: String, item: MenuItem): Boolean {
-        return super.performAction(id, item)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt
deleted file mode 100644
index e660a3761ff9..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.util
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNotSame
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mozilla.geckoview.GeckoRuntime
-
-@RunWith(AndroidJUnit4::class)
-class SpeculativeSessionFactoryTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `create does nothing if matching speculative session already exists`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertSame(speculativeSession, factory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `create clears previous non-matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        factory.create(runtime = runtime, private = false, contextId = null, defaultSettings = mock())
-        assertNotSame(speculativeSession, factory.speculativeEngineSession)
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `get consumes matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertFalse(factory.hasSpeculativeSession())
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-
-        val speculativeSession = factory.get(private = true, contextId = null)
-        assertNotNull(speculativeSession)
-        assertFalse(speculativeSession!!.isObserved())
-
-        assertFalse(factory.hasSpeculativeSession())
-        assertNull(factory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `get clears previous non-matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        assertNull(factory.get(private = true, contextId = "test"))
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clears speculative session on crash`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-
-        factory.speculativeEngineSession?.engineSession?.notifyObservers { onCrash() }
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clears speculative session when process is killed`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-
-        factory.speculativeEngineSession?.engineSession?.notifyObservers { onProcessKilled() }
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clear unregisters observer and closes session`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-        assertTrue(speculativeSession!!.engineSession.isObserved())
-
-        factory.clear()
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt
deleted file mode 100644
index 0b9c7d5c1595..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt
+++ /dev/null
@@ -1,603 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.DisabledFlags
-import mozilla.components.concept.engine.webextension.MessageHandler
-import mozilla.components.concept.engine.webextension.Port
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.never
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.MockCreateTabDetails
-import org.mozilla.geckoview.MockUpdateTabDetails
-import org.mozilla.geckoview.MockWebExtension
-import org.mozilla.geckoview.WebExtension
-import org.mozilla.geckoview.WebExtensionController
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebExtensionTest {
-
-    @Test
-    fun `register background message handler`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val portCaptor = argumentCaptor<Port>()
-        val portDelegateCaptor = argumentCaptor<WebExtension.PortDelegate>()
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-
-        extension.registerBackgroundMessageHandler("mozacTest", messageHandler)
-        verify(nativeGeckoWebExt).setMessageDelegate(messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Verify messages are forwarded to message handler
-        val message: Any = mock()
-        val sender: WebExtension.MessageSender = mock()
-        whenever(messageHandler.onMessage(eq(message), eq(null))).thenReturn("result")
-        assertNotNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler).onMessage(eq(message), eq(null))
-
-        whenever(messageHandler.onMessage(eq(message), eq(null))).thenReturn(null)
-        assertNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler, times(2)).onMessage(eq(message), eq(null))
-
-        // Verify port is connected and forwarded to message handler
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        verify(messageHandler).onPortConnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertNotNull(extension.getConnectedPort("mozacTest"))
-        assertSame(port, (extension.getConnectedPort("mozacTest") as GeckoPort).nativePort)
-
-        // Verify port messages are forwarded to message handler
-        verify(port).setDelegate(portDelegateCaptor.capture())
-        val portDelegate = portDelegateCaptor.value
-        val portMessage: JSONObject = mock()
-        portDelegate.onPortMessage(portMessage, port)
-        verify(messageHandler).onPortMessage(eq(portMessage), portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-
-        // Verify disconnected port is forwarded to message handler if connected
-        portDelegate.onDisconnect(mock())
-        verify(messageHandler, never()).onPortDisconnected(portCaptor.capture())
-
-        portDelegate.onDisconnect(port)
-        verify(messageHandler).onPortDisconnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertNull(extension.getConnectedPort("mozacTest"))
-    }
-
-    @Test
-    fun `register content message handler`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val portCaptor = argumentCaptor<Port>()
-        val portDelegateCaptor = argumentCaptor<WebExtension.PortDelegate>()
-
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        assertFalse(extension.hasContentMessageHandler(session, "mozacTest"))
-        extension.registerContentMessageHandler(session, "mozacTest", messageHandler)
-        verify(webExtensionSessionController).setMessageDelegate(eq(nativeGeckoWebExt), messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Verify messages are forwarded to message handler and return value passed on
-        val message: Any = mock()
-        val sender: WebExtension.MessageSender = mock()
-        whenever(messageHandler.onMessage(eq(message), eq(session))).thenReturn("result")
-        assertNotNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler).onMessage(eq(message), eq(session))
-
-        whenever(messageHandler.onMessage(eq(message), eq(session))).thenReturn(null)
-        assertNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler, times(2)).onMessage(eq(message), eq(session))
-
-        // Verify port is connected and forwarded to message handler
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        verify(messageHandler).onPortConnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-        assertNotNull(extension.getConnectedPort("mozacTest", session))
-        assertSame(port, (extension.getConnectedPort("mozacTest", session) as GeckoPort).nativePort)
-
-        // Verify port messages are forwarded to message handler
-        verify(port).setDelegate(portDelegateCaptor.capture())
-        val portDelegate = portDelegateCaptor.value
-        val portMessage: JSONObject = mock()
-        portDelegate.onPortMessage(portMessage, port)
-        verify(messageHandler).onPortMessage(eq(portMessage), portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-
-        // Verify disconnected port is forwarded to message handler if connected
-        portDelegate.onDisconnect(mock())
-        verify(messageHandler, never()).onPortDisconnected(portCaptor.capture())
-
-        portDelegate.onDisconnect(port)
-        verify(messageHandler).onPortDisconnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-        assertNull(extension.getConnectedPort("mozacTest", session))
-    }
-
-    @Test
-    fun `disconnect port from content script`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerContentMessageHandler(session, "mozacTest", messageHandler)
-        verify(webExtensionSessionController).setMessageDelegate(eq(nativeGeckoWebExt), messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Connect port
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        assertNotNull(extension.getConnectedPort("mozacTest", session))
-
-        // Disconnect port
-        extension.disconnectPort("mozacTest", session)
-        verify(port).disconnect()
-        assertNull(extension.getConnectedPort("mozacTest", session))
-    }
-
-    @Test
-    fun `disconnect port from background script`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerBackgroundMessageHandler("mozacTest", messageHandler)
-
-        verify(nativeGeckoWebExt).setMessageDelegate(messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Connect port
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        assertNotNull(extension.getConnectedPort("mozacTest"))
-
-        // Disconnect port
-        extension.disconnectPort("mozacTest")
-        verify(port).disconnect()
-        assertNull(extension.getConnectedPort("mozacTest"))
-    }
-
-    @Test
-    fun `register global default action handler`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val actionHandler: ActionHandler = mock()
-        val actionDelegateCaptor = argumentCaptor<WebExtension.ActionDelegate>()
-        val browserActionCaptor = argumentCaptor<Action>()
-        val pageActionCaptor = argumentCaptor<Action>()
-        val nativeBrowserAction: WebExtension.Action = mock()
-        val nativePageAction: WebExtension.Action = mock()
-
-        // Create extension and register global default action handler
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerActionHandler(actionHandler)
-        verify(nativeGeckoWebExt).setActionDelegate(actionDelegateCaptor.capture())
-
-        // Verify that browser actions are forwarded to the handler
-        actionDelegateCaptor.value.onBrowserAction(nativeGeckoWebExt, null, nativeBrowserAction)
-        verify(actionHandler).onBrowserAction(eq(extension), eq(null), browserActionCaptor.capture())
-
-        // Verify that page actions are forwarded to the handler
-        actionDelegateCaptor.value.onPageAction(nativeGeckoWebExt, null, nativePageAction)
-        verify(actionHandler).onPageAction(eq(extension), eq(null), pageActionCaptor.capture())
-
-        // Verify that toggle popup is forwarded to the handler
-        actionDelegateCaptor.value.onTogglePopup(nativeGeckoWebExt, nativeBrowserAction)
-        verify(actionHandler).onToggleActionPopup(eq(extension), any())
-
-        // We don't have access to the native WebExtension.Action fields and
-        // can't mock them either, but we can verify that we've linked
-        // the actions by simulating a click.
-        browserActionCaptor.value.onClick()
-        verify(nativeBrowserAction).click()
-        pageActionCaptor.value.onClick()
-        verify(nativePageAction).click()
-    }
-
-    @Test
-    fun `register session-specific action handler`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val actionHandler: ActionHandler = mock()
-        val actionDelegateCaptor = argumentCaptor<WebExtension.ActionDelegate>()
-        val browserActionCaptor = argumentCaptor<Action>()
-        val pageActionCaptor = argumentCaptor<Action>()
-        val nativeBrowserAction: WebExtension.Action = mock()
-        val nativePageAction: WebExtension.Action = mock()
-
-        // Create extension and register action handler for session
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerActionHandler(session, actionHandler)
-        verify(webExtensionSessionController).setActionDelegate(eq(nativeGeckoWebExt), actionDelegateCaptor.capture())
-
-        whenever(webExtensionSessionController.getActionDelegate(nativeGeckoWebExt)).thenReturn(actionDelegateCaptor.value)
-        assertTrue(extension.hasActionHandler(session))
-
-        // Verify that browser actions are forwarded to the handler
-        actionDelegateCaptor.value.onBrowserAction(nativeGeckoWebExt, null, nativeBrowserAction)
-        verify(actionHandler).onBrowserAction(eq(extension), eq(session), browserActionCaptor.capture())
-
-        // Verify that page actions are forwarded to the handler
-        actionDelegateCaptor.value.onPageAction(nativeGeckoWebExt, null, nativePageAction)
-        verify(actionHandler).onPageAction(eq(extension), eq(session), pageActionCaptor.capture())
-
-        // We don't have access to the native WebExtension.Action fields and
-        // can't mock them either, but we can verify that we've linked
-        // the actions by simulating a click.
-        browserActionCaptor.value.onClick()
-        verify(nativeBrowserAction).click()
-        pageActionCaptor.value.onClick()
-        verify(nativePageAction).click()
-    }
-
-    @Test
-    fun `register global tab handler`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val tabHandler: TabHandler = mock()
-        val tabDelegateCaptor = argumentCaptor<WebExtension.TabDelegate>()
-        val engineSessionCaptor = argumentCaptor<GeckoEngineSession>()
-        var metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putString("optionsPageUrl", "optionsPageUrl")
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension(bundle)
-
-        // Create extension and register global tab handler
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        val defaultSettings: DefaultSettings = mock()
-
-        extension.registerTabHandler(tabHandler, defaultSettings)
-        verify(nativeGeckoWebExt).tabDelegate = tabDelegateCaptor.capture()
-
-        // Verify that tab methods are forwarded to the handler
-        val tabBundle = GeckoBundle()
-        tabBundle.putBoolean("active", true)
-        tabBundle.putString("url", "url")
-        val tabDetails = MockCreateTabDetails(tabBundle)
-        tabDelegateCaptor.value.onNewTab(nativeGeckoWebExt, tabDetails)
-        verify(tabHandler).onNewTab(eq(extension), engineSessionCaptor.capture(), eq(true), eq("url"))
-        assertNotNull(engineSessionCaptor.value)
-
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExt)
-        verify(tabHandler, never()).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-
-        metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeGeckoWebExtWithMetadata = MockWebExtension(bundle)
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExtWithMetadata)
-        verify(tabHandler, never()).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-
-        metaDataBundle.putString("optionsPageURL", "http://options-page.moz")
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeGeckoWebExtWithOptionsPageUrl = MockWebExtension(bundle)
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExtWithOptionsPageUrl)
-        verify(tabHandler).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-    }
-
-    @Test
-    fun `register session-specific tab handler`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val tabHandler: TabHandler = mock()
-        val tabDelegateCaptor = argumentCaptor<WebExtension.SessionTabDelegate>()
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        // Create extension and register tab handler for session
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerTabHandler(session, tabHandler)
-        verify(webExtensionSessionController).setTabDelegate(eq(nativeGeckoWebExt), tabDelegateCaptor.capture())
-
-        assertFalse(extension.hasTabHandler(session))
-        whenever(webExtensionSessionController.getTabDelegate(nativeGeckoWebExt)).thenReturn(tabDelegateCaptor.value)
-        assertTrue(extension.hasTabHandler(session))
-
-        // Verify that tab methods are forwarded to the handler
-        val tabBundle = GeckoBundle()
-        tabBundle.putBoolean("active", true)
-        val tabDetails = MockUpdateTabDetails(tabBundle)
-        tabDelegateCaptor.value.onUpdateTab(nativeGeckoWebExt, mock(), tabDetails)
-        verify(tabHandler).onUpdateTab(eq(extension), eq(session), eq(true), eq(null))
-
-        tabDelegateCaptor.value.onCloseTab(nativeGeckoWebExt, mock())
-        verify(tabHandler).onCloseTab(eq(extension), eq(session))
-    }
-
-    @Test
-    fun `all metadata fields are mapped correctly`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("promptPermissions", arrayOf("p1", "p2"))
-        metaDataBundle.putStringArray("origins", arrayOf("o1", "o2"))
-        metaDataBundle.putString("description", "desc")
-        metaDataBundle.putString("version", "1.0")
-        metaDataBundle.putString("creatorName", "developer1")
-        metaDataBundle.putString("creatorURL", "https://developer1.dev")
-        metaDataBundle.putString("homepageURL", "https://mozilla.org")
-        metaDataBundle.putString("name", "myextension")
-        metaDataBundle.putString("optionsPageURL", "http://options-page.moz")
-        metaDataBundle.putString("baseURL", "moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/")
-        metaDataBundle.putBoolean("openOptionsPageInTab", false)
-        metaDataBundle.putStringArray("disabledFlags", arrayOf("userDisabled"))
-        metaDataBundle.putBoolean("temporary", true)
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeWebExtension = MockWebExtension(bundle)
-        val extensionWithMetadata = GeckoWebExtension(nativeWebExtension, runtime)
-        val metadata = extensionWithMetadata.getMetadata()
-        assertNotNull(metadata!!)
-        assertEquals("1.0", metadata.version)
-        assertEquals(listOf("p1", "p2"), metadata.permissions)
-        assertEquals(listOf("o1", "o2"), metadata.hostPermissions)
-        assertEquals("desc", metadata.description)
-        assertEquals("developer1", metadata.developerName)
-        assertEquals("https://developer1.dev", metadata.developerUrl)
-        assertEquals("https://mozilla.org", metadata.homePageUrl)
-        assertEquals("myextension", metadata.name)
-        assertEquals("http://options-page.moz", metadata.optionsPageUrl)
-        assertEquals("moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/", metadata.baseUrl)
-        assertFalse(metadata.openOptionsPageInTab)
-        assertTrue(metadata.temporary)
-        assertTrue(metadata.disabledFlags.contains(DisabledFlags.USER))
-        assertFalse(metadata.disabledFlags.contains(DisabledFlags.BLOCKLIST))
-        assertFalse(metadata.disabledFlags.contains(DisabledFlags.APP_SUPPORT))
-    }
-
-    @Test
-    fun `nullable metadata fields`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("promptPermissions", arrayOf("p1", "p2"))
-        metaDataBundle.putString("version", "1.0")
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putString("baseURL", "moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeWebExtension = MockWebExtension(bundle)
-        val extensionWithMetadata = GeckoWebExtension(nativeWebExtension, runtime)
-        val metadata = extensionWithMetadata.getMetadata()
-        assertNotNull(metadata!!)
-        assertEquals("1.0", metadata.version)
-        assertEquals(listOf("p1", "p2"), metadata.permissions)
-        assertEquals(emptyList<String>(), metadata.hostPermissions)
-        assertEquals("moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/", metadata.baseUrl)
-        assertNull(metadata.description)
-        assertNull(metadata.developerName)
-        assertNull(metadata.developerUrl)
-        assertNull(metadata.homePageUrl)
-        assertNull(metadata.name)
-        assertNull(metadata.optionsPageUrl)
-    }
-
-    @Test
-    fun `isBuiltIn depends on native state`() {
-        val runtime: GeckoRuntime = mock()
-
-        val builtInBundle = GeckoBundle()
-        builtInBundle.putBoolean("isBuiltIn", true)
-        builtInBundle.putString("webExtensionId", "id")
-        builtInBundle.putString("locationURI", "uri")
-        val builtInExtension = GeckoWebExtension(
-            mockNativeExtension(builtInBundle),
-            runtime
-        )
-        assertTrue(builtInExtension.isBuiltIn())
-
-        val externalBundle = GeckoBundle()
-        externalBundle.putBoolean("isBuiltIn", false)
-        externalBundle.putString("webExtensionId", "id")
-        externalBundle.putString("locationURI", "uri")
-        val externalExtension = GeckoWebExtension(
-            mockNativeExtension(externalBundle),
-            runtime
-        )
-        assertFalse(externalExtension.isBuiltIn())
-    }
-
-    @Test
-    fun `isEnabled depends on native state and defaults to true if state unknown`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putBoolean("enabled", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeEnabledWebExtension = MockWebExtension(bundle)
-        val enabledWebExtension = GeckoWebExtension(nativeEnabledWebExtension, runtime)
-        assertTrue(enabledWebExtension.isEnabled())
-
-        metaDataBundle.putBoolean("enabled", false)
-        metaDataBundle.putStringArray("disabledFlags", arrayOf("userDisabled"))
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeDisabledWebExtnesion = MockWebExtension(bundle)
-        val disabledWebExtension = GeckoWebExtension(nativeDisabledWebExtnesion, runtime)
-        assertFalse(disabledWebExtension.isEnabled())
-    }
-
-    @Test
-    fun `isAllowedInPrivateBrowsing depends on native state and defaults to false if state unknown`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-
-        val builtInBundle = GeckoBundle()
-        builtInBundle.putBoolean("isBuiltIn", true)
-        builtInBundle.putString("webExtensionId", "id")
-        builtInBundle.putString("locationURI", "uri")
-        builtInBundle.putBoolean("privateBrowsingAllowed", false)
-
-        val builtInExtension = GeckoWebExtension(
-            mockNativeExtension(builtInBundle),
-            runtime
-        )
-        assertTrue(builtInExtension.isAllowedInPrivateBrowsing())
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putBoolean("privateBrowsingAllowed", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithPrivateBrowsing = MockWebExtension(bundle)
-        val webExtensionWithPrivateBrowsing = GeckoWebExtension(nativeWebExtensionWithPrivateBrowsing, runtime)
-        assertTrue(webExtensionWithPrivateBrowsing.isAllowedInPrivateBrowsing())
-
-        metaDataBundle.putBoolean("privateBrowsingAllowed", false)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithoutPrivateBrowsing = MockWebExtension(bundle)
-        val webExtensionWithoutPrivateBrowsing = GeckoWebExtension(nativeWebExtensionWithoutPrivateBrowsing, runtime)
-        assertFalse(webExtensionWithoutPrivateBrowsing.isAllowedInPrivateBrowsing())
-    }
-
-    @Test
-    fun `loadIcon tries to load icon from metadata`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        val emptyIconBundle = GeckoBundle()
-        metaDataBundle.putBoolean("enabled", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putBundle("icons", emptyIconBundle)
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithoutIcon = MockWebExtension(bundle)
-        val webExtensionWithoutIcon = GeckoWebExtension(nativeWebExtensionWithoutIcon, runtime)
-
-        var iconLoadComplete = false
-        var result = webExtensionWithoutIcon.getIcon(48)
-        assertNotNull(result)
-        result.accept { iconLoadComplete = true }
-        assertTrue(iconLoadComplete)
-
-        iconLoadComplete = false
-        val iconBundle = GeckoBundle()
-        iconBundle.putString("48", "test")
-        metaDataBundle.putBundle("icons", iconBundle)
-        val nativeWebExtensionWithIcon = MockWebExtension(bundle)
-        val webExtensionWithIcon = GeckoWebExtension(nativeWebExtensionWithIcon, runtime)
-
-        result = webExtensionWithIcon.getIcon(48)
-        assertNotNull(result)
-        result.accept { iconLoadComplete = true }
-        assertFalse(iconLoadComplete)
-    }
-
-    private fun mockNativeExtension(useBundle: GeckoBundle? = null): WebExtension {
-        val bundle = useBundle ?: GeckoBundle().apply {
-            putString("webExtensionId", "id")
-            putString("locationURI", "uri")
-        }
-        return spy(MockWebExtension(bundle))
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt
deleted file mode 100644
index d47ff20ec86a..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt
+++ /dev/null
@@ -1,118 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webnotifications
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.webnotifications.WebNotification
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.MockWebNotification
-import org.mozilla.geckoview.WebNotification as GeckoViewWebNotification
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebNotificationDelegateTest {
-
-    @Test
-    fun `onShowNotification is forwarded to delegate`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = "source"
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onShowNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onShowNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-        assertFalse(notification.triggeredByWebExtension)
-    }
-
-    @Test
-    fun `onCloseNotification is forwarded to delegate`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = "source"
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onCloseNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onCloseNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-    }
-
-    @Test
-    fun `notification without a source are from web extensions`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = ""
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onShowNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onShowNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-        assertTrue(notification.triggeredByWebExtension)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt
deleted file mode 100644
index 446e9184e801..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt
+++ /dev/null
@@ -1,154 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushSubscription
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.isNull
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoResult
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebPushDelegateTest {
-
-    @Test
-    fun `delegate is always invoked`() {
-        val delegate: WebPushDelegate = mock()
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-
-        geckoDelegate.onGetSubscription("test")
-
-        verify(delegate).onGetSubscription(eq("test"), any())
-
-        geckoDelegate.onSubscribe("test", null)
-
-        verify(delegate).onSubscribe(eq("test"), isNull(), any())
-
-        geckoDelegate.onSubscribe("test", "key".toByteArray())
-
-        verify(delegate).onSubscribe(eq("test"), eq("key".toByteArray()), any())
-
-        geckoDelegate.onUnsubscribe("test")
-
-        verify(delegate).onUnsubscribe(eq("test"), any())
-    }
-
-    @Test
-    fun `onGetSubscription result is completed`() {
-        var subscription: WebPushSubscription? = WebPushSubscription(
-            "test",
-            "https://example.com",
-            null,
-            ByteArray(65),
-            ByteArray(16)
-        )
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onGetSubscription(
-                scope: String,
-                onSubscription: (WebPushSubscription?) -> Unit
-            ) {
-                onSubscription(subscription)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onGetSubscription("test")
-
-        result?.accept { sub ->
-            assert(sub!!.scope == subscription!!.scope)
-        }
-
-        subscription = null
-
-        val nullResult = geckoDelegate.onGetSubscription("test")
-
-        nullResult?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onSubscribe result is completed`() {
-        var subscription: WebPushSubscription? = WebPushSubscription(
-            "test",
-            "https://example.com",
-            null,
-            ByteArray(65),
-            ByteArray(16)
-        )
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onSubscribe(
-                scope: String,
-                serverKey: ByteArray?,
-                onSubscribe: (WebPushSubscription?) -> Unit
-            ) {
-                onSubscribe(subscription)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onSubscribe("test", null)
-
-        result?.accept { sub ->
-            assert(sub!!.scope == subscription!!.scope)
-            assertNull(sub.appServerKey)
-        }
-
-        subscription = null
-
-        val nullResult = geckoDelegate.onSubscribe("test", null)
-        nullResult?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onUnsubscribe result is completed successfully`() {
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onUnsubscribe(
-                scope: String,
-                onUnsubscribe: (Boolean) -> Unit
-            ) {
-                onUnsubscribe(true)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onUnsubscribe("test")
-
-        result?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onUnsubscribe result receives throwable when unsuccessful`() {
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onUnsubscribe(
-                scope: String,
-                onUnsubscribe: (Boolean) -> Unit
-            ) {
-                onUnsubscribe(false)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-
-        val result = geckoDelegate.onUnsubscribe("test")
-
-        result?.exceptionally<Void> { throwable ->
-            assertTrue(throwable.localizedMessage == "Un-subscribing from subscription failed.")
-            GeckoResult.fromValue(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt
deleted file mode 100644
index 4fc5d0d08046..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.`when`
-import org.mockito.Mockito.isNull
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.WebPushController
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebPushHandlerTest {
-
-    lateinit var runtime: GeckoRuntime
-    lateinit var controller: WebPushController
-
-    @Before
-    fun setup() {
-        controller = mock()
-        runtime = mock()
-        `when`(runtime.webPushController).thenReturn(controller)
-    }
-
-    @Test
-    fun `runtime controller is invoked`() {
-        val handler = GeckoWebPushHandler(runtime)
-
-        handler.onPushMessage("", null)
-        verify(controller).onPushEvent(any(), isNull())
-
-        handler.onSubscriptionChanged("test")
-        verify(controller).onSubscriptionChanged(eq("test"))
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt
deleted file mode 100644
index db2007204314..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.window
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Test
-import org.junit.runner.RunWith
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWindowRequestTest {
-
-    @Test
-    fun testPrepare() {
-        val engineSession: GeckoEngineSession = mock()
-        val windowRequest = GeckoWindowRequest("mozilla.org", engineSession)
-        assertEquals(engineSession, windowRequest.prepare())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/test/ReflectionUtils.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/test/ReflectionUtils.kt
deleted file mode 100644
index 3186862e2524..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/mozilla/components/test/ReflectionUtils.kt
+++ /dev/null
@@ -1,20 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.test
-
-import java.lang.reflect.Field
-import java.lang.reflect.Modifier
-
-object ReflectionUtils {
-    fun <T : Any> setField(instance: T, fieldName: String, value: Any?) {
-        val originField = instance.javaClass.getField(fieldName)
-
-        val modifiersField = Field::class.java.getDeclaredField("modifiers")
-        modifiersField.isAccessible = true
-        modifiersField.setInt(originField, originField.modifiers and Modifier.FINAL.inv())
-
-        originField.set(instance, value)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockSelection.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockSelection.kt
deleted file mode 100644
index b9cd522290d7..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockSelection.kt
+++ /dev/null
@@ -1,9 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import org.mozilla.gecko.util.GeckoBundle
-
-class MockSelection(bundle: GeckoBundle) : GeckoSession.SelectionActionDelegate.Selection(bundle, emptySet(), null)
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebExtension.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebExtension.kt
deleted file mode 100644
index 0046f6dc4b2e..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebExtension.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import mozilla.components.support.test.mock
-import org.mozilla.gecko.util.GeckoBundle
-
-class MockWebExtension(bundle: GeckoBundle) : WebExtension(DelegateControllerProvider { mock() }, bundle)
-class MockCreateTabDetails(bundle: GeckoBundle) : WebExtension.CreateTabDetails(bundle)
-class MockUpdateTabDetails(bundle: GeckoBundle) : WebExtension.UpdateTabDetails(bundle)
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebNotification.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebNotification.kt
deleted file mode 100644
index 62b8f93e1378..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebNotification.kt
+++ /dev/null
@@ -1,17 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-class MockWebNotification(
-    title: String,
-    tag: String,
-    cookie: String,
-    text: String,
-    imageUrl: String,
-    textDirection: String,
-    lang: String,
-    requireInteraction: Boolean,
-    source: String
-) : WebNotification(title, tag, cookie, text, imageUrl, textDirection, lang, requireInteraction, source)
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt b/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt
deleted file mode 100644
index 48424a016e03..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt
+++ /dev/null
@@ -1,21 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import mozilla.components.test.ReflectionUtils
-
-class MockWebResponseInfo(
-    uri: String,
-    contentType: String,
-    contentLength: Long,
-    filename: String?
-) : GeckoSession.WebResponseInfo() {
-    init {
-        ReflectionUtils.setField(this, "uri", uri)
-        ReflectionUtils.setField(this, "contentType", contentType)
-        ReflectionUtils.setField(this, "filename", filename)
-        ReflectionUtils.setField(this, "contentLength", contentLength)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/browser/engine-gecko-beta/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
deleted file mode 100644
index cf1c399ea81e..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
+++ /dev/null
@@ -1,2 +0,0 @@
-mock-maker-inline
-// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/components/browser/engine-gecko-beta/src/test/resources/robolectric.properties b/android-components/components/browser/engine-gecko-beta/src/test/resources/robolectric.properties
deleted file mode 100644
index 89a6c8b4c2e7..000000000000
--- a/android-components/components/browser/engine-gecko-beta/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-sdk=28
\ No newline at end of file
diff --git a/android-components/components/browser/engine-gecko-nightly/README.md b/android-components/components/browser/engine-gecko-nightly/README.md
deleted file mode 100644
index 7b5627804fcf..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/README.md
+++ /dev/null
@@ -1,41 +0,0 @@
-# [Android Components](../../../README.md) > Browser > Engine-Gecko
-
-[*Engine*](../../concept/engine/README.md) implementation based on [GeckoView](https://wiki.mozilla.org/Mobile/GeckoView).
-
-## Usage
-
-### Setting up the dependency
-
-Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
-
-```Groovy
-implementation "org.mozilla.components:browser-engine-gecko-nightly:{latest-version}"
-```
-
-### Integration with the Glean SDK
-
-#### Before using this component
-Products sending telemetry and using this component *must request* a data-review following [this process](https://wiki.mozilla.org/Firefox/Data_Collection).
-
-The [Glean SDK](../../../components/service/glean/README.md) can be used to collect [Gecko Telemetry](https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/index.html).
-Applications using both this component and the Glean SDK should setup the Gecko Telemetry delegate
-as shown below:
-
-```Kotlin
-    val builder = GeckoRuntimeSettings.Builder()
-    val runtimeSettings = builder
-        .telemetryDelegate(GeckoGleanAdapter()) // Sets up the delegate!
-        .build()
-    // Create the Gecko runtime.
-    GeckoRuntime.create(context, runtimeSettings)
-```
-
-#### Adding new metrics
-
-New Gecko metrics can be added as described [in the Firefox Telemetry docs](https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/start/adding-a-new-probe.html).
-
-## License
-
-    This Source Code Form is subject to the terms of the Mozilla Public
-    License, v. 2.0. If a copy of the MPL was not distributed with this
-    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/browser/engine-gecko-nightly/build.gradle b/android-components/components/browser/engine-gecko-nightly/build.gradle
deleted file mode 100644
index 8e89ee8f13d7..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/build.gradle
+++ /dev/null
@@ -1,86 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-buildscript {
-    repositories {
-        maven {
-            url "https://maven.mozilla.org/maven2"
-        }
-
-        dependencies {
-            classpath "org.mozilla.telemetry:glean-gradle-plugin:${Versions.mozilla_glean}"
-        }
-    }
-}
-
-plugins {
-    id "com.jetbrains.python.envs" version "0.0.26"
-}
-
-apply plugin: 'com.android.library'
-apply plugin: 'kotlin-android'
-
-android {
-    compileSdkVersion config.compileSdkVersion
-
-    defaultConfig {
-        minSdkVersion config.minSdkVersion
-        targetSdkVersion config.targetSdkVersion
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-
-    packagingOptions {
-        exclude 'META-INF/proguard/androidx-annotations.pro'
-    }
-}
-
-// Set configuration for the Glean parser to extract metrics.yaml
-// file from AAR dependencies of this project rather than look
-// for it into the project directory.
-ext.allowMetricsFromAAR = true
-// Generate markdown docs for the collected Gecko metrics.
-ext.gleanGenerateMarkdownDocs = true
-
-dependencies {
-    implementation project(':concept-engine')
-    implementation project(':concept-fetch')
-    implementation project(':support-ktx')
-    implementation project(':support-utils')
-
-    implementation Dependencies.kotlin_stdlib
-    implementation Dependencies.kotlin_coroutines
-
-    api Gecko.geckoview_nightly
-
-    testImplementation Dependencies.androidx_test_core
-    testImplementation Dependencies.androidx_test_junit
-    testImplementation Dependencies.testing_robolectric
-    testImplementation Dependencies.testing_coroutines
-    testImplementation Dependencies.testing_mockito
-    testImplementation Dependencies.testing_mockwebserver
-    testImplementation project(':support-test')
-    testImplementation project(':tooling-fetch-tests')
-
-    // We only compile against Glean. It's up to the app to add those dependencies
-    // if it wants to collect GeckoView telemetry through the Glean SDK.
-    compileOnly project(":service-glean")
-    testImplementation project(":service-glean")
-    testImplementation Dependencies.androidx_work_testing
-
-    androidTestImplementation Dependencies.androidx_test_core
-    androidTestImplementation Dependencies.androidx_test_runner
-    androidTestImplementation Dependencies.androidx_test_rules
-    androidTestImplementation project(':tooling-fetch-tests')
-}
-
-apply plugin: "org.mozilla.telemetry.glean-gradle-plugin"
-apply from: '../../../publish.gradle'
-ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
diff --git a/android-components/components/browser/engine-gecko-nightly/docs/metrics.md b/android-components/components/browser/engine-gecko-nightly/docs/metrics.md
deleted file mode 100644
index 684a4e89638c..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/docs/metrics.md
+++ /dev/null
@@ -1,118 +0,0 @@
-<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
-
-# Metrics
-
-This document enumerates the metrics collected by this project using the [Glean SDK](https://mozilla.github.io/glean/book/index.html).
-This project may depend on other projects which also collect metrics.
-This means you might have to go searching through the dependency tree to get a full picture of everything collected by this project.
-
-# Pings
-
-- [metrics](#metrics)
-
-## metrics
-
-This is a built-in ping that is assembled out of the box by the Glean SDK.
-
-See the Glean SDK documentation for the [`metrics` ping](https://mozilla.github.io/glean/book/user/pings/metrics.html).
-
-All Glean pings contain built-in metrics in the [`ping_info`](https://mozilla.github.io/glean/book/user/pings/index.html#the-ping_info-section) and [`client_info`](https://mozilla.github.io/glean/book/user/pings/index.html#the-client_info-section) sections.
-
-In addition to those built-in metrics, the following metrics are added to the ping:
-
-| Name | Type | Description | Data reviews | Extras | Expiration | [Data Sensitivity](https://wiki.mozilla.org/Firefox/Data_Collection) |
-| --- | --- | --- | --- | --- | --- | --- |
-| avif.aom_decode_error |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Image-decode Error from AOM decoder  |[Bug 1690406](https://bugzilla.mozilla.org/show_bug.cgi?id=1690406#c3)|<ul><li>error</li><li>mem_error</li><li>abi_mismatch</li><li>incapable</li><li>unsup_bitstream</li><li>unsup_feature</li><li>corrupt_frame</li><li>invalid_param</li></ul>|never | |
-| avif.bit_depth |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Bits per pixel of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>color_8</li><li>color_10</li><li>color_12</li><li>color_16</li><li>unknown</li></ul>|never | |
-| avif.decode_result |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Decode result of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>success</li><li>parse_error</li><li>no_primary_item</li><li>decode_error</li><li>size_overflow</li><li>out_of_memory</li><li>pipe_init_error</li><li>write_buffer_error</li><li>alpha_y_sz_mismatch</li><li>alpha_y_bpc_mismatch</li></ul>|never | |
-| avif.decoder |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Decoder of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>dav1d</li><li>aom</li></ul>|never | |
-| avif.yuv_color_space |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |YUV color space of AVIF image.  |[Bug 1670827](https://bugzilla.mozilla.org/show_bug.cgi?id=1670827#c9)|<ul><li>bt601</li><li>bt709</li><li>bt2020</li><li>identity</li><li>unknown</li></ul>|never | |
-| geckoview.build_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |The Buildid of the Gecko engine, example: 20200205124310  |[Bug 1611240](https://bugzilla.mozilla.org/show_bug.cgi?id=1611240#c2)||never | |
-| geckoview.content_process_lifetime |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The uptime of content processes in ms  |[Bug 1625325](https://bugzilla.mozilla.org/show_bug.cgi?id=1625325#c2)||never | |
-| geckoview.document_site_origins |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |When a document is loaded, report the number of [site origins](https://searchfox.org/ mozilla-central/rev/ 3300072e993ae05d50d5c63d815260367eaf9179/ caps/nsIPrincipal.idl#264) of the entire browser if it has been at least 5 minutes since last time we collect this data.  |[Bug 1589700](https://bugzilla.mozilla.org/show_bug.cgi?id=1589700#c5)||never | |
-| geckoview.page_load_progress_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between page load progress starts (0) and completion (100).  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| geckoview.page_load_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to load a page. This includes all static contents, no dynamic content. Loading of about: pages is not counted. Back back navigation (sometimes via BFCache) is included which is a source of bimodality due to the <50ms load times.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| geckoview.page_reload_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time taken to reload a page. This includes all static contents, no dynamic content. Loading of about: pages is not counted.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| geckoview.per_document_site_origins |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |When a document is unloaded, report the highest number of [site origins](https://searchfox.org/ mozilla-central/rev/ 3300072e993ae05d50d5c63d815260367eaf9179/ caps/nsIPrincipal.idl#264) loaded simultaneously in that document.  |[Bug 1603185](https://bugzilla.mozilla.org/show_bug.cgi?id=1603185#c13)||never | |
-| geckoview.startup_runtime |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to initialize GeckoRuntime.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| geckoview.version |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |The version of the Gecko engine, example: 74.0a1  |[Bug 1611240](https://bugzilla.mozilla.org/show_bug.cgi?id=1611240#c2)||never | |
-| gfx.adapter.primary.description |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Long form description of the Graphics adapter  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.device_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter device identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_date |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver date  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_files |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |List of graphics adapter driver files  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_vendor |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver vendor identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.driver_version |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter driver version  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.ram |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Graphics adapter dedicated memory  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Megabytes</li></ul>|never | |
-| gfx.adapter.primary.subsystem_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter subsystem identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.adapter.primary.vendor_id |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Graphics adapter vendor identification  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.checkerboard.duration |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The duration of a checkerboard event. Checkerboarding is when painting has not kept up with asynchronous panning and zooming so the compositor has to display a "checkerboard pattern" (or in practice, the background color) rather than the actual page content.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.peak_pixel_count |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The peak number of CSS pixels that checkerboarded during a checkerboard event. The minimum value of the largest histogram bucket is the size of a 4k display with maximum APZ zooming.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.potential_duration |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The total amount of time that we could reasonably be checkerboarding. This is the union of two possibly-intersecting sets of time periods: The first set is that in which checkerboarding was actually happening, since by definition it could potentially be happening. The second set is that in which the APZC is actively transforming content in the compositor, since it could potentially transform it so as to display checkerboarding to the user. Combined with other information, this allows us to meaningfully say how frequently users actually enncounters checkerboarding.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.checkerboard.severity |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |An opaque measurement of the severity of a checkerboard event. This doesn't have units, it's just useful for comparing two checkerboard events to see which one is worse, for some implementation-specific definition of "worse". The larger the value, the worse the checkerboarding.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.composite_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to composite a frame. On non-webrender this is the time taken in `CompositorBridgeParent::CompositeToTarget()`. On webrender, this is the time taken from the start of `WebRenderBridgeParent::CompositeToTarget()`, until the render thread has rendered the frame (in `RenderThread::HandleFrameOneDoc()`).  |[Bug 1580129](https://bugzilla.mozilla.org/show_bug.cgi?id=1580129#c7)||never | |
-| gfx.content.frame_time.from_paint |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.from_vsync |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from the vsync that started a paint in the content process until that frame is presented in the compositor.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.reason |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |The reason that `gfx.content.frame_time.from_paint` recorded a slow (>200ms) result, if any.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)|<ul><li>on_time</li><li>no_vsync</li><li>missed_composite</li><li>slow_composite</li><li>missed_composite_mid</li><li>missed_composite_long</li><li>missed_composite_low</li><li>no_vsync_no_id</li></ul>|never | |
-| gfx.content.frame_time.with_svg |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor, for frames that contained an SVG to be drawn by webrender.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.without_resource_upload |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor by webrender, excluding time spent uploading resources.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.frame_time.without_upload |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |The time, in percentage of a vsync interval, spent from beginning a paint in the content process until that frame is presented in the compositor by webrender, excluding time spent uploading any content.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.full_paint_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in the full paint pipeline for content until it's ready for composition. For non-webrender this includes `paint_time`, plus rasterization if OMTP is enabled. For webrender, this includes `paint_time`, plus scene building time.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.content.paint_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in the main-thread paint pipeline for content. For non-webrender, this includes display list building, layer building, and when OMTP is disabled, rasterization. For webrender, this includes display list building, and webrender display list building.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.display.count |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Amount of displays connected to the device  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Display count</li></ul>|never | |
-| gfx.display.primary_height |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Height of the primary display, takes device rotation into account.  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Pixels</li></ul>|never | |
-| gfx.display.primary_width |[quantity](https://mozilla.github.io/glean/book/user/metrics/quantity.html) |Width of the primary display, takes device rotation into account.  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)|<ul><li>unit: Pixels</li></ul>|never | |
-| gfx.feature.webrender |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Whether webrender is enabled or disabled, and why. |[Bug 1687312](https://bugzilla.mozilla.org/show_bug.cgi?id=1687312#c5)||never | |
-| gfx.scroll_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a scroll event on the event loop and compositing its result onto the screen (ms).  |[Bug 1604818](https://bugzilla.mozilla.org/show_bug.cgi?id=1604818#c4)||never | |
-| gfx.status.compositor |[string](https://mozilla.github.io/glean/book/user/metrics/string.html) |Name of the graphics compositor in use. Possible values are "opengl, d3d11, client, webrender or basic"  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.status.headless |[boolean](https://mozilla.github.io/glean/book/user/metrics/boolean.html) |Boolean indicated whether graphics is running in headless (no display) mode  |[Bug 1594145](https://bugzilla.mozilla.org/show_bug.cgi?id=1594145#c4)||never | |
-| gfx.webrender.framebuild_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to build a webrender frame. This involves calculating the visibility of primitives, requesting resources, and building the render passes which will be used to render the frame.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.webrender.scenebuild_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to build a webrender scene. This occurs each time webrender receives a new display list. This additionally includes blob rasterization time.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| gfx.webrender.sceneswap_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taken to do a webrender scene swap. This is book-keeping that APZ must perform once webrender has built a new scene.  |[Bug 1584109](https://bugzilla.mozilla.org/show_bug.cgi?id=1584109#c1)||never | |
-| javascript.gc.compact_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the compact phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.mark_roots_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent marking GC roots.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.mark_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the mark phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.minor_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time taked by a minor (nursery) collection.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.prepare_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the preparation phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.slice_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent running a GC slice.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.sweep_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time spent in the sweep phase.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c17)||never | |
-| javascript.gc.total_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The total time taken by a major collection.  |[Bug 1636419](https://bugzilla.mozilla.org/show_bug.cgi?id=1636419#c8)||never | |
-| js.baseline_compile_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during Baseline compilation for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.bytecode_caching_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent caching JS bytecode for scripts executed during a page load.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.delazification_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during delazification for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.execution_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of page load time spent executing Javascript.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| js.xdr_encode_percentage |[custom_distribution](https://mozilla.github.io/glean/book/user/metrics/custom_distribution.html) |Percentage of execution time spent during XDR encoding for JS scripts up until the page load event fires.  |[Bug 1664475](https://bugzilla.mozilla.org/show_bug.cgi?id=1664475#c6)||2021-03-18 | |
-| media.audio.backend |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |The operating system audio backend  |[Bug 1671714](https://bugzilla.mozilla.org/show_bug.cgi?id=1671714#c10)|<ul><li>unknown</li><li>audiounit</li><li>audiounit_rust</li><li>aaudio</li><li>opensl</li><li>wasapi</li><li>winmm</li><li>alsa</li><li>jack</li><li>oss</li><li>pulse</li><li>pulse_rust</li><li>sndio</li><li>sun</li></ul>|never | |
-| media.audio.init_failure |[labeled_counter](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html) |Failure occurs when initializing the audio stream.  |[Bug 1671714](https://bugzilla.mozilla.org/show_bug.cgi?id=1671714#c10)|<ul><li>first</li><li>other</li></ul>|never | |
-| network.cache_hit_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time to open existing cache entry file.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.dns_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from the DNS request being issued to the response.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.dns_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from connection open to the DNS request being issued.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.first_from_cache |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from connection open to cache read start.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.font_download_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time after navigationStart that all webfont downloads are completed.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.tcp_connection |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from the TCP SYN packet is received to the connection is established and ready for HTTP.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| network.tls_handshake |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |In the HTTP page channel, time from after the TCP SYN packet is received to the secure connection is established and ready for HTTP.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.interaction.keypress_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a keypress event in the event loop and compositing its result onto the screen.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.interaction.mouseup_click_present_latency |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between receiving a mouseup which follow by a mouseclick on the event loop and compositing its result onto the screen.  |[Bug 1698643](https://bugzilla.mozilla.org/show_bug.cgi?id=1698643#c3)||never | |
-| performance.interaction.tab_switch_composite |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time between tab selection and first composite of the tab content onto the screen.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.page.non_blank_paint |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between navigationStart and the first non-blank paint of a foreground root content document, in milliseconds. This only records documents that were in an active docshell throughout the whole time between navigation start and non-blank paint. The non-blank paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.page.total_content_page_load |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time to load all of a page's resources and render.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.pageload.dcl |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from navigationStart to domContentLoaded for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.dcl_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from responseStart to domContentLoaded for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.fcp |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between navigationStart and the first contentful paint of a foreground http or https root content document, in milliseconds. The contentful paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.fcp_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |The time between responseStart and the first contentful paint of a foreground http or https root content document, in milliseconds. The contentful paint timestamp is taken during display list building and does not include rasterization or compositing of that paint.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.load_time |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from navigationStart to loadEventStart for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.load_time_responsestart |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time in milliseconds from responseStart to loadEventStart for the foreground http or https root content document.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.pageload.req_anim_frame_callback |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in milliseconds calling all request animation frame callbacks for a document before it has reached readystate complete.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.responsiveness.req_anim_frame_callback |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time spent in milliseconds calling all request animation frame callbacks for a document after it has reached readystate complete.  |[Bug 1671729](https://bugzilla.mozilla.org/show_bug.cgi?id=1671729#c7)||never | |
-| performance.time.dom_complete |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domComplete as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_content_loaded_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domContentLoadedEventEnd as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_content_loaded_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domContentLoadedEventStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.dom_interactive |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to domInteractive as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.load_event_end |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to loadEventEnd as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.load_event_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to loadEventStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| performance.time.response_start |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |Time from navigationStart to responseStart as per the W3C Performance Timing API.  |[Bug 1580077](https://bugzilla.mozilla.org/show_bug.cgi?id=1580077#c10)||never | |
-| test.glean.geckoview.streaming |[timing_distribution](https://mozilla.github.io/glean/book/user/metrics/timing_distribution.html) |A test-only, disabled metric. This is required to guarantee that a `GleanGeckoHistogramMapping` is always generated, even though the GeckoView AAR exports no metric. Please note that the data-review field below contains no review, since this metric is disabled and not allowed to collect any data.  |[Review 1](https://bugzilla.mozilla.org/1566374)||never | |
-
-Data categories are [defined here](https://wiki.mozilla.org/Firefox/Data_Collection).
-
-<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
-
diff --git a/android-components/components/browser/engine-gecko-nightly/metrics.yaml b/android-components/components/browser/engine-gecko-nightly/metrics.yaml
deleted file mode 100644
index 4775ce544de8..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/metrics.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-# IMPORTANT NOTE: this file is here only as a safety measure, to make
-# sure the correct code is generated even though the GeckoView AAR file
-# reports an empty metrics.yaml file. The metric in this file is currently
-# disabled and not supposed to collect any data.
----
-
-$schema: moz://mozilla.org/schemas/glean/metrics/2-0-0
-
-test.glean.geckoview:
-  streaming:
-    type: timing_distribution
-    gecko_datapoint: TELEMETRY_TEST_STREAMING
-    disabled: true
-    description: |
-      A test-only, disabled metric. This is required to guarantee
-      that a `GleanGeckoHistogramMapping` is always generated, even
-      though the GeckoView AAR exports no metric. Please note that
-      the data-review field below contains no review, since this
-      metric is disabled and not allowed to collect any data.
-    bugs:
-      - https://bugzilla.mozilla.org/1566374
-    data_reviews:
-      - https://bugzilla.mozilla.org/1566374
-    notification_emails:
-      - glean-team@mozilla.com
-    expires: never
diff --git a/android-components/components/browser/engine-gecko-nightly/proguard-rules.pro b/android-components/components/browser/engine-gecko-nightly/proguard-rules.pro
deleted file mode 100644
index f1b424510da5..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/proguard-rules.pro
+++ /dev/null
@@ -1,21 +0,0 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/browser/engine-gecko-nightly/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt b/android-components/components/browser/engine-gecko-nightly/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt
deleted file mode 100644
index 38e0a1586fb8..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/androidTest/java/mozilla/components/browser/engine/gecko/fetch/geckoview/GeckoViewFetchTestCases.kt
+++ /dev/null
@@ -1,126 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch.geckoview
-
-import androidx.test.annotation.UiThreadTest
-import androidx.test.core.app.ApplicationProvider
-import androidx.test.filters.MediumTest
-import mozilla.components.browser.engine.gecko.fetch.GeckoViewFetchClient
-import mozilla.components.concept.fetch.Client
-import org.junit.Assert.assertTrue
-import org.junit.Test
-
-@MediumTest
-class GeckoViewFetchTestCases : mozilla.components.tooling.fetch.tests.FetchTestCases() {
-    override fun createNewClient(): Client = GeckoViewFetchClient(ApplicationProvider.getApplicationContext())
-
-    @Test
-    @UiThreadTest
-    fun clientInstance() {
-        assertTrue(createNewClient() is GeckoViewFetchClient)
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithGzippedBody() {
-        super.get200WithGzippedBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200OverridingDefaultHeaders() {
-        super.get200OverridingDefaultHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithDuplicatedCacheControlRequestHeaders() {
-        super.get200WithDuplicatedCacheControlRequestHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithDuplicatedCacheControlResponseHeaders() {
-        super.get200WithDuplicatedCacheControlResponseHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithHeaders() {
-        super.get200WithHeaders()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithReadTimeout() {
-        super.get200WithReadTimeout()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithStringBody() {
-        super.get200WithStringBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get302FollowRedirects() {
-        super.get302FollowRedirects()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get302FollowRedirectsDisabled() {
-        super.get302FollowRedirectsDisabled()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get404WithBody() {
-        super.get404WithBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun post200WithBody() {
-        super.post200WithBody()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun put201FileUpload() {
-        super.put201FileUpload()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithCookiePolicy() {
-        super.get200WithCookiePolicy()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithContentTypeCharset() {
-        super.get200WithContentTypeCharset()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun get200WithCacheControl() {
-        super.get200WithCacheControl()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun getThrowsIOExceptionWhenHostNotReachable() {
-        super.getThrowsIOExceptionWhenHostNotReachable()
-    }
-
-    @Test
-    @UiThreadTest
-    override fun getDataUri() {
-        super.getDataUri()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/AndroidManifest.xml b/android-components/components/browser/engine-gecko-nightly/src/main/AndroidManifest.xml
deleted file mode 100644
index 5012ce552616..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="mozilla.components.browser.engine.gecko" />
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt
deleted file mode 100644
index bba8c952775f..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngine.kt
+++ /dev/null
@@ -1,773 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.annotation.SuppressLint
-import android.content.Context
-import android.util.AttributeSet
-import android.util.JsonReader
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.activity.GeckoActivityDelegate
-import mozilla.components.browser.engine.gecko.ext.getAntiTrackingPolicy
-import mozilla.components.browser.engine.gecko.ext.getEtpLevel
-import mozilla.components.browser.engine.gecko.ext.getStrictSocialTrackingProtection
-import mozilla.components.browser.engine.gecko.integration.LocaleSettingUpdater
-import mozilla.components.browser.engine.gecko.mediaquery.from
-import mozilla.components.browser.engine.gecko.mediaquery.toGeckoValue
-import mozilla.components.browser.engine.gecko.profiler.Profiler
-import mozilla.components.browser.engine.gecko.util.SpeculativeSessionFactory
-import mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-import mozilla.components.browser.engine.gecko.webextension.GeckoWebExtensionException
-import mozilla.components.browser.engine.gecko.webnotifications.GeckoWebNotificationDelegate
-import mozilla.components.browser.engine.gecko.webpush.GeckoWebPushDelegate
-import mozilla.components.browser.engine.gecko.webpush.GeckoWebPushHandler
-import mozilla.components.concept.engine.CancellableOperation
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.concept.engine.content.blocking.TrackerLog
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.utils.EngineVersion
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.EnableSource
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.concept.engine.webextension.WebExtensionDelegate
-import mozilla.components.concept.engine.webextension.WebExtensionRuntime
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushHandler
-import mozilla.components.support.ktx.kotlin.isResourceUrl
-import mozilla.components.support.utils.ThreadUtils
-import org.json.JSONObject
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.Event
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebExtensionController
-import java.lang.ref.WeakReference
-
-/**
- * Gecko-based implementation of Engine interface.
- */
-@Suppress("LargeClass")
-class GeckoEngine(
-    context: Context,
-    private val defaultSettings: Settings? = null,
-    private val runtime: GeckoRuntime = GeckoRuntime.getDefault(context),
-    executorProvider: () -> GeckoWebExecutor = { GeckoWebExecutor(runtime) },
-    override val trackingProtectionExceptionStore: TrackingProtectionExceptionStorage =
-        TrackingProtectionExceptionFileStorage(context, runtime)
-) : Engine, WebExtensionRuntime {
-    private val executor by lazy { executorProvider.invoke() }
-    private val localeUpdater = LocaleSettingUpdater(context, runtime)
-    @VisibleForTesting internal val speculativeConnectionFactory = SpeculativeSessionFactory()
-    private var webExtensionDelegate: WebExtensionDelegate? = null
-    private val webExtensionActionHandler = object : ActionHandler {
-        override fun onBrowserAction(extension: WebExtension, session: EngineSession?, action: Action) {
-            webExtensionDelegate?.onBrowserActionDefined(extension, action)
-        }
-
-        override fun onPageAction(extension: WebExtension, session: EngineSession?, action: Action) {
-            webExtensionDelegate?.onPageActionDefined(extension, action)
-        }
-
-        override fun onToggleActionPopup(extension: WebExtension, action: Action): EngineSession? {
-            return webExtensionDelegate?.onToggleActionPopup(extension, GeckoEngineSession(runtime,
-                defaultSettings = defaultSettings), action)
-        }
-    }
-    private val webExtensionTabHandler = object : TabHandler {
-        override fun onNewTab(webExtension: WebExtension, engineSession: EngineSession, active: Boolean, url: String) {
-            webExtensionDelegate?.onNewTab(webExtension, engineSession, active, url)
-        }
-    }
-
-    private var webPushHandler: WebPushHandler? = null
-
-    init {
-        runtime.delegate = GeckoRuntime.Delegate {
-            // On shutdown: The runtime is shutting down (possibly because of an unrecoverable error state). We crash
-            // the app here for two reasons:
-            //  - We want to know about those unsolicited shutdowns and fix those issues.
-            //  - We can't recover easily from this situation. Just continuing will leave us with an engine that
-            //    doesn't do anything anymore.
-            @Suppress("TooGenericExceptionThrown")
-            throw RuntimeException("GeckoRuntime is shutting down")
-        }
-        trackingProtectionExceptionStore.restore()
-    }
-
-    /**
-     * Fetch a list of trackers logged for a given [session] .
-     *
-     * @param session the session where the trackers were logged.
-     * @param onSuccess callback invoked if the data was fetched successfully.
-     * @param onError (optional) callback invoked if fetching the data caused an exception.
-     */
-    override fun getTrackersLog(
-        session: EngineSession,
-        onSuccess: (List<TrackerLog>) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        runtime.contentBlockingController.getLog(geckoSession).then({ contentLogList ->
-            val list = contentLogList ?: emptyList()
-            val logs = list.map { logEntry ->
-                logEntry.toTrackerLog()
-            }.filterNot {
-                !it.cookiesHasBeenBlocked &&
-                    it.blockedCategories.isEmpty() &&
-                    it.loadedCategories.isEmpty()
-            }
-
-            onSuccess(logs)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * Creates a new Gecko-based EngineView.
-     */
-    override fun createView(context: Context, attrs: AttributeSet?): EngineView {
-        return GeckoEngineView(context, attrs).apply {
-            setColorScheme(settings.preferredColorScheme)
-        }
-    }
-
-    /**
-     * See [Engine.createSession].
-     */
-    override fun createSession(private: Boolean, contextId: String?): EngineSession {
-        ThreadUtils.assertOnUiThread()
-        val speculativeSession = speculativeConnectionFactory.get(private, contextId)
-        return speculativeSession ?: GeckoEngineSession(runtime, private, defaultSettings, contextId)
-    }
-
-    /**
-     * See [Engine.createSessionState].
-     */
-    override fun createSessionState(json: JSONObject): EngineSessionState {
-        return GeckoEngineSessionState.fromJSON(json)
-    }
-
-    /**
-     * See [Engine.createSessionStateFrom].
-     */
-    override fun createSessionStateFrom(reader: JsonReader): EngineSessionState {
-        return GeckoEngineSessionState.from(reader)
-    }
-
-    /**
-     * See [Engine.speculativeCreateSession].
-     */
-    override fun speculativeCreateSession(private: Boolean, contextId: String?) {
-        ThreadUtils.assertOnUiThread()
-        speculativeConnectionFactory.create(runtime, private, contextId, defaultSettings)
-    }
-
-    /**
-     * See [Engine.clearSpeculativeSession].
-     */
-    override fun clearSpeculativeSession() {
-        speculativeConnectionFactory.clear()
-    }
-
-    /**
-     * Opens a speculative connection to the host of [url].
-     *
-     * This is useful if an app thinks it may be making a request to that host in the near future. If no request
-     * is made, the connection will be cleaned up after an unspecified.
-     */
-    override fun speculativeConnect(url: String) {
-        executor.speculativeConnect(url)
-    }
-
-    /**
-     * See [Engine.installWebExtension].
-     */
-    override fun installWebExtension(
-        id: String,
-        url: String,
-        onSuccess: ((WebExtension) -> Unit),
-        onError: ((String, Throwable) -> Unit)
-    ): CancellableOperation {
-
-        val onInstallSuccess: ((org.mozilla.geckoview.WebExtension) -> Unit) = {
-            val installedExtension = GeckoWebExtension(it, runtime)
-            webExtensionDelegate?.onInstalled(installedExtension)
-            installedExtension.registerActionHandler(webExtensionActionHandler)
-            installedExtension.registerTabHandler(webExtensionTabHandler, defaultSettings)
-            onSuccess(installedExtension)
-        }
-
-        val geckoResult = if (url.isResourceUrl()) {
-            runtime.webExtensionController.ensureBuiltIn(url, id).apply {
-                then({
-                    onInstallSuccess(it!!)
-                    GeckoResult<Void>()
-                }, { throwable ->
-                    onError(id, throwable)
-                    GeckoResult<Void>()
-                })
-            }
-        } else {
-            runtime.webExtensionController.install(url).apply {
-                then({
-                    onInstallSuccess(it!!)
-                    GeckoResult<Void>()
-                }, { throwable ->
-                    onError(id, throwable)
-                    GeckoResult<Void>()
-                })
-            }
-        }
-        return geckoResult.asCancellableOperation()
-    }
-
-    /**
-     * See [Engine.uninstallWebExtension].
-     */
-    override fun uninstallWebExtension(
-        ext: WebExtension,
-        onSuccess: () -> Unit,
-        onError: (String, Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.uninstall((ext as GeckoWebExtension).nativeExtension).then({
-            webExtensionDelegate?.onUninstalled(ext)
-            onSuccess()
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(ext.id, throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.updateWebExtension].
-     */
-    override fun updateWebExtension(
-        extension: WebExtension,
-        onSuccess: (WebExtension?) -> Unit,
-        onError: (String, Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.update((extension as GeckoWebExtension).nativeExtension).then({ geckoExtension ->
-            val updatedExtension = if (geckoExtension != null) {
-                GeckoWebExtension(geckoExtension, runtime).also {
-                    it.registerActionHandler(webExtensionActionHandler)
-                    it.registerTabHandler(webExtensionTabHandler, defaultSettings)
-                }
-            } else {
-                null
-            }
-            onSuccess(updatedExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(extension.id, GeckoWebExtensionException(throwable))
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.registerWebExtensionDelegate].
-     */
-    @Suppress("Deprecation")
-    override fun registerWebExtensionDelegate(
-        webExtensionDelegate: WebExtensionDelegate
-    ) {
-        this.webExtensionDelegate = webExtensionDelegate
-
-        val promptDelegate = object : WebExtensionController.PromptDelegate {
-            override fun onInstallPrompt(ext: org.mozilla.geckoview.WebExtension): GeckoResult<AllowOrDeny>? {
-                val extension = GeckoWebExtension(ext, runtime)
-                return if (webExtensionDelegate.onInstallPermissionRequest(extension)) {
-                    GeckoResult.allow()
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-
-            override fun onUpdatePrompt(
-                current: org.mozilla.geckoview.WebExtension,
-                updated: org.mozilla.geckoview.WebExtension,
-                newPermissions: Array<out String>,
-                newOrigins: Array<out String>
-            ): GeckoResult<AllowOrDeny>? {
-                val result = GeckoResult<AllowOrDeny>()
-                webExtensionDelegate.onUpdatePermissionRequest(
-                    GeckoWebExtension(current, runtime),
-                    GeckoWebExtension(updated, runtime),
-                    newPermissions.toList() + newOrigins.toList()
-                ) {
-                    allow -> if (allow) result.complete(AllowOrDeny.ALLOW) else result.complete(AllowOrDeny.DENY)
-                }
-                return result
-            }
-        }
-
-        val debuggerDelegate = object : WebExtensionController.DebuggerDelegate {
-            override fun onExtensionListUpdated() {
-                webExtensionDelegate.onExtensionListUpdated()
-            }
-        }
-
-        runtime.webExtensionController.promptDelegate = promptDelegate
-        runtime.webExtensionController.setDebuggerDelegate(debuggerDelegate)
-    }
-
-    /**
-     * See [Engine.listInstalledWebExtensions].
-     */
-    override fun listInstalledWebExtensions(onSuccess: (List<WebExtension>) -> Unit, onError: (Throwable) -> Unit) {
-        runtime.webExtensionController.list().then({
-            val extensions = it?.map {
-                extension -> GeckoWebExtension(extension, runtime)
-            } ?: emptyList()
-
-            extensions.forEach { extension ->
-                extension.registerActionHandler(webExtensionActionHandler)
-                extension.registerTabHandler(webExtensionTabHandler, defaultSettings)
-            }
-
-            onSuccess(extensions)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.enableWebExtension].
-     */
-    override fun enableWebExtension(
-        extension: WebExtension,
-        source: EnableSource,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.enable((extension as GeckoWebExtension).nativeExtension, source.id).then({
-            val enabledExtension = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onEnabled(enabledExtension)
-            onSuccess(enabledExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.disableWebExtension].
-     */
-    override fun disableWebExtension(
-        extension: WebExtension,
-        source: EnableSource,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.disable((extension as GeckoWebExtension).nativeExtension, source.id).then({
-            val disabledExtension = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onDisabled(disabledExtension)
-            onSuccess(disabledExtension)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.setAllowedInPrivateBrowsing].
-     */
-    override fun setAllowedInPrivateBrowsing(
-        extension: WebExtension,
-        allowed: Boolean,
-        onSuccess: (WebExtension) -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        runtime.webExtensionController.setAllowedInPrivateBrowsing(
-            (extension as GeckoWebExtension).nativeExtension,
-            allowed
-        ).then({
-            val ext = GeckoWebExtension(it!!, runtime)
-            webExtensionDelegate?.onAllowedInPrivateBrowsingChanged(ext)
-            onSuccess(ext)
-            GeckoResult<Void>()
-        }, { throwable ->
-            onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.registerWebNotificationDelegate].
-     */
-    override fun registerWebNotificationDelegate(
-        webNotificationDelegate: WebNotificationDelegate
-    ) {
-        runtime.webNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-    }
-
-    /**
-     * See [Engine.registerWebPushDelegate].
-     */
-    override fun registerWebPushDelegate(
-        webPushDelegate: WebPushDelegate
-    ): WebPushHandler {
-        runtime.webPushController.setDelegate(GeckoWebPushDelegate(webPushDelegate))
-
-        if (webPushHandler == null) {
-            webPushHandler = GeckoWebPushHandler(runtime)
-        }
-
-        return requireNotNull(webPushHandler)
-    }
-
-    /**
-     * See [Engine.registerActivityDelegate].
-     */
-    override fun registerActivityDelegate(
-        activityDelegate: ActivityDelegate
-    ) {
-        /**
-         * Having the activity delegate on the engine can cause issues with resolving multiple requests to the delegate
-         * from different sessions. Ideally, this should be moved to the [EngineView].
-         *
-         * See: https://bugzilla.mozilla.org/show_bug.cgi?id=1672195
-         *
-         * Attaching the delegate to the Gecko [Engine] implicitly assumes we have WebAuthn support. When a feature
-         * implements the ActivityDelegate today, we need to make sure that it has full support for WebAuthn. This
-         * needs to be fixed in GeckoView.
-         *
-         * See: https://bugzilla.mozilla.org/show_bug.cgi?id=1671988
-         */
-        runtime.activityDelegate = GeckoActivityDelegate(WeakReference(activityDelegate))
-    }
-
-    /**
-     * See [Engine.unregisterActivityDelegate].
-     */
-    override fun unregisterActivityDelegate() {
-        runtime.activityDelegate = null
-    }
-
-    /**
-     * See [Engine.clearData].
-     */
-    override fun clearData(
-        data: Engine.BrowsingData,
-        host: String?,
-        onSuccess: () -> Unit,
-        onError: (Throwable) -> Unit
-    ) {
-        val flags = data.types.toLong()
-        if (host != null) {
-            runtime.storageController.clearDataFromHost(host, flags)
-        } else {
-            runtime.storageController.clearData(flags)
-        }.then({
-            onSuccess()
-            GeckoResult<Void>()
-        }, {
-            throwable -> onError(throwable)
-            GeckoResult<Void>()
-        })
-    }
-
-    /**
-     * See [Engine.profiler].
-     */
-    override val profiler: Profiler? = Profiler(runtime)
-
-    override fun name(): String = "Gecko"
-
-    override val version: EngineVersion = EngineVersion.parse(org.mozilla.geckoview.BuildConfig.MOZILLA_VERSION)
-        ?: throw IllegalStateException("Could not determine engine version")
-
-    /**
-     * See [Engine.settings]
-     */
-    override val settings: Settings = object : Settings() {
-        override var javascriptEnabled: Boolean
-            get() = runtime.settings.javaScriptEnabled
-            set(value) { runtime.settings.javaScriptEnabled = value }
-
-        override var webFontsEnabled: Boolean
-            get() = runtime.settings.webFontsEnabled
-            set(value) { runtime.settings.webFontsEnabled = value }
-
-        override var automaticFontSizeAdjustment: Boolean
-            get() = runtime.settings.automaticFontSizeAdjustment
-            set(value) { runtime.settings.automaticFontSizeAdjustment = value }
-
-        override var automaticLanguageAdjustment: Boolean
-            get() = localeUpdater.enabled
-            set(value) {
-                localeUpdater.enabled = value
-                defaultSettings?.automaticLanguageAdjustment = value
-            }
-
-        override var safeBrowsingPolicy: Array<SafeBrowsingPolicy> =
-            arrayOf(SafeBrowsingPolicy.RECOMMENDED)
-            set(value) {
-                val policy = value.sumBy { it.id }
-                runtime.settings.contentBlocking.setSafeBrowsing(policy)
-                field = value
-            }
-
-        override var trackingProtectionPolicy: TrackingProtectionPolicy? = null
-            set(value) {
-                value?.let { policy ->
-                    with(runtime.settings.contentBlocking) {
-                        if (enhancedTrackingProtectionLevel != value.getEtpLevel()) {
-                            enhancedTrackingProtectionLevel = value.getEtpLevel()
-                        }
-
-                        if (strictSocialTrackingProtection != value.getStrictSocialTrackingProtection()) {
-                            strictSocialTrackingProtection = policy.getStrictSocialTrackingProtection()
-                        }
-
-                        if (antiTrackingCategories != value.getAntiTrackingPolicy()) {
-                            setAntiTracking(policy.getAntiTrackingPolicy())
-                        }
-
-                        if (cookieBehavior != value.cookiePolicy.id) {
-                            cookieBehavior = value.cookiePolicy.id
-                        }
-
-                        if (cookiePurging != value.cookiePurging) {
-                            setCookiePurging(value.cookiePurging)
-                        }
-                    }
-
-                    defaultSettings?.trackingProtectionPolicy = value
-                    field = value
-                }
-            }
-
-        override var remoteDebuggingEnabled: Boolean
-            get() = runtime.settings.remoteDebuggingEnabled
-            set(value) { runtime.settings.remoteDebuggingEnabled = value }
-
-        override var historyTrackingDelegate: HistoryTrackingDelegate?
-            get() = defaultSettings?.historyTrackingDelegate
-            set(value) { defaultSettings?.historyTrackingDelegate = value }
-
-        override var testingModeEnabled: Boolean
-            get() = defaultSettings?.testingModeEnabled ?: false
-            set(value) { defaultSettings?.testingModeEnabled = value }
-
-        override var userAgentString: String?
-            get() = defaultSettings?.userAgentString ?: GeckoSession.getDefaultUserAgent()
-            set(value) { defaultSettings?.userAgentString = value }
-
-        override var preferredColorScheme: PreferredColorScheme
-            get() = PreferredColorScheme.from(runtime.settings.preferredColorScheme)
-            set(value) { runtime.settings.preferredColorScheme = value.toGeckoValue() }
-
-        override var suspendMediaWhenInactive: Boolean
-            get() = defaultSettings?.suspendMediaWhenInactive ?: false
-            set(value) { defaultSettings?.suspendMediaWhenInactive = value }
-
-        override var clearColor: Int?
-            get() = defaultSettings?.clearColor
-            set(value) { defaultSettings?.clearColor = value }
-
-        override var fontInflationEnabled: Boolean?
-            get() = runtime.settings.fontInflationEnabled
-            set(value) {
-                // automaticFontSizeAdjustment is set to true by default, which
-                // will cause an exception if fontInflationEnabled is set
-                // (to either true or false). We therefore need to be able to
-                // set our built-in default value to null so that the exception
-                // is only thrown if an app is configured incorrectly but not
-                // if it uses default values.
-                value?.let {
-                    runtime.settings.fontInflationEnabled = it
-                }
-            }
-
-        override var fontSizeFactor: Float?
-            get() = runtime.settings.fontSizeFactor
-            set(value) {
-                // automaticFontSizeAdjustment is set to true by default, which
-                // will cause an exception if fontSizeFactor is set as well.
-                // We therefore need to be able to set our built-in default value
-                // to null so that the exception is only thrown if an app is
-                // configured incorrectly but not if it uses default values.
-                value?.let {
-                    runtime.settings.fontSizeFactor = it
-                }
-            }
-
-        override var loginAutofillEnabled: Boolean
-            get() = runtime.settings.loginAutofillEnabled
-            set(value) { runtime.settings.loginAutofillEnabled = value }
-
-        override var forceUserScalableContent: Boolean
-            get() = runtime.settings.forceUserScalableEnabled
-            set(value) { runtime.settings.forceUserScalableEnabled = value }
-    }.apply {
-        defaultSettings?.let {
-            this.javascriptEnabled = it.javascriptEnabled
-            this.webFontsEnabled = it.webFontsEnabled
-            this.automaticFontSizeAdjustment = it.automaticFontSizeAdjustment
-            this.automaticLanguageAdjustment = it.automaticLanguageAdjustment
-            this.trackingProtectionPolicy = it.trackingProtectionPolicy
-            this.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.RECOMMENDED)
-            this.remoteDebuggingEnabled = it.remoteDebuggingEnabled
-            this.testingModeEnabled = it.testingModeEnabled
-            this.userAgentString = it.userAgentString
-            this.preferredColorScheme = it.preferredColorScheme
-            this.fontInflationEnabled = it.fontInflationEnabled
-            this.fontSizeFactor = it.fontSizeFactor
-            this.forceUserScalableContent = it.forceUserScalableContent
-            this.clearColor = it.clearColor
-            this.loginAutofillEnabled = it.loginAutofillEnabled
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun ContentBlockingController.LogEntry.BlockingData.getLoadedCategory(): TrackingCategory {
-        val socialTrackingProtectionEnabled = settings.trackingProtectionPolicy?.strictSocialTrackingProtection
-                ?: false
-
-        return when (category) {
-            Event.LOADED_FINGERPRINTING_CONTENT -> TrackingCategory.FINGERPRINTING
-            Event.LOADED_CRYPTOMINING_CONTENT -> TrackingCategory.CRYPTOMINING
-            Event.LOADED_SOCIALTRACKING_CONTENT -> {
-                if (socialTrackingProtectionEnabled) TrackingCategory.MOZILLA_SOCIAL else TrackingCategory.NONE
-            }
-            Event.COOKIES_LOADED_SOCIALTRACKER -> {
-                if (!socialTrackingProtectionEnabled) TrackingCategory.MOZILLA_SOCIAL else TrackingCategory.NONE
-            }
-            Event.LOADED_LEVEL_1_TRACKING_CONTENT -> TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-            Event.LOADED_LEVEL_2_TRACKING_CONTENT -> {
-
-                // We are making sure that we are only showing trackers that our settings are
-                // taking into consideration.
-                val isContentListActive =
-                    settings.trackingProtectionPolicy?.contains(TrackingCategory.CONTENT)
-                        ?: false
-                val isStrictLevelActive =
-                    runtime.settings
-                        .contentBlocking
-                        .getEnhancedTrackingProtectionLevel() == ContentBlocking.EtpLevel.STRICT
-
-                if (isStrictLevelActive && isContentListActive) {
-                    TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-                } else {
-                    TrackingCategory.NONE
-                }
-            }
-            else -> TrackingCategory.NONE
-        }
-    }
-
-    private fun isCategoryActive(category: TrackingCategory) = settings.trackingProtectionPolicy?.contains(category)
-        ?: false
-
-    /**
-     * Mimics the behavior for categorizing trackers from desktop, they should be kept in sync,
-     * as differences will result in improper categorization for trackers.
-     * https://dxr.mozilla.org/mozilla-central/source/browser/base/content/browser-siteProtections.js
-     */
-    internal fun ContentBlockingController.LogEntry.toTrackerLog(): TrackerLog {
-        val cookiesHasBeenBlocked = this.blockingData.any { it.hasBlockedCookies() }
-        val blockedCategories = blockingData.map { it.getBlockedCategory() }
-            .filterNot { it == TrackingCategory.NONE }
-            .distinct()
-        val loadedCategories = blockingData.map { it.getLoadedCategory() }
-            .filterNot { it == TrackingCategory.NONE }
-            .distinct()
-        /**
-         *  When a resource is shimmed we'll received a [REPLACED_UNSAFE_CONTENT] event with
-         *  the quantity [BlockingData.count] of categories that were shimmed, but it doesn't
-         *  specify which ones, it only tells us how many. For example:
-         *     {
-         *      "category": REPLACED_TRACKING_CONTENT,
-         *      "count": 2
-         *     }
-         *
-         *  This indicates that there are 2 categories that were shimmed, as a result
-         *  we have to infer based on the categories that are active vs the amount of
-         *  shimmed categories, for example:
-         *
-         *     "blockData": [
-         *      {
-         *          "category": LOADED_LEVEL_1_TRACKING_CONTENT,
-         *          "count": 1
-         *      },
-         *      {
-         *          "category": LOADED_SOCIALTRACKING_CONTENT,
-         *          "count": 1
-         *      },
-         *      {
-         *          "category": REPLACED_TRACKING_CONTENT,
-         *          "count": 2
-         *      }
-         *     ]
-         *  This indicates that categories [LOADED_LEVEL_1_TRACKING_CONTENT] and
-         *  [LOADED_SOCIALTRACKING_CONTENT] were loaded but shimmed and we should display them
-         *  as blocked instead of loaded.
-         */
-        val shimmedCount = blockingData.find {
-            it.category == Event.REPLACED_TRACKING_CONTENT
-        }?.count ?: 0
-
-        // If we find blocked categories that are loaded it means they were shimmed.
-        val shimmedCategories = loadedCategories.filter { isCategoryActive(it) }
-            .take(shimmedCount)
-
-        // We have to remove the categories that are shimmed from the loaded list and
-        // put them back in the blocked list.
-        return TrackerLog(
-            url = origin,
-            loadedCategories = loadedCategories.filterNot { it in shimmedCategories },
-            blockedCategories = (blockedCategories + shimmedCategories).distinct(),
-            cookiesHasBeenBlocked = cookiesHasBeenBlocked
-        )
-    }
-}
-
-internal fun ContentBlockingController.LogEntry.BlockingData.hasBlockedCookies(): Boolean {
-    return category == Event.COOKIES_BLOCKED_BY_PERMISSION ||
-        category == Event.COOKIES_BLOCKED_TRACKER ||
-        category == Event.COOKIES_BLOCKED_ALL ||
-        category == Event.COOKIES_PARTITIONED_FOREIGN ||
-        category == Event.COOKIES_BLOCKED_FOREIGN ||
-        category == Event.COOKIES_BLOCKED_SOCIALTRACKER
-}
-
-// There is going to be a patch from GV for adding [REPLACED_UNSAFE_CONTENT] as
-// a valid option for [BlockingData.category]
-// https://bugzilla.mozilla.org/show_bug.cgi?id=1669577
-@SuppressLint("SwitchIntDef")
-internal fun ContentBlockingController.LogEntry.BlockingData.getBlockedCategory(): TrackingCategory {
-    return when (category) {
-        Event.BLOCKED_FINGERPRINTING_CONTENT -> TrackingCategory.FINGERPRINTING
-        Event.BLOCKED_CRYPTOMINING_CONTENT -> TrackingCategory.CRYPTOMINING
-        Event.BLOCKED_SOCIALTRACKING_CONTENT, Event.COOKIES_BLOCKED_SOCIALTRACKER -> TrackingCategory.MOZILLA_SOCIAL
-        Event.BLOCKED_TRACKING_CONTENT -> TrackingCategory.SCRIPTS_AND_SUB_RESOURCES
-        else -> TrackingCategory.NONE
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt
deleted file mode 100644
index 490e9ff6e29b..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSession.kt
+++ /dev/null
@@ -1,1118 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.annotation.SuppressLint
-import android.net.Uri
-import android.os.Build
-import android.view.WindowManager
-import androidx.annotation.VisibleForTesting
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.MainScope
-import kotlinx.coroutines.launch
-import mozilla.components.browser.engine.gecko.fetch.toResponse
-import mozilla.components.browser.engine.gecko.mediasession.GeckoMediaSessionDelegate
-import mozilla.components.browser.engine.gecko.permission.GeckoPermissionRequest
-import mozilla.components.browser.engine.gecko.prompt.GeckoPromptDelegate
-import mozilla.components.browser.engine.gecko.window.GeckoWindowRequest
-import mozilla.components.browser.errorpages.ErrorType
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.HitResult
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.content.blocking.Tracker
-import mozilla.components.concept.engine.history.HistoryItem
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.manifest.WebAppManifestParser
-import mozilla.components.concept.engine.request.RequestInterceptor
-import mozilla.components.concept.engine.request.RequestInterceptor.InterceptionResponse
-import mozilla.components.concept.engine.window.WindowRequest
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_DISPOSITION
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_LENGTH
-import mozilla.components.concept.fetch.Headers.Names.CONTENT_TYPE
-import mozilla.components.concept.storage.PageVisit
-import mozilla.components.concept.storage.RedirectSource
-import mozilla.components.concept.storage.VisitType
-import mozilla.components.support.base.Component
-import mozilla.components.support.base.facts.Action
-import mozilla.components.support.base.facts.Fact
-import mozilla.components.support.base.facts.collect
-import mozilla.components.support.base.log.logger.Logger
-import mozilla.components.support.ktx.kotlin.isEmail
-import mozilla.components.support.ktx.kotlin.isExtensionUrl
-import mozilla.components.support.ktx.kotlin.isGeoLocation
-import mozilla.components.support.ktx.kotlin.isPhone
-import mozilla.components.support.ktx.kotlin.sanitizeFileName
-import mozilla.components.support.ktx.kotlin.tryGetHostFromUrl
-import mozilla.components.support.utils.DownloadUtils
-import org.json.JSONObject
-import org.mozilla.geckoview.WebResponse
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.NavigationDelegate
-import org.mozilla.geckoview.GeckoSessionSettings
-import org.mozilla.geckoview.WebRequestError
-import java.util.Locale
-import kotlin.coroutines.CoroutineContext
-
-/**
- * Gecko-based EngineSession implementation.
- */
-@Suppress("TooManyFunctions", "LargeClass")
-class GeckoEngineSession(
-    private val runtime: GeckoRuntime,
-    private val privateMode: Boolean = false,
-    private val defaultSettings: Settings? = null,
-    contextId: String? = null,
-    private val geckoSessionProvider: () -> GeckoSession = {
-        val settings = GeckoSessionSettings.Builder()
-            .usePrivateMode(privateMode)
-            .contextId(contextId)
-            .build()
-        GeckoSession(settings)
-    },
-    private val context: CoroutineContext = Dispatchers.IO,
-    openGeckoSession: Boolean = true
-) : CoroutineScope, EngineSession() {
-
-    // This logger is temporary and parsed by FNPRMS for performance measurements. It can be
-    // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-    // It mimics GeckoView debug log statements, hence the unintuitive tag and messages.
-    private val fnprmsLogger = Logger("GeckoSession")
-
-    private val logger = Logger("GeckoEngineSession")
-
-    internal lateinit var geckoSession: GeckoSession
-    internal var currentUrl: String? = null
-    internal var lastLoadRequestUri: String? = null
-    internal var pageLoadingUrl: String? = null
-    internal var scrollY: Int = 0
-
-    internal var job: Job = Job()
-    private var canGoBack: Boolean = false
-
-    /**
-     * See [EngineSession.settings]
-     */
-    override val settings: Settings = object : Settings() {
-        override var requestInterceptor: RequestInterceptor? = null
-        override var historyTrackingDelegate: HistoryTrackingDelegate? = null
-        override var userAgentString: String?
-            get() = geckoSession.settings.userAgentOverride
-            set(value) { geckoSession.settings.userAgentOverride = value }
-        override var suspendMediaWhenInactive: Boolean
-            get() = geckoSession.settings.suspendMediaWhenInactive
-            set(value) { geckoSession.settings.suspendMediaWhenInactive = value }
-    }
-
-    internal var initialLoad = true
-
-    override val coroutineContext: CoroutineContext
-        get() = context + job
-
-    init {
-        createGeckoSession(shouldOpen = openGeckoSession)
-    }
-
-    /**
-     * Represents a request to load a [url].
-     *
-     * @param url the url to load.
-     * @param parent the parent (referring) [EngineSession] i.e. the session that
-     * triggered creating this one.
-     * @param flags the [LoadUrlFlags] to use when loading the provided url.
-     * @param additionalHeaders the extra headers to use when loading the provided url.
-     **/
-    data class LoadRequest(
-        val url: String,
-        val parent: EngineSession?,
-        val flags: LoadUrlFlags,
-        val additionalHeaders: Map<String, String>?
-    )
-    @VisibleForTesting
-    internal var initialLoadRequest: LoadRequest? = null
-
-    /**
-     * See [EngineSession.loadUrl]
-     */
-    override fun loadUrl(
-        url: String,
-        parent: EngineSession?,
-        flags: LoadUrlFlags,
-        additionalHeaders: Map<String, String>?
-    ) {
-        val scheme = Uri.parse(url).normalizeScheme().scheme
-        if (BLOCKED_SCHEMES.contains(scheme)) {
-            logger.error("URL scheme not allowed. Aborting load.")
-            return
-        }
-
-        if (initialLoad) {
-            initialLoadRequest = LoadRequest(url, parent, flags, additionalHeaders)
-        }
-
-        val loader = GeckoSession.Loader()
-            .uri(url)
-            .flags(flags.value)
-
-        if (additionalHeaders != null) {
-            loader.additionalHeaders(additionalHeaders)
-                .headerFilter(GeckoSession.HEADER_FILTER_CORS_SAFELISTED)
-        }
-
-        if (parent != null) {
-            loader.referrer((parent as GeckoEngineSession).geckoSession)
-        }
-
-        geckoSession.load(loader)
-        Fact(Component.BROWSER_ENGINE_GECKO_NIGHTLY, Action.IMPLEMENTATION_DETAIL, "GeckoSession.load").collect()
-    }
-
-    /**
-     * See [EngineSession.loadData]
-     */
-    override fun loadData(data: String, mimeType: String, encoding: String) {
-        when (encoding) {
-            "base64" -> geckoSession.load(GeckoSession.Loader().data(data.toByteArray(), mimeType))
-            else -> geckoSession.load(GeckoSession.Loader().data(data, mimeType))
-        }
-    }
-
-    /**
-     * See [EngineSession.stopLoading]
-     */
-    override fun stopLoading() {
-        geckoSession.stop()
-    }
-
-    /**
-     * See [EngineSession.reload]
-     */
-    override fun reload(flags: LoadUrlFlags) {
-        initialLoadRequest?.let {
-            // We have a pending initial load request, which means we never
-            // successfully loaded a page. Calling reload now would just reload
-            // about:blank. To prevent that we trigger the initial load again.
-            loadUrl(it.url, it.parent, it.flags, it.additionalHeaders)
-        } ?: geckoSession.reload(flags.value)
-    }
-
-    /**
-     * See [EngineSession.goBack]
-     */
-    override fun goBack() {
-        geckoSession.goBack()
-        if (canGoBack) {
-            notifyObservers { onNavigateBack() }
-        }
-    }
-    /**
-     * See [EngineSession.goForward]
-     */
-    override fun goForward() {
-        geckoSession.goForward()
-    }
-
-    /**
-     * See [EngineSession.goToHistoryIndex]
-     */
-    override fun goToHistoryIndex(index: Int) {
-        geckoSession.gotoHistoryIndex(index)
-    }
-
-    /**
-     * See [EngineSession.restoreState]
-     */
-    override fun restoreState(state: EngineSessionState): Boolean {
-        if (state !is GeckoEngineSessionState) {
-            throw IllegalStateException("Can only restore from GeckoEngineSessionState")
-        }
-        // Also checking if SessionState is empty as a workaround for:
-        // https://bugzilla.mozilla.org/show_bug.cgi?id=1687523
-        if (state.actualState.isNullOrEmpty()) {
-            return false
-        }
-
-        geckoSession.restoreState(state.actualState)
-        return true
-    }
-
-    /**
-     * See [EngineSession.updateTrackingProtection]
-     */
-    override fun updateTrackingProtection(policy: TrackingProtectionPolicy) {
-        updateContentBlocking(policy)
-        val enabled = policy != TrackingProtectionPolicy.none()
-        etpEnabled = enabled
-        notifyObservers {
-            onTrackerBlockingEnabledChange(this, enabled)
-        }
-    }
-
-    @VisibleForTesting
-    internal fun updateContentBlocking(policy: TrackingProtectionPolicy) {
-        /**
-         * As described on https://bugzilla.mozilla.org/show_bug.cgi?id=1579264,useTrackingProtection
-         * is a misleading setting. When is set to true is blocking content (scripts/sub-resources).
-         * Instead of just turn on/off tracking protection. Until, this issue is fixed consumers need
-         * a way to indicate, if they want to block content or not, this is why we use
-         * [TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES].
-         */
-        val shouldBlockContent =
-            policy.contains(TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)
-
-        val enabledInBrowsingMode = if (privateMode) {
-            policy.useForPrivateSessions
-        } else {
-            policy.useForRegularSessions
-        }
-        geckoSession.settings.useTrackingProtection = enabledInBrowsingMode && shouldBlockContent
-    }
-
-    // This is a temporary solution to address
-    // https://github.com/mozilla-mobile/android-components/issues/8431
-    // until we eventually delete [EngineObserver] then this will not be needed.
-    @VisibleForTesting internal var etpEnabled: Boolean? = null
-
-    override fun register(observer: Observer) {
-        super.register(observer)
-        etpEnabled?.let { enabled ->
-            onTrackerBlockingEnabledChange(observer, enabled)
-        }
-    }
-
-    private fun onTrackerBlockingEnabledChange(observer: Observer, enabled: Boolean) {
-        // We now register engine observers in a middleware using a dedicated
-        // store thread. Since this notification can be delayed until an observer
-        // is registered we switch to the main scope to make sure we're not notifying
-        // on the store thread.
-        MainScope().launch {
-            observer.onTrackerBlockingEnabledChange(enabled)
-        }
-    }
-
-    /**
-     * Indicates if this [EngineSession] should be ignored the tracking protection policies.
-     * @param onResult A callback to inform if this [EngineSession] is in
-     * the exception list, true if it is in, otherwise false.
-     */
-    internal fun isIgnoredForTrackingProtection(onResult: (Boolean) -> Unit) {
-        runtime.contentBlockingController.checkException(geckoSession).accept {
-            if (it != null) {
-                onResult(it)
-            } else {
-                onResult(false)
-            }
-        }
-    }
-
-    /**
-     * See [EngineSession.settings]
-     */
-    override fun toggleDesktopMode(enable: Boolean, reload: Boolean) {
-        val currentMode = geckoSession.settings.userAgentMode
-        val currentViewPortMode = geckoSession.settings.viewportMode
-        var overrideUrl: String? = null
-
-        val newMode = if (enable) {
-            GeckoSessionSettings.USER_AGENT_MODE_DESKTOP
-        } else {
-            GeckoSessionSettings.USER_AGENT_MODE_MOBILE
-        }
-
-        val newViewportMode = if (enable) {
-            overrideUrl = currentUrl?.let { checkForMobileSite(it) }
-            GeckoSessionSettings.VIEWPORT_MODE_DESKTOP
-        } else {
-            GeckoSessionSettings.VIEWPORT_MODE_MOBILE
-        }
-
-        if (newMode != currentMode || newViewportMode != currentViewPortMode) {
-            geckoSession.settings.userAgentMode = newMode
-            geckoSession.settings.viewportMode = newViewportMode
-            notifyObservers { onDesktopModeChange(enable) }
-        }
-
-        if (reload) {
-            if (overrideUrl == null) {
-                this.reload()
-            } else {
-                loadUrl(overrideUrl, flags = LoadUrlFlags.select(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY))
-            }
-        }
-    }
-
-    /**
-     * Checks and returns a non-mobile version of the url.
-     */
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun checkForMobileSite(url: String): String? {
-        var overrideUrl: String? = null
-        val mPrefix = "m."
-        val mobilePrefix = "mobile."
-
-        val uri = Uri.parse(url)
-        val authority = uri.authority?.toLowerCase(Locale.ROOT) ?: return null
-
-        val foundPrefix = when {
-            authority.startsWith(mPrefix) -> mPrefix
-            authority.startsWith(mobilePrefix) -> mobilePrefix
-            else -> null
-        }
-
-        foundPrefix?.let {
-            val mobileUri = Uri.parse(url).buildUpon().authority(authority.substring(it.length))
-            overrideUrl = mobileUri.toString()
-        }
-
-        return overrideUrl
-    }
-
-    /**
-     * See [EngineSession.findAll]
-     */
-    override fun findAll(text: String) {
-        notifyObservers { onFind(text) }
-        geckoSession.finder.find(text, 0).then { result: GeckoSession.FinderResult? ->
-            result?.let {
-                val activeMatchOrdinal = if (it.current > 0) it.current - 1 else it.current
-                notifyObservers { onFindResult(activeMatchOrdinal, it.total, true) }
-            }
-            GeckoResult<Void>()
-        }
-    }
-
-    /**
-     * See [EngineSession.findNext]
-     */
-    @SuppressLint("WrongConstant") // FinderFindFlags annotation doesn't include a 0 value.
-    override fun findNext(forward: Boolean) {
-        val findFlags = if (forward) 0 else GeckoSession.FINDER_FIND_BACKWARDS
-        geckoSession.finder.find(null, findFlags).then { result: GeckoSession.FinderResult? ->
-            result?.let {
-                val activeMatchOrdinal = if (it.current > 0) it.current - 1 else it.current
-                notifyObservers { onFindResult(activeMatchOrdinal, it.total, true) }
-            }
-            GeckoResult<Void>()
-        }
-    }
-
-    /**
-     * See [EngineSession.clearFindMatches]
-     */
-    override fun clearFindMatches() {
-        geckoSession.finder.clear()
-    }
-
-    /**
-     * See [EngineSession.exitFullScreenMode]
-     */
-    override fun exitFullScreenMode() {
-        geckoSession.exitFullScreen()
-    }
-
-    /**
-     * See [EngineSession.markActiveForWebExtensions].
-     */
-    override fun markActiveForWebExtensions(active: Boolean) {
-        runtime.webExtensionController.setTabActive(geckoSession, active)
-    }
-
-    /**
-     * Purges the history for the session (back and forward history).
-     */
-    override fun purgeHistory() {
-        geckoSession.purgeHistory()
-    }
-
-    /**
-     * See [EngineSession.close].
-     */
-    override fun close() {
-        super.close()
-        job.cancel()
-        geckoSession.close()
-    }
-
-    /**
-     * NavigationDelegate implementation for forwarding callbacks to observers of the session.
-     */
-    @Suppress("ComplexMethod")
-    private fun createNavigationDelegate() = object : GeckoSession.NavigationDelegate {
-        override fun onLocationChange(session: GeckoSession, url: String?) {
-            if (url == null) {
-                return // \_()_/
-            }
-
-            // Ignore initial loads of about:blank, see:
-            // https://github.com/mozilla-mobile/android-components/issues/403
-            // https://github.com/mozilla-mobile/android-components/issues/6832
-            if (initialLoad && url == ABOUT_BLANK) {
-                return
-            }
-
-            currentUrl = url
-            initialLoad = false
-            initialLoadRequest = null
-
-            isIgnoredForTrackingProtection { ignored ->
-                notifyObservers {
-                    onExcludedOnTrackingProtectionChange(ignored)
-                }
-            }
-            notifyObservers { onLocationChange(url) }
-        }
-
-        override fun onLoadRequest(
-            session: GeckoSession,
-            request: NavigationDelegate.LoadRequest
-        ): GeckoResult<AllowOrDeny> {
-            // The process switch involved when loading extension pages will
-            // trigger an initial load of about:blank which we want to
-            // avoid:
-            // https://github.com/mozilla-mobile/android-components/issues/6832
-            // https://github.com/mozilla-mobile/android-components/issues/403
-            if (currentUrl?.isExtensionUrl() != request.uri.isExtensionUrl()) {
-                initialLoad = true
-            }
-
-            return when {
-                maybeInterceptRequest(request, false) != null ->
-                    GeckoResult.fromValue(AllowOrDeny.DENY)
-                request.target == NavigationDelegate.TARGET_WINDOW_NEW ->
-                    GeckoResult.fromValue(AllowOrDeny.ALLOW)
-                else -> {
-                    notifyObservers {
-                        onLoadRequest(
-                            url = request.uri,
-                            triggeredByRedirect = request.isRedirect,
-                            triggeredByWebContent = request.hasUserGesture
-                        )
-                    }
-
-                    GeckoResult.fromValue(AllowOrDeny.ALLOW)
-                }
-            }
-        }
-
-        override fun onSubframeLoadRequest(
-            session: GeckoSession,
-            request: NavigationDelegate.LoadRequest
-        ): GeckoResult<AllowOrDeny> {
-            if (request.target == NavigationDelegate.TARGET_WINDOW_NEW) {
-                return GeckoResult.fromValue(AllowOrDeny.ALLOW)
-            }
-
-            return if (maybeInterceptRequest(request, true) != null) {
-                GeckoResult.fromValue(AllowOrDeny.DENY)
-            } else {
-                // Not notifying session observer because of performance concern and currently there
-                // is no use case.
-                GeckoResult.fromValue(AllowOrDeny.ALLOW)
-            }
-        }
-
-        override fun onCanGoForward(session: GeckoSession, canGoForward: Boolean) {
-            notifyObservers { onNavigationStateChange(canGoForward = canGoForward) }
-        }
-
-        override fun onCanGoBack(session: GeckoSession, canGoBack: Boolean) {
-            notifyObservers { onNavigationStateChange(canGoBack = canGoBack) }
-            this@GeckoEngineSession.canGoBack = canGoBack
-        }
-
-        override fun onNewSession(
-            session: GeckoSession,
-            uri: String
-        ): GeckoResult<GeckoSession> {
-            val newEngineSession = GeckoEngineSession(runtime, privateMode, defaultSettings, openGeckoSession = false)
-            notifyObservers {
-                MainScope().launch {
-                    onWindowRequest(GeckoWindowRequest(uri, newEngineSession))
-                }
-            }
-            return GeckoResult.fromValue(newEngineSession.geckoSession)
-        }
-
-        override fun onLoadError(
-            session: GeckoSession,
-            uri: String?,
-            error: WebRequestError
-        ): GeckoResult<String> {
-            val response = settings.requestInterceptor?.onErrorRequest(
-                this@GeckoEngineSession,
-                geckoErrorToErrorType(error.code),
-                uri
-            )
-            return GeckoResult.fromValue(response?.uri)
-        }
-
-        private fun maybeInterceptRequest(
-            request: NavigationDelegate.LoadRequest,
-            isSubframeRequest: Boolean
-        ): InterceptionResponse? {
-            val interceptor = settings.requestInterceptor
-            val interceptionResponse = if (
-                interceptor != null && (!request.isDirectNavigation || interceptor.interceptsAppInitiatedRequests())
-            ) {
-                val engineSession = this@GeckoEngineSession
-                val isSameDomain = engineSession.currentUrl?.tryGetHostFromUrl() == request.uri.tryGetHostFromUrl()
-                interceptor.onLoadRequest(
-                    engineSession,
-                    request.uri,
-                    lastLoadRequestUri,
-                    request.hasUserGesture,
-                    isSameDomain,
-                    request.isRedirect,
-                    request.isDirectNavigation,
-                    isSubframeRequest
-                )?.apply {
-                    when (this) {
-                        is InterceptionResponse.Content -> loadData(data, mimeType, encoding)
-                        is InterceptionResponse.Url -> loadUrl(url)
-                        is InterceptionResponse.AppIntent -> {
-                            notifyObservers {
-                                onLaunchIntentRequest(url = url, appIntent = appIntent)
-                            }
-                        }
-                    }
-                }
-            } else {
-                null
-            }
-
-            lastLoadRequestUri = request.uri
-            return interceptionResponse
-        }
-    }
-
-    /**
-     * ProgressDelegate implementation for forwarding callbacks to observers of the session.
-     */
-    private fun createProgressDelegate() = object : GeckoSession.ProgressDelegate {
-        override fun onProgressChange(session: GeckoSession, progress: Int) {
-            notifyObservers { onProgress(progress) }
-        }
-
-        override fun onSecurityChange(
-            session: GeckoSession,
-            securityInfo: GeckoSession.ProgressDelegate.SecurityInformation
-        ) {
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && securityInfo.origin?.startsWith(MOZ_NULL_PRINCIPAL) == true) {
-                return
-            }
-
-            notifyObservers {
-                // TODO provide full certificate info: https://github.com/mozilla-mobile/android-components/issues/5557
-                onSecurityChange(securityInfo.isSecure, securityInfo.host, securityInfo.getIssuerName())
-            }
-        }
-
-        override fun onPageStart(session: GeckoSession, url: String) {
-            // This log statement is temporary and parsed by FNPRMS for performance measurements. It can be
-            // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-            fnprmsLogger.info("handleMessage GeckoView:PageStart uri=") // uri intentionally blank
-
-            pageLoadingUrl = url
-
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && url == ABOUT_BLANK) {
-                return
-            }
-
-            notifyObservers {
-                onProgress(PROGRESS_START)
-                onLoadingStateChange(true)
-            }
-        }
-
-        override fun onPageStop(session: GeckoSession, success: Boolean) {
-            // This log statement is temporary and parsed by FNPRMS for performance measurements. It can be
-            // removed once FNPRMS is replaced: https://github.com/mozilla-mobile/android-components/issues/8662
-            fnprmsLogger.info("handleMessage GeckoView:PageStop uri=null") // uri intentionally hard-coded to null
-            // by the time we reach here, any new request will come from web content.
-            // If it comes from the chrome, loadUrl(url) or loadData(string) will set it to
-            // false.
-
-            // Ignore initial load of about:blank (see https://github.com/mozilla-mobile/android-components/issues/403)
-            if (initialLoad && pageLoadingUrl == ABOUT_BLANK) {
-                return
-            }
-
-            notifyObservers {
-                onProgress(PROGRESS_STOP)
-                onLoadingStateChange(false)
-            }
-        }
-
-        override fun onSessionStateChange(session: GeckoSession, sessionState: GeckoSession.SessionState) {
-            notifyObservers {
-                onStateUpdated(GeckoEngineSessionState(sessionState))
-            }
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun createHistoryDelegate() = object : GeckoSession.HistoryDelegate {
-        @SuppressWarnings("ReturnCount")
-        override fun onVisited(
-            session: GeckoSession,
-            url: String,
-            lastVisitedURL: String?,
-            flags: Int
-        ): GeckoResult<Boolean>? {
-            // Don't track:
-            // - private visits
-            // - error pages
-            // - non-top level visits (i.e. iframes).
-            if (privateMode ||
-                (flags and GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL) == 0 ||
-                (flags and GeckoSession.HistoryDelegate.VISIT_UNRECOVERABLE_ERROR) != 0) {
-                return GeckoResult.fromValue(false)
-            }
-
-            val isReload = lastVisitedURL?.let { it == url } ?: false
-
-            val visitType = if (isReload) {
-                VisitType.RELOAD
-            } else {
-                // Note the difference between `VISIT_REDIRECT_PERMANENT`,
-                // `VISIT_REDIRECT_TEMPORARY`, `VISIT_REDIRECT_SOURCE`, and
-                // `VISIT_REDIRECT_SOURCE_PERMANENT`.
-                //
-                // The former two indicate if the visited page is the *target*
-                // of a redirect; that is, another page redirected to it.
-                //
-                // The latter two indicate if the visited page is the *source*
-                // of a redirect: it's redirecting to another page, because the
-                // server returned an HTTP 3xy status code.
-                if (flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_PERMANENT != 0) {
-                    VisitType.REDIRECT_PERMANENT
-                } else if (flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY != 0) {
-                    VisitType.REDIRECT_TEMPORARY
-                } else {
-                    VisitType.LINK
-                }
-            }
-            val redirectSource = when {
-                flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE_PERMANENT != 0 ->
-                    RedirectSource.PERMANENT
-                flags and GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE != 0 ->
-                    RedirectSource.TEMPORARY
-                else -> RedirectSource.NOT_A_SOURCE
-            }
-
-            val delegate = settings.historyTrackingDelegate ?: return GeckoResult.fromValue(false)
-
-            // Check if the delegate wants this type of url.
-            if (!delegate.shouldStoreUri(url)) {
-                return GeckoResult.fromValue(false)
-            }
-
-            return launchGeckoResult {
-                delegate.onVisited(url, PageVisit(visitType, redirectSource))
-                true
-            }
-        }
-
-        override fun getVisited(
-            session: GeckoSession,
-            urls: Array<out String>
-        ): GeckoResult<BooleanArray>? {
-            if (privateMode) {
-                return GeckoResult.fromValue(null)
-            }
-
-            val delegate = settings.historyTrackingDelegate ?: return GeckoResult.fromValue(null)
-
-            return launchGeckoResult {
-                val visits = delegate.getVisited(urls.toList())
-                visits.toBooleanArray()
-            }
-        }
-
-        override fun onHistoryStateChange(
-            session: GeckoSession,
-            historyList: GeckoSession.HistoryDelegate.HistoryList
-        ) {
-            val items = historyList.map {
-                // title is sometimes null despite the @NotNull annotation
-                // https://bugzilla.mozilla.org/show_bug.cgi?id=1660286
-                val title: String? = it.title
-                HistoryItem(
-                    title = title ?: it.uri,
-                    uri = it.uri
-                )
-            }
-            notifyObservers { onHistoryStateChanged(items, historyList.currentIndex) }
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    internal fun createContentDelegate() = object : GeckoSession.ContentDelegate {
-        override fun onFirstComposite(session: GeckoSession) = Unit
-
-        override fun onFirstContentfulPaint(session: GeckoSession) {
-            notifyObservers { onFirstContentfulPaint() }
-        }
-
-        override fun onPaintStatusReset(session: GeckoSession) {
-            notifyObservers { onPaintStatusReset() }
-        }
-
-        override fun onContextMenu(
-            session: GeckoSession,
-            screenX: Int,
-            screenY: Int,
-            element: GeckoSession.ContentDelegate.ContextElement
-        ) {
-            val hitResult = handleLongClick(element.srcUri, element.type, element.linkUri, element.title)
-            hitResult?.let {
-                notifyObservers { onLongPress(it) }
-            }
-        }
-
-        override fun onCrash(session: GeckoSession) {
-            notifyObservers { onCrash() }
-        }
-
-        override fun onKill(session: GeckoSession) {
-            notifyObservers {
-                onProcessKilled()
-            }
-        }
-
-        private fun recoverGeckoSession() {
-            // Recover the GeckoSession after the process getting killed or crashing. We create a
-            // new underlying GeckoSession.
-            // Eventually we may be able to re-use the same GeckoSession by re-opening it. However
-            // that seems to have caused issues:
-            // https://github.com/mozilla-mobile/android-components/issues/3640
-
-            geckoSession.close()
-            createGeckoSession()
-        }
-
-        override fun onFullScreen(session: GeckoSession, fullScreen: Boolean) {
-            notifyObservers { onFullScreenChange(fullScreen) }
-        }
-
-        override fun onExternalResponse(session: GeckoSession, webResponse: WebResponse) {
-            with(webResponse) {
-                val contentType = headers[CONTENT_TYPE]?.trim()
-                val contentLength = headers[CONTENT_LENGTH]?.trim()?.toLong()
-                val contentDisposition = headers[CONTENT_DISPOSITION]?.trim()
-                val url = uri
-                val fileName = DownloadUtils.guessFileName(
-                    contentDisposition,
-                    destinationDirectory = null,
-                    url = url,
-                    mimeType = contentType
-                )
-                val response = webResponse.toResponse()
-
-                notifyObservers {
-                    onExternalResource(
-                            url = url,
-                            contentLength = contentLength,
-                            contentType = DownloadUtils.sanitizeMimeType(contentType),
-                            fileName = fileName.sanitizeFileName(),
-                            response = response,
-                            isPrivate = privateMode
-                    )
-                }
-            }
-        }
-
-        override fun onCloseRequest(session: GeckoSession) {
-            notifyObservers {
-                onWindowRequest(GeckoWindowRequest(
-                        engineSession = this@GeckoEngineSession,
-                        type = WindowRequest.Type.CLOSE
-                    )
-                )
-            }
-        }
-
-        override fun onTitleChange(session: GeckoSession, title: String?) {
-            if (!privateMode) {
-                currentUrl?.let { url ->
-                    settings.historyTrackingDelegate?.let { delegate ->
-                        // NB: There's no guarantee that the title change will be processed by the
-                        // delegate before the session is closed (and the corresponding coroutine
-                        // job is cancelled). Observers will always be notified of the title
-                        // change though.
-                        launch(coroutineContext) {
-                            delegate.onTitleChanged(url, title ?: "")
-                        }
-                    }
-                }
-            }
-            notifyObservers { onTitleChange(title ?: "") }
-        }
-
-        override fun onFocusRequest(session: GeckoSession) = Unit
-
-        override fun onWebAppManifest(session: GeckoSession, manifest: JSONObject) {
-            val parsed = WebAppManifestParser().parse(manifest)
-            if (parsed is WebAppManifestParser.Result.Success) {
-                notifyObservers { onWebAppManifestLoaded(parsed.manifest) }
-            }
-        }
-
-        override fun onMetaViewportFitChange(session: GeckoSession, viewportFit: String) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-                val layoutInDisplayCutoutMode = when (viewportFit) {
-                    "cover" -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
-                    "contain" -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
-                    else -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
-                }
-
-                notifyObservers { onMetaViewportFitChanged(layoutInDisplayCutoutMode) }
-            }
-        }
-    }
-
-    private fun createContentBlockingDelegate() = object : ContentBlocking.Delegate {
-        override fun onContentBlocked(session: GeckoSession, event: ContentBlocking.BlockEvent) {
-            notifyObservers {
-                onTrackerBlocked(event.toTracker())
-            }
-        }
-
-        override fun onContentLoaded(session: GeckoSession, event: ContentBlocking.BlockEvent) {
-            notifyObservers {
-                onTrackerLoaded(event.toTracker())
-            }
-        }
-    }
-
-    private fun ContentBlocking.BlockEvent.toTracker(): Tracker {
-        val blockedContentCategories = mutableListOf<TrackingProtectionPolicy.TrackingCategory>()
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.AD)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.AD)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.ANALYTIC)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.ANALYTICS)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.SOCIAL)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.SOCIAL)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.FINGERPRINTING)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.FINGERPRINTING)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.CRYPTOMINING)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.CRYPTOMINING)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.CONTENT)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.CONTENT)
-        }
-
-        if (antiTrackingCategory.contains(ContentBlocking.AntiTracking.TEST)) {
-            blockedContentCategories.add(TrackingProtectionPolicy.TrackingCategory.TEST)
-        }
-
-        return Tracker(
-            url = uri,
-            trackingCategories = blockedContentCategories,
-            cookiePolicies = getCookiePolicies()
-        )
-    }
-
-    private fun ContentBlocking.BlockEvent.getCookiePolicies(): List<TrackingProtectionPolicy.CookiePolicy> {
-        val cookiesPolicies = mutableListOf<TrackingProtectionPolicy.CookiePolicy>()
-
-        if (cookieBehaviorCategory == ContentBlocking.CookieBehavior.ACCEPT_ALL) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_ALL)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_FIRST_PARTY)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_ONLY_FIRST_PARTY)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_NONE)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_NONE)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_NON_TRACKERS)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_NON_TRACKERS)
-        }
-
-        if (cookieBehaviorCategory.contains(ContentBlocking.CookieBehavior.ACCEPT_VISITED)) {
-            cookiesPolicies.add(TrackingProtectionPolicy.CookiePolicy.ACCEPT_VISITED)
-        }
-
-        return cookiesPolicies
-    }
-
-    internal fun GeckoSession.ProgressDelegate.SecurityInformation.getIssuerName(): String? {
-        return certificate?.issuerDN?.name?.substringAfterLast("O=")?.substringBeforeLast(",C=")
-    }
-
-    private operator fun Int.contains(mask: Int): Boolean {
-        return (this and mask) != 0
-    }
-
-    private fun createPermissionDelegate() = object : GeckoSession.PermissionDelegate {
-        override fun onContentPermissionRequest(
-            session: GeckoSession,
-            uri: String?,
-            type: Int,
-            callback: GeckoSession.PermissionDelegate.Callback
-        ) {
-            val request = GeckoPermissionRequest.Content(uri ?: "", type, callback)
-            notifyObservers { onContentPermissionRequest(request) }
-        }
-
-        override fun onMediaPermissionRequest(
-            session: GeckoSession,
-            uri: String,
-            video: Array<out GeckoSession.PermissionDelegate.MediaSource>?,
-            audio: Array<out GeckoSession.PermissionDelegate.MediaSource>?,
-            callback: GeckoSession.PermissionDelegate.MediaCallback
-        ) {
-            val request = GeckoPermissionRequest.Media(
-                    uri,
-                    video?.toList() ?: emptyList(),
-                    audio?.toList() ?: emptyList(),
-                    callback)
-            notifyObservers { onContentPermissionRequest(request) }
-        }
-
-        override fun onAndroidPermissionsRequest(
-            session: GeckoSession,
-            permissions: Array<out String>?,
-            callback: GeckoSession.PermissionDelegate.Callback
-        ) {
-            val request = GeckoPermissionRequest.App(
-                    permissions?.toList() ?: emptyList(),
-                    callback)
-            notifyObservers { onAppPermissionRequest(request) }
-        }
-    }
-
-    private fun createScrollDelegate() = object : GeckoSession.ScrollDelegate {
-        override fun onScrollChanged(session: GeckoSession, scrollX: Int, scrollY: Int) {
-            this@GeckoEngineSession.scrollY = scrollY
-        }
-    }
-
-    @Suppress("ComplexMethod")
-    fun handleLongClick(elementSrc: String?, elementType: Int, uri: String? = null, title: String? = null): HitResult? {
-        return when (elementType) {
-            GeckoSession.ContentDelegate.ContextElement.TYPE_AUDIO ->
-                elementSrc?.let {
-                    HitResult.AUDIO(it, title)
-                }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_VIDEO ->
-                elementSrc?.let {
-                    HitResult.VIDEO(it, title)
-                }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE -> {
-                when {
-                    elementSrc != null && uri != null ->
-                        HitResult.IMAGE_SRC(elementSrc, uri)
-                    elementSrc != null ->
-                        HitResult.IMAGE(elementSrc, title)
-                    else -> HitResult.UNKNOWN("")
-                }
-            }
-            GeckoSession.ContentDelegate.ContextElement.TYPE_NONE -> {
-                elementSrc?.let {
-                    when {
-                        it.isPhone() -> HitResult.PHONE(it)
-                        it.isEmail() -> HitResult.EMAIL(it)
-                        it.isGeoLocation() -> HitResult.GEO(it)
-                        else -> HitResult.UNKNOWN(it)
-                    }
-                } ?: uri?.let {
-                    HitResult.UNKNOWN(it)
-                }
-            }
-            else -> HitResult.UNKNOWN("")
-        }
-    }
-
-    private fun createGeckoSession(shouldOpen: Boolean = true) {
-        this.geckoSession = geckoSessionProvider()
-
-        defaultSettings?.trackingProtectionPolicy?.let { updateTrackingProtection(it) }
-        defaultSettings?.requestInterceptor?.let { settings.requestInterceptor = it }
-        defaultSettings?.historyTrackingDelegate?.let { settings.historyTrackingDelegate = it }
-        defaultSettings?.testingModeEnabled?.let { geckoSession.settings.fullAccessibilityTree = it }
-        defaultSettings?.userAgentString?.let { geckoSession.settings.userAgentOverride = it }
-        defaultSettings?.suspendMediaWhenInactive?.let { geckoSession.settings.suspendMediaWhenInactive = it }
-        defaultSettings?.clearColor?.let { geckoSession.compositorController.clearColor = it }
-
-        if (shouldOpen) {
-            geckoSession.open(runtime)
-        }
-
-        geckoSession.navigationDelegate = createNavigationDelegate()
-        geckoSession.progressDelegate = createProgressDelegate()
-        geckoSession.contentDelegate = createContentDelegate()
-        geckoSession.contentBlockingDelegate = createContentBlockingDelegate()
-        geckoSession.permissionDelegate = createPermissionDelegate()
-        geckoSession.promptDelegate = GeckoPromptDelegate(this)
-        geckoSession.historyDelegate = createHistoryDelegate()
-        geckoSession.mediaSessionDelegate = GeckoMediaSessionDelegate(this)
-        geckoSession.scrollDelegate = createScrollDelegate()
-    }
-
-    companion object {
-        internal const val PROGRESS_START = 25
-        internal const val PROGRESS_STOP = 100
-        internal const val MOZ_NULL_PRINCIPAL = "moz-nullprincipal:"
-        internal const val ABOUT_BLANK = "about:blank"
-        internal val BLOCKED_SCHEMES = listOf("content", "file", "resource") // See 1684761 and 1684947
-
-        /**
-         * Provides an ErrorType corresponding to the error code provided.
-         */
-        @Suppress("ComplexMethod")
-        internal fun geckoErrorToErrorType(errorCode: Int) =
-            when (errorCode) {
-                WebRequestError.ERROR_UNKNOWN -> ErrorType.UNKNOWN
-                WebRequestError.ERROR_SECURITY_SSL -> ErrorType.ERROR_SECURITY_SSL
-                WebRequestError.ERROR_SECURITY_BAD_CERT -> ErrorType.ERROR_SECURITY_BAD_CERT
-                WebRequestError.ERROR_NET_INTERRUPT -> ErrorType.ERROR_NET_INTERRUPT
-                WebRequestError.ERROR_NET_TIMEOUT -> ErrorType.ERROR_NET_TIMEOUT
-                WebRequestError.ERROR_CONNECTION_REFUSED -> ErrorType.ERROR_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_SOCKET_TYPE -> ErrorType.ERROR_UNKNOWN_SOCKET_TYPE
-                WebRequestError.ERROR_REDIRECT_LOOP -> ErrorType.ERROR_REDIRECT_LOOP
-                WebRequestError.ERROR_OFFLINE -> ErrorType.ERROR_OFFLINE
-                WebRequestError.ERROR_PORT_BLOCKED -> ErrorType.ERROR_PORT_BLOCKED
-                WebRequestError.ERROR_NET_RESET -> ErrorType.ERROR_NET_RESET
-                WebRequestError.ERROR_UNSAFE_CONTENT_TYPE -> ErrorType.ERROR_UNSAFE_CONTENT_TYPE
-                WebRequestError.ERROR_CORRUPTED_CONTENT -> ErrorType.ERROR_CORRUPTED_CONTENT
-                WebRequestError.ERROR_CONTENT_CRASHED -> ErrorType.ERROR_CONTENT_CRASHED
-                WebRequestError.ERROR_INVALID_CONTENT_ENCODING -> ErrorType.ERROR_INVALID_CONTENT_ENCODING
-                WebRequestError.ERROR_UNKNOWN_HOST -> ErrorType.ERROR_UNKNOWN_HOST
-                WebRequestError.ERROR_MALFORMED_URI -> ErrorType.ERROR_MALFORMED_URI
-                WebRequestError.ERROR_UNKNOWN_PROTOCOL -> ErrorType.ERROR_UNKNOWN_PROTOCOL
-                WebRequestError.ERROR_FILE_NOT_FOUND -> ErrorType.ERROR_FILE_NOT_FOUND
-                WebRequestError.ERROR_FILE_ACCESS_DENIED -> ErrorType.ERROR_FILE_ACCESS_DENIED
-                WebRequestError.ERROR_PROXY_CONNECTION_REFUSED -> ErrorType.ERROR_PROXY_CONNECTION_REFUSED
-                WebRequestError.ERROR_UNKNOWN_PROXY_HOST -> ErrorType.ERROR_UNKNOWN_PROXY_HOST
-                WebRequestError.ERROR_SAFEBROWSING_MALWARE_URI -> ErrorType.ERROR_SAFEBROWSING_MALWARE_URI
-                WebRequestError.ERROR_SAFEBROWSING_UNWANTED_URI -> ErrorType.ERROR_SAFEBROWSING_UNWANTED_URI
-                WebRequestError.ERROR_SAFEBROWSING_HARMFUL_URI -> ErrorType.ERROR_SAFEBROWSING_HARMFUL_URI
-                WebRequestError.ERROR_SAFEBROWSING_PHISHING_URI -> ErrorType.ERROR_SAFEBROWSING_PHISHING_URI
-                else -> ErrorType.UNKNOWN
-            }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt
deleted file mode 100644
index f6f3501ef2b3..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionState.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.util.JsonReader
-import android.util.JsonWriter
-import mozilla.components.concept.engine.EngineSessionState
-import org.json.JSONException
-import org.json.JSONObject
-import org.mozilla.geckoview.GeckoSession
-import java.io.IOException
-
-private const val GECKO_STATE_KEY = "GECKO_STATE"
-
-class GeckoEngineSessionState internal constructor(
-    internal val actualState: GeckoSession.SessionState?
-) : EngineSessionState {
-    override fun writeTo(writer: JsonWriter) {
-        with(writer) {
-            beginObject()
-
-            name(GECKO_STATE_KEY)
-            value(actualState.toString())
-
-            endObject()
-            flush()
-        }
-    }
-
-    companion object {
-        fun fromJSON(json: JSONObject): GeckoEngineSessionState = try {
-            val state = json.getString(GECKO_STATE_KEY)
-
-            GeckoEngineSessionState(
-                GeckoSession.SessionState.fromString(state)
-            )
-        } catch (e: JSONException) {
-            GeckoEngineSessionState(null)
-        }
-
-        /**
-         * Creates a [GeckoEngineSessionState] from the given [JsonReader].
-         */
-        fun from(reader: JsonReader): GeckoEngineSessionState = try {
-            reader.beginObject()
-
-            val rawState = if (reader.hasNext()) {
-                val key = reader.nextName()
-                if (key != GECKO_STATE_KEY) {
-                    throw AssertionError("Unknown state key: $key")
-                }
-
-                reader.nextString()
-            } else {
-                null
-            }
-
-            reader.endObject()
-
-            GeckoEngineSessionState(
-                rawState?.let { GeckoSession.SessionState.fromString(it) }
-            )
-        } catch (e: IOException) {
-            GeckoEngineSessionState(null)
-        } catch (e: JSONException) {
-            // Internally GeckoView uses org.json and currently may throw JSONException in certain cases
-            // https://github.com/mozilla-mobile/android-components/issues/9332
-            GeckoEngineSessionState(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
deleted file mode 100644
index 14f06596c125..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
+++ /dev/null
@@ -1,219 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.content.res.Configuration
-import android.graphics.Bitmap
-import android.graphics.Color
-import android.util.AttributeSet
-import android.widget.FrameLayout
-import androidx.annotation.VisibleForTesting
-import androidx.core.view.ViewCompat
-import mozilla.components.browser.engine.gecko.selection.GeckoSelectionActionDelegate
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import org.mozilla.geckoview.BasicSelectionActionDelegate
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-
-/**
- * Gecko-based EngineView implementation.
- */
-class GeckoEngineView @JvmOverloads constructor(
-    context: Context,
-    attrs: AttributeSet? = null,
-    defStyleAttr: Int = 0
-) : FrameLayout(context, attrs, defStyleAttr), EngineView {
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var geckoView = object : NestedGeckoView(context) {
-
-        override fun onAttachedToWindow() {
-            try {
-                super.onAttachedToWindow()
-            } catch (e: IllegalStateException) {
-                // This is to debug "display already acquired" crashes
-                val otherActivityClassName =
-                    this.session?.accessibility?.view?.context?.javaClass?.simpleName
-                val otherActivityClassHashcode =
-                    this.session?.accessibility?.view?.context?.hashCode()
-                val activityClassName = context.javaClass.simpleName
-                val activityClassHashCode = context.hashCode()
-                val msg = "ATTACH VIEW: Current activity: $activityClassName hashcode " +
-                        "$activityClassHashCode Other activity: $otherActivityClassName " +
-                        "hashcode $otherActivityClassHashcode"
-                throw IllegalStateException(msg, e)
-            }
-        }
-
-        override fun onDetachedFromWindow() {
-            // We are releasing the session before GeckoView gets detached from the window. Otherwise
-            // GeckoView will close the session automatically and we do not want that.
-            releaseSession()
-
-            super.onDetachedFromWindow()
-        }
-    }.apply {
-        // Explicitly mark this view as important for autofill. The default "auto" doesn't seem to trigger any
-        // autofill behavior for us here.
-        @Suppress("WrongConstant")
-        ViewCompat.setImportantForAutofill(this, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES)
-    }
-
-    internal fun setColorScheme(preferredColorScheme: PreferredColorScheme) {
-        var colorScheme = preferredColorScheme
-        if (preferredColorScheme == PreferredColorScheme.System) {
-            colorScheme =
-                if (context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
-                    == Configuration.UI_MODE_NIGHT_YES
-                ) {
-                    PreferredColorScheme.Dark
-                } else {
-                    PreferredColorScheme.Light
-                }
-        }
-
-        if (colorScheme == PreferredColorScheme.Dark) {
-            geckoView.coverUntilFirstPaint(DARK_COVER)
-        } else {
-            geckoView.coverUntilFirstPaint(Color.WHITE)
-        }
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var currentSession: GeckoEngineSession? = null
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var currentSelection: BasicSelectionActionDelegate? = null
-
-    override var selectionActionDelegate: SelectionActionDelegate? = null
-
-    init {
-        addView(geckoView)
-    }
-
-    /**
-     * Render the content of the given session.
-     */
-    @Synchronized
-    override fun render(session: EngineSession) {
-        val internalSession = session as GeckoEngineSession
-        currentSession = session
-
-        if (geckoView.session != internalSession.geckoSession) {
-            geckoView.session?.let {
-                // Release a previously assigned session. Otherwise GeckoView will close it
-                // automatically.
-                detachSelectionActionDelegate(it)
-                geckoView.releaseSession()
-            }
-
-            try {
-                geckoView.setSession(internalSession.geckoSession)
-                attachSelectionActionDelegate(internalSession.geckoSession)
-            } catch (e: IllegalStateException) {
-                // This is to debug "display already acquired" crashes
-                val otherActivityClassName =
-                    internalSession.geckoSession.accessibility.view?.context?.javaClass?.simpleName
-                val otherActivityClassHashcode =
-                    internalSession.geckoSession.accessibility.view?.context?.hashCode()
-                val activityClassName = context.javaClass.simpleName
-                val activityClassHashCode = context.hashCode()
-                val msg = "SET SESSION: Current activity: $activityClassName hashcode " +
-                        "$activityClassHashCode Other activity: $otherActivityClassName " +
-                        "hashcode $otherActivityClassHashcode"
-                throw IllegalStateException(msg, e)
-            }
-        }
-    }
-
-    private fun attachSelectionActionDelegate(session: GeckoSession) {
-        val delegate = GeckoSelectionActionDelegate.maybeCreate(context, selectionActionDelegate)
-        if (delegate != null) {
-            session.selectionActionDelegate = delegate
-            currentSelection = delegate
-        }
-    }
-
-    private fun detachSelectionActionDelegate(session: GeckoSession?) {
-        if (currentSelection != null) {
-            session?.selectionActionDelegate = null
-            currentSelection = null
-        }
-    }
-
-    @Synchronized
-    override fun release() {
-        detachSelectionActionDelegate(currentSession?.geckoSession)
-
-        currentSession = null
-
-        geckoView.releaseSession()
-    }
-
-    override fun onDetachedFromWindow() {
-        super.onDetachedFromWindow()
-
-        release()
-    }
-
-    override fun canClearSelection() = !currentSelection?.selection?.text.isNullOrEmpty()
-
-    override fun canScrollVerticallyUp() = currentSession?.let { it.scrollY > 0 } != false
-
-    override fun canScrollVerticallyDown() =
-        true // waiting for this issue https://bugzilla.mozilla.org/show_bug.cgi?id=1507569
-
-    override fun getInputResultDetail() = geckoView.inputResultDetail
-
-    override fun setVerticalClipping(clippingHeight: Int) {
-        geckoView.setVerticalClipping(clippingHeight)
-    }
-
-    override fun setDynamicToolbarMaxHeight(height: Int) {
-        geckoView.setDynamicToolbarMaxHeight(height)
-    }
-
-    @Suppress("TooGenericExceptionCaught")
-    override fun captureThumbnail(onFinish: (Bitmap?) -> Unit) {
-        try {
-            val geckoResult = geckoView.capturePixels()
-            geckoResult.then({ bitmap ->
-                onFinish(bitmap)
-                GeckoResult<Void>()
-            }, {
-                onFinish(null)
-                GeckoResult<Void>()
-            })
-        } catch (e: Exception) {
-            // There's currently no reliable way for consumers of GeckoView to
-            // know whether or not the compositor is ready. So we have to add
-            // a catch-all here. In the future, GeckoView will invoke our error
-            // callback instead and this block can be removed:
-            // https://bugzilla.mozilla.org/show_bug.cgi?id=1645114
-            // https://github.com/mozilla-mobile/android-components/issues/6680
-            onFinish(null)
-        }
-    }
-
-    override fun clearSelection() {
-        currentSelection?.clearSelection()
-    }
-
-    override fun setVisibility(visibility: Int) {
-        // GeckoView doesn't react to onVisibilityChanged so we need to propagate ourselves for now:
-        // https://bugzilla.mozilla.org/show_bug.cgi?id=1630775
-        // We do this to prevent the content from resizing when the view is not visible:
-        // https://github.com/mozilla-mobile/android-components/issues/6664
-        geckoView.visibility = visibility
-        super.setVisibility(visibility)
-    }
-
-    companion object {
-        internal const val DARK_COVER = 0xFF2A2A2E.toInt()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt
deleted file mode 100644
index 7ae791694b73..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/GeckoResult.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.CoroutineStart
-import kotlinx.coroutines.Deferred
-import kotlinx.coroutines.launch
-import mozilla.components.concept.engine.CancellableOperation
-import org.mozilla.geckoview.GeckoResult
-import kotlin.coroutines.CoroutineContext
-import kotlin.coroutines.EmptyCoroutineContext
-import kotlin.coroutines.resume
-import kotlin.coroutines.resumeWithException
-import kotlin.coroutines.suspendCoroutine
-
-/**
- * Wait for a GeckoResult to be complete in a co-routine.
- */
-suspend fun <T> GeckoResult<T>.await() = suspendCoroutine<T?> { continuation ->
-    then({
-        continuation.resume(it)
-        GeckoResult<Void>()
-    }, {
-        continuation.resumeWithException(it)
-        GeckoResult<Void>()
-    })
-}
-
-/**
- * Converts a [GeckoResult] to a [CancellableOperation].
- */
-fun <T> GeckoResult<T>.asCancellableOperation(): CancellableOperation {
-    val geckoResult = this
-    return object : CancellableOperation {
-        override fun cancel(): Deferred<Boolean> {
-            val result = CompletableDeferred<Boolean>()
-            geckoResult.cancel().then({
-                result.complete(it ?: false)
-                GeckoResult<Void>()
-            }, { throwable ->
-                result.completeExceptionally(throwable)
-                GeckoResult<Void>()
-            })
-            return result
-        }
-    }
-}
-
-/**
- * Create a GeckoResult from a co-routine.
- */
-@Suppress("TooGenericExceptionCaught")
-fun <T> CoroutineScope.launchGeckoResult(
-    context: CoroutineContext = EmptyCoroutineContext,
-    start: CoroutineStart = CoroutineStart.DEFAULT,
-    block: suspend CoroutineScope.() -> T
-) = GeckoResult<T>().apply {
-    launch(context, start) {
-        try {
-            val value = block()
-            complete(value)
-        } catch (exception: Throwable) {
-            completeExceptionally(exception)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
deleted file mode 100644
index 25b32c6963e4..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
+++ /dev/null
@@ -1,171 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.view.MotionEvent
-import androidx.annotation.VisibleForTesting
-import androidx.core.view.NestedScrollingChild
-import androidx.core.view.NestedScrollingChildHelper
-import androidx.core.view.ViewCompat
-import mozilla.components.concept.engine.InputResultDetail
-import org.mozilla.geckoview.GeckoView
-
-/**
- * geckoView that supports nested scrolls (for using in a CoordinatorLayout).
- *
- * This code is a simplified version of the NestedScrollView implementation
- * which can be found in the support library:
- * [android.support.v4.widget.NestedScrollView]
- *
- * Based on:
- * https://github.com/takahirom/webview-in-coordinatorlayout
- */
-
-@Suppress("ClickableViewAccessibility")
-open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrollingChild {
-
-    @VisibleForTesting
-    internal var lastY: Int = 0
-
-    @VisibleForTesting
-    internal val scrollOffset = IntArray(2)
-
-    private val scrollConsumed = IntArray(2)
-
-    @VisibleForTesting
-    internal var nestedOffsetY: Int = 0
-
-    @VisibleForTesting
-    internal var childHelper: NestedScrollingChildHelper = NestedScrollingChildHelper(this)
-
-    /**
-     * How user's MotionEvent will be handled.
-     *
-     * @see InputResultDetail
-     */
-    internal var inputResultDetail = InputResultDetail.newInstance(true)
-
-    init {
-        isNestedScrollingEnabled = true
-    }
-
-    @Suppress("ComplexMethod")
-    override fun onTouchEvent(ev: MotionEvent): Boolean {
-        val event = MotionEvent.obtain(ev)
-        val action = ev.actionMasked
-        val eventY = event.y.toInt()
-
-        when (action) {
-            MotionEvent.ACTION_MOVE -> {
-                val allowScroll = !shouldPinOnScreen() && inputResultDetail.isTouchHandledByBrowser()
-
-                var deltaY = lastY - eventY
-
-                if (allowScroll && dispatchNestedPreScroll(0, deltaY, scrollConsumed, scrollOffset)) {
-                    deltaY -= scrollConsumed[1]
-                    event.offsetLocation(0f, (-scrollOffset[1]).toFloat())
-                    nestedOffsetY += scrollOffset[1]
-                }
-
-                lastY = eventY - scrollOffset[1]
-
-                if (allowScroll && dispatchNestedScroll(0, scrollOffset[1], 0, deltaY, scrollOffset)) {
-                    lastY -= scrollOffset[1]
-                    event.offsetLocation(0f, scrollOffset[1].toFloat())
-                    nestedOffsetY += scrollOffset[1]
-                }
-            }
-
-            MotionEvent.ACTION_DOWN -> {
-                // A new gesture started. Ask GV if it can handle this.
-                updateInputResult(event)
-
-                nestedOffsetY = 0
-                lastY = eventY
-
-                // The event should be handled either by onTouchEvent,
-                // either by onTouchEventForResult, never by both.
-                // Early return if we sent it to updateInputResult(..) which calls onTouchEventForResult.
-                event.recycle()
-                return true
-            }
-
-            // We don't care about other touch events
-            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
-                stopNestedScroll()
-                // Reset handled status so that parents of this View would not get the old value
-                // when querying it for a newly started touch event.
-                inputResultDetail = InputResultDetail.newInstance(true)
-            }
-        }
-
-        // Execute event handler from parent class in all cases
-        val eventHandled = callSuperOnTouchEvent(event)
-
-        // Recycle previously obtained event
-        event.recycle()
-
-        return eventHandled
-    }
-
-    @VisibleForTesting
-    internal fun callSuperOnTouchEvent(event: MotionEvent): Boolean {
-        return super.onTouchEvent(event)
-    }
-
-    @VisibleForTesting
-    internal fun updateInputResult(event: MotionEvent) {
-        super.onTouchEventForDetailResult(event)
-            .accept {
-                inputResultDetail = inputResultDetail.copy(
-                    it?.handledResult(), it?.scrollableDirections(), it?.overscrollDirections()
-                )
-                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL)
-            }
-    }
-
-    override fun setNestedScrollingEnabled(enabled: Boolean) {
-        childHelper.isNestedScrollingEnabled = enabled
-    }
-
-    override fun isNestedScrollingEnabled(): Boolean {
-        return childHelper.isNestedScrollingEnabled
-    }
-
-    override fun startNestedScroll(axes: Int): Boolean {
-        return childHelper.startNestedScroll(axes)
-    }
-
-    override fun stopNestedScroll() {
-        childHelper.stopNestedScroll()
-    }
-
-    override fun hasNestedScrollingParent(): Boolean {
-        return childHelper.hasNestedScrollingParent()
-    }
-
-    override fun dispatchNestedScroll(
-        dxConsumed: Int,
-        dyConsumed: Int,
-        dxUnconsumed: Int,
-        dyUnconsumed: Int,
-        offsetInWindow: IntArray?
-    ): Boolean {
-        return childHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow)
-    }
-
-    override fun dispatchNestedPreScroll(dx: Int, dy: Int, consumed: IntArray?, offsetInWindow: IntArray?): Boolean {
-        return childHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow)
-    }
-
-    override fun dispatchNestedFling(velocityX: Float, velocityY: Float, consumed: Boolean): Boolean {
-        return childHelper.dispatchNestedFling(velocityX, velocityY, consumed)
-    }
-
-    override fun dispatchNestedPreFling(velocityX: Float, velocityY: Float): Boolean {
-        return childHelper.dispatchNestedPreFling(velocityX, velocityY)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt
deleted file mode 100644
index bb0114f0904e..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorage.kt
+++ /dev/null
@@ -1,171 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Context
-import android.util.AtomicFile
-import androidx.annotation.VisibleForTesting
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.launch
-import mozilla.components.browser.engine.gecko.content.blocking.GeckoTrackingProtectionException
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.support.ktx.util.readAndDeserialize
-import mozilla.components.support.ktx.util.writeString
-import org.json.JSONArray
-import org.json.JSONObject
-import org.mozilla.geckoview.ContentBlockingController.ContentBlockingException
-import org.mozilla.geckoview.GeckoRuntime
-import java.io.File
-
-private const val STORE_FILE_NAME_FORMAT =
-    "mozilla_components_tracking_protection_storage_gecko.json"
-
-/**
- * A [TrackingProtectionExceptionStorage] implementation to store tracking protection exceptions.
- */
-internal class TrackingProtectionExceptionFileStorage(
-    private val context: Context,
-    private val runtime: GeckoRuntime
-) : TrackingProtectionExceptionStorage {
-    private val fileLock = Any()
-    internal var scope = CoroutineScope(Dispatchers.IO)
-
-    /**
-     * Restore all exceptions from the [STORE_FILE_NAME_FORMAT] file,
-     * and provides them to the gecko [runtime].
-     */
-    override fun restore() {
-        scope.launch {
-            synchronized(fileLock) {
-                getFile(context).readAndDeserialize { json ->
-                    if (json.isNotEmpty()) {
-                        val jsonArray = JSONArray(json)
-                        val exceptionList = (0 until jsonArray.length()).map { index ->
-                            val jsonObject = jsonArray.getJSONObject(index)
-                            ContentBlockingException.fromJson(jsonObject)
-                        }
-                        runtime.contentBlockingController.restoreExceptionList(exceptionList)
-                    }
-                }
-            }
-        }
-    }
-
-    override fun contains(session: EngineSession, onResult: (Boolean) -> Unit) {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        runtime.contentBlockingController.checkException(geckoSession).accept {
-            if (it != null) {
-                onResult(it)
-            } else {
-                onResult(false)
-            }
-        }
-    }
-
-    override fun fetchAll(onResult: (List<TrackingProtectionException>) -> Unit) {
-        runtime.contentBlockingController.saveExceptionList().accept { exceptionList ->
-            val exceptions = if (exceptionList != null) {
-                val exceptions = exceptionList.map { it.toTrackingProtectionException() }
-                exceptions
-            } else {
-                emptyList()
-            }
-            onResult(exceptions)
-        }
-    }
-
-    override fun add(session: EngineSession) {
-        val geckoEngineSession = (session as GeckoEngineSession)
-        runtime.contentBlockingController.addException(geckoEngineSession.geckoSession)
-        geckoEngineSession.notifyObservers {
-            onExcludedOnTrackingProtectionChange(true)
-        }
-        persist()
-    }
-
-    override fun remove(session: EngineSession) {
-        val geckoEngineSession = (session as GeckoEngineSession)
-        runtime.contentBlockingController.removeException(geckoEngineSession.geckoSession)
-        geckoEngineSession.notifyObservers {
-            onExcludedOnTrackingProtectionChange(false)
-        }
-        persist()
-    }
-
-    override fun remove(exception: TrackingProtectionException) {
-        val geckoException = (exception as GeckoTrackingProtectionException)
-        runtime.contentBlockingController.removeException(geckoException.toContentBlockingException())
-        persist()
-    }
-
-    override fun removeAll(activeSessions: List<EngineSession>?) {
-        runtime.contentBlockingController.clearExceptionList()
-        activeSessions?.forEach { engineSession ->
-            engineSession.notifyObservers {
-                onExcludedOnTrackingProtectionChange(false)
-            }
-        }
-        removeFileFromDisk(context)
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun getFile(context: Context): AtomicFile {
-        return AtomicFile(
-            File(
-                context.filesDir,
-                STORE_FILE_NAME_FORMAT
-            )
-        )
-    }
-
-    /**
-     * Take all the exception from the gecko [runtime] and saves them into the
-     * [STORE_FILE_NAME_FORMAT] file.
-     */
-    private fun persist() {
-        runtime.contentBlockingController.saveExceptionList().accept { exceptionList ->
-            if (exceptionList != null) {
-                scope.launch {
-                    synchronized(fileLock) {
-                        getFile(context).writeString {
-                            val jsonList = exceptionList.map { item ->
-                                item.toJson()
-                            }
-                            JSONArray(jsonList).toString()
-                        }
-                    }
-                }
-            } else {
-                removeFileFromDisk(context)
-            }
-        }
-    }
-
-    private fun removeFileFromDisk(context: Context) {
-        scope.launch {
-            synchronized(fileLock) {
-                getFile(context)
-                    .delete()
-            }
-        }
-    }
-}
-
-private fun ContentBlockingException.toTrackingProtectionException(): GeckoTrackingProtectionException {
-    val json = toJson()
-    val principal = json.getString("principal")
-    val uri = json.getString("uri")
-    return GeckoTrackingProtectionException(uri, principal)
-}
-
-private fun GeckoTrackingProtectionException.toContentBlockingException(): ContentBlockingException {
-    val json = JSONObject()
-    json.put("principal", principal)
-    json.put("uri", url)
-    return ContentBlockingException.fromJson(json)
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt
deleted file mode 100644
index cc93f915fc52..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegate.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.activity
-
-import android.app.PendingIntent
-import android.content.Intent
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.support.base.log.logger.Logger
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import java.lang.ref.WeakReference
-
-/**
- * A wrapper for the [ActivityDelegate] to communicate with the Gecko-based delegate.
- */
-internal class GeckoActivityDelegate(
-    private val delegateRef: WeakReference<ActivityDelegate>
-) : GeckoRuntime.ActivityDelegate {
-
-    private val logger = Logger(GeckoActivityDelegate::javaClass.name)
-
-    override fun onStartActivityForResult(intent: PendingIntent): GeckoResult<Intent> {
-        val result: GeckoResult<Intent> = GeckoResult()
-        val delegate = delegateRef.get()
-
-        if (delegate == null) {
-            logger.warn("No activity delegate attached. Cannot request FIDO auth.")
-
-            result.completeExceptionally(RuntimeException("Activity for result failed; no delegate attached."))
-
-            return result
-        }
-
-        delegate.startIntentSenderForResult(intent.intentSender) { data ->
-            if (data != null) {
-                result.complete(data)
-            } else {
-                result.completeExceptionally(RuntimeException("Activity for result failed."))
-            }
-        }
-        return result
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
deleted file mode 100644
index 71288f44b210..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.autofill
-
-import kotlinx.coroutines.Dispatchers.IO
-import kotlinx.coroutines.GlobalScope
-import kotlinx.coroutines.launch
-import mozilla.components.concept.storage.Login
-import mozilla.components.concept.storage.LoginStorageDelegate
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-
-/**
- * This class exists only to convert incoming [LoginEntry] arguments into [Login]s, then forward
- * them to [storageDelegate]. This allows us to avoid duplicating [LoginStorageDelegate] code
- * between different versions of GeckoView, by duplicating this wrapper instead.
- */
-@Suppress("Deprecation")
-// This will be addressed in https://github.com/mozilla-mobile/android-components/issues/10093
-class GeckoLoginDelegateWrapper(private val storageDelegate: LoginStorageDelegate) :
-    Autocomplete.LoginStorageDelegate {
-
-    override fun onLoginSave(login: Autocomplete.LoginEntry) {
-        storageDelegate.onLoginSave(login.toLogin())
-    }
-
-    override fun onLoginFetch(domain: String): GeckoResult<Array<Autocomplete.LoginEntry>>? {
-        val result = GeckoResult<Array<Autocomplete.LoginEntry>>()
-
-        GlobalScope.launch(IO) {
-            val storedLogins = storageDelegate.onLoginFetch(domain)
-
-            val logins = storedLogins.await()
-                .map { it.toLoginEntry() }
-                .toTypedArray()
-
-            result.complete(logins)
-        }
-
-        return result
-    }
-}
-
-/**
- * Converts a GeckoView [LoginStorage.LoginEntry] to an Android Components [Login]
- */
-private fun Autocomplete.LoginEntry.toLogin() = Login(
-    guid = guid,
-    origin = origin,
-    formActionOrigin = formActionOrigin,
-    httpRealm = httpRealm,
-    username = username,
-    password = password
-)
-
-/**
- * Converts an Android Components [Login] to a GeckoView [LoginStorage.LoginEntry]
- */
-private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-    .guid(guid)
-    .origin(origin)
-    .formActionOrigin(formActionOrigin)
-    .httpRealm(httpRealm)
-    .username(username)
-    .password(password)
-    .build()
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt
deleted file mode 100644
index eb5ed61a9a5b..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/content/blocking/GeckoTrackingProtectionException.kt
+++ /dev/null
@@ -1,15 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.content.blocking
-
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-
-/**
- * Represents a site that will be ignored by the tracking protection policies.
- * @property url The url of the site to be ignored.
- * @property principal Internal gecko identifier of an URI.
- */
-data class GeckoTrackingProtectionException(override val url: String, val principal: String = "") :
-    TrackingProtectionException
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt
deleted file mode 100644
index 3e8f4db2676c..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicy.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.ext
-
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-/**
- * Converts a [TrackingProtectionPolicy] into a GeckoView setting that can be used with [GeckoRuntimeSettings.Builder].
- */
-fun TrackingProtectionPolicy.toContentBlockingSetting(
-    safeBrowsingPolicy: Array<EngineSession.SafeBrowsingPolicy> = arrayOf(EngineSession.SafeBrowsingPolicy.RECOMMENDED)
-) = ContentBlocking.Settings.Builder().apply {
-    enhancedTrackingProtectionLevel(getEtpLevel())
-    antiTracking(getAntiTrackingPolicy())
-    cookieBehavior(cookiePolicy.id)
-    cookiePurging(cookiePurging)
-    safeBrowsing(safeBrowsingPolicy.sumBy { it.id })
-    strictSocialTrackingProtection(getStrictSocialTrackingProtection())
-}.build()
-
-/**
- * Returns whether [TrackingCategory.STRICT] is enabled in the [TrackingProtectionPolicy].
- */
-internal fun TrackingProtectionPolicy.getStrictSocialTrackingProtection(): Boolean {
-    return strictSocialTrackingProtection ?: trackingCategories.contains(TrackingCategory.STRICT)
-}
-
-/**
- * Returns the [TrackingProtectionPolicy] categories as an Enhanced Tracking Protection level for GeckoView.
- */
-internal fun TrackingProtectionPolicy.getEtpLevel(): Int {
-    return when {
-        trackingCategories.contains(TrackingCategory.NONE) -> ContentBlocking.EtpLevel.NONE
-        else -> ContentBlocking.EtpLevel.STRICT
-    }
-}
-
-/**
- * Returns the [TrackingProtectionPolicy] as a tracking policy for GeckoView.
- */
-internal fun TrackingProtectionPolicy.getAntiTrackingPolicy(): Int {
-    /**
-     * The [TrackingProtectionPolicy.TrackingCategory.SCRIPTS_AND_SUB_RESOURCES] is an
-     * artificial category, created with the sole purpose of going around this bug
-     * https://bugzilla.mozilla.org/show_bug.cgi?id=1579264, for this reason we have to
-     * remove its value from the valid anti tracking categories, when is present.
-     */
-    val total = trackingCategories.sumBy { it.id }
-    return if (contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)) {
-        total - TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-    } else {
-        total
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt
deleted file mode 100644
index d2cadff58668..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchClient.kt
+++ /dev/null
@@ -1,138 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch
-
-import android.content.Context
-import androidx.annotation.VisibleForTesting
-import mozilla.components.concept.fetch.Client
-import mozilla.components.concept.fetch.Headers
-import mozilla.components.concept.fetch.MutableHeaders
-import mozilla.components.concept.fetch.Request
-import mozilla.components.concept.fetch.Response
-import mozilla.components.concept.fetch.isDataUri
-import mozilla.components.concept.fetch.isBlobUri
-import mozilla.components.concept.fetch.Response.Companion.SUCCESS
-
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebRequest
-import org.mozilla.geckoview.WebRequest.CACHE_MODE_DEFAULT
-import org.mozilla.geckoview.WebRequest.CACHE_MODE_RELOAD
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebResponse
-import java.io.IOException
-import java.net.SocketTimeoutException
-import java.nio.ByteBuffer
-import java.util.concurrent.TimeUnit
-import java.util.concurrent.TimeoutException
-
-/**
- * GeckoView ([GeckoWebExecutor]) based implementation of [Client].
- */
-class GeckoViewFetchClient(
-    context: Context,
-    runtime: GeckoRuntime = GeckoRuntime.getDefault(context),
-    private val maxReadTimeOut: Pair<Long, TimeUnit> = Pair(MAX_READ_TIMEOUT_MINUTES, TimeUnit.MINUTES)
-) : Client() {
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var executor: GeckoWebExecutor = GeckoWebExecutor(runtime)
-
-    @Throws(IOException::class)
-    override fun fetch(request: Request): Response {
-        if (request.isDataUri()) {
-            return fetchDataUri(request)
-        }
-
-        val webRequest = request.toWebRequest()
-
-        val readTimeOut = request.readTimeout ?: maxReadTimeOut
-        val readTimeOutMillis = readTimeOut.let { (timeout, unit) ->
-            unit.toMillis(timeout)
-        }
-
-        return try {
-            val webResponse = executor.fetch(webRequest, request.fetchFlags).poll(readTimeOutMillis)
-            webResponse?.toResponse() ?: throw IOException("Fetch failed with null response")
-        } catch (e: TimeoutException) {
-            throw SocketTimeoutException()
-        } catch (e: WebRequestError) {
-            throw IOException(e)
-        }
-    }
-
-    private val Request.fetchFlags: Int
-        get() {
-            var fetchFlags = 0
-            if (cookiePolicy == Request.CookiePolicy.OMIT) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_ANONYMOUS
-            }
-            if (private) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_PRIVATE
-            }
-            if (redirect == Request.Redirect.MANUAL) {
-                fetchFlags += GeckoWebExecutor.FETCH_FLAGS_NO_REDIRECTS
-            }
-            return fetchFlags
-        }
-
-    companion object {
-        const val MAX_READ_TIMEOUT_MINUTES = 5L
-    }
-}
-
-private fun Request.toWebRequest(): WebRequest = WebRequest.Builder(url)
-    .method(method.name)
-    .addHeadersFrom(this)
-    .addBodyFrom(this)
-    .cacheMode(if (useCaches) CACHE_MODE_DEFAULT else CACHE_MODE_RELOAD)
-    .build()
-
-private fun WebRequest.Builder.addHeadersFrom(request: Request): WebRequest.Builder {
-    request.headers?.forEach { header ->
-        addHeader(header.name, header.value)
-    }
-
-    return this
-}
-
-private fun WebRequest.Builder.addBodyFrom(request: Request): WebRequest.Builder {
-    request.body?.let { body ->
-        body.useStream { inStream ->
-            val bytes = inStream.readBytes()
-            val buffer = ByteBuffer.allocateDirect(bytes.size)
-            buffer.put(bytes)
-            this.body(buffer)
-        }
-    }
-
-    return this
-}
-
-internal fun WebResponse.toResponse(): Response {
-    val isDataUri = uri.startsWith("data:")
-    val isBlobUri = uri.startsWith("blob:")
-    val headers = translateHeaders(this)
-    // We use the same API for blobs, data URLs and HTTP requests, but blobs won't receive a status code.
-    // If no exception is thrown we assume success.
-    val status = if (isBlobUri || isDataUri) SUCCESS else statusCode
-    return Response(
-        uri,
-        status,
-        headers,
-            body?.let {
-                Response.Body(it, headers["Content-Type"])
-            } ?: Response.Body.empty()
-    )
-}
-
-private fun translateHeaders(webResponse: WebResponse): Headers {
-    val headers = MutableHeaders()
-    webResponse.headers.forEach { (k, v) ->
-        v.split(",").forEach { headers.append(k, it.trim()) }
-    }
-
-    return headers
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt
deleted file mode 100644
index 9630faf81c98..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/glean/GeckoAdapter.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.glean
-
-import mozilla.components.browser.engine.gecko.GleanMetrics.GleanGeckoMetricsMapping
-import org.mozilla.geckoview.RuntimeTelemetry
-
-/**
- * This implements a [RuntimeTelemetry.Delegate] that dispatches Gecko runtime
- * telemetry to the Glean SDK.
- *
- * Metrics defined in the `metrics.yaml` file in Gecko's mozilla-central repository
- * will be automatically dispatched to the Glean SDK and sent through the requested
- * pings.
- *
- * This can be used, in products collecting data through the Glean SDK, by
- * providing an instance to `GeckoRuntimeSettings.Builder().telemetryDelegate`.
- */
-class GeckoAdapter : RuntimeTelemetry.Delegate {
-    // Note that the `GleanGeckoMetricsMapping` is automatically generated at
-    // build time by the Glean SDK parsers.
-
-    override fun onHistogram(metric: RuntimeTelemetry.Histogram) {
-        if (metric.isCategorical) {
-            // Gecko categorical histograms are a bit special: their value indicates
-            // the index of the label they want to accumulate 1 unit to. Moreover,
-            // Gecko batches them up before sending: each value in `metric.value` is
-            // the index of a potentially different label.
-            GleanGeckoMetricsMapping.getCategoricalMetric(metric.name)?.let { categorical ->
-                metric.value.forEach { labelIndex -> categorical[labelIndex.toInt()].add(1) }
-            }
-        } else {
-            GleanGeckoMetricsMapping.getHistogram(metric.name)?.accumulateSamples(metric.value)
-        }
-    }
-
-    override fun onBooleanScalar(metric: RuntimeTelemetry.Metric<Boolean>) {
-        GleanGeckoMetricsMapping.getBooleanScalar(metric.name)?.set(metric.value)
-    }
-
-    override fun onStringScalar(metric: RuntimeTelemetry.Metric<String>) {
-        GleanGeckoMetricsMapping.getStringScalar(metric.name)?.set(metric.value)
-    }
-
-    override fun onLongScalar(metric: RuntimeTelemetry.Metric<Long>) {
-        GleanGeckoMetricsMapping.getQuantityScalar(metric.name)?.set(metric.value)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt
deleted file mode 100644
index ac16867ea835..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/LocaleSettingUpdater.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-import android.content.BroadcastReceiver
-import android.content.Context
-import android.content.Intent
-import android.content.IntentFilter
-import androidx.core.os.LocaleListCompat as LocaleList
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Class to set the locales setting for geckoview, updating from the locale of the device.
- */
-class LocaleSettingUpdater(
-    private val context: Context,
-    private val runtime: GeckoRuntime
-) : SettingUpdater<Array<String>>() {
-
-    override var value: Array<String> = findValue()
-        set(value) {
-            runtime.settings.locales = value
-            field = value
-        }
-
-    private val localeChangedReceiver by lazy {
-        object : BroadcastReceiver() {
-            override fun onReceive(context: Context, intent: Intent?) {
-                updateValue()
-            }
-        }
-    }
-
-    override fun registerForUpdates() {
-        context.registerReceiver(localeChangedReceiver, IntentFilter(Intent.ACTION_LOCALE_CHANGED))
-    }
-
-    override fun unregisterForUpdates() {
-        context.unregisterReceiver(localeChangedReceiver)
-    }
-
-    override fun findValue(): Array<String> {
-        val localeList = LocaleList.getAdjustedDefault()
-        return arrayOfNulls<Unit>(localeList.size())
-            .mapIndexedNotNull { i, _ -> localeList.get(i).toLanguageTag() }
-            .toTypedArray()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt
deleted file mode 100644
index af4d455a791d..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/integration/SettingUpdater.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-abstract class SettingUpdater<T> {
-    /**
-     * Toggle the automatic tracking of a setting derived from the device state.
-     */
-    var enabled: Boolean = false
-        set(value) {
-            if (value) {
-                updateValue()
-                registerForUpdates()
-            } else {
-                unregisterForUpdates()
-            }
-            field = value
-        }
-
-    /**
-     * The setter for this property should change the GeckoView setting.
-     */
-    abstract var value: T
-
-    internal fun updateValue() {
-        value = findValue()
-    }
-
-    /**
-     * Register for updates from the device state. This is setting specific.
-     */
-    abstract fun registerForUpdates()
-
-    /**
-     * Unregister for updates from the device state.
-     */
-    abstract fun unregisterForUpdates()
-
-    /**
-     * Find the value of the setting from the device state. This is setting specific.
-     */
-    abstract fun findValue(): T
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt
deleted file mode 100644
index 919cde564afd..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediaquery/PreferredColorScheme.kt
+++ /dev/null
@@ -1,22 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package mozilla.components.browser.engine.gecko.mediaquery
-
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-internal fun PreferredColorScheme.Companion.from(geckoValue: Int) =
-        when (geckoValue) {
-            GeckoRuntimeSettings.COLOR_SCHEME_DARK -> PreferredColorScheme.Dark
-            GeckoRuntimeSettings.COLOR_SCHEME_LIGHT -> PreferredColorScheme.Light
-            GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM -> PreferredColorScheme.System
-            else -> PreferredColorScheme.System
-        }
-
-internal fun PreferredColorScheme.toGeckoValue() =
-    when (this) {
-        is PreferredColorScheme.Dark -> GeckoRuntimeSettings.COLOR_SCHEME_DARK
-        is PreferredColorScheme.Light -> GeckoRuntimeSettings.COLOR_SCHEME_LIGHT
-        is PreferredColorScheme.System -> GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM
-    }
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt
deleted file mode 100644
index 931135eb41d5..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionController.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import mozilla.components.concept.engine.mediasession.MediaSession
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-/**
- * [MediaSession.Controller] (`concept-engine`) implementation for GeckoView.
- */
-internal class GeckoMediaSessionController(
-    private val mediaSession: GeckoViewMediaSession
-) : MediaSession.Controller {
-
-    override fun pause() {
-        mediaSession.pause()
-    }
-
-    override fun stop() {
-        mediaSession.stop()
-    }
-
-    override fun play() {
-        mediaSession.play()
-    }
-
-    override fun seekTo(time: Double, fast: Boolean) {
-        mediaSession.seekTo(time, fast)
-    }
-
-    override fun seekForward() {
-        mediaSession.seekForward()
-    }
-
-    override fun seekBackward() {
-        mediaSession.seekBackward()
-    }
-
-    override fun nextTrack() {
-        mediaSession.nextTrack()
-    }
-
-    override fun previousTrack() {
-        mediaSession.previousTrack()
-    }
-
-    override fun skipAd() {
-        mediaSession.skipAd()
-    }
-
-    override fun muteAudio(mute: Boolean) {
-        mediaSession.muteAudio(mute)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt
deleted file mode 100644
index 5c66f956c640..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegate.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import android.graphics.Bitmap
-import kotlinx.coroutines.withTimeoutOrNull
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.browser.engine.gecko.await
-import mozilla.components.concept.engine.mediasession.MediaSession
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.Image.ImageProcessingException
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-private const val ARTWORK_RETRIEVE_TIMEOUT = 1000L
-private const val ARTWORK_IMAGE_SIZE = 48
-private const val ARTWORK_ERROR_SIZE = 1
-
-internal class GeckoMediaSessionDelegate(
-    private val engineSession: GeckoEngineSession
-) : GeckoViewMediaSession.Delegate {
-
-    override fun onActivated(geckoSession: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaActivated(GeckoMediaSessionController(mediaSession))
-        }
-    }
-
-    override fun onDeactivated(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaDeactivated()
-        }
-    }
-
-    override fun onMetadata(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        metaData: GeckoViewMediaSession.Metadata
-    ) {
-        val getArtwork: (suspend () -> Bitmap?)? = metaData.artwork?.let {
-            {
-                try {
-                    var bitmap = withTimeoutOrNull(ARTWORK_RETRIEVE_TIMEOUT) {
-                        it.getBitmap(ARTWORK_IMAGE_SIZE).await()
-                    }
-
-                    /* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1697255 */
-                    if (bitmap != null &&
-                        (bitmap.height <= ARTWORK_ERROR_SIZE || bitmap.width <= ARTWORK_ERROR_SIZE)) {
-                        bitmap = null
-                    }
-
-                    bitmap
-                } catch (e: ImageProcessingException) {
-                    null
-                }
-            }
-        }
-
-        engineSession.notifyObservers {
-            onMediaMetadataChanged(
-                MediaSession.Metadata(metaData.title, metaData.artist, metaData.album, getArtwork)
-            )
-        }
-    }
-
-    override fun onFeatures(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        features: Long
-    ) {
-        engineSession.notifyObservers {
-            onMediaFeatureChanged(MediaSession.Feature(features))
-        }
-    }
-
-    override fun onPlay(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.PLAYING)
-        }
-    }
-
-    override fun onPause(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.PAUSED)
-        }
-    }
-
-    override fun onStop(session: GeckoSession, mediaSession: GeckoViewMediaSession) {
-        engineSession.notifyObservers {
-            onMediaPlaybackStateChanged(MediaSession.PlaybackState.STOPPED)
-        }
-    }
-
-    override fun onPositionState(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        positionState: GeckoViewMediaSession.PositionState
-    ) {
-        engineSession.notifyObservers {
-            onMediaPositionStateChanged(
-                MediaSession.PositionState(positionState.duration, positionState.position,
-                    positionState.playbackRate)
-            )
-        }
-    }
-
-    override fun onFullscreen(
-        session: GeckoSession,
-        mediaSession: GeckoViewMediaSession,
-        enabled: Boolean,
-        elementMetaData: GeckoViewMediaSession.ElementMetadata?
-    ) {
-        val sessionElementMetaData =
-            elementMetaData?.let {
-                MediaSession.ElementMetadata(
-                    elementMetaData.source,
-                    elementMetaData.duration,
-                    elementMetaData.width,
-                    elementMetaData.height,
-                    elementMetaData.audioTrackCount,
-                    elementMetaData.videoTrackCount
-                )
-            }
-
-        engineSession.notifyObservers {
-            onMediaFullscreenChanged(enabled, sessionElementMetaData)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt
deleted file mode 100644
index bf8f84d52e9a..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequest.kt
+++ /dev/null
@@ -1,161 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.permission
-
-import android.Manifest.permission.ACCESS_COARSE_LOCATION
-import android.Manifest.permission.ACCESS_FINE_LOCATION
-import android.Manifest.permission.CAMERA
-import android.Manifest.permission.RECORD_AUDIO
-import mozilla.components.concept.engine.permission.Permission
-import mozilla.components.concept.engine.permission.PermissionRequest
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_AUDIOCAPTURE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_CAMERA
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_MICROPHONE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_OTHER
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource.SOURCE_SCREEN
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_AUDIBLE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_INAUDIBLE
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_DESKTOP_NOTIFICATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_MEDIA_KEY_SYSTEM_ACCESS
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_PERSISTENT_STORAGE
-import java.util.UUID
-
-/**
- * Gecko-based implementation of [PermissionRequest].
- *
- * @property permissions the list of requested permissions.
- * @property callback the callback to grant/reject the requested permissions.
- * @property id a unique identifier for the request.
- */
-sealed class GeckoPermissionRequest constructor(
-    override val permissions: List<Permission>,
-    private val callback: PermissionDelegate.Callback? = null,
-    override val id: String = UUID.randomUUID().toString()
-) : PermissionRequest {
-
-    /**
-     * Represents a gecko-based content permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property type the type of the requested content permission (will be
-     * mapped to corresponding [Permission]).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class Content(
-        override val uri: String,
-        private val type: Int,
-        private val callback: PermissionDelegate.Callback
-    ) : GeckoPermissionRequest(
-            listOf(permissionsMap.getOrElse(type) { Permission.Generic("$type", "Gecko permission type = $type") }),
-            callback
-    ) {
-        companion object {
-            val permissionsMap = mapOf(
-                PERMISSION_DESKTOP_NOTIFICATION to Permission.ContentNotification(),
-                PERMISSION_GEOLOCATION to Permission.ContentGeoLocation(),
-                PERMISSION_AUTOPLAY_AUDIBLE to Permission.ContentAutoPlayAudible(),
-                PERMISSION_AUTOPLAY_INAUDIBLE to Permission.ContentAutoPlayInaudible(),
-                PERMISSION_PERSISTENT_STORAGE to Permission.ContentPersistentStorage(),
-                PERMISSION_MEDIA_KEY_SYSTEM_ACCESS to Permission.ContentMediaKeySystemAccess()
-            )
-        }
-    }
-
-    /**
-     * Represents a gecko-based application permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property nativePermissions the list of requested app permissions (will be
-     * mapped to corresponding [Permission]s).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class App(
-        private val nativePermissions: List<String>,
-        private val callback: PermissionDelegate.Callback
-    ) : GeckoPermissionRequest(
-            nativePermissions.map { permissionsMap.getOrElse(it) { Permission.Generic(it) } },
-            callback
-    ) {
-        override val uri: String? = null
-
-        companion object {
-            val permissionsMap = mapOf(
-                ACCESS_COARSE_LOCATION to Permission.AppLocationCoarse(ACCESS_COARSE_LOCATION),
-                ACCESS_FINE_LOCATION to Permission.AppLocationFine(ACCESS_FINE_LOCATION),
-                CAMERA to Permission.AppCamera(CAMERA),
-                RECORD_AUDIO to Permission.AppAudio(RECORD_AUDIO)
-            )
-        }
-    }
-
-    /**
-     * Represents a gecko-based media permission request.
-     *
-     * @property uri the URI of the content requesting the permissions.
-     * @property videoSources the list of requested video sources (will be
-     * mapped to the corresponding [Permission]).
-     * @property audioSources the list of requested audio sources (will be
-     * mapped to corresponding [Permission]).
-     * @property callback the callback to grant/reject the requested permissions.
-     */
-    data class Media(
-        override val uri: String,
-        private val videoSources: List<MediaSource>,
-        private val audioSources: List<MediaSource>,
-        private val callback: PermissionDelegate.MediaCallback
-    ) : GeckoPermissionRequest(
-            videoSources.map { mapPermission(it) } + audioSources.map { mapPermission(it) }
-    ) {
-        override fun grant(permissions: List<Permission>) {
-            val videos = permissions.mapNotNull { permission -> videoSources.find { it.id == permission.id } }
-            val audios = permissions.mapNotNull { permission -> audioSources.find { it.id == permission.id } }
-            callback.grant(videos.firstOrNull(), audios.firstOrNull())
-        }
-
-        override fun containsVideoAndAudioSources(): Boolean {
-            return videoSources.isNotEmpty() && audioSources.isNotEmpty()
-        }
-
-        override fun reject() {
-            callback.reject()
-        }
-
-        companion object {
-            fun mapPermission(mediaSource: MediaSource): Permission =
-                if (mediaSource.type == MediaSource.TYPE_AUDIO) {
-                    mapAudioPermission(mediaSource)
-                } else {
-                    mapVideoPermission(mediaSource)
-                }
-
-            @Suppress("SwitchIntDef")
-            private fun mapAudioPermission(mediaSource: MediaSource) = when (mediaSource.source) {
-                SOURCE_AUDIOCAPTURE -> Permission.ContentAudioCapture(mediaSource.id, mediaSource.name)
-                SOURCE_MICROPHONE -> Permission.ContentAudioMicrophone(mediaSource.id, mediaSource.name)
-                SOURCE_OTHER -> Permission.ContentAudioOther(mediaSource.id, mediaSource.name)
-                else -> Permission.Generic(mediaSource.id, mediaSource.name)
-            }
-
-            @Suppress("ComplexMethod", "SwitchIntDef")
-            private fun mapVideoPermission(mediaSource: MediaSource) = when (mediaSource.source) {
-                SOURCE_CAMERA -> Permission.ContentVideoCamera(mediaSource.id, mediaSource.name)
-                SOURCE_SCREEN -> Permission.ContentVideoScreen(mediaSource.id, mediaSource.name)
-                SOURCE_OTHER -> Permission.ContentVideoOther(mediaSource.id, mediaSource.name)
-                else -> Permission.Generic(mediaSource.id, mediaSource.name)
-            }
-        }
-    }
-
-    override fun grant(permissions: List<Permission>) {
-        callback?.grant()
-    }
-
-    override fun reject() {
-        callback?.reject()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt
deleted file mode 100644
index 98fd12f20372..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/profiler/Profiler.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.profiler
-
-import mozilla.components.concept.base.profiler.Profiler
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Gecko-based implementation of [Profiler], wrapping the
- * ProfilerController object provided by GeckoView.
- */
-class Profiler(
-    private val runtime: GeckoRuntime
-) : Profiler {
-
-    /**
-     * See [Profiler.isProfilerActive].
-     */
-    override fun isProfilerActive(): Boolean {
-        return runtime.profilerController.isProfilerActive
-    }
-
-    /**
-     * See [Profiler.getProfilerTime].
-     */
-    override fun getProfilerTime(): Double? {
-        return runtime.profilerController.profilerTime
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?, endTime: Double?, text: String?) {
-        runtime.profilerController.addMarker(markerName, startTime, endTime, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?, text: String?) {
-        runtime.profilerController.addMarker(markerName, startTime, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, startTime: Double?) {
-        runtime.profilerController.addMarker(markerName, startTime)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String, text: String?) {
-        runtime.profilerController.addMarker(markerName, text)
-    }
-
-    /**
-     * See [Profiler.addMarker].
-     */
-    override fun addMarker(markerName: String) {
-        runtime.profilerController.addMarker(markerName)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt
deleted file mode 100644
index fc5d38bb6d8d..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegate.kt
+++ /dev/null
@@ -1,667 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.prompt
-
-import android.content.Context
-import android.net.Uri
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.prompt.Choice
-import mozilla.components.concept.engine.prompt.PromptRequest
-import mozilla.components.concept.engine.prompt.PromptRequest.MenuChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.MultipleChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.SingleChoice
-import mozilla.components.concept.engine.prompt.ShareData
-import mozilla.components.concept.storage.Login
-import mozilla.components.support.base.log.logger.Logger
-import mozilla.components.support.ktx.android.net.getFileName
-import mozilla.components.support.ktx.kotlin.toDate
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PromptDelegate
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.BeforeUnloadPrompt
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATETIME_LOCAL
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.MONTH
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.TIME
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.WEEK
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.PromptResponse
-import java.io.File
-import java.io.FileOutputStream
-import java.io.IOException
-import java.io.InputStream
-import java.security.InvalidParameterException
-import java.text.SimpleDateFormat
-import java.util.Date
-import java.util.Locale
-
-typealias GeckoAuthOptions = PromptDelegate.AuthPrompt.AuthOptions
-typealias GeckoChoice = PromptDelegate.ChoicePrompt.Choice
-typealias GECKO_AUTH_FLAGS = PromptDelegate.AuthPrompt.AuthOptions.Flags
-typealias GECKO_AUTH_LEVEL = PromptDelegate.AuthPrompt.AuthOptions.Level
-typealias GECKO_PROMPT_FILE_TYPE = PromptDelegate.FilePrompt.Type
-typealias GECKO_PROMPT_CHOICE_TYPE = PromptDelegate.ChoicePrompt.Type
-typealias GECKO_PROMPT_FILE_CAPTURE = PromptDelegate.FilePrompt.Capture
-typealias GECKO_PROMPT_SHARE_RESULT = PromptDelegate.SharePrompt.Result
-typealias AC_AUTH_LEVEL = PromptRequest.Authentication.Level
-typealias AC_AUTH_METHOD = PromptRequest.Authentication.Method
-typealias AC_FILE_FACING_MODE = PromptRequest.File.FacingMode
-
-/**
- * Gecko-based PromptDelegate implementation.
- */
-internal class GeckoPromptDelegate(private val geckoEngineSession: GeckoEngineSession) :
-    PromptDelegate {
-
-    private fun Autocomplete.LoginEntry.toLogin() = Login(
-        guid = guid,
-        origin = origin,
-        formActionOrigin = formActionOrigin,
-        httpRealm = httpRealm,
-        username = username,
-        password = password
-    )
-
-    private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-        .guid(guid)
-        .origin(origin)
-        .formActionOrigin(formActionOrigin)
-        .httpRealm(httpRealm)
-        .username(username)
-        .password(password)
-        .build()
-
-    override fun onLoginSave(
-        session: GeckoSession,
-        prompt: PromptDelegate.AutocompleteRequest<Autocomplete.LoginSaveOption>
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirmSave: (Login) -> Unit = { login ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(Autocomplete.LoginSelectOption(login.toLoginEntry())))
-            }
-        }
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.SaveLoginPrompt(
-                    hint = prompt.options[0].hint,
-                    logins = prompt.options.map { it.value.toLogin() },
-                    onConfirm = onConfirmSave,
-                    onDismiss = onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onLoginSelect(
-        session: GeckoSession,
-        prompt: PromptDelegate.AutocompleteRequest<Autocomplete.LoginSelectOption>
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirmSelect: (Login) -> Unit = { login ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(Autocomplete.LoginSelectOption(login.toLoginEntry())))
-            }
-        }
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        // Exactly one of `httpRealm` and `formSubmitURL` must be present to be a valid login entry.
-        val loginList = prompt.options.filter { option ->
-            option.value.formActionOrigin != null || option.value.httpRealm != null
-        }.map { option ->
-            option.value.toLogin()
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.SelectLoginPrompt(
-                    logins = loginList,
-                    onConfirm = onConfirmSelect,
-                    onDismiss = onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onChoicePrompt(
-        session: GeckoSession,
-        geckoPrompt: PromptDelegate.ChoicePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val choices = convertToChoices(geckoPrompt.choices)
-        val onConfirmSingleChoice: (Choice) -> Unit = { selectedChoice ->
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(selectedChoice.id))
-            }
-        }
-        val onConfirmMultipleSelection: (Array<Choice>) -> Unit = { selectedChoices ->
-            if (!geckoPrompt.isComplete) {
-                val ids = selectedChoices.toIdsArray()
-                geckoResult.complete(geckoPrompt.confirm(ids))
-            }
-        }
-
-        val promptRequest = when (geckoPrompt.type) {
-            GECKO_PROMPT_CHOICE_TYPE.SINGLE -> SingleChoice(
-                choices,
-                onConfirmSingleChoice
-            )
-            GECKO_PROMPT_CHOICE_TYPE.MENU -> MenuChoice(
-                choices,
-                onConfirmSingleChoice
-            )
-            GECKO_PROMPT_CHOICE_TYPE.MULTIPLE -> MultipleChoice(
-                choices,
-                onConfirmMultipleSelection
-            )
-            else -> throw InvalidParameterException("${geckoPrompt.type} is not a valid Gecko @Choice.ChoiceType")
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(promptRequest)
-        }
-
-        return geckoResult
-    }
-
-    override fun onAlertPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.AlertPrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: () -> Unit = { prompt.dismissSafely(geckoResult) }
-        val title = prompt.title ?: ""
-        val message = prompt.message ?: ""
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Alert(
-                    title,
-                    message,
-                    false,
-                    onConfirm
-                ) { _ ->
-                    onConfirm()
-                })
-        }
-        return geckoResult
-    }
-
-    override fun onFilePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.FilePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val isMultipleFilesSelection = prompt.type == GECKO_PROMPT_FILE_TYPE.MULTIPLE
-
-        val captureMode = when (prompt.capture) {
-            GECKO_PROMPT_FILE_CAPTURE.ANY -> AC_FILE_FACING_MODE.ANY
-            GECKO_PROMPT_FILE_CAPTURE.USER -> AC_FILE_FACING_MODE.FRONT_CAMERA
-            GECKO_PROMPT_FILE_CAPTURE.ENVIRONMENT -> AC_FILE_FACING_MODE.BACK_CAMERA
-            else -> AC_FILE_FACING_MODE.NONE
-        }
-
-        val onSelectMultiple: (Context, Array<Uri>) -> Unit = { context, uris ->
-            val filesUris = uris.map {
-                it.toFileUri(context)
-            }.toTypedArray()
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(context, filesUris))
-            }
-        }
-
-        val onSelectSingle: (Context, Uri) -> Unit = { context, uri ->
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(context, uri.toFileUri(context)))
-            }
-        }
-
-        val onDismiss: () -> Unit = {
-            prompt.dismissSafely(geckoResult)
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.File(
-                    prompt.mimeTypes ?: emptyArray(),
-                    isMultipleFilesSelection,
-                    captureMode,
-                    onSelectSingle,
-                    onSelectMultiple,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    @Suppress("ComplexMethod")
-    override fun onDateTimePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.DateTimePrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: (String) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(it))
-            }
-        }
-        val onClear: () -> Unit = {
-            onConfirm("")
-        }
-        val initialDateString = prompt.defaultValue ?: ""
-
-        val format = when (prompt.type) {
-            DATE -> "yyyy-MM-dd"
-            MONTH -> "yyyy-MM"
-            WEEK -> "yyyy-'W'ww"
-            TIME -> "HH:mm"
-            DATETIME_LOCAL -> "yyyy-MM-dd'T'HH:mm"
-            else -> {
-                throw InvalidParameterException("${prompt.type} is not a valid DatetimeType")
-            }
-        }
-
-        notifyDatePromptRequest(
-            prompt.title ?: "",
-            initialDateString,
-            prompt.minValue,
-            prompt.maxValue,
-            onClear,
-            format,
-            onConfirm
-        )
-
-        return geckoResult
-    }
-
-    override fun onAuthPrompt(
-        session: GeckoSession,
-        geckoPrompt: PromptDelegate.AuthPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = geckoPrompt.title ?: ""
-        val message = geckoPrompt.message ?: ""
-        val flags = geckoPrompt.authOptions.flags
-        val userName = geckoPrompt.authOptions.username ?: ""
-        val password = geckoPrompt.authOptions.password ?: ""
-        val method =
-            if (flags in GECKO_AUTH_FLAGS.HOST) AC_AUTH_METHOD.HOST else AC_AUTH_METHOD.PROXY
-        val level = geckoPrompt.authOptions.toACLevel()
-        val onlyShowPassword = flags in GECKO_AUTH_FLAGS.ONLY_PASSWORD
-        val previousFailed = flags in GECKO_AUTH_FLAGS.PREVIOUS_FAILED
-        val isCrossOrigin = flags in GECKO_AUTH_FLAGS.CROSS_ORIGIN_SUB_RESOURCE
-
-        val onConfirm: (String, String) -> Unit =
-            { user, pass ->
-                if (!geckoPrompt.isComplete) {
-                    if (onlyShowPassword) {
-                        geckoResult.complete(geckoPrompt.confirm(pass))
-                    } else {
-                        geckoResult.complete(geckoPrompt.confirm(user, pass))
-                    }
-                }
-            }
-
-        val onDismiss: () -> Unit = { geckoPrompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Authentication(
-                    title,
-                    message,
-                    userName,
-                    password,
-                    method,
-                    level,
-                    onlyShowPassword,
-                    previousFailed,
-                    isCrossOrigin,
-                    onConfirm,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onTextPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.TextPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = prompt.title ?: ""
-        val inputLabel = prompt.message ?: ""
-        val inputValue = prompt.defaultValue ?: ""
-        val onDismiss: () -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.TextPrompt(
-                    title,
-                    inputLabel,
-                    inputValue,
-                    false,
-                    onDismiss
-                ) { _, valueInput ->
-                    if (!prompt.isComplete) {
-                        geckoResult.complete(prompt.confirm(valueInput))
-                    }
-                })
-        }
-
-        return geckoResult
-    }
-
-    override fun onColorPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.ColorPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onConfirm: (String) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(it))
-            }
-        }
-        val onDismiss: () -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        val defaultColor = prompt.defaultValue ?: ""
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Color(defaultColor, onConfirm, onDismiss)
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onPopupPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.PopupPrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onAllow: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onDeny: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.DENY))
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Popup(prompt.targetUri ?: "", onAllow, onDeny)
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onBeforeUnloadPrompt(
-        session: GeckoSession,
-        geckoPrompt: BeforeUnloadPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = geckoPrompt.title ?: ""
-        val onAllow: () -> Unit = {
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onDeny: () -> Unit = {
-            if (!geckoPrompt.isComplete) {
-                geckoResult.complete(geckoPrompt.confirm(AllowOrDeny.DENY))
-                geckoEngineSession.notifyObservers { onBeforeUnloadPromptDenied() }
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(PromptRequest.BeforeUnload(title, onAllow, onDeny))
-        }
-
-        return geckoResult
-    }
-
-    override fun onSharePrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.SharePrompt
-    ): GeckoResult<PromptResponse> {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val onSuccess = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(GECKO_PROMPT_SHARE_RESULT.SUCCESS))
-            }
-        }
-        val onFailure = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(GECKO_PROMPT_SHARE_RESULT.FAILURE))
-            }
-        }
-        val onDismiss = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Share(
-                    ShareData(
-                        title = prompt.title,
-                        text = prompt.text,
-                        url = prompt.uri
-                    ),
-                    onSuccess,
-                    onFailure,
-                    onDismiss
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onButtonPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.ButtonPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-        val title = prompt.title ?: ""
-        val message = prompt.message ?: ""
-
-        val onConfirmPositiveButton: (Boolean) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(PromptDelegate.ButtonPrompt.Type.POSITIVE))
-            }
-        }
-        val onConfirmNegativeButton: (Boolean) -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(PromptDelegate.ButtonPrompt.Type.NEGATIVE))
-            }
-        }
-
-        val onDismiss: (Boolean) -> Unit = { prompt.dismissSafely(geckoResult) }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Confirm(
-                    title,
-                    message,
-                    false,
-                    "",
-                    "",
-                    "",
-                    onConfirmPositiveButton,
-                    onConfirmNegativeButton,
-                    onDismiss
-                ) {
-                    onDismiss(false)
-                }
-            )
-        }
-        return geckoResult
-    }
-
-    override fun onRepostConfirmPrompt(
-        session: GeckoSession,
-        prompt: PromptDelegate.RepostConfirmPrompt
-    ): GeckoResult<PromptResponse>? {
-        val geckoResult = GeckoResult<PromptResponse>()
-
-        val onConfirm: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.ALLOW))
-            }
-        }
-        val onCancel: () -> Unit = {
-            if (!prompt.isComplete) {
-                geckoResult.complete(prompt.confirm(AllowOrDeny.DENY))
-                geckoEngineSession.notifyObservers { onRepostPromptCancelled() }
-            }
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.Repost(
-                    onConfirm,
-                    onCancel
-                )
-            )
-        }
-        return geckoResult
-    }
-
-    private fun GeckoChoice.toChoice(): Choice {
-        val choiceChildren = items?.map { it.toChoice() }?.toTypedArray()
-        // On the GeckoView docs states that label is a @NonNull, but on run-time
-        // we are getting null values
-        @Suppress("USELESS_ELVIS")
-        return Choice(id, !disabled, label ?: "", selected, separator, choiceChildren)
-    }
-
-    /**
-     * Convert an array of [GeckoChoice] to Choice array.
-     * @return array of Choice
-     */
-    private fun convertToChoices(
-        geckoChoices: Array<out GeckoChoice>
-    ): Array<Choice> {
-
-        return geckoChoices.map { geckoChoice ->
-            val choice = geckoChoice.toChoice()
-            choice
-        }.toTypedArray()
-    }
-
-    @Suppress("LongParameterList")
-    private fun notifyDatePromptRequest(
-        title: String,
-        initialDateString: String,
-        minDateString: String?,
-        maxDateString: String?,
-        onClear: () -> Unit,
-        format: String,
-        onConfirm: (String) -> Unit
-    ) {
-        val initialDate = initialDateString.toDate(format)
-        val minDate = if (minDateString.isNullOrEmpty()) null else minDateString.toDate()
-        val maxDate = if (maxDateString.isNullOrEmpty()) null else maxDateString.toDate()
-        val onSelect: (Date) -> Unit = {
-            val stringDate = it.toString(format)
-            onConfirm(stringDate)
-        }
-
-        val selectionType = when (format) {
-            "HH:mm" -> PromptRequest.TimeSelection.Type.TIME
-            "yyyy-MM" -> PromptRequest.TimeSelection.Type.MONTH
-            "yyyy-MM-dd'T'HH:mm" -> PromptRequest.TimeSelection.Type.DATE_AND_TIME
-            else -> PromptRequest.TimeSelection.Type.DATE
-        }
-
-        geckoEngineSession.notifyObservers {
-            onPromptRequest(
-                PromptRequest.TimeSelection(
-                    title,
-                    initialDate,
-                    minDate,
-                    maxDate,
-                    selectionType,
-                    onSelect,
-                    onClear
-                )
-            )
-        }
-    }
-
-    private fun GeckoAuthOptions.toACLevel(): AC_AUTH_LEVEL {
-        return when (level) {
-            GECKO_AUTH_LEVEL.NONE -> AC_AUTH_LEVEL.NONE
-            GECKO_AUTH_LEVEL.PW_ENCRYPTED -> AC_AUTH_LEVEL.PASSWORD_ENCRYPTED
-            GECKO_AUTH_LEVEL.SECURE -> AC_AUTH_LEVEL.SECURED
-            else -> {
-                AC_AUTH_LEVEL.NONE
-            }
-        }
-    }
-
-    private operator fun Int.contains(mask: Int): Boolean {
-        return (this and mask) != 0
-    }
-
-    private fun Uri.toFileUri(context: Context): Uri {
-        val contentResolver = context.contentResolver
-        val cacheUploadDirectory = java.io.File(context.cacheDir, "/uploads")
-
-        if (!cacheUploadDirectory.exists()) {
-            cacheUploadDirectory.mkdir()
-        }
-
-        val temporalFile = java.io.File(cacheUploadDirectory, getFileName(contentResolver))
-        try {
-            contentResolver.openInputStream(this)!!.use { inStream ->
-                copyFile(temporalFile, inStream)
-            }
-        } catch (e: IOException) {
-            Logger("GeckoPromptDelegate").warn("Could not convert uri to file uri", e)
-        }
-        return Uri.parse("file:///${temporalFile.absolutePath}")
-    }
-
-    @VisibleForTesting
-    internal fun copyFile(temporalFile: File, inStream: InputStream): Long {
-        return FileOutputStream(temporalFile).use { outStream ->
-            inStream.copyTo(outStream)
-        }
-    }
-}
-
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-internal fun Array<Choice>.toIdsArray(): Array<String> {
-    return this.map { it.id }.toTypedArray()
-}
-
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-internal fun Date.toString(format: String): String {
-    val formatter = SimpleDateFormat(format, Locale.ROOT)
-    return formatter.format(this) ?: ""
-}
-
-/**
- * Only dismiss if the prompt is not already dismissed.
- */
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-
-internal fun PromptDelegate.BasePrompt.dismissSafely(geckoResult: GeckoResult<PromptResponse>) {
-    if (!this.isComplete) {
-        geckoResult.complete(dismiss())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt
deleted file mode 100644
index 781430af630c..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegate.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.selection
-
-import android.app.Activity
-import android.content.Context
-import android.view.MenuItem
-import androidx.annotation.VisibleForTesting
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import org.mozilla.geckoview.BasicSelectionActionDelegate
-
-/**
- * An adapter between the GV [BasicSelectionActionDelegate] and a generic [SelectionActionDelegate].
- *
- * @param customDelegate handles as much of this logic as possible.
- */
-open class GeckoSelectionActionDelegate(
-    activity: Activity,
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal val customDelegate: SelectionActionDelegate
-) : BasicSelectionActionDelegate(activity) {
-
-    companion object {
-        /**
-         * @returns a [GeckoSelectionActionDelegate] if [customDelegate] is non-null and [context]
-         * is an instance of [Activity]. Otherwise, returns null.
-         */
-        fun maybeCreate(context: Context, customDelegate: SelectionActionDelegate?): GeckoSelectionActionDelegate? {
-            return if (context is Activity && customDelegate != null) {
-                GeckoSelectionActionDelegate(context, customDelegate)
-            } else {
-                null
-            }
-        }
-    }
-
-    override fun getAllActions(): Array<String> {
-        return customDelegate.sortedActions(super.getAllActions() + customDelegate.getAllActions())
-    }
-
-    override fun isActionAvailable(id: String): Boolean {
-        val selectedText = mSelection?.text
-
-        val customActionIsAvailable = !selectedText.isNullOrEmpty() &&
-        customDelegate.isActionAvailable(id, selectedText)
-
-        return customActionIsAvailable ||
-            super.isActionAvailable(id)
-    }
-
-    override fun prepareAction(id: String, item: MenuItem) {
-        val title = customDelegate.getActionTitle(id)
-            ?: return super.prepareAction(id, item)
-
-        item.title = title
-    }
-
-    override fun performAction(id: String, item: MenuItem): Boolean {
-        /* Temporary, removed once https://bugzilla.mozilla.org/show_bug.cgi?id=1694983 is fixed */
-        try {
-            val selectedText = mSelection?.text ?: return super.performAction(id, item)
-
-            return customDelegate.performAction(id, selectedText) || super.performAction(id, item)
-        } catch (e: SecurityException) {
-            return false
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt
deleted file mode 100644
index 202e78abe940..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactory.kt
+++ /dev/null
@@ -1,154 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.util
-
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.Settings
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Helper factory for creating and maintaining a speculative [EngineSession].
- */
-internal class SpeculativeSessionFactory {
-    @VisibleForTesting
-    internal var speculativeEngineSession: SpeculativeEngineSession? = null
-
-    /**
-     * Creates a speculative [EngineSession] using the provided [contextId] and [defaultSettings].
-     * Creates a private session if [private] is set to true.
-     *
-     * The speculative [EngineSession] is kept internally until explicitly needed and access via [get].
-     */
-    @Synchronized
-    fun create(
-        runtime: GeckoRuntime,
-        private: Boolean,
-        contextId: String?,
-        defaultSettings: Settings?
-    ) {
-        if (speculativeEngineSession?.matches(private, contextId) == true) {
-            // We already have a speculative engine session for this configuration. Nothing to do here.
-            return
-        }
-
-        // Clear any potentially non-matching engine session
-        clear()
-
-        speculativeEngineSession = SpeculativeEngineSession.create(
-            this,
-            runtime,
-            private,
-            contextId,
-            defaultSettings
-        )
-    }
-
-    /**
-     * Clears the internal speculative [EngineSession].
-     */
-    @Synchronized
-    fun clear() {
-        speculativeEngineSession?.cleanUp()
-        speculativeEngineSession = null
-    }
-
-    /**
-     * Returns and consumes a previously created [private] speculative [EngineSession] if it uses
-     * the same [contextId]. Returns `null` if no speculative [EngineSession] for that
-     * configuration is available.
-     */
-    @Synchronized
-    fun get(
-        private: Boolean,
-        contextId: String?
-    ): GeckoEngineSession? {
-        val speculativeEngineSession = speculativeEngineSession ?: return null
-
-        return if (speculativeEngineSession.matches(private, contextId)) {
-            this.speculativeEngineSession = null
-            speculativeEngineSession.unwrap()
-        } else {
-            clear()
-            null
-        }
-    }
-
-    @VisibleForTesting
-    internal fun hasSpeculativeSession(): Boolean {
-        return speculativeEngineSession != null
-    }
-}
-
-/**
- * Internal wrapper for [GeckoEngineSession] that takes care of registering and unregistering an
- * observer for handling content process crashes/kills.
- */
-internal class SpeculativeEngineSession constructor(
-    @VisibleForTesting internal val engineSession: GeckoEngineSession,
-    @VisibleForTesting internal val observer: SpeculativeSessionObserver
-) {
-    /**
-     * Checks whether the [SpeculativeEngineSession] matches the given configuration.
-     */
-    fun matches(private: Boolean, contextId: String?): Boolean {
-        return engineSession.geckoSession.settings.usePrivateMode == private &&
-            engineSession.geckoSession.settings.contextId == contextId
-    }
-
-    /**
-     * Unwraps the internal [GeckoEngineSession].
-     *
-     * After calling [unwrap] the wrapper will no longer observe the [GeckoEngineSession] and further
-     * crash handling is left to the application.
-     */
-    fun unwrap(): GeckoEngineSession {
-        engineSession.unregister(observer)
-        return engineSession
-    }
-
-    /**
-     * Cleans up the internal state of this [SpeculativeEngineSession]. After calling this method
-     * his [SpeculativeEngineSession] cannot be used anymore.
-     */
-    fun cleanUp() {
-        engineSession.unregister(observer)
-        engineSession.close()
-    }
-
-    companion object {
-        fun create(
-            factory: SpeculativeSessionFactory,
-            runtime: GeckoRuntime,
-            private: Boolean,
-            contextId: String?,
-            defaultSettings: Settings?
-        ): SpeculativeEngineSession {
-            val engineSession = GeckoEngineSession(runtime, private, defaultSettings, contextId)
-            val observer = SpeculativeSessionObserver(factory)
-            engineSession.register(observer)
-
-            return SpeculativeEngineSession(engineSession, observer)
-        }
-    }
-}
-
-/**
- * [EngineSession.Observer] implementation that will notify the [SpeculativeSessionFactory] if an
- * [GeckoEngineSession] can no longer be used after a crash.
- */
-internal class SpeculativeSessionObserver(
-    private val factory: SpeculativeSessionFactory
-
-) : EngineSession.Observer {
-    override fun onCrash() {
-        factory.clear()
-    }
-
-    override fun onProcessKilled() {
-        factory.clear()
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt
deleted file mode 100644
index 0f24dab354dd..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtension.kt
+++ /dev/null
@@ -1,427 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import android.graphics.Bitmap
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.browser.engine.gecko.await
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.Settings
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.DisabledFlags
-import mozilla.components.concept.engine.webextension.MessageHandler
-import mozilla.components.concept.engine.webextension.Metadata
-import mozilla.components.concept.engine.webextension.Port
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.support.base.log.logger.Logger
-import org.json.JSONObject
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.WebExtension as GeckoNativeWebExtension
-import org.mozilla.geckoview.WebExtension.Action as GeckoNativeWebExtensionAction
-
-/**
- * Gecko-based implementation of [WebExtension], wrapping the native web
- * extension object provided by GeckoView.
- */
-class GeckoWebExtension(
-    val nativeExtension: GeckoNativeWebExtension,
-    val runtime: GeckoRuntime
-) : WebExtension(nativeExtension.id, nativeExtension.location, true) {
-
-    private val connectedPorts: MutableMap<PortId, GeckoPort> = mutableMapOf()
-    private val logger = Logger("GeckoWebExtension")
-
-    /**
-     * Uniquely identifies a port using its name and the session it
-     * was opened for. Ports connected from background scripts will
-     * have a null session.
-     */
-    data class PortId(val name: String, val session: EngineSession? = null)
-
-    /**
-     * See [WebExtension.registerBackgroundMessageHandler].
-     */
-    override fun registerBackgroundMessageHandler(name: String, messageHandler: MessageHandler) {
-        val portDelegate = object : GeckoNativeWebExtension.PortDelegate {
-
-            override fun onPortMessage(message: Any, port: GeckoNativeWebExtension.Port) {
-                messageHandler.onPortMessage(message, GeckoPort(port))
-            }
-
-            override fun onDisconnect(port: GeckoNativeWebExtension.Port) {
-                val connectedPort = connectedPorts[PortId(name)]
-                if (connectedPort != null && connectedPort.nativePort == port) {
-                    connectedPorts.remove(PortId(name))
-                    messageHandler.onPortDisconnected(GeckoPort(port))
-                }
-            }
-        }
-
-        val messageDelegate = object : GeckoNativeWebExtension.MessageDelegate {
-
-            override fun onConnect(port: GeckoNativeWebExtension.Port) {
-                port.setDelegate(portDelegate)
-                val geckoPort = GeckoPort(port)
-                connectedPorts[PortId(name)] = geckoPort
-                messageHandler.onPortConnected(geckoPort)
-            }
-
-            override fun onMessage(
-                // We don't use the same delegate instance for multiple apps so we don't need to verify the name.
-                name: String,
-                message: Any,
-                sender: GeckoNativeWebExtension.MessageSender
-            ): GeckoResult<Any>? {
-                val response = messageHandler.onMessage(message, null)
-                return response?.let { GeckoResult.fromValue(it) }
-            }
-        }
-
-        nativeExtension.setMessageDelegate(messageDelegate, name)
-    }
-
-    /**
-     * See [WebExtension.registerContentMessageHandler].
-     */
-    override fun registerContentMessageHandler(session: EngineSession, name: String, messageHandler: MessageHandler) {
-        val portDelegate = object : GeckoNativeWebExtension.PortDelegate {
-
-            override fun onPortMessage(message: Any, port: GeckoNativeWebExtension.Port) {
-                messageHandler.onPortMessage(message, GeckoPort(port, session))
-            }
-
-            override fun onDisconnect(port: GeckoNativeWebExtension.Port) {
-                val connectedPort = connectedPorts[PortId(name, session)]
-                if (connectedPort != null && connectedPort.nativePort == port) {
-                    connectedPorts.remove(PortId(name, session))
-                    messageHandler.onPortDisconnected(connectedPort)
-                }
-            }
-        }
-
-        val messageDelegate = object : GeckoNativeWebExtension.MessageDelegate {
-
-            override fun onConnect(port: GeckoNativeWebExtension.Port) {
-                port.setDelegate(portDelegate)
-                val geckoPort = GeckoPort(port, session)
-                connectedPorts[PortId(name, session)] = geckoPort
-                messageHandler.onPortConnected(geckoPort)
-            }
-
-            override fun onMessage(
-                // We don't use the same delegate instance for multiple apps so we don't need to verify the name.
-                name: String,
-                message: Any,
-                sender: GeckoNativeWebExtension.MessageSender
-            ): GeckoResult<Any>? {
-                val response = messageHandler.onMessage(message, session)
-                return response?.let { GeckoResult.fromValue(it) }
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setMessageDelegate(nativeExtension, messageDelegate, name)
-    }
-
-    /**
-     * See [WebExtension.hasContentMessageHandler].
-     */
-    override fun hasContentMessageHandler(session: EngineSession, name: String): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getMessageDelegate(nativeExtension, name) != null
-    }
-
-    /**
-     * See [WebExtension.getConnectedPort].
-     */
-    override fun getConnectedPort(name: String, session: EngineSession?): Port? {
-        return connectedPorts[PortId(name, session)]
-    }
-
-    /**
-     * See [WebExtension.disconnectPort].
-     */
-    override fun disconnectPort(name: String, session: EngineSession?) {
-        val portId = PortId(name, session)
-        val port = connectedPorts[portId]
-        port?.let {
-            it.disconnect()
-            connectedPorts.remove(portId)
-        }
-    }
-
-    /**
-     * See [WebExtension.registerActionHandler].
-     */
-    override fun registerActionHandler(actionHandler: ActionHandler) {
-        if (!supportActions) {
-            logger.error("Attempt to register default action handler but browser and page " +
-                "action support is turned off for this extension: $id")
-            return
-        }
-
-        val actionDelegate = object : GeckoNativeWebExtension.ActionDelegate {
-
-            override fun onBrowserAction(
-                ext: GeckoNativeWebExtension,
-                // Session will always be null here for the global default delegate
-                session: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onBrowserAction(this@GeckoWebExtension, null, action.convert())
-            }
-
-            override fun onPageAction(
-                ext: GeckoNativeWebExtension,
-                // Session will always be null here for the global default delegate
-                session: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onPageAction(this@GeckoWebExtension, null, action.convert())
-            }
-
-            override fun onTogglePopup(
-                ext: GeckoNativeWebExtension,
-                action: GeckoNativeWebExtensionAction
-            ): GeckoResult<GeckoSession>? {
-                val session = actionHandler.onToggleActionPopup(this@GeckoWebExtension, action.convert())
-                return session?.let { GeckoResult.fromValue((session as GeckoEngineSession).geckoSession) }
-            }
-        }
-
-        nativeExtension.setActionDelegate(actionDelegate)
-    }
-
-    /**
-     * See [WebExtension.registerActionHandler].
-     */
-    override fun registerActionHandler(session: EngineSession, actionHandler: ActionHandler) {
-        if (!supportActions) {
-            logger.error("Attempt to register action handler on session but browser and page " +
-                "action support is turned off for this extension: $id")
-            return
-        }
-
-        val actionDelegate = object : GeckoNativeWebExtension.ActionDelegate {
-
-            override fun onBrowserAction(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onBrowserAction(this@GeckoWebExtension, session, action.convert())
-            }
-
-            override fun onPageAction(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession?,
-                action: GeckoNativeWebExtensionAction
-            ) {
-                actionHandler.onPageAction(this@GeckoWebExtension, session, action.convert())
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setActionDelegate(nativeExtension, actionDelegate)
-    }
-
-    /**
-     * See [WebExtension.hasActionHandler].
-     */
-    override fun hasActionHandler(session: EngineSession): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getActionDelegate(nativeExtension) != null
-    }
-
-    /**
-     * See [WebExtension.registerTabHandler].
-     */
-    override fun registerTabHandler(tabHandler: TabHandler, defaultSettings: Settings?) {
-
-        val tabDelegate = object : GeckoNativeWebExtension.TabDelegate {
-
-            override fun onNewTab(
-                ext: GeckoNativeWebExtension,
-                tabDetails: GeckoNativeWebExtension.CreateTabDetails
-            ): GeckoResult<GeckoSession>? {
-                val geckoEngineSession = GeckoEngineSession(
-                    runtime,
-                    defaultSettings = defaultSettings,
-                    openGeckoSession = false
-                )
-
-                tabHandler.onNewTab(
-                    this@GeckoWebExtension,
-                    geckoEngineSession,
-                    tabDetails.active == true,
-                    tabDetails.url ?: ""
-                )
-                return GeckoResult.fromValue(geckoEngineSession.geckoSession)
-            }
-
-            override fun onOpenOptionsPage(ext: GeckoNativeWebExtension) {
-                ext.metaData.optionsPageUrl?.let { optionsPageUrl ->
-                    tabHandler.onNewTab(
-                        this@GeckoWebExtension,
-                        GeckoEngineSession(runtime,
-                            defaultSettings = defaultSettings),
-                        false,
-                        optionsPageUrl
-                    )
-                }
-            }
-        }
-
-        nativeExtension.tabDelegate = tabDelegate
-    }
-
-    /**
-     * See [WebExtension.registerTabHandler].
-     */
-    override fun registerTabHandler(session: EngineSession, tabHandler: TabHandler) {
-
-        val tabDelegate = object : GeckoNativeWebExtension.SessionTabDelegate {
-
-            override fun onUpdateTab(
-                ext: GeckoNativeWebExtension,
-                geckoSession: GeckoSession,
-                tabDetails: GeckoNativeWebExtension.UpdateTabDetails
-            ): GeckoResult<AllowOrDeny> {
-
-                return if (tabHandler.onUpdateTab(
-                    this@GeckoWebExtension,
-                    session,
-                    tabDetails.active == true,
-                    tabDetails.url)
-                ) {
-                    GeckoResult.allow()
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-
-            override fun onCloseTab(
-                ext: GeckoNativeWebExtension?,
-                geckoSession: GeckoSession
-            ): GeckoResult<AllowOrDeny> {
-
-                return if (ext != null) {
-                    if (tabHandler.onCloseTab(this@GeckoWebExtension, session)) {
-                        GeckoResult.allow()
-                    } else {
-                        GeckoResult.deny()
-                    }
-                } else {
-                    GeckoResult.deny()
-                }
-            }
-        }
-
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        geckoSession.webExtensionController.setTabDelegate(nativeExtension, tabDelegate)
-    }
-
-    /**
-     * See [WebExtension.hasTabHandler].
-     */
-    override fun hasTabHandler(session: EngineSession): Boolean {
-        val geckoSession = (session as GeckoEngineSession).geckoSession
-        return geckoSession.webExtensionController.getTabDelegate(nativeExtension) != null
-    }
-
-    /**
-     * See [WebExtension.getMetadata].
-     */
-    override fun getMetadata(): Metadata? {
-        return nativeExtension.metaData.let {
-            Metadata(
-                name = it.name,
-                description = it.description,
-                developerName = it.creatorName,
-                developerUrl = it.creatorUrl,
-                homePageUrl = it.homepageUrl,
-                version = it.version,
-                permissions = it.permissions.toList(),
-                // Origins is marked as @NonNull but may be null: https://bugzilla.mozilla.org/show_bug.cgi?id=1629957
-                hostPermissions = it.origins.orEmpty().toList(),
-                disabledFlags = DisabledFlags.select(it.disabledFlags),
-                optionsPageUrl = it.optionsPageUrl,
-                openOptionsPageInTab = it.openOptionsPageInTab,
-                baseUrl = it.baseUrl,
-                temporary = it.temporary
-            )
-        }
-    }
-
-    override fun isBuiltIn(): Boolean {
-        return nativeExtension.isBuiltIn
-    }
-
-    override fun isEnabled(): Boolean {
-        return nativeExtension.metaData.enabled
-    }
-
-    override fun isAllowedInPrivateBrowsing(): Boolean {
-        return isBuiltIn() || nativeExtension.metaData.allowedInPrivateBrowsing
-    }
-
-    override suspend fun loadIcon(size: Int): Bitmap? {
-        return getIcon(size).await()
-    }
-
-    @VisibleForTesting
-    internal fun getIcon(size: Int): GeckoResult<Bitmap> {
-        return nativeExtension.metaData.icon.getBitmap(size)
-    }
-}
-
-/**
- * Gecko-based implementation of [Port], wrapping the native port provided by GeckoView.
- */
-class GeckoPort(
-    internal val nativePort: GeckoNativeWebExtension.Port,
-    engineSession: EngineSession? = null
-) : Port(engineSession) {
-
-    override fun postMessage(message: JSONObject) {
-        nativePort.postMessage(message)
-    }
-
-    override fun name(): String {
-        return nativePort.name
-    }
-
-    override fun senderUrl(): String {
-        return nativePort.sender.url
-    }
-
-    override fun disconnect() {
-        nativePort.disconnect()
-    }
-}
-
-private fun GeckoNativeWebExtensionAction.convert(): Action {
-    val loadIcon: (suspend (Int) -> Bitmap?)? = icon?.let {
-        { size -> icon?.getBitmap(size)?.await() }
-    }
-
-    val onClick = { click() }
-
-    return Action(
-        title,
-        enabled,
-        loadIcon,
-        badgeText,
-        badgeTextColor,
-        badgeBackgroundColor,
-        onClick
-    )
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt
deleted file mode 100644
index c7aca040271a..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionException.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import mozilla.components.concept.engine.webextension.WebExtensionException
-import org.mozilla.geckoview.WebExtension.InstallException
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_USER_CANCELED
-
-/**
- * An unexpected gecko exception that occurs when trying to perform an action on the extension like
- * (but not exclusively) installing/uninstalling, removing or updating..
- */
-class GeckoWebExtensionException(throwable: Throwable) : WebExtensionException(throwable) {
-    override val isRecoverable: Boolean = throwable is InstallException &&
-            throwable.code == ERROR_USER_CANCELED
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt
deleted file mode 100644
index f65277ac7f6c..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegate.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webnotifications
-
-import mozilla.components.concept.engine.webnotifications.WebNotification
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import org.mozilla.geckoview.WebNotification as GeckoViewWebNotification
-import org.mozilla.geckoview.WebNotificationDelegate as GeckoViewWebNotificationDelegate
-
-internal class GeckoWebNotificationDelegate(
-    private val webNotificationDelegate: WebNotificationDelegate
-) : GeckoViewWebNotificationDelegate {
-    override fun onShowNotification(webNotification: GeckoViewWebNotification) {
-        webNotificationDelegate.onShowNotification(webNotification.toWebNotification())
-    }
-
-    override fun onCloseNotification(webNotification: GeckoViewWebNotification) {
-        webNotificationDelegate.onCloseNotification(webNotification.toWebNotification())
-    }
-
-    private fun GeckoViewWebNotification.toWebNotification(): WebNotification {
-        return WebNotification(
-            title = title,
-            tag = tag,
-            body = text,
-            sourceUrl = source,
-            iconUrl = imageUrl,
-            direction = textDirection,
-            lang = lang,
-            requireInteraction = requireInteraction,
-            triggeredByWebExtension = source == null
-        )
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt
deleted file mode 100644
index 3facfc2de16a..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegate.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushSubscription
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.WebPushDelegate as GeckoViewWebPushDelegate
-import org.mozilla.geckoview.WebPushSubscription as GeckoWebPushSubscription
-
-/**
- * A wrapper for the [WebPushDelegate] to communicate with the Gecko-based delegate.
- */
-internal class GeckoWebPushDelegate(private val delegate: WebPushDelegate) : GeckoViewWebPushDelegate {
-
-    /**
-     * See [GeckoViewWebPushDelegate.onGetSubscription].
-     */
-    override fun onGetSubscription(scope: String): GeckoResult<GeckoWebPushSubscription>? {
-        val result: GeckoResult<GeckoWebPushSubscription> = GeckoResult()
-
-        delegate.onGetSubscription(scope) { subscription ->
-            result.complete(subscription?.toGeckoSubscription())
-        }
-
-        return result
-    }
-
-    /**
-     * See [GeckoViewWebPushDelegate.onSubscribe].
-     */
-    override fun onSubscribe(scope: String, appServerKey: ByteArray?): GeckoResult<GeckoWebPushSubscription>? {
-        val result: GeckoResult<GeckoWebPushSubscription> = GeckoResult()
-
-        delegate.onSubscribe(scope, appServerKey) { subscription ->
-            result.complete(subscription?.toGeckoSubscription())
-        }
-
-        return result
-    }
-
-    /**
-     * See [GeckoViewWebPushDelegate.onUnsubscribe].
-     */
-    override fun onUnsubscribe(scope: String): GeckoResult<Void>? {
-        val result: GeckoResult<Void> = GeckoResult()
-
-        delegate.onUnsubscribe(scope) { success ->
-            if (success) {
-                result.complete(null)
-            } else {
-                result.completeExceptionally(WebPushException("Un-subscribing from subscription failed."))
-            }
-        }
-
-        return result
-    }
-}
-
-/**
- * A helper extension to convert the subscription data class to the Gecko-based implementation.
- */
-internal fun WebPushSubscription.toGeckoSubscription() = GeckoWebPushSubscription(
-    scope,
-    endpoint,
-    appServerKey,
-    publicKey,
-    authSecret
-)
-
-internal class WebPushException(message: String) : IllegalStateException(message)
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt
deleted file mode 100644
index 413c1cc90629..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandler.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import mozilla.components.concept.engine.webpush.WebPushHandler
-import org.mozilla.geckoview.GeckoRuntime
-
-/**
- * Gecko-based implementation of [WebPushHandler], wrapping the
- * controller object provided by GeckoView.
- */
-internal class GeckoWebPushHandler(
-    private val runtime: GeckoRuntime
-) : WebPushHandler {
-
-    /**
-     * See [WebPushHandler].
-     */
-    override fun onPushMessage(scope: String, message: ByteArray?) {
-        runtime.webPushController.onPushEvent(scope, message)
-    }
-
-    /**
-     * See [WebPushHandler].
-     */
-    override fun onSubscriptionChanged(scope: String) {
-        runtime.webPushController.onSubscriptionChanged(scope)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt b/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt
deleted file mode 100644
index d5ca91901a79..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/main/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequest.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.window
-
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.window.WindowRequest
-
-/**
- * Gecko-based implementation of [WindowRequest].
- */
-class GeckoWindowRequest(
-    override val url: String = "",
-    private val engineSession: GeckoEngineSession,
-    override val type: WindowRequest.Type = WindowRequest.Type.OPEN
-) : WindowRequest {
-
-    override fun prepare(): EngineSession {
-        return this.engineSession
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt
deleted file mode 100644
index 3b6f5eb427aa..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionStateTest.kt
+++ /dev/null
@@ -1,61 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.util.JsonWriter
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.mock
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.doReturn
-import org.mozilla.geckoview.GeckoSession
-import java.io.ByteArrayOutputStream
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineSessionStateTest {
-
-    @Test
-    fun writeTo() {
-        val geckoState: GeckoSession.SessionState = mock()
-        doReturn("<state>").`when`(geckoState).toString()
-
-        val state = GeckoEngineSessionState(geckoState)
-
-        val stream = ByteArrayOutputStream()
-        val writer = JsonWriter(stream.writer())
-        state.writeTo(writer)
-        val json = JSONObject(stream.toString())
-
-        assertEquals(1, json.length())
-        assertTrue(json.has("GECKO_STATE"))
-        assertEquals("<state>", json.getString("GECKO_STATE"))
-    }
-
-    @Test
-    fun fromJSON() {
-        val json = JSONObject().apply {
-            put("GECKO_STATE", "{ 'foo': 'bar' }")
-        }
-
-        val state = GeckoEngineSessionState.fromJSON(json)
-
-        assertEquals("""{"foo":"bar"}""", state.actualState.toString())
-    }
-
-    @Test
-    fun `fromJSON with invalid JSON returns empty State`() {
-        val json = JSONObject().apply {
-            put("nothing", "helpful")
-        }
-
-        val state = GeckoEngineSessionState.fromJSON(json)
-
-        assertNull(state.actualState)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt
deleted file mode 100644
index faab2e9b5ad5..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineSessionTest.kt
+++ /dev/null
@@ -1,3008 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.content.Intent
-import android.graphics.Color
-import android.os.Handler
-import android.os.Message
-import android.view.WindowManager
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runBlockingTest
-import mozilla.components.browser.errorpages.ErrorType
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.LoadUrlFlags
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.CookiePolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.EngineSessionState
-import mozilla.components.concept.engine.HitResult
-import mozilla.components.concept.engine.UnsupportedSettingException
-import mozilla.components.concept.engine.content.blocking.Tracker
-import mozilla.components.concept.engine.history.HistoryItem
-import mozilla.components.concept.engine.history.HistoryTrackingDelegate
-import mozilla.components.concept.engine.manifest.WebAppManifest
-import mozilla.components.concept.engine.permission.PermissionRequest
-import mozilla.components.concept.engine.request.RequestInterceptor
-import mozilla.components.concept.engine.window.WindowRequest
-import mozilla.components.concept.fetch.Headers
-import mozilla.components.concept.fetch.Response
-import mozilla.components.concept.storage.PageVisit
-import mozilla.components.concept.storage.RedirectSource
-import mozilla.components.concept.storage.VisitType
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.expectException
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import mozilla.components.support.utils.ThreadUtils
-import mozilla.components.test.ReflectionUtils
-import mozilla.components.support.test.argumentCaptor
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentCaptor
-import org.mockito.ArgumentMatchers.anyBoolean
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.ArgumentMatchers.anyList
-import org.mockito.ArgumentMatchers.anyString
-import org.mockito.Mockito.atLeastOnce
-import org.mockito.Mockito.never
-import org.mockito.Mockito.reset
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.verifyZeroInteractions
-import org.mozilla.geckoview.WebResponse
-import org.mozilla.geckoview.AllowOrDeny
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_AUDIO
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_IMAGE
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_NONE
-import org.mozilla.geckoview.GeckoSession.ContentDelegate.ContextElement.TYPE_VIDEO
-import org.mozilla.geckoview.GeckoSession.ProgressDelegate.SecurityInformation
-import org.mozilla.geckoview.GeckoSessionSettings
-import org.mozilla.geckoview.SessionFinder
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebRequestError.ERROR_CATEGORY_UNKNOWN
-import org.mozilla.geckoview.WebRequestError.ERROR_MALFORMED_URI
-import org.mozilla.geckoview.WebRequestError.ERROR_UNKNOWN
-import java.security.Principal
-import java.security.cert.X509Certificate
-typealias GeckoAntiTracking = ContentBlocking.AntiTracking
-typealias GeckoSafeBrowsing = ContentBlocking.SafeBrowsing
-typealias GeckoCookieBehavior = ContentBlocking.CookieBehavior
-
-@ExperimentalCoroutinesApi
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineSessionTest {
-
-    private lateinit var runtime: GeckoRuntime
-    private lateinit var geckoSession: GeckoSession
-    private lateinit var geckoSessionProvider: () -> GeckoSession
-
-    private lateinit var navigationDelegate: ArgumentCaptor<GeckoSession.NavigationDelegate>
-    private lateinit var progressDelegate: ArgumentCaptor<GeckoSession.ProgressDelegate>
-    private lateinit var contentDelegate: ArgumentCaptor<GeckoSession.ContentDelegate>
-    private lateinit var permissionDelegate: ArgumentCaptor<GeckoSession.PermissionDelegate>
-    private lateinit var contentBlockingDelegate: ArgumentCaptor<ContentBlocking.Delegate>
-    private lateinit var historyDelegate: ArgumentCaptor<GeckoSession.HistoryDelegate>
-
-    @Suppress("DEPRECATION")
-    // Deprecation will be handled in https://github.com/mozilla-mobile/android-components/issues/8514
-    @Before
-    fun setup() {
-        ThreadUtils.setHandlerForTest(object : Handler() {
-            override fun sendMessageAtTime(msg: Message, uptimeMillis: Long): Boolean {
-                val wrappedRunnable = Runnable {
-                    try {
-                        msg.callback?.run()
-                    } catch (t: Throwable) {
-                        // We ignore this in the test as the runnable could be calling
-                        // a native method (disposeNative) which won't work in Robolectric
-                    }
-                }
-                return super.sendMessageAtTime(Message.obtain(this, wrappedRunnable), uptimeMillis)
-            }
-        })
-
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        navigationDelegate = ArgumentCaptor.forClass(GeckoSession.NavigationDelegate::class.java)
-        progressDelegate = ArgumentCaptor.forClass(GeckoSession.ProgressDelegate::class.java)
-        contentDelegate = ArgumentCaptor.forClass(GeckoSession.ContentDelegate::class.java)
-        permissionDelegate = ArgumentCaptor.forClass(GeckoSession.PermissionDelegate::class.java)
-        contentBlockingDelegate = ArgumentCaptor.forClass(ContentBlocking.Delegate::class.java)
-        historyDelegate = ArgumentCaptor.forClass(GeckoSession.HistoryDelegate::class.java)
-
-        geckoSession = mockGeckoSession()
-        geckoSessionProvider = { geckoSession }
-    }
-
-    private fun captureDelegates() {
-        verify(geckoSession).navigationDelegate = navigationDelegate.capture()
-        verify(geckoSession).progressDelegate = progressDelegate.capture()
-        verify(geckoSession).contentDelegate = contentDelegate.capture()
-        verify(geckoSession).permissionDelegate = permissionDelegate.capture()
-        verify(geckoSession).contentBlockingDelegate = contentBlockingDelegate.capture()
-        verify(geckoSession).historyDelegate = historyDelegate.capture()
-    }
-
-    @Test
-    fun engineSessionInitialization() {
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        verify(geckoSession).open(any())
-
-        captureDelegates()
-
-        assertNotNull(navigationDelegate.value)
-        assertNotNull(progressDelegate.value)
-    }
-
-    @Test
-    fun isIgnoredForTrackingProtection() {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        var geckoResult = GeckoResult<Boolean?>()
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        var wasExecuted = false
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        session.isIgnoredForTrackingProtection {
-            wasExecuted = it
-        }
-
-        geckoResult.complete(true)
-        assertTrue(wasExecuted)
-
-        geckoResult = GeckoResult()
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        session.isIgnoredForTrackingProtection {
-            wasExecuted = it
-        }
-
-        geckoResult.complete(null)
-        assertFalse(wasExecuted)
-    }
-
-    @Test
-    fun progressDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var observedProgress = 0
-        var observedLoadingState = false
-        var observedSecurityChange = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadingStateChange(loading: Boolean) { observedLoadingState = loading }
-            override fun onProgress(progress: Int) { observedProgress = progress }
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                // We cannot assert on actual parameters as SecurityInfo's fields can't be set
-                // from the outside and its constructor isn't accessible either.
-                observedSecurityChange = true
-            }
-        })
-
-        captureDelegates()
-
-        progressDelegate.value.onPageStart(mock(), "http://mozilla.org")
-        assertEquals(GeckoEngineSession.PROGRESS_START, observedProgress)
-        assertEquals(true, observedLoadingState)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertEquals(GeckoEngineSession.PROGRESS_STOP, observedProgress)
-        assertEquals(false, observedLoadingState)
-
-        // Stop will update the loading state and progress observers even when
-        // we haven't completed been successful.
-        progressDelegate.value.onPageStart(mock(), "http://mozilla.org")
-        assertEquals(GeckoEngineSession.PROGRESS_START, observedProgress)
-        assertEquals(true, observedLoadingState)
-
-        progressDelegate.value.onPageStop(mock(), false)
-        assertEquals(GeckoEngineSession.PROGRESS_STOP, observedProgress)
-        assertEquals(false, observedLoadingState)
-
-        val securityInfo = mock<SecurityInformation>()
-        progressDelegate.value.onSecurityChange(mock(), securityInfo)
-        assertTrue(observedSecurityChange)
-
-        observedSecurityChange = false
-
-        progressDelegate.value.onSecurityChange(mock(), mock())
-        assertTrue(observedSecurityChange)
-    }
-
-    @Test
-    fun navigationDelegateNotifiesObservers() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var observedUrl = ""
-        var observedCanGoBack = false
-        var observedCanGoForward = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-            override fun onNavigationStateChange(canGoBack: Boolean?, canGoForward: Boolean?) {
-                canGoBack?.let { observedCanGoBack = canGoBack }
-                canGoForward?.let { observedCanGoForward = canGoForward }
-            }
-        })
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-
-        geckoResult.complete(true)
-
-        navigationDelegate.value.onLocationChange(mock(), "http://mozilla.org")
-        assertEquals("http://mozilla.org", observedUrl)
-        verify(mockedContentBlockingController).checkException(any())
-
-        navigationDelegate.value.onCanGoBack(mock(), true)
-        assertEquals(true, observedCanGoBack)
-
-        navigationDelegate.value.onCanGoForward(mock(), true)
-        assertEquals(true, observedCanGoForward)
-    }
-
-    // This will be addressed on https://github.com/mozilla-mobile/android-components/issues/8312
-    @Suppress("deprecation")
-    @Test
-    fun contentDelegateNotifiesObserverAboutDownloads() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider, privateMode = true)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        val response = WebResponse.Builder("https://download.mozilla.org/image.png")
-            .addHeader(Headers.Names.CONTENT_TYPE, "image/png")
-            .addHeader(Headers.Names.CONTENT_LENGTH, "42")
-            .body(mock())
-            .build()
-
-        val captor = argumentCaptor<Response>()
-        captureDelegates()
-        contentDelegate.value.onExternalResponse(mock(), response)
-
-        verify(observer).onExternalResource(
-            url = eq("https://download.mozilla.org/image.png"),
-            fileName = eq("image.png"),
-            contentLength = eq(42),
-            contentType = eq("image/png"),
-            userAgent = eq(null),
-            cookie = eq(null),
-            isPrivate = eq(true),
-            response = captor.capture()
-        )
-        assertNotNull(captor.value)
-    }
-
-    @Test
-    fun contentDelegateNotifiesObserverAboutWebAppManifest() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        val json = JSONObject().apply {
-            put("name", "Minimal")
-            put("start_url", "/")
-        }
-        val manifest = WebAppManifest(
-            name = "Minimal",
-            startUrl = "/"
-        )
-
-        captureDelegates()
-        contentDelegate.value.onWebAppManifest(mock(), json)
-
-        verify(observer).onWebAppManifestLoaded(manifest)
-    }
-
-    @Test
-    fun permissionDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val observedContentPermissionRequests: MutableList<PermissionRequest> = mutableListOf()
-        val observedAppPermissionRequests: MutableList<PermissionRequest> = mutableListOf()
-        engineSession.register(object : EngineSession.Observer {
-            override fun onContentPermissionRequest(permissionRequest: PermissionRequest) {
-                observedContentPermissionRequests.add(permissionRequest)
-            }
-
-            override fun onAppPermissionRequest(permissionRequest: PermissionRequest) {
-                observedAppPermissionRequests.add(permissionRequest)
-            }
-        })
-
-        captureDelegates()
-
-        permissionDelegate.value.onContentPermissionRequest(
-            geckoSession,
-            "originContent",
-            GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION,
-            mock()
-        )
-
-        permissionDelegate.value.onContentPermissionRequest(
-            geckoSession,
-            null,
-            GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION,
-            mock()
-        )
-
-        permissionDelegate.value.onMediaPermissionRequest(
-            geckoSession,
-            "originMedia",
-            emptyArray(),
-            emptyArray(),
-            mock()
-        )
-
-        permissionDelegate.value.onMediaPermissionRequest(
-            geckoSession,
-            "about:blank",
-            null,
-            null,
-            mock()
-        )
-
-        permissionDelegate.value.onAndroidPermissionsRequest(
-            geckoSession,
-            emptyArray(),
-            mock()
-        )
-
-        permissionDelegate.value.onAndroidPermissionsRequest(
-            geckoSession,
-            null,
-            mock()
-        )
-
-        assertEquals(4, observedContentPermissionRequests.size)
-        assertEquals("originContent", observedContentPermissionRequests[0].uri)
-        assertEquals("", observedContentPermissionRequests[1].uri)
-        assertEquals("originMedia", observedContentPermissionRequests[2].uri)
-        assertEquals("about:blank", observedContentPermissionRequests[3].uri)
-        assertEquals(2, observedAppPermissionRequests.size)
-    }
-
-    @Test
-    fun loadUrl() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        val parentEngineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadUrl("http://mozilla.org")
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://mozilla.org")
-        )
-
-        engineSession.loadUrl("http://www.mozilla.org", flags = LoadUrlFlags.select(LoadUrlFlags.EXTERNAL))
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").flags(LoadUrlFlags.EXTERNAL)
-        )
-
-        engineSession.loadUrl("http://www.mozilla.org", parent = parentEngineSession)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").referrer(parentEngineSession.geckoSession)
-        )
-
-        val extraHeaders = mapOf("X-Extra-Header" to "true")
-        engineSession.loadUrl("http://www.mozilla.org", additionalHeaders = extraHeaders)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("http://www.mozilla.org").additionalHeaders(extraHeaders)
-        )
-    }
-
-    @Test
-    fun `loadUrl doesn't load URLs with blocked schemes`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadUrl("file://test.txt")
-        engineSession.loadUrl("FILE://test.txt")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("file://test.txt"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("FILE://test.txt"))
-
-        engineSession.loadUrl("content://authority/path/id")
-        engineSession.loadUrl("CoNtEnT://authority/path/id")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("content://authority/path/id"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("CoNtEnT://authority/path/id"))
-
-        engineSession.loadUrl("resource://package/test.text")
-        engineSession.loadUrl("RESOURCE://package/test.text")
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("resource://package/test.text"))
-        verify(geckoSession, never()).load(GeckoSession.Loader().uri("RESOURCE://package/test.text"))
-    }
-
-    @Test
-    fun loadData() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadData("<html><body>Hello!</body></html>")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("<html><body>Hello!</body></html>", "text/html")
-        )
-
-        engineSession.loadData("Hello!", "text/plain", "UTF-8")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("Hello!", "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", "text/plain", "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", encoding = "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/html")
-        )
-    }
-
-    @Test
-    fun loadDataBase64() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.loadData("Hello!", "text/plain", "UTF-8")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("Hello!", "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", "text/plain", "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-
-        engineSession.loadData("ahr0cdovl21vemlsbgeub3jn==", encoding = "base64")
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("ahr0cdovl21vemlsbgeub3jn==".toByteArray(), "text/plain")
-        )
-    }
-
-    @Test
-    fun stopLoading() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.stopLoading()
-
-        verify(geckoSession).stop()
-    }
-
-    @Test
-    fun reload() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        engineSession.loadUrl("http://mozilla.org")
-
-        // Initial load is still in progress so reload should not be called.
-        // Instead we should have called loadUrl again to prevent reloading
-        // about:blank.
-        engineSession.reload()
-        verify(geckoSession, never()).reload(GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-        verify(geckoSession, times(2)).load(
-            GeckoSession.Loader().uri("http://mozilla.org")
-        )
-
-        // Subsequent reloads should simply call reload on the gecko session.
-        engineSession.initialLoadRequest = null
-        engineSession.reload()
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_NONE)
-
-        engineSession.reload(flags = LoadUrlFlags.select(LoadUrlFlags.BYPASS_CACHE))
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-    }
-
-    @Test
-    fun goBack() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goBack()
-
-        verify(geckoSession).goBack()
-    }
-
-    @Test
-    fun goForward() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goForward()
-
-        verify(geckoSession).goForward()
-    }
-
-    @Test
-    fun goToHistoryIndex() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.goToHistoryIndex(0)
-
-        verify(geckoSession).gotoHistoryIndex(0)
-    }
-
-    @Test
-    fun restoreState() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val actualState: GeckoSession.SessionState = mock()
-        val state = GeckoEngineSessionState(actualState)
-
-        assertTrue(engineSession.restoreState(state))
-        verify(geckoSession).restoreState(any())
-    }
-
-    @Test
-    fun `restoreState returns false for null state`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        val state = GeckoEngineSessionState(null)
-
-        assertFalse(engineSession.restoreState(state))
-        verify(geckoSession, never()).restoreState(any())
-    }
-
-    @Test
-    fun progressDelegateIgnoresInitialLoadOfAboutBlank() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var observedSecurityChange = false
-        var progressObserved = false
-        var loadingStateChangeObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedSecurityChange = true
-            }
-
-            override fun onProgress(progress: Int) {
-                progressObserved = true
-            }
-
-            override fun onLoadingStateChange(loading: Boolean) {
-                loadingStateChangeObserved = true
-            }
-        })
-
-        captureDelegates()
-
-        progressDelegate.value.onSecurityChange(mock(),
-                MockSecurityInformation("moz-nullprincipal:{uuid}"))
-        assertFalse(observedSecurityChange)
-
-        progressDelegate.value.onSecurityChange(mock(),
-                MockSecurityInformation("https://www.mozilla.org"))
-        assertTrue(observedSecurityChange)
-
-        progressDelegate.value.onPageStart(mock(), "about:blank")
-        assertFalse(progressObserved)
-        assertFalse(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertFalse(progressObserved)
-        assertFalse(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStart(mock(), "https://www.mozilla.org")
-        assertTrue(progressObserved)
-        assertTrue(loadingStateChangeObserved)
-
-        progressDelegate.value.onPageStop(mock(), true)
-        assertTrue(progressObserved)
-        assertTrue(loadingStateChangeObserved)
-    }
-
-    @Test
-    fun navigationDelegateIgnoresInitialLoadOfAboutBlank() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var observedUrl = ""
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-        })
-
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-
-        geckoResult.complete(true)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", observedUrl)
-        verify(mockedContentBlockingController).checkException(any())
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("about:blank", observedUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will reset initial load flag on process switch to ignore about blank loads`() {
-        val geckoResult = GeckoResult<Boolean?>()
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        captureDelegates()
-        assertTrue(session.initialLoad)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://mozilla.org")
-        assertFalse(session.initialLoad)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("moz-extension://1234-test"))
-        assertTrue(session.initialLoad)
-
-        var observedUrl = ""
-        session.register(object : EngineSession.Observer {
-            override fun onLocationChange(url: String) { observedUrl = url }
-        })
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", observedUrl)
-
-        navigationDelegate.value.onLocationChange(mock(), "about:blank")
-        assertEquals("about:blank", observedUrl)
-    }
-
-    @Test
-    fun `do not keep track of current url via onPageStart events`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        assertNull(engineSession.currentUrl)
-        progressDelegate.value.onPageStart(geckoSession, "https://www.mozilla.org")
-        assertNull(engineSession.currentUrl)
-
-        progressDelegate.value.onPageStart(geckoSession, "https://www.firefox.com")
-        assertNull(engineSession.currentUrl)
-    }
-
-    @Test
-    fun `keeps track of current url via onLocationChange events`() {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        var geckoResult = GeckoResult<Boolean?>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-        geckoResult.complete(true)
-
-        assertNull(engineSession.currentUrl)
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.mozilla.org")
-        assertEquals("https://www.mozilla.org", engineSession.currentUrl)
-
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.firefox.com")
-        assertEquals("https://www.firefox.com", engineSession.currentUrl)
-    }
-
-    @Test
-    fun `notifies configured history delegate of title changes`() = runBlockingTest {
-        val mockedContentBlockingController = mock<ContentBlockingController>()
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-        var geckoResult = GeckoResult<Boolean?>()
-        whenever(runtime.contentBlockingController).thenReturn(mockedContentBlockingController)
-        whenever(mockedContentBlockingController.checkException(any())).thenReturn(geckoResult)
-
-        captureDelegates()
-        geckoResult.complete(true)
-
-        // Nothing breaks if history delegate isn't configured.
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-
-        // This sets the currentUrl.
-        navigationDelegate.value.onLocationChange(geckoSession, "https://www.mozilla.com")
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate).onTitleChanged(eq("https://www.mozilla.com"), eq("Hello World!"))
-    }
-
-    @Test
-    fun `does not notify configured history delegate of title changes for private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-        verify(observer).onTitleChange("Hello World!")
-
-        // This sets the currentUrl.
-        progressDelegate.value.onPageStart(geckoSession, "https://www.mozilla.com")
-
-        contentDelegate.value.onTitleChange(geckoSession, "Mozilla")
-        verify(historyTrackingDelegate, never()).onTitleChanged(anyString(), anyString())
-        verify(observer).onTitleChange("Mozilla")
-    }
-
-    @Test
-    fun `does not notify configured history delegate for redirects`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `does not notify configured history delegate for top-level visits to error pages`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "about:neterror", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL or GeckoSession.HistoryDelegate.VISIT_UNRECOVERABLE_ERROR)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `notifies configured history delegate of visits`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com")).thenReturn(true)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com"), eq(PageVisit(VisitType.LINK, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `notifies configured history delegate of reloads`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com")).thenReturn(true)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", "https://www.mozilla.com", GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com"), eq(PageVisit(VisitType.RELOAD, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `checks with the delegate before trying to record a visit`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com/allowed")).thenReturn(true)
-        whenever(historyTrackingDelegate.shouldStoreUri("https://www.mozilla.com/not-allowed")).thenReturn(false)
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com/allowed", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).shouldStoreUri("https://www.mozilla.com/allowed")
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/allowed"), eq(PageVisit(VisitType.LINK, RedirectSource.NOT_A_SOURCE)))
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com/not-allowed", null, GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).shouldStoreUri("https://www.mozilla.com/not-allowed")
-        verify(historyTrackingDelegate, never()).onVisited(eq("https://www.mozilla.com/not-allowed"), any())
-    }
-
-    @Test
-    fun `correctly processes redirect visit flags`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-        whenever(historyTrackingDelegate.shouldStoreUri(any())).thenReturn(true)
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/tempredirect",
-                null,
-                // bitwise 'or'
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/tempredirect"), eq(PageVisit(VisitType.LINK, RedirectSource.TEMPORARY)))
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/permredirect",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_SOURCE_PERMANENT
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/permredirect"), eq(PageVisit(VisitType.LINK, RedirectSource.PERMANENT)))
-
-        // Visits below are targets of redirects, not redirects themselves.
-        // Check that they're mapped to "link".
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/targettemp",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_TEMPORARY
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/targettemp"), eq(PageVisit(VisitType.REDIRECT_TEMPORARY, RedirectSource.NOT_A_SOURCE)))
-
-        historyDelegate.value.onVisited(
-                geckoSession,
-                "https://www.mozilla.com/targetperm",
-                null,
-                GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL
-                        or GeckoSession.HistoryDelegate.VISIT_REDIRECT_PERMANENT
-        )
-
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).onVisited(eq("https://www.mozilla.com/targetperm"), eq(PageVisit(VisitType.REDIRECT_PERMANENT, RedirectSource.NOT_A_SOURCE)))
-    }
-
-    @Test
-    fun `does not notify configured history delegate of visits for private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.onVisited(geckoSession, "https://www.mozilla.com", "https://www.mozilla.com", GeckoSession.HistoryDelegate.VISIT_TOP_LEVEL)
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).onVisited(anyString(), any())
-    }
-
-    @Test
-    fun `requests visited URLs from configured history delegate`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        // Nothing breaks if history delegate isn't configured.
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate).getVisited(eq(listOf("https://www.mozilla.com", "https://www.mozilla.org")))
-    }
-
-    @Test
-    fun `does not request visited URLs from configured history delegate in private sessions`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext,
-                privateMode = true)
-        val historyTrackingDelegate: HistoryTrackingDelegate = mock()
-
-        captureDelegates()
-
-        engineSession.settings.historyTrackingDelegate = historyTrackingDelegate
-
-        historyDelegate.value.getVisited(geckoSession, arrayOf("https://www.mozilla.com", "https://www.mozilla.org"))
-            engineSession.job.children.forEach { it.join() }
-            verify(historyTrackingDelegate, never()).getVisited(anyList())
-    }
-
-    @Test
-    fun `notifies configured history delegate of state changes`() = runBlockingTest {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider,
-            context = coroutineContext)
-        val observer = mock<EngineSession.Observer>()
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        class MockHistoryList(
-            items: List<GeckoSession.HistoryDelegate.HistoryItem>,
-            private val currentIndex: Int
-        ) : ArrayList<GeckoSession.HistoryDelegate.HistoryItem>(items), GeckoSession.HistoryDelegate.HistoryList {
-            override fun getCurrentIndex() = currentIndex
-        }
-
-        fun mockHistoryItem(title: String?, uri: String): GeckoSession.HistoryDelegate.HistoryItem {
-            val item = mock<GeckoSession.HistoryDelegate.HistoryItem>()
-            whenever(item.title).thenReturn(title)
-            whenever(item.uri).thenReturn(uri)
-            return item
-        }
-
-        historyDelegate.value.onHistoryStateChange(mock(), MockHistoryList(emptyList(), 0))
-        verify(observer).onHistoryStateChanged(emptyList(), 0)
-
-        historyDelegate.value.onHistoryStateChange(mock(), MockHistoryList(listOf(
-            mockHistoryItem("Firefox", "https://firefox.com"),
-            mockHistoryItem("Mozilla", "http://mozilla.org"),
-            mockHistoryItem(null, "https://example.com")
-        ), 1))
-        verify(observer).onHistoryStateChanged(listOf(
-            HistoryItem("Firefox", "https://firefox.com"),
-            HistoryItem("Mozilla", "http://mozilla.org"),
-            HistoryItem("https://example.com", "https://example.com")
-        ), 1)
-    }
-
-    @Test
-    fun websiteTitleUpdates() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        val observer: EngineSession.Observer = mock()
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        contentDelegate.value.onTitleChange(geckoSession, "Hello World!")
-
-        verify(observer).onTitleChange("Hello World!")
-    }
-
-    @Test
-    fun trackingProtectionDelegateNotifiesObservers() {
-        val engineSession = GeckoEngineSession(
-            mock(),
-            geckoSessionProvider = geckoSessionProvider
-        )
-
-        var trackerBlocked: Tracker? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onTrackerBlocked(tracker: Tracker) {
-                trackerBlocked = tracker
-            }
-        })
-
-        captureDelegates()
-        var geckoCategories = 0
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.AD)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.ANALYTIC)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.SOCIAL)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.CRYPTOMINING)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.FINGERPRINTING)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.CONTENT)
-        geckoCategories = geckoCategories.or(GeckoAntiTracking.TEST)
-
-        contentBlockingDelegate.value.onContentBlocked(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", geckoCategories, 0, 0, false)
-        )
-
-        assertEquals("tracker1", trackerBlocked!!.url)
-
-        val expectedBlockedCategories = listOf(
-            TrackingCategory.AD,
-            TrackingCategory.ANALYTICS,
-            TrackingCategory.SOCIAL,
-            TrackingCategory.CRYPTOMINING,
-            TrackingCategory.FINGERPRINTING,
-            TrackingCategory.CONTENT,
-            TrackingCategory.TEST
-        )
-
-        assertTrue(trackerBlocked!!.trackingCategories.containsAll(expectedBlockedCategories))
-
-        var trackerLoaded: Tracker? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onTrackerLoaded(tracker: Tracker) {
-                trackerLoaded = tracker
-            }
-        })
-
-        var geckoCookieCategories = 0
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_ALL)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_VISITED)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_NON_TRACKERS)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_NONE)
-        geckoCookieCategories = geckoCookieCategories.or(GeckoCookieBehavior.ACCEPT_FIRST_PARTY)
-
-        contentBlockingDelegate.value.onContentLoaded(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", 0, 0, geckoCookieCategories, false)
-        )
-
-        val expectedCookieCategories = listOf(
-            CookiePolicy.ACCEPT_ONLY_FIRST_PARTY,
-            CookiePolicy.ACCEPT_NONE,
-            CookiePolicy.ACCEPT_VISITED,
-            CookiePolicy.ACCEPT_NON_TRACKERS
-        )
-
-        assertEquals("tracker1", trackerLoaded!!.url)
-        assertTrue(trackerLoaded!!.cookiePolicies.containsAll(expectedCookieCategories))
-
-        contentBlockingDelegate.value.onContentLoaded(
-            geckoSession,
-            ContentBlocking.BlockEvent("tracker1", 0, 0, GeckoCookieBehavior.ACCEPT_ALL, false)
-        )
-
-        assertTrue(
-            trackerLoaded!!.cookiePolicies.containsAll(
-                listOf(
-                    CookiePolicy.ACCEPT_ALL
-                )
-            )
-        )
-    }
-
-    @Test
-    fun `WHEN updateing tracking protection with a recommended policy THEN etpEnabled should be enabled`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-
-        val session = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        var trackerBlockingObserved = false
-
-        session.register(object : EngineSession.Observer {
-            override fun onTrackerBlockingEnabledChange(enabled: Boolean) {
-                trackerBlockingObserved = enabled
-            }
-        })
-
-        val policy = TrackingProtectionPolicy.recommended()
-        session.updateTrackingProtection(policy)
-
-        verify(session).updateContentBlocking(policy)
-        assertTrue(session.etpEnabled!!)
-        assertTrue(trackerBlockingObserved)
-    }
-
-    @Test
-    fun `WHEN calling updateTrackingProtection with a none policy THEN etpEnabled should be disabled`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-
-        val session = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        var trackerBlockingObserved = false
-
-        session.register(object : EngineSession.Observer {
-            override fun onTrackerBlockingEnabledChange(enabled: Boolean) {
-                trackerBlockingObserved = enabled
-            }
-        })
-
-        val policy = TrackingProtectionPolicy.none()
-        session.updateTrackingProtection(policy)
-
-        verify(session).updateContentBlocking(policy)
-        assertFalse(session.etpEnabled!!)
-        assertFalse(trackerBlockingObserved)
-    }
-
-    @Test
-    fun `WHEN updating the contentBlocking with a policy SCRIPTS_AND_SUB_RESOURCES useForPrivateSessions being in privateMode THEN useTrackingProtection should be true`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        val session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = true
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.select(trackingCategories = arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)).forPrivateSessionsOnly()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN calling updateContentBlocking with a policy SCRIPTS_AND_SUB_RESOURCES useForRegularSessions being in privateMode THEN useTrackingProtection should be true`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        val session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = false
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.select(trackingCategories = arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)).forRegularSessionsOnly()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN updating content blocking without a policy SCRIPTS_AND_SUB_RESOURCES for any browsing mode THEN useTrackingProtection should be false`() {
-        val geckoSetting = mock<GeckoSessionSettings>()
-        val geckoSession = mock<GeckoSession>()
-
-        var session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = false
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-        session.geckoSession = geckoSession
-
-        val policy = TrackingProtectionPolicy.none()
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting).useTrackingProtection = false
-
-        session = spy(GeckoEngineSession(
-            runtime = runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            privateMode = true
-        ))
-
-        whenever(geckoSession.settings).thenReturn(geckoSetting)
-        session.geckoSession = geckoSession
-
-        session.updateContentBlocking(policy)
-
-        verify(geckoSetting, times(2)).useTrackingProtection = false
-    }
-
-    @Test
-    fun `changes to updateTrackingProtection will be notified to all new observers`() {
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.settings.contentBlocking).thenReturn(mock())
-        val session = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        val observers = mutableListOf<EngineSession.Observer>()
-        val policy = TrackingProtectionPolicy.strict()
-
-        for (x in 1..5) {
-            observers.add(spy(object : EngineSession.Observer {}))
-        }
-
-        session.updateTrackingProtection(policy)
-
-        observers.forEach { session.register(it) }
-
-        observers.forEach {
-            verify(it).onTrackerBlockingEnabledChange(true)
-        }
-
-        observers.forEach { session.unregister(it) }
-
-        session.updateTrackingProtection(TrackingProtectionPolicy.none())
-
-        observers.forEach { session.register(it) }
-
-        observers.forEach {
-            verify(it).onTrackerBlockingEnabledChange(false)
-        }
-    }
-
-    @Test
-    fun safeBrowsingCategoriesAreAligned() {
-        assertEquals(GeckoSafeBrowsing.NONE, SafeBrowsingPolicy.NONE.id)
-        assertEquals(GeckoSafeBrowsing.MALWARE, SafeBrowsingPolicy.MALWARE.id)
-        assertEquals(GeckoSafeBrowsing.UNWANTED, SafeBrowsingPolicy.UNWANTED.id)
-        assertEquals(GeckoSafeBrowsing.HARMFUL, SafeBrowsingPolicy.HARMFUL.id)
-        assertEquals(GeckoSafeBrowsing.PHISHING, SafeBrowsingPolicy.PHISHING.id)
-        assertEquals(GeckoSafeBrowsing.DEFAULT, SafeBrowsingPolicy.RECOMMENDED.id)
-    }
-
-    @Test
-    fun trackingProtectionCategoriesAreAligned() {
-
-        assertEquals(GeckoAntiTracking.NONE, TrackingCategory.NONE.id)
-        assertEquals(GeckoAntiTracking.AD, TrackingCategory.AD.id)
-        assertEquals(GeckoAntiTracking.CONTENT, TrackingCategory.CONTENT.id)
-        assertEquals(GeckoAntiTracking.SOCIAL, TrackingCategory.SOCIAL.id)
-        assertEquals(GeckoAntiTracking.TEST, TrackingCategory.TEST.id)
-        assertEquals(GeckoAntiTracking.CRYPTOMINING, TrackingCategory.CRYPTOMINING.id)
-        assertEquals(GeckoAntiTracking.FINGERPRINTING, TrackingCategory.FINGERPRINTING.id)
-        assertEquals(GeckoAntiTracking.STP, TrackingCategory.MOZILLA_SOCIAL.id)
-
-        assertEquals(GeckoCookieBehavior.ACCEPT_ALL, CookiePolicy.ACCEPT_ALL.id)
-        assertEquals(
-            GeckoCookieBehavior.ACCEPT_NON_TRACKERS,
-            CookiePolicy.ACCEPT_NON_TRACKERS.id
-        )
-        assertEquals(GeckoCookieBehavior.ACCEPT_NONE, CookiePolicy.ACCEPT_NONE.id)
-        assertEquals(
-            GeckoCookieBehavior.ACCEPT_FIRST_PARTY, CookiePolicy.ACCEPT_ONLY_FIRST_PARTY.id
-
-        )
-        assertEquals(GeckoCookieBehavior.ACCEPT_VISITED, CookiePolicy.ACCEPT_VISITED.id)
-    }
-
-    @Test
-    fun settingTestingMode() {
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings())
-        verify(geckoSession.settings).fullAccessibilityTree = false
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings(testingModeEnabled = true))
-        verify(geckoSession.settings).fullAccessibilityTree = true
-    }
-
-    @Test
-    fun settingUserAgent() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        engineSession.settings.userAgentString
-
-        verify(geckoSession.settings).userAgentOverride
-
-        engineSession.settings.userAgentString = "test-ua"
-
-        verify(geckoSession.settings).userAgentOverride = "test-ua"
-    }
-
-    @Test
-    fun settingUserAgentDefault() {
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings(userAgentString = "test-ua"))
-
-        verify(geckoSession.settings).userAgentOverride = "test-ua"
-    }
-
-    @Test
-    fun settingSuspendMediaWhenInactive() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        verify(geckoSession.settings, never()).suspendMediaWhenInactive = anyBoolean()
-
-        assertFalse(engineSession.settings.suspendMediaWhenInactive)
-        verify(geckoSession.settings).suspendMediaWhenInactive
-
-        engineSession.settings.suspendMediaWhenInactive = true
-        verify(geckoSession.settings).suspendMediaWhenInactive = true
-    }
-
-    @Test
-    fun settingSuspendMediaWhenInactiveDefault() {
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        verify(geckoSession.settings, never()).suspendMediaWhenInactive = anyBoolean()
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings())
-        verify(geckoSession.settings).suspendMediaWhenInactive = false
-
-        GeckoEngineSession(runtime,
-            geckoSessionProvider = geckoSessionProvider,
-            defaultSettings = DefaultSettings(suspendMediaWhenInactive = true))
-        verify(geckoSession.settings).suspendMediaWhenInactive = true
-    }
-
-    @Test
-    fun settingClearColorDefault() {
-        whenever(geckoSession.compositorController).thenReturn(mock())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        verify(geckoSession.compositorController, never()).clearColor = anyInt()
-
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings())
-        verify(geckoSession.compositorController, never()).clearColor = anyInt()
-
-        GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = DefaultSettings(clearColor = Color.BLUE))
-        verify(geckoSession.compositorController).clearColor = Color.BLUE
-    }
-
-    @Test
-    fun unsupportedSettings() {
-        val settings = GeckoEngineSession(runtime,
-                geckoSessionProvider = geckoSessionProvider).settings
-
-        expectException(UnsupportedSettingException::class) {
-            settings.javascriptEnabled = true
-        }
-
-        expectException(UnsupportedSettingException::class) {
-            settings.domStorageEnabled = false
-        }
-
-        expectException(UnsupportedSettingException::class) {
-            settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-        }
-    }
-
-    @Test
-    fun settingInterceptorToProvideAlternativeContent() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return RequestInterceptor.InterceptionResponse.Content("<h1>Hello World</h1>")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        assertEquals("sample:about", interceptorCalledWithUri)
-        verify(geckoSession).load(
-            GeckoSession.Loader().data("<h1>Hello World</h1>", "text/html")
-        )
-    }
-
-    @Test
-    fun settingInterceptorToProvideAlternativeUrl() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return RequestInterceptor.InterceptionResponse.Url("https://mozilla.org")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", "trigger:uri"))
-
-        assertEquals("sample:about", interceptorCalledWithUri)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri("https://mozilla.org")
-        )
-    }
-
-    @Test
-    fun settingInterceptorCanIgnoreAppInitiatedRequests() {
-        var interceptorCalled = false
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = false
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalled = true
-                return RequestInterceptor.InterceptionResponse.Url("https://mozilla.org")
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider, defaultSettings = defaultSettings)
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", isDirectNavigation = true))
-        assertFalse(interceptorCalled)
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about", isDirectNavigation = false))
-        assertTrue(interceptorCalled)
-    }
-
-    @Test
-    fun onLoadRequestWithoutInterceptor() {
-        val defaultSettings = DefaultSettings()
-
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        verify(geckoSession, never()).load(any())
-    }
-
-    @Test
-    fun onLoadRequestWithInterceptorThatDoesNotIntercept() {
-        var interceptorCalledWithUri: String? = null
-
-        val interceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                interceptorCalledWithUri = uri
-                return null
-            }
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = interceptor)
-
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        navigationDelegate.value.onLoadRequest(geckoSession, mockLoadRequest("sample:about"))
-
-        assertEquals("sample:about", interceptorCalledWithUri!!)
-        verify(geckoSession, never()).load(any())
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithNull() {
-        var interceptedUri: String? = null
-        val requestInterceptor: RequestInterceptor = mock()
-        var defaultSettings = DefaultSettings()
-        var engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        // Interceptor is not called when there is none attached.
-        var onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-        verify(requestInterceptor, never()).onErrorRequest(engineSession, ErrorType.UNKNOWN, "")
-        onLoadError!!.then { value: String? ->
-            interceptedUri = value
-            GeckoResult.fromValue(null)
-        }
-        assertNull(interceptedUri)
-
-        // Interceptor is called correctly
-        defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        geckoSession = mockGeckoSession()
-        engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-
-        verify(requestInterceptor).onErrorRequest(engineSession, ErrorType.UNKNOWN, "")
-        onLoadError!!.then { value: String? ->
-            interceptedUri = value
-            GeckoResult.fromValue(null)
-        }
-        assertNull(interceptedUri)
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithErrorPage() {
-        val requestInterceptor: RequestInterceptor = object : RequestInterceptor {
-            override fun onErrorRequest(
-                session: EngineSession,
-                errorType: ErrorType,
-                uri: String?
-            ): RequestInterceptor.ErrorResponse? =
-                RequestInterceptor.ErrorResponse("nonNullData")
-        }
-
-        val defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider,
-                defaultSettings = defaultSettings)
-
-        captureDelegates()
-
-        val onLoadError = navigationDelegate.value.onLoadError(
-            geckoSession,
-            "about:failed",
-            WebRequestError(
-                ERROR_CATEGORY_UNKNOWN,
-                ERROR_UNKNOWN)
-        )
-
-        onLoadError!!.then { value: String? ->
-            GeckoResult.fromValue(value)
-        }
-    }
-
-    @Test
-    fun onLoadErrorCallsInterceptorWithInvalidUri() {
-        val requestInterceptor: RequestInterceptor = mock()
-        val defaultSettings = DefaultSettings(requestInterceptor = requestInterceptor)
-        val engineSession = GeckoEngineSession(runtime, defaultSettings = defaultSettings)
-
-        engineSession.geckoSession.navigationDelegate!!.onLoadError(
-            engineSession.geckoSession,
-            null,
-            WebRequestError(ERROR_MALFORMED_URI, ERROR_CATEGORY_UNKNOWN)
-        )
-        verify(requestInterceptor).onErrorRequest(engineSession, ErrorType.ERROR_MALFORMED_URI, null)
-    }
-
-    @Test
-    fun geckoErrorMappingToErrorType() {
-        assertEquals(
-            ErrorType.ERROR_SECURITY_SSL,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SECURITY_SSL)
-        )
-        assertEquals(
-            ErrorType.ERROR_SECURITY_BAD_CERT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SECURITY_BAD_CERT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_INTERRUPT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_INTERRUPT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_TIMEOUT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_TIMEOUT)
-        )
-        assertEquals(
-            ErrorType.ERROR_NET_RESET,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_NET_RESET)
-        )
-        assertEquals(
-            ErrorType.ERROR_CONNECTION_REFUSED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CONNECTION_REFUSED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_SOCKET_TYPE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_SOCKET_TYPE)
-        )
-        assertEquals(
-            ErrorType.ERROR_REDIRECT_LOOP,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_REDIRECT_LOOP)
-        )
-        assertEquals(
-            ErrorType.ERROR_OFFLINE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_OFFLINE)
-        )
-        assertEquals(
-            ErrorType.ERROR_PORT_BLOCKED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_PORT_BLOCKED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNSAFE_CONTENT_TYPE,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNSAFE_CONTENT_TYPE)
-        )
-        assertEquals(
-            ErrorType.ERROR_CORRUPTED_CONTENT,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CORRUPTED_CONTENT)
-        )
-        assertEquals(
-            ErrorType.ERROR_CONTENT_CRASHED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_CONTENT_CRASHED)
-        )
-        assertEquals(
-            ErrorType.ERROR_INVALID_CONTENT_ENCODING,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_INVALID_CONTENT_ENCODING)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_HOST,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_HOST)
-        )
-        assertEquals(
-            ErrorType.ERROR_MALFORMED_URI,
-            GeckoEngineSession.geckoErrorToErrorType(ERROR_MALFORMED_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_PROTOCOL,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_PROTOCOL)
-        )
-        assertEquals(
-            ErrorType.ERROR_FILE_NOT_FOUND,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_FILE_NOT_FOUND)
-        )
-        assertEquals(
-            ErrorType.ERROR_FILE_ACCESS_DENIED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_FILE_ACCESS_DENIED)
-        )
-        assertEquals(
-            ErrorType.ERROR_PROXY_CONNECTION_REFUSED,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_PROXY_CONNECTION_REFUSED)
-        )
-        assertEquals(
-            ErrorType.ERROR_UNKNOWN_PROXY_HOST,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_UNKNOWN_PROXY_HOST)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_MALWARE_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_MALWARE_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_HARMFUL_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_HARMFUL_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_PHISHING_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_PHISHING_URI)
-        )
-        assertEquals(
-            ErrorType.ERROR_SAFEBROWSING_UNWANTED_URI,
-            GeckoEngineSession.geckoErrorToErrorType(WebRequestError.ERROR_SAFEBROWSING_UNWANTED_URI)
-        )
-        assertEquals(
-            ErrorType.UNKNOWN,
-            GeckoEngineSession.geckoErrorToErrorType(-500)
-        )
-    }
-
-    @Test
-    fun defaultSettings() {
-        val runtime = mock<GeckoRuntime>()
-        whenever(runtime.settings).thenReturn(mock())
-
-        val defaultSettings =
-            DefaultSettings(trackingProtectionPolicy = TrackingProtectionPolicy.strict())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-                privateMode = false, defaultSettings = defaultSettings)
-
-        assertFalse(geckoSession.settings.usePrivateMode)
-        verify(geckoSession.settings).useTrackingProtection = true
-    }
-
-    @Test
-    fun `WHEN TrackingCategory do not includes content then useTrackingProtection must be set to false`() {
-        val defaultSettings =
-            DefaultSettings(trackingProtectionPolicy = TrackingProtectionPolicy.recommended())
-
-        GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider,
-            privateMode = false, defaultSettings = defaultSettings)
-
-        verify(geckoSession.settings).useTrackingProtection = false
-    }
-
-    @Test
-    fun contentDelegate() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        val delegate = engineSession.createContentDelegate()
-
-        var observedChanged = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLongPress(hitResult: HitResult) {
-                observedChanged = true
-            }
-        })
-
-        class MockContextElement(
-            baseUri: String?,
-            linkUri: String?,
-            title: String?,
-            altText: String?,
-            typeStr: String,
-            srcUri: String?
-        ) : GeckoSession.ContentDelegate.ContextElement(baseUri, linkUri, title, altText, typeStr, srcUri)
-
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "HTMLAudioElement", "file.mp3"))
-        assertTrue(observedChanged)
-
-        observedChanged = false
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "HTMLAudioElement", null))
-        assertFalse(observedChanged)
-
-        observedChanged = false
-        delegate.onContextMenu(geckoSession, 0, 0,
-            MockContextElement(null, null, "title", "alt", "foobar", null))
-        assertFalse(observedChanged)
-    }
-
-    @Test
-    fun handleLongClick() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var result = engineSession.handleLongClick("file.mp3", TYPE_AUDIO)
-        assertNotNull(result)
-        assertTrue(result is HitResult.AUDIO && result.src == "file.mp3")
-
-        result = engineSession.handleLongClick("file.mp4", TYPE_VIDEO)
-        assertNotNull(result)
-        assertTrue(result is HitResult.VIDEO && result.src == "file.mp4")
-
-        result = engineSession.handleLongClick("file.png", TYPE_IMAGE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.IMAGE && result.src == "file.png")
-
-        result = engineSession.handleLongClick("file.png", TYPE_IMAGE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.IMAGE_SRC && result.src == "file.png" && result.uri == "https://mozilla.org")
-
-        result = engineSession.handleLongClick(null, TYPE_IMAGE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "")
-
-        result = engineSession.handleLongClick("tel:+1234567890", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.PHONE && result.src == "tel:+1234567890")
-
-        result = engineSession.handleLongClick("geo:1,-1", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.GEO && result.src == "geo:1,-1")
-
-        result = engineSession.handleLongClick("mailto:asa@mozilla.com", TYPE_NONE)
-        assertNotNull(result)
-        assertTrue(result is HitResult.EMAIL && result.src == "mailto:asa@mozilla.com")
-
-        result = engineSession.handleLongClick(null, TYPE_NONE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "https://mozilla.org")
-
-        result = engineSession.handleLongClick("data://foobar", TYPE_NONE, "https://mozilla.org")
-        assertNotNull(result)
-        assertTrue(result is HitResult.UNKNOWN && result.src == "data://foobar")
-
-        result = engineSession.handleLongClick(null, TYPE_NONE, null)
-        assertNull(result)
-    }
-
-    @Test
-    fun setDesktopMode() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        var desktopModeToggled = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onDesktopModeChange(enabled: Boolean) {
-                desktopModeToggled = true
-            }
-        })
-        engineSession.toggleDesktopMode(true)
-        assertTrue(desktopModeToggled)
-
-        desktopModeToggled = false
-        whenever(geckoSession.settings.userAgentMode)
-                .thenReturn(GeckoSessionSettings.USER_AGENT_MODE_DESKTOP)
-        whenever(geckoSession.settings.viewportMode)
-                .thenReturn(GeckoSessionSettings.VIEWPORT_MODE_DESKTOP)
-
-        engineSession.toggleDesktopMode(true)
-        assertFalse(desktopModeToggled)
-
-        engineSession.toggleDesktopMode(true)
-        assertFalse(desktopModeToggled)
-
-        engineSession.toggleDesktopMode(false)
-        assertTrue(desktopModeToggled)
-    }
-
-    @Test
-    fun `toggleDesktopMode should reload a non-mobile url when set to desktop mode`() {
-        val mobileUrl = "https://m.example.com"
-        val nonMobileUrl = "https://example.com"
-        val engineSession = spy(GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider))
-        engineSession.currentUrl = mobileUrl
-
-        engineSession.toggleDesktopMode(true, reload = true)
-        verify(engineSession, atLeastOnce()).loadUrl(nonMobileUrl, null, LoadUrlFlags.select(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY), null)
-
-        engineSession.toggleDesktopMode(false, reload = true)
-        verify(engineSession, atLeastOnce()).reload()
-    }
-
-    @Test
-    fun checkForMobileSite() {
-        val mUrl = "https://m.example.com"
-        val mobileUrl = "https://mobile.example.com"
-        val nonAuthorityUrl = "mobile.example.com"
-        val unrecognizedMobilePrefixUrl = "https://phone.example.com"
-        val nonMobileUrl = "https://example.com"
-
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-
-        assertNull(engineSession.checkForMobileSite(nonAuthorityUrl))
-        assertNull(engineSession.checkForMobileSite(unrecognizedMobilePrefixUrl))
-        assertEquals(nonMobileUrl, engineSession.checkForMobileSite(mUrl))
-        assertEquals(nonMobileUrl, engineSession.checkForMobileSite(mobileUrl))
-    }
-
-    @Test
-    fun findAll() {
-        val finderResult = mock<GeckoSession.FinderResult>()
-        val sessionFinder = mock<SessionFinder>()
-        whenever(sessionFinder.find("mozilla", 0))
-                .thenReturn(GeckoResult.fromValue(finderResult))
-
-        whenever(geckoSession.finder).thenReturn(sessionFinder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var findObserved: String? = null
-        var findResultObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFind(text: String) {
-                findObserved = text
-            }
-
-            override fun onFindResult(activeMatchOrdinal: Int, numberOfMatches: Int, isDoneCounting: Boolean) {
-                assertEquals(0, activeMatchOrdinal)
-                assertEquals(0, numberOfMatches)
-                assertTrue(isDoneCounting)
-                findResultObserved = true
-            }
-        })
-
-        engineSession.findAll("mozilla")
-
-        assertEquals("mozilla", findObserved)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find("mozilla", 0)
-    }
-
-    @Test
-    fun findNext() {
-        val finderResult = mock<GeckoSession.FinderResult>()
-        val sessionFinder = mock<SessionFinder>()
-        whenever(sessionFinder.find(eq(null), anyInt()))
-                .thenReturn(GeckoResult.fromValue(finderResult))
-
-        whenever(geckoSession.finder).thenReturn(sessionFinder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        var findResultObserved = false
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFindResult(activeMatchOrdinal: Int, numberOfMatches: Int, isDoneCounting: Boolean) {
-                assertEquals(0, activeMatchOrdinal)
-                assertEquals(0, numberOfMatches)
-                assertTrue(isDoneCounting)
-                findResultObserved = true
-            }
-        })
-
-        engineSession.findNext(true)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find(null, 0)
-
-        engineSession.findNext(false)
-        assertTrue(findResultObserved)
-        verify(sessionFinder).find(null, GeckoSession.FINDER_FIND_BACKWARDS)
-    }
-
-    @Test
-    fun clearFindMatches() {
-        val finder = mock<SessionFinder>()
-        whenever(geckoSession.finder).thenReturn(finder)
-
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.clearFindMatches()
-
-        verify(finder).clear()
-    }
-
-    @Test
-    fun exitFullScreenModeTriggersExitEvent() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        // Verify the event is triggered for exiting fullscreen mode and GeckoView is called.
-        engineSession.exitFullScreenMode()
-        verify(geckoSession).exitFullScreen()
-
-        // Verify the call to the observer.
-        engineSession.register(observer)
-
-        captureDelegates()
-
-        contentDelegate.value.onFullScreen(geckoSession, true)
-
-        verify(observer).onFullScreenChange(true)
-    }
-
-    @Test
-    fun exitFullscreenTrueHasNoInteraction() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        engineSession.exitFullScreenMode()
-        verify(geckoSession).exitFullScreen()
-    }
-
-    @Test
-    fun viewportFitChangeTranslateValuesCorrectly() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        // Verify the call to the observer.
-        engineSession.register(observer)
-        captureDelegates()
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "test")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "auto")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "cover")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)
-        reset(observer)
-
-        contentDelegate.value.onMetaViewportFitChange(geckoSession, "contain")
-        verify(observer).onMetaViewportFitChanged(WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER)
-        reset(observer)
-    }
-
-    @Test
-    fun clearData() {
-        val engineSession = GeckoEngineSession(runtime, geckoSessionProvider = geckoSessionProvider)
-        val observer: EngineSession.Observer = mock()
-
-        engineSession.register(observer)
-
-        engineSession.clearData()
-
-        verifyZeroInteractions(observer)
-    }
-
-    @Test
-    fun `Closing engine session should close underlying gecko session`() {
-        val geckoSession = mockGeckoSession()
-
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = { geckoSession })
-
-        engineSession.close()
-
-        verify(geckoSession).close()
-    }
-
-    @Test
-    fun `onLoadRequest will try to intercept new window load requests`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        var result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.DENY)
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-
-        result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = false)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.DENY)
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `onLoadRequest allows new window requests if not intercepted`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        var result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("about:blank", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertNull(observedIntent)
-        assertNull(observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-
-        result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("https://www.example.com", null,
-            GeckoSession.NavigationDelegate.TARGET_WINDOW_NEW, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertNull(observedIntent)
-        assertNull(observedUrl)
-        assertNull(observedLoadUrl)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `onLoadRequest not intercepted and not new window will notify observer`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLoadUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadRequest(url: String, triggeredByRedirect: Boolean, triggeredByWebContent: Boolean) {
-                observedLoadUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        val result = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("https://www.example.com", null, triggeredByRedirect = true)
-        )
-
-        assertEquals(result!!.poll(0), AllowOrDeny.ALLOW)
-        assertEquals("https://www.example.com", observedLoadUrl)
-        assertEquals(true, observedTriggeredByRedirect)
-        assertEquals(false, observedTriggeredByWebContent)
-    }
-
-    @Test
-    fun `State provided through delegate will be returned from saveState`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        val state: GeckoSession.SessionState = mock()
-
-        var observedState: EngineSessionState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onStateUpdated(state: EngineSessionState) {
-                observedState = state
-            }
-        })
-
-        progressDelegate.value.onSessionStateChange(mock(), state)
-
-        assertNotNull(observedState)
-        assertTrue(observedState is GeckoEngineSessionState)
-
-        val actualState = (observedState as GeckoEngineSessionState).actualState
-        assertEquals(state, actualState)
-    }
-
-    @Test
-    fun `onFirstContentfulPaint notifies observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observed = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onFirstContentfulPaint() {
-                observed = true
-            }
-        })
-
-        contentDelegate.value.onFirstContentfulPaint(mock())
-        assertTrue(observed)
-    }
-
-    @Test
-    fun `onPaintStatusReset notifies observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observed = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onPaintStatusReset() {
-                observed = true
-            }
-        })
-
-        contentDelegate.value.onPaintStatusReset(mock())
-        assertTrue(observed)
-    }
-
-    @Test
-    fun `onCrash notifies observers about crash`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var crashedState = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onCrash() {
-                crashedState = true
-            }
-        })
-
-        contentDelegate.value.onCrash(mock())
-
-        assertEquals(true, crashedState)
-    }
-
-    @Test
-    fun `onLoadRequest will notify onLaunchIntent observers if request was intercepted with app intent`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-    }
-
-    @Test
-    fun `onLoadRequest keep track of the last onLoadRequest uri correctly`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                observedUrl = lastUri
-                return null
-            }
-        }
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test1"))
-        assertEquals(null, observedUrl)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test2"))
-        assertEquals("test1", observedUrl)
-
-        navigationDelegate.value.onLoadRequest(mock(), mockLoadRequest("test3"))
-        assertEquals("test2", observedUrl)
-    }
-
-    @Test
-    fun `onSubframeLoadRequest will notify onLaunchIntent observers if request was intercepted with app intent`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedUrl: String? = null
-        var observedIntent: Intent? = null
-        var observedIsSubframe = false
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                observedIsSubframe = isSubframeRequest
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), "result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedUrl = url
-                observedIntent = appIntent
-            }
-        })
-
-        navigationDelegate.value.onSubframeLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertEquals(true, observedIsSubframe)
-
-        navigationDelegate.value.onSubframeLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNotNull(observedIntent)
-        assertEquals("result", observedUrl)
-        assertEquals(true, observedIsSubframe)
-    }
-
-    @Test
-    fun `onLoadRequest will notify any observers if request was intercepted as url`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLaunchIntentUrl: String? = null
-        var observedLaunchIntent: Intent? = null
-        var observedOnLoadRequestUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun interceptsAppInitiatedRequests() = true
-
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    "sample:about" -> RequestInterceptor.InterceptionResponse.Url("result")
-                    else -> null
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedLaunchIntentUrl = url
-                observedLaunchIntent = appIntent
-            }
-
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedOnLoadRequestUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(mock(),
-            mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-        assertNull(observedOnLoadRequestUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNull(observedTriggeredByRedirect)
-        assertNull(observedTriggeredByWebContent)
-        assertNull(observedOnLoadRequestUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will notify onLoadRequest observers if request was not intercepted`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observedLaunchIntentUrl: String? = null
-        var observedLaunchIntent: Intent? = null
-        var observedOnLoadRequestUrl: String? = null
-        var observedTriggeredByRedirect: Boolean? = null
-        var observedTriggeredByWebContent: Boolean? = null
-
-        engineSession.settings.requestInterceptor = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLaunchIntentRequest(
-                url: String,
-                appIntent: Intent?
-            ) {
-                observedLaunchIntentUrl = url
-                observedLaunchIntent = appIntent
-            }
-
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedOnLoadRequestUrl = url
-                observedTriggeredByRedirect = triggeredByRedirect
-                observedTriggeredByWebContent = triggeredByWebContent
-            }
-        })
-
-        navigationDelegate.value.onLoadRequest(mock(),
-            mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNotNull(observedTriggeredByRedirect)
-        assertTrue(observedTriggeredByRedirect!!)
-        assertNotNull(observedTriggeredByWebContent)
-        assertFalse(observedTriggeredByWebContent!!)
-        assertEquals("sample:about", observedOnLoadRequestUrl)
-
-        navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = false))
-
-        assertNull(observedLaunchIntentUrl)
-        assertNull(observedLaunchIntent)
-        assertNotNull(observedTriggeredByRedirect)
-        assertFalse(observedTriggeredByRedirect!!)
-        assertNotNull(observedTriggeredByWebContent)
-        assertFalse(observedTriggeredByWebContent!!)
-        assertEquals("sample:about", observedOnLoadRequestUrl)
-    }
-
-    @Test
-    fun `onLoadRequest will notify observers if the url is loaded from the user interacting with chrome`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        val fakeUrl = "https://example.com"
-        var observedUrl: String?
-        var observedTriggeredByWebContent: Boolean?
-
-        engineSession.settings.requestInterceptor = object : RequestInterceptor {
-            override fun onLoadRequest(
-                engineSession: EngineSession,
-                uri: String,
-                lastUri: String?,
-                hasUserGesture: Boolean,
-                isSameDomain: Boolean,
-                isRedirect: Boolean,
-                isDirectNavigation: Boolean,
-                isSubframeRequest: Boolean
-            ): RequestInterceptor.InterceptionResponse? {
-                return when (uri) {
-                    fakeUrl -> null
-                    else -> RequestInterceptor.InterceptionResponse.AppIntent(mock(), fakeUrl)
-                }
-            }
-        }
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onLoadRequest(
-                url: String,
-                triggeredByRedirect: Boolean,
-                triggeredByWebContent: Boolean
-            ) {
-                observedTriggeredByWebContent = triggeredByWebContent
-                observedUrl = url
-            }
-        })
-
-        fun fakePageLoad(expectedTriggeredByWebContent: Boolean) {
-            observedTriggeredByWebContent = null
-            observedUrl = null
-            navigationDelegate.value.onLoadRequest(
-                mock(), mockLoadRequest(fakeUrl, triggeredByRedirect = true,
-                hasUserGesture = expectedTriggeredByWebContent))
-            progressDelegate.value.onPageStop(mock(), true)
-            assertNotNull(observedTriggeredByWebContent)
-            assertEquals(expectedTriggeredByWebContent, observedTriggeredByWebContent!!)
-            assertNotNull(observedUrl)
-            assertEquals(fakeUrl, observedUrl)
-        }
-
-        // loadUrl(url: String)
-        engineSession.loadUrl(fakeUrl)
-        verify(geckoSession).load(
-            GeckoSession.Loader().uri(fakeUrl)
-        )
-        fakePageLoad(false)
-
-        // subsequent page loads _are_ from web content
-        fakePageLoad(true)
-
-        // loadData(data: String, mimeType: String, encoding: String)
-        val fakeData = "data://"
-        val fakeMimeType = ""
-        val fakeEncoding = ""
-        engineSession.loadData(data = fakeData, mimeType = fakeMimeType, encoding = fakeEncoding)
-        verify(geckoSession).load(
-            GeckoSession.Loader().data(fakeData, fakeMimeType)
-        )
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // reload()
-        engineSession.initialLoadRequest = null
-        engineSession.reload()
-        verify(geckoSession).reload(GeckoSession.LOAD_FLAGS_NONE)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goBack()
-        engineSession.goBack()
-        verify(geckoSession).goBack()
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goForward()
-        engineSession.goForward()
-        verify(geckoSession).goForward()
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // toggleDesktopMode()
-        engineSession.toggleDesktopMode(false, reload = true)
-        // This is the second time in this test, so we actually want two invocations.
-        verify(geckoSession, times(2)).reload(GeckoSession.LOAD_FLAGS_NONE)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-
-        // goToHistoryIndex(index: Int)
-        engineSession.goToHistoryIndex(0)
-        verify(geckoSession).gotoHistoryIndex(0)
-        fakePageLoad(false)
-
-        fakePageLoad(true)
-    }
-
-    @Test
-    fun `onLoadRequest will return correct GeckoResult if no observer is available`() {
-        GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-        captureDelegates()
-
-        val geckoResult = navigationDelegate.value.onLoadRequest(
-            mock(), mockLoadRequest("sample:about", triggeredByRedirect = true))
-
-        assertEquals(geckoResult!!, GeckoResult.fromValue(AllowOrDeny.ALLOW))
-    }
-
-    @Test
-    fun loadFlagsAreAligned() {
-        assertEquals(LoadUrlFlags.BYPASS_CACHE, GeckoSession.LOAD_FLAGS_BYPASS_CACHE)
-        assertEquals(LoadUrlFlags.BYPASS_PROXY, GeckoSession.LOAD_FLAGS_BYPASS_PROXY)
-        assertEquals(LoadUrlFlags.EXTERNAL, GeckoSession.LOAD_FLAGS_EXTERNAL)
-        assertEquals(LoadUrlFlags.ALLOW_POPUPS, GeckoSession.LOAD_FLAGS_ALLOW_POPUPS)
-        assertEquals(LoadUrlFlags.BYPASS_CLASSIFIER, GeckoSession.LOAD_FLAGS_BYPASS_CLASSIFIER)
-        assertEquals(LoadUrlFlags.LOAD_FLAGS_FORCE_ALLOW_DATA_URI, GeckoSession.LOAD_FLAGS_FORCE_ALLOW_DATA_URI)
-        assertEquals(LoadUrlFlags.LOAD_FLAGS_REPLACE_HISTORY, GeckoSession.LOAD_FLAGS_REPLACE_HISTORY)
-    }
-
-    @Test
-    fun `onKill will notify observers`() {
-        val engineSession = GeckoEngineSession(mock(),
-            geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var observerNotified = false
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onProcessKilled() {
-                observerNotified = true
-            }
-        })
-
-        val mockedState: GeckoSession.SessionState = mock()
-        progressDelegate.value.onSessionStateChange(geckoSession, mockedState)
-
-        contentDelegate.value.onKill(geckoSession)
-
-        assertTrue(observerNotified)
-    }
-
-    @Test
-    fun `onNewSession creates window request`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var receivedWindowRequest: WindowRequest? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onWindowRequest(windowRequest: WindowRequest) {
-                receivedWindowRequest = windowRequest
-            }
-        })
-
-        navigationDelegate.value.onNewSession(mock(), "mozilla.org")
-
-        assertNotNull(receivedWindowRequest)
-        assertEquals("mozilla.org", receivedWindowRequest!!.url)
-        assertEquals(WindowRequest.Type.OPEN, receivedWindowRequest!!.type)
-    }
-
-    @Test
-    fun `onCloseRequest creates window request`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        captureDelegates()
-
-        var receivedWindowRequest: WindowRequest? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onWindowRequest(windowRequest: WindowRequest) {
-                receivedWindowRequest = windowRequest
-            }
-        })
-
-        contentDelegate.value.onCloseRequest(geckoSession)
-
-        assertNotNull(receivedWindowRequest)
-        assertSame(engineSession, receivedWindowRequest!!.prepare())
-        assertEquals(WindowRequest.Type.CLOSE, receivedWindowRequest!!.type)
-    }
-
-    class MockSecurityInformation(
-        origin: String? = null,
-        certificate: X509Certificate? = null
-    ) : SecurityInformation() {
-        init {
-            origin?.let {
-                ReflectionUtils.setField(this, "origin", origin)
-            }
-            certificate?.let {
-                ReflectionUtils.setField(this, "certificate", certificate)
-            }
-        }
-    }
-
-    @Test
-    fun `certificate issuer is parsed and provided onSecurityChange`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = "Verified By: CN=Digicert SHA2 Extended Validation Server CA,OU=www.digicert.com,O=DigiCert Inc,C=US"
-        val parsedIssuerName = "DigiCert Inc"
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `certificate issuer is parsed and provided onSecurityChange with null arg`() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = null
-        val parsedIssuerName = null
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `pattern-breaking certificate issuer isnt parsed and returns original name `() {
-        val engineSession = GeckoEngineSession(mock(), geckoSessionProvider = geckoSessionProvider)
-
-        var observedIssuer: String? = null
-        engineSession.register(object : EngineSession.Observer {
-            override fun onSecurityChange(secure: Boolean, host: String?, issuer: String?) {
-                observedIssuer = issuer
-            }
-        })
-
-        captureDelegates()
-
-        val unparsedIssuerName = "pattern breaking cert"
-        val parsedIssuerName = "pattern breaking cert"
-        val certificate: X509Certificate = mock()
-        val principal: Principal = mock()
-        whenever(principal.name).thenReturn(unparsedIssuerName)
-        whenever(certificate.issuerDN).thenReturn(principal)
-
-        val securityInformation = MockSecurityInformation(certificate = certificate)
-        progressDelegate.value.onSecurityChange(mock(), securityInformation)
-        assertEquals(parsedIssuerName, observedIssuer)
-    }
-
-    @Test
-    fun `GIVEN canGoBack true WHEN goBack() is called THEN verify EngineObserver onNavigateBack() is triggered`() {
-        var observedOnNavigateBack = false
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        engineSession.register(object : EngineSession.Observer {
-            override fun onNavigateBack() {
-                observedOnNavigateBack = true
-            }
-        })
-
-        captureDelegates()
-        navigationDelegate.value.onCanGoBack(mock(), true)
-        engineSession.goBack()
-        assertTrue(observedOnNavigateBack)
-    }
-
-    @Test
-    fun `GIVEN canGoBack false WHEN goBack() is called THEN verify EngineObserver onNavigateBack() is not triggered`() {
-        var observedOnNavigateBack = false
-        val engineSession = GeckoEngineSession(mock(),
-                geckoSessionProvider = geckoSessionProvider)
-        engineSession.register(object : EngineSession.Observer {
-            override fun onNavigateBack() {
-                observedOnNavigateBack = true
-            }
-        })
-
-        captureDelegates()
-        navigationDelegate.value.onCanGoBack(mock(), false)
-        engineSession.goBack()
-        assertFalse(observedOnNavigateBack)
-    }
-
-    private fun mockGeckoSession(): GeckoSession {
-        val session = mock<GeckoSession>()
-        whenever(session.settings).thenReturn(
-            mock())
-        return session
-    }
-
-    private fun mockLoadRequest(
-        uri: String,
-        triggerUri: String? = null,
-        target: Int = 0,
-        triggeredByRedirect: Boolean = false,
-        hasUserGesture: Boolean = false,
-        isDirectNavigation: Boolean = false
-    ): GeckoSession.NavigationDelegate.LoadRequest {
-        var flags = 0
-        if (triggeredByRedirect) {
-            flags = flags or 0x800000
-        }
-
-        val constructor = GeckoSession.NavigationDelegate.LoadRequest::class.java.getDeclaredConstructor(
-            String::class.java,
-            String::class.java,
-            Int::class.java,
-            Int::class.java,
-            Boolean::class.java,
-            Boolean::class.java)
-        constructor.isAccessible = true
-
-        return constructor.newInstance(uri, triggerUri, target, flags, hasUserGesture, isDirectNavigation)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt
deleted file mode 100644
index eb9bdb294ca4..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineTest.kt
+++ /dev/null
@@ -1,2064 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.graphics.Color
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.ext.getAntiTrackingPolicy
-import mozilla.components.browser.engine.gecko.mediaquery.toGeckoValue
-import mozilla.components.browser.engine.gecko.util.SpeculativeEngineSession
-import mozilla.components.browser.engine.gecko.util.SpeculativeSessionObserver
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession.SafeBrowsingPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.CookiePolicy
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy.TrackingCategory
-import mozilla.components.concept.engine.UnsupportedSettingException
-import mozilla.components.concept.engine.content.blocking.TrackerLog
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionExceptionStorage
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.WebExtension
-import mozilla.components.concept.engine.webextension.WebExtensionDelegate
-import mozilla.components.concept.engine.webextension.WebExtensionException
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNotSame
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentMatchers.anyBoolean
-import org.mockito.ArgumentMatchers.anyFloat
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.Mockito.never
-import org.mockito.Mockito.reset
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.ContentBlocking
-import org.mozilla.geckoview.ContentBlocking.CookieBehavior
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.Event
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoRuntimeSettings
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.MockWebExtension
-import org.mozilla.geckoview.StorageController
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_CORRUPT_FILE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_FILE_ACCESS
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_INCORRECT_HASH
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_INCORRECT_ID
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_NETWORK_FAILURE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_POSTPONED
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_SIGNEDSTATE_REQUIRED
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_UNEXPECTED_ADDON_TYPE
-import org.mozilla.geckoview.WebExtension.InstallException.ErrorCodes.ERROR_USER_CANCELED
-import org.mozilla.geckoview.WebExtensionController
-import org.mozilla.geckoview.WebPushController
-import org.robolectric.Robolectric
-import java.io.IOException
-import org.mozilla.geckoview.WebExtension as GeckoWebExtension
-
-typealias GeckoInstallException = org.mozilla.geckoview.WebExtension.InstallException
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineTest {
-
-    private lateinit var runtime: GeckoRuntime
-    private lateinit var context: Context
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        context = mock()
-    }
-
-    @Test
-    fun createView() {
-        assertTrue(GeckoEngine(context, runtime = runtime).createView(
-            Robolectric.buildActivity(Activity::class.java).get()
-        ) is GeckoEngineView)
-    }
-
-    @Test
-    fun createSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertTrue(engine.createSession() is GeckoEngineSession)
-
-        // Create a private speculative session and consume it
-        engine.speculativeCreateSession(private = true)
-        assertTrue(engine.speculativeConnectionFactory.hasSpeculativeSession())
-        var privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertSame(privateSpeculativeSession, engine.createSession(private = true))
-        assertFalse(engine.speculativeConnectionFactory.hasSpeculativeSession())
-
-        // Create a regular speculative session and make sure it is not returned
-        // if a private session is requested instead.
-        engine.speculativeCreateSession(private = false)
-        assertTrue(engine.speculativeConnectionFactory.hasSpeculativeSession())
-        privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertNotSame(privateSpeculativeSession, engine.createSession(private = true))
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(privateSpeculativeSession.geckoSession.isOpen)
-        assertFalse(engine.speculativeConnectionFactory.hasSpeculativeSession())
-    }
-
-    @Test
-    fun speculativeCreateSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        // Create a private speculative session
-        engine.speculativeCreateSession(private = true)
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        val privateSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!
-        assertTrue(privateSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-
-        // Creating another private speculative session should have no effect as
-        // session hasn't been "consumed".
-        engine.speculativeCreateSession(private = true)
-        assertSame(privateSpeculativeSession, engine.speculativeConnectionFactory.speculativeEngineSession)
-        assertTrue(privateSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-
-        // Creating a non-private speculative session should affect prepared session
-        engine.speculativeCreateSession(private = false)
-        assertNotSame(privateSpeculativeSession, engine.speculativeConnectionFactory.speculativeEngineSession)
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(privateSpeculativeSession.engineSession.geckoSession.isOpen)
-        val regularSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!
-        assertFalse(regularSpeculativeSession.engineSession.geckoSession.settings.usePrivateMode)
-    }
-
-    @Test
-    fun clearSpeculativeSession() {
-        val engine = GeckoEngine(context, runtime = runtime)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        val mockEngineSession: GeckoEngineSession = mock()
-        val mockEngineSessionObserver: SpeculativeSessionObserver = mock()
-        engine.speculativeConnectionFactory.speculativeEngineSession =
-            SpeculativeEngineSession(mockEngineSession, mockEngineSessionObserver)
-        engine.clearSpeculativeSession()
-
-        verify(mockEngineSession).unregister(mockEngineSessionObserver)
-        verify(mockEngineSession).close()
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `createSession with contextId`() {
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        // Create a speculative session with a context id and consume it
-        engine.speculativeCreateSession(private = false, contextId = "1")
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        var newSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertSame(newSpeculativeSession, engine.createSession(private = false, contextId = "1"))
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-
-        // Create a regular speculative session and make sure it is not returned
-        // if a session with a context id is requested instead.
-        engine.speculativeCreateSession(private = false)
-        assertNotNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-        newSpeculativeSession = engine.speculativeConnectionFactory.speculativeEngineSession!!.engineSession
-        assertNotSame(newSpeculativeSession, engine.createSession(private = false, contextId = "1"))
-        // Make sure previous (never used) speculative session is now closed
-        assertFalse(newSpeculativeSession.geckoSession.isOpen)
-        assertNull(engine.speculativeConnectionFactory.speculativeEngineSession)
-    }
-
-    @Test
-    fun name() {
-        assertEquals("Gecko", GeckoEngine(context, runtime = runtime).name())
-    }
-
-    @Test
-    fun settings() {
-        val defaultSettings = DefaultSettings()
-        val contentBlockingSettings = ContentBlocking.Settings.Builder().build()
-        val runtime = mock<GeckoRuntime>()
-        val runtimeSettings = mock<GeckoRuntimeSettings>()
-        whenever(runtimeSettings.javaScriptEnabled).thenReturn(true)
-        whenever(runtimeSettings.webFontsEnabled).thenReturn(true)
-        whenever(runtimeSettings.automaticFontSizeAdjustment).thenReturn(true)
-        whenever(runtimeSettings.fontInflationEnabled).thenReturn(true)
-        whenever(runtimeSettings.fontSizeFactor).thenReturn(1.0F)
-        whenever(runtimeSettings.forceUserScalableEnabled).thenReturn(false)
-        whenever(runtimeSettings.loginAutofillEnabled).thenReturn(false)
-        whenever(runtimeSettings.contentBlocking).thenReturn(contentBlockingSettings)
-        whenever(runtimeSettings.preferredColorScheme).thenReturn(GeckoRuntimeSettings.COLOR_SCHEME_SYSTEM)
-        whenever(runtime.settings).thenReturn(runtimeSettings)
-        val engine = GeckoEngine(context, runtime = runtime, defaultSettings = defaultSettings)
-
-        assertTrue(engine.settings.javascriptEnabled)
-        engine.settings.javascriptEnabled = false
-        verify(runtimeSettings).javaScriptEnabled = false
-
-        assertFalse(engine.settings.loginAutofillEnabled)
-        engine.settings.loginAutofillEnabled = true
-        verify(runtimeSettings).loginAutofillEnabled = true
-
-        assertTrue(engine.settings.webFontsEnabled)
-        engine.settings.webFontsEnabled = false
-        verify(runtimeSettings).webFontsEnabled = false
-
-        assertTrue(engine.settings.automaticFontSizeAdjustment)
-        engine.settings.automaticFontSizeAdjustment = false
-        verify(runtimeSettings).automaticFontSizeAdjustment = false
-
-        assertTrue(engine.settings.fontInflationEnabled!!)
-        engine.settings.fontInflationEnabled = null
-        verify(runtimeSettings, never()).fontInflationEnabled = anyBoolean()
-        engine.settings.fontInflationEnabled = false
-        verify(runtimeSettings).fontInflationEnabled = false
-
-        assertEquals(1.0F, engine.settings.fontSizeFactor)
-        engine.settings.fontSizeFactor = null
-        verify(runtimeSettings, never()).fontSizeFactor = anyFloat()
-        engine.settings.fontSizeFactor = 2.0F
-        verify(runtimeSettings).fontSizeFactor = 2.0F
-
-        assertFalse(engine.settings.forceUserScalableContent)
-        engine.settings.forceUserScalableContent = true
-        verify(runtimeSettings).forceUserScalableEnabled = true
-
-        assertFalse(engine.settings.remoteDebuggingEnabled)
-        engine.settings.remoteDebuggingEnabled = true
-        verify(runtimeSettings).remoteDebuggingEnabled = true
-
-        assertFalse(engine.settings.testingModeEnabled)
-        engine.settings.testingModeEnabled = true
-        assertTrue(engine.settings.testingModeEnabled)
-
-        assertEquals(PreferredColorScheme.System, engine.settings.preferredColorScheme)
-        engine.settings.preferredColorScheme = PreferredColorScheme.Dark
-        verify(runtimeSettings).preferredColorScheme = PreferredColorScheme.Dark.toGeckoValue()
-
-        assertFalse(engine.settings.suspendMediaWhenInactive)
-        engine.settings.suspendMediaWhenInactive = true
-        assertEquals(true, engine.settings.suspendMediaWhenInactive)
-
-        assertNull(engine.settings.clearColor)
-        engine.settings.clearColor = Color.BLUE
-        assertEquals(Color.BLUE, engine.settings.clearColor)
-
-        // Specifying no ua-string default should result in GeckoView's default.
-        assertEquals(GeckoSession.getDefaultUserAgent(), engine.settings.userAgentString)
-        // It also should be possible to read and set a new default.
-        engine.settings.userAgentString = engine.settings.userAgentString + "-test"
-        assertEquals(GeckoSession.getDefaultUserAgent() + "-test", engine.settings.userAgentString)
-
-        assertEquals(null, engine.settings.trackingProtectionPolicy)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory =
-            TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        val safeStrictBrowsingCategories = SafeBrowsingPolicy.RECOMMENDED.id
-        assertEquals(safeStrictBrowsingCategories, contentBlockingSettings.safeBrowsingCategories)
-
-        engine.settings.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.PHISHING)
-        assertEquals(SafeBrowsingPolicy.PHISHING.id, contentBlockingSettings.safeBrowsingCategories)
-
-        assertEquals(defaultSettings.trackingProtectionPolicy, TrackingProtectionPolicy.strict())
-        assertEquals(contentBlockingSettings.cookieBehavior, CookiePolicy.ACCEPT_NON_TRACKERS.id)
-
-        try {
-            engine.settings.domStorageEnabled
-            fail("Expected UnsupportedOperationException")
-        } catch (e: UnsupportedSettingException) { }
-
-        try {
-            engine.settings.domStorageEnabled = false
-            fail("Expected UnsupportedOperationException")
-        } catch (e: UnsupportedSettingException) { }
-    }
-
-    @Test
-    fun `the SCRIPTS_AND_SUB_RESOURCES tracking protection category must not be passed to gecko view`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory = TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            mockRuntime.settings.contentBlocking.antiTrackingCategories
-        )
-
-        mockRuntime.settings.contentBlocking.setAntiTracking(0)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            arrayOf(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES)
-        )
-
-        assertEquals(0, mockRuntime.settings.contentBlocking.antiTrackingCategories)
-    }
-
-    @Test
-    fun `WHEN a strict tracking protection policy is set THEN the strict social list must be activated`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(true)
-    }
-
-    @Test
-    fun `WHEN a strict tracking protection policy is set THEN the setEnhancedTrackingProtectionLevel must be STRICT`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-    }
-
-    @Test
-    fun `setAntiTracking is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setAntiTracking(
-            policy.getAntiTrackingPolicy()
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setAntiTracking(
-            policy.getAntiTrackingPolicy()
-        )
-    }
-
-    @Test
-    fun `cookiePurging is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setCookiePurging(policy.cookiePurging)
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setCookiePurging(policy.cookiePurging)
-    }
-
-    @Test
-    fun `setCookieBehavior is only invoked when the value is changed`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-        whenever(mockRuntime.settings.contentBlocking.cookieBehavior).thenReturn(CookieBehavior.ACCEPT_NONE)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-        val policy = TrackingProtectionPolicy.recommended()
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking).setCookieBehavior(
-            policy.cookiePolicy.id
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = policy
-
-        verify(mockRuntime.settings.contentBlocking, never()).setCookieBehavior(
-            policy.cookiePolicy.id
-        )
-    }
-
-    @Test
-    fun `setEnhancedTrackingProtectionLevel MUST always be set to STRICT unless the tracking protection policy is none`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        val settings = spy(ContentBlocking.Settings.Builder().build())
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(settings)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.NONE
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-        verify(mockRuntime.settings.contentBlocking, never()).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.NONE
-        )
-
-        reset(settings)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        verify(mockRuntime.settings.contentBlocking).setEnhancedTrackingProtectionLevel(
-            ContentBlocking.EtpLevel.STRICT
-        )
-    }
-
-    @Test
-    fun `WHEN a non strict tracking protection policy is set THEN the strict social list must be disabled`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking.strictSocialTrackingProtection).thenReturn(true)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(false)
-    }
-
-    @Test
-    fun `WHEN strict social tracking protection is set to true THEN the strict social list must be activated`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            strictSocialTrackingProtection = true
-        )
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(true)
-    }
-
-    @Test
-    fun `WHEN strict social tracking protection is set to false THEN the strict social list must be disabled`() {
-        val mockRuntime = mock<GeckoRuntime>()
-        whenever(mockRuntime.settings).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking).thenReturn(mock())
-        whenever(mockRuntime.settings.contentBlocking.strictSocialTrackingProtection).thenReturn(true)
-
-        val engine = GeckoEngine(testContext, runtime = mockRuntime)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            strictSocialTrackingProtection = false
-        )
-
-        verify(mockRuntime.settings.contentBlocking).setStrictSocialTrackingProtection(false)
-    }
-
-    @Test
-    fun defaultSettings() {
-        val runtime = mock<GeckoRuntime>()
-        val runtimeSettings = mock<GeckoRuntimeSettings>()
-        val contentBlockingSettings = ContentBlocking.Settings.Builder().build()
-        whenever(runtimeSettings.javaScriptEnabled).thenReturn(true)
-        whenever(runtime.settings).thenReturn(runtimeSettings)
-        whenever(runtimeSettings.contentBlocking).thenReturn(contentBlockingSettings)
-        whenever(runtimeSettings.fontInflationEnabled).thenReturn(true)
-
-        val engine = GeckoEngine(context,
-            DefaultSettings(
-                trackingProtectionPolicy = TrackingProtectionPolicy.strict(),
-                javascriptEnabled = false,
-                webFontsEnabled = false,
-                automaticFontSizeAdjustment = false,
-                fontInflationEnabled = false,
-                fontSizeFactor = 2.0F,
-                remoteDebuggingEnabled = true,
-                testingModeEnabled = true,
-                userAgentString = "test-ua",
-                preferredColorScheme = PreferredColorScheme.Light,
-                suspendMediaWhenInactive = true,
-                forceUserScalableContent = false
-            ), runtime)
-
-        verify(runtimeSettings).javaScriptEnabled = false
-        verify(runtimeSettings).webFontsEnabled = false
-        verify(runtimeSettings).automaticFontSizeAdjustment = false
-        verify(runtimeSettings).fontInflationEnabled = false
-        verify(runtimeSettings).fontSizeFactor = 2.0F
-        verify(runtimeSettings).remoteDebuggingEnabled = true
-        verify(runtimeSettings).forceUserScalableEnabled = false
-
-        val trackingStrictCategories = TrackingProtectionPolicy.strict().trackingCategories.sumBy { it.id }
-        val artificialCategory =
-            TrackingCategory.SCRIPTS_AND_SUB_RESOURCES.id
-        assertEquals(
-            trackingStrictCategories - artificialCategory,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        assertEquals(SafeBrowsingPolicy.RECOMMENDED.id, contentBlockingSettings.safeBrowsingCategories)
-
-        assertEquals(CookiePolicy.ACCEPT_NON_TRACKERS.id, contentBlockingSettings.cookieBehavior)
-        assertTrue(engine.settings.testingModeEnabled)
-        assertEquals("test-ua", engine.settings.userAgentString)
-        assertEquals(PreferredColorScheme.Light, engine.settings.preferredColorScheme)
-        assertTrue(engine.settings.suspendMediaWhenInactive)
-
-        engine.settings.safeBrowsingPolicy = arrayOf(SafeBrowsingPolicy.PHISHING)
-        engine.settings.trackingProtectionPolicy =
-            TrackingProtectionPolicy.select(
-                trackingCategories = arrayOf(TrackingProtectionPolicy.TrackingCategory.AD),
-                cookiePolicy = CookiePolicy.ACCEPT_ONLY_FIRST_PARTY
-            )
-
-        assertEquals(
-            TrackingProtectionPolicy.TrackingCategory.AD.id,
-            contentBlockingSettings.antiTrackingCategories
-        )
-
-        assertEquals(
-            SafeBrowsingPolicy.PHISHING.id,
-            contentBlockingSettings.safeBrowsingCategories
-        )
-
-        assertEquals(
-            CookiePolicy.ACCEPT_ONLY_FIRST_PARTY.id,
-            contentBlockingSettings.cookieBehavior
-        )
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.none()
-
-        assertEquals(CookiePolicy.ACCEPT_ALL.id, contentBlockingSettings.cookieBehavior)
-    }
-
-    @Test
-    fun `speculativeConnect forwards call to executor`() {
-        val executor: GeckoWebExecutor = mock()
-
-        val engine = GeckoEngine(context, runtime = runtime, executorProvider = { executor })
-
-        engine.speculativeConnect("https://www.mozilla.org")
-
-        verify(executor).speculativeConnect("https://www.mozilla.org")
-    }
-
-    @Test
-    fun `install built-in web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<GeckoWebExtension>()
-
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(
-            extId,
-            extUrl,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extUrlCaptor = argumentCaptor<String>()
-        val extIdCaptor = argumentCaptor<String>()
-        verify(extensionController).ensureBuiltIn(extUrlCaptor.capture(), extIdCaptor.capture())
-        assertEquals(extUrl, extUrlCaptor.value)
-        assertEquals(extId, extIdCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `install external web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<GeckoWebExtension>()
-
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(
-            extId,
-            extUrl,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<String>()
-        verify(extensionController).install(extCaptor.capture())
-        assertEquals(extUrl, extCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `install built-in web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<GeckoWebExtension>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `install external web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<GeckoWebExtension>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `uninstall web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val nativeExtension = mockNativeExtension("test-webext", "https://addons.mozilla.org/1/some_web_ext.xpi")
-        val ext = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            nativeExtension,
-            runtime
-        )
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val result = GeckoResult<Void>()
-
-        whenever(extensionController.uninstall(any())).thenReturn(result)
-        engine.uninstallWebExtension(
-            ext,
-            onSuccess = { onSuccessCalled = true },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        result.complete(null)
-        verify(webExtensionsDelegate).onUninstalled(ext)
-
-        val extCaptor = argumentCaptor<GeckoWebExtension>()
-        verify(extensionController).uninstall(extCaptor.capture())
-        assertSame(nativeExtension, extCaptor.value)
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-    }
-
-    @Test
-    fun `uninstall web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val nativeExtension = mockNativeExtension(
-            "test-webext",
-            "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-        )
-        val ext = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            nativeExtension,
-            runtime
-        )
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var onErrorCalled = false
-        val expected = IOException()
-        val result = GeckoResult<Void>()
-
-        var throwable: Throwable? = null
-        whenever(extensionController.uninstall(any())).thenReturn(result)
-        engine.uninstallWebExtension(ext) { _, e ->
-            onErrorCalled = true
-            throwable = e
-        }
-        result.completeExceptionally(expected)
-        verify(webExtensionsDelegate, never()).onUninstalled(ext)
-
-        assertTrue(onErrorCalled)
-        assertEquals(expected, throwable)
-    }
-
-    @Test
-    fun `web extension delegate handles installation of built-in extensions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(webExtensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstalled(extCaptor.capture())
-        assertEquals(extId, extCaptor.value.id)
-        assertEquals(extUrl, extCaptor.value.url)
-    }
-
-    @Test
-    fun `web extension delegate handles installation of external extensions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/123/some_web_ext.xpi"
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(webExtensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        result.complete(mockNativeExtension(extId, extUrl))
-
-        val extCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstalled(extCaptor.capture())
-        assertEquals(extId, extCaptor.value.id)
-        assertEquals(extUrl, extCaptor.value.url)
-    }
-
-    @Test
-    fun `web extension delegate handles install prompt`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val extension = mockNativeExtension("test", "uri")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        assertEquals(GeckoResult.deny(), geckoDelegateCaptor.value.onInstallPrompt(extension))
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onInstallPermissionRequest(extensionCaptor.capture())
-        val capturedExtension =
-                extensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(extension, capturedExtension.nativeExtension)
-
-        whenever(webExtensionsDelegate.onInstallPermissionRequest(any())).thenReturn(true)
-        assertEquals(GeckoResult.allow(), geckoDelegateCaptor.value.onInstallPrompt(extension))
-    }
-
-    @Test
-    fun `web extension delegate handles update prompt`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val currentExtension = mockNativeExtension("test", "uri")
-        val updatedExtension = mockNativeExtension("testUpdated", "uri")
-        val updatedPermissions = arrayOf("p1", "p2")
-        val hostPermissions = arrayOf("p3", "p4")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        val result = geckoDelegateCaptor.value.onUpdatePrompt(
-            currentExtension, updatedExtension, updatedPermissions, hostPermissions
-        )
-        assertNotNull(result)
-
-        val currentExtensionCaptor = argumentCaptor<WebExtension>()
-        val updatedExtensionCaptor = argumentCaptor<WebExtension>()
-        val onPermissionsGrantedCaptor = argumentCaptor<((Boolean) -> Unit)>()
-        verify(webExtensionsDelegate).onUpdatePermissionRequest(
-            currentExtensionCaptor.capture(),
-            updatedExtensionCaptor.capture(),
-            eq(updatedPermissions.toList() + hostPermissions.toList()),
-            onPermissionsGrantedCaptor.capture()
-        )
-        val current =
-            currentExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(currentExtension, current.nativeExtension)
-        val updated =
-            updatedExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(updatedExtension, updated.nativeExtension)
-
-        onPermissionsGrantedCaptor.value.invoke(true)
-        assertEquals(GeckoResult.allow(), result)
-    }
-
-    @Test
-    fun `web extension delegate handles update prompt with empty host permissions`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val currentExtension = mockNativeExtension("test", "uri")
-        val updatedExtension = mockNativeExtension("testUpdated", "uri")
-        val updatedPermissions = arrayOf("p1", "p2")
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val geckoDelegateCaptor = argumentCaptor<WebExtensionController.PromptDelegate>()
-        verify(webExtensionController).promptDelegate = geckoDelegateCaptor.capture()
-
-        val result = geckoDelegateCaptor.value.onUpdatePrompt(
-                currentExtension, updatedExtension, updatedPermissions, emptyArray()
-        )
-        assertNotNull(result)
-
-        val currentExtensionCaptor = argumentCaptor<WebExtension>()
-        val updatedExtensionCaptor = argumentCaptor<WebExtension>()
-        val onPermissionsGrantedCaptor = argumentCaptor<((Boolean) -> Unit)>()
-        verify(webExtensionsDelegate).onUpdatePermissionRequest(
-            currentExtensionCaptor.capture(),
-            updatedExtensionCaptor.capture(),
-            eq(updatedPermissions.toList()),
-            onPermissionsGrantedCaptor.capture()
-        )
-        val current =
-                currentExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(currentExtension, current.nativeExtension)
-        val updated =
-                updatedExtensionCaptor.value as mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension
-        assertEquals(updatedExtension, updated.nativeExtension)
-
-        onPermissionsGrantedCaptor.value.invoke(true)
-        assertEquals(GeckoResult.allow(), result)
-    }
-
-    @Test
-    fun `web extension delegate notified of browser actions from built-in extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val browserAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onBrowserAction(extension, null, browserAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onBrowserActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(browserAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified of page actions from built-in extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val pageAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onPageAction(extension, null, pageAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onPageActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(pageAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified when built-in extension wants to open tab`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "resource://android/assets/extensions/test"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.ensureBuiltIn(extUrl, extId)).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val tabDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.TabDelegate>()
-        verify(extension).tabDelegate = tabDelegateCaptor.capture()
-
-        val createTabDetails: org.mozilla.geckoview.WebExtension.CreateTabDetails = mock()
-        tabDelegateCaptor.value.onNewTab(extension, createTabDetails)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onNewTab(extensionCaptor.capture(), any(), eq(false), eq(""))
-        assertEquals(extId, extensionCaptor.value.id)
-    }
-
-    @Test
-    fun `web extension delegate notified of browser actions from external extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val browserAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onBrowserAction(extension, null, browserAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onBrowserActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(browserAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified of page actions from external extensions`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val actionDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.ActionDelegate>()
-        verify(extension).setActionDelegate(actionDelegateCaptor.capture())
-
-        val pageAction: org.mozilla.geckoview.WebExtension.Action = mock()
-        actionDelegateCaptor.value.onPageAction(extension, null, pageAction)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        val actionCaptor = argumentCaptor<Action>()
-        verify(webExtensionsDelegate).onPageActionDefined(extensionCaptor.capture(), actionCaptor.capture())
-        assertEquals(extId, extensionCaptor.value.id)
-
-        actionCaptor.value.onClick()
-        verify(pageAction).click()
-    }
-
-    @Test
-    fun `web extension delegate notified when external extension wants to open tab`() {
-        val runtime = mock<GeckoRuntime>()
-        val extId = "test-webext"
-        val extUrl = "https://addons.mozilla.org/firefox/downloads/file/123/some_web_ext.xpi"
-
-        val extensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val result = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.install(any())).thenReturn(result)
-        engine.installWebExtension(extId, extUrl)
-        val extension = mockNativeExtension(extId, extUrl)
-        result.complete(extension)
-
-        val tabDelegateCaptor = argumentCaptor<org.mozilla.geckoview.WebExtension.TabDelegate>()
-        verify(extension).tabDelegate = tabDelegateCaptor.capture()
-
-        val createTabDetails: org.mozilla.geckoview.WebExtension.CreateTabDetails = mock()
-        tabDelegateCaptor.value.onNewTab(extension, createTabDetails)
-
-        val extensionCaptor = argumentCaptor<WebExtension>()
-        verify(webExtensionsDelegate).onNewTab(extensionCaptor.capture(), any(), eq(false), eq(""))
-        assertEquals(extId, extensionCaptor.value.id)
-    }
-
-    @Test
-    fun `web extension delegate notified of extension list change`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val debuggerDelegateCaptor = argumentCaptor<WebExtensionController.DebuggerDelegate>()
-        verify(webExtensionController).setDebuggerDelegate(debuggerDelegateCaptor.capture())
-
-        debuggerDelegateCaptor.value.onExtensionListUpdated()
-        verify(webExtensionsDelegate).onExtensionListUpdated()
-    }
-
-    @Test
-    fun `update web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val updatedExtension = MockWebExtension(bundle)
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        updateExtensionResult.complete(updatedExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-    }
-
-    @Test
-    fun `try to update a web extension without a new update available`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, _ -> onErrorCalled = true }
-        )
-        updateExtensionResult.complete(null)
-
-        assertFalse(onErrorCalled)
-        assertNull(result)
-    }
-
-    @Test
-    fun `update web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.updateWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { _, e -> throwable = e }
-        )
-        updateExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable!!.cause)
-        assertNull(result)
-    }
-
-    @Test
-    fun `failures when updating MUST indicate if they are recoverable`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        val performUpdate: (GeckoInstallException) -> WebExtensionException = { exception ->
-            val updateExtensionResult = GeckoResult<GeckoWebExtension>()
-            whenever(extensionController.update(any())).thenReturn(updateExtensionResult)
-            whenever(runtime.webExtensionController).thenReturn(extensionController)
-            var throwable: WebExtensionException? = null
-
-            engine.updateWebExtension(
-                extension,
-                onError = { _, e -> throwable = e as WebExtensionException
-                }
-            )
-
-            updateExtensionResult.completeExceptionally(exception)
-            throwable!!
-        }
-
-        val unrecoverableExceptions = listOf(
-            mockGeckoInstallException(ERROR_NETWORK_FAILURE),
-            mockGeckoInstallException(ERROR_INCORRECT_HASH),
-            mockGeckoInstallException(ERROR_CORRUPT_FILE),
-            mockGeckoInstallException(ERROR_FILE_ACCESS),
-            mockGeckoInstallException(ERROR_SIGNEDSTATE_REQUIRED),
-            mockGeckoInstallException(ERROR_UNEXPECTED_ADDON_TYPE),
-            mockGeckoInstallException(ERROR_INCORRECT_ID),
-            mockGeckoInstallException(ERROR_POSTPONED)
-        )
-
-        unrecoverableExceptions.forEach { exception ->
-            assertFalse(performUpdate(exception).isRecoverable)
-        }
-
-        val recoverableExceptions = listOf(mockGeckoInstallException(ERROR_USER_CANCELED))
-
-        recoverableExceptions.forEach { exception ->
-            assertTrue(performUpdate(exception).isRecoverable)
-        }
-    }
-
-    @Test
-    fun `list web extensions successfully`() {
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putBoolean("privateBrowsingAllowed", false)
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val installedExtension = MockWebExtension(bundle)
-
-        val installedExtensions = listOf<GeckoWebExtension>(installedExtension)
-        val installedExtensionResult = GeckoResult<List<GeckoWebExtension>>()
-
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(extensionController.list()).thenReturn(installedExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(testContext, runtime = runtime)
-        var extensions: List<WebExtension>? = null
-        var onErrorCalled = false
-
-        engine.listInstalledWebExtensions(
-            onSuccess = { extensions = it },
-            onError = { onErrorCalled = true }
-        )
-        installedExtensionResult.complete(installedExtensions)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(extensions)
-    }
-
-    @Test
-    fun `list web extensions failure`() {
-        val installedExtensionResult = GeckoResult<List<GeckoWebExtension>>()
-
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-        whenever(extensionController.list()).thenReturn(installedExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        var extensions: List<WebExtension>? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.listInstalledWebExtensions(
-            onSuccess = { extensions = it },
-            onError = { throwable = it }
-        )
-        installedExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(extensions)
-    }
-
-    @Test
-    fun `enable web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val enabledExtension = MockWebExtension(bundle)
-        val enableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.enable(any(), anyInt())).thenReturn(enableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.enableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { onErrorCalled = true }
-        )
-        enableExtensionResult.complete(enabledExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onEnabled(result!!)
-    }
-
-    @Test
-    fun `enable web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val enableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.enable(any(), anyInt())).thenReturn(enableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.enableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { throwable = it }
-        )
-        enableExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onEnabled(any())
-    }
-
-    @Test
-    fun `disable web extension successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val disabledExtension = MockWebExtension(bundle)
-        val disableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.disable(any(), anyInt())).thenReturn(disableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.disableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { onErrorCalled = true }
-        )
-        disableExtensionResult.complete(disabledExtension)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onDisabled(result!!)
-    }
-
-    @Test
-    fun `disable web extension failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val disableExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.disable(any(), anyInt())).thenReturn(disableExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.disableWebExtension(
-            extension,
-            onSuccess = { result = it },
-            onError = { throwable = it }
-        )
-        disableExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onEnabled(any())
-    }
-
-    @Test
-    fun `set allowedInPrivateBrowsing successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val allowedInPrivateBrowsing = MockWebExtension(bundle)
-        val allowedInPrivateBrowsingExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.setAllowedInPrivateBrowsing(any(), anyBoolean())).thenReturn(allowedInPrivateBrowsingExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        var onErrorCalled = false
-
-        engine.setAllowedInPrivateBrowsing(
-            extension,
-            true,
-            onSuccess = { ext -> result = ext },
-            onError = { onErrorCalled = true }
-        )
-        allowedInPrivateBrowsingExtensionResult.complete(allowedInPrivateBrowsing)
-
-        assertFalse(onErrorCalled)
-        assertNotNull(result)
-        verify(webExtensionsDelegate).onAllowedInPrivateBrowsingChanged(result!!)
-    }
-
-    @Test
-    fun `set allowedInPrivateBrowsing failure`() {
-        val runtime = mock<GeckoRuntime>()
-        val extensionController: WebExtensionController = mock()
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        val allowedInPrivateBrowsingExtensionResult = GeckoResult<GeckoWebExtension>()
-        whenever(extensionController.setAllowedInPrivateBrowsing(any(), anyBoolean())).thenReturn(allowedInPrivateBrowsingExtensionResult)
-        whenever(runtime.webExtensionController).thenReturn(extensionController)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        val webExtensionsDelegate: WebExtensionDelegate = mock()
-        engine.registerWebExtensionDelegate(webExtensionsDelegate)
-
-        val extension = mozilla.components.browser.engine.gecko.webextension.GeckoWebExtension(
-            mockNativeExtension(),
-            runtime
-        )
-        var result: WebExtension? = null
-        val expected = IOException()
-        var throwable: Throwable? = null
-
-        engine.setAllowedInPrivateBrowsing(
-            extension,
-            true,
-            onSuccess = { ext -> result = ext },
-            onError = { throwable = it }
-        )
-        allowedInPrivateBrowsingExtensionResult.completeExceptionally(expected)
-
-        assertSame(expected, throwable)
-        assertNull(result)
-        verify(webExtensionsDelegate, never()).onAllowedInPrivateBrowsingChanged(any())
-    }
-
-    @Test(expected = RuntimeException::class)
-    fun `WHEN GeckoRuntime is shutting down THEN GeckoEngine throws runtime exception`() {
-        val runtime: GeckoRuntime = mock()
-
-        GeckoEngine(context, runtime = runtime)
-
-        val captor = argumentCaptor<GeckoRuntime.Delegate>()
-        verify(runtime).delegate = captor.capture()
-
-        assertNotNull(captor.value)
-
-        captor.value.onShutdown()
-    }
-
-    @Test
-    fun `clear browsing data for all hosts`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var onSuccessCalled = false
-
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearData(eq(Engine.BrowsingData.all().types.toLong()))).thenReturn(result)
-        result.complete(null)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), onSuccess = { onSuccessCalled = true })
-        assertTrue(onSuccessCalled)
-    }
-
-    @Test
-    fun `error handler invoked when clearing browsing data for all hosts fails`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var throwable: Throwable? = null
-        var onErrorCalled = false
-
-        val exception = IOException()
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearData(eq(Engine.BrowsingData.all().types.toLong()))).thenReturn(result)
-        result.completeExceptionally(exception)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), onError = {
-            onErrorCalled = true
-            throwable = it
-        })
-        assertTrue(onErrorCalled)
-        assertSame(exception, throwable)
-    }
-
-    @Test
-    fun `clear browsing data for specified host`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var onSuccessCalled = false
-
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearDataFromHost(
-                eq("mozilla.org"),
-                eq(Engine.BrowsingData.all().types.toLong()))
-        ).thenReturn(result)
-        result.complete(null)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), host = "mozilla.org", onSuccess = { onSuccessCalled = true })
-        assertTrue(onSuccessCalled)
-    }
-
-    @Test
-    fun `error handler invoked when clearing browsing data for specified hosts fails`() {
-        val runtime: GeckoRuntime = mock()
-        val storageController: StorageController = mock()
-
-        var throwable: Throwable? = null
-        var onErrorCalled = false
-
-        val exception = IOException()
-        val result = GeckoResult<Void>()
-        whenever(runtime.storageController).thenReturn(storageController)
-        whenever(storageController.clearDataFromHost(
-                eq("mozilla.org"),
-                eq(Engine.BrowsingData.all().types.toLong()))
-        ).thenReturn(result)
-        result.completeExceptionally(exception)
-
-        val engine = GeckoEngine(context, runtime = runtime)
-        engine.clearData(data = Engine.BrowsingData.all(), host = "mozilla.org", onError = {
-            onErrorCalled = true
-            throwable = it
-        })
-        assertTrue(onErrorCalled)
-        assertSame(exception, throwable)
-    }
-
-    @Test
-    fun `test parsing engine version`() {
-        val runtime: GeckoRuntime = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val version = engine.version
-
-        println(version)
-
-        assertTrue(version.major >= 69)
-        assertTrue(version.isAtLeast(69, 0, 0))
-    }
-
-    @Test
-    fun `after init is called the trackingProtectionExceptionStore must be restored`() {
-        val mockStore: TrackingProtectionExceptionStorage = mock()
-        val runtime: GeckoRuntime = mock()
-        GeckoEngine(context, runtime = runtime, trackingProtectionExceptionStore = mockStore)
-
-        verify(mockStore).restore()
-    }
-
-    @Test
-    fun `fetch trackers logged successfully`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        var onSuccessCalled = false
-        var onErrorCalled = false
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(mockGeckoContentBlockingSetting.enhancedTrackingProtectionLevel).thenReturn(
-            ContentBlocking.EtpLevel.STRICT
-        )
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-                onSuccessCalled = true
-            },
-            onError = { onErrorCalled = true }
-        )
-
-        logEntriesResult.complete(createDummyLogEntryList())
-
-        val trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.FINGERPRINTING))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.CRYPTOMINING))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.FINGERPRINTING))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.CRYPTOMINING))
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        assertTrue(onSuccessCalled)
-        assertFalse(onErrorCalled)
-
-        logEntriesResult = GeckoResult()
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-        logEntriesResult.completeExceptionally(Exception())
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-                onSuccessCalled = true
-            },
-            onError = { onErrorCalled = true }
-        )
-
-        assertTrue(onErrorCalled)
-    }
-
-    @Test
-    fun `shimmed content MUST be categorized as blocked`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = spy(GeckoEngine(context, runtime = runtime))
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        val logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        val engineSetting = DefaultSettings()
-        engineSetting.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        whenever(engine.settings).thenReturn(engineSetting)
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-
-        logEntriesResult.complete(createShimmedEntryList())
-
-        val trackerLog = trackersLog!!.first()
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-        assertTrue(trackerLog.loadedCategories.isEmpty())
-    }
-
-    @Test
-    fun `fetch site with social trackers`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.recommended()
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-        logEntriesResult.complete(createSocialTrackersLogEntryList())
-
-        var trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        var trackerLog2 = trackersLog!![1]
-        assertFalse(trackerLog2.cookiesHasBeenBlocked)
-        assertEquals("www.tracker2.com", trackerLog2.url)
-        assertTrue(trackerLog2.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.strict()
-
-        logEntriesResult = GeckoResult()
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(mockSession, onSuccess = { trackersLog = it })
-        logEntriesResult.complete(createSocialTrackersLogEntryList())
-
-        trackerLog = trackersLog!!.first()
-        assertTrue(trackerLog.cookiesHasBeenBlocked)
-        assertEquals("www.tracker.com", trackerLog.url)
-        assertTrue(trackerLog.blockedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-
-        trackerLog2 = trackersLog!![1]
-        assertFalse(trackerLog2.cookiesHasBeenBlocked)
-        assertEquals("www.tracker2.com", trackerLog2.url)
-        assertTrue(trackerLog2.loadedCategories.contains(TrackingCategory.MOZILLA_SOCIAL))
-    }
-
-    @Test
-    fun `fetch trackers logged of the level 2 list`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-        val mockSession = mock<GeckoEngineSession>()
-        val mockGeckoSetting = mock<GeckoRuntimeSettings>()
-        val mockGeckoContentBlockingSetting = mock<ContentBlocking.Settings>()
-        var trackersLog: List<TrackerLog>? = null
-
-        val mockContentBlockingController = mock<ContentBlockingController>()
-        var logEntriesResult = GeckoResult<List<ContentBlockingController.LogEntry>>()
-
-        whenever(runtime.settings).thenReturn(mockGeckoSetting)
-        whenever(mockGeckoSetting.contentBlocking).thenReturn(mockGeckoContentBlockingSetting)
-        whenever(mockGeckoContentBlockingSetting.enhancedTrackingProtectionLevel).thenReturn(
-            ContentBlocking.EtpLevel.STRICT
-        )
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.settings.trackingProtectionPolicy = TrackingProtectionPolicy.select(
-            arrayOf(
-                TrackingCategory.STRICT,
-                TrackingCategory.CONTENT
-            )
-        )
-
-        logEntriesResult = GeckoResult()
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlockingController)
-        whenever(mockContentBlockingController.getLog(any())).thenReturn(logEntriesResult)
-
-        engine.getTrackersLog(
-            mockSession,
-            onSuccess = {
-                trackersLog = it
-            },
-            onError = { }
-        )
-        logEntriesResult.complete(createDummyLogEntryList())
-
-        val trackerLog = trackersLog!![1]
-        assertTrue(trackerLog.loadedCategories.contains(TrackingCategory.SCRIPTS_AND_SUB_RESOURCES))
-    }
-
-    @Test
-    fun `registerWebNotificationDelegate sets delegate`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerWebNotificationDelegate(mock())
-
-        verify(runtime).webNotificationDelegate = any()
-    }
-
-    @Test
-    fun `registerWebPushDelegate sets delegate and returns same handler`() {
-        val runtime = mock<GeckoRuntime>()
-        val controller: WebPushController = mock()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        whenever(runtime.webPushController).thenReturn(controller)
-
-        val handler1 = engine.registerWebPushDelegate(mock())
-        val handler2 = engine.registerWebPushDelegate(mock())
-
-        verify(controller, times(2)).setDelegate(any())
-
-        assert(handler1 == handler2)
-    }
-
-    @Test
-    fun `registerActivityDelegate sets delegate`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerActivityDelegate(mock())
-
-        verify(runtime).activityDelegate = any()
-    }
-
-    @Test
-    fun `unregisterActivityDelegate sets delegate to null`() {
-        val runtime = mock<GeckoRuntime>()
-        val engine = GeckoEngine(context, runtime = runtime)
-
-        engine.registerActivityDelegate(mock())
-
-        verify(runtime).activityDelegate = any()
-
-        engine.unregisterActivityDelegate()
-
-        verify(runtime).activityDelegate = null
-    }
-
-    private fun createSocialTrackersLogEntryList(): List<ContentBlockingController.LogEntry> {
-        val blockedLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(blockedLogEntry, "origin", "www.tracker.com")
-        val blockedCookieSocialTracker = createBlockingData(Event.COOKIES_BLOCKED_SOCIALTRACKER)
-        val blockedSocialContent = createBlockingData(Event.BLOCKED_SOCIALTRACKING_CONTENT)
-
-        ReflectionUtils.setField(blockedLogEntry, "blockingData", listOf(blockedSocialContent, blockedCookieSocialTracker))
-
-        val loadedLogEntry = object : ContentBlockingController.LogEntry() {}
-        ReflectionUtils.setField(loadedLogEntry, "origin", "www.tracker2.com")
-
-        val loadedCookieSocialTracker = createBlockingData(Event.COOKIES_LOADED_SOCIALTRACKER)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        ReflectionUtils.setField(loadedLogEntry, "blockingData", listOf(loadedCookieSocialTracker, loadedSocialContent))
-
-        return listOf(blockedLogEntry, loadedLogEntry)
-    }
-
-    private fun createDummyLogEntryList(): List<ContentBlockingController.LogEntry> {
-        val addLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(addLogEntry, "origin", "www.tracker.com")
-        val blockedCookiePermission = createBlockingData(Event.COOKIES_BLOCKED_BY_PERMISSION)
-        val loadedCookieSocialTracker = createBlockingData(Event.COOKIES_LOADED_SOCIALTRACKER)
-        val blockedCookieSocialTracker = createBlockingData(Event.COOKIES_BLOCKED_SOCIALTRACKER)
-
-        val blockedTrackingContent = createBlockingData(Event.BLOCKED_TRACKING_CONTENT)
-        val blockedFingerprintingContent = createBlockingData(Event.BLOCKED_FINGERPRINTING_CONTENT)
-        val blockedCyptominingContent = createBlockingData(Event.BLOCKED_CRYPTOMINING_CONTENT)
-        val blockedSocialContent = createBlockingData(Event.BLOCKED_SOCIALTRACKING_CONTENT)
-
-        val loadedTrackingLevel1Content = createBlockingData(Event.LOADED_LEVEL_1_TRACKING_CONTENT)
-        val loadedTrackingLevel2Content = createBlockingData(Event.LOADED_LEVEL_2_TRACKING_CONTENT)
-        val loadedFingerprintingContent = createBlockingData(Event.LOADED_FINGERPRINTING_CONTENT)
-        val loadedCyptominingContent = createBlockingData(Event.LOADED_CRYPTOMINING_CONTENT)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        val contentBlockingList = listOf(
-            blockedTrackingContent,
-            loadedTrackingLevel1Content,
-            loadedTrackingLevel2Content,
-            blockedFingerprintingContent,
-            loadedFingerprintingContent,
-            blockedCyptominingContent,
-            loadedCyptominingContent,
-            blockedCookiePermission,
-            blockedSocialContent,
-            loadedSocialContent,
-            loadedCookieSocialTracker,
-            blockedCookieSocialTracker
-        )
-
-        val addLogSecondEntry = object : ContentBlockingController.LogEntry() {}
-        ReflectionUtils.setField(addLogSecondEntry, "origin", "www.tracker2.com")
-        val contentBlockingSecondEntryList = listOf(loadedTrackingLevel2Content)
-
-        ReflectionUtils.setField(addLogEntry, "blockingData", contentBlockingList)
-        ReflectionUtils.setField(addLogSecondEntry, "blockingData", contentBlockingSecondEntryList)
-
-        return listOf(addLogEntry, addLogSecondEntry)
-    }
-
-    private fun createShimmedEntryList(): List<ContentBlockingController.LogEntry> {
-        val addLogEntry = object : ContentBlockingController.LogEntry() {}
-
-        ReflectionUtils.setField(addLogEntry, "origin", "www.tracker.com")
-        val shimmedContent = createBlockingData(Event.REPLACED_TRACKING_CONTENT, 2)
-        val loadedTrackingLevel1Content = createBlockingData(Event.LOADED_LEVEL_1_TRACKING_CONTENT)
-        val loadedSocialContent = createBlockingData(Event.LOADED_SOCIALTRACKING_CONTENT)
-
-        val contentBlockingList = listOf(
-            loadedTrackingLevel1Content,
-            loadedSocialContent,
-            shimmedContent
-        )
-
-        ReflectionUtils.setField(addLogEntry, "blockingData", contentBlockingList)
-
-        return listOf(addLogEntry)
-    }
-
-    private fun createBlockingData(category: Int, count: Int = 0): ContentBlockingController.LogEntry.BlockingData {
-        val blockingData = object : ContentBlockingController.LogEntry.BlockingData() {}
-        ReflectionUtils.setField(blockingData, "category", category)
-        ReflectionUtils.setField(blockingData, "count", count)
-        return blockingData
-    }
-
-    private fun mockNativeExtension(useBundle: GeckoBundle? = null): GeckoWebExtension {
-        val bundle = useBundle ?: GeckoBundle().apply {
-            putString("webExtensionId", "id")
-            putString("locationURI", "uri")
-        }
-        return spy(MockWebExtension(bundle))
-    }
-
-    private fun mockNativeExtension(id: String, location: String): GeckoWebExtension {
-        val bundle = GeckoBundle().apply {
-            putString("webExtensionId", id)
-            putString("locationURI", location)
-        }
-        return spy(MockWebExtension(bundle))
-    }
-
-    private fun mockGeckoInstallException(errorCode: Int): GeckoInstallException {
-        val exception = object : GeckoInstallException() {}
-        ReflectionUtils.setField(exception, "code", errorCode)
-        return exception
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
deleted file mode 100644
index 6d99f123e351..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
+++ /dev/null
@@ -1,288 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.graphics.Bitmap
-import android.graphics.Color
-import android.view.View
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineView.Companion.DARK_COVER
-import mozilla.components.browser.engine.gecko.selection.GeckoSelectionActionDelegate
-import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.never
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.MockSelection
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class GeckoEngineViewTest {
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Test
-    fun render() {
-        val engineView = GeckoEngineView(context)
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-        verify(geckoView, times(1)).setSession(geckoSession)
-
-        whenever(geckoView.session).thenReturn(geckoSession)
-        engineView.render(engineSession)
-        verify(geckoView, times(1)).setSession(geckoSession)
-    }
-
-    @Test
-    fun captureThumbnail() {
-        val engineView = GeckoEngineView(context)
-        val mockGeckoView = mock<NestedGeckoView>()
-        var thumbnail: Bitmap? = null
-
-        var geckoResult = GeckoResult<Bitmap>()
-        whenever(mockGeckoView.capturePixels()).thenReturn(geckoResult)
-        engineView.geckoView = mockGeckoView
-
-        // Test GeckoResult resolves successfuly
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        verify(mockGeckoView).capturePixels()
-        geckoResult.complete(mock())
-        assertNotNull(thumbnail)
-
-        geckoResult = GeckoResult()
-        whenever(mockGeckoView.capturePixels()).thenReturn(geckoResult)
-
-        // Test GeckoResult resolves in error
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        geckoResult.completeExceptionally(mock())
-        assertNull(thumbnail)
-
-        // Test GeckoView throwing an exception
-        whenever(mockGeckoView.capturePixels()).thenThrow(IllegalStateException("Compositor not ready"))
-
-        thumbnail = mock()
-        engineView.captureThumbnail {
-            thumbnail = it
-        }
-        assertNull(thumbnail)
-    }
-
-    @Test
-    fun `clearSelection is forwarded to BasicSelectionAction instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-        engineView.currentSelection = mock()
-
-        engineView.clearSelection()
-
-        verify(engineView.currentSelection)?.clearSelection()
-    }
-
-    @Test
-    fun `setColorScheme uses preferred color scheme to set correct cover color`() {
-        val engineView = GeckoEngineView(context)
-
-        engineView.geckoView = mock()
-
-        var preferredColorScheme: PreferredColorScheme = PreferredColorScheme.Light
-
-        engineView.setColorScheme(preferredColorScheme)
-
-        verify(engineView.geckoView)?.coverUntilFirstPaint(Color.WHITE)
-
-        preferredColorScheme = PreferredColorScheme.Dark
-        engineView.setColorScheme(preferredColorScheme)
-        verify(engineView.geckoView)?.coverUntilFirstPaint(DARK_COVER)
-    }
-
-    @Test
-    fun `setVerticalClipping is forwarded to GeckoView instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.setVerticalClipping(-42)
-
-        verify(engineView.geckoView).setVerticalClipping(-42)
-    }
-
-    @Test
-    fun `setDynamicToolbarMaxHeight is forwarded to GeckoView instance`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.setDynamicToolbarMaxHeight(42)
-
-        verify(engineView.geckoView).setDynamicToolbarMaxHeight(42)
-    }
-
-    @Test
-    fun `release method releases session from GeckoView`() {
-        val engineView = GeckoEngineView(context)
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        verify(geckoView, never()).releaseSession()
-
-        engineView.release()
-
-        verify(geckoView).releaseSession()
-    }
-
-    @Test
-    fun `after rendering currentSelection should be a GeckoSelectionActionDelegate`() {
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = mock()
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        assertTrue(engineView.currentSelection is GeckoSelectionActionDelegate)
-    }
-
-    @Test
-    fun `will attach and detach selection action delegate when rendering and releasing`() {
-        val delegate: SelectionActionDelegate = mock()
-
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = delegate
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        val captor = argumentCaptor<GeckoSession.SelectionActionDelegate>()
-        verify(geckoSession).selectionActionDelegate = captor.capture()
-
-        assertTrue(captor.value is GeckoSelectionActionDelegate)
-        val capturedDelegate = captor.value as GeckoSelectionActionDelegate
-
-        assertEquals(delegate, capturedDelegate.customDelegate)
-
-        verify(geckoSession, never()).selectionActionDelegate = null
-
-        engineView.release()
-
-        verify(geckoSession).selectionActionDelegate = null
-    }
-
-    @Test
-    fun `will attach and detach selection action delegate when rendering new session`() {
-        val delegate: SelectionActionDelegate = mock()
-
-        val engineView = GeckoEngineView(context).apply {
-            selectionActionDelegate = delegate
-        }
-        val engineSession = mock<GeckoEngineSession>()
-        val geckoSession = mock<GeckoSession>()
-        val geckoView = mock<NestedGeckoView>()
-
-        whenever(engineSession.geckoSession).thenReturn(geckoSession)
-        engineView.geckoView = geckoView
-
-        engineView.render(engineSession)
-
-        val captor = argumentCaptor<GeckoSession.SelectionActionDelegate>()
-        verify(geckoSession).selectionActionDelegate = captor.capture()
-
-        assertTrue(captor.value is GeckoSelectionActionDelegate)
-        val capturedDelegate = captor.value as GeckoSelectionActionDelegate
-
-        assertEquals(delegate, capturedDelegate.customDelegate)
-
-        verify(geckoSession, never()).selectionActionDelegate = null
-
-        whenever(geckoView.session).thenReturn(geckoSession)
-
-        engineView.render(mock<GeckoEngineSession>().apply {
-            whenever(this.geckoSession).thenReturn(mock())
-        })
-
-        verify(geckoSession).selectionActionDelegate = null
-    }
-
-    @Test
-    fun `setVisibility is propagated to gecko view`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        engineView.visibility = View.GONE
-        verify(engineView.geckoView)?.visibility = View.GONE
-    }
-
-    @Test
-    fun `canClearSelection should return false for null selection, null and empty selection text`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-        engineView.currentSelection = mock()
-
-        // null selection returns false
-        whenever(engineView.currentSelection?.selection).thenReturn(null)
-        assertFalse(engineView.canClearSelection())
-
-        // selection with null text returns false
-        val selectionWthNullText: GeckoSession.SelectionActionDelegate.Selection = mock()
-        whenever(engineView.currentSelection?.selection).thenReturn(selectionWthNullText)
-        assertFalse(engineView.canClearSelection())
-
-        // selection with empty text returns false
-        val bundle = GeckoBundle()
-        bundle.putString("selection", "")
-        val selectionWthEmptyText: GeckoSession.SelectionActionDelegate.Selection = MockSelection(bundle)
-        whenever(engineView.currentSelection?.selection).thenReturn(selectionWthEmptyText)
-        assertFalse(engineView.canClearSelection())
-    }
-
-    @Test
-    fun `GIVEN a GeckoView WHEN EngineView returns the InputResultDetail THEN the value from the GeckoView is used`() {
-        val engineView = GeckoEngineView(context)
-        val geckoview = engineView.geckoView
-
-        assertSame(geckoview.inputResultDetail, engineView.getInputResultDetail())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt
deleted file mode 100644
index 9f4822f7a549..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/GeckoResultTest.kt
+++ /dev/null
@@ -1,80 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runBlockingTest
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mozilla.geckoview.GeckoResult
-
-@ExperimentalCoroutinesApi
-@RunWith(AndroidJUnit4::class)
-class GeckoResultTest {
-
-    @Test
-    fun awaitWithResult() = runBlockingTest {
-        val result = GeckoResult.fromValue(42).await()
-        assertEquals(42, result)
-    }
-
-    @Test(expected = IllegalStateException::class)
-    fun awaitWithException() = runBlockingTest {
-        GeckoResult.fromException<Unit>(IllegalStateException()).await()
-    }
-
-    @Test
-    fun fromResult() = runBlockingTest {
-        val result = launchGeckoResult { 42 }
-
-        result.then {
-            assertEquals(42, it)
-            GeckoResult.fromValue(null)
-        }.await()
-    }
-
-    @Test
-    fun fromException() = runBlockingTest {
-        val result = launchGeckoResult { throw IllegalStateException() }
-
-        result.then({
-            assertTrue("Invalid branch", false)
-            GeckoResult.fromValue(null)
-        }, {
-            assertTrue(it is IllegalStateException)
-            GeckoResult.fromValue(null)
-        }).await()
-    }
-
-    @Test
-    fun asCancellableOperation() = runBlockingTest {
-        val geckoResult: GeckoResult<Int> = mock()
-        val op = geckoResult.asCancellableOperation()
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(false))
-        assertFalse(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(null))
-        assertFalse(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromValue(true))
-        assertTrue(op.cancel().await())
-
-        whenever(geckoResult.cancel()).thenReturn(GeckoResult.fromException(IllegalStateException()))
-        try {
-            op.cancel().await()
-            fail("Expected IllegalStateException")
-        } catch (e: IllegalStateException) {
-            // expected
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
deleted file mode 100644
index b5d95681bc17..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
+++ /dev/null
@@ -1,151 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import android.view.MotionEvent
-import android.view.MotionEvent.ACTION_CANCEL
-import android.view.MotionEvent.ACTION_DOWN
-import android.view.MotionEvent.ACTION_MOVE
-import android.view.MotionEvent.ACTION_UP
-import androidx.core.view.NestedScrollingChildHelper
-import androidx.core.view.ViewCompat.SCROLL_AXIS_VERTICAL
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.mockMotionEvent
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.anyInt
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_HANDLED
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class NestedGeckoViewTest {
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Test
-    fun `NestedGeckoView must delegate NestedScrollingChild implementation to childHelper`() {
-        val nestedWebView = NestedGeckoView(context)
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-
-        doReturn(true).`when`(mockChildHelper).isNestedScrollingEnabled
-        doReturn(true).`when`(mockChildHelper).hasNestedScrollingParent()
-
-        nestedWebView.isNestedScrollingEnabled = true
-        verify(mockChildHelper).isNestedScrollingEnabled = true
-
-        assertTrue(nestedWebView.isNestedScrollingEnabled)
-        verify(mockChildHelper).isNestedScrollingEnabled
-
-        nestedWebView.startNestedScroll(1)
-        verify(mockChildHelper).startNestedScroll(1)
-
-        nestedWebView.stopNestedScroll()
-        verify(mockChildHelper).stopNestedScroll()
-
-        assertTrue(nestedWebView.hasNestedScrollingParent())
-        verify(mockChildHelper).hasNestedScrollingParent()
-
-        nestedWebView.dispatchNestedScroll(0, 0, 0, 0, null)
-        verify(mockChildHelper).dispatchNestedScroll(0, 0, 0, 0, null)
-
-        nestedWebView.dispatchNestedPreScroll(0, 0, null, null)
-        verify(mockChildHelper).dispatchNestedPreScroll(0, 0, null, null)
-
-        nestedWebView.dispatchNestedFling(0f, 0f, true)
-        verify(mockChildHelper).dispatchNestedFling(0f, 0f, true)
-
-        nestedWebView.dispatchNestedPreFling(0f, 0f)
-        verify(mockChildHelper).dispatchNestedPreFling(0f, 0f)
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_DOWN`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        val downEvent = mockMotionEvent(ACTION_DOWN)
-        val eventCaptor = argumentCaptor<MotionEvent>()
-        nestedWebView.childHelper = mockChildHelper
-
-        nestedWebView.onTouchEvent(downEvent)
-
-        // We pass a deep copy to `updateInputResult`.
-        // Can't easily check for equality, `eventTime` should be good enough.
-        verify(nestedWebView).updateInputResult(eventCaptor.capture())
-        assertEquals(downEvent.eventTime, eventCaptor.value.eventTime)
-        verify(mockChildHelper).startNestedScroll(SCROLL_AXIS_VERTICAL)
-        verify(nestedWebView, times(0)).callSuperOnTouchEvent(any())
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_MOVE`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
-
-        doReturn(true).`when`(mockChildHelper).dispatchNestedPreScroll(
-            anyInt(), anyInt(), any(),
-            any()
-        )
-
-        nestedWebView.scrollOffset[0] = 1
-        nestedWebView.scrollOffset[1] = 2
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_MOVE, y = 10f))
-        assertEquals(nestedWebView.nestedOffsetY, 2)
-        assertEquals(nestedWebView.lastY, 8)
-
-        doReturn(true).`when`(mockChildHelper).dispatchNestedScroll(
-            anyInt(), anyInt(), anyInt(), anyInt(), any()
-        )
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_MOVE, y = 10f))
-        assertEquals(nestedWebView.nestedOffsetY, 6)
-        assertEquals(nestedWebView.lastY, 6)
-
-        // onTouchEventForResult should be called only for ACTION_DOWN
-        verify(nestedWebView, times(0)).updateInputResult(any())
-    }
-
-    @Test
-    fun `verify onTouchEvent when ACTION_UP or ACTION_CANCEL`() {
-        val nestedWebView = spy(NestedGeckoView(context))
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        val mockChildHelper: NestedScrollingChildHelper = mock()
-        nestedWebView.childHelper = mockChildHelper
-        doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
-
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_UP))
-        verify(mockChildHelper).stopNestedScroll()
-        // ACTION_UP should call "inputResultDetail.reset()". Test that call's effect.
-        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
-        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
-
-        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
-        nestedWebView.onTouchEvent(mockMotionEvent(ACTION_CANCEL))
-        verify(mockChildHelper, times(2)).stopNestedScroll()
-        // ACTION_CANCEL should call "inputResultDetail.reset()". Test that call's effect.
-        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
-        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
-
-        // onTouchEventForResult should be called only for ACTION_DOWN
-        verify(nestedWebView, times(0)).updateInputResult(any())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt
deleted file mode 100644
index 30b3ea651345..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/TrackingProtectionExceptionFileStorageTest.kt
+++ /dev/null
@@ -1,292 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko
-
-import android.app.Activity
-import android.content.Context
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import mozilla.components.browser.engine.gecko.content.blocking.GeckoTrackingProtectionException
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.content.blocking.TrackingProtectionException
-import mozilla.components.support.ktx.util.readAndDeserialize
-import mozilla.components.support.test.any
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.ContentBlockingController
-import org.mozilla.geckoview.ContentBlockingController.ContentBlockingException
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.robolectric.Robolectric.buildActivity
-
-@RunWith(AndroidJUnit4::class)
-class TrackingProtectionExceptionFileStorageTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    private val context: Context
-        get() = buildActivity(Activity::class.java).get()
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `restoreAsync exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        storage.restore()
-
-        verify(mockContentBlocking).restoreExceptionList(any<List<ContentBlockingException>>())
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `add exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        var excludedOnTrackingProtection = false
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        session.register(object : EngineSession.Observer {
-            override fun onExcludedOnTrackingProtectionChange(excluded: Boolean) {
-                excludedOnTrackingProtection = excluded
-            }
-        })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertTrue(excludedOnTrackingProtection)
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `remove all exceptions`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        val geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        val engineSession: EngineSession = mock()
-        val activeSessions: List<EngineSession> = listOf(engineSession)
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-
-        // Removing exceptions
-        storage.removeAll(activeSessions)
-        verify(mockContentBlocking).clearExceptionList()
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        verify(engineSession).notifyObservers(any())
-    }
-
-    @Test
-    fun `remove exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-        var excludedOnTrackingProtection = false
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        session.register(object : EngineSession.Observer {
-            override fun onExcludedOnTrackingProtectionChange(excluded: Boolean) {
-                excludedOnTrackingProtection = excluded
-            }
-        })
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).addException(mockGeckoSession)
-        verify(mockContentBlocking).saveExceptionList()
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-        assertTrue(excludedOnTrackingProtection)
-
-        // Removing exception
-        geckoResult = GeckoResult<List<ContentBlockingException>>()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-        storage.remove(session)
-        verify(mockContentBlocking).removeException(mockGeckoSession)
-        geckoResult.complete(null)
-        assertNull(storage.getFile(context).readAndDeserialize { })
-        assertFalse(excludedOnTrackingProtection)
-    }
-
-    @Test
-    fun `remove a TrackingProtectionException`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = spy(GeckoEngineSession(runtime))
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.cnn.com\\/\"}")))
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        // Adding exception
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-        storage.scope = CoroutineScope(Dispatchers.Main)
-
-        storage.add(session)
-        geckoResult.complete(mockExceptionList)
-        assertNotNull(storage.getFile(context).readAndDeserialize { })
-
-        // Removing exception
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-        storage.remove(
-            GeckoTrackingProtectionException(
-                "https://www.cnn.com/",
-                "eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ"
-            )
-        )
-        verify(mockContentBlocking).removeException(any<ContentBlockingException>())
-        geckoResult.complete(null)
-        assertNull(storage.getFile(context).readAndDeserialize { })
-    }
-
-    @Test
-    fun `contains exception`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        var geckoResult = GeckoResult<Boolean>()
-        val mockGeckoSession = mock<GeckoSession>()
-        var containsException = false
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.checkException(mockGeckoSession)).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-
-        storage.contains(session) { contains ->
-            containsException = contains
-        }
-        geckoResult.complete(true)
-
-        verify(mockContentBlocking).checkException(mockGeckoSession)
-        assertTrue(containsException)
-
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.checkException(mockGeckoSession)).thenReturn(geckoResult)
-
-        storage.contains(session) { contains ->
-            containsException = contains
-        }
-        geckoResult.complete(null)
-        assertFalse(containsException)
-    }
-
-    @Test
-    fun `getAll exceptions`() {
-        val mockContentBlocking = mock<ContentBlockingController>()
-        val session = mock<GeckoEngineSession>()
-        var geckoResult = GeckoResult<List<ContentBlockingException>>()
-        val mockGeckoSession = mock<GeckoSession>()
-        val mockExceptionList =
-            listOf(ContentBlockingException.fromJson(JSONObject("{\"principal\":\"eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==\",\"uri\":\"https:\\/\\/www.mozilla.com\\/\"}")))
-        var exceptionList: List<TrackingProtectionException>? = null
-
-        whenever(session.geckoSession).thenReturn(mockGeckoSession)
-        whenever(runtime.contentBlockingController).thenReturn(mockContentBlocking)
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        val storage = TrackingProtectionExceptionFileStorage(testContext, runtime)
-
-        storage.fetchAll { exceptions ->
-            exceptionList = exceptions
-        }
-        geckoResult.complete(mockExceptionList)
-
-        verify(mockContentBlocking).saveExceptionList()
-        assertTrue(exceptionList!!.isNotEmpty())
-        assertEquals("https://www.mozilla.com/", exceptionList!!.first().url)
-        assertEquals("eyIxIjp7IjAiOiJodHRwczovL3d3dy5jbm4uY29tLyJ9fQ==", (exceptionList!!.first() as GeckoTrackingProtectionException).principal)
-
-        geckoResult = GeckoResult()
-        whenever(runtime.contentBlockingController.saveExceptionList()).thenReturn(geckoResult)
-
-        storage.fetchAll { exceptions ->
-            exceptionList = exceptions
-        }
-
-        geckoResult.complete(null)
-        assertTrue(exceptionList!!.isEmpty())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt
deleted file mode 100644
index 461b0f4df5aa..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/activity/GeckoActivityDelegateTest.kt
+++ /dev/null
@@ -1,75 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.activity
-
-import android.app.PendingIntent
-import android.content.Intent
-import android.content.IntentSender
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.activity.ActivityDelegate
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNotNull
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.`when`
-import org.mozilla.geckoview.GeckoResult
-import java.lang.ref.WeakReference
-
-@RunWith(AndroidJUnit4::class)
-class GeckoActivityDelegateTest {
-    lateinit var pendingIntent: PendingIntent
-
-    @Before
-    fun setup() {
-        pendingIntent = mock()
-        `when`(pendingIntent.intentSender).thenReturn(mock())
-    }
-
-    @Test
-    fun `onStartActivityForResult is completed successfully`() {
-        val delegate: ActivityDelegate = object : ActivityDelegate {
-            override fun startIntentSenderForResult(intent: IntentSender, onResult: (Intent?) -> Unit) {
-                onResult(mock())
-            }
-        }
-
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(delegate))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.accept {
-            assertNotNull(it)
-        }
-    }
-
-    @Test
-    fun `onStartActivityForResult completes exceptionally on null response`() {
-        val delegate: ActivityDelegate = object : ActivityDelegate {
-            override fun startIntentSenderForResult(intent: IntentSender, onResult: (Intent?) -> Unit) {
-                onResult(null)
-            }
-        }
-
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(delegate))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.exceptionally { throwable ->
-            assertEquals("Activity for result failed.", throwable.localizedMessage)
-            GeckoResult.fromValue(null)
-        }
-    }
-
-    @Test
-    fun `onStartActivityForResult completes exceptionally when there is no object attached to the weak reference`() {
-        val geckoActivityDelegate = GeckoActivityDelegate(WeakReference(null))
-        val result = geckoActivityDelegate.onStartActivityForResult(pendingIntent)
-
-        result.exceptionally { throwable ->
-            assertEquals("Activity for result failed; no delegate attached.", throwable.localizedMessage)
-            GeckoResult.fromValue(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt
deleted file mode 100644
index a3f8b58a1b50..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/ext/TrackingProtectionPolicyKtTest.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- *  License, v. 2.0. If a copy of the MPL was not distributed with this
- *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-package mozilla.components.browser.engine.gecko.ext
-
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.EngineSession.TrackingProtectionPolicy
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.mozilla.geckoview.ContentBlocking.EtpLevel
-
-class TrackingProtectionPolicyKtTest {
-
-    private val defaultSafeBrowsing = arrayOf(EngineSession.SafeBrowsingPolicy.RECOMMENDED)
-
-    @Test
-    fun `transform the policy to a GeckoView ContentBlockingSetting`() {
-        val policy = TrackingProtectionPolicy.recommended()
-        val setting = policy.toContentBlockingSetting()
-
-        assertEquals(policy.getEtpLevel(), setting.enhancedTrackingProtectionLevel)
-        assertEquals(policy.getAntiTrackingPolicy(), setting.antiTrackingCategories)
-        assertEquals(policy.cookiePolicy.id, setting.cookieBehavior)
-        assertEquals(defaultSafeBrowsing.sumBy { it.id }, setting.safeBrowsingCategories)
-        assertEquals(setting.strictSocialTrackingProtection, policy.strictSocialTrackingProtection)
-        assertEquals(setting.cookiePurging, policy.cookiePurging)
-
-        val policyWithSafeBrowsing = TrackingProtectionPolicy.recommended().toContentBlockingSetting(emptyArray())
-        assertEquals(0, policyWithSafeBrowsing.safeBrowsingCategories)
-    }
-
-    @Test
-    fun `getEtpLevel is always Strict unless None`() {
-        assertEquals(EtpLevel.STRICT, TrackingProtectionPolicy.recommended().getEtpLevel())
-        assertEquals(EtpLevel.STRICT, TrackingProtectionPolicy.strict().getEtpLevel())
-        assertEquals(EtpLevel.NONE, TrackingProtectionPolicy.none().getEtpLevel())
-    }
-
-    @Test
-    fun `getStrictSocialTrackingProtection is true if category is STRICT`() {
-        val recommendedPolicy = TrackingProtectionPolicy.recommended()
-        val strictPolicy = TrackingProtectionPolicy.strict()
-
-        assertFalse(recommendedPolicy.toContentBlockingSetting().strictSocialTrackingProtection)
-        assertTrue(strictPolicy.toContentBlockingSetting().strictSocialTrackingProtection)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt
deleted file mode 100644
index 90ca218805ad..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/fetch/GeckoViewFetchUnitTestCases.kt
+++ /dev/null
@@ -1,332 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.fetch
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.fetch.Client
-import mozilla.components.concept.fetch.Request
-import mozilla.components.concept.fetch.Response
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.tooling.fetch.tests.FetchTestCases
-import okhttp3.Headers
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.mockwebserver.RecordedRequest
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentCaptor
-import org.mockito.ArgumentMatchers.anyInt
-import org.mockito.ArgumentMatchers.anyLong
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoWebExecutor
-import org.mozilla.geckoview.WebRequest
-import org.mozilla.geckoview.WebRequestError
-import org.mozilla.geckoview.WebResponse
-import java.io.IOException
-import java.nio.charset.Charset
-import java.util.concurrent.TimeoutException
-
-/**
- * We can't run standard JVM unit tests for GWE. Therefore, we provide both
- * instrumented tests as well as these unit tests which mock both requests
- * and responses. While these tests guard our logic to map responses to our
- * concept-fetch abstractions, they are not sufficient to guard the full
- * functionality of [GeckoViewFetchClient]. That's why end-to-end tests are
- * provided in instrumented tests.
- */
-@RunWith(AndroidJUnit4::class)
-class GeckoViewFetchUnitTestCases : FetchTestCases() {
-
-    override fun createNewClient(): Client {
-        val client = GeckoViewFetchClient(testContext, mock())
-        geckoWebExecutor?.let { client.executor = it }
-        return client
-    }
-
-    override fun createWebServer(): MockWebServer {
-        return mockWebServer ?: super.createWebServer()
-    }
-
-    private var geckoWebExecutor: GeckoWebExecutor? = null
-    private var mockWebServer: MockWebServer? = null
-
-    @Before
-    fun setup() {
-        geckoWebExecutor = null
-    }
-
-    @Test
-    fun clientInstance() {
-        assertTrue(createNewClient() is GeckoViewFetchClient)
-    }
-
-    @Test
-    override fun get200WithDuplicatedCacheControlRequestHeaders() {
-        val headerMap = mapOf("Cache-Control" to "no-cache, no-store")
-        mockRequest(headerMap)
-        mockResponse(200)
-
-        super.get200WithDuplicatedCacheControlRequestHeaders()
-    }
-
-    @Test
-    override fun get200WithDuplicatedCacheControlResponseHeaders() {
-        val responseHeaderMap = mapOf(
-            "Cache-Control" to "no-cache, no-store",
-            "Content-Length" to "16"
-        )
-        mockResponse(200, responseHeaderMap)
-
-        super.get200WithDuplicatedCacheControlResponseHeaders()
-    }
-
-    @Test
-    override fun get200OverridingDefaultHeaders() {
-        val headerMap = mapOf(
-            "Accept" to "text/html",
-            "Accept-Encoding" to "deflate",
-            "User-Agent" to "SuperBrowser/1.0",
-            "Connection" to "close")
-        mockRequest(headerMap)
-        mockResponse(200)
-
-        super.get200OverridingDefaultHeaders()
-    }
-
-    @Test
-    override fun get200WithGzippedBody() {
-        val responseHeaderMap = mapOf("Content-Encoding" to "gzip")
-        mockRequest()
-        mockResponse(200, responseHeaderMap, "This is compressed")
-
-        super.get200WithGzippedBody()
-    }
-
-    @Test
-    override fun get200WithHeaders() {
-        val requestHeaders = mapOf(
-            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
-            "Accept-Encoding" to "gzip, deflate",
-            "Accept-Language" to "en-US,en;q=0.5",
-            "Connection" to "keep-alive",
-            "User-Agent" to "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0"
-        )
-        mockRequest(requestHeaders)
-        mockResponse(200)
-
-        super.get200WithHeaders()
-    }
-
-    @Test
-    override fun get200WithReadTimeout() {
-        mockRequest()
-        mockResponse(200)
-
-        val geckoResult = mock<GeckoResult<*>>()
-        whenever(geckoResult.poll(anyLong())).thenThrow(TimeoutException::class.java)
-        @Suppress("UNCHECKED_CAST")
-        whenever(geckoWebExecutor!!.fetch(any(), anyInt())).thenReturn(geckoResult as GeckoResult<WebResponse>)
-
-        super.get200WithReadTimeout()
-    }
-
-    @Test
-    override fun get200WithStringBody() {
-        mockRequest()
-        mockResponse(200, body = "Hello World")
-
-        super.get200WithStringBody()
-    }
-
-    @Test
-    override fun get302FollowRedirects() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.redirect).thenReturn(Request.Redirect.FOLLOW)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_NONE))
-    }
-
-    @Test
-    override fun get302FollowRedirectsDisabled() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.redirect).thenReturn(Request.Redirect.MANUAL)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_NO_REDIRECTS))
-    }
-
-    @Test
-    override fun get404WithBody() {
-        mockRequest()
-        mockResponse(404, body = "Error")
-        super.get404WithBody()
-    }
-
-    @Test
-    override fun post200WithBody() {
-        mockRequest(method = "POST", body = "Hello World")
-        mockResponse(200)
-        super.post200WithBody()
-    }
-
-    @Test
-    override fun put201FileUpload() {
-        mockRequest(method = "PUT", headerMap = mapOf("Content-Type" to "image/png"), body = "I am an image file!")
-        mockResponse(201, headerMap = mapOf("Location" to "/your-image.png"), body = "Thank you!")
-        super.put201FileUpload()
-    }
-
-    @Test(expected = IOException::class)
-    fun pollReturningNull() {
-        mockResponse(200)
-
-        val geckoResult = mock<GeckoResult<*>>()
-        whenever(geckoResult.poll(anyLong())).thenReturn(null)
-        @Suppress("UNCHECKED_CAST")
-        whenever(geckoWebExecutor!!.fetch(any(), anyInt())).thenReturn(geckoResult as GeckoResult<WebResponse>)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        createNewClient().fetch(request)
-    }
-
-    @Test
-    override fun get200WithCookiePolicy() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.cookiePolicy).thenReturn(Request.CookiePolicy.OMIT)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_ANONYMOUS))
-    }
-
-    @Test
-    fun performPrivateRequest() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.private).thenReturn(true)
-        createNewClient().fetch(request)
-
-        verify(geckoWebExecutor)!!.fetch(any(), eq(GeckoWebExecutor.FETCH_FLAGS_PRIVATE))
-    }
-
-    @Test
-    override fun get200WithContentTypeCharset() {
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-
-        mockResponse(200,
-                headerMap = mapOf("Content-Type" to "text/html; charset=ISO-8859-1"),
-                body = "",
-                charset = Charsets.ISO_8859_1)
-
-        val response = createNewClient().fetch(request)
-        assertEquals("", response.body.string())
-    }
-
-    @Test
-    override fun get200WithCacheControl() {
-        mockResponse(200)
-
-        val request = mock<Request>()
-        whenever(request.url).thenReturn("https://mozilla.org")
-        whenever(request.method).thenReturn(Request.Method.GET)
-        whenever(request.useCaches).thenReturn(false)
-        createNewClient().fetch(request)
-
-        val captor = ArgumentCaptor.forClass(WebRequest::class.java)
-
-        verify(geckoWebExecutor)!!.fetch(captor.capture(), eq(GeckoWebExecutor.FETCH_FLAGS_NONE))
-        assertEquals(WebRequest.CACHE_MODE_RELOAD, captor.value.cacheMode)
-    }
-
-    @Test(expected = IOException::class)
-    override fun getThrowsIOExceptionWhenHostNotReachable() {
-        val executor = mock<GeckoWebExecutor>()
-        whenever(executor.fetch(any(), anyInt())).thenAnswer { throw WebRequestError(0, 0) }
-        geckoWebExecutor = executor
-
-        createNewClient().fetch(Request(""))
-    }
-
-    @Test
-    fun toResponseMustReturn200ForBlobUrls() {
-        val builder = WebResponse.Builder("blob:https://mdn.mozillademos.org/d518464c-5075-9046-aef2-9c313214ed53").statusCode(0).build()
-        assertEquals(Response.SUCCESS, builder.toResponse().status)
-    }
-
-    @Test
-    fun toResponseMustReturn200ForDataUrls() {
-        val builder = WebResponse.Builder("data:,Hello%2C%20World!").statusCode(0).build()
-        assertEquals(Response.SUCCESS, builder.toResponse().status)
-    }
-
-    private fun mockRequest(headerMap: Map<String, String>? = null, body: String? = null, method: String = "GET") {
-        val server = mock<MockWebServer>()
-        whenever(server.url(any())).thenReturn(mock())
-        val request = mock<RecordedRequest>()
-        whenever(request.method).thenReturn(method)
-
-        headerMap?.let {
-            whenever(request.headers).thenReturn(Headers.of(headerMap))
-            whenever(request.getHeader(any())).thenAnswer { inv -> it[inv.getArgument(0)] }
-        }
-
-        body?.let {
-            val buffer = okio.Buffer()
-            buffer.write(body.toByteArray())
-            whenever(request.body).thenReturn(buffer)
-        }
-
-        whenever(server.takeRequest()).thenReturn(request)
-        mockWebServer = server
-    }
-
-    private fun mockResponse(
-        statusCode: Int,
-        headerMap: Map<String, String>? = null,
-        body: String? = null,
-        charset: Charset = Charsets.UTF_8
-    ) {
-        val executor = mock<GeckoWebExecutor>()
-        val builder = WebResponse.Builder("").statusCode(statusCode)
-        headerMap?.let {
-            headerMap.forEach { (k, v) -> builder.addHeader(k, v) }
-        }
-
-        body?.let {
-            builder.body(it.byteInputStream(charset))
-        }
-
-        val response = builder.build()
-
-        whenever(executor.fetch(any(), anyInt())).thenReturn(GeckoResult.fromValue(response))
-        geckoWebExecutor = executor
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt
deleted file mode 100644
index 5d6b14100cd1..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/integration/SettingUpdaterTest.kt
+++ /dev/null
@@ -1,72 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.integration
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-
-@RunWith(AndroidJUnit4::class)
-class SettingUpdaterTest {
-
-    @Test
-    fun `test updateValue`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertEquals("current", subject.value)
-
-        subject.updateValue()
-        assertEquals("new", subject.value)
-    }
-
-    @Test
-    fun `test enabled updates value`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertEquals("current", subject.value)
-
-        subject.enabled = true
-        assertEquals("new", subject.value)
-
-        // disabling doesn't update the value.
-        subject.nextValue = "disabled"
-        subject.enabled = false
-        assertEquals("new", subject.value)
-    }
-
-    @Test
-    fun `test registering and deregistering for updates`() {
-        val subject = DummySettingUpdater("current", "new")
-        assertFalse("Initialized not registering for updates", subject.registered)
-
-        subject.updateValue()
-        assertFalse("updateValue not registering for updates", subject.registered)
-
-        subject.enabled = true
-        assertTrue("enabled = true registering for updates", subject.registered)
-
-        subject.enabled = false
-        assertFalse("enabled = false deregistering for updates", subject.registered)
-    }
-}
-
-class DummySettingUpdater(
-    override var value: String = "",
-    var nextValue: String
-) : SettingUpdater<String>() {
-
-    var registered = false
-
-    override fun registerForUpdates() {
-        registered = true
-    }
-
-    override fun unregisterForUpdates() {
-        registered = false
-    }
-
-    override fun findValue() = nextValue
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt
deleted file mode 100644
index 433e3e3af7f7..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionControllerTest.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.mediasession
-
-import mozilla.components.support.test.mock
-import org.junit.Test
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-class GeckoMediaSessionControllerTest {
-    @Test
-    fun `GeckoMediaSessionController works correctly with GeckoView MediaSession`() {
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-        val controller = GeckoMediaSessionController(geckoViewMediaSession)
-
-        controller.pause()
-        verify(geckoViewMediaSession, times(1)).pause()
-
-        controller.stop()
-        verify(geckoViewMediaSession, times(1)).stop()
-
-        controller.play()
-        verify(geckoViewMediaSession, times(1)).play()
-
-        controller.seekTo(123.0, true)
-        verify(geckoViewMediaSession, times(1)).seekTo(123.0, true)
-
-        controller.seekForward()
-        verify(geckoViewMediaSession, times(1)).seekForward()
-
-        controller.seekBackward()
-        verify(geckoViewMediaSession, times(1)).seekBackward()
-
-        controller.nextTrack()
-        verify(geckoViewMediaSession, times(1)).nextTrack()
-
-        controller.previousTrack()
-        verify(geckoViewMediaSession, times(1)).previousTrack()
-
-        controller.skipAd()
-        verify(geckoViewMediaSession, times(1)).skipAd()
-
-        controller.muteAudio(true)
-        verify(geckoViewMediaSession, times(1)).muteAudio(true)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt
deleted file mode 100644
index 16edbd74cc3c..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/mediasession/GeckoMediaSessionDelegateTest.kt
+++ /dev/null
@@ -1,201 +0,0 @@
-package mozilla.components.browser.engine.gecko.mediasession
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.mediasession.MediaSession
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.MediaSession as GeckoViewMediaSession
-
-@RunWith(AndroidJUnit4::class)
-class GeckoMediaSessionDelegateTest {
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `media session activated is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedController: MediaSession.Controller? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaActivated(mediaSessionController: MediaSession.Controller) {
-                observedController = mediaSessionController
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onActivated(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedController)
-        observedController!!.play()
-        verify(geckoViewMediaSession).play()
-    }
-
-    @Test
-    fun `media session deactivated is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedActivated = true
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaDeactivated() {
-                observedActivated = false
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onDeactivated(mock(), geckoViewMediaSession)
-
-        assertFalse(observedActivated)
-    }
-
-    @Test
-    fun `media session metadata is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedMetadata: MediaSession.Metadata? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaMetadataChanged(
-                metadata: MediaSession.Metadata
-            ) {
-                observedMetadata = metadata
-            }
-        })
-
-        val metadata: GeckoViewMediaSession.Metadata = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onMetadata(mock(), geckoViewMediaSession, metadata)
-
-        assertNotNull(observedMetadata)
-        assertEquals(observedMetadata?.title, metadata.title)
-        assertEquals(observedMetadata?.artist, metadata.artist)
-        assertEquals(observedMetadata?.album, metadata.album)
-        assertEquals(observedMetadata?.getArtwork, metadata.artwork)
-    }
-
-    @Test
-    fun `media session feature is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedFeature: MediaSession.Feature? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaFeatureChanged(
-                features: MediaSession.Feature
-            ) {
-                observedFeature = features
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onFeatures(mock(), geckoViewMediaSession, 123)
-
-        assertNotNull(observedFeature)
-        assertEquals(observedFeature, MediaSession.Feature(123))
-    }
-
-    @Test
-    fun `media session play state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedPlaybackState: MediaSession.PlaybackState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaPlaybackStateChanged(
-                playbackState: MediaSession.PlaybackState
-            ) {
-                observedPlaybackState = playbackState
-            }
-        })
-
-        engineSession.geckoSession.mediaSessionDelegate!!.onPlay(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.PLAYING)
-
-        observedPlaybackState = null
-        engineSession.geckoSession.mediaSessionDelegate!!.onPause(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.PAUSED)
-
-        observedPlaybackState = null
-        engineSession.geckoSession.mediaSessionDelegate!!.onStop(mock(), geckoViewMediaSession)
-
-        assertNotNull(observedPlaybackState)
-        assertEquals(observedPlaybackState, MediaSession.PlaybackState.STOPPED)
-    }
-
-    @Test
-    fun `media session position state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedPositionState: MediaSession.PositionState? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaPositionStateChanged(
-                positionState: MediaSession.PositionState
-            ) {
-                observedPositionState = positionState
-            }
-        })
-
-        val positionState: GeckoViewMediaSession.PositionState = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onPositionState(mock(), geckoViewMediaSession, positionState)
-
-        assertNotNull(observedPositionState)
-        assertEquals(observedPositionState?.duration, positionState.duration)
-        assertEquals(observedPositionState?.position, positionState.position)
-        assertEquals(observedPositionState?.playbackRate, positionState.playbackRate)
-    }
-
-    @Test
-    fun `media session fullscreen state is forwarded to observer`() {
-        val engineSession = GeckoEngineSession(runtime)
-        val geckoViewMediaSession: GeckoViewMediaSession = mock()
-
-        var observedFullscreen: Boolean? = null
-        var observedElementMetadata: MediaSession.ElementMetadata? = null
-
-        engineSession.register(object : EngineSession.Observer {
-            override fun onMediaFullscreenChanged(
-                fullscreen: Boolean,
-                elementMetadata: MediaSession.ElementMetadata?
-            ) {
-                observedFullscreen = fullscreen
-                observedElementMetadata = elementMetadata
-            }
-        })
-
-        val elementMetadata: GeckoViewMediaSession.ElementMetadata = mock()
-        engineSession.geckoSession.mediaSessionDelegate!!.onFullscreen(mock(), geckoViewMediaSession, true, elementMetadata)
-
-        assertNotNull(observedFullscreen)
-        assertNotNull(observedElementMetadata)
-        assertEquals(observedFullscreen, true)
-        assertEquals(observedElementMetadata?.source, elementMetadata.source)
-        assertEquals(observedElementMetadata?.duration, elementMetadata.duration)
-        assertEquals(observedElementMetadata?.width, elementMetadata.width)
-        assertEquals(observedElementMetadata?.height, elementMetadata.height)
-        assertEquals(observedElementMetadata?.audioTrackCount, elementMetadata.audioTrackCount)
-        assertEquals(observedElementMetadata?.videoTrackCount, elementMetadata.videoTrackCount)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt
deleted file mode 100644
index bdaaf578b403..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/permission/GeckoPermissionRequestTest.kt
+++ /dev/null
@@ -1,192 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.permission
-
-import android.Manifest
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.permission.Permission
-import mozilla.components.support.test.mock
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.MediaSource
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_DESKTOP_NOTIFICATION
-import org.mozilla.geckoview.GeckoSession.PermissionDelegate.PERMISSION_GEOLOCATION
-
-@RunWith(AndroidJUnit4::class)
-class GeckoPermissionRequestTest {
-
-    @Test
-    fun `create content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        var request = GeckoPermissionRequest.Content(uri, PERMISSION_DESKTOP_NOTIFICATION, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentNotification()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentGeoLocation()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_AUDIBLE, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentAutoPlayAudible()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, GeckoSession.PermissionDelegate.PERMISSION_AUTOPLAY_INAUDIBLE, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.ContentAutoPlayInaudible()), request.permissions)
-
-        request = GeckoPermissionRequest.Content(uri, 1234, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(listOf(Permission.Generic("1234", "Gecko permission type = 1234")), request.permissions)
-    }
-
-    @Test
-    fun `grant content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        val request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        request.grant()
-        verify(callback).grant()
-    }
-
-    @Test
-    fun `reject content permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val uri = "https://mozilla.org"
-
-        val request = GeckoPermissionRequest.Content(uri, PERMISSION_GEOLOCATION, callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    @Test
-    fun `create app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-        val permissions = listOf(
-                Manifest.permission.ACCESS_COARSE_LOCATION,
-                Manifest.permission.ACCESS_FINE_LOCATION,
-                Manifest.permission.CAMERA,
-                Manifest.permission.RECORD_AUDIO,
-                "unknown app permission")
-
-        val mappedPermissions = listOf(
-                Permission.AppLocationCoarse(Manifest.permission.ACCESS_COARSE_LOCATION),
-                Permission.AppLocationFine(Manifest.permission.ACCESS_FINE_LOCATION),
-                Permission.AppCamera(Manifest.permission.CAMERA),
-                Permission.AppAudio(Manifest.permission.RECORD_AUDIO),
-                Permission.Generic("unknown app permission")
-        )
-
-        val request = GeckoPermissionRequest.App(permissions, callback)
-        assertEquals(mappedPermissions, request.permissions)
-    }
-
-    @Test
-    fun `grant app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-
-        val request = GeckoPermissionRequest.App(listOf(Manifest.permission.CAMERA), callback)
-        request.grant()
-        verify(callback).grant()
-    }
-
-    @Test
-    fun `reject app permission request`() {
-        val callback: GeckoSession.PermissionDelegate.Callback = mock()
-
-        val request = GeckoPermissionRequest.App(listOf(Manifest.permission.CAMERA), callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    @Test
-    fun `create media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val audioCapture = MockMediaSource("audioCapture", "audioCapture",
-                MediaSource.SOURCE_AUDIOCAPTURE, MediaSource.TYPE_AUDIO)
-        val audioOther = MockMediaSource("audioOther", "audioOther",
-                MediaSource.SOURCE_OTHER, MediaSource.TYPE_AUDIO)
-
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-        val videoScreen = MockMediaSource("videoScreen", "videoScreen",
-                MediaSource.SOURCE_SCREEN, MediaSource.TYPE_VIDEO)
-        val videoOther = MockMediaSource("videoOther", "videoOther",
-                MediaSource.SOURCE_OTHER, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioCapture, audioMicrophone, audioOther)
-        val videoSources = listOf(videoCamera, videoOther, videoScreen)
-
-        val mappedPermissions = listOf(
-                Permission.ContentVideoCamera("videoCamera", "videoCamera"),
-                Permission.ContentVideoScreen("videoScreen", "videoScreen"),
-                Permission.ContentVideoOther("videoOther", "videoOther"),
-                Permission.ContentAudioMicrophone("audioMicrophone", "audioMicrophone"),
-                Permission.ContentAudioCapture("audioCapture", "audioCapture"),
-                Permission.ContentAudioOther("audioOther", "audioOther")
-        )
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        assertEquals(uri, request.uri)
-        assertEquals(mappedPermissions.size, request.permissions.size)
-        assertTrue(request.permissions.containsAll(mappedPermissions))
-    }
-
-    @Test
-    fun `grant media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioMicrophone)
-        val videoSources = listOf(videoCamera)
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        request.grant(request.permissions)
-        verify(callback).grant(videoCamera, audioMicrophone)
-    }
-
-    @Test
-    fun `reject media permission request`() {
-        val callback: GeckoSession.PermissionDelegate.MediaCallback = mock()
-        val uri = "https://mozilla.org"
-
-        val audioMicrophone = MockMediaSource("audioMicrophone", "audioMicrophone",
-                MediaSource.SOURCE_MICROPHONE, MediaSource.TYPE_AUDIO)
-        val videoCamera = MockMediaSource("videoCamera", "videoCamera",
-                MediaSource.SOURCE_CAMERA, MediaSource.TYPE_VIDEO)
-
-        val audioSources = listOf(audioMicrophone)
-        val videoSources = listOf(videoCamera)
-
-        val request = GeckoPermissionRequest.Media(uri, videoSources, audioSources, callback)
-        request.reject()
-        verify(callback).reject()
-    }
-
-    class MockMediaSource(id: String, name: String, source: Int, type: Int) : MediaSource() {
-        init {
-            ReflectionUtils.setField(this, "id", id)
-            ReflectionUtils.setField(this, "name", name)
-            ReflectionUtils.setField(this, "source", source)
-            ReflectionUtils.setField(this, "type", type)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt
deleted file mode 100644
index c14c3d456f9b..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/prompt/GeckoPromptDelegateTest.kt
+++ /dev/null
@@ -1,1409 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.prompt
-
-import android.net.Uri
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.EngineSession
-import mozilla.components.concept.engine.prompt.Choice
-import mozilla.components.concept.engine.prompt.PromptRequest
-import mozilla.components.concept.engine.prompt.PromptRequest.MultipleChoice
-import mozilla.components.concept.engine.prompt.PromptRequest.SingleChoice
-import mozilla.components.concept.storage.Login
-import mozilla.components.support.ktx.kotlin.toDate
-import mozilla.components.support.test.any
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import mozilla.components.support.test.whenever
-import mozilla.components.test.ReflectionUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.never
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.Autocomplete
-import org.mozilla.geckoview.GeckoResult
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.DATETIME_LOCAL
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.MONTH
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.TIME
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.DateTimePrompt.Type.WEEK
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.ANY
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.NONE
-import org.mozilla.geckoview.GeckoSession.PromptDelegate.FilePrompt.Capture.USER
-import java.io.FileInputStream
-import java.security.InvalidParameterException
-import java.util.Calendar
-import java.util.Calendar.YEAR
-import java.util.Date
-
-typealias GeckoChoice = GeckoSession.PromptDelegate.ChoicePrompt.Choice
-typealias GECKO_AUTH_LEVEL = GeckoSession.PromptDelegate.AuthPrompt.AuthOptions.Level
-typealias GECKO_PROMPT_CHOICE_TYPE = GeckoSession.PromptDelegate.ChoicePrompt.Type
-typealias GECKO_AUTH_FLAGS = GeckoSession.PromptDelegate.AuthPrompt.AuthOptions.Flags
-typealias GECKO_PROMPT_FILE_TYPE = GeckoSession.PromptDelegate.FilePrompt.Type
-typealias AC_AUTH_METHOD = PromptRequest.Authentication.Method
-typealias AC_AUTH_LEVEL = PromptRequest.Authentication.Level
-
-@RunWith(AndroidJUnit4::class)
-class GeckoPromptDelegateTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_SINGLE must provide a SingleChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = MultipleChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val geckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.SINGLE,
-            arrayOf(geckoChoice)
-        )
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                promptRequestSingleChoice = promptRequest
-            }
-        })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is SingleChoice)
-        val request = promptRequestSingleChoice as SingleChoice
-
-        request.onConfirm(request.choices.first())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(request.choices.first())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_MULTIPLE must provide a MultipleChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = SingleChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val mockGeckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.MULTIPLE,
-            arrayOf(mockGeckoChoice)
-        )
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                promptRequestSingleChoice = promptRequest
-            }
-        })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is MultipleChoice)
-
-        (promptRequestSingleChoice as MultipleChoice).onConfirm(arrayOf())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        (promptRequestSingleChoice as MultipleChoice).onConfirm(arrayOf())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onChoicePrompt called with CHOICE_TYPE_MENU must provide a MenuChoice PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var promptRequestSingleChoice: PromptRequest = PromptRequest.MenuChoice(arrayOf()) {}
-        var confirmWasCalled = false
-        val gecko = GeckoPromptDelegate(mockSession)
-        val geckoChoice = object : GeckoChoice() {}
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            GECKO_PROMPT_CHOICE_TYPE.MENU,
-            arrayOf(geckoChoice)
-        )
-
-        mockSession.register(
-            object : EngineSession.Observer {
-                override fun onPromptRequest(promptRequest: PromptRequest) {
-                    promptRequestSingleChoice = promptRequest
-                }
-            })
-
-        val geckoResult = gecko.onChoicePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        assertTrue(promptRequestSingleChoice is PromptRequest.MenuChoice)
-        val request = promptRequestSingleChoice as PromptRequest.MenuChoice
-
-        request.onConfirm(request.choices.first())
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(request.choices.first())
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test(expected = InvalidParameterException::class)
-    fun `calling onChoicePrompt with not valid Gecko ChoiceType will throw an exception`() {
-        val promptDelegate = GeckoPromptDelegate(mock())
-        val geckoPrompt = GeckoChoicePrompt(
-            "title",
-            "message",
-            -1,
-            arrayOf()
-        )
-        promptDelegate.onChoicePrompt(mock(), geckoPrompt)
-    }
-
-    @Test
-    fun `onAlertPrompt must provide an alert PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var alertRequest: PromptRequest? = null
-        var dismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                alertRequest = promptRequest
-            }
-        })
-
-        val geckoResult = promptDelegate.onAlertPrompt(mock(), GeckoAlertPrompt())
-        geckoResult.accept {
-            dismissWasCalled = true
-        }
-        assertTrue(alertRequest is PromptRequest.Alert)
-
-        (alertRequest as PromptRequest.Alert).onDismiss()
-        assertTrue(dismissWasCalled)
-
-        assertEquals((alertRequest as PromptRequest.Alert).title, "title")
-        assertEquals((alertRequest as PromptRequest.Alert).message, "message")
-    }
-
-    @Test
-    fun `toIdsArray must convert an list of choices to array of id strings`() {
-        val choices = arrayOf(Choice(id = "0", label = ""), Choice(id = "1", label = ""))
-        val ids = choices.toIdsArray()
-        ids.forEachIndexed { index, item ->
-            assertEquals("$index", item)
-        }
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_DATE must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-        var onClearPicker = false
-        var geckoPrompt = GeckoDateTimePrompt("title", DATE, "", "", "")
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-
-        var geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-
-        confirmCalled = false
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-
-        assertFalse(confirmCalled)
-
-        geckoPrompt = GeckoDateTimePrompt("title", DATE, "", "", "")
-        geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onClearPicker = true
-        }
-
-        (dateRequest as PromptRequest.TimeSelection).onClear()
-        assertTrue(onClearPicker)
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_DATE with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val geckoPrompt =
-            GeckoDateTimePrompt(
-                title = "title",
-                type = DATE,
-                defaultValue = "2019-11-29",
-                minValue = "2019-11-28",
-                maxValue = "2019-11-30"
-            )
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2019-11-29".toDate("yyyy-MM-dd"))
-            assertEquals(minimumDate, "2019-11-28".toDate("yyyy-MM-dd"))
-            assertEquals(maximumDate, "2019-11-30".toDate("yyyy-MM-dd"))
-        }
-        val selectedDate = "2019-11-28".toDate("yyyy-MM-dd")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM-dd")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_MONTH must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = MONTH)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_MONTH with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = MONTH,
-            defaultValue = "2019-11",
-            minValue = "2019-11",
-            maxValue = "2019-11"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2019-11".toDate("yyyy-MM"))
-            assertEquals(minimumDate, "2019-11".toDate("yyyy-MM"))
-            assertEquals(maximumDate, "2019-11".toDate("yyyy-MM"))
-        }
-        val selectedDate = "2019-11".toDate("yyyy-MM")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_WEEK must provide a date PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = WEEK)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_WEEK with date parameters must format dates correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = WEEK,
-            defaultValue = "2018-W18",
-            minValue = "2018-W18",
-            maxValue = "2018-W26"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2018-W18".toDate("yyyy-'W'ww"))
-            assertEquals(minimumDate, "2018-W18".toDate("yyyy-'W'ww"))
-            assertEquals(maximumDate, "2018-W26".toDate("yyyy-'W'ww"))
-        }
-        val selectedDate = "2018-W26".toDate("yyyy-'W'ww")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-'W'ww")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_TIME must provide a TimeSelection PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(type = TIME)
-
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_TIME with time parameters must format time correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = TIME,
-            defaultValue = "17:00",
-            minValue = "9:00",
-            maxValue = "18:00"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "17:00".toDate("HH:mm"))
-            assertEquals(minimumDate, "9:00".toDate("HH:mm"))
-            assertEquals(maximumDate, "18:00".toDate("HH:mm"))
-        }
-        val selectedDate = "17:00".toDate("HH:mm")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("HH:mm")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt called with DATETIME_TYPE_DATETIME_LOCAL must provide a TimeSelection PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var dateRequest: PromptRequest? = null
-        var confirmCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                dateRequest = promptRequest
-            }
-        })
-        val geckoResult =
-            promptDelegate.onDateTimePrompt(mock(), GeckoDateTimePrompt(type = DATETIME_LOCAL))
-        geckoResult!!.accept {
-            confirmCalled = true
-        }
-
-        assertTrue(dateRequest is PromptRequest.TimeSelection)
-        (dateRequest as PromptRequest.TimeSelection).onConfirm(Date())
-        assertTrue(confirmCalled)
-        assertEquals((dateRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test
-    fun `onDateTimePrompt DATETIME_TYPE_DATETIME_LOCAL with date parameters must format time correctly`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var timeSelectionRequest: PromptRequest.TimeSelection? = null
-        var geckoDate: String? = null
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                timeSelectionRequest = promptRequest as PromptRequest.TimeSelection
-            }
-        })
-        val geckoPrompt = GeckoDateTimePrompt(
-            title = "title",
-            type = DATETIME_LOCAL,
-            defaultValue = "2018-06-12T19:30",
-            minValue = "2018-06-07T00:00",
-            maxValue = "2018-06-14T00:00"
-        )
-        val geckoResult = promptDelegate.onDateTimePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            geckoDate = geckoPrompt.getGeckoResult()["datetime"].toString()
-        }
-
-        assertNotNull(timeSelectionRequest)
-        with(timeSelectionRequest!!) {
-            assertEquals(initialDate, "2018-06-12T19:30".toDate("yyyy-MM-dd'T'HH:mm"))
-            assertEquals(minimumDate, "2018-06-07T00:00".toDate("yyyy-MM-dd'T'HH:mm"))
-            assertEquals(maximumDate, "2018-06-14T00:00".toDate("yyyy-MM-dd'T'HH:mm"))
-        }
-        val selectedDate = "2018-06-12T19:30".toDate("yyyy-MM-dd'T'HH:mm")
-        (timeSelectionRequest as PromptRequest.TimeSelection).onConfirm(selectedDate)
-        assertNotNull(geckoDate?.toDate("yyyy-MM-dd'T'HH:mm")?.equals(selectedDate))
-        assertEquals((timeSelectionRequest as PromptRequest.TimeSelection).title, "title")
-    }
-
-    @Test(expected = InvalidParameterException::class)
-    fun `Calling onDateTimePrompt with invalid DatetimeType will throw an exception`() {
-        val promptDelegate = GeckoPromptDelegate(mock())
-        promptDelegate.onDateTimePrompt(
-            mock(),
-            GeckoDateTimePrompt(
-                type = 13223,
-                defaultValue = "17:00",
-                minValue = "9:00",
-                maxValue = "18:00"
-            )
-        )
-    }
-
-    @Test
-    fun `date to string`() {
-        val date = Date()
-
-        var dateString = date.toString()
-        assertNotNull(dateString.isEmpty())
-
-        dateString = date.toString("yyyy")
-        val calendar = Calendar.getInstance()
-        calendar.time = date
-        val year = calendar[YEAR].toString()
-        assertEquals(dateString, year)
-    }
-
-    @Test
-    fun `Calling onFilePrompt must provide a FilePicker PromptRequest`() {
-        val context = spy(testContext)
-        val contentResolver = spy(context.contentResolver)
-        val mockSession = GeckoEngineSession(runtime)
-        var onSingleFileSelectedWasCalled = false
-        var onMultipleFilesSelectedWasCalled = false
-        var onDismissWasCalled = false
-        val mockUri: Uri = mock()
-
-        doReturn(contentResolver).`when`(context).contentResolver
-        doReturn(mock<FileInputStream>()).`when`(contentResolver).openInputStream(any())
-
-        var filePickerRequest: PromptRequest.File = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        // Prevent the file from being copied
-        doReturn(0L).`when`(promptDelegate).copyFile(any(), any())
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                filePickerRequest = promptRequest as PromptRequest.File
-            }
-        })
-        var geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.SINGLE, capture = NONE)
-
-        var geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onSingleFileSelectedWasCalled = true
-        }
-
-        filePickerRequest.onSingleFileSelected(context, mockUri)
-        assertTrue(onSingleFileSelectedWasCalled)
-
-        onSingleFileSelectedWasCalled = false
-        filePickerRequest.onSingleFileSelected(context, mockUri)
-
-        assertFalse(onSingleFileSelectedWasCalled)
-
-        geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.MULTIPLE, capture = ANY)
-        geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onMultipleFilesSelectedWasCalled = true
-        }
-
-        filePickerRequest.onMultipleFilesSelected(context, arrayOf(mockUri))
-        assertTrue(onMultipleFilesSelectedWasCalled)
-
-        onMultipleFilesSelectedWasCalled = false
-        filePickerRequest.onMultipleFilesSelected(context, arrayOf(mockUri))
-
-        assertFalse(onMultipleFilesSelectedWasCalled)
-
-        geckoPrompt = GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.SINGLE, capture = NONE)
-        geckoResult = promptDelegate.onFilePrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        filePickerRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        assertTrue(filePickerRequest.mimeTypes.isEmpty())
-        assertFalse(filePickerRequest.isMultipleFilesSelection)
-        assertEquals(PromptRequest.File.FacingMode.NONE, filePickerRequest.captureMode)
-
-        promptDelegate.onFilePrompt(
-            mock(),
-            GeckoFilePrompt(type = GECKO_PROMPT_FILE_TYPE.MULTIPLE, capture = USER)
-        )
-
-        assertTrue(filePickerRequest.isMultipleFilesSelection)
-        assertEquals(
-            PromptRequest.File.FacingMode.FRONT_CAMERA,
-            filePickerRequest.captureMode
-        )
-    }
-
-    @Test
-    fun `Calling onLoginSave must provide an SaveLoginPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onLoginSaved = false
-        var onDismissWasCalled = false
-
-        var loginSaveRequest: PromptRequest.SaveLoginPrompt = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                loginSaveRequest = promptRequest as PromptRequest.SaveLoginPrompt
-            }
-        })
-
-        val login = createLogin()
-        val saveOption = Autocomplete.LoginSaveOption(login.toLoginEntry())
-
-        var geckoResult =
-            promptDelegate.onLoginSave(mock(), GeckoLoginSavePrompt(arrayOf(saveOption)))
-
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        loginSaveRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        geckoResult = promptDelegate.onLoginSave(mock(), GeckoLoginSavePrompt(arrayOf(saveOption)))
-
-        geckoResult!!.accept {
-            onLoginSaved = true
-        }
-
-        loginSaveRequest.onConfirm(login)
-        assertTrue(onLoginSaved)
-
-        onLoginSaved = false
-
-        loginSaveRequest.onConfirm(login)
-
-        assertFalse(onLoginSaved)
-    }
-
-    @Test
-    fun `Calling onLoginSelect must provide an SelectLoginPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onLoginSelected = false
-        var onDismissWasCalled = false
-
-        var loginSelectRequest: PromptRequest.SelectLoginPrompt = mock()
-
-        val promptDelegate = spy(GeckoPromptDelegate(mockSession))
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                loginSelectRequest = promptRequest as PromptRequest.SelectLoginPrompt
-            }
-        })
-
-        val login = createLogin()
-        val loginSelectOption = Autocomplete.LoginSelectOption(login.toLoginEntry())
-
-        val secondLogin = createLogin(username = "username2")
-        val secondLoginSelectOption = Autocomplete.LoginSelectOption(secondLogin.toLoginEntry())
-
-        var geckoResult =
-            promptDelegate.onLoginSelect(
-                mock(),
-                GeckoLoginSelectPrompt(arrayOf(loginSelectOption, secondLoginSelectOption))
-            )
-
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        loginSelectRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        geckoResult = promptDelegate.onLoginSelect(
-            mock(),
-            GeckoLoginSelectPrompt(arrayOf(loginSelectOption, secondLoginSelectOption))
-        )
-
-        geckoResult!!.accept {
-            onLoginSelected = true
-        }
-
-        loginSelectRequest.onConfirm(login)
-        assertTrue(onLoginSelected)
-
-        onLoginSelected = false
-        loginSelectRequest.onConfirm(login)
-
-        assertFalse(onLoginSelected)
-    }
-
-    fun createLogin(
-        guid: String = "id",
-        password: String = "password",
-        username: String = "username",
-        origin: String = "https://www.origin.com",
-        httpRealm: String = "httpRealm",
-        formActionOrigin: String = "https://www.origin.com",
-        usernameField: String = "usernameField",
-        passwordField: String = "passwordField"
-    ) = Login(
-        guid = guid,
-        origin = origin,
-        password = password,
-        username = username,
-        httpRealm = httpRealm,
-        formActionOrigin = formActionOrigin,
-        usernameField = usernameField,
-        passwordField = passwordField
-    )
-
-    /**
-     * Converts an Android Components [Login] to a GeckoView [LoginStorage.LoginEntry]
-     */
-    private fun Login.toLoginEntry() = Autocomplete.LoginEntry.Builder()
-        .guid(guid)
-        .origin(origin)
-        .formActionOrigin(formActionOrigin)
-        .httpRealm(httpRealm)
-        .username(username)
-        .password(password)
-        .build()
-
-    @Test
-    fun `Calling onAuthPrompt must provide an Authentication PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var authRequest: PromptRequest.Authentication = mock()
-        var onConfirmWasCalled = false
-        var onConfirmOnlyPasswordWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                authRequest = promptRequest as PromptRequest.Authentication
-            }
-        })
-
-        var geckoResult =
-            promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = mock()))
-        geckoResult!!.accept {
-            onConfirmWasCalled = true
-        }
-
-        authRequest.onConfirm("", "")
-        assertTrue(onConfirmWasCalled)
-
-        onConfirmWasCalled = false
-        authRequest.onConfirm("", "")
-
-        assertFalse(onConfirmWasCalled)
-
-        geckoResult =
-            promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = mock()))
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        authRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        val authOptions = GeckoAuthOptions()
-        ReflectionUtils.setField(authOptions, "level", GECKO_AUTH_LEVEL.SECURE)
-
-        var flags = 0
-        flags = flags.or(GECKO_AUTH_FLAGS.ONLY_PASSWORD)
-        flags = flags.or(GECKO_AUTH_FLAGS.PREVIOUS_FAILED)
-        flags = flags.or(GECKO_AUTH_FLAGS.CROSS_ORIGIN_SUB_RESOURCE)
-        flags = flags.or(GECKO_AUTH_FLAGS.HOST)
-        ReflectionUtils.setField(authOptions, "flags", flags)
-
-        val geckoPrompt = GeckoAuthPrompt(authOptions = authOptions)
-        geckoResult = promptDelegate.onAuthPrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            val hasPassword = geckoPrompt.getGeckoResult().containsKey("password")
-            val hasUser = geckoPrompt.getGeckoResult().containsKey("username")
-            onConfirmOnlyPasswordWasCalled = hasPassword && hasUser == false
-        }
-
-        authRequest.onConfirm("", "")
-
-        with(authRequest) {
-            assertTrue(onlyShowPassword)
-            assertTrue(previousFailed)
-            assertTrue(isCrossOrigin)
-
-            assertEquals(method, AC_AUTH_METHOD.HOST)
-            assertEquals(level, AC_AUTH_LEVEL.SECURED)
-            assertTrue(onConfirmOnlyPasswordWasCalled)
-        }
-
-        ReflectionUtils.setField(authOptions, "level", GECKO_AUTH_LEVEL.PW_ENCRYPTED)
-
-        promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = authOptions))
-
-        assertEquals(authRequest.level, AC_AUTH_LEVEL.PASSWORD_ENCRYPTED)
-
-        ReflectionUtils.setField(authOptions, "level", -2423)
-
-        promptDelegate.onAuthPrompt(mock(), GeckoAuthPrompt(authOptions = authOptions))
-
-        assertEquals(authRequest.level, AC_AUTH_LEVEL.NONE)
-    }
-
-    @Test
-    fun `Calling onColorPrompt must provide a Color PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var colorRequest: PromptRequest.Color = mock()
-        var onConfirmWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                colorRequest = promptRequest as PromptRequest.Color
-            }
-        })
-
-        var geckoResult =
-            promptDelegate.onColorPrompt(mock(), GeckoColorPrompt(defaultValue = "#e66465"))
-        geckoResult!!.accept {
-            onConfirmWasCalled = true
-        }
-
-        with(colorRequest) {
-
-            assertEquals(defaultColor, "#e66465")
-
-            onConfirm("#f6b73c")
-            assertTrue(onConfirmWasCalled)
-
-            onConfirmWasCalled = false
-            onConfirm("#f6b73c")
-
-            assertFalse(onConfirmWasCalled)
-        }
-
-        geckoResult = promptDelegate.onColorPrompt(mock(), GeckoColorPrompt())
-        geckoResult!!.accept {
-            onDismissWasCalled = true
-        }
-
-        colorRequest.onDismiss()
-        assertTrue(onDismissWasCalled)
-
-        with(colorRequest) {
-            assertEquals(defaultColor, "defaultValue")
-        }
-    }
-
-    @Test
-    fun `onTextPrompt must provide an TextPrompt PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.TextPrompt = mock()
-        var dismissWasCalled = false
-        var confirmWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.TextPrompt
-            }
-        })
-
-        var geckoResult = promptDelegate.onTextPrompt(mock(), GeckoTextPrompt())
-        geckoResult!!.accept {
-            dismissWasCalled = true
-        }
-
-        with(request) {
-            assertEquals(title, "title")
-            assertEquals(inputLabel, "message")
-            assertEquals(inputValue, "defaultValue")
-
-            onDismiss()
-            assertTrue(dismissWasCalled)
-        }
-
-        geckoResult = promptDelegate.onTextPrompt(mock(), GeckoTextPrompt())
-        geckoResult!!.accept {
-            confirmWasCalled = true
-        }
-
-        request.onConfirm(true, "newInput")
-        assertTrue(confirmWasCalled)
-
-        confirmWasCalled = false
-        request.onConfirm(true, "newInput")
-
-        assertFalse(confirmWasCalled)
-    }
-
-    @Test
-    fun `onPopupRequest must provide a Popup PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Popup? = null
-        var onAllowWasCalled = false
-        var onDenyWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Popup
-            }
-        })
-
-        var geckoPrompt = GeckoPopupPrompt(targetUri = "www.popuptest.com/")
-        var geckoResult = promptDelegate.onPopupPrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onAllowWasCalled = geckoPrompt.getGeckoResult()["response"] == true
-        }
-
-        with(request!!) {
-            assertEquals(targetUri, "www.popuptest.com/")
-
-            onAllow()
-            assertTrue(onAllowWasCalled)
-
-            onAllowWasCalled = false
-            onAllow()
-
-            assertFalse(onAllowWasCalled)
-        }
-
-        geckoPrompt = GeckoPopupPrompt()
-        geckoResult = promptDelegate.onPopupPrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onDenyWasCalled = geckoPrompt.getGeckoResult()["response"] == false
-        }
-
-        request!!.onDeny()
-        assertTrue(onDenyWasCalled)
-
-        onDenyWasCalled = false
-        request!!.onDeny()
-
-        assertFalse(onDenyWasCalled)
-    }
-
-    @Test
-    fun `onBeforeUnloadPrompt must provide a BeforeUnload PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.BeforeUnload? = null
-        var onAllowWasCalled = false
-        var onDenyWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.BeforeUnload
-            }
-        })
-
-        var geckoPrompt = GeckoBeforeUnloadPrompt()
-        var geckoResult = promptDelegate.onBeforeUnloadPrompt(mock(), geckoPrompt)
-
-        geckoResult!!.accept {
-            onAllowWasCalled = geckoPrompt.getGeckoResult()["allow"] == true
-        }
-
-        with(request!!) {
-            assertEquals(title, "")
-
-            onLeave()
-            assertTrue(onAllowWasCalled)
-
-            onAllowWasCalled = false
-            onLeave()
-
-            assertFalse(onAllowWasCalled)
-        }
-
-        geckoPrompt = GeckoBeforeUnloadPrompt()
-        geckoResult = promptDelegate.onBeforeUnloadPrompt(mock(), geckoPrompt)
-        geckoResult!!.accept {
-            onDenyWasCalled = geckoPrompt.getGeckoResult()["allow"] == false
-        }
-
-        request!!.onStay()
-        assertTrue(onDenyWasCalled)
-
-        onDenyWasCalled = false
-        request!!.onStay()
-
-        assertFalse(onDenyWasCalled)
-    }
-
-    @Test
-    fun `onBeforeUnloadPrompt will inform listeners when if navigation is cancelled`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onBeforeUnloadPromptCancelledCalled = false
-        var request: PromptRequest.BeforeUnload = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.BeforeUnload
-            }
-
-            override fun onBeforeUnloadPromptDenied() {
-                onBeforeUnloadPromptCancelledCalled = true
-            }
-        })
-        val prompt = mock<GeckoBeforeUnloadPrompt>()
-        doReturn(false).`when`(prompt).isComplete
-
-        GeckoPromptDelegate(mockSession).onBeforeUnloadPrompt(mock(), prompt)
-        request.onStay()
-
-        assertTrue(onBeforeUnloadPromptCancelledCalled)
-    }
-
-    @Test
-    fun `onSharePrompt must provide a Share PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Share? = null
-        var onSuccessWasCalled = false
-        var onFailureWasCalled = false
-        var onDismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Share
-            }
-        })
-
-        var geckoPrompt = GeckoSharePrompt()
-        var geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onSuccessWasCalled = true
-        }
-
-        with(request!!) {
-            assertEquals(data.title, "title")
-            assertEquals(data.text, "text")
-            assertEquals(data.url, "https://example.com")
-
-            onSuccess()
-            assertTrue(onSuccessWasCalled)
-
-            onSuccessWasCalled = false
-            onSuccess()
-
-            assertFalse(onSuccessWasCalled)
-        }
-
-        geckoPrompt = GeckoSharePrompt()
-        geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onFailureWasCalled = true
-        }
-
-        request!!.onFailure()
-        assertTrue(onFailureWasCalled)
-
-        onFailureWasCalled = false
-        request!!.onFailure()
-
-        assertFalse(onFailureWasCalled)
-
-        geckoPrompt = GeckoSharePrompt()
-        geckoResult = promptDelegate.onSharePrompt(mock(), geckoPrompt)
-        geckoResult.accept {
-            onDismissWasCalled = true
-        }
-
-        request!!.onDismiss()
-        assertTrue(onDismissWasCalled)
-    }
-
-    @Test
-    fun `onButtonPrompt must provide a Confirm PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Confirm = mock()
-        var onPositiveButtonWasCalled = false
-        var onNegativeButtonWasCalled = false
-        var onNeutralButtonWasCalled = false
-        var dismissWasCalled = false
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Confirm
-            }
-        })
-
-        var geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onPositiveButtonWasCalled = true
-        }
-
-        with(request) {
-
-            assertNotNull(request)
-            assertEquals(title, "title")
-            assertEquals(message, "message")
-
-            onConfirmPositiveButton(false)
-            assertTrue(onPositiveButtonWasCalled)
-
-            onPositiveButtonWasCalled = false
-            onConfirmPositiveButton(false)
-
-            assertFalse(onPositiveButtonWasCalled)
-        }
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onNeutralButtonWasCalled = true
-        }
-
-        request.onConfirmNeutralButton(false)
-        assertTrue(onNeutralButtonWasCalled)
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            onNegativeButtonWasCalled = true
-        }
-
-        request.onConfirmNegativeButton(false)
-        assertTrue(onNegativeButtonWasCalled)
-
-        onNegativeButtonWasCalled = false
-        request.onConfirmNegativeButton(false)
-
-        assertFalse(onNegativeButtonWasCalled)
-
-        geckoResult = promptDelegate.onButtonPrompt(mock(), GeckoPromptPrompt())
-        geckoResult!!.accept {
-            dismissWasCalled = true
-        }
-
-        request.onDismiss()
-        assertTrue(dismissWasCalled)
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt must provide a Repost PromptRequest`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Repost = mock()
-        var onPositiveButtonWasCalled = false
-        var onNegativeButtonWasCalled = false
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-        })
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        var geckoResult = promptDelegate.onRepostConfirmPrompt(mock(), GeckoRepostPrompt())
-        geckoResult!!.accept {
-            onPositiveButtonWasCalled = true
-        }
-        request.onConfirm()
-        assertTrue(onPositiveButtonWasCalled)
-
-        onPositiveButtonWasCalled = false
-        request.onConfirm()
-
-        assertFalse(onPositiveButtonWasCalled)
-
-        geckoResult = promptDelegate.onRepostConfirmPrompt(mock(), GeckoRepostPrompt())
-        geckoResult!!.accept {
-            onNegativeButtonWasCalled = true
-        }
-        request.onDismiss()
-        assertTrue(onNegativeButtonWasCalled)
-
-        onNegativeButtonWasCalled = false
-        request.onDismiss()
-
-        assertFalse(onNegativeButtonWasCalled)
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt will not be able to complete multiple times`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var request: PromptRequest.Repost = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-        })
-
-        val promptDelegate = GeckoPromptDelegate(mockSession)
-
-        var prompt = mock<GeckoRepostPrompt>()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(false).`when`(prompt).isComplete
-        request.onConfirm()
-        verify(prompt).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(true).`when`(prompt).isComplete
-        request.onConfirm()
-        verify(prompt, never()).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(false).`when`(prompt).isComplete
-        request.onDismiss()
-        verify(prompt).confirm(any())
-
-        prompt = mock()
-        promptDelegate.onRepostConfirmPrompt(mock(), prompt)
-        doReturn(true).`when`(prompt).isComplete
-        request.onDismiss()
-        verify(prompt, never()).confirm(any())
-    }
-
-    @Test
-    fun `onRepostConfirmPrompt will inform listeners when it is being dismissed`() {
-        val mockSession = GeckoEngineSession(runtime)
-        var onRepostPromptCancelledCalled = false
-        var request: PromptRequest.Repost = mock()
-
-        mockSession.register(object : EngineSession.Observer {
-            override fun onPromptRequest(promptRequest: PromptRequest) {
-                request = promptRequest as PromptRequest.Repost
-            }
-
-            override fun onRepostPromptCancelled() {
-                onRepostPromptCancelledCalled = true
-            }
-        })
-        val prompt = mock<GeckoRepostPrompt>()
-        doReturn(false).`when`(prompt).isComplete
-
-        GeckoPromptDelegate(mockSession).onRepostConfirmPrompt(mock(), prompt)
-        request.onDismiss()
-
-        assertTrue(onRepostPromptCancelledCalled)
-    }
-
-    @Test
-    fun `dismissSafely only dismiss if the prompt is NOT already dismissed`() {
-        val prompt = spy(GeckoAlertPrompt())
-        val geckoResult = mock<GeckoResult<GeckoSession.PromptDelegate.PromptResponse>>()
-
-        doReturn(false).`when`(prompt).isComplete
-
-        prompt.dismissSafely(geckoResult)
-
-        verify(geckoResult).complete(any())
-    }
-
-    @Test
-    fun `dismissSafely do nothing if the prompt is already dismissed`() {
-        val prompt = spy(GeckoAlertPrompt())
-        val geckoResult = mock<GeckoResult<GeckoSession.PromptDelegate.PromptResponse>>()
-
-        doReturn(true).`when`(prompt).isComplete
-
-        prompt.dismissSafely(geckoResult)
-
-        verify(geckoResult, never()).complete(any())
-    }
-
-    class GeckoChoicePrompt(
-        title: String,
-        message: String,
-        type: Int,
-        choices: Array<out GeckoChoice>
-    ) : GeckoSession.PromptDelegate.ChoicePrompt(title, message, type, choices)
-
-    class GeckoAlertPrompt(title: String = "title", message: String = "message") :
-        GeckoSession.PromptDelegate.AlertPrompt(title, message)
-
-    class GeckoDateTimePrompt(
-        title: String = "title",
-        type: Int,
-        defaultValue: String = "",
-        minValue: String = "",
-        maxValue: String = ""
-    ) : GeckoSession.PromptDelegate.DateTimePrompt(title, type, defaultValue, minValue, maxValue)
-
-    class GeckoFilePrompt(
-        title: String = "title",
-        type: Int,
-        capture: Int = 0,
-        mimeTypes: Array<out String> = emptyArray()
-    ) : GeckoSession.PromptDelegate.FilePrompt(title, type, capture, mimeTypes)
-
-    class GeckoAuthPrompt(
-        title: String = "title",
-        message: String = "message",
-        authOptions: AuthOptions
-    ) : GeckoSession.PromptDelegate.AuthPrompt(title, message, authOptions)
-
-    class GeckoColorPrompt(
-        title: String = "title",
-        defaultValue: String = "defaultValue"
-    ) : GeckoSession.PromptDelegate.ColorPrompt(title, defaultValue)
-
-    class GeckoTextPrompt(
-        title: String = "title",
-        message: String = "message",
-        defaultValue: String = "defaultValue"
-    ) : GeckoSession.PromptDelegate.TextPrompt(title, message, defaultValue)
-
-    class GeckoPopupPrompt(
-        targetUri: String = "targetUri"
-    ) : GeckoSession.PromptDelegate.PopupPrompt(targetUri)
-
-    class GeckoBeforeUnloadPrompt : GeckoSession.PromptDelegate.BeforeUnloadPrompt()
-
-    class GeckoSharePrompt(
-        title: String? = "title",
-        text: String? = "text",
-        url: String? = "https://example.com"
-    ) : GeckoSession.PromptDelegate.SharePrompt(title, text, url)
-
-    class GeckoPromptPrompt(
-        title: String = "title",
-        message: String = "message"
-    ) : GeckoSession.PromptDelegate.ButtonPrompt(title, message)
-
-    class GeckoLoginSelectPrompt(
-        loginArray: Array<Autocomplete.LoginSelectOption>
-    ) : GeckoSession.PromptDelegate.AutocompleteRequest<Autocomplete.LoginSelectOption>(loginArray)
-
-    class GeckoLoginSavePrompt(
-        login: Array<Autocomplete.LoginSaveOption>
-    ) : GeckoSession.PromptDelegate.AutocompleteRequest<Autocomplete.LoginSaveOption>(login)
-
-    class GeckoAuthOptions : GeckoSession.PromptDelegate.AuthPrompt.AuthOptions()
-
-    class GeckoRepostPrompt : GeckoSession.PromptDelegate.RepostConfirmPrompt()
-
-    private fun GeckoSession.PromptDelegate.BasePrompt.getGeckoResult(): GeckoBundle {
-        val javaClass = GeckoSession.PromptDelegate.BasePrompt::class.java
-        val method = javaClass.getDeclaredMethod("ensureResult")
-        method.isAccessible = true
-        return (method.invoke(this) as GeckoBundle)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt
deleted file mode 100644
index 9d73baae3c74..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/selection/GeckoSelectionActionDelegateTest.kt
+++ /dev/null
@@ -1,92 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.selection
-
-import android.app.Activity
-import android.app.Application
-import android.app.Service
-import android.view.MenuItem
-import mozilla.components.concept.engine.selection.SelectionActionDelegate
-import mozilla.components.support.test.mock
-import org.junit.Assert
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Test
-
-class GeckoSelectionActionDelegateTest {
-
-    @Test
-    fun `maybe create with non-activity context should return null`() {
-        val customDelegate = mock<SelectionActionDelegate>()
-
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Application>(), customDelegate))
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Service>(), customDelegate))
-    }
-
-    @Test
-    fun `maybe create with null delegate context should return null`() {
-        assertNull(GeckoSelectionActionDelegate.maybeCreate(mock<Activity>(), null))
-    }
-
-    @Test
-    fun `maybe create with expected inputs should return non-null`() {
-        assertNotNull(GeckoSelectionActionDelegate.maybeCreate(mock<Activity>(), mock()))
-    }
-
-    @Test
-    fun `getAllActions should contain all actions from the custom delegate`() {
-        val customActions = arrayOf("1", "2", "3")
-        val customDelegate = object : SelectionActionDelegate {
-            override fun getAllActions(): Array<String> = customActions
-            override fun isActionAvailable(id: String, selectedText: String): Boolean = false
-            override fun getActionTitle(id: String): CharSequence? = ""
-            override fun performAction(id: String, selectedText: String): Boolean = false
-            override fun sortedActions(actions: Array<String>): Array<String> {
-                return actions
-            }
-        }
-
-        val geckoDelegate = TestGeckoSelectionActionDelegate(mock(), customDelegate)
-
-        val actualActions = geckoDelegate.allActions
-
-        customActions.forEach {
-            Assert.assertTrue(actualActions.contains(it))
-        }
-    }
-
-    @Test
-    fun `WHEN perform action triggers a security exception THEN false is returned`() {
-        val customActions = arrayOf("1", "2", "3")
-        val customDelegate = object : SelectionActionDelegate {
-            override fun getAllActions(): Array<String> = customActions
-            override fun isActionAvailable(id: String, selectedText: String): Boolean = false
-            override fun getActionTitle(id: String): CharSequence? = ""
-            override fun performAction(id: String, selectedText: String): Boolean {
-                throw SecurityException("test")
-            }
-            override fun sortedActions(actions: Array<String>): Array<String> {
-                return actions
-            }
-        }
-
-        val geckoDelegate = TestGeckoSelectionActionDelegate(mock(), customDelegate)
-        assertFalse(geckoDelegate.performAction("test", mock()))
-    }
-}
-
-/**
- * Test object that overrides visibility for [getAllActions]
- */
-class TestGeckoSelectionActionDelegate(
-    activity: Activity,
-    customDelegate: SelectionActionDelegate
-) : GeckoSelectionActionDelegate(activity, customDelegate) {
-    public override fun getAllActions() = super.getAllActions()
-    public override fun performAction(id: String, item: MenuItem): Boolean {
-        return super.performAction(id, item)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt
deleted file mode 100644
index e660a3761ff9..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/util/SpeculativeSessionFactoryTest.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.util
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNotSame
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mozilla.geckoview.GeckoRuntime
-
-@RunWith(AndroidJUnit4::class)
-class SpeculativeSessionFactoryTest {
-
-    private lateinit var runtime: GeckoRuntime
-
-    @Before
-    fun setup() {
-        runtime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-    }
-
-    @Test
-    fun `create does nothing if matching speculative session already exists`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertSame(speculativeSession, factory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `create clears previous non-matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        factory.create(runtime = runtime, private = false, contextId = null, defaultSettings = mock())
-        assertNotSame(speculativeSession, factory.speculativeEngineSession)
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `get consumes matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertFalse(factory.hasSpeculativeSession())
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-
-        val speculativeSession = factory.get(private = true, contextId = null)
-        assertNotNull(speculativeSession)
-        assertFalse(speculativeSession!!.isObserved())
-
-        assertFalse(factory.hasSpeculativeSession())
-        assertNull(factory.speculativeEngineSession)
-    }
-
-    @Test
-    fun `get clears previous non-matching speculative session`() {
-        val factory = SpeculativeSessionFactory()
-        assertNull(factory.speculativeEngineSession)
-
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        val speculativeSession = factory.speculativeEngineSession
-        assertNotNull(speculativeSession)
-
-        assertNull(factory.get(private = true, contextId = "test"))
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clears speculative session on crash`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-
-        factory.speculativeEngineSession?.engineSession?.notifyObservers { onCrash() }
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clears speculative session when process is killed`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-
-        factory.speculativeEngineSession?.engineSession?.notifyObservers { onProcessKilled() }
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession!!.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-
-    @Test
-    fun `clear unregisters observer and closes session`() {
-        val factory = SpeculativeSessionFactory()
-        factory.create(runtime = runtime, private = true, contextId = null, defaultSettings = mock())
-        assertTrue(factory.hasSpeculativeSession())
-        val speculativeSession = factory.speculativeEngineSession
-        assertTrue(speculativeSession!!.engineSession.isObserved())
-
-        factory.clear()
-        assertFalse(factory.hasSpeculativeSession())
-        assertFalse(speculativeSession.engineSession.geckoSession.isOpen)
-        assertFalse(speculativeSession.engineSession.isObserved())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt
deleted file mode 100644
index 0b9c7d5c1595..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webextension/GeckoWebExtensionTest.kt
+++ /dev/null
@@ -1,603 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webextension
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.concept.engine.DefaultSettings
-import mozilla.components.concept.engine.webextension.Action
-import mozilla.components.concept.engine.webextension.ActionHandler
-import mozilla.components.concept.engine.webextension.DisabledFlags
-import mozilla.components.concept.engine.webextension.MessageHandler
-import mozilla.components.concept.engine.webextension.Port
-import mozilla.components.concept.engine.webextension.TabHandler
-import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.whenever
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertSame
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.never
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mozilla.gecko.util.GeckoBundle
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoSession
-import org.mozilla.geckoview.MockCreateTabDetails
-import org.mozilla.geckoview.MockUpdateTabDetails
-import org.mozilla.geckoview.MockWebExtension
-import org.mozilla.geckoview.WebExtension
-import org.mozilla.geckoview.WebExtensionController
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebExtensionTest {
-
-    @Test
-    fun `register background message handler`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val portCaptor = argumentCaptor<Port>()
-        val portDelegateCaptor = argumentCaptor<WebExtension.PortDelegate>()
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-
-        extension.registerBackgroundMessageHandler("mozacTest", messageHandler)
-        verify(nativeGeckoWebExt).setMessageDelegate(messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Verify messages are forwarded to message handler
-        val message: Any = mock()
-        val sender: WebExtension.MessageSender = mock()
-        whenever(messageHandler.onMessage(eq(message), eq(null))).thenReturn("result")
-        assertNotNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler).onMessage(eq(message), eq(null))
-
-        whenever(messageHandler.onMessage(eq(message), eq(null))).thenReturn(null)
-        assertNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler, times(2)).onMessage(eq(message), eq(null))
-
-        // Verify port is connected and forwarded to message handler
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        verify(messageHandler).onPortConnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertNotNull(extension.getConnectedPort("mozacTest"))
-        assertSame(port, (extension.getConnectedPort("mozacTest") as GeckoPort).nativePort)
-
-        // Verify port messages are forwarded to message handler
-        verify(port).setDelegate(portDelegateCaptor.capture())
-        val portDelegate = portDelegateCaptor.value
-        val portMessage: JSONObject = mock()
-        portDelegate.onPortMessage(portMessage, port)
-        verify(messageHandler).onPortMessage(eq(portMessage), portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-
-        // Verify disconnected port is forwarded to message handler if connected
-        portDelegate.onDisconnect(mock())
-        verify(messageHandler, never()).onPortDisconnected(portCaptor.capture())
-
-        portDelegate.onDisconnect(port)
-        verify(messageHandler).onPortDisconnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertNull(extension.getConnectedPort("mozacTest"))
-    }
-
-    @Test
-    fun `register content message handler`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val portCaptor = argumentCaptor<Port>()
-        val portDelegateCaptor = argumentCaptor<WebExtension.PortDelegate>()
-
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        assertFalse(extension.hasContentMessageHandler(session, "mozacTest"))
-        extension.registerContentMessageHandler(session, "mozacTest", messageHandler)
-        verify(webExtensionSessionController).setMessageDelegate(eq(nativeGeckoWebExt), messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Verify messages are forwarded to message handler and return value passed on
-        val message: Any = mock()
-        val sender: WebExtension.MessageSender = mock()
-        whenever(messageHandler.onMessage(eq(message), eq(session))).thenReturn("result")
-        assertNotNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler).onMessage(eq(message), eq(session))
-
-        whenever(messageHandler.onMessage(eq(message), eq(session))).thenReturn(null)
-        assertNull(messageDelegateCaptor.value.onMessage("mozacTest", message, sender))
-        verify(messageHandler, times(2)).onMessage(eq(message), eq(session))
-
-        // Verify port is connected and forwarded to message handler
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        verify(messageHandler).onPortConnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-        assertNotNull(extension.getConnectedPort("mozacTest", session))
-        assertSame(port, (extension.getConnectedPort("mozacTest", session) as GeckoPort).nativePort)
-
-        // Verify port messages are forwarded to message handler
-        verify(port).setDelegate(portDelegateCaptor.capture())
-        val portDelegate = portDelegateCaptor.value
-        val portMessage: JSONObject = mock()
-        portDelegate.onPortMessage(portMessage, port)
-        verify(messageHandler).onPortMessage(eq(portMessage), portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-
-        // Verify disconnected port is forwarded to message handler if connected
-        portDelegate.onDisconnect(mock())
-        verify(messageHandler, never()).onPortDisconnected(portCaptor.capture())
-
-        portDelegate.onDisconnect(port)
-        verify(messageHandler).onPortDisconnected(portCaptor.capture())
-        assertSame(port, (portCaptor.value as GeckoPort).nativePort)
-        assertSame(session, (portCaptor.value as GeckoPort).engineSession)
-        assertNull(extension.getConnectedPort("mozacTest", session))
-    }
-
-    @Test
-    fun `disconnect port from content script`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerContentMessageHandler(session, "mozacTest", messageHandler)
-        verify(webExtensionSessionController).setMessageDelegate(eq(nativeGeckoWebExt), messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Connect port
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        assertNotNull(extension.getConnectedPort("mozacTest", session))
-
-        // Disconnect port
-        extension.disconnectPort("mozacTest", session)
-        verify(port).disconnect()
-        assertNull(extension.getConnectedPort("mozacTest", session))
-    }
-
-    @Test
-    fun `disconnect port from background script`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val messageHandler: MessageHandler = mock()
-        val messageDelegateCaptor = argumentCaptor<WebExtension.MessageDelegate>()
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerBackgroundMessageHandler("mozacTest", messageHandler)
-
-        verify(nativeGeckoWebExt).setMessageDelegate(messageDelegateCaptor.capture(), eq("mozacTest"))
-
-        // Connect port
-        val port: WebExtension.Port = mock()
-        messageDelegateCaptor.value.onConnect(port)
-        assertNotNull(extension.getConnectedPort("mozacTest"))
-
-        // Disconnect port
-        extension.disconnectPort("mozacTest")
-        verify(port).disconnect()
-        assertNull(extension.getConnectedPort("mozacTest"))
-    }
-
-    @Test
-    fun `register global default action handler`() {
-        val runtime: GeckoRuntime = mock()
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val actionHandler: ActionHandler = mock()
-        val actionDelegateCaptor = argumentCaptor<WebExtension.ActionDelegate>()
-        val browserActionCaptor = argumentCaptor<Action>()
-        val pageActionCaptor = argumentCaptor<Action>()
-        val nativeBrowserAction: WebExtension.Action = mock()
-        val nativePageAction: WebExtension.Action = mock()
-
-        // Create extension and register global default action handler
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerActionHandler(actionHandler)
-        verify(nativeGeckoWebExt).setActionDelegate(actionDelegateCaptor.capture())
-
-        // Verify that browser actions are forwarded to the handler
-        actionDelegateCaptor.value.onBrowserAction(nativeGeckoWebExt, null, nativeBrowserAction)
-        verify(actionHandler).onBrowserAction(eq(extension), eq(null), browserActionCaptor.capture())
-
-        // Verify that page actions are forwarded to the handler
-        actionDelegateCaptor.value.onPageAction(nativeGeckoWebExt, null, nativePageAction)
-        verify(actionHandler).onPageAction(eq(extension), eq(null), pageActionCaptor.capture())
-
-        // Verify that toggle popup is forwarded to the handler
-        actionDelegateCaptor.value.onTogglePopup(nativeGeckoWebExt, nativeBrowserAction)
-        verify(actionHandler).onToggleActionPopup(eq(extension), any())
-
-        // We don't have access to the native WebExtension.Action fields and
-        // can't mock them either, but we can verify that we've linked
-        // the actions by simulating a click.
-        browserActionCaptor.value.onClick()
-        verify(nativeBrowserAction).click()
-        pageActionCaptor.value.onClick()
-        verify(nativePageAction).click()
-    }
-
-    @Test
-    fun `register session-specific action handler`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        val actionHandler: ActionHandler = mock()
-        val actionDelegateCaptor = argumentCaptor<WebExtension.ActionDelegate>()
-        val browserActionCaptor = argumentCaptor<Action>()
-        val pageActionCaptor = argumentCaptor<Action>()
-        val nativeBrowserAction: WebExtension.Action = mock()
-        val nativePageAction: WebExtension.Action = mock()
-
-        // Create extension and register action handler for session
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerActionHandler(session, actionHandler)
-        verify(webExtensionSessionController).setActionDelegate(eq(nativeGeckoWebExt), actionDelegateCaptor.capture())
-
-        whenever(webExtensionSessionController.getActionDelegate(nativeGeckoWebExt)).thenReturn(actionDelegateCaptor.value)
-        assertTrue(extension.hasActionHandler(session))
-
-        // Verify that browser actions are forwarded to the handler
-        actionDelegateCaptor.value.onBrowserAction(nativeGeckoWebExt, null, nativeBrowserAction)
-        verify(actionHandler).onBrowserAction(eq(extension), eq(session), browserActionCaptor.capture())
-
-        // Verify that page actions are forwarded to the handler
-        actionDelegateCaptor.value.onPageAction(nativeGeckoWebExt, null, nativePageAction)
-        verify(actionHandler).onPageAction(eq(extension), eq(session), pageActionCaptor.capture())
-
-        // We don't have access to the native WebExtension.Action fields and
-        // can't mock them either, but we can verify that we've linked
-        // the actions by simulating a click.
-        browserActionCaptor.value.onClick()
-        verify(nativeBrowserAction).click()
-        pageActionCaptor.value.onClick()
-        verify(nativePageAction).click()
-    }
-
-    @Test
-    fun `register global tab handler`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.settings).thenReturn(mock())
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val tabHandler: TabHandler = mock()
-        val tabDelegateCaptor = argumentCaptor<WebExtension.TabDelegate>()
-        val engineSessionCaptor = argumentCaptor<GeckoEngineSession>()
-        var metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putString("optionsPageUrl", "optionsPageUrl")
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension(bundle)
-
-        // Create extension and register global tab handler
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        val defaultSettings: DefaultSettings = mock()
-
-        extension.registerTabHandler(tabHandler, defaultSettings)
-        verify(nativeGeckoWebExt).tabDelegate = tabDelegateCaptor.capture()
-
-        // Verify that tab methods are forwarded to the handler
-        val tabBundle = GeckoBundle()
-        tabBundle.putBoolean("active", true)
-        tabBundle.putString("url", "url")
-        val tabDetails = MockCreateTabDetails(tabBundle)
-        tabDelegateCaptor.value.onNewTab(nativeGeckoWebExt, tabDetails)
-        verify(tabHandler).onNewTab(eq(extension), engineSessionCaptor.capture(), eq(true), eq("url"))
-        assertNotNull(engineSessionCaptor.value)
-
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExt)
-        verify(tabHandler, never()).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-
-        metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeGeckoWebExtWithMetadata = MockWebExtension(bundle)
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExtWithMetadata)
-        verify(tabHandler, never()).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-
-        metaDataBundle.putString("optionsPageURL", "http://options-page.moz")
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeGeckoWebExtWithOptionsPageUrl = MockWebExtension(bundle)
-        tabDelegateCaptor.value.onOpenOptionsPage(nativeGeckoWebExtWithOptionsPageUrl)
-        verify(tabHandler).onNewTab(eq(extension), any(), eq(false), eq("http://options-page.moz"))
-    }
-
-    @Test
-    fun `register session-specific tab handler`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val webExtensionSessionController: WebExtension.SessionController = mock()
-        val session: GeckoEngineSession = mock()
-        val geckoSession: GeckoSession = mock()
-        whenever(geckoSession.webExtensionController).thenReturn(webExtensionSessionController)
-        whenever(session.geckoSession).thenReturn(geckoSession)
-
-        val tabHandler: TabHandler = mock()
-        val tabDelegateCaptor = argumentCaptor<WebExtension.SessionTabDelegate>()
-
-        val nativeGeckoWebExt: WebExtension = mockNativeExtension()
-        // Create extension and register tab handler for session
-        val extension = GeckoWebExtension(
-            runtime = runtime,
-            nativeExtension = nativeGeckoWebExt
-        )
-        extension.registerTabHandler(session, tabHandler)
-        verify(webExtensionSessionController).setTabDelegate(eq(nativeGeckoWebExt), tabDelegateCaptor.capture())
-
-        assertFalse(extension.hasTabHandler(session))
-        whenever(webExtensionSessionController.getTabDelegate(nativeGeckoWebExt)).thenReturn(tabDelegateCaptor.value)
-        assertTrue(extension.hasTabHandler(session))
-
-        // Verify that tab methods are forwarded to the handler
-        val tabBundle = GeckoBundle()
-        tabBundle.putBoolean("active", true)
-        val tabDetails = MockUpdateTabDetails(tabBundle)
-        tabDelegateCaptor.value.onUpdateTab(nativeGeckoWebExt, mock(), tabDetails)
-        verify(tabHandler).onUpdateTab(eq(extension), eq(session), eq(true), eq(null))
-
-        tabDelegateCaptor.value.onCloseTab(nativeGeckoWebExt, mock())
-        verify(tabHandler).onCloseTab(eq(extension), eq(session))
-    }
-
-    @Test
-    fun `all metadata fields are mapped correctly`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("promptPermissions", arrayOf("p1", "p2"))
-        metaDataBundle.putStringArray("origins", arrayOf("o1", "o2"))
-        metaDataBundle.putString("description", "desc")
-        metaDataBundle.putString("version", "1.0")
-        metaDataBundle.putString("creatorName", "developer1")
-        metaDataBundle.putString("creatorURL", "https://developer1.dev")
-        metaDataBundle.putString("homepageURL", "https://mozilla.org")
-        metaDataBundle.putString("name", "myextension")
-        metaDataBundle.putString("optionsPageURL", "http://options-page.moz")
-        metaDataBundle.putString("baseURL", "moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/")
-        metaDataBundle.putBoolean("openOptionsPageInTab", false)
-        metaDataBundle.putStringArray("disabledFlags", arrayOf("userDisabled"))
-        metaDataBundle.putBoolean("temporary", true)
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeWebExtension = MockWebExtension(bundle)
-        val extensionWithMetadata = GeckoWebExtension(nativeWebExtension, runtime)
-        val metadata = extensionWithMetadata.getMetadata()
-        assertNotNull(metadata!!)
-        assertEquals("1.0", metadata.version)
-        assertEquals(listOf("p1", "p2"), metadata.permissions)
-        assertEquals(listOf("o1", "o2"), metadata.hostPermissions)
-        assertEquals("desc", metadata.description)
-        assertEquals("developer1", metadata.developerName)
-        assertEquals("https://developer1.dev", metadata.developerUrl)
-        assertEquals("https://mozilla.org", metadata.homePageUrl)
-        assertEquals("myextension", metadata.name)
-        assertEquals("http://options-page.moz", metadata.optionsPageUrl)
-        assertEquals("moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/", metadata.baseUrl)
-        assertFalse(metadata.openOptionsPageInTab)
-        assertTrue(metadata.temporary)
-        assertTrue(metadata.disabledFlags.contains(DisabledFlags.USER))
-        assertFalse(metadata.disabledFlags.contains(DisabledFlags.BLOCKLIST))
-        assertFalse(metadata.disabledFlags.contains(DisabledFlags.APP_SUPPORT))
-    }
-
-    @Test
-    fun `nullable metadata fields`() {
-        val runtime: GeckoRuntime = mock()
-        val webExtensionController: WebExtensionController = mock()
-        whenever(runtime.webExtensionController).thenReturn(webExtensionController)
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putStringArray("promptPermissions", arrayOf("p1", "p2"))
-        metaDataBundle.putString("version", "1.0")
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putString("baseURL", "moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/")
-        bundle.putBundle("metaData", metaDataBundle)
-
-        val nativeWebExtension = MockWebExtension(bundle)
-        val extensionWithMetadata = GeckoWebExtension(nativeWebExtension, runtime)
-        val metadata = extensionWithMetadata.getMetadata()
-        assertNotNull(metadata!!)
-        assertEquals("1.0", metadata.version)
-        assertEquals(listOf("p1", "p2"), metadata.permissions)
-        assertEquals(emptyList<String>(), metadata.hostPermissions)
-        assertEquals("moz-extension://123c5c5b-cd03-4bea-b23f-ac0b9ab40257/", metadata.baseUrl)
-        assertNull(metadata.description)
-        assertNull(metadata.developerName)
-        assertNull(metadata.developerUrl)
-        assertNull(metadata.homePageUrl)
-        assertNull(metadata.name)
-        assertNull(metadata.optionsPageUrl)
-    }
-
-    @Test
-    fun `isBuiltIn depends on native state`() {
-        val runtime: GeckoRuntime = mock()
-
-        val builtInBundle = GeckoBundle()
-        builtInBundle.putBoolean("isBuiltIn", true)
-        builtInBundle.putString("webExtensionId", "id")
-        builtInBundle.putString("locationURI", "uri")
-        val builtInExtension = GeckoWebExtension(
-            mockNativeExtension(builtInBundle),
-            runtime
-        )
-        assertTrue(builtInExtension.isBuiltIn())
-
-        val externalBundle = GeckoBundle()
-        externalBundle.putBoolean("isBuiltIn", false)
-        externalBundle.putString("webExtensionId", "id")
-        externalBundle.putString("locationURI", "uri")
-        val externalExtension = GeckoWebExtension(
-            mockNativeExtension(externalBundle),
-            runtime
-        )
-        assertFalse(externalExtension.isBuiltIn())
-    }
-
-    @Test
-    fun `isEnabled depends on native state and defaults to true if state unknown`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putBoolean("enabled", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeEnabledWebExtension = MockWebExtension(bundle)
-        val enabledWebExtension = GeckoWebExtension(nativeEnabledWebExtension, runtime)
-        assertTrue(enabledWebExtension.isEnabled())
-
-        metaDataBundle.putBoolean("enabled", false)
-        metaDataBundle.putStringArray("disabledFlags", arrayOf("userDisabled"))
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeDisabledWebExtnesion = MockWebExtension(bundle)
-        val disabledWebExtension = GeckoWebExtension(nativeDisabledWebExtnesion, runtime)
-        assertFalse(disabledWebExtension.isEnabled())
-    }
-
-    @Test
-    fun `isAllowedInPrivateBrowsing depends on native state and defaults to false if state unknown`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-
-        val builtInBundle = GeckoBundle()
-        builtInBundle.putBoolean("isBuiltIn", true)
-        builtInBundle.putString("webExtensionId", "id")
-        builtInBundle.putString("locationURI", "uri")
-        builtInBundle.putBoolean("privateBrowsingAllowed", false)
-
-        val builtInExtension = GeckoWebExtension(
-            mockNativeExtension(builtInBundle),
-            runtime
-        )
-        assertTrue(builtInExtension.isAllowedInPrivateBrowsing())
-
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        metaDataBundle.putBoolean("privateBrowsingAllowed", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithPrivateBrowsing = MockWebExtension(bundle)
-        val webExtensionWithPrivateBrowsing = GeckoWebExtension(nativeWebExtensionWithPrivateBrowsing, runtime)
-        assertTrue(webExtensionWithPrivateBrowsing.isAllowedInPrivateBrowsing())
-
-        metaDataBundle.putBoolean("privateBrowsingAllowed", false)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithoutPrivateBrowsing = MockWebExtension(bundle)
-        val webExtensionWithoutPrivateBrowsing = GeckoWebExtension(nativeWebExtensionWithoutPrivateBrowsing, runtime)
-        assertFalse(webExtensionWithoutPrivateBrowsing.isAllowedInPrivateBrowsing())
-    }
-
-    @Test
-    fun `loadIcon tries to load icon from metadata`() {
-        val runtime: GeckoRuntime = mock()
-        whenever(runtime.webExtensionController).thenReturn(mock())
-        val bundle = GeckoBundle()
-        bundle.putString("webExtensionId", "id")
-        bundle.putString("locationURI", "uri")
-
-        val metaDataBundle = GeckoBundle()
-        val emptyIconBundle = GeckoBundle()
-        metaDataBundle.putBoolean("enabled", true)
-        metaDataBundle.putStringArray("disabledFlags", emptyArray())
-        metaDataBundle.putBundle("icons", emptyIconBundle)
-        bundle.putBundle("metaData", metaDataBundle)
-        val nativeWebExtensionWithoutIcon = MockWebExtension(bundle)
-        val webExtensionWithoutIcon = GeckoWebExtension(nativeWebExtensionWithoutIcon, runtime)
-
-        var iconLoadComplete = false
-        var result = webExtensionWithoutIcon.getIcon(48)
-        assertNotNull(result)
-        result.accept { iconLoadComplete = true }
-        assertTrue(iconLoadComplete)
-
-        iconLoadComplete = false
-        val iconBundle = GeckoBundle()
-        iconBundle.putString("48", "test")
-        metaDataBundle.putBundle("icons", iconBundle)
-        val nativeWebExtensionWithIcon = MockWebExtension(bundle)
-        val webExtensionWithIcon = GeckoWebExtension(nativeWebExtensionWithIcon, runtime)
-
-        result = webExtensionWithIcon.getIcon(48)
-        assertNotNull(result)
-        result.accept { iconLoadComplete = true }
-        assertFalse(iconLoadComplete)
-    }
-
-    private fun mockNativeExtension(useBundle: GeckoBundle? = null): WebExtension {
-        val bundle = useBundle ?: GeckoBundle().apply {
-            putString("webExtensionId", "id")
-            putString("locationURI", "uri")
-        }
-        return spy(MockWebExtension(bundle))
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt
deleted file mode 100644
index d47ff20ec86a..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webnotifications/GeckoWebNotificationDelegateTest.kt
+++ /dev/null
@@ -1,118 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webnotifications
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.webnotifications.WebNotification
-import mozilla.components.concept.engine.webnotifications.WebNotificationDelegate
-import mozilla.components.support.test.argumentCaptor
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.MockWebNotification
-import org.mozilla.geckoview.WebNotification as GeckoViewWebNotification
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebNotificationDelegateTest {
-
-    @Test
-    fun `onShowNotification is forwarded to delegate`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = "source"
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onShowNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onShowNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-        assertFalse(notification.triggeredByWebExtension)
-    }
-
-    @Test
-    fun `onCloseNotification is forwarded to delegate`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = "source"
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onCloseNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onCloseNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-    }
-
-    @Test
-    fun `notification without a source are from web extensions`() {
-        val webNotificationDelegate: WebNotificationDelegate = mock()
-        val geckoViewWebNotification: GeckoViewWebNotification = MockWebNotification(
-            title = "title",
-            tag = "tag",
-            cookie = "cookie",
-            text = "text",
-            imageUrl = "imageUrl",
-            textDirection = "textDirection",
-            lang = "lang",
-            requireInteraction = true,
-            source = ""
-        )
-        val geckoWebNotificationDelegate = GeckoWebNotificationDelegate(webNotificationDelegate)
-
-        val notificationCaptor = argumentCaptor<WebNotification>()
-        geckoWebNotificationDelegate.onShowNotification(geckoViewWebNotification)
-        verify(webNotificationDelegate).onShowNotification(notificationCaptor.capture())
-
-        val notification = notificationCaptor.value
-        assertEquals(notification.title, geckoViewWebNotification.title)
-        assertEquals(notification.tag, geckoViewWebNotification.tag)
-        assertEquals(notification.body, geckoViewWebNotification.text)
-        assertEquals(notification.sourceUrl, geckoViewWebNotification.source)
-        assertEquals(notification.iconUrl, geckoViewWebNotification.imageUrl)
-        assertEquals(notification.direction, geckoViewWebNotification.textDirection)
-        assertEquals(notification.lang, geckoViewWebNotification.lang)
-        assertEquals(notification.requireInteraction, geckoViewWebNotification.requireInteraction)
-        assertTrue(notification.triggeredByWebExtension)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt
deleted file mode 100644
index 446e9184e801..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushDelegateTest.kt
+++ /dev/null
@@ -1,154 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.concept.engine.webpush.WebPushDelegate
-import mozilla.components.concept.engine.webpush.WebPushSubscription
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.isNull
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoResult
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebPushDelegateTest {
-
-    @Test
-    fun `delegate is always invoked`() {
-        val delegate: WebPushDelegate = mock()
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-
-        geckoDelegate.onGetSubscription("test")
-
-        verify(delegate).onGetSubscription(eq("test"), any())
-
-        geckoDelegate.onSubscribe("test", null)
-
-        verify(delegate).onSubscribe(eq("test"), isNull(), any())
-
-        geckoDelegate.onSubscribe("test", "key".toByteArray())
-
-        verify(delegate).onSubscribe(eq("test"), eq("key".toByteArray()), any())
-
-        geckoDelegate.onUnsubscribe("test")
-
-        verify(delegate).onUnsubscribe(eq("test"), any())
-    }
-
-    @Test
-    fun `onGetSubscription result is completed`() {
-        var subscription: WebPushSubscription? = WebPushSubscription(
-            "test",
-            "https://example.com",
-            null,
-            ByteArray(65),
-            ByteArray(16)
-        )
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onGetSubscription(
-                scope: String,
-                onSubscription: (WebPushSubscription?) -> Unit
-            ) {
-                onSubscription(subscription)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onGetSubscription("test")
-
-        result?.accept { sub ->
-            assert(sub!!.scope == subscription!!.scope)
-        }
-
-        subscription = null
-
-        val nullResult = geckoDelegate.onGetSubscription("test")
-
-        nullResult?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onSubscribe result is completed`() {
-        var subscription: WebPushSubscription? = WebPushSubscription(
-            "test",
-            "https://example.com",
-            null,
-            ByteArray(65),
-            ByteArray(16)
-        )
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onSubscribe(
-                scope: String,
-                serverKey: ByteArray?,
-                onSubscribe: (WebPushSubscription?) -> Unit
-            ) {
-                onSubscribe(subscription)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onSubscribe("test", null)
-
-        result?.accept { sub ->
-            assert(sub!!.scope == subscription!!.scope)
-            assertNull(sub.appServerKey)
-        }
-
-        subscription = null
-
-        val nullResult = geckoDelegate.onSubscribe("test", null)
-        nullResult?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onUnsubscribe result is completed successfully`() {
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onUnsubscribe(
-                scope: String,
-                onUnsubscribe: (Boolean) -> Unit
-            ) {
-                onUnsubscribe(true)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-        val result = geckoDelegate.onUnsubscribe("test")
-
-        result?.accept { sub ->
-            assertNull(sub)
-        }
-    }
-
-    @Test
-    fun `onUnsubscribe result receives throwable when unsuccessful`() {
-        val delegate: WebPushDelegate = object : WebPushDelegate {
-            override fun onUnsubscribe(
-                scope: String,
-                onUnsubscribe: (Boolean) -> Unit
-            ) {
-                onUnsubscribe(false)
-            }
-        }
-
-        val geckoDelegate = GeckoWebPushDelegate(delegate)
-
-        val result = geckoDelegate.onUnsubscribe("test")
-
-        result?.exceptionally<Void> { throwable ->
-            assertTrue(throwable.localizedMessage == "Un-subscribing from subscription failed.")
-            GeckoResult.fromValue(null)
-        }
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt
deleted file mode 100644
index 4fc5d0d08046..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/webpush/GeckoWebPushHandlerTest.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.webpush
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.support.test.any
-import mozilla.components.support.test.eq
-import mozilla.components.support.test.mock
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.`when`
-import org.mockito.Mockito.isNull
-import org.mockito.Mockito.verify
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.WebPushController
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWebPushHandlerTest {
-
-    lateinit var runtime: GeckoRuntime
-    lateinit var controller: WebPushController
-
-    @Before
-    fun setup() {
-        controller = mock()
-        runtime = mock()
-        `when`(runtime.webPushController).thenReturn(controller)
-    }
-
-    @Test
-    fun `runtime controller is invoked`() {
-        val handler = GeckoWebPushHandler(runtime)
-
-        handler.onPushMessage("", null)
-        verify(controller).onPushEvent(any(), isNull())
-
-        handler.onSubscriptionChanged("test")
-        verify(controller).onSubscriptionChanged(eq("test"))
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt
deleted file mode 100644
index db2007204314..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/browser/engine/gecko/window/GeckoWindowRequestTest.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.engine.gecko.window
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.engine.gecko.GeckoEngineSession
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertEquals
-import org.junit.Test
-import org.junit.runner.RunWith
-
-@RunWith(AndroidJUnit4::class)
-class GeckoWindowRequestTest {
-
-    @Test
-    fun testPrepare() {
-        val engineSession: GeckoEngineSession = mock()
-        val windowRequest = GeckoWindowRequest("mozilla.org", engineSession)
-        assertEquals(engineSession, windowRequest.prepare())
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/test/ReflectionUtils.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/test/ReflectionUtils.kt
deleted file mode 100644
index 3186862e2524..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/mozilla/components/test/ReflectionUtils.kt
+++ /dev/null
@@ -1,20 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.test
-
-import java.lang.reflect.Field
-import java.lang.reflect.Modifier
-
-object ReflectionUtils {
-    fun <T : Any> setField(instance: T, fieldName: String, value: Any?) {
-        val originField = instance.javaClass.getField(fieldName)
-
-        val modifiersField = Field::class.java.getDeclaredField("modifiers")
-        modifiersField.isAccessible = true
-        modifiersField.setInt(originField, originField.modifiers and Modifier.FINAL.inv())
-
-        originField.set(instance, value)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockSelection.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockSelection.kt
deleted file mode 100644
index b9cd522290d7..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockSelection.kt
+++ /dev/null
@@ -1,9 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import org.mozilla.gecko.util.GeckoBundle
-
-class MockSelection(bundle: GeckoBundle) : GeckoSession.SelectionActionDelegate.Selection(bundle, emptySet(), null)
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebExtension.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebExtension.kt
deleted file mode 100644
index 0046f6dc4b2e..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebExtension.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import mozilla.components.support.test.mock
-import org.mozilla.gecko.util.GeckoBundle
-
-class MockWebExtension(bundle: GeckoBundle) : WebExtension(DelegateControllerProvider { mock() }, bundle)
-class MockCreateTabDetails(bundle: GeckoBundle) : WebExtension.CreateTabDetails(bundle)
-class MockUpdateTabDetails(bundle: GeckoBundle) : WebExtension.UpdateTabDetails(bundle)
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebNotification.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebNotification.kt
deleted file mode 100644
index 62b8f93e1378..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebNotification.kt
+++ /dev/null
@@ -1,17 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-class MockWebNotification(
-    title: String,
-    tag: String,
-    cookie: String,
-    text: String,
-    imageUrl: String,
-    textDirection: String,
-    lang: String,
-    requireInteraction: Boolean,
-    source: String
-) : WebNotification(title, tag, cookie, text, imageUrl, textDirection, lang, requireInteraction, source)
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt b/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt
deleted file mode 100644
index 48424a016e03..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/java/org/mozilla/geckoview/MockWebResponseInfo.kt
+++ /dev/null
@@ -1,21 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.geckoview
-
-import mozilla.components.test.ReflectionUtils
-
-class MockWebResponseInfo(
-    uri: String,
-    contentType: String,
-    contentLength: Long,
-    filename: String?
-) : GeckoSession.WebResponseInfo() {
-    init {
-        ReflectionUtils.setField(this, "uri", uri)
-        ReflectionUtils.setField(this, "contentType", contentType)
-        ReflectionUtils.setField(this, "filename", filename)
-        ReflectionUtils.setField(this, "contentLength", contentLength)
-    }
-}
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/browser/engine-gecko-nightly/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
deleted file mode 100644
index cf1c399ea81e..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
+++ /dev/null
@@ -1,2 +0,0 @@
-mock-maker-inline
-// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/components/browser/engine-gecko-nightly/src/test/resources/robolectric.properties b/android-components/components/browser/engine-gecko-nightly/src/test/resources/robolectric.properties
deleted file mode 100644
index 89a6c8b4c2e7..000000000000
--- a/android-components/components/browser/engine-gecko-nightly/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-sdk=28
\ No newline at end of file
diff --git a/android-components/components/browser/engine-gecko/README.md b/android-components/components/browser/engine-gecko/README.md
index 5bae20c8936f..2071f57f5ea7 100644
--- a/android-components/components/browser/engine-gecko/README.md
+++ b/android-components/components/browser/engine-gecko/README.md
@@ -1,11 +1,9 @@
 # [Android Components](../../../README.md) > Browser > Engine-Gecko
 
-[*Engine*](../../concept/engine/README.md) implementation based on [GeckoView](https://wiki.mozilla.org/Mobile/GeckoView) (Nightly channel).
+[*Engine*](../../concept/engine/README.md) implementation based on [GeckoView](https://wiki.mozilla.org/Mobile/GeckoView).
 
 ## Usage
 
-See [concept-engine](../../concept/engine/README.md) for a documentation of the abstract engine API this component implements.
-
 ### Setting up the dependency
 
 Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
@@ -14,45 +12,27 @@ Use Gradle to download the library from [maven.mozilla.org](https://maven.mozill
 implementation "org.mozilla.components:browser-engine-gecko:{latest-version}"
 ```
 
-### Initializing
-
-It is recommended to create only one `GeckoEngine` instance per app. To create a `GeckoEngine` a `GeckoRuntime` and optionally `DefaultSettings` are needed.
-
-```Kotlin
-// Create default settings (optional) and enable tracking protection for all future sessions.
-val defaultSettings = DefaultSettings().apply {
-    trackingProtectionPolicy = EngineSession.TrackingProtectionPolicy.all()
-}
-
-// Create and initialize a Gecko runtime with the default settings.
-val runtime = GeckoRuntime.getDefault(applicationContext)
-
-// Create an engine instance to be used by other components.
-val engine = GeckoEngine(runtime, defaultSettings)
-```
-
-### Integration
-
-Usually it is not needed to interact with the `Engine` component directly. The [browser-session](../session/README.md) component will take care of making the state accessible and link a `Session` to an `EngineSession` internally. The [feature-session](../../feature/session/README.md) component will provide "use cases" to perform actions like loading URLs and takes care of rendering the selected `Session` on an `EngineView`.
+### Integration with the Glean SDK
 
-### View
+#### Before using this component
+Products sending telemetry and using this component *must request* a data-review following [this process](https://wiki.mozilla.org/Firefox/Data_Collection).
 
-`GeckoEngineView` is the Gecko-based implementation of `EngineView` in order to render web content.
+The [Glean SDK](../../../components/service/glean/README.md) can be used to collect [Gecko Telemetry](https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/index.html).
+Applications using both this component and the Glean SDK should setup the Gecko Telemetry delegate
+as shown below:
 
-```XML
-<mozilla.components.browser.engine.gecko.GeckoEngineView
-    android:id="@+id/engineView"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" />
+```Kotlin
+    val builder = GeckoRuntimeSettings.Builder()
+    val runtimeSettings = builder
+        .telemetryDelegate(GeckoGleanAdapter()) // Sets up the delegate!
+        .build()
+    // Create the Gecko runtime.
+    GeckoRuntime.create(context, runtimeSettings)
 ```
 
-`GeckoEngineView` can render any `GeckoEngineSession` using the `render()` method.
+#### Adding new metrics
 
-```Kotlin
-val engineSession = engine.createSession()
-val engineView = view.findViewById<GeckoEngineView>(R.id.engineView)
-engineView.render(engineSession)
-```
+New Gecko metrics can be added as described [in the Firefox Telemetry docs](https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/start/adding-a-new-probe.html).
 
 ## License
 
diff --git a/android-components/components/browser/engine-gecko/build.gradle b/android-components/components/browser/engine-gecko/build.gradle
index 03b52d8df952..f1a7117bb349 100644
--- a/android-components/components/browser/engine-gecko/build.gradle
+++ b/android-components/components/browser/engine-gecko/build.gradle
@@ -54,17 +54,18 @@ dependencies {
     implementation project(':concept-fetch')
     implementation project(':support-ktx')
     implementation project(':support-utils')
+
     implementation Dependencies.kotlin_stdlib
     implementation Dependencies.kotlin_coroutines
 
-    api Gecko.geckoview_release
+    api Dependencies.mozilla_geckoview
 
     testImplementation Dependencies.androidx_test_core
     testImplementation Dependencies.androidx_test_junit
     testImplementation Dependencies.testing_robolectric
+    testImplementation Dependencies.testing_coroutines
     testImplementation Dependencies.testing_mockito
     testImplementation Dependencies.testing_mockwebserver
-    testImplementation Dependencies.testing_coroutines
     testImplementation project(':support-test')
     testImplementation project(':tooling-fetch-tests')
 
diff --git a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
index 038a0d9fd491..14f06596c125 100644
--- a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
+++ b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/GeckoEngineView.kt
@@ -90,13 +90,6 @@ class GeckoEngineView @JvmOverloads constructor(
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var currentSelection: BasicSelectionActionDelegate? = null
 
-    /**
-     * Cache of the last valid input result we got from GeckoView.
-     */
-    @Suppress("Deprecation")
-    @VisibleForTesting
-    internal var lastInputResult: EngineView.InputResult = EngineView.InputResult.INPUT_RESULT_UNHANDLED
-
     override var selectionActionDelegate: SelectionActionDelegate? = null
 
     init {
@@ -175,25 +168,7 @@ class GeckoEngineView @JvmOverloads constructor(
     override fun canScrollVerticallyDown() =
         true // waiting for this issue https://bugzilla.mozilla.org/show_bug.cgi?id=1507569
 
-    @Suppress("MagicNumber", "Deprecation")
-    override fun getInputResult(): EngineView.InputResult {
-        // Direct mapping of GeckoView's returned values.
-        // If not fail fast to allow for a quick fix.
-        val input = geckoView.inputResult
-        lastInputResult = when (input) {
-            0 -> EngineView.InputResult.INPUT_RESULT_UNHANDLED
-            1 -> EngineView.InputResult.INPUT_RESULT_HANDLED
-            2 -> EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT
-            3 -> {
-                // Drop this result and return the previous.
-                // See https://bugzilla.mozilla.org/show_bug.cgi?id=1687430 for details
-                lastInputResult
-            }
-            else -> throw IllegalArgumentException("Unexpected geckoView.inputResult: \"$input\"")
-        }
-
-        return lastInputResult
-    }
+    override fun getInputResultDetail() = geckoView.inputResultDetail
 
     override fun setVerticalClipping(clippingHeight: Int) {
         geckoView.setVerticalClipping(clippingHeight)
diff --git a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
index a1ba885563ab..25b32c6963e4 100644
--- a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
+++ b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/NestedGeckoView.kt
@@ -10,10 +10,8 @@ import androidx.annotation.VisibleForTesting
 import androidx.core.view.NestedScrollingChild
 import androidx.core.view.NestedScrollingChildHelper
 import androidx.core.view.ViewCompat
-import mozilla.components.concept.engine.EngineView
+import mozilla.components.concept.engine.InputResultDetail
 import org.mozilla.geckoview.GeckoView
-import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_HANDLED
-import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_UNHANDLED
 
 /**
  * geckoView that supports nested scrolls (for using in a CoordinatorLayout).
@@ -44,11 +42,11 @@ open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrolli
     internal var childHelper: NestedScrollingChildHelper = NestedScrollingChildHelper(this)
 
     /**
-     * Integer indicating how user's MotionEvent was handled.
+     * How user's MotionEvent will be handled.
      *
-     * There must be a 1-1 relation between this values and [EngineView.InputResult]'s.
+     * @see InputResultDetail
      */
-    internal var inputResult: Int = INPUT_RESULT_UNHANDLED
+    internal var inputResultDetail = InputResultDetail.newInstance(true)
 
     init {
         isNestedScrollingEnabled = true
@@ -62,7 +60,8 @@ open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrolli
 
         when (action) {
             MotionEvent.ACTION_MOVE -> {
-                val allowScroll = !shouldPinOnScreen() && inputResult == INPUT_RESULT_HANDLED
+                val allowScroll = !shouldPinOnScreen() && inputResultDetail.isTouchHandledByBrowser()
+
                 var deltaY = lastY - eventY
 
                 if (allowScroll && dispatchNestedPreScroll(0, deltaY, scrollConsumed, scrollOffset)) {
@@ -99,7 +98,7 @@ open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrolli
                 stopNestedScroll()
                 // Reset handled status so that parents of this View would not get the old value
                 // when querying it for a newly started touch event.
-                inputResult = INPUT_RESULT_UNHANDLED
+                inputResultDetail = InputResultDetail.newInstance(true)
             }
         }
 
@@ -121,9 +120,9 @@ open class NestedGeckoView(context: Context) : GeckoView(context), NestedScrolli
     internal fun updateInputResult(event: MotionEvent) {
         super.onTouchEventForDetailResult(event)
             .accept {
-                // This should never be null.
-                // Prefer to crash and investigate after rather than not knowing about problems with this.
-                inputResult = it?.handledResult()!!
+                inputResultDetail = inputResultDetail.copy(
+                    it?.handledResult(), it?.scrollableDirections(), it?.overscrollDirections()
+                )
                 startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL)
             }
     }
diff --git a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
index ae946e495495..71288f44b210 100644
--- a/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
+++ b/android-components/components/browser/engine-gecko/src/main/java/mozilla/components/browser/engine/gecko/autofill/GeckoLoginDelegateWrapper.kt
@@ -17,6 +17,8 @@ import org.mozilla.geckoview.GeckoResult
  * them to [storageDelegate]. This allows us to avoid duplicating [LoginStorageDelegate] code
  * between different versions of GeckoView, by duplicating this wrapper instead.
  */
+@Suppress("Deprecation")
+// This will be addressed in https://github.com/mozilla-mobile/android-components/issues/10093
 class GeckoLoginDelegateWrapper(private val storageDelegate: LoginStorageDelegate) :
     Autocomplete.LoginStorageDelegate {
 
diff --git a/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt b/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
index 37288c748cd3..6d99f123e351 100644
--- a/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
+++ b/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/GeckoEngineViewTest.kt
@@ -12,7 +12,6 @@ import android.view.View
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import mozilla.components.browser.engine.gecko.GeckoEngineView.Companion.DARK_COVER
 import mozilla.components.browser.engine.gecko.selection.GeckoSelectionActionDelegate
-import mozilla.components.concept.engine.EngineView
 import mozilla.components.concept.engine.mediaquery.PreferredColorScheme
 import mozilla.components.concept.engine.selection.SelectionActionDelegate
 import mozilla.components.support.test.argumentCaptor
@@ -22,6 +21,7 @@ import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertNull
+import org.junit.Assert.assertSame
 import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -278,55 +278,11 @@ class GeckoEngineViewTest {
         assertFalse(engineView.canClearSelection())
     }
 
-    @Suppress("Deprecation")
     @Test
-    fun `currentInputResult should default to EngineView#InputResult#INPUT_RESULT_UNHANDLED`() {
+    fun `GIVEN a GeckoView WHEN EngineView returns the InputResultDetail THEN the value from the GeckoView is used`() {
         val engineView = GeckoEngineView(context)
+        val geckoview = engineView.geckoView
 
-        assertEquals(EngineView.InputResult.INPUT_RESULT_UNHANDLED, engineView.lastInputResult)
-    }
-
-    @Suppress("Deprecation")
-    @Test
-    fun `getInputResult should do a 1-1 mapping of the values received from GeckoView and cache the result`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        whenever(engineView.geckoView.inputResult).thenReturn(0)
-        assertEquals(EngineView.InputResult.INPUT_RESULT_UNHANDLED, engineView.getInputResult())
-        assertEquals(EngineView.InputResult.INPUT_RESULT_UNHANDLED, engineView.lastInputResult)
-
-        whenever(engineView.geckoView.inputResult).thenReturn(1)
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.getInputResult())
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.lastInputResult)
-
-        whenever(engineView.geckoView.inputResult).thenReturn(2)
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT, engineView.getInputResult())
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT, engineView.lastInputResult)
-    }
-
-    @Suppress("Deprecation")
-    @Test
-    fun `INPUT_RESULD_IGNORED should be ignored`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        whenever(engineView.geckoView.inputResult).thenReturn(1)
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.getInputResult())
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.lastInputResult)
-
-        whenever(engineView.geckoView.inputResult).thenReturn(3)
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.getInputResult())
-        assertEquals(EngineView.InputResult.INPUT_RESULT_HANDLED, engineView.lastInputResult)
-    }
-
-    @Suppress("Deprecation")
-    @Test(expected = IllegalArgumentException::class)
-    fun `Values other than 0, 1, 2, 3 received as input results from GeckoView should throw`() {
-        val engineView = GeckoEngineView(context)
-        engineView.geckoView = mock()
-
-        whenever(engineView.geckoView.inputResult).thenReturn(4)
-        engineView.getInputResult()
+        assertSame(geckoview.inputResultDetail, engineView.getInputResultDetail())
     }
 }
diff --git a/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt b/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
index a9b9a91273ff..b5d95681bc17 100644
--- a/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
+++ b/android-components/components/browser/engine-gecko/src/test/java/mozilla/components/browser/engine/gecko/NestedGeckoViewTest.kt
@@ -19,6 +19,7 @@ import mozilla.components.support.test.argumentCaptor
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.mockMotionEvent
 import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -28,7 +29,6 @@ import org.mockito.Mockito.spy
 import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
 import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_HANDLED
-import org.mozilla.geckoview.PanZoomController.INPUT_RESULT_UNHANDLED
 import org.robolectric.Robolectric.buildActivity
 
 @RunWith(AndroidJUnit4::class)
@@ -97,7 +97,7 @@ class NestedGeckoViewTest {
         val nestedWebView = spy(NestedGeckoView(context))
         val mockChildHelper: NestedScrollingChildHelper = mock()
         nestedWebView.childHelper = mockChildHelper
-        nestedWebView.inputResult = INPUT_RESULT_HANDLED
+        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
         doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
 
         doReturn(true).`when`(mockChildHelper).dispatchNestedPreScroll(
@@ -127,19 +127,23 @@ class NestedGeckoViewTest {
     @Test
     fun `verify onTouchEvent when ACTION_UP or ACTION_CANCEL`() {
         val nestedWebView = spy(NestedGeckoView(context))
-        nestedWebView.inputResult = INPUT_RESULT_HANDLED
+        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
         val mockChildHelper: NestedScrollingChildHelper = mock()
         nestedWebView.childHelper = mockChildHelper
         doReturn(true).`when`(nestedWebView).callSuperOnTouchEvent(any())
 
         nestedWebView.onTouchEvent(mockMotionEvent(ACTION_UP))
         verify(mockChildHelper).stopNestedScroll()
-        assertEquals(INPUT_RESULT_UNHANDLED, nestedWebView.inputResult)
+        // ACTION_UP should call "inputResultDetail.reset()". Test that call's effect.
+        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
+        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
 
-        nestedWebView.inputResult = INPUT_RESULT_HANDLED
+        nestedWebView.inputResultDetail = nestedWebView.inputResultDetail.copy(INPUT_RESULT_HANDLED)
         nestedWebView.onTouchEvent(mockMotionEvent(ACTION_CANCEL))
         verify(mockChildHelper, times(2)).stopNestedScroll()
-        assertEquals(INPUT_RESULT_UNHANDLED, nestedWebView.inputResult)
+        // ACTION_CANCEL should call "inputResultDetail.reset()". Test that call's effect.
+        assertTrue(nestedWebView.inputResultDetail.isTouchUnhandled())
+        assertFalse(nestedWebView.inputResultDetail.isTouchHandledByBrowser())
 
         // onTouchEventForResult should be called only for ACTION_DOWN
         verify(nestedWebView, times(0)).updateInputResult(any())
diff --git a/android-components/components/browser/session-storage/build.gradle b/android-components/components/browser/session-storage/build.gradle
index 9138512a0757..de522547b84a 100644
--- a/android-components/components/browser/session-storage/build.gradle
+++ b/android-components/components/browser/session-storage/build.gradle
@@ -56,7 +56,7 @@ dependencies {
     testImplementation Dependencies.testing_mockito
     testImplementation Dependencies.testing_coroutines
 
-    androidTestImplementation project(':browser-engine-gecko-nightly')
+    androidTestImplementation project(':browser-engine-gecko')
     androidTestImplementation project(':support-android-test')
     androidTestImplementation project(':browser-session')
     androidTestImplementation project(':feature-tabs')
diff --git a/android-components/samples/browser/build.gradle b/android-components/samples/browser/build.gradle
index 833a9c6b7957..b8fa876fd5dd 100644
--- a/android-components/samples/browser/build.gradle
+++ b/android-components/samples/browser/build.gradle
@@ -31,14 +31,7 @@ android {
     flavorDimensions "engine"
 
     productFlavors {
-        // GeckoView release channels
-        geckoNightly {
-            dimension "engine"
-        }
-        geckoBeta {
-            dimension "engine"
-        }
-        geckoRelease {
+        gecko {
             dimension "engine"
         }
 
@@ -136,9 +129,7 @@ dependencies {
     implementation project(':support-webextensions')
     implementation project(':support-rustlog')
 
-    geckoNightlyImplementation project(':browser-engine-gecko-nightly')
-    geckoBetaImplementation project(':browser-engine-gecko-beta')
-    geckoReleaseImplementation project(':browser-engine-gecko')
+    geckoImplementation project(':browser-engine-gecko')
 
     implementation Dependencies.google_material
 
diff --git a/android-components/samples/browser/src/geckoNightly/java/org/mozilla/samples/browser/Components.kt b/android-components/samples/browser/src/gecko/java/org/mozilla/samples/browser/Components.kt
similarity index 100%
rename from android-components/samples/browser/src/geckoNightly/java/org/mozilla/samples/browser/Components.kt
rename to android-components/samples/browser/src/gecko/java/org/mozilla/samples/browser/Components.kt
diff --git a/android-components/samples/browser/src/geckoBeta/java/org/mozilla/samples/browser/Components.kt b/android-components/samples/browser/src/geckoBeta/java/org/mozilla/samples/browser/Components.kt
deleted file mode 100644
index a390852a3e7c..000000000000
--- a/android-components/samples/browser/src/geckoBeta/java/org/mozilla/samples/browser/Components.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.samples.browser
-
-import android.content.Context
-import mozilla.components.browser.engine.gecko.GeckoEngine
-import mozilla.components.browser.engine.gecko.glean.GeckoAdapter
-import mozilla.components.browser.engine.gecko.fetch.GeckoViewFetchClient
-import mozilla.components.concept.engine.Engine
-import mozilla.components.feature.webcompat.WebCompatFeature
-import mozilla.components.feature.webcompat.reporter.WebCompatReporterFeature
-import mozilla.components.lib.crash.handler.CrashHandlerService
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-/**
- * Helper class for lazily instantiating components needed by the application.
- */
-class Components(applicationContext: Context) : DefaultComponents(applicationContext) {
-    private val runtime by lazy {
-        // Allow for exfiltrating Gecko metrics through the Glean SDK.
-        val builder = GeckoRuntimeSettings.Builder()
-        builder.crashHandler(CrashHandlerService::class.java)
-        builder.telemetryDelegate(GeckoAdapter())
-        GeckoRuntime.create(applicationContext, builder.build())
-    }
-
-    override val engine: Engine by lazy {
-        GeckoEngine(applicationContext, engineSettings, runtime).also {
-            WebCompatFeature.install(it)
-            WebCompatReporterFeature.install(it)
-        }
-    }
-
-    override val client by lazy { GeckoViewFetchClient(applicationContext, runtime) }
-}
diff --git a/android-components/samples/browser/src/geckoRelease/java/org/mozilla/samples/browser/Components.kt b/android-components/samples/browser/src/geckoRelease/java/org/mozilla/samples/browser/Components.kt
deleted file mode 100644
index 0af1bb26cb90..000000000000
--- a/android-components/samples/browser/src/geckoRelease/java/org/mozilla/samples/browser/Components.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.samples.browser
-
-import android.content.Context
-import mozilla.components.browser.engine.gecko.GeckoEngine
-import mozilla.components.browser.engine.gecko.glean.GeckoAdapter
-import mozilla.components.browser.engine.gecko.fetch.GeckoViewFetchClient
-import mozilla.components.concept.engine.Engine
-import mozilla.components.feature.webcompat.WebCompatFeature
-import mozilla.components.feature.webcompat.reporter.WebCompatReporterFeature
-import mozilla.components.lib.crash.handler.CrashHandlerService
-import org.mozilla.geckoview.GeckoRuntime
-import org.mozilla.geckoview.GeckoRuntimeSettings
-
-/**
- * Helper class for lazily instantiating components needed by the application.
- */
-class Components(private val applicationContext: Context) : DefaultComponents(applicationContext) {
-    private val runtime by lazy {
-        // Allow for exfiltrating Gecko metrics through the Glean SDK.
-        val builder = GeckoRuntimeSettings.Builder()
-        builder.crashHandler(CrashHandlerService::class.java)
-        builder.telemetryDelegate(GeckoAdapter())
-        GeckoRuntime.create(applicationContext, builder.build())
-    }
-
-    override val engine: Engine by lazy {
-        GeckoEngine(applicationContext, engineSettings, runtime).also {
-            WebCompatFeature.install(it)
-            WebCompatReporterFeature.install(it)
-        }
-    }
-
-    override val client by lazy { GeckoViewFetchClient(applicationContext, runtime) }
-}
diff --git a/android-components/taskcluster/ci/config.yml b/android-components/taskcluster/ci/config.yml
index dd7d8c9ee78e..121a7f22d67a 100644
--- a/android-components/taskcluster/ci/config.yml
+++ b/android-components/taskcluster/ci/config.yml
@@ -9,7 +9,6 @@ treeherder:
         # This list is based on .buildconfig.yml except the exceptions down below
         browser-awesomebar: browser-awesomebar
         browser-domains: browser-domains
-        browser-engine-gecko-beta: browser-engine-gecko-beta
         browser-engine-gecko: browser-engine-gecko
         browser-engine-system: browser-engine-system
         browser-errorpages: browser-errorpages
@@ -124,7 +123,6 @@ treeherder:
         ui-widgets: ui-widgets
 
         # These ones are too long to fit in 25 chars
-        browser-engine-gecko-nigh: browser-engine-gecko-nightly
         lib-fetch-httpurlconnect: lib-fetch-httpurlconnection
         feature-webcompat-report: feature-webcompat-reporter
 
