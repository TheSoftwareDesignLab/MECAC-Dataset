diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
index b79c448eeffa..6f02421602b6 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
@@ -6,16 +6,20 @@ package mozilla.components.browser.toolbar.behavior
 
 import android.content.Context
 import android.util.AttributeSet
+import android.view.Gravity
 import android.view.MotionEvent
 import android.view.View
 import androidx.annotation.VisibleForTesting
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
+import com.google.android.material.snackbar.Snackbar
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.base.crash.CrashReporting
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.support.ktx.android.view.findViewInHierarchy
 
+private const val SMALL_ELEVATION_CHANGE = 0.01f
+
 /**
  * Where the toolbar is placed on the screen.
  */
@@ -32,6 +36,7 @@ enum class ToolbarPosition {
  *
  * This implementation will:
  * - Show/Hide the [BrowserToolbar] automatically when scrolling vertically.
+ * - On showing a [Snackbar] position it above the [BrowserToolbar].
  * - Snap the [BrowserToolbar] to be hidden or visible when the user stops scrolling.
  */
 class BrowserToolbarBehavior(
@@ -125,6 +130,14 @@ class BrowserToolbarBehavior(
         return false // allow events to be passed to below listeners
     }
 
+    override fun layoutDependsOn(parent: CoordinatorLayout, child: BrowserToolbar, dependency: View): Boolean {
+        if (toolbarPosition == ToolbarPosition.BOTTOM && dependency is Snackbar.SnackbarLayout) {
+            positionSnackbar(child, dependency)
+        }
+
+        return super.layoutDependsOn(parent, child, dependency)
+    }
+
     override fun onLayoutChild(
         parent: CoordinatorLayout,
         child: BrowserToolbar,
@@ -168,6 +181,23 @@ class BrowserToolbarBehavior(
         isScrollEnabled = false
     }
 
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun positionSnackbar(child: View, snackbarLayout: Snackbar.SnackbarLayout) {
+        val params = snackbarLayout.layoutParams as CoordinatorLayout.LayoutParams
+
+        // Position the snackbar above the toolbar so that it doesn't overlay the toolbar.
+        params.anchorId = child.id
+        params.anchorGravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
+        params.gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
+
+        snackbarLayout.layoutParams = params
+
+        // In order to avoid the snackbar casting a shadow on the toolbar we adjust the elevation of the snackbar here.
+        // We still place it slightly behind the toolbar so that it will not animate over the toolbar but instead pop
+        // out from under the toolbar.
+        snackbarLayout.elevation = child.elevation - SMALL_ELEVATION_CHANGE
+    }
+
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal fun tryToScrollVertically(distance: Float) {
         browserToolbar?.let { toolbar ->
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
index 2eab0d16d821..1cad11902e9f 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
@@ -6,12 +6,14 @@ package mozilla.components.browser.toolbar.behavior
 
 import android.content.Context
 import android.graphics.Bitmap
+import android.view.Gravity
 import android.view.MotionEvent.ACTION_DOWN
 import android.view.MotionEvent.ACTION_MOVE
 import android.widget.FrameLayout
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.google.android.material.snackbar.Snackbar
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.engine.EngineSession
 import mozilla.components.concept.engine.EngineView
@@ -472,6 +474,29 @@ class BrowserToolbarBehaviorTest {
         verify(yTranslator).collapseWithAnimation(toolbar)
     }
 
+    @Test
+    fun `Behavior will position snackbar above toolbar`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+
+        val toolbar: BrowserToolbar = mock()
+        doReturn(4223).`when`(toolbar).id
+
+        val layoutParams: CoordinatorLayout.LayoutParams = CoordinatorLayout.LayoutParams(0, 0)
+
+        val snackbarLayout: Snackbar.SnackbarLayout = mock()
+        doReturn(layoutParams).`when`(snackbarLayout).layoutParams
+
+        behavior.layoutDependsOn(
+            parent = mock(),
+            child = toolbar,
+            dependency = snackbarLayout,
+        )
+
+        assertEquals(4223, layoutParams.anchorId)
+        assertEquals(Gravity.TOP or Gravity.CENTER_HORIZONTAL, layoutParams.anchorGravity)
+        assertEquals(Gravity.TOP or Gravity.CENTER_HORIZONTAL, layoutParams.gravity)
+    }
+
     @Test
     fun `Behavior will forceExpand when scrolling up and !shouldScroll if the touch was handled in the browser`() {
         val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadDialogFragment.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadDialogFragment.kt
index 8450318929f6..0ae87fca2d59 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadDialogFragment.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadDialogFragment.kt
@@ -10,7 +10,7 @@ import mozilla.components.browser.state.state.content.DownloadState
 import mozilla.components.feature.downloads.DownloadDialogFragment.Companion.BYTES_TO_MB_LIMIT
 import mozilla.components.feature.downloads.DownloadDialogFragment.Companion.KILOBYTE
 import mozilla.components.feature.downloads.DownloadDialogFragment.Companion.MEGABYTE
-import mozilla.components.feature.downloads.ext.realFilenameOrGuessed
+import mozilla.components.support.utils.DownloadUtils
 
 /**
  * This is a general representation of a dialog meant to be used in collaboration with [DownloadsFeature]
@@ -34,7 +34,11 @@ abstract class DownloadDialogFragment : AppCompatDialogFragment() {
      */
     fun setDownload(download: DownloadState) {
         val args = arguments ?: Bundle()
-        args.putString(KEY_FILE_NAME, download.realFilenameOrGuessed)
+        args.putString(
+            KEY_FILE_NAME,
+            download.fileName
+                ?: DownloadUtils.guessFileName(null, download.destinationDirectory, download.url, download.contentType),
+        )
         args.putString(KEY_URL, download.url)
         args.putLong(KEY_CONTENT_LENGTH, download.contentLength ?: 0)
         arguments = args
diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
index cb6cf0eb32eb..09203d67321b 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/DownloadsFeature.kt
@@ -17,6 +17,7 @@ import androidx.core.net.toUri
 import androidx.fragment.app.FragmentManager
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.collect
 import kotlinx.coroutines.flow.mapNotNull
 import mozilla.components.browser.state.selector.findCustomTabOrSelectedTab
 import mozilla.components.browser.state.selector.findTabOrCustomTabOrSelectedTab
@@ -24,7 +25,6 @@ import mozilla.components.browser.state.state.SessionState
 import mozilla.components.browser.state.state.content.DownloadState
 import mozilla.components.browser.state.store.BrowserStore
 import mozilla.components.feature.downloads.DownloadDialogFragment.Companion.FRAGMENT_TAG
-import mozilla.components.feature.downloads.ext.realFilenameOrGuessed
 import mozilla.components.feature.downloads.manager.AndroidDownloadManager
 import mozilla.components.feature.downloads.manager.DownloadManager
 import mozilla.components.feature.downloads.manager.noop
@@ -42,43 +42,6 @@ import mozilla.components.support.ktx.kotlin.isSameOriginAs
 import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifChanged
 import mozilla.components.support.utils.Browsers
 
-/**
- * The name of the file to be downloaded.
- */
-@JvmInline
-value class Filename(val value: String)
-
-/**
- * The size of the file to be downloaded expressed as the number of `bytes`.
- * The value will be `0` if the size is unknown.
- */
-@JvmInline
-value class ContentSize(val value: Long)
-
-/**
- * The list of all applications that can perform a download, including this application.
- */
-@JvmInline
-value class ThirdPartyDownloaderApps(val value: List<DownloaderApp>)
-
-/**
- * Callback for when the user picked a certain application with which to download the current file.
- */
-@JvmInline
-value class ThirdPartyDownloaderAppChosenCallback(val value: (DownloaderApp) -> Unit)
-
-/**
- * Callback for when the positive button of a download dialog was tapped.
- */
-@JvmInline
-value class PositiveActionCallback(val value: () -> Unit)
-
-/**
- * Callback for when the negative button of a download dialog was tapped.
- */
-@JvmInline
-value class NegativeActionCallback(val value: () -> Unit)
-
 /**
  * Feature implementation to provide download functionality for the selected
  * session. The feature will subscribe to the selected session and listen
@@ -98,10 +61,6 @@ value class NegativeActionCallback(val value: () -> Unit)
  * @property promptsStyling styling properties for the dialog.
  * @property shouldForwardToThirdParties Indicates if downloads should be forward to third party apps,
  * if there are multiple apps a chooser dialog will shown.
- * @property customFirstPartyDownloadDialog An optional delegate for showing a dialog for a download
- * that will be processed by the current application.
- * @property customThirdPartyDownloadDialog An optional delegate for showing a dialog for a download
- * that can be processed by multiple installed applications including the current one.
  */
 @Suppress("LongParameterList", "LargeClass")
 class DownloadsFeature(
@@ -116,10 +75,6 @@ class DownloadsFeature(
     private val fragmentManager: FragmentManager? = null,
     private val promptsStyling: PromptsStyling? = null,
     private val shouldForwardToThirdParties: () -> Boolean = { false },
-    private val customFirstPartyDownloadDialog:
-        ((Filename, ContentSize, PositiveActionCallback, NegativeActionCallback) -> Unit)? = null,
-    private val customThirdPartyDownloadDialog:
-        ((ThirdPartyDownloaderApps, ThirdPartyDownloaderAppChosenCallback, NegativeActionCallback) -> Unit)? = null,
 ) : LifecycleAwareFeature, PermissionsFeature {
 
     var onDownloadStopped: onDownloadStopped
@@ -206,45 +161,16 @@ class DownloadsFeature(
         val shouldShowAppDownloaderDialog = shouldForwardToThirdParties() && apps.size > 1
 
         return if (shouldShowAppDownloaderDialog) {
-            when (customThirdPartyDownloadDialog) {
-                null -> showAppDownloaderDialog(tab, download, apps)
-                else -> customThirdPartyDownloadDialog.invoke(
-                    ThirdPartyDownloaderApps(apps),
-                    ThirdPartyDownloaderAppChosenCallback {
-                        onDownloaderAppSelected(it, tab, download)
-                    },
-                    NegativeActionCallback {
-                        useCases.cancelDownloadRequest.invoke(tab.id, download.id)
-                    },
-                )
-            }
-
+            showAppDownloaderDialog(tab, download, apps)
             false
         } else {
             if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
-                when {
-                    customFirstPartyDownloadDialog != null && !download.skipConfirmation -> {
-                        customFirstPartyDownloadDialog.invoke(
-                            Filename(download.realFilenameOrGuessed),
-                            ContentSize(download.contentLength ?: 0),
-                            PositiveActionCallback {
-                                startDownload(download)
-                                useCases.consumeDownload.invoke(tab.id, download.id)
-                            },
-                            NegativeActionCallback {
-                                useCases.cancelDownloadRequest.invoke(tab.id, download.id)
-                            },
-                        )
-                        false
-                    }
-                    fragmentManager != null && !download.skipConfirmation -> {
-                        showDownloadDialog(tab, download)
-                        false
-                    }
-                    else -> {
-                        useCases.consumeDownload(tab.id, download.id)
-                        startDownload(download)
-                    }
+                if (fragmentManager != null && !download.skipConfirmation) {
+                    showDownloadDialog(tab, download)
+                    false
+                } else {
+                    useCases.consumeDownload(tab.id, download.id)
+                    startDownload(download)
                 }
             } else {
                 onNeedToRequestPermissions(downloadManager.permissions)
@@ -340,7 +266,25 @@ class DownloadsFeature(
     ) {
         appChooserDialog.setApps(apps)
         appChooserDialog.onAppSelected = { app ->
-            onDownloaderAppSelected(app, tab, download)
+            if (app.packageName == applicationContext.packageName) {
+                if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
+                    startDownload(download)
+                    useCases.consumeDownload(tab.id, download.id)
+                } else {
+                    onNeedToRequestPermissions(downloadManager.permissions)
+                }
+            } else {
+                try {
+                    applicationContext.startActivity(app.toIntent())
+                } catch (error: ActivityNotFoundException) {
+                    val errorMessage = applicationContext.getString(
+                        R.string.mozac_feature_downloads_unable_to_open_third_party_app,
+                        app.name,
+                    )
+                    Toast.makeText(applicationContext, errorMessage, Toast.LENGTH_SHORT).show()
+                }
+                useCases.consumeDownload(tab.id, download.id)
+            }
         }
 
         appChooserDialog.onDismiss = {
@@ -352,29 +296,6 @@ class DownloadsFeature(
         }
     }
 
-    @VisibleForTesting
-    internal fun onDownloaderAppSelected(app: DownloaderApp, tab: SessionState, download: DownloadState) {
-        if (app.packageName == applicationContext.packageName) {
-            if (applicationContext.isPermissionGranted(downloadManager.permissions.asIterable())) {
-                startDownload(download)
-                useCases.consumeDownload(tab.id, download.id)
-            } else {
-                onNeedToRequestPermissions(downloadManager.permissions)
-            }
-        } else {
-            try {
-                applicationContext.startActivity(app.toIntent())
-            } catch (error: ActivityNotFoundException) {
-                val errorMessage = applicationContext.getString(
-                    R.string.mozac_feature_downloads_unable_to_open_third_party_app,
-                    app.name,
-                )
-                Toast.makeText(applicationContext, errorMessage, Toast.LENGTH_SHORT).show()
-            }
-            useCases.consumeDownload(tab.id, download.id)
-        }
-    }
-
     private fun getAppDownloaderDialog() = findPreviousAppDownloaderDialogFragment()
         ?: DownloadAppChooserDialog.newInstance(
             promptsStyling?.gravity,
@@ -445,8 +366,7 @@ class DownloadsFeature(
 
     private val ActivityInfo.identifier: String get() = packageName + name
 
-    @VisibleForTesting
-    internal fun DownloaderApp.toIntent(): Intent {
+    private fun DownloaderApp.toIntent(): Intent {
         return Intent(Intent.ACTION_VIEW).apply {
             setDataAndTypeAndNormalize(url.toUri(), contentType)
             flags = Intent.FLAG_ACTIVITY_NEW_TASK
diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ext/DownloadState.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ext/DownloadState.kt
index 460b834dce52..239466803e62 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ext/DownloadState.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ext/DownloadState.kt
@@ -47,6 +47,3 @@ internal fun DownloadState.withResponse(headers: Headers, stream: InputStream?):
         contentLength = contentLength ?: headers[CONTENT_LENGTH]?.toLongOrNull(),
     )
 }
-
-internal val DownloadState.realFilenameOrGuessed
-    get() = fileName ?: DownloadUtils.guessFileName(null, destinationDirectory, url, contentType)
diff --git a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
index 5be32f71b386..e60a0938162c 100644
--- a/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
+++ b/android-components/components/feature/downloads/src/main/java/mozilla/components/feature/downloads/ui/DownloaderAppAdapter.kt
@@ -16,7 +16,7 @@ import mozilla.components.feature.downloads.R
 /**
  * An adapter for displaying the applications that can perform downloads.
  */
-class DownloaderAppAdapter(
+internal class DownloaderAppAdapter(
     context: Context,
     private val apps: List<DownloaderApp>,
     val onAppSelected: ((DownloaderApp) -> Unit),
@@ -49,14 +49,11 @@ class DownloaderAppAdapter(
 /**
  * View holder for a [DownloaderApp] item.
  */
-class DownloaderAppViewHolder(
+internal class DownloaderAppViewHolder(
     itemView: View,
     val nameLabel: TextView,
     val iconImage: ImageView,
 ) : RecyclerView.ViewHolder(itemView) {
-    /**
-     * Show a certain downloader application in the current View.
-     */
     fun bind(app: DownloaderApp, onAppSelected: ((DownloaderApp) -> Unit)) {
         itemView.app = app
         itemView.setOnClickListener {
diff --git a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt b/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
index 58c89930cb5a..86ce40dc7ede 100644
--- a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
+++ b/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/DownloadsFeatureTest.kt
@@ -8,7 +8,6 @@ import android.Manifest.permission.INTERNET
 import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
 import android.content.ActivityNotFoundException
 import android.content.Context
-import android.content.Intent
 import android.content.pm.ActivityInfo
 import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
@@ -30,7 +29,6 @@ import mozilla.components.feature.downloads.manager.DownloadManager
 import mozilla.components.feature.downloads.ui.DownloadAppChooserDialog
 import mozilla.components.feature.downloads.ui.DownloaderApp
 import mozilla.components.support.test.any
-import mozilla.components.support.test.argumentCaptor
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.ext.joinBlocking
 import mozilla.components.support.test.libstate.ext.waitUntilIdle
@@ -653,93 +651,6 @@ class DownloadsFeatureTest {
         verify(feature).showAppDownloaderDialog(any(), any(), any(), any())
     }
 
-    @Test
-    fun `GIVEN download should not be forwarded to third party apps but to a custom delegate WHEN processing a download request THEN forward it to the delegate`() {
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val usecases: DownloadsUseCases = mock()
-        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
-        val cancelDownloadUseCase: CancelDownloadRequestUseCase = mock()
-        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
-        doReturn(cancelDownloadUseCase).`when`(usecases).cancelDownloadRequest
-        val downloadManager: DownloadManager = mock()
-        var delegateFilename = ""
-        var delegateContentSize: Long = -1
-        var delegatePositiveActionCallback: (() -> Unit)? = null
-        var delegateNegativeActionCallback: (() -> Unit)? = null
-        grantPermissions()
-        doReturn(arrayOf(INTERNET, WRITE_EXTERNAL_STORAGE)).`when`(downloadManager).permissions
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = testContext,
-                store = mock(),
-                useCases = usecases,
-                downloadManager = downloadManager,
-                shouldForwardToThirdParties = { true },
-                customFirstPartyDownloadDialog = { filename, contentSize, positiveActionCallback, negativeActionCallback ->
-                    delegateFilename = filename.value
-                    delegateContentSize = contentSize.value
-                    delegatePositiveActionCallback = positiveActionCallback.value
-                    delegateNegativeActionCallback = negativeActionCallback.value
-                },
-            ),
-        )
-
-        feature.processDownload(tab, download)
-
-        assertEquals("file.txt", delegateFilename)
-        assertEquals(0, delegateContentSize)
-        assertNotNull(delegatePositiveActionCallback)
-        delegatePositiveActionCallback?.invoke()
-        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
-        assertNotNull(delegateNegativeActionCallback)
-        delegateNegativeActionCallback?.invoke()
-        verify(cancelDownloadUseCase).invoke(tab.id, download.id)
-    }
-
-    @Test
-    fun `GIVEN download should be forwarded to third party apps and a custom delegate is set WHEN processing a download request THEN forward it to the delegate`() {
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val usecases: DownloadsUseCases = mock()
-        val cancelDownloadUseCase: CancelDownloadRequestUseCase = mock()
-        doReturn(cancelDownloadUseCase).`when`(usecases).cancelDownloadRequest
-        val downloadManager: DownloadManager = mock()
-        var delegateDownloaderApps: List<DownloaderApp> = emptyList()
-        var delegateChosenAppCallback: ((DownloaderApp) -> Unit)? = null
-        var delegateNegativeActionCallback: (() -> Unit)? = null
-        val ourApp = mock<DownloaderApp>()
-        val anotherApp = mock<DownloaderApp>()
-        grantPermissions()
-        doReturn(arrayOf(INTERNET, WRITE_EXTERNAL_STORAGE)).`when`(downloadManager).permissions
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = testContext,
-                store = mock(),
-                useCases = usecases,
-                downloadManager = downloadManager,
-                shouldForwardToThirdParties = { true },
-                customThirdPartyDownloadDialog = { apps, chosenAppCallback, dismissCallback ->
-                    delegateDownloaderApps = apps.value
-                    delegateChosenAppCallback = chosenAppCallback.value
-                    delegateNegativeActionCallback = dismissCallback.value
-                },
-            ),
-        )
-        doReturn(listOf(ourApp, anotherApp)).`when`(feature).getDownloaderApps(testContext, download)
-        doNothing().`when`(feature).onDownloaderAppSelected(anotherApp, tab, download)
-
-        feature.processDownload(tab, download)
-
-        assertEquals(listOf(ourApp, anotherApp), delegateDownloaderApps)
-        assertNotNull(delegateChosenAppCallback)
-        delegateChosenAppCallback?.invoke(anotherApp)
-        verify(feature).onDownloaderAppSelected(anotherApp, tab, download)
-        assertNotNull(delegateNegativeActionCallback)
-        delegateNegativeActionCallback?.invoke()
-        verify(cancelDownloadUseCase).invoke(tab.id, download.id)
-    }
-
     @Test
     fun `when url is data url return only our app as downloader app`() {
         val context = mock<Context>()
@@ -919,137 +830,6 @@ class DownloadsFeatureTest {
         verify(spyContext, times(0)).startActivity(any())
     }
 
-    @Test
-    fun `GIVEN permissions are granted WHEN our app is selected for download THEN perform the download`() {
-        val spyContext = spy(testContext)
-        val usecases: DownloadsUseCases = mock()
-        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
-        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val ourApp = DownloaderApp(name = "app", packageName = testContext.packageName, resolver = mock(), activityName = "", url = "", contentType = null)
-        var wasPermissionsRequested = false
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = testContext,
-                store = mock(),
-                useCases = usecases,
-                onNeedToRequestPermissions = { wasPermissionsRequested = true },
-            ),
-        )
-        doReturn(false).`when`(feature).startDownload(any())
-
-        grantPermissions()
-        feature.onDownloaderAppSelected(ourApp, tab, download)
-
-        verify(feature).startDownload(download)
-        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
-        assertFalse(wasPermissionsRequested)
-        verify(spyContext, never()).startActivity(any())
-    }
-
-    @Test
-    fun `GIVEN permissions are not granted WHEN our app is selected for download THEN request the needed permissions`() {
-        val spyContext = spy(testContext)
-        val usecases: DownloadsUseCases = mock()
-        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
-        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val ourApp = DownloaderApp(name = "app", packageName = testContext.packageName, resolver = mock(), activityName = "", url = "", contentType = null)
-        var wasPermissionsRequested = false
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = testContext,
-                store = mock(),
-                useCases = usecases,
-                onNeedToRequestPermissions = { wasPermissionsRequested = true },
-            ),
-        )
-
-        feature.onDownloaderAppSelected(ourApp, tab, download)
-
-        verify(feature, never()).startDownload(any())
-        verify(consumeDownloadUseCase, never()).invoke(anyString(), anyString())
-        assertTrue(wasPermissionsRequested)
-        verify(spyContext, never()).startActivity(any())
-    }
-
-    @Test
-    fun `GIVEN a download WHEN a 3rd party app is selected THEN delegate download to it`() {
-        val spyContext = spy(testContext)
-        val usecases: DownloadsUseCases = mock()
-        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
-        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val anotherApp = DownloaderApp(
-            name = "app",
-            packageName = "test",
-            resolver = mock(),
-            activityName = "",
-            url = download.url,
-            contentType = null,
-        )
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = spyContext,
-                store = mock(),
-                useCases = usecases,
-            ),
-        )
-        val intentArgumentCaptor = argumentCaptor<Intent>()
-        val expectedIntent = with(feature) { anotherApp.toIntent() }
-
-        feature.onDownloaderAppSelected(anotherApp, tab, download)
-
-        verify(spyContext).startActivity(intentArgumentCaptor.capture())
-        assertEquals(expectedIntent.toUri(0), intentArgumentCaptor.value.toUri(0))
-        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
-        verify(feature, never()).startDownload(any())
-        assertNull(ShadowToast.getTextOfLatestToast())
-    }
-
-    @Test
-    fun `GIVEN a download WHEN a 3rd party app is selected and the download fails THEN show a warning toast and consume the download`() {
-        val spyContext = spy(testContext)
-        val usecases: DownloadsUseCases = mock()
-        val consumeDownloadUseCase: ConsumeDownloadUseCase = mock()
-        doReturn(consumeDownloadUseCase).`when`(usecases).consumeDownload
-        val tab = createTab("https://www.mozilla.org", id = "test-tab")
-        val download = DownloadState(url = "https://www.mozilla.org/file.txt", sessionId = "test-tab", id = "test")
-        val anotherApp = DownloaderApp(
-            name = "app",
-            packageName = "test",
-            resolver = mock(),
-            activityName = "",
-            url = download.url,
-            contentType = null,
-        )
-        val feature = spy(
-            DownloadsFeature(
-                applicationContext = spyContext,
-                store = mock(),
-                useCases = usecases,
-            ),
-        )
-        val expectedWarningText = testContext.getString(
-            R.string.mozac_feature_downloads_unable_to_open_third_party_app,
-            anotherApp.name,
-        )
-        val intentArgumentCaptor = argumentCaptor<Intent>()
-        val expectedIntent = with(feature) { anotherApp.toIntent() }
-        doThrow(ActivityNotFoundException()).`when`(spyContext).startActivity(any())
-
-        feature.onDownloaderAppSelected(anotherApp, tab, download)
-
-        verify(spyContext).startActivity(intentArgumentCaptor.capture())
-        assertEquals(expectedIntent.toUri(0), intentArgumentCaptor.value.toUri(0))
-        verify(consumeDownloadUseCase).invoke(tab.id, download.id)
-        verify(feature, never()).startDownload(any())
-        assertEquals(expectedWarningText, ShadowToast.getTextOfLatestToast())
-    }
-
     @Test
     fun `when an app third party is selected for downloading we MUST forward the download`() {
         val spyContext = spy(testContext)
diff --git a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/ext/DownloadStateKtTest.kt b/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/ext/DownloadStateKtTest.kt
deleted file mode 100644
index 10364fbcdd2a..000000000000
--- a/android-components/components/feature/downloads/src/test/java/mozilla/components/feature/downloads/ext/DownloadStateKtTest.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.feature.downloads.ext
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.state.state.content.DownloadState
-import mozilla.components.support.utils.DownloadUtils
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNotEquals
-import org.junit.Test
-import org.junit.runner.RunWith
-
-@RunWith(AndroidJUnit4::class)
-class DownloadStateKtTest {
-    @Test
-    fun `GIVEN a download filename is unkwnown WHEN requested with a guessing fallback THEN return a guessed canonical filename`() {
-        val download = DownloadState(
-            url = "url",
-            fileName = null,
-        )
-        val expectedName = with(download) {
-            DownloadUtils.guessFileName(null, destinationDirectory, url, contentType)
-        }
-
-        val result = download.realFilenameOrGuessed
-
-        assertEquals(expectedName, result)
-    }
-
-    @Test
-    fun `GIVEN a download filename is available WHEN requested with a guessing fallback THEN return the available filename`() {
-        val download = DownloadState(
-            url = "http://example.com/file.jpg",
-            fileName = "test",
-            contentType = "image/jpeg",
-        )
-        val guessedName = with(download) {
-            DownloadUtils.guessFileName(null, destinationDirectory, url, contentType)
-        }
-
-        val result = download.realFilenameOrGuessed
-
-        assertEquals("test", result)
-        assertNotEquals(guessedName, result)
-    }
-}
diff --git a/docs/changelog.md b/docs/changelog.md
index 50b0e3f61c44..b5bc6ae52c67 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -14,7 +14,7 @@ permalink: /changelog/
 
 * **feature-downloads**:
   * üåüÔ∏è `DownloadsFeature` now allows passing a download dialog delegate for 1st party downloads through a new `customDownloadDialog` parameter.
-  * üåü `DownloadsFeature` now allows passing a download dialog delegate for 3rd party downloads through a new `customThirdPartyDownloadDialog` parameter.
+
 
 * **feature-media**
   * üöí Bug fixed [bug #1802620](https://bugzilla.mozilla.org/show_bug.cgi?id=1802620). Handles `ForegroundServiceStartNotAllowedException`.
