diff --git a/focus-android/app/src/main/java/org/mozilla/focus/autocomplete/UrlAutoCompleteFilter.kt b/focus-android/app/src/main/java/org/mozilla/focus/autocomplete/UrlAutoCompleteFilter.kt
index 7c3565d5c83d..bfe25f3979dd 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/autocomplete/UrlAutoCompleteFilter.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/autocomplete/UrlAutoCompleteFilter.kt
@@ -13,6 +13,7 @@ import kotlinx.coroutines.experimental.launch
 import org.mozilla.focus.locale.Locales
 import org.mozilla.focus.utils.Settings
 import org.mozilla.focus.widget.InlineAutocompleteEditText
+import org.mozilla.focus.widget.InlineAutocompleteEditText.AutocompleteResult
 import java.io.IOException
 import java.util.*
 import kotlin.collections.LinkedHashSet
@@ -22,6 +23,11 @@ class UrlAutoCompleteFilter : InlineAutocompleteEditText.OnFilterListener {
         private val LOG_TAG = "UrlAutoCompleteFilter"
     }
 
+    object AutocompleteSource {
+        const val DEFAULT_LIST = "default"
+        const val CUSTOM_LIST = "custom"
+    }
+
     private var settings : Settings? = null
 
     private var customDomains : List<String> = emptyList()
@@ -39,7 +45,10 @@ class UrlAutoCompleteFilter : InlineAutocompleteEditText.OnFilterListener {
             if (it.shouldAutocompleteFromCustomDomainList()) {
                 val autocomplete = tryToAutocomplete(searchText, customDomains)
                 if (autocomplete != null) {
-                    view.onAutocomplete(prepareAutocompleteResult(rawSearchText, autocomplete))
+                    view.onAutocomplete(prepareAutocompleteResult(
+                            rawSearchText,
+                            autocomplete,
+                            AutocompleteSource.CUSTOM_LIST))
                     return
                 }
             }
@@ -47,11 +56,16 @@ class UrlAutoCompleteFilter : InlineAutocompleteEditText.OnFilterListener {
             if (it.shouldAutocompleteFromShippedDomainList()) {
                 val autocomplete = tryToAutocomplete(searchText, preInstalledDomains)
                 if (autocomplete != null) {
-                    view.onAutocomplete(prepareAutocompleteResult(rawSearchText, autocomplete))
+                    view.onAutocomplete(prepareAutocompleteResult(
+                            rawSearchText,
+                            autocomplete,
+                            AutocompleteSource.DEFAULT_LIST))
                     return
                 }
             }
         }
+
+        view.onAutocomplete(AutocompleteResult.emptyResult())
     }
 
     private fun tryToAutocomplete(searchText: String, domains: List<String>): String? {
@@ -134,6 +148,12 @@ class UrlAutoCompleteFilter : InlineAutocompleteEditText.OnFilterListener {
      * doesn't exactly match searchText (ie. if casing differs). It's simplest to just build a suggestion
      * that exactly matches the search text - which is what this method is for:
      */
-    private fun prepareAutocompleteResult(rawSearchText: String, lowerCaseResult: String) =
-            rawSearchText + lowerCaseResult.substring(rawSearchText.length)
+    private fun prepareAutocompleteResult(
+            rawSearchText: String,
+            lowerCaseResult: String,
+            source: String
+    ) =
+            AutocompleteResult(
+                rawSearchText + lowerCaseResult.substring(rawSearchText.length),
+                source)
 }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/InlineAutocompleteEditText.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/InlineAutocompleteEditText.java
index 0103588c499e..e995772251c3 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/widget/InlineAutocompleteEditText.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/InlineAutocompleteEditText.java
@@ -8,6 +8,7 @@
 import android.content.Context;
 import android.graphics.Rect;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.v4.content.ContextCompat;
 import android.text.Editable;
 import android.text.NoCopySpan;
@@ -49,6 +50,40 @@ public interface OnTextChangeListener {
         void onTextChange(String originalText, String autocompleteText);
     }
 
+    public static class AutocompleteResult {
+        public static AutocompleteResult emptyResult() {
+            return new AutocompleteResult(null, null);
+        }
+
+        public final String text;
+        public final String source;
+
+        public AutocompleteResult(String text, String source) {
+            this.text = text;
+            this.source = source;
+        }
+
+        public boolean isEmpty() {
+            return text == null;
+        }
+
+        public String getText() {
+            return text;
+        }
+
+        public String getSource() {
+            return source;
+        }
+
+        public int getLength() {
+            return text.length();
+        }
+
+        public boolean startsWith(String text) {
+            return this.text.startsWith(text);
+        }
+    }
+
     private static final String LOGTAG = "GeckoToolbarEditText";
     private static final NoCopySpan AUTOCOMPLETE_SPAN = new NoCopySpan.Concrete();
 
@@ -60,7 +95,7 @@ public interface OnTextChangeListener {
     private OnTextChangeListener mTextChangeListener;
 
     // The previous autocomplete result returned to us
-    private String mAutoCompleteResult = "";
+    private AutocompleteResult mAutoCompleteResult = AutocompleteResult.emptyResult();
     // Length of the user-typed portion of the result
     private int mAutoCompletePrefixLength;
     // If text change is due to us setting autocomplete
@@ -182,7 +217,7 @@ private void resetAutocompleteState() {
                         ContextCompat.getColor(getContext(), R.color.colorAccent))
         };
 
-        mAutoCompleteResult = "";
+        mAutoCompleteResult = AutocompleteResult.emptyResult();
 
         // Pretend we already autocompleted the existing text,
         // so that actions like backspacing don't trigger autocompletion.
@@ -231,7 +266,7 @@ private boolean removeAutocomplete(final Editable text) {
 
         // Keep mAutoCompletePrefixLength the same because the prefix has not changed.
         // Clear mAutoCompleteResult to make sure we get fresh autocomplete text next time.
-        mAutoCompleteResult = "";
+        mAutoCompleteResult = AutocompleteResult.emptyResult();
 
         // Reshow the cursor.
         setCursorVisible(true);
@@ -280,21 +315,21 @@ private boolean commitAutocomplete(final Editable text) {
      *
      * @param result Result URI to be turned into autocomplete text
      */
-    public final void onAutocomplete(final String result) {
+    public final void onAutocomplete(final AutocompleteResult result) {
         // If mDiscardAutoCompleteResult is true, we temporarily disabled
         // autocomplete (due to backspacing, etc.) and we should bail early.
         if (mDiscardAutoCompleteResult) {
             return;
         }
 
-        if (!isEnabled() || result == null) {
-            mAutoCompleteResult = "";
+        if (!isEnabled() || result == null || result.isEmpty()) {
+            mAutoCompleteResult = AutocompleteResult.emptyResult();
             return;
         }
 
         final Editable text = getText();
         final int textLength = text.length();
-        final int resultLength = result.length();
+        final int resultLength = result.getLength();
         final int autoCompleteStart = text.getSpanStart(AUTOCOMPLETE_SPAN);
         mAutoCompleteResult = result;
 
@@ -303,7 +338,7 @@ public final void onAutocomplete(final String result) {
 
             // If the result and the current text don't have the same prefixes,
             // the result is stale and we should wait for the another result to come in.
-            if (!TextUtils.regionMatches(result, 0, text, 0, autoCompleteStart)) {
+            if (!TextUtils.regionMatches(result.getText(), 0, text, 0, autoCompleteStart)) {
                 return;
             }
 
@@ -311,7 +346,7 @@ public final void onAutocomplete(final String result) {
 
             // Replace the existing autocomplete text with new one.
             // replace() preserves the autocomplete spans that we set before.
-            text.replace(autoCompleteStart, textLength, result, autoCompleteStart, resultLength);
+            text.replace(autoCompleteStart, textLength, result.getText(), autoCompleteStart, resultLength);
 
             // Reshow the cursor if there is no longer any autocomplete text.
             if (autoCompleteStart == resultLength) {
@@ -326,7 +361,7 @@ public final void onAutocomplete(final String result) {
             // If the result prefix doesn't match the current text,
             // the result is stale and we should wait for the another result to come in.
             if (resultLength <= textLength ||
-                    !TextUtils.regionMatches(result, 0, text, 0, textLength)) {
+                    !TextUtils.regionMatches(result.getText(), 0, text, 0, textLength)) {
                 return;
             }
 
@@ -356,7 +391,7 @@ public final void onAutocomplete(final String result) {
             beginSettingAutocomplete();
 
             // First add trailing text.
-            text.append(result, textLength, resultLength);
+            text.append(result.getText(), textLength, resultLength);
 
             // Restore selection/composing spans.
             for (int i = 0; i < spans.length; i++) {
