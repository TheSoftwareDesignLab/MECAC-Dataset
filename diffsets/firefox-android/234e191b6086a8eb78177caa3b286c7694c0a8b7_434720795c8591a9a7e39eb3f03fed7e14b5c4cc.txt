diff --git a/android-components/buildSrc/src/main/java/Dependencies.kt b/android-components/buildSrc/src/main/java/Dependencies.kt
index fd71c35f64c7..9024222d52e9 100644
--- a/android-components/buildSrc/src/main/java/Dependencies.kt
+++ b/android-components/buildSrc/src/main/java/Dependencies.kt
@@ -16,6 +16,7 @@ private object Versions {
     const val support_libraries = "28.0.0"
     const val constraint_layout = "1.1.2"
     const val workmanager = "1.0.0-alpha09"
+    const val lifecycle = "1.1.1"
 
     const val dokka = "0.9.16"
     const val android_gradle_plugin = "3.1.4"
@@ -56,6 +57,7 @@ object Dependencies {
     const val support_compat = "com.android.support:support-compat:${Versions.support_libraries}"
 
     const val arch_workmanager = "android.arch.work:work-runtime:${Versions.workmanager}"
+    const val arch_lifecycle = "android.arch.lifecycle:extensions:${Versions.lifecycle}"
 
     const val tools_dokka = "org.jetbrains.dokka:dokka-android-gradle-plugin:${Versions.dokka}"
     const val tools_androidgradle = "com.android.tools.build:gradle:${Versions.android_gradle_plugin}"
diff --git a/android-components/components/browser/session/build.gradle b/android-components/components/browser/session/build.gradle
index 9f56931b0254..43cedaa96989 100644
--- a/android-components/components/browser/session/build.gradle
+++ b/android-components/components/browser/session/build.gradle
@@ -27,7 +27,10 @@ dependencies {
     implementation project(':support-ktx')
 
     implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
+
     implementation Dependencies.support_customtabs
+    implementation Dependencies.arch_lifecycle
 
     // We expose this as API because we are using Observable in our public API and do not want every
     // consumer to have to manually import "utils".
diff --git a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/SessionManager.kt b/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/SessionManager.kt
index e7ce84225615..bd53e296a864 100644
--- a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/SessionManager.kt
+++ b/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/SessionManager.kt
@@ -6,8 +6,6 @@ package mozilla.components.browser.session
 
 import android.support.annotation.GuardedBy
 import mozilla.components.browser.session.engine.EngineObserver
-import mozilla.components.browser.session.storage.SessionWithState
-import mozilla.components.browser.session.storage.SessionsSnapshot
 import mozilla.components.concept.engine.Engine
 import mozilla.components.concept.engine.EngineSession
 import mozilla.components.support.base.observer.Observable
@@ -38,11 +36,11 @@ class SessionManager(
      * Produces a snapshot of this manager's state, suitable for restoring via [SessionManager.restore].
      * Only regular sessions are included in the snapshot. Private and Custom Tab sessions are omitted.
      *
-     * @return [SessionsSnapshot] or null if no sessions are present.
+     * @return [Snapshot] or null if no sessions are present.
      */
-    fun createSnapshot(): SessionsSnapshot? = synchronized(values) {
+    fun createSnapshot(): Snapshot? = synchronized(values) {
         if (values.isEmpty()) {
-            return@synchronized null
+            return null
         }
 
         // Filter out CustomTab and private sessions.
@@ -51,16 +49,16 @@ class SessionManager(
                 .filter { !it.isCustomTabSession() }
                 .filter { !it.private }
                 .map { session ->
-                    SessionWithState(
-                            session,
-                            session.engineSessionHolder.engineSession
+                    Snapshot.Item(
+                        session,
+                        session.engineSessionHolder.engineSession
                     )
                 }
                 .toList()
 
         // We might have some sessions (private, custom tab) but none we'd include in the snapshot.
         if (sessionStateTuples.isEmpty()) {
-            return@synchronized null
+            return null
         }
 
         // We need to find out the index of our selected session in the filtered list. If we have a
@@ -79,7 +77,7 @@ class SessionManager(
             "Selection index after filtering session must be valid"
         }
 
-        SessionsSnapshot(
+        Snapshot(
             sessions = sessionStateTuples,
             selectedSessionIndex = selectedIndexAfterFiltering
         )
@@ -176,17 +174,17 @@ class SessionManager(
     }
 
     /**
-     * Restores sessions from the provided [SessionsSnapshot].
+     * Restores sessions from the provided [Snapshot].
      * Notification behaviour is as follows:
      * - onSessionAdded notifications will not fire,
      * - onSessionSelected notification will fire exactly once if the snapshot isn't empty,
      * - once snapshot has been restored, and appropriate session has been selected, onSessionsRestored
      *   notification will fire.
      *
-     * @param snapshot A [SessionsSnapshot] which may be produced by [createSnapshot].
+     * @param snapshot A [Snapshot] which may be produced by [createSnapshot].
      * @throws IllegalArgumentException if an empty snapshot is passed in.
      */
-    fun restore(snapshot: SessionsSnapshot) = synchronized(values) {
+    fun restore(snapshot: Snapshot) = synchronized(values) {
         require(snapshot.sessions.isNotEmpty()) {
             "Snapshot must contain session state tuples"
         }
@@ -470,4 +468,16 @@ class SessionManager(
          */
         fun onAllSessionsRemoved() = Unit
     }
+
+    data class Snapshot(
+        val sessions: List<Item>,
+        val selectedSessionIndex: Int
+    ) {
+        fun isEmpty() = sessions.isEmpty()
+
+        data class Item(
+            val session: Session,
+            val engineSession: EngineSession? = null
+        )
+    }
 }
diff --git a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/DefaultSessionStorage.kt b/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/DefaultSessionStorage.kt
deleted file mode 100644
index ecfbf9b33728..000000000000
--- a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/DefaultSessionStorage.kt
+++ /dev/null
@@ -1,229 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.session.storage
-
-import android.content.Context
-import android.util.AtomicFile
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.session.Session.Source
-import mozilla.components.browser.session.SessionManager
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession
-import org.json.JSONArray
-import org.json.JSONException
-import org.json.JSONObject
-import java.io.File
-import java.io.FileOutputStream
-import java.io.IOException
-import java.util.concurrent.Executors
-import java.util.concurrent.ScheduledExecutorService
-import java.util.concurrent.ScheduledFuture
-import java.util.concurrent.TimeUnit
-
-const val SELECTED_SESSION_INDEX_KEY = "selectedSessionIndex"
-const val SESSION_STATE_TUPLES_KEY = "sessionStateTuples"
-
-const val SESSION_SOURCE_KEY = "source"
-const val SESSION_URL_KEY = "url"
-const val SESSION_UUID_KEY = "uuid"
-const val SESSION_PARENT_UUID_KEY = "parentUuid"
-
-const val SESSION_KEY = "session"
-const val ENGINE_SESSION_KEY = "engineSession"
-
-const val VERSION_KEY = "version"
-const val VERSION = 1
-const val FILE_NAME_FORMAT = "mozilla_components_session_storage_%s.json"
-
-/**
- * Default implementation of [SessionStorage] which persists browser and engine
- * session states to a JSON file.
- *
- * The JSON format used for persisting:
- * {
- *     "version": Int,
- *     "selectedSessionIndex": Int,
- *     "sessionStateTuples": [
- *         {
- *             "session": {},
- *             "engineSession": {}
- *         },
- *         ...
- *     ]
- * }
- */
-@Suppress("TooManyFunctions")
-class DefaultSessionStorage(
-    private val context: Context,
-    private val savePeriodically: Boolean = true,
-    private val saveIntervalInSeconds: Long = 300,
-    private val scheduler: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor()
-) : SessionStorage {
-    private var scheduledFuture: ScheduledFuture<*>? = null
-
-    override fun start(sessionManager: SessionManager) {
-        if (savePeriodically) {
-            scheduledFuture = scheduler.scheduleAtFixedRate(
-                { sessionManager.createSnapshot()?.let { persist(sessionManager.engine, it) } },
-                saveIntervalInSeconds,
-                saveIntervalInSeconds,
-                TimeUnit.SECONDS)
-        }
-    }
-
-    override fun stop() {
-        scheduledFuture?.cancel(false)
-    }
-
-    @Synchronized
-    override fun clear(engine: Engine) {
-        getFile(engine.name()).delete()
-    }
-
-    @Synchronized
-    @SuppressWarnings("ReturnCount")
-    override fun read(engine: Engine): SessionsSnapshot? {
-        val tuples: MutableList<SessionWithState> = mutableListOf()
-        var selectedSessionIndex = 0
-
-        try {
-            getFile(engine.name()).openRead().use {
-                val json = it.bufferedReader().use {
-                    it.readText()
-                }
-
-                val jsonRoot = JSONObject(json)
-                selectedSessionIndex = jsonRoot.getInt(SELECTED_SESSION_INDEX_KEY)
-                val sessionStateTuples = jsonRoot.getJSONArray(SESSION_STATE_TUPLES_KEY)
-                for (i in 0..(sessionStateTuples.length() - 1)) {
-                    val sessionStateTupleJson = sessionStateTuples.getJSONObject(i)
-                    val session = deserializeSession(sessionStateTupleJson.getJSONObject(SESSION_KEY))
-                    val engineSession = deserializeEngineSession(
-                        engine,
-                        sessionStateTupleJson.getJSONObject(ENGINE_SESSION_KEY)
-                    )
-                    tuples.add(SessionWithState(session, engineSession))
-                }
-            }
-        } catch (_: IOException) {
-            return null
-        } catch (_: JSONException) {
-            return null
-        }
-
-        if (tuples.isEmpty()) {
-            return null
-        }
-
-        // If we see an illegal selected index on disk, reset it to 0.
-        if (tuples.getOrNull(selectedSessionIndex) == null) {
-            selectedSessionIndex = 0
-        }
-
-        return SessionsSnapshot(
-            sessions = tuples,
-            selectedSessionIndex = selectedSessionIndex
-        )
-    }
-
-    @Synchronized
-    override fun persist(engine: Engine, snapshot: SessionsSnapshot): Boolean {
-        require(snapshot.sessions.isNotEmpty()) {
-            "SessionsSnapshot must not be empty"
-        }
-        requireNotNull(snapshot.sessions.getOrNull(snapshot.selectedSessionIndex)) {
-            "SessionSnapshot's selected index must be in bounds"
-        }
-
-        var file: AtomicFile? = null
-        var outputStream: FileOutputStream? = null
-
-        return try {
-            val json = JSONObject()
-            json.put(VERSION_KEY, VERSION)
-            json.put(SELECTED_SESSION_INDEX_KEY, snapshot.selectedSessionIndex)
-
-            val sessions = JSONArray()
-            snapshot.sessions.forEachIndexed { index, sessionWithState ->
-                val sessionJson = JSONObject()
-                sessionJson.put(SESSION_KEY, serializeSession(sessionWithState.session))
-                sessionJson.put(ENGINE_SESSION_KEY, serializeEngineSession(sessionWithState.engineSession))
-                sessions.put(index, sessionJson)
-            }
-            json.put(SESSION_STATE_TUPLES_KEY, sessions)
-
-            file = getFile(engine.name())
-            outputStream = file.startWrite()
-            outputStream.write(json.toString().toByteArray())
-            file.finishWrite(outputStream)
-            true
-        } catch (_: IOException) {
-            file?.failWrite(outputStream)
-            false
-        } catch (_: JSONException) {
-            file?.failWrite(outputStream)
-            false
-        }
-    }
-
-    internal fun getFile(engine: String): AtomicFile {
-        return AtomicFile(File(context.filesDir, String.format(FILE_NAME_FORMAT, engine).toLowerCase()))
-    }
-
-    @Throws(JSONException::class)
-    internal fun serializeSession(session: Session): JSONObject {
-        return JSONObject().apply {
-            put(SESSION_URL_KEY, session.url)
-            put(SESSION_SOURCE_KEY, session.source.name)
-            put(SESSION_UUID_KEY, session.id)
-            put(SESSION_PARENT_UUID_KEY, session.parentId ?: "")
-        }
-    }
-
-    @Throws(JSONException::class)
-    internal fun deserializeSession(json: JSONObject): Session {
-        val source = try {
-            Source.valueOf(json.getString(SESSION_SOURCE_KEY))
-        } catch (e: IllegalArgumentException) {
-            Source.NONE
-        }
-        val session = Session(
-                json.getString(SESSION_URL_KEY),
-                // Currently, snapshot cannot contain private sessions.
-                false,
-                source,
-                json.getString(SESSION_UUID_KEY)
-        )
-        session.parentId = json.getString(SESSION_PARENT_UUID_KEY).takeIf { it != "" }
-        return session
-    }
-
-    private fun serializeEngineSession(engineSession: EngineSession?): JSONObject {
-        if (engineSession == null) {
-            return JSONObject()
-        }
-        return JSONObject().apply {
-            engineSession.saveState().forEach { (k, v) -> if (shouldSerialize(v)) put(k, v) }
-        }
-    }
-
-    private fun deserializeEngineSession(engine: Engine, json: JSONObject): EngineSession {
-        return engine.createSession().apply {
-            val values = mutableMapOf<String, Any>()
-            json.keys().forEach { k -> values[k] = json[k] }
-            restoreState(values)
-        }
-    }
-
-    private fun shouldSerialize(value: Any): Boolean {
-        // For now we only persist primitive types
-        return when (value) {
-            is Number -> true
-            is Boolean -> true
-            is String -> true
-            else -> false
-        }
-    }
-}
diff --git a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/SessionStorage.kt b/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/SessionStorage.kt
index 5578b9cd36b7..e7a0fc8e6664 100644
--- a/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/SessionStorage.kt
+++ b/android-components/components/browser/session/src/main/java/mozilla/components/browser/session/storage/SessionStorage.kt
@@ -4,59 +4,438 @@
 
 package mozilla.components.browser.session.storage
 
+import android.arch.lifecycle.Lifecycle
+import android.arch.lifecycle.LifecycleObserver
+import android.arch.lifecycle.OnLifecycleEvent
+import android.arch.lifecycle.ProcessLifecycleOwner
+import android.content.Context
+import android.os.SystemClock
+import android.support.annotation.CheckResult
+import android.support.annotation.VisibleForTesting
+import android.support.annotation.WorkerThread
+import android.util.AtomicFile
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
+import mozilla.components.browser.session.SelectionAwareSessionObserver
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
 import mozilla.components.concept.engine.Engine
 import mozilla.components.concept.engine.EngineSession
+import mozilla.components.support.base.log.logger.Logger
+import org.json.JSONArray
+import org.json.JSONException
+import org.json.JSONObject
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+import java.util.concurrent.Executors
+import java.util.concurrent.ScheduledExecutorService
+import java.util.concurrent.ScheduledFuture
+import java.util.concurrent.TimeUnit
 
-data class SessionWithState(
-    val session: Session,
-    val engineSession: EngineSession? = null
-)
-data class SessionsSnapshot(
-    val sessions: List<SessionWithState>,
-    val selectedSessionIndex: Int
-)
+private const val STORE_FILE_NAME_FORMAT = "mozilla_components_session_storage_%s.json"
+
+// Current version of the format used [SessionStorage].
+private const val VERSION = 1
+
+// Minimum interval between saving states.
+private const val DEFAULT_INTERVAL_MILLISECONDS = 2000L
+
+private val sessionFileLock = Any()
 
 /**
- * Storage component for browser and engine sessions.
+ * Session storage for persisting the state of a [SessionManager] to disk (browser and engine session states).
  */
-interface SessionStorage {
+class SessionStorage(
+    private val context: Context,
+    private val engine: Engine
+) {
     /**
-     * Erases persisted [SessionsSnapshot] (if present) for a given [Engine].
+     * Reads the saved state from disk. Returns null if no state was found on disk or if reading the file failed.
      */
-    fun clear(engine: Engine)
+    fun restore(): SessionManager.Snapshot? {
+        return readSnapshotFromDisk(getFileForEngine(context, engine), engine)
+    }
 
     /**
-     * Persists the provided [SessionsSnapshot] for a given [Engine].
-     * [SessionsSnapshot] may be obtained using [SessionManager.createSnapshot].
-     * Throws if snapshot is empty or otherwise incoherent.
-     *
-     * @param engine the engine in which context to persist a snapshot.
-     * @param snapshot the snapshot of snapshot which are to be persisted.
-     * @return true if the snapshot was persisted, otherwise false.
+     * Clears the state saved on disk.
      */
-    @Throws(IllegalArgumentException::class)
-    fun persist(engine: Engine, snapshot: SessionsSnapshot): Boolean
+    fun clear() {
+        removeSnapshotFromDisk(context, engine)
+    }
 
     /**
-     * Returns the latest persisted sessions snapshot that may be used to read sessions.
-     * Resulting [SessionsSnapshot] may be restored via [SessionManager.restore].
-     *
-     * @param engine the engine for which to read the snapshot.
-     * @return snapshot of sessions to read, or null if it's empty or couldn't be read.
+     * Saves the given state to disk.
      */
-    fun read(engine: Engine): SessionsSnapshot?
+    @WorkerThread
+    fun save(snapshot: SessionManager.Snapshot): Boolean {
+        if (snapshot.isEmpty()) {
+            clear()
+            return true
+        }
+
+        return saveSnapshotToDisk(getFileForEngine(context, engine), snapshot)
+    }
 
     /**
-     * Starts persisting the state frequently and automatically.
+     * Starts configuring automatic saving of the state.
+     */
+    @CheckResult
+    fun autoSave(
+        sessionManager: SessionManager,
+        interval: Long = DEFAULT_INTERVAL_MILLISECONDS,
+        unit: TimeUnit = TimeUnit.MILLISECONDS
+    ): AutoSave {
+        return AutoSave(sessionManager, this, unit.toMillis(interval))
+    }
+}
+
+class AutoSave(
+    private val sessionManager: SessionManager,
+    private val sessionStorage: SessionStorage,
+    private val minimumIntervalMs: Long
+) {
+    internal val logger = Logger("SessionStorage/AutoSave")
+    internal var saveJob: Job? = null
+    private var lastSaveTimestamp: Long = now()
+
+    /**
+     * Saves the state periodically when the app is in the foreground.
      *
-     * @param sessionManager the session manager to persist from.
+     * @param interval The interval in which the state should be saved to disk.
+     * @param unit The time unit of the [interval] parameter.
      */
-    fun start(sessionManager: SessionManager)
+    fun periodicallyInForeground(
+        interval: Long = 300,
+        unit: TimeUnit = TimeUnit.SECONDS,
+        scheduler: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor(),
+        lifecycle: Lifecycle = ProcessLifecycleOwner.get().lifecycle
+    ): AutoSave {
+        lifecycle.addObserver(AutoSavePeriodically(this, scheduler, interval, unit))
+        return this
+    }
 
     /**
-     * Stops persisting the state automatically.
+     * Saves the state automatically when the app goes to the background.
+     */
+    fun whenGoingToBackground(
+        lifecycle: Lifecycle = ProcessLifecycleOwner.get().lifecycle
+    ): AutoSave {
+        lifecycle.addObserver(AutoSaveBackground(this))
+        return this
+    }
+
+    /**
+     * Saves the state automatically when the sessions change, e.g. sessions get added and removed.
+     */
+    fun whenSessionsChange(): AutoSave {
+        AutoSaveSessionChange(
+            this,
+            sessionManager
+        ).observeSelected()
+        return this
+    }
+
+    /**
+     * Triggers saving the current state to disk.
+     *
+     * This method will not schedule a new save job if a job is already in flight. Additionally it will obey the
+     * interval passed to [SessionStorage.autoSave]; job may get delayed.
+     *
+     * @param delaySave Whether to delay the save job to obey the interval passed to [SessionStorage.autoSave].
      */
-    fun stop()
+    @Synchronized
+    internal fun triggerSave(delaySave: Boolean = true): Job {
+        val currentJob = saveJob
+
+        if (currentJob != null && currentJob.isActive) {
+            logger.debug("Skipping save, other job already in flight")
+            return currentJob
+        }
+
+        val now = now()
+        val delayMs = lastSaveTimestamp + minimumIntervalMs - now
+        lastSaveTimestamp = now
+
+        GlobalScope.launch(Dispatchers.IO) {
+            if (delaySave && delayMs > 0) {
+                logger.debug("Delaying save (${delayMs}ms)")
+                delay(delayMs)
+            }
+
+            val start = now()
+
+            try {
+                val snapshot = sessionManager.createSnapshot()
+                if (snapshot != null) {
+                    sessionStorage.save(snapshot)
+                }
+            } finally {
+                val took = now() - start
+                logger.debug("Saved state to disk [${took}ms]")
+            }
+        }.also {
+            saveJob = it
+            return it
+        }
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal fun now() = SystemClock.elapsedRealtime()
+}
+
+/**
+ * [LifecycleObserver] to start/stop a task that saves the state at a periodic interval.
+ */
+private class AutoSavePeriodically(
+    private val autoSave: AutoSave,
+    private val scheduler: ScheduledExecutorService,
+    private val interval: Long,
+    private val unit: TimeUnit
+) : LifecycleObserver {
+    private var scheduledFuture: ScheduledFuture<*>? = null
+
+    @OnLifecycleEvent(Lifecycle.Event.ON_START)
+    fun start() {
+        scheduledFuture = scheduler.scheduleAtFixedRate(
+            {
+                autoSave.logger.info("Save: Periodic")
+                autoSave.triggerSave()
+            },
+            interval,
+            interval,
+            unit
+        )
+    }
+
+    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
+    fun stop() {
+        scheduledFuture?.cancel(false)
+    }
+}
+
+/**
+ * [LifecycleObserver] to save the state when the app goes to the background.
+ */
+private class AutoSaveBackground(
+    private val autoSave: AutoSave
+) : LifecycleObserver {
+    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
+    fun stop() {
+        autoSave.logger.info("Save: Background")
+
+        runBlocking {
+            // Since the app is going to the background and can get killed at any time, we do not want to delay saving
+            // the state to disk.
+            autoSave.triggerSave(delaySave = false).join()
+        }
+    }
+}
+
+/**
+ * [SelectionAwareSessionObserver] to save the state whenever sessions change.
+ */
+private class AutoSaveSessionChange(
+    private val autoSave: AutoSave,
+    sessionManager: SessionManager
+) : SelectionAwareSessionObserver(sessionManager) {
+    override fun onSessionSelected(session: Session) {
+        super.onSessionSelected(session)
+        autoSave.logger.info("Save: Session selected")
+        autoSave.triggerSave()
+    }
+
+    override fun onLoadingStateChanged(session: Session, loading: Boolean) {
+        if (!loading) {
+            autoSave.logger.info("Save: Load finished")
+            autoSave.triggerSave()
+        }
+    }
+
+    override fun onSessionAdded(session: Session) {
+        autoSave.logger.info("Save: Session added")
+        autoSave.triggerSave()
+    }
+
+    override fun onSessionRemoved(session: Session) {
+        autoSave.logger.info("Save: Session removed")
+        autoSave.triggerSave()
+    }
+}
+
+@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+@Suppress("ReturnCount")
+internal fun readSnapshotFromDisk(file: AtomicFile, engine: Engine): SessionManager.Snapshot? {
+    synchronized(sessionFileLock) {
+        val tuples: MutableList<SessionManager.Snapshot.Item> = mutableListOf()
+        var selectedSessionIndex = 0
+
+        try {
+            file.openRead().use {
+                val json = it.bufferedReader().use { reader -> reader.readText() }
+
+                val jsonRoot = JSONObject(json)
+                selectedSessionIndex = jsonRoot.getInt(Keys.SELECTED_SESSION_INDEX_KEY)
+                val sessionStateTuples = jsonRoot.getJSONArray(Keys.SESSION_STATE_TUPLES_KEY)
+                for (i in 0 until sessionStateTuples.length()) {
+                    val sessionStateTupleJson = sessionStateTuples.getJSONObject(i)
+                    val session = deserializeSession(sessionStateTupleJson.getJSONObject(Keys.SESSION_KEY))
+                    val engineSession = deserializeEngineSession(
+                        engine,
+                        sessionStateTupleJson.getJSONObject(Keys.ENGINE_SESSION_KEY)
+                    )
+                    tuples.add(
+                        SessionManager.Snapshot.Item(
+                            session,
+                            engineSession
+                        )
+                    )
+                }
+            }
+        } catch (_: IOException) {
+            return null
+        } catch (_: JSONException) {
+            return null
+        }
+
+        if (tuples.isEmpty()) {
+            return null
+        }
+
+        // If we see an illegal selected index on disk, reset it to 0.
+        if (tuples.getOrNull(selectedSessionIndex) == null) {
+            selectedSessionIndex = 0
+        }
+
+        return SessionManager.Snapshot(
+            sessions = tuples,
+            selectedSessionIndex = selectedSessionIndex
+        )
+    }
+}
+
+@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+internal fun saveSnapshotToDisk(file: AtomicFile, snapshot: SessionManager.Snapshot): Boolean {
+    require(snapshot.sessions.isNotEmpty()) {
+        "SessionsSnapshot must not be empty"
+    }
+    requireNotNull(snapshot.sessions.getOrNull(snapshot.selectedSessionIndex)) {
+        "SessionSnapshot's selected index must be in bounds"
+    }
+
+    synchronized(sessionFileLock) {
+        var outputStream: FileOutputStream? = null
+
+        return try {
+            val json = JSONObject()
+            json.put(Keys.VERSION_KEY, VERSION)
+            json.put(Keys.SELECTED_SESSION_INDEX_KEY, snapshot.selectedSessionIndex)
+
+            val sessions = JSONArray()
+            snapshot.sessions.forEachIndexed { index, sessionWithState ->
+                val sessionJson = JSONObject()
+                sessionJson.put(Keys.SESSION_KEY, serializeSession(sessionWithState.session))
+                sessionJson.put(Keys.ENGINE_SESSION_KEY, serializeEngineSession(sessionWithState.engineSession))
+                sessions.put(index, sessionJson)
+            }
+            json.put(Keys.SESSION_STATE_TUPLES_KEY, sessions)
+
+            outputStream = file.startWrite()
+            outputStream.write(json.toString().toByteArray())
+            file.finishWrite(outputStream)
+            true
+        } catch (_: IOException) {
+            file.failWrite(outputStream)
+            false
+        } catch (_: JSONException) {
+            file.failWrite(outputStream)
+            false
+        }
+    }
+}
+
+private fun removeSnapshotFromDisk(context: Context, engine: Engine) {
+    synchronized(sessionFileLock) {
+        getFileForEngine(context, engine).delete()
+    }
+}
+
+@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+internal fun getFileForEngine(context: Context, engine: Engine): AtomicFile {
+    return AtomicFile(File(context.filesDir, String.format(STORE_FILE_NAME_FORMAT, engine.name()).toLowerCase()))
+}
+
+@Throws(JSONException::class)
+private fun serializeSession(session: Session): JSONObject {
+    return JSONObject().apply {
+        put(Keys.SESSION_URL_KEY, session.url)
+        put(Keys.SESSION_SOURCE_KEY, session.source.name)
+        put(Keys.SESSION_UUID_KEY, session.id)
+        put(Keys.SESSION_PARENT_UUID_KEY, session.parentId ?: "")
+    }
+}
+
+@Throws(JSONException::class)
+@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+internal fun deserializeSession(json: JSONObject): Session {
+    val source = try {
+        Session.Source.valueOf(json.getString(Keys.SESSION_SOURCE_KEY))
+    } catch (e: IllegalArgumentException) {
+        Session.Source.NONE
+    }
+    val session = Session(
+        json.getString(Keys.SESSION_URL_KEY),
+        // Currently, snapshot cannot contain private sessions.
+        false,
+        source,
+        json.getString(Keys.SESSION_UUID_KEY)
+    )
+    session.parentId = json.getString(Keys.SESSION_PARENT_UUID_KEY).takeIf { it != "" }
+    return session
+}
+
+private fun serializeEngineSession(engineSession: EngineSession?): JSONObject {
+    if (engineSession == null) {
+        return JSONObject()
+    }
+    return JSONObject().apply {
+        engineSession.saveState().forEach { (k, v) -> if (shouldSerialize(v)) put(k, v) }
+    }
+}
+
+private fun deserializeEngineSession(engine: Engine, json: JSONObject): EngineSession {
+    return engine.createSession().apply {
+        val values = mutableMapOf<String, Any>()
+        json.keys().forEach { k -> values[k] = json[k] }
+        restoreState(values)
+    }
+}
+
+private fun shouldSerialize(value: Any): Boolean {
+    // For now we only persist primitive types
+    return when (value) {
+        is Number -> true
+        is Boolean -> true
+        is String -> true
+        else -> false
+    }
+}
+
+private object Keys {
+    const val SELECTED_SESSION_INDEX_KEY = "selectedSessionIndex"
+    const val SESSION_STATE_TUPLES_KEY = "sessionStateTuples"
+
+    const val SESSION_SOURCE_KEY = "source"
+    const val SESSION_URL_KEY = "url"
+    const val SESSION_UUID_KEY = "uuid"
+    const val SESSION_PARENT_UUID_KEY = "parentUuid"
+
+    const val SESSION_KEY = "session"
+    const val ENGINE_SESSION_KEY = "engineSession"
+
+    const val VERSION_KEY = "version"
 }
diff --git a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/SessionManagerTest.kt b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/SessionManagerTest.kt
index 299a3eeb2cb0..0dc234d176b5 100644
--- a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/SessionManagerTest.kt
+++ b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/SessionManagerTest.kt
@@ -5,8 +5,6 @@
 package mozilla.components.browser.session
 
 import android.graphics.Bitmap
-import mozilla.components.browser.session.storage.SessionWithState
-import mozilla.components.browser.session.storage.SessionsSnapshot
 import mozilla.components.browser.session.tab.CustomTabConfig
 import mozilla.components.concept.engine.Engine
 import mozilla.components.concept.engine.EngineSession
@@ -334,7 +332,7 @@ class SessionManagerTest {
     @Test(expected = IllegalArgumentException::class)
     fun `restore checks validity of a snapshot - empty`() {
         val manager = SessionManager(mock())
-        manager.restore(SessionsSnapshot(listOf(), selectedSessionIndex = 0))
+        manager.restore(SessionManager.Snapshot(listOf(), selectedSessionIndex = 0))
     }
 
     @Test
@@ -343,8 +341,8 @@ class SessionManagerTest {
 
         // Just one session in the snapshot.
         manager.restore(
-            SessionsSnapshot(
-                listOf(SessionWithState(session = Session("http://www.mozilla.org"))),
+            SessionManager.Snapshot(
+                listOf(SessionManager.Snapshot.Item(session = Session("http://www.mozilla.org"))),
                 selectedSessionIndex = 0
             )
         )
@@ -357,10 +355,13 @@ class SessionManagerTest {
         val engineSession = mock(EngineSession::class.java)
         `when`(engineSession.saveState()).thenReturn(engineSessionState)
 
-        val snapshot = SessionsSnapshot(
+        val snapshot = SessionManager.Snapshot(
             listOf(
-                SessionWithState(session = regularSession, engineSession = engineSession),
-                SessionWithState(session = Session("http://www.wikipedia.org"))
+                SessionManager.Snapshot.Item(
+                    session = regularSession,
+                    engineSession = engineSession
+                ),
+                SessionManager.Snapshot.Item(session = Session("http://www.wikipedia.org"))
             ),
             selectedSessionIndex = 0
         )
@@ -384,7 +385,11 @@ class SessionManagerTest {
 
         val session = Session("http://www.mozilla.org")
         // Snapshot with a single session.
-        manager.restore(SessionsSnapshot(listOf(SessionWithState(session)), 0))
+        manager.restore(SessionManager.Snapshot(listOf(
+            SessionManager.Snapshot.Item(
+                session
+            )
+        ), 0))
 
         verify(observer, times(1)).onSessionsRestored()
         verify(observer, never()).onSessionAdded(session)
@@ -396,8 +401,12 @@ class SessionManagerTest {
         val session2 = Session("http://www.firefox.com")
         val session3 = Session("http://www.wikipedia.org")
         // Snapshot with multiple sessions.
-        manager.restore(SessionsSnapshot(
-            listOf(SessionWithState(session2), SessionWithState(session3), SessionWithState(session)),
+        manager.restore(SessionManager.Snapshot(
+            listOf(
+                SessionManager.Snapshot.Item(session2),
+                SessionManager.Snapshot.Item(session3),
+                SessionManager.Snapshot.Item(session)
+            ),
             1
         ))
 
diff --git a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/engine/EngineSessionHolderTest.kt b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/engine/EngineSessionHolderTest.kt
index 29c07c75aeee..4a35ecc228b7 100644
--- a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/engine/EngineSessionHolderTest.kt
+++ b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/engine/EngineSessionHolderTest.kt
@@ -4,8 +4,8 @@
 
 package mozilla.components.browser.session.engine
 
-import junit.framework.Assert.assertTrue
 import mozilla.components.concept.engine.EngineSession
+import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.mockito.Mockito.mock
 import java.util.concurrent.CountDownLatch
@@ -17,7 +17,7 @@ class EngineSessionHolderTest {
     @Test
     fun `engine session holder changes are visible across threads`() {
         val engineSessionHolder = EngineSessionHolder()
-        var countDownLatch = CountDownLatch(1)
+        val countDownLatch = CountDownLatch(1)
 
         val executor = Executors.newScheduledThreadPool(2)
 
diff --git a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/DefaultSessionStorageTest.kt b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/DefaultSessionStorageTest.kt
deleted file mode 100644
index caf554857725..000000000000
--- a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/DefaultSessionStorageTest.kt
+++ /dev/null
@@ -1,297 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.session.storage
-
-import android.util.AtomicFile
-import mozilla.components.browser.session.Session
-import mozilla.components.browser.session.Session.Source
-import mozilla.components.browser.session.SessionManager
-import mozilla.components.concept.engine.Engine
-import mozilla.components.concept.engine.EngineSession
-import org.json.JSONException
-import org.json.JSONObject
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertTrue
-import org.junit.Assert.assertFalse
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.ArgumentMatchers
-import org.mockito.ArgumentMatchers.any
-import org.mockito.ArgumentMatchers.anyString
-import org.mockito.Mockito.`when`
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.doThrow
-import org.mockito.Mockito.mock
-import org.mockito.Mockito.never
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.verify
-import org.robolectric.RobolectricTestRunner
-import org.robolectric.RuntimeEnvironment
-import java.io.FileNotFoundException
-import java.io.IOException
-import java.util.concurrent.ScheduledExecutorService
-import java.util.concurrent.ScheduledFuture
-import java.util.concurrent.TimeUnit
-
-@RunWith(RobolectricTestRunner::class)
-class DefaultSessionStorageTest {
-
-    @Test
-    fun persistAndRestore() {
-        val session1 = Session("http://mozilla.org", id = "session1")
-        val session2 = Session("http://getpocket.com", id = "session2")
-        val session3 = Session("http://getpocket.com", id = "session3")
-        session3.parentId = "session1"
-
-        val engineSessionState = mutableMapOf("k0" to "v0", "k1" to 1, "k2" to true, "k3" to emptyList<Any>())
-
-        val engineSession = mock(EngineSession::class.java)
-        `when`(engineSession.saveState()).thenReturn(engineSessionState)
-
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-        `when`(engine.createSession()).thenReturn(mock(EngineSession::class.java))
-
-        // Engine session just for one of the sessions for simplicity.
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(
-                SessionWithState(session1, engineSession),
-                SessionWithState(session2),
-                SessionWithState(session3)
-            ),
-            selectedSessionIndex = 0
-        )
-
-        // Persist the snapshot
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application)
-        val persisted = storage.persist(engine, sessionsSnapshot)
-        assertTrue(persisted)
-
-        // Read it back
-        val restoredSnapshot = storage.read(engine)
-        assertNotNull(restoredSnapshot)
-        assertEquals(3, restoredSnapshot!!.sessions.size)
-        assertEquals(0, restoredSnapshot.selectedSessionIndex)
-
-        assertEquals(session1, restoredSnapshot.sessions[0].session)
-        assertEquals(session1.url, restoredSnapshot.sessions[0].session.url)
-        assertEquals(session1.id, restoredSnapshot.sessions[0].session.id)
-        assertNull(restoredSnapshot.sessions[0].session.parentId)
-
-        assertEquals(session2, restoredSnapshot.sessions[1].session)
-        assertEquals(session2.url, restoredSnapshot.sessions[1].session.url)
-        assertEquals(session2.id, restoredSnapshot.sessions[1].session.id)
-        assertNull(restoredSnapshot.sessions[1].session.parentId)
-
-        assertEquals(session3, restoredSnapshot.sessions[2].session)
-        assertEquals(session3.url, restoredSnapshot.sessions[2].session.url)
-        assertEquals(session3.id, restoredSnapshot.sessions[2].session.id)
-        assertEquals("session1", restoredSnapshot.sessions[2].session.parentId)
-
-        val restoredEngineSession = restoredSnapshot.sessions[0].engineSession
-        assertNotNull(restoredEngineSession)
-        verify(restoredEngineSession)!!.restoreState(engineSessionState.filter { it.key != "k3" })
-    }
-
-    @Test
-    fun persistAndClear() {
-        val session1 = Session("http://mozilla.org", id = "session1")
-        val session2 = Session("http://getpocket.com", id = "session2")
-
-        val engineSession = mock(EngineSession::class.java)
-
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-        `when`(engine.createSession()).thenReturn(mock(EngineSession::class.java))
-
-        // Engine session just for one of the sessions for simplicity.
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(SessionWithState(session1, engineSession), SessionWithState(session2)),
-            selectedSessionIndex = 0
-        )
-
-        // Persist the snapshot
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application)
-        val persisted = storage.persist(engine, sessionsSnapshot)
-        assertTrue(persisted)
-
-        storage.clear(engine)
-
-        // Read it back. Expect null, indicating empty.
-        val restoredSnapshot = storage.read(engine)
-        assertNull(restoredSnapshot)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun persistThrowsOnEmptySnapshot() {
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application)
-        storage.persist(engine, SessionsSnapshot(sessions = listOf(), selectedSessionIndex = 0))
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun persistThrowsOnIllegalSnapshot() {
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application)
-
-        val session = Session("http://mozilla.org")
-        val engineSession = mock(EngineSession::class.java)
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(SessionWithState(session, engineSession)),
-            selectedSessionIndex = 1
-        )
-        storage.persist(engine, sessionsSnapshot)
-    }
-
-    @Test
-    fun restoreReturnsNullOnIOException() {
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-
-        val context = spy(RuntimeEnvironment.application)
-        val storage = spy(DefaultSessionStorage(context))
-        val file = mock(AtomicFile::class.java)
-
-        doReturn(file).`when`(storage).getFile(anyString())
-        doThrow(FileNotFoundException::class.java).`when`(file).openRead()
-
-        assertNull(storage.read(engine))
-    }
-
-    @Test
-    fun restoreReturnsNullOnJSONException() {
-        val session = Session("http://mozilla.org")
-        val engineSession = mock(EngineSession::class.java)
-
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-        `when`(engine.createSession()).thenReturn(engineSession)
-
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(SessionWithState(session, engineSession)),
-            selectedSessionIndex = 0
-        )
-
-        val storage = spy(DefaultSessionStorage(RuntimeEnvironment.application))
-        val persisted = storage.persist(engine, sessionsSnapshot)
-        assertTrue(persisted)
-
-        doThrow(JSONException::class.java).`when`(storage).deserializeSession(anyJson())
-        assertNull(storage.read(engine))
-    }
-
-    @Test
-    fun persistReturnsFalseOnIOException() {
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-
-        val session = Session("http://mozilla.org")
-        val engineSession = mock(EngineSession::class.java)
-        val context = spy(RuntimeEnvironment.application)
-        val storage = spy(DefaultSessionStorage(context))
-        val file = mock(AtomicFile::class.java)
-
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(SessionWithState(session, engineSession)),
-            selectedSessionIndex = 0
-        )
-
-        doReturn(file).`when`(storage).getFile(anyString())
-        doThrow(IOException::class.java).`when`(file).startWrite()
-
-        assertFalse(storage.persist(engine, sessionsSnapshot))
-    }
-
-    @Test
-    fun persistReturnsFalseOnJSONException() {
-        val engine = mock(Engine::class.java)
-        `when`(engine.name()).thenReturn("gecko")
-
-        val session = Session("http://mozilla.org")
-        val engineSession = mock(EngineSession::class.java)
-        val context = spy(RuntimeEnvironment.application)
-        val storage = spy(DefaultSessionStorage(context))
-        val file = mock(AtomicFile::class.java)
-
-        val sessionsSnapshot = SessionsSnapshot(
-            sessions = listOf(SessionWithState(session, engineSession)),
-            selectedSessionIndex = 0
-        )
-
-        doReturn(file).`when`(storage).getFile(anyString())
-        doThrow(JSONException::class.java).`when`(storage).serializeSession(session)
-
-        val persisted = storage.persist(engine, sessionsSnapshot)
-        assertFalse(persisted)
-    }
-
-    @Test
-    fun startSchedulesPeriodicSaves() {
-        val engine = mock(Engine::class.java)
-        val scheduler = mock(ScheduledExecutorService::class.java)
-        val scheduledFuture = mock(ScheduledFuture::class.java)
-        `when`(scheduler.scheduleAtFixedRate(any(Runnable::class.java),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(TimeUnit.SECONDS))).thenReturn(scheduledFuture)
-
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application, true, 300, scheduler)
-        storage.start(SessionManager(engine))
-        verify(scheduler).scheduleAtFixedRate(any(Runnable::class.java),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(TimeUnit.SECONDS))
-    }
-
-    @Test
-    fun stopCancelsScheduledTask() {
-        val engine = mock(Engine::class.java)
-        val scheduler = mock(ScheduledExecutorService::class.java)
-        val scheduledFuture = mock(ScheduledFuture::class.java)
-        `when`(scheduler.scheduleAtFixedRate(any(Runnable::class.java),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(300L),
-                ArgumentMatchers.eq(TimeUnit.SECONDS))).thenReturn(scheduledFuture)
-
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application, true, 300, scheduler)
-        storage.stop()
-        verify(scheduledFuture, never()).cancel(ArgumentMatchers.eq(false))
-
-        storage.start(SessionManager(engine))
-        storage.stop()
-        verify(scheduledFuture).cancel(ArgumentMatchers.eq(false))
-    }
-
-    @Test
-    fun deserializeWithInvalidSource() {
-        val storage = DefaultSessionStorage(RuntimeEnvironment.application)
-
-        val json = JSONObject()
-        json.put("uuid", "testId")
-        json.put("url", "testUrl")
-        json.put("source", Source.NEW_TAB.name)
-        json.put("parentUuid", "")
-        assertEquals(Source.NEW_TAB, storage.deserializeSession(json).source)
-
-        val jsonInvalid = JSONObject()
-        jsonInvalid.put("uuid", "testId")
-        jsonInvalid.put("url", "testUrl")
-        jsonInvalid.put("source", "invalidSource")
-        jsonInvalid.put("parentUuid", "")
-        assertEquals(Source.NONE, storage.deserializeSession(jsonInvalid).source)
-    }
-
-    @Suppress("UNCHECKED_CAST")
-    private fun <T> anyJson(): T {
-        any<T>()
-        return null as T
-    }
-}
\ No newline at end of file
diff --git a/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/SessionStorageTest.kt b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/SessionStorageTest.kt
new file mode 100644
index 000000000000..dbf8533d4e02
--- /dev/null
+++ b/android-components/components/browser/session/src/test/java/mozilla/components/browser/session/storage/SessionStorageTest.kt
@@ -0,0 +1,444 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.session.storage
+
+import android.arch.lifecycle.Lifecycle
+import android.arch.lifecycle.LifecycleOwner
+import android.arch.lifecycle.LifecycleRegistry
+import android.util.AtomicFile
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.runBlocking
+import mozilla.components.browser.session.Session
+import mozilla.components.browser.session.Session.Source
+import mozilla.components.browser.session.SessionManager
+import mozilla.components.concept.engine.Engine
+import mozilla.components.concept.engine.EngineSession
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import org.json.JSONObject
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNotSame
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertSame
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.doThrow
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import org.mockito.Mockito.verifyNoMoreInteractions
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.util.concurrent.ScheduledExecutorService
+import java.util.concurrent.ScheduledFuture
+import java.util.concurrent.TimeUnit
+
+@RunWith(RobolectricTestRunner::class)
+class SessionStorageTest {
+
+    @Test
+    fun `Restored snapshot should contain sessions of saved snapshot`() {
+        val session1 = Session("http://mozilla.org", id = "session1")
+        val session2 = Session("http://getpocket.com", id = "session2")
+        val session3 = Session("http://getpocket.com", id = "session3")
+        session3.parentId = "session1"
+
+        val engineSessionState = mutableMapOf("k0" to "v0", "k1" to 1, "k2" to true, "k3" to emptyList<Any>())
+
+        val engineSession = mock(EngineSession::class.java)
+        `when`(engineSession.saveState()).thenReturn(engineSessionState)
+
+        val engine = mock(Engine::class.java)
+        `when`(engine.name()).thenReturn("gecko")
+        `when`(engine.createSession()).thenReturn(mock(EngineSession::class.java))
+
+        // Engine session just for one of the sessions for simplicity.
+        val sessionsSnapshot = SessionManager.Snapshot(
+            sessions = listOf(
+                SessionManager.Snapshot.Item(session1, engineSession),
+                SessionManager.Snapshot.Item(session2),
+                SessionManager.Snapshot.Item(session3)
+            ),
+            selectedSessionIndex = 0
+        )
+
+        // Persist the snapshot
+        val storage = SessionStorage(RuntimeEnvironment.application, engine)
+        val persisted = storage.save(sessionsSnapshot)
+        assertTrue(persisted)
+
+        // Read it back
+        val restoredSnapshot = storage.restore()
+        assertNotNull(restoredSnapshot)
+        assertEquals(3, restoredSnapshot!!.sessions.size)
+        assertEquals(0, restoredSnapshot.selectedSessionIndex)
+
+        assertEquals(session1, restoredSnapshot.sessions[0].session)
+        assertEquals(session1.url, restoredSnapshot.sessions[0].session.url)
+        assertEquals(session1.id, restoredSnapshot.sessions[0].session.id)
+        assertNull(restoredSnapshot.sessions[0].session.parentId)
+
+        assertEquals(session2, restoredSnapshot.sessions[1].session)
+        assertEquals(session2.url, restoredSnapshot.sessions[1].session.url)
+        assertEquals(session2.id, restoredSnapshot.sessions[1].session.id)
+        assertNull(restoredSnapshot.sessions[1].session.parentId)
+
+        assertEquals(session3, restoredSnapshot.sessions[2].session)
+        assertEquals(session3.url, restoredSnapshot.sessions[2].session.url)
+        assertEquals(session3.id, restoredSnapshot.sessions[2].session.id)
+        assertEquals("session1", restoredSnapshot.sessions[2].session.parentId)
+
+        val restoredEngineSession = restoredSnapshot.sessions[0].engineSession
+        assertNotNull(restoredEngineSession)
+        verify(restoredEngineSession)!!.restoreState(engineSessionState.filter { it.key != "k3" })
+    }
+
+    @Test
+    fun `Saving empty snapshot`() {
+        val engine = mock(Engine::class.java)
+        `when`(engine.name()).thenReturn("gecko")
+
+        val storage = spy(SessionStorage(RuntimeEnvironment.application, engine))
+        storage.save(SessionManager.Snapshot(emptyList(), SessionManager.NO_SELECTION))
+
+        verify(storage).clear()
+
+        val snapshot = storage.restore()
+        assertNull(snapshot)
+    }
+
+    @Test
+    fun `Should return empty snapshot after clearing`() {
+        val session1 = Session("http://mozilla.org", id = "session1")
+        val session2 = Session("http://getpocket.com", id = "session2")
+
+        val engineSession = mock(EngineSession::class.java)
+
+        val engine = mock(Engine::class.java)
+        `when`(engine.name()).thenReturn("gecko")
+        `when`(engine.createSession()).thenReturn(mock(EngineSession::class.java))
+
+        // Engine session just for one of the sessions for simplicity.
+        val sessionsSnapshot = SessionManager.Snapshot(
+            sessions = listOf(
+                SessionManager.Snapshot.Item(session1, engineSession),
+                SessionManager.Snapshot.Item(session2)
+            ),
+            selectedSessionIndex = 0
+        )
+
+        // Persist the snapshot
+        val storage = SessionStorage(RuntimeEnvironment.application, engine)
+        val persisted = storage.save(sessionsSnapshot)
+        assertTrue(persisted)
+
+        storage.clear()
+
+        // Read it back. Expect null, indicating empty.
+        val restoredSnapshot = storage.restore()
+        assertNull(restoredSnapshot)
+    }
+
+    @Test(expected = IllegalArgumentException::class)
+    fun `Should throw when saving illegal snapshot`() {
+        val engine = mock(Engine::class.java)
+        `when`(engine.name()).thenReturn("gecko")
+
+        val storage = SessionStorage(RuntimeEnvironment.application, engine)
+
+        val session = Session("http://mozilla.org")
+        val engineSession = mock(EngineSession::class.java)
+        val sessionsSnapshot = SessionManager.Snapshot(
+            sessions = listOf(
+                SessionManager.Snapshot.Item(
+                    session,
+                    engineSession
+                )
+            ),
+            selectedSessionIndex = 1
+        )
+        storage.save(sessionsSnapshot)
+    }
+
+    @Test
+    fun `AutoSave - when going to background`() {
+        runBlocking {
+            val lifecycle = LifecycleRegistry(mock(LifecycleOwner::class.java))
+
+            val snapshot: SessionManager.Snapshot = mock()
+            val sessionManager: SessionManager = mock()
+            doReturn(snapshot).`when`(sessionManager).createSnapshot()
+
+            val sessionStorage: SessionStorage = mock()
+
+            val autoSave = AutoSave(
+                sessionManager = sessionManager,
+                sessionStorage = sessionStorage,
+                minimumIntervalMs = 0
+            ).whenGoingToBackground(lifecycle)
+
+            verifyNoMoreInteractions(sessionStorage)
+
+            lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)
+            lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)
+            lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)
+            lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE)
+
+            verifyNoMoreInteractions(sessionStorage)
+
+            lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_STOP)
+
+            autoSave.saveJob?.join()
+
+            verify(sessionStorage).save(snapshot)
+        }
+    }
+
+    @Test
+    fun `AutoSave - when session gets added`() {
+        runBlocking {
+            val sessionManager = SessionManager(mock())
+
+            val sessionStorage: SessionStorage = mock()
+
+            val autoSave = AutoSave(
+                sessionManager = sessionManager,
+                sessionStorage = sessionStorage,
+                minimumIntervalMs = 0
+            ).whenSessionsChange()
+
+            assertNull(autoSave.saveJob)
+            verify(sessionStorage, never()).save(any())
+
+            sessionManager.add(Session("https://www.mozilla.org"))
+
+            autoSave.saveJob?.join()
+
+            verify(sessionStorage).save(any())
+        }
+    }
+
+    @Test
+    fun `AutoSave - when session gets removed`() {
+        runBlocking {
+            val sessionManager = SessionManager(mock())
+            sessionManager.add(Session("https://www.firefox.com"))
+            val session = Session("https://www.mozilla.org").also {
+                sessionManager.add(it)
+            }
+
+            val sessionStorage: SessionStorage = mock()
+
+            val autoSave = AutoSave(
+                sessionManager = sessionManager,
+                sessionStorage = sessionStorage,
+                minimumIntervalMs = 0
+            ).whenSessionsChange()
+
+            assertNull(autoSave.saveJob)
+            verify(sessionStorage, never()).save(any())
+
+            sessionManager.remove(session)
+
+            autoSave.saveJob?.join()
+
+            verify(sessionStorage).save(any())
+        }
+    }
+
+    @Test
+    fun `AutoSave - when session gets selected`() {
+        runBlocking {
+            val sessionManager = SessionManager(mock())
+            sessionManager.add(Session("https://www.firefox.com"))
+            val session = Session("https://www.mozilla.org").also {
+                sessionManager.add(it)
+            }
+
+            val sessionStorage: SessionStorage = mock()
+
+            val autoSave = AutoSave(
+                sessionManager = sessionManager,
+                sessionStorage = sessionStorage,
+                minimumIntervalMs = 0
+            ).whenSessionsChange()
+
+            assertNull(autoSave.saveJob)
+            verify(sessionStorage, never()).save(any())
+
+            sessionManager.select(session)
+
+            autoSave.saveJob?.join()
+
+            verify(sessionStorage).save(any())
+        }
+    }
+
+    @Test
+    fun `AutoSave - when session loading state changes`() {
+        runBlocking {
+            val sessionManager = SessionManager(mock())
+            val session = Session("https://www.mozilla.org").also {
+                sessionManager.add(it)
+            }
+
+            val sessionStorage: SessionStorage = mock()
+
+            val autoSave = AutoSave(
+                sessionManager = sessionManager,
+                sessionStorage = sessionStorage,
+                minimumIntervalMs = 0
+            ).whenSessionsChange()
+
+            session.loading = true
+
+            assertNull(autoSave.saveJob)
+            verify(sessionStorage, never()).save(any())
+
+            session.loading = false
+
+            autoSave.saveJob?.join()
+
+            verify(sessionStorage).save(any())
+        }
+    }
+
+    @Test
+    fun `AutoSave - periodically in foreground`() {
+        val engine = mock(Engine::class.java)
+        val scheduler = mock(ScheduledExecutorService::class.java)
+        val scheduledFuture = mock(ScheduledFuture::class.java)
+        `when`(scheduler.scheduleAtFixedRate(any(),
+                ArgumentMatchers.eq(300L),
+                ArgumentMatchers.eq(300L),
+                ArgumentMatchers.eq(TimeUnit.SECONDS))).thenReturn(scheduledFuture)
+
+        val lifecycle = LifecycleRegistry(mock(LifecycleOwner::class.java))
+
+        val storage = SessionStorage(RuntimeEnvironment.application, engine)
+        storage.autoSave(mock())
+            .periodicallyInForeground(300, TimeUnit.SECONDS, scheduler, lifecycle)
+
+        verifyNoMoreInteractions(scheduler)
+
+        lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)
+
+        verify(scheduler).scheduleAtFixedRate(any(),
+                ArgumentMatchers.eq(300L),
+                ArgumentMatchers.eq(300L),
+                ArgumentMatchers.eq(TimeUnit.SECONDS))
+
+        verifyNoMoreInteractions(scheduler)
+
+        lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_STOP)
+
+        verify(scheduledFuture).cancel(false)
+    }
+
+    @Test
+    fun `AutoSave - No new job triggered while save in flight`() {
+        val sessionManager = SessionManager(mock())
+        val sessionStorage: SessionStorage = mock()
+
+        val autoSave = AutoSave(
+            sessionManager = sessionManager,
+            sessionStorage = sessionStorage,
+            minimumIntervalMs = 0
+        )
+
+        val runningJob: Job = mock()
+        doReturn(true).`when`(runningJob).isActive
+
+        val saveJob = autoSave.triggerSave()
+        assertSame(saveJob, saveJob)
+    }
+
+    @Test
+    fun `AutoSave - New job triggered if current job is done`() {
+        val sessionManager = SessionManager(mock())
+        val sessionStorage: SessionStorage = mock()
+
+        val autoSave = AutoSave(
+            sessionManager = sessionManager,
+            sessionStorage = sessionStorage,
+            minimumIntervalMs = 0
+        )
+
+        val completed: Job = mock()
+        doReturn(false).`when`(completed).isActive
+
+        val saveJob = autoSave.triggerSave()
+        assertNotSame(completed, saveJob)
+    }
+
+    @Test
+    fun `saveSnapshotToDisk - Fails write on IOException`() {
+        val file: AtomicFile = mock()
+        doThrow(IOException::class.java).`when`(file).startWrite()
+
+        val snapshot = SessionManager.Snapshot(
+            sessions = listOf(
+                SessionManager.Snapshot.Item(Session("http://mozilla.org"))
+            ),
+            selectedSessionIndex = 0
+        )
+
+        saveSnapshotToDisk(file, snapshot)
+
+        verify(file).failWrite(any())
+    }
+
+    @Test
+    fun `readSnapshotFromDisk - Returns null on FileNotFoundException`() {
+        val file: AtomicFile = mock()
+        doThrow(FileNotFoundException::class.java).`when`(file).openRead()
+
+        val snapshot = readSnapshotFromDisk(file, engine = mock())
+        assertNull(snapshot)
+    }
+
+    @Test
+    fun `readSnapshotFromDisk - Returns null on corrupt JSON`() {
+        val file = getFileForEngine(RuntimeEnvironment.application, engine = mock())
+
+        val stream = file.startWrite()
+        stream.bufferedWriter().write("{ name: 'Foo")
+        file.finishWrite(stream)
+
+        val snapshot = readSnapshotFromDisk(file, engine = mock())
+        assertNull(snapshot)
+    }
+
+    @Test
+    fun deserializeWithInvalidSource() {
+        val json = JSONObject()
+        json.put("uuid", "testId")
+        json.put("url", "testUrl")
+        json.put("source", Source.NEW_TAB.name)
+        json.put("parentUuid", "")
+        assertEquals(Source.NEW_TAB, deserializeSession(json).source)
+
+        val jsonInvalid = JSONObject()
+        jsonInvalid.put("uuid", "testId")
+        jsonInvalid.put("url", "testUrl")
+        jsonInvalid.put("source", "invalidSource")
+        jsonInvalid.put("parentUuid", "")
+        assertEquals(Source.NONE, deserializeSession(jsonInvalid).source)
+    }
+
+    @Suppress("UNCHECKED_CAST")
+    private fun <T> anyJson(): T {
+        any<T>()
+        return null as T
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/SessionFeature.kt b/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/SessionFeature.kt
index c94d4dbb6f6a..d66563221162 100644
--- a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/SessionFeature.kt
+++ b/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/SessionFeature.kt
@@ -5,7 +5,6 @@
 package mozilla.components.feature.session
 
 import mozilla.components.browser.session.SessionManager
-import mozilla.components.browser.session.storage.SessionStorage
 import mozilla.components.concept.engine.EngineView
 
 /**
@@ -15,7 +14,6 @@ class SessionFeature(
     private val sessionManager: SessionManager,
     private val sessionUseCases: SessionUseCases,
     engineView: EngineView,
-    private val sessionStorage: SessionStorage? = null,
     sessionId: String? = null
 ) {
     internal val presenter = EngineViewPresenter(sessionManager, engineView, sessionId)
@@ -25,8 +23,6 @@ class SessionFeature(
      */
     fun start() {
         presenter.start()
-
-        sessionStorage?.start(sessionManager)
     }
 
     /**
@@ -50,13 +46,5 @@ class SessionFeature(
      */
     fun stop() {
         presenter.stop()
-
-        sessionStorage?.stop()
-        val snapshot = sessionManager.createSnapshot()
-        if (snapshot == null) {
-            sessionStorage?.clear(sessionManager.engine)
-        } else {
-            sessionStorage?.persist(sessionManager.engine, snapshot)
-        }
     }
 }
diff --git a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/SessionFeatureTest.kt b/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/SessionFeatureTest.kt
index 8a673f89c887..4c8730a7190e 100644
--- a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/SessionFeatureTest.kt
+++ b/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/SessionFeatureTest.kt
@@ -6,7 +6,6 @@ package mozilla.components.feature.session
 
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
-import mozilla.components.browser.session.storage.SessionStorage
 import mozilla.components.concept.engine.EngineSession
 import mozilla.components.concept.engine.EngineView
 import org.junit.Test
@@ -18,15 +17,13 @@ import org.mockito.Mockito.verify
 class SessionFeatureTest {
     private val sessionManager = mock(SessionManager::class.java)
     private val engineView = mock(EngineView::class.java)
-    private val sessionStorage = mock(SessionStorage::class.java)
     private val sessionUseCases = SessionUseCases(sessionManager)
 
     @Test
     fun start() {
-        val feature = SessionFeature(sessionManager, sessionUseCases, engineView, sessionStorage)
+        val feature = SessionFeature(sessionManager, sessionUseCases, engineView)
         feature.start()
         verify(sessionManager).register(feature.presenter)
-        verify(sessionStorage).start(sessionManager)
     }
 
     @Test
@@ -50,9 +47,8 @@ class SessionFeatureTest {
 
     @Test
     fun stop() {
-        val feature = SessionFeature(sessionManager, sessionUseCases, engineView, sessionStorage)
+        val feature = SessionFeature(sessionManager, sessionUseCases, engineView)
         feature.stop()
         verify(sessionManager).unregister(feature.presenter)
-        verify(sessionStorage).stop()
     }
 }
\ No newline at end of file
diff --git a/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/toolbar/TabCounterToolbarButtonTest.kt b/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/toolbar/TabCounterToolbarButtonTest.kt
index e9a919b7b051..d47d333ec3c7 100644
--- a/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/toolbar/TabCounterToolbarButtonTest.kt
+++ b/android-components/components/feature/tabs/src/test/java/mozilla/components/feature/tabs/toolbar/TabCounterToolbarButtonTest.kt
@@ -8,8 +8,6 @@ import android.view.ViewGroup
 import android.widget.LinearLayout
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
-import mozilla.components.browser.session.storage.SessionWithState
-import mozilla.components.browser.session.storage.SessionsSnapshot
 import mozilla.components.support.test.any
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.mock
@@ -145,10 +143,10 @@ class TabCounterToolbarButtonTest {
 
         assertEquals("0", view.getText())
 
-        val snapshot = SessionsSnapshot(listOf(
-            SessionWithState(Session("about:blank")),
-            SessionWithState(Session("about:blank")),
-            SessionWithState(Session("about:blank"))
+        val snapshot = SessionManager.Snapshot(listOf(
+            SessionManager.Snapshot.Item(Session("about:blank")),
+            SessionManager.Snapshot.Item(Session("about:blank")),
+            SessionManager.Snapshot.Item(Session("about:blank"))
         ), selectedSessionIndex = 0)
         sessionManager.restore(snapshot)
 
diff --git a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/BrowserFragment.kt b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/BrowserFragment.kt
index a15047a02e6c..dbac3ee495f5 100644
--- a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/BrowserFragment.kt
+++ b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/BrowserFragment.kt
@@ -48,7 +48,6 @@ class BrowserFragment : Fragment(), BackHandler, DownloadDialogListener {
                 components.sessionManager,
                 components.sessionUseCases,
                 engineView,
-                components.sessionStorage,
                 sessionId)
 
         toolbarFeature = ToolbarFeature(
diff --git a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/DefaultComponents.kt b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/DefaultComponents.kt
index 30b416e47ffc..0925737b4964 100644
--- a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/DefaultComponents.kt
+++ b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/DefaultComponents.kt
@@ -17,7 +17,7 @@ import mozilla.components.browser.menu.item.SimpleBrowserMenuItem
 import mozilla.components.browser.search.SearchEngineManager
 import mozilla.components.browser.session.Session
 import mozilla.components.browser.session.SessionManager
-import mozilla.components.browser.session.storage.DefaultSessionStorage
+import mozilla.components.browser.session.storage.SessionStorage
 import mozilla.components.browser.storage.memory.InMemoryHistoryStorage
 import mozilla.components.concept.engine.DefaultSettings
 import mozilla.components.concept.engine.Engine
@@ -26,6 +26,7 @@ import mozilla.components.feature.search.SearchUseCases
 import mozilla.components.feature.session.SessionUseCases
 import mozilla.components.feature.tabs.TabsUseCases
 import org.mozilla.samples.browser.request.SampleRequestInterceptor
+import java.util.concurrent.TimeUnit
 
 open class DefaultComponents(private val applicationContext: Context) {
 
@@ -40,20 +41,22 @@ open class DefaultComponents(private val applicationContext: Context) {
     // Storage
     val historyStorage by lazy { InMemoryHistoryStorage() }
 
-    // Session
-    val sessionStorage by lazy { DefaultSessionStorage(applicationContext) }
+    private val sessionStorage by lazy { SessionStorage(applicationContext, engine) }
 
     val sessionManager by lazy {
         SessionManager(engine,
                 defaultSession = { Session("about:blank") }
         ).apply {
-            sessionStorage.read(engine)?.let {
-                restore(it)
-            }
+            sessionStorage.restore()?.let { snapshot -> restore(snapshot) }
 
             if (size == 0) {
                 add(Session("https://www.mozilla.org"))
             }
+
+            sessionStorage.autoSave(this)
+                .periodicallyInForeground(interval = 30, unit = TimeUnit.SECONDS)
+                .whenGoingToBackground()
+                .whenSessionsChange()
         }
     }
 
diff --git a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/SampleApplication.kt b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/SampleApplication.kt
index 0e9c9a9ec111..351044de4310 100644
--- a/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/SampleApplication.kt
+++ b/android-components/samples/browser/src/main/java/org/mozilla/samples/browser/SampleApplication.kt
@@ -5,7 +5,15 @@
 package org.mozilla.samples.browser
 
 import android.app.Application
+import mozilla.components.support.base.log.Log
+import mozilla.components.support.base.log.sink.AndroidLogSink
 
 class SampleApplication : Application() {
     val components by lazy { Components(this) }
+
+    override fun onCreate() {
+        super.onCreate()
+
+        Log.addSink(AndroidLogSink())
+    }
 }
