diff --git a/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/Devices.kt b/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/Devices.kt
index 35550a3737c0..90d22d4f6bc1 100644
--- a/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/Devices.kt
+++ b/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/Devices.kt
@@ -18,20 +18,20 @@ interface DeviceConstellation : Observable<DeviceEventsObserver> {
      * @param name An initial name for the current device. This may be changed via [setDeviceNameAsync].
      * @param type Type of the current device. This can't be changed.
      * @param capabilities A list of capabilities that the current device claims to have.
-     * @return A [Deferred] that will be resolved once initialization is complete.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
     fun initDeviceAsync(
         name: String,
         type: DeviceType = DeviceType.MOBILE,
         capabilities: List<DeviceCapability>
-    ): Deferred<Unit>
+    ): Deferred<Boolean>
 
     /**
      * Destroy current device record.
      * Use this when device record is no longer relevant, e.g. while logging out. On success, other
      * devices will no longer see the current device in their device lists.
      *
-     * @return A boolean flag indicating if the operation succeeded.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
     fun destroyCurrentDeviceAsync(): Deferred<Boolean>
 
@@ -41,9 +41,9 @@ interface DeviceConstellation : Observable<DeviceEventsObserver> {
      * @param capabilities A list of capabilities to configure. This is expected to be the same or
      * longer list than what was passed into [initDeviceAsync]. Removing capabilities is currently
      * not supported.
-     * @return A [Deferred] that will be resolved once operation is complete.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
-    fun ensureCapabilitiesAsync(capabilities: List<DeviceCapability>): Deferred<Unit>
+    fun ensureCapabilitiesAsync(capabilities: List<DeviceCapability>): Deferred<Boolean>
 
     /**
      * Current state of the constellation. May be missing if state was never queried.
@@ -59,44 +59,45 @@ interface DeviceConstellation : Observable<DeviceEventsObserver> {
 
     /**
      * Get all devices in the constellation.
-     * @return A list of all devices in the constellation.
+     * @return A list of all devices in the constellation, or `null` on failure.
      */
-    fun fetchAllDevicesAsync(): Deferred<List<Device>>
+    fun fetchAllDevicesAsync(): Deferred<List<Device>?>
 
     /**
      * Set name of the current device.
      * @param name New device name.
-     * @return A [Deferred] that will be resolved once operation is complete.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
-    fun setDeviceNameAsync(name: String): Deferred<Unit>
+    fun setDeviceNameAsync(name: String): Deferred<Boolean>
 
     /**
      * Set a [DevicePushSubscription] for the current device.
      * @param subscription A new [DevicePushSubscription].
-     * @return A [Deferred] that will be resolved once operation is complete.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
-    fun setDevicePushSubscriptionAsync(subscription: DevicePushSubscription): Deferred<Unit>
+    fun setDevicePushSubscriptionAsync(subscription: DevicePushSubscription): Deferred<Boolean>
 
     /**
      * Send an event to a specified device.
      * @param targetDeviceId A device ID of the recipient.
      * @param outgoingEvent An event to send.
-     * @return A [Deferred] that will be resolved once operation is complete.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
-    fun sendEventToDeviceAsync(targetDeviceId: String, outgoingEvent: DeviceEventOutgoing): Deferred<Unit>
+    fun sendEventToDeviceAsync(targetDeviceId: String, outgoingEvent: DeviceEventOutgoing): Deferred<Boolean>
 
     /**
      * Process a raw event, obtained via a push message or some other out-of-band mechanism.
      * @param payload A raw, plaintext payload to be processed.
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete.
      */
-    fun processRawEvent(payload: String)
+    fun processRawEventAsync(payload: String): Deferred<Boolean>
 
     /**
      * Poll for events targeted at the current [Device]. It's expected that if a [DeviceEvent] was
      * returned after a poll, it will not be returned in consequent polls.
-     * @return A list of [DeviceEvent] instances that are currently pending for this [Device].
+     * @return A list of [DeviceEvent] instances that are currently pending for this [Device], or `null` on failure.
      */
-    fun pollForEventsAsync(): Deferred<List<DeviceEvent>>
+    fun pollForEventsAsync(): Deferred<List<DeviceEvent>?>
 
     /**
      * Begin periodically refreshing constellation state, including polling for events.
@@ -109,10 +110,12 @@ interface DeviceConstellation : Observable<DeviceEventsObserver> {
     fun stopPeriodicRefresh()
 
     /**
-     * Refreshes internal state of the device constellation.
-     * @return A [Deferred] that will be resolved once operation is complete.
+     * Refreshes [ConstellationState] and polls for device events.
+     *
+     * @return A [Deferred] that will be resolved with a success flag once operation is complete. Failure may
+     * indicate a partial success.
      */
-    fun refreshDeviceStateAsync(): Deferred<Unit>
+    fun refreshDeviceStateAsync(): Deferred<Boolean>
 }
 
 /**
diff --git a/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/OAuthAccount.kt b/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/OAuthAccount.kt
index 7e756c43e661..ddfd912eb2f1 100644
--- a/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/OAuthAccount.kt
+++ b/android-components/components/concept/sync/src/main/java/mozilla/components/concept/sync/OAuthAccount.kt
@@ -11,6 +11,7 @@ import kotlinx.coroutines.Deferred
  */
 enum class AuthExceptionType(val msg: String) {
     KEY_INFO("Missing key info"),
+    NO_TOKEN("Missing access token"),
     UNAUTHORIZED("Unauthorized")
 }
 
@@ -24,24 +25,29 @@ class AuthException(type: AuthExceptionType, cause: Exception? = null) : Throwab
  */
 @SuppressWarnings("TooManyFunctions")
 interface OAuthAccount : AutoCloseable {
-    fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String>
-    fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String>
-    fun getProfile(ignoreCache: Boolean): Deferred<Profile>
-    fun getProfile(): Deferred<Profile>
-    fun completeOAuthFlow(code: String, state: String): Deferred<Unit>
-    fun getAccessToken(singleScope: String): Deferred<AccessTokenInfo>
+    fun beginOAuthFlowAsync(scopes: Array<String>, wantsKeys: Boolean): Deferred<String?>
+    fun beginPairingFlowAsync(pairingUrl: String, scopes: Array<String>): Deferred<String?>
+    fun getProfileAsync(ignoreCache: Boolean): Deferred<Profile?>
+    fun getProfileAsync(): Deferred<Profile?>
+    fun completeOAuthFlowAsync(code: String, state: String): Deferred<Boolean>
+    fun getAccessTokenAsync(singleScope: String): Deferred<AccessTokenInfo?>
     fun getTokenServerEndpointURL(): String
     fun registerPersistenceCallback(callback: StatePersistenceCallback)
     fun deviceConstellation(): DeviceConstellation
     fun toJSONString(): String
 
     /**
+     * Returns an [AuthInfo] instance which may be used for data synchronization.
+     *
+     * @return An [AuthInfo] which is guaranteed to have a sync key.
      * @throws AuthException if account needs to restart the OAuth flow.
      */
     suspend fun authInfo(singleScope: String): AuthInfo {
         val tokenServerURL = this.getTokenServerEndpointURL()
-        val tokenInfo = this.getAccessToken(singleScope).await()
-        val keyInfo = tokenInfo.key ?: throw AuthException(AuthExceptionType.KEY_INFO)
+        val tokenInfo = this.getAccessTokenAsync(singleScope).await()
+                ?: throw AuthException(AuthExceptionType.NO_TOKEN)
+        val keyInfo = tokenInfo.key
+                ?: throw AuthException(AuthExceptionType.KEY_INFO)
 
         return AuthInfo(
                 kid = keyInfo.kid,
diff --git a/android-components/components/feature/accounts/src/main/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeature.kt b/android-components/components/feature/accounts/src/main/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeature.kt
index 796f4259d335..6d06e0483d6d 100644
--- a/android-components/components/feature/accounts/src/main/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeature.kt
+++ b/android-components/components/feature/accounts/src/main/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeature.kt
@@ -12,7 +12,6 @@ import mozilla.components.concept.engine.EngineSession
 import mozilla.components.concept.engine.request.RequestInterceptor
 import mozilla.components.feature.tabs.TabsUseCases
 import mozilla.components.service.fxa.manager.FxaAccountManager
-import mozilla.components.service.fxa.FxaException
 import kotlin.coroutines.CoroutineContext
 
 /**
@@ -37,15 +36,12 @@ class FirefoxAccountsAuthFeature(
         }
     }
 
-    private fun beginAuthenticationAsync(beginAuthentication: suspend () -> String) {
+    private fun beginAuthenticationAsync(beginAuthentication: suspend () -> String?) {
         CoroutineScope(coroutineContext).launch {
-            val authUrl = try {
-                beginAuthentication()
-            } catch (e: FxaException) {
-                // FIXME return a fallback URL provided by Config...
-                // https://github.com/mozilla-mobile/android-components/issues/2496
-                "https://accounts.firefox.com/signin"
-            }
+            // FIXME return a fallback URL provided by Config...
+            // https://github.com/mozilla-mobile/android-components/issues/2496
+            val authUrl = beginAuthentication() ?: "https://accounts.firefox.com/signin"
+
             // TODO
             // We may fail to obtain an authentication URL, for example due to transient network errors.
             // If that happens, open up a fallback URL in order to present some kind of a "no network"
diff --git a/android-components/components/feature/accounts/src/test/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeatureTest.kt b/android-components/components/feature/accounts/src/test/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeatureTest.kt
index 56ec700070c6..ea95b7c677e1 100644
--- a/android-components/components/feature/accounts/src/test/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeatureTest.kt
+++ b/android-components/components/feature/accounts/src/test/java/mozilla/components/feature/accounts/FirefoxAccountsAuthFeatureTest.kt
@@ -14,7 +14,6 @@ import mozilla.components.feature.tabs.TabsUseCases
 import mozilla.components.service.fxa.AccountStorage
 import mozilla.components.service.fxa.Config
 import mozilla.components.service.fxa.manager.FxaAccountManager
-import mozilla.components.service.fxa.FxaNetworkException
 import mozilla.components.service.fxa.SharedPrefAccountStorage
 import mozilla.components.service.fxa.manager.DeviceTuple
 import mozilla.components.support.test.any
@@ -116,15 +115,10 @@ class FirefoxAccountsAuthFeatureTest {
         val mockAccount: OAuthAccount = mock()
         val profile = Profile(uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
 
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.beginPairingFlow(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
-        // This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
-        // and threads will deadlock since it'll never be resolved while state machine is waiting for it.
-        // So we manually complete it here!
-        val unitDeferred = CompletableDeferred<Unit>()
-        unitDeferred.complete(Unit)
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitDeferred)
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.beginPairingFlowAsync(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -149,18 +143,11 @@ class FirefoxAccountsAuthFeatureTest {
         val mockAccount: OAuthAccount = mock()
         val profile = Profile(uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
 
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
-
-        val exceptionalDeferred = CompletableDeferred<String>()
-        exceptionalDeferred.completeExceptionally(FxaNetworkException("oops"))
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(exceptionalDeferred)
-        `when`(mockAccount.beginPairingFlow(anyString(), any())).thenReturn(exceptionalDeferred)
-        // This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
-        // and threads will deadlock since it'll never be resolved while state machine is waiting for it.
-        // So we manually complete it here!
-        val unitDeferred = CompletableDeferred<Unit>()
-        unitDeferred.complete(Unit)
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitDeferred)
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
+
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred(value = null))
+        `when`(mockAccount.beginPairingFlowAsync(anyString(), any())).thenReturn(CompletableDeferred(value = null))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
diff --git a/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/WorkManagerSyncDispatcher.kt b/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/WorkManagerSyncDispatcher.kt
index 9aac66f9426a..c91fe0d06d76 100644
--- a/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/WorkManagerSyncDispatcher.kt
+++ b/android-components/components/feature/sync/src/main/java/mozilla/components/feature/sync/WorkManagerSyncDispatcher.kt
@@ -234,14 +234,17 @@ class WorkManagerSyncWorker(
                     resultBuilder.putBoolean(it.key, true)
                 }
                 is SyncStatus.Error -> {
-                    // Notify auth error observers that we saw an auth-related error while syncing.
-                    if (status.exception is AuthException) {
-                        authErrorRegistry.notifyObservers {
-                            onAuthErrorAsync(status.exception as AuthException)
+                    val exception = status.exception
+                    when (exception) {
+                        // Notify auth error observers that we saw an auth-related error while syncing.
+                        is AuthException -> {
+                            authErrorRegistry.notifyObservers {
+                                onAuthErrorAsync(exception)
+                            }
                         }
                     }
 
-                    logger.error("Failed to synchronize store ${it.key}", status.exception)
+                    logger.error("Failed to synchronize store ${it.key}", exception)
                     resultBuilder.putBoolean(it.key, false)
                 }
             }
diff --git a/android-components/components/feature/sync/src/test/java/mozilla/components/feature/sync/StorageSyncTest.kt b/android-components/components/feature/sync/src/test/java/mozilla/components/feature/sync/StorageSyncTest.kt
index 3da05fbfad07..69ab54036e58 100644
--- a/android-components/components/feature/sync/src/test/java/mozilla/components/feature/sync/StorageSyncTest.kt
+++ b/android-components/components/feature/sync/src/test/java/mozilla/components/feature/sync/StorageSyncTest.kt
@@ -44,7 +44,7 @@ class StorageSyncTest {
         val mockAccessTokenInfo = AccessTokenInfo(
             scope = "scope", key = OAuthScopedKey("kty", "scope", "kid", "k"), token = "token", expiresAt = 0
         )
-        `when`(mockAccount.getAccessToken(any())).thenReturn(CompletableDeferred((mockAccessTokenInfo)))
+        `when`(mockAccount.getAccessTokenAsync(any())).thenReturn(CompletableDeferred((mockAccessTokenInfo)))
 
         // Single store, different result types.
         val testStore: SyncableStore = mock()
@@ -88,7 +88,7 @@ class StorageSyncTest {
         val mockAccessTokenInfo = AccessTokenInfo(
                 scope = "scope", key = OAuthScopedKey("kty", "scope", "kid", "k"), token = "token", expiresAt = 0
         )
-        `when`(mockAccount.getAccessToken(any())).thenReturn(CompletableDeferred((mockAccessTokenInfo)))
+        `when`(mockAccount.getAccessTokenAsync(any())).thenReturn(CompletableDeferred((mockAccessTokenInfo)))
 
         val verifier = object {
             private val blocks = mutableListOf<() -> Unit>()
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
index 34d532ef0f1e..fd04f779a4cc 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
@@ -11,11 +11,8 @@ import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.plus
 import mozilla.appservices.fxaclient.FirefoxAccount as InternalFxAcct
-import mozilla.appservices.fxaclient.FxaException.Unauthorized as Unauthorized
 
 import mozilla.components.concept.sync.AccessTokenInfo
-import mozilla.components.concept.sync.AuthException
-import mozilla.components.concept.sync.AuthExceptionType
 import mozilla.components.concept.sync.DeviceConstellation
 import mozilla.components.concept.sync.OAuthAccount
 import mozilla.components.concept.sync.Profile
@@ -34,6 +31,8 @@ class FirefoxAccount internal constructor(
     private val job = SupervisorJob()
     private val scope = CoroutineScope(Dispatchers.IO) + job
 
+    private val logger = Logger("FirefoxAccount")
+
     /**
      * Why this exists: in the `init` block below you'll notice that we register a persistence callback
      * as soon as we initialize this object. Essentially, we _always_ have a persistence callback
@@ -107,12 +106,20 @@ class FirefoxAccount internal constructor(
      * @param wantsKeys Fetch keys for end-to-end encryption of data from Mozilla-hosted services
      * @return Deferred<String> that resolves to the flow URL when complete
      */
-    override fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String> {
-        return scope.async { inner.beginOAuthFlow(scopes, wantsKeys) }
+    override fun beginOAuthFlowAsync(scopes: Array<String>, wantsKeys: Boolean): Deferred<String?> {
+        return scope.async {
+            handleFxaExceptions(logger, "begin oauth flow", { null }) {
+                inner.beginOAuthFlow(scopes, wantsKeys)
+            }
+        }
     }
 
-    override fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String> {
-        return scope.async { inner.beginPairingFlow(pairingUrl, scopes) }
+    override fun beginPairingFlowAsync(pairingUrl: String, scopes: Array<String>): Deferred<String?> {
+        return scope.async {
+            handleFxaExceptions(logger, "begin oauth pairing flow", { null }) {
+                inner.beginPairingFlow(pairingUrl, scopes)
+            }
+        }
     }
 
     /**
@@ -120,13 +127,13 @@ class FirefoxAccount internal constructor(
      * or from the server (requires the client to have access to the profile scope).
      *
      * @param ignoreCache Fetch the profile information directly from the server
-     * @return Deferred<[Profile]> representing the user's basic profile info
-     * @throws Unauthorized We couldn't find any suitable access token to make that call.
-     * The caller should then start the OAuth Flow again with the "profile" scope.
+     * @return Profile (optional, if successfully retrieved) representing the user's basic profile info
      */
-    override fun getProfile(ignoreCache: Boolean): Deferred<Profile> {
+    override fun getProfileAsync(ignoreCache: Boolean): Deferred<Profile?> {
         return scope.async {
-            inner.getProfile(ignoreCache).into()
+            handleFxaExceptions(logger, "getProfile", { null }) {
+                inner.getProfile(ignoreCache).into()
+            }
         }
     }
 
@@ -134,11 +141,9 @@ class FirefoxAccount internal constructor(
      * Convenience method to fetch the profile from a cached account by default, but fall back
      * to retrieval from the server.
      *
-     * @return Deferred<[Profile]> representing the user's basic profile info
-     * @throws Unauthorized We couldn't find any suitable access token to make that call.
-     * The caller should then start the OAuth Flow again with the "profile" scope.
+     * @return Profile (optional, if successfully retrieved) representing the user's basic profile info
      */
-    override fun getProfile(): Deferred<Profile> = getProfile(false)
+    override fun getProfileAsync(): Deferred<Profile?> = getProfileAsync(false)
 
     /**
      * Fetches the token server endpoint, for authentication using the SAML bearer flow.
@@ -156,12 +161,16 @@ class FirefoxAccount internal constructor(
 
     /**
      * Authenticates the current account using the code and state parameters fetched from the
-     * redirect URL reached after completing the sign in flow triggered by [beginOAuthFlow].
+     * redirect URL reached after completing the sign in flow triggered by [beginOAuthFlowAsync].
      *
      * Modifies the FirefoxAccount state.
      */
-    override fun completeOAuthFlow(code: String, state: String): Deferred<Unit> {
-        return scope.async { inner.completeOAuthFlow(code, state) }
+    override fun completeOAuthFlowAsync(code: String, state: String): Deferred<Boolean> {
+        return scope.async {
+            handleFxaExceptions(logger, "complete oauth flow") {
+                inner.completeOAuthFlow(code, state)
+            }
+        }
     }
 
     /**
@@ -170,16 +179,11 @@ class FirefoxAccount internal constructor(
      * @param singleScope Single OAuth scope (no spaces) for which the client wants access
      * @return [AccessTokenInfo] that stores the token, along with its scope, key and
      *                           expiration timestamp (in seconds) since epoch when complete
-     * @throws AuthException We couldn't provide an access token for this scope.
-     * The caller should then start the OAuth Flow again with the desired scope.
      */
-    override fun getAccessToken(singleScope: String): Deferred<AccessTokenInfo> {
+    override fun getAccessTokenAsync(singleScope: String): Deferred<AccessTokenInfo?> {
         return scope.async {
-            try {
+            handleFxaExceptions(logger, "get access token", { null }) {
                 inner.getAccessToken(singleScope).into()
-            } catch (e: FxaUnauthorizedException) {
-                // Re-wrap an internal auth error to a concept-level auth error.
-                throw AuthException(AuthExceptionType.UNAUTHORIZED, cause = e)
             }
         }
     }
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaDeviceConstellation.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaDeviceConstellation.kt
index 4d003aca6105..2aea3487f27e 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaDeviceConstellation.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaDeviceConstellation.kt
@@ -11,6 +11,7 @@ import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
+import mozilla.appservices.fxaclient.AccountEvent
 import mozilla.appservices.fxaclient.FirefoxAccount
 import mozilla.components.concept.sync.ConstellationState
 import mozilla.components.concept.sync.Device
@@ -54,9 +55,15 @@ class FxaDeviceConstellation(
         })
     }
 
-    override fun initDeviceAsync(name: String, type: DeviceType, capabilities: List<DeviceCapability>): Deferred<Unit> {
+    override fun initDeviceAsync(
+        name: String,
+        type: DeviceType,
+        capabilities: List<DeviceCapability>
+    ): Deferred<Boolean> {
         return scope.async {
-            account.initializeDevice(name, type.into(), capabilities.map { it.into() }.toSet())
+            handleFxaExceptions(logger, "initializing device") {
+                account.initializeDevice(name, type.into(), capabilities.map { it.into() }.toSet())
+            }
         }
     }
 
@@ -64,13 +71,9 @@ class FxaDeviceConstellation(
         val state = state()
         state?.currentDevice?.let {
             return scope.async {
-                maybeExceptional({
+                handleFxaExceptions(logger, "destroying current device") {
                     account.destroyDevice(it.id)
-                    true
-                }, { error ->
-                    logger.error("Failed to destroy device record", error)
-                    false
-                })
+                }
             }
         }
 
@@ -83,37 +86,45 @@ class FxaDeviceConstellation(
         return CompletableDeferred(false)
     }
 
-    override fun ensureCapabilitiesAsync(capabilities: List<DeviceCapability>): Deferred<Unit> {
+    override fun ensureCapabilitiesAsync(capabilities: List<DeviceCapability>): Deferred<Boolean> {
         return scope.async {
-            account.ensureCapabilities(capabilities.map { it.into() }.toSet())
+            handleFxaExceptions(logger, "ensuring capabilities") {
+                account.ensureCapabilities(capabilities.map { it.into() }.toSet())
+            }
         }
     }
 
-    override fun processRawEvent(payload: String) {
-        scope.launch {
-            val events = account.handlePushMessage(payload).filter {
-                it is mozilla.appservices.fxaclient.AccountEvent.TabReceived
-            }.map {
-                (it as mozilla.appservices.fxaclient.AccountEvent.TabReceived).into()
+    override fun processRawEventAsync(payload: String): Deferred<Boolean> {
+        return scope.async {
+            handleFxaExceptions(logger, "processing raw events") {
+                val events = account.handlePushMessage(payload).filter {
+                    it is AccountEvent.TabReceived
+                }.map {
+                    (it as AccountEvent.TabReceived).into()
+                }
+                deviceManager.processEvents(events)
             }
-            deviceManager.processEvents(events)
         }
     }
 
-    override fun pollForEventsAsync(): Deferred<List<DeviceEvent>> {
+    override fun pollForEventsAsync(): Deferred<List<DeviceEvent>?> {
         // Currently ignoring non-TabReceived events.
         return scope.async {
-            account.pollDeviceCommands().filter {
-                it is mozilla.appservices.fxaclient.AccountEvent.TabReceived
-            }.map {
-                (it as mozilla.appservices.fxaclient.AccountEvent.TabReceived).into()
+            handleFxaExceptions(logger, "polling for device events", { null }) {
+                account.pollDeviceCommands().filter {
+                    it is AccountEvent.TabReceived
+                }.map {
+                    (it as AccountEvent.TabReceived).into()
+                }
             }
         }
     }
 
-    override fun fetchAllDevicesAsync(): Deferred<List<Device>> {
+    override fun fetchAllDevicesAsync(): Deferred<List<Device>?> {
         return scope.async {
-            account.getDevices().map { it.into() }
+            handleFxaExceptions(logger, "fetching all devices", { null }) {
+                account.getDevices().map { it.into() }
+            }
         }
     }
 
@@ -125,27 +136,33 @@ class FxaDeviceConstellation(
         deviceObserverRegistry.register(observer, owner, autoPause)
     }
 
-    override fun setDeviceNameAsync(name: String): Deferred<Unit> {
+    override fun setDeviceNameAsync(name: String): Deferred<Boolean> {
         return scope.async {
-            account.setDeviceDisplayName(name)
+            handleFxaExceptions(logger, "changing device name") {
+                account.setDeviceDisplayName(name)
+            }
         }
     }
 
-    override fun setDevicePushSubscriptionAsync(subscription: DevicePushSubscription): Deferred<Unit> {
+    override fun setDevicePushSubscriptionAsync(subscription: DevicePushSubscription): Deferred<Boolean> {
         return scope.async {
-            account.setDevicePushSubscription(
-                    subscription.endpoint, subscription.publicKey, subscription.authKey
-            )
+            handleFxaExceptions(logger, "updating device push subscription") {
+                account.setDevicePushSubscription(
+                        subscription.endpoint, subscription.publicKey, subscription.authKey
+                )
+            }
         }
     }
 
-    override fun sendEventToDeviceAsync(targetDeviceId: String, outgoingEvent: DeviceEventOutgoing): Deferred<Unit> {
+    override fun sendEventToDeviceAsync(targetDeviceId: String, outgoingEvent: DeviceEventOutgoing): Deferred<Boolean> {
         return scope.async {
-            when (outgoingEvent) {
-                is DeviceEventOutgoing.SendTab -> {
-                    account.sendSingleTab(targetDeviceId, outgoingEvent.title, outgoingEvent.url)
+            handleFxaExceptions(logger, "sending device event") {
+                when (outgoingEvent) {
+                    is DeviceEventOutgoing.SendTab -> {
+                        account.sendSingleTab(targetDeviceId, outgoingEvent.title, outgoingEvent.url)
+                    }
+                    else -> logger.debug("Skipped sending unsupported event type: $outgoingEvent")
                 }
-                else -> logger.debug("Skipped sending unsupported event type: $outgoingEvent")
             }
         }
     }
@@ -162,10 +179,14 @@ class FxaDeviceConstellation(
         deviceManager.stopPolling()
     }
 
-    override fun refreshDeviceStateAsync(): Deferred<Unit> {
+    override fun refreshDeviceStateAsync(): Deferred<Boolean> {
         return scope.async {
-            deviceManager.refreshDevicesAsync().await()
-            deviceManager.processEvents(pollForEventsAsync().await())
+            val refreshedDevices = deviceManager.refreshDevicesAsync().await()
+            val events = pollForEventsAsync().await()?.let {
+                deviceManager.processEvents(it)
+                true
+            } ?: false
+            refreshedDevices && events
         }
     }
 }
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Utils.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Utils.kt
index 2d251fe3cb56..04f6312c384f 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Utils.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Utils.kt
@@ -4,24 +4,64 @@
 
 package mozilla.components.service.fxa
 
+import mozilla.components.concept.sync.AuthException
+import mozilla.components.concept.sync.AuthExceptionType
+import mozilla.components.service.fxa.manager.authErrorRegistry
+import mozilla.components.support.base.log.logger.Logger
+
 /**
- * Runs a provided lambda, and if that throws non-panic FxA exception, runs the second lambda.
+ * Runs a provided lambda, and if that throws non-panic, non-auth FxA exception, runs [handleErrorBlock].
+ * If that lambda throws an FxA auth exception, notifies [authErrorRegistry], and runs [postHandleAuthErrorBlock].
  *
  * @param block A lambda to execute which mail fail with an [FxaException].
- * @param handleErrorBlock A lambda to execute if [block] fails with a non-panic [FxaException].
+ * @param postHandleAuthErrorBlock A lambda to execute if [block] failed with [FxaUnauthorizedException].
+ * @param handleErrorBlock A lambda to execute if [block] fails with a non-panic, non-auth [FxaException].
  * @return object of type T, as defined by [block].
  */
-fun <T> maybeExceptional(block: () -> T, handleErrorBlock: (e: FxaException) -> T): T {
+fun <T> handleFxaExceptions(
+    logger: Logger,
+    operation: String,
+    block: () -> T,
+    postHandleAuthErrorBlock: (e: FxaUnauthorizedException) -> T,
+    handleErrorBlock: (e: FxaException) -> T
+): T {
     return try {
-        block()
+        logger.info("Executing: $operation")
+        val res = block()
+        logger.info("Successfully executed: $operation")
+        res
     } catch (e: FxaException) {
         when (e) {
             is FxaPanicException -> {
                 throw e
             }
+            is FxaUnauthorizedException -> {
+                logger.warn("Auth error while running: $operation")
+                authErrorRegistry.notifyObservers { onAuthErrorAsync(AuthException(AuthExceptionType.UNAUTHORIZED, e)) }
+                postHandleAuthErrorBlock(e)
+            }
             else -> {
+                logger.error("Error while running: $operation", e)
                 handleErrorBlock(e)
             }
         }
     }
 }
+
+/**
+ * Helper method that handles [FxaException] and allows specifying a lazy default value via [default]
+ * block for use in case of errors. Execution is wrapped in log statements.
+ */
+fun <T> handleFxaExceptions(logger: Logger, operation: String, default: (error: FxaException) -> T, block: () -> T): T {
+    return handleFxaExceptions(logger, operation, block, { default(it) }, { default(it) })
+}
+
+/**
+ * Helper method that handles [FxaException] and returns a [Boolean] success flag as a result.
+ */
+fun handleFxaExceptions(logger: Logger, operation: String, block: () -> Unit): Boolean {
+    return handleFxaExceptions(logger, operation, { false }, {
+        block()
+        true
+    })
+}
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaAccountManager.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaAccountManager.kt
index aa6d1d510eb7..ccff0bf6088d 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaAccountManager.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaAccountManager.kt
@@ -16,7 +16,6 @@ import kotlinx.coroutines.async
 import kotlinx.coroutines.cancel
 import mozilla.components.concept.sync.AccountObserver
 import mozilla.components.concept.sync.AuthException
-import mozilla.components.concept.sync.AuthExceptionType
 import mozilla.components.concept.sync.DeviceCapability
 import mozilla.components.concept.sync.DeviceEvent
 import mozilla.components.concept.sync.DeviceType
@@ -30,7 +29,6 @@ import mozilla.components.service.fxa.Config
 import mozilla.components.service.fxa.FirefoxAccount
 import mozilla.components.service.fxa.FxaException
 import mozilla.components.service.fxa.FxaPanicException
-import mozilla.components.service.fxa.FxaUnauthorizedException
 import mozilla.components.service.fxa.SharedPrefAccountStorage
 import java.util.concurrent.ConcurrentLinkedQueue
 import kotlin.coroutines.CoroutineContext
@@ -76,10 +74,9 @@ private interface OAuthObserver {
     fun onBeginOAuthFlow(authUrl: String)
 
     /**
-     * Account manager encountered an error during authentication. Inspect [error] for details.
-     * @param error A specific FxA error encountered.
+     * Account manager encountered an error during authentication.
      */
-    fun onError(error: FxaException)
+    fun onError()
 }
 
 /**
@@ -109,7 +106,7 @@ open class FxaAccountManager(
     syncManager: SyncManager? = null,
     // We want a single-threaded execution model for our account-related "actions" (state machine side-effects).
     // That is, we want to ensure a sequential execution flow, but on a background thread.
-    val coroutineContext: CoroutineContext = Executors
+    private val coroutineContext: CoroutineContext = Executors
             .newSingleThreadExecutor().asCoroutineDispatcher() + SupervisorJob()
 ) : Closeable, Observable<AccountObserver> by ObserverRegistry() {
     private val logger = Logger("FirefoxAccountStateMachine")
@@ -119,14 +116,15 @@ open class FxaAccountManager(
     // through its motions. This allows us to keep around only one observer in the registry.
     private val fxaOAuthObserver = FxaOAuthObserver()
     private class FxaOAuthObserver : OAuthObserver {
-        lateinit var deferredAuthUrl: CompletableDeferred<String>
+        @Volatile
+        lateinit var deferredAuthUrl: CompletableDeferred<String?>
 
         override fun onBeginOAuthFlow(authUrl: String) {
             deferredAuthUrl.complete(authUrl)
         }
 
-        override fun onError(error: FxaException) {
-            deferredAuthUrl.completeExceptionally(error)
+        override fun onError() {
+            deferredAuthUrl.complete(null)
         }
     }
     private val oauthObservers = object : Observable<OAuthObserver> by ObserverRegistry() {}
@@ -188,7 +186,7 @@ open class FxaAccountManager(
                 }
                 AccountState.AuthenticatedNoProfile -> {
                     when (event) {
-                        is Event.AuthenticationError -> AccountState.AuthenticationProblems
+                        is Event.AuthenticationError -> AccountState.AuthenticationProblem
                         Event.FetchProfile -> AccountState.AuthenticatedNoProfile
                         Event.FetchedProfile -> AccountState.AuthenticatedWithProfile
                         Event.FailedToFetchProfile -> AccountState.AuthenticatedNoProfile
@@ -198,15 +196,15 @@ open class FxaAccountManager(
                 }
                 AccountState.AuthenticatedWithProfile -> {
                     when (event) {
-                        is Event.AuthenticationError -> AccountState.AuthenticationProblems
+                        is Event.AuthenticationError -> AccountState.AuthenticationProblem
                         Event.Logout -> AccountState.NotAuthenticated
                         else -> null
                     }
                 }
-                AccountState.AuthenticationProblems -> {
+                AccountState.AuthenticationProblem -> {
                     when (event) {
-                        Event.Authenticate -> AccountState.AuthenticationProblems
-                        Event.FailedToAuthenticate -> AccountState.AuthenticationProblems
+                        Event.Authenticate -> AccountState.AuthenticationProblem
+                        Event.FailedToAuthenticate -> AccountState.AuthenticationProblem
                         is Event.Authenticated -> AccountState.AuthenticatedNoProfile
                         Event.Logout -> AccountState.NotAuthenticated
                         else -> null
@@ -257,7 +255,7 @@ open class FxaAccountManager(
      */
     fun accountNeedsReauth(): Boolean {
         return when (state) {
-            AccountState.AuthenticationProblems -> true
+            AccountState.AuthenticationProblem -> true
             else -> false
         }
     }
@@ -273,8 +271,8 @@ open class FxaAccountManager(
         return processQueueAsync(Event.FetchProfile)
     }
 
-    fun beginAuthenticationAsync(pairingUrl: String? = null): Deferred<String> {
-        val deferredAuthUrl: CompletableDeferred<String> = CompletableDeferred()
+    fun beginAuthenticationAsync(pairingUrl: String? = null): Deferred<String?> {
+        val deferredAuthUrl = CompletableDeferred<String?>()
 
         // Observer will 'complete' this deferred once state machine resolves its events.
         fxaOAuthObserver.deferredAuthUrl = deferredAuthUrl
@@ -392,13 +390,9 @@ open class FxaAccountManager(
                         return doAuthenticate()
                     }
                     is Event.Pair -> {
-                        val url = try {
-                            account.beginPairingFlow(via.pairingUrl, scopes).await()
-                        } catch (e: FxaPanicException) {
-                            // Don't swallow panics from the underlying library.
-                            throw e
-                        } catch (e: FxaException) {
-                            oauthObservers.notifyObservers { onError(e) }
+                        val url = account.beginPairingFlowAsync(via.pairingUrl, scopes).await()
+                        if (url == null) {
+                            oauthObservers.notifyObservers { onError() }
                             return Event.FailedToAuthenticate
                         }
                         oauthObservers.notifyObservers { onBeginOAuthFlow(url) }
@@ -414,7 +408,7 @@ open class FxaAccountManager(
                         account.registerPersistenceCallback(statePersistenceCallback)
 
                         logger.info("Completing oauth flow")
-                        account.completeOAuthFlow(via.code, via.state).await()
+                        account.completeOAuthFlowAsync(via.code, via.state).await()
 
                         logger.info("Registering device constellation observer")
                         account.deviceConstellation().register(deviceEventsIntegration)
@@ -439,16 +433,12 @@ open class FxaAccountManager(
                         logger.info("Registering device constellation observer")
                         account.deviceConstellation().register(deviceEventsIntegration)
 
-                        logger.info("Ensuring device capabilities")
-                        try {
-                            account.deviceConstellation().ensureCapabilitiesAsync(deviceTuple.capabilities).await()
-                        } catch (e: FxaPanicException) {
-                            // Don't swallow panics from the underlying library.
-                            throw e
-                        } catch (e: FxaUnauthorizedException) {
-                            return Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED, e))
-                        } catch (e: FxaException) {
-                            logger.warn("Failed to ensure device capabilities", e)
+                        // If this is the first time ensuring our capabilities,
+                        logger.info("Ensuring device capabilities...")
+                        if (account.deviceConstellation().ensureCapabilitiesAsync(deviceTuple.capabilities).await()) {
+                            logger.info("Successfully ensured device capabilities.")
+                        } else {
+                            logger.warn("Failed to ensure device capabilities.")
                         }
 
                         logger.info("Starting periodic refresh of the device constellation")
@@ -463,15 +453,8 @@ open class FxaAccountManager(
                         // https://github.com/mozilla/application-services/issues/483
                         logger.info("Fetching profile...")
 
-                        profile = try {
-                            account.getProfile(true).await()
-                        } catch (e: FxaPanicException) {
-                            // Don't swallow panics from the underlying library.
-                            throw e
-                        } catch (e: FxaUnauthorizedException) {
-                            return Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED, e))
-                        } catch (e: FxaException) {
-                            logger.error("Failed to get profile for authenticated account", e)
+                        profile = account.getProfileAsync(true).await()
+                        if (profile == null) {
                             return Event.FailedToFetchProfile
                         }
 
@@ -491,7 +474,7 @@ open class FxaAccountManager(
                     else -> null
                 }
             }
-            AccountState.AuthenticationProblems -> {
+            AccountState.AuthenticationProblem -> {
                 when (via) {
                     Event.Authenticate -> {
                         return doAuthenticate()
@@ -507,13 +490,9 @@ open class FxaAccountManager(
     }
 
     private suspend fun doAuthenticate(): Event? {
-        val url = try {
-            account.beginOAuthFlow(scopes, true).await()
-        } catch (e: FxaPanicException) {
-            // Don't swallow panics from the underlying library.
-            throw e
-        } catch (e: FxaException) {
-            oauthObservers.notifyObservers { onError(e) }
+        val url = account.beginOAuthFlowAsync(scopes, true).await()
+        if (url == null) {
+            oauthObservers.notifyObservers { onError() }
             return Event.FailedToAuthenticate
         }
         oauthObservers.notifyObservers { onBeginOAuthFlow(url) }
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaDeviceManager.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaDeviceManager.kt
index 8bb5dc036c8f..08b4f9c3c398 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaDeviceManager.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/FxaDeviceManager.kt
@@ -19,16 +19,11 @@ import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
-import mozilla.components.concept.sync.AuthException
-import mozilla.components.concept.sync.AuthExceptionType
 import mozilla.components.concept.sync.ConstellationState
 import mozilla.components.concept.sync.DeviceEvent
 import mozilla.components.concept.sync.DeviceConstellation
 import mozilla.components.concept.sync.DeviceConstellationObserver
 import mozilla.components.concept.sync.DeviceEventsObserver
-import mozilla.components.service.fxa.FxaException
-import mozilla.components.service.fxa.FxaPanicException
-import mozilla.components.service.fxa.FxaUnauthorizedException
 import mozilla.components.support.base.log.logger.Logger
 
 import mozilla.components.support.base.observer.Observable
@@ -63,24 +58,13 @@ internal open class PollingDeviceManager(
         getRefreshManager().stopRefresh()
     }
 
-    fun pollAsync(): Deferred<Unit> {
+    fun pollAsync(): Deferred<Boolean> {
         return scope.async {
             logger.debug("poll")
-            val events = try {
-                constellation.pollForEventsAsync().await()
-            } catch (e: FxaPanicException) {
-                // Re-throw panics.
-                throw e
-            } catch (e: FxaUnauthorizedException) {
-                // Propagate auth errors.
-                authErrorRegistry.notifyObservers { onAuthErrorAsync(AuthException(AuthExceptionType.UNAUTHORIZED, e)) }
-                return@async
-            } catch (e: FxaException) {
-                // Ignore intermittent errors.
-                logger.warn("Failed to poll for events", e)
-                return@async
-            }
-            processEvents(events)
+            constellation.pollForEventsAsync().await()?.let {
+                processEvents(it)
+                true
+            } ?: false
         }
     }
 
@@ -93,24 +77,12 @@ internal open class PollingDeviceManager(
         notifyObservers { onEvents(events) }
     }
 
-    fun refreshDevicesAsync(): Deferred<Unit> = synchronized(this) {
+    fun refreshDevicesAsync(): Deferred<Boolean> = synchronized(this) {
         return scope.async {
             logger.info("Refreshing device list...")
 
-            val allDevices = try {
-                constellation.fetchAllDevicesAsync().await()
-            } catch (e: FxaPanicException) {
-                // Re-throw panics.
-                throw e
-            } catch (e: FxaUnauthorizedException) {
-                // Propagate auth errors.
-                authErrorRegistry.notifyObservers { onAuthErrorAsync(AuthException(AuthExceptionType.UNAUTHORIZED, e)) }
-                return@async
-            } catch (e: FxaException) {
-                // Ignore intermittent errors.
-                logger.warn("Failed to fetch devices", e)
-                return@async
-            }
+            // Attempt to fetch devices, or bail out on failure.
+            val allDevices = constellation.fetchAllDevicesAsync().await() ?: return@async false
 
             // Find the current device.
             val currentDevice = allDevices.find { it.isCurrentDevice }
@@ -135,6 +107,7 @@ internal open class PollingDeviceManager(
             }
 
             logger.info("Refreshed device list; saw ${allDevices.size} device(s).")
+            true
         }
     }
 
@@ -190,12 +163,15 @@ internal class WorkManagerDeviceRefreshWorker(
 
     @Suppress("ReturnCount", "ComplexMethod")
     override suspend fun doWork(): Result {
-        logger.debug("Polling for new events via ${DeviceManagerProvider.deviceManager}")
+        logger.info("Polling for new events via ${DeviceManagerProvider.deviceManager}")
 
-        DeviceManagerProvider.deviceManager?.let { deviceManager ->
+        val result = DeviceManagerProvider.deviceManager?.let { deviceManager ->
+            // TODO we may have failed to ensure device capabilities earlier (due to intermittent issues on startup).
             deviceManager.refreshDevicesAsync().await()
             deviceManager.pollAsync().await()
-        }
+        } ?: false
+
+        logger.info("Polling result: $result")
 
         return Result.success()
     }
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/State.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/State.kt
index 938823b47596..8dae12de8379 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/State.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/manager/State.kt
@@ -12,7 +12,7 @@ import mozilla.components.concept.sync.AuthException
 enum class AccountState {
     Start,
     NotAuthenticated,
-    AuthenticationProblems,
+    AuthenticationProblem,
     AuthenticatedNoProfile,
     AuthenticatedWithProfile
 }
diff --git a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt
index 11a7ffd9046c..67bf0f8ec789 100644
--- a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt
+++ b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt
@@ -125,7 +125,7 @@ class FxaAccountManagerTest {
         assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
         assertNull(FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
         assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Logout))
-        assertEquals(AccountState.AuthenticationProblems, FxaAccountManager.nextState(state, Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED))))
+        assertEquals(AccountState.AuthenticationProblem, FxaAccountManager.nextState(state, Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED))))
 
         // State 'AuthenticatedWithProfile'.
         state = AccountState.AuthenticatedWithProfile
@@ -139,19 +139,19 @@ class FxaAccountManagerTest {
         assertNull(FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
         assertNull(FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
         assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Logout))
-        assertEquals(AccountState.AuthenticationProblems, FxaAccountManager.nextState(state, Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED))))
+        assertEquals(AccountState.AuthenticationProblem, FxaAccountManager.nextState(state, Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED))))
 
-        // State 'AuthenticationProblems'.
-        state = AccountState.AuthenticationProblems
+        // State 'AuthenticationProblem'.
+        state = AccountState.AuthenticationProblem
         assertNull(FxaAccountManager.nextState(state, Event.Init))
         assertNull(FxaAccountManager.nextState(state, Event.AccountNotFound))
         assertNull(FxaAccountManager.nextState(state, Event.AccountRestored))
-        assertEquals(AccountState.AuthenticationProblems, FxaAccountManager.nextState(state, Event.Authenticate))
+        assertEquals(AccountState.AuthenticationProblem, FxaAccountManager.nextState(state, Event.Authenticate))
         assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.Authenticated("code", "state")))
         assertNull(FxaAccountManager.nextState(state, Event.FetchProfile))
         assertNull(FxaAccountManager.nextState(state, Event.FetchedProfile))
         assertNull(FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
-        assertEquals(AccountState.AuthenticationProblems, FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
+        assertEquals(AccountState.AuthenticationProblem, FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
         assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Logout))
         assertNull(FxaAccountManager.nextState(state, Event.AuthenticationError(AuthException(AuthExceptionType.UNAUTHORIZED))))
     }
@@ -170,7 +170,7 @@ class FxaAccountManagerTest {
             account
         }
 
-        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(CompletableDeferred(true))
         // We have an account at the start.
         `when`(accountStorage.read()).thenReturn(account)
 
@@ -206,9 +206,7 @@ class FxaAccountManagerTest {
             account
         }
 
-        val fxaNetworkError = CompletableDeferred<Unit>()
-        fxaNetworkError.completeExceptionally(FxaNetworkException("fxa 500"))
-        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(fxaNetworkError)
+        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(CompletableDeferred(false))
         // We have an account at the start.
         `when`(accountStorage.read()).thenReturn(account)
 
@@ -247,10 +245,11 @@ class FxaAccountManagerTest {
 
         manager.register(accountObserver)
 
-        // Hit a 401 while we're restoring account.
-        val fxa401 = CompletableDeferred<Unit>()
-        fxa401.completeExceptionally(FxaUnauthorizedException("401"))
-        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(fxa401)
+        `when`(constellation.ensureCapabilitiesAsync(any())).then {
+            // Hit an auth error.
+            authErrorRegistry.notifyObservers { onAuthErrorAsync(AuthException(AuthExceptionType.UNAUTHORIZED)) }
+            CompletableDeferred(false)
+        }
         // We have an account at the start.
         `when`(accountStorage.read()).thenReturn(account)
 
@@ -283,7 +282,7 @@ class FxaAccountManagerTest {
         manager.register(accountObserver)
 
         // Hit a panic while we're restoring account.
-        val fxaPanic = CompletableDeferred<Unit>()
+        val fxaPanic = CompletableDeferred<Boolean>()
         fxaPanic.completeExceptionally(FxaPanicException("panic!"))
         `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(fxaPanic)
         // We have an account at the start.
@@ -316,7 +315,7 @@ class FxaAccountManagerTest {
             account
         }
 
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
@@ -355,27 +354,27 @@ class FxaAccountManagerTest {
     class StatePersistenceTestableAccount(private val profile: Profile, private val constellation: DeviceConstellation) : OAuthAccount {
         var persistenceCallback: StatePersistenceCallback? = null
 
-        override fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String> {
+        override fun beginOAuthFlowAsync(scopes: Array<String>, wantsKeys: Boolean): Deferred<String?> {
             return CompletableDeferred("auth://url")
         }
 
-        override fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String> {
+        override fun beginPairingFlowAsync(pairingUrl: String, scopes: Array<String>): Deferred<String?> {
             return CompletableDeferred("auth://url")
         }
 
-        override fun getProfile(ignoreCache: Boolean): Deferred<Profile> {
+        override fun getProfileAsync(ignoreCache: Boolean): Deferred<Profile?> {
             return CompletableDeferred(profile)
         }
 
-        override fun getProfile(): Deferred<Profile> {
+        override fun getProfileAsync(): Deferred<Profile?> {
             return CompletableDeferred(profile)
         }
 
-        override fun completeOAuthFlow(code: String, state: String): Deferred<Unit> {
-            return unitCompletedDeferrable()
+        override fun completeOAuthFlowAsync(code: String, state: String): Deferred<Boolean> {
+            return CompletableDeferred(true)
         }
 
-        override fun getAccessToken(singleScope: String): Deferred<AccessTokenInfo> {
+        override fun getAccessTokenAsync(singleScope: String): Deferred<AccessTokenInfo?> {
             fail()
             return CompletableDeferred()
         }
@@ -488,11 +487,11 @@ class FxaAccountManagerTest {
         val constellation: DeviceConstellation = mock()
         val profile = Profile(
             "testUid", "test@example.com", null, "Test Profile")
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
         // We have an account at the start.
         `when`(accountStorage.read()).thenReturn(mockAccount)
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.ensureCapabilitiesAsync(any())).thenReturn(CompletableDeferred(true))
 
         val manager = TestableFxaAccountManager(
                 context,
@@ -561,7 +560,7 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         manager.finishAuthenticationAsync("dummyCode", "dummyState").await()
 
@@ -596,7 +595,7 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        val fxaPanic = CompletableDeferred<Unit>()
+        val fxaPanic = CompletableDeferred<Boolean>()
         fxaPanic.completeExceptionally(FxaPanicException("panic!"))
         `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(fxaPanic)
 
@@ -608,13 +607,13 @@ class FxaAccountManagerTest {
         val mockAccount: OAuthAccount = mock()
         val profile = Profile(uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
         val accountStorage = mock<AccountStorage>()
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
 
         val fxaPanic = CompletableDeferred<String>()
         fxaPanic.completeExceptionally(FxaPanicException("panic!"))
 
-        `when`(mockAccount.beginPairingFlow(any(), any())).thenReturn(fxaPanic)
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(mockAccount.beginPairingFlowAsync(any(), any())).thenReturn(fxaPanic)
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -629,7 +628,7 @@ class FxaAccountManagerTest {
 
         manager.initAsync().await()
         manager.beginAuthenticationAsync("http://pairing.com").await()
-        Unit
+        fail()
     }
 
     @Test
@@ -651,7 +650,7 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         manager.finishAuthenticationAsync("dummyCode", "dummyState").await()
 
@@ -674,8 +673,7 @@ class FxaAccountManagerTest {
         val constellation: DeviceConstellation = mock()
         val profile = Profile(uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
         val accountObserver: AccountObserver = mock()
-        val fxaException = FxaNetworkException("network problem")
-        val manager = prepareUnhappyAuthenticationFlow(mockAccount, profile, accountStorage, accountObserver, fxaException, this.coroutineContext)
+        val manager = prepareUnhappyAuthenticationFlow(mockAccount, profile, accountStorage, accountObserver, this.coroutineContext)
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
 
@@ -685,12 +683,7 @@ class FxaAccountManagerTest {
 
         reset(accountObserver)
 
-        try {
-            manager.beginAuthenticationAsync().await()
-            fail()
-        } catch (e: FxaNetworkException) {
-            assertEquals(fxaException.message, e.message)
-        }
+        assertNull(manager.beginAuthenticationAsync().await())
 
         // Confirm that account state observable doesn't receive authentication errors.
         verify(accountObserver, never()).onError(any())
@@ -698,8 +691,8 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         // Try again, without any network problems this time.
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         assertEquals("auth://url", manager.beginAuthenticationAsync().await())
 
@@ -727,8 +720,7 @@ class FxaAccountManagerTest {
         val constellation: DeviceConstellation = mock()
         val profile = Profile(uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
         val accountObserver: AccountObserver = mock()
-        val fxaException = FxaNetworkException("network problem")
-        val manager = prepareUnhappyAuthenticationFlow(mockAccount, profile, accountStorage, accountObserver, fxaException, this.coroutineContext)
+        val manager = prepareUnhappyAuthenticationFlow(mockAccount, profile, accountStorage, accountObserver, this.coroutineContext)
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
 
@@ -738,12 +730,7 @@ class FxaAccountManagerTest {
 
         reset(accountObserver)
 
-        try {
-            manager.beginAuthenticationAsync(pairingUrl = "auth://pairing").await()
-            fail()
-        } catch (e: FxaNetworkException) {
-            assertEquals(fxaException.message, e.message)
-        }
+        assertNull(manager.beginAuthenticationAsync(pairingUrl = "auth://pairing").await())
 
         // Confirm that account state observable doesn't receive authentication errors.
         verify(accountObserver, never()).onError(any())
@@ -751,8 +738,8 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         // Try again, without any network problems this time.
-        `when`(mockAccount.beginPairingFlow(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(mockAccount.beginPairingFlowAsync(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         assertEquals("auth://url", manager.beginAuthenticationAsync(pairingUrl = "auth://pairing").await())
 
@@ -792,7 +779,7 @@ class FxaAccountManagerTest {
         assertNull(manager.accountProfile())
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
 
         manager.finishAuthenticationAsync("dummyCode", "dummyState").await()
 
@@ -828,15 +815,11 @@ class FxaAccountManagerTest {
         val mockAccount: OAuthAccount = mock()
         val constellation: DeviceConstellation = mock()
 
-        val exceptionalProfile = CompletableDeferred<Profile>()
-        val fxaException = FxaException("test exception")
-        exceptionalProfile.completeExceptionally(fxaException)
-
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(exceptionalProfile)
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(value = null))
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -880,7 +863,7 @@ class FxaAccountManagerTest {
         val profile = Profile(
             uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
 
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
 
         manager.updateProfileAsync().await()
 
@@ -897,15 +880,17 @@ class FxaAccountManagerTest {
         val mockAccount: OAuthAccount = mock()
         val constellation: DeviceConstellation = mock()
 
-        val exceptionalProfile = CompletableDeferred<Profile>()
-        val fxaException = FxaUnauthorizedException("401")
-        exceptionalProfile.completeExceptionally(fxaException)
-
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(exceptionalProfile)
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
+
+        `when`(mockAccount.getProfileAsync(anyBoolean())).then {
+            // Hit an auth error.
+            authErrorRegistry.notifyObservers { onAuthErrorAsync(AuthException(AuthExceptionType.UNAUTHORIZED)) }
+            CompletableDeferred(value = null)
+        }
+
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -951,10 +936,10 @@ class FxaAccountManagerTest {
         exceptionalProfile.completeExceptionally(fxaException)
 
         `when`(mockAccount.deviceConstellation()).thenReturn(constellation)
-        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(unitCompletedDeferrable())
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(exceptionalProfile)
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(constellation.initDeviceAsync(any(), any(), any())).thenReturn(CompletableDeferred(true))
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(exceptionalProfile)
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -994,10 +979,10 @@ class FxaAccountManagerTest {
         coroutineContext: CoroutineContext
     ): FxaAccountManager {
 
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.beginPairingFlow(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.beginPairingFlowAsync(anyString(), any())).thenReturn(CompletableDeferred("auth://url"))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -1024,17 +1009,13 @@ class FxaAccountManagerTest {
         profile: Profile,
         accountStorage: AccountStorage,
         accountObserver: AccountObserver,
-        fxaException: FxaException,
         coroutineContext: CoroutineContext
     ): FxaAccountManager {
-        `when`(mockAccount.getProfile(anyBoolean())).thenReturn(CompletableDeferred(profile))
-
-        // Pretend we have a network problem while initiating an auth flow.
-        val exceptionalDeferred = CompletableDeferred<String>()
-        exceptionalDeferred.completeExceptionally(fxaException)
-        `when`(mockAccount.beginOAuthFlow(any(), anyBoolean())).thenReturn(exceptionalDeferred)
-        `when`(mockAccount.beginPairingFlow(anyString(), any())).thenReturn(exceptionalDeferred)
-        `when`(mockAccount.completeOAuthFlow(anyString(), anyString())).thenReturn(unitCompletedDeferrable())
+        `when`(mockAccount.getProfileAsync(anyBoolean())).thenReturn(CompletableDeferred(profile))
+
+        `when`(mockAccount.beginOAuthFlowAsync(any(), anyBoolean())).thenReturn(CompletableDeferred(value = null))
+        `when`(mockAccount.beginPairingFlowAsync(anyString(), any())).thenReturn(CompletableDeferred(value = null))
+        `when`(mockAccount.completeOAuthFlowAsync(anyString(), anyString())).thenReturn(CompletableDeferred(true))
         // There's no account at the start.
         `when`(accountStorage.read()).thenReturn(null)
 
@@ -1055,13 +1036,4 @@ class FxaAccountManagerTest {
 
         return manager
     }
-}
-
-// This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
-// and threads will deadlock since it'll never be resolved while state machine is waiting for it.
-// So we manually complete it here.
-fun unitCompletedDeferrable(): CompletableDeferred<Unit> {
-    val d = CompletableDeferred<Unit>()
-    d.complete(Unit)
-    return d
 }
\ No newline at end of file
diff --git a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/UtilsKtTest.kt b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/UtilsKtTest.kt
index 1fa23ebd2d80..9f16dd5e62db 100644
--- a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/UtilsKtTest.kt
+++ b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/UtilsKtTest.kt
@@ -4,70 +4,188 @@
 
 package mozilla.components.service.fxa
 
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
+import mozilla.components.concept.sync.AuthException
+import mozilla.components.service.fxa.manager.AuthErrorObserver
+import mozilla.components.service.fxa.manager.authErrorRegistry
+import mozilla.components.support.test.mock
 import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNull
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
+import org.junit.Before
 import org.junit.Test
 
 class UtilsKtTest {
+    private class TestAuthErrorObserver : AuthErrorObserver {
+        var lastError: AuthException? = null
+
+        override fun onAuthErrorAsync(e: AuthException): Deferred<Unit> {
+            lastError = e
+            // unit completable starts off in a non-active state.
+            val done = CompletableDeferred<Unit>()
+            done.complete(Unit)
+            return done
+        }
+    }
+
+    @Before
+    fun cleanup() {
+        authErrorRegistry.unregisterObservers()
+    }
+
     @Test
-    fun `maybeExceptional returns correct data back`() {
-        assertEquals(1, maybeExceptional({
+    fun `handleFxaExceptions form 1 returns correct data back`() {
+        assertEquals(1, handleFxaExceptions(mock(), "test op", {
             1
-        }, {
-            fail()
-        }))
+        }, { fail() }, { fail() }))
 
-        assertEquals("Hello", maybeExceptional({
+        assertEquals("Hello", handleFxaExceptions(mock(), "test op", {
             "Hello"
-        }, {
-            fail()
-        }))
+        }, { fail() }, { fail() }))
     }
 
     @Test
-    fun `maybeExceptional does not swallow non-panics`() {
+    fun `handleFxaExceptions form 1 does not swallow non-panics`() {
+        val authErrorObserver = TestAuthErrorObserver()
+        authErrorRegistry.register(authErrorObserver)
+
         // Network.
-        assertEquals("pass!", maybeExceptional({
+        assertEquals("pass!", handleFxaExceptions(mock(), "test op", {
             throw FxaNetworkException("oops")
-        }, {
-            assertEquals("oops", it.message)
-            assertTrue(it is FxaNetworkException)
+        }, { "fail" }, { error ->
+            assertEquals("oops", error.message)
+            assertTrue(error is FxaNetworkException)
             "pass!"
         }))
 
-        assertEquals("pass!", maybeExceptional({
+        assertNull(authErrorObserver.lastError)
+
+        assertEquals("pass!", handleFxaExceptions(mock(), "test op", {
             throw FxaUnauthorizedException("auth!")
         }, {
-            assertEquals("auth!", it.message)
-            assertTrue(it is FxaUnauthorizedException)
             "pass!"
+        }, {
+            fail()
         }))
 
-        assertEquals("pass!", maybeExceptional({
+        assertEquals("auth!", (authErrorObserver.lastError as AuthException).cause!!.message)
+        assertTrue((authErrorObserver.lastError as AuthException).cause is FxaUnauthorizedException)
+
+        authErrorObserver.lastError = null
+        assertEquals("pass!", handleFxaExceptions(mock(), "test op", {
             throw FxaUnspecifiedException("dunno")
-        }, {
-            assertEquals("dunno", it.message)
-            assertTrue(it is FxaUnspecifiedException)
+        }, { "fail" }, { error ->
+            assertEquals("dunno", error.message)
+            assertTrue(error is FxaUnspecifiedException)
             "pass!"
         }))
+        assertNull(authErrorObserver.lastError)
     }
 
     @Test(expected = IllegalStateException::class)
-    fun `maybeExceptional re-throws non-fxa exceptions`() {
-        maybeExceptional({
+    fun `handleFxaExceptions form 1 re-throws non-fxa exceptions`() {
+        handleFxaExceptions(mock(), "test op", {
             throw IllegalStateException("bad state")
-        }, {
-            fail()
-        })
+        }, { fail() }, { fail() })
     }
 
     @Test(expected = FxaPanicException::class)
-    fun `maybeExceptional re-throws fxa panic exceptions`() {
-        maybeExceptional({
+    fun `handleFxaExceptions form 1 re-throws fxa panic exceptions`() {
+        handleFxaExceptions(mock(), "test op", {
             throw FxaPanicException("don't panic!")
-        }, {
-            fail()
+        }, { fail() }, { fail() })
+    }
+
+    @Test
+    fun `handleFxaExceptions form 2 works`() {
+        val authErrorObserver = TestAuthErrorObserver()
+        authErrorRegistry.register(authErrorObserver)
+
+        assertTrue(handleFxaExceptions(mock(), "test op") {
+            Unit
         })
+
+        assertFalse(handleFxaExceptions(mock(), "test op") {
+            throw FxaUnspecifiedException("dunno")
+        })
+
+        assertNull(authErrorObserver.lastError)
+
+        assertFalse(handleFxaExceptions(mock(), "test op") {
+            throw FxaUnauthorizedException("401")
+        })
+
+        assertEquals("401", (authErrorObserver.lastError as AuthException).cause!!.message)
+        assertTrue((authErrorObserver.lastError as AuthException).cause is FxaUnauthorizedException)
+
+        authErrorObserver.lastError = null
+
+        assertFalse(handleFxaExceptions(mock(), "test op") {
+            throw FxaNetworkException("dunno")
+        })
+
+        assertNull(authErrorObserver.lastError)
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `handleFxaExceptions form 2 re-throws non-fxa exceptions`() {
+        handleFxaExceptions(mock(), "test op") {
+            throw IllegalStateException("bad state")
+        }
+    }
+
+    @Test(expected = FxaPanicException::class)
+    fun `handleFxaExceptions form 2 re-throws fxa panic exceptions`() {
+        handleFxaExceptions(mock(), "test op") {
+            throw FxaPanicException("dunno")
+        }
+    }
+
+    @Test
+    fun `handleFxaExceptions form 3 works`() {
+        val authErrorObserver = TestAuthErrorObserver()
+        authErrorRegistry.register(authErrorObserver)
+
+        assertEquals(1, handleFxaExceptions(mock(), "test op", { 2 }) {
+            1
+        })
+
+        assertEquals(0, handleFxaExceptions(mock(), "test op", { 0 }) {
+            throw FxaUnspecifiedException("dunno")
+        })
+
+        assertNull(authErrorObserver.lastError)
+
+        assertEquals(-1, handleFxaExceptions(mock(), "test op", { -1 }) {
+            throw FxaUnauthorizedException("401")
+        })
+
+        assertEquals("401", (authErrorObserver.lastError as AuthException).cause!!.message)
+        assertTrue((authErrorObserver.lastError as AuthException).cause is FxaUnauthorizedException)
+
+        authErrorObserver.lastError = null
+
+        assertEquals("bad", handleFxaExceptions(mock(), "test op", { "bad" }) {
+            throw FxaNetworkException("dunno")
+        })
+
+        assertNull(authErrorObserver.lastError)
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `handleFxaExceptions form 3 re-throws non-fxa exceptions`() {
+        handleFxaExceptions(mock(), "test op", { "nope" }) {
+            throw IllegalStateException("bad state")
+        }
+    }
+
+    @Test(expected = FxaPanicException::class)
+    fun `handleFxaExceptions form 3 re-throws fxa panic exceptions`() {
+        handleFxaExceptions(mock(), "test op", { "nope" }) {
+            throw FxaPanicException("dunno")
+        }
     }
 }
\ No newline at end of file
diff --git a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/manager/PollingDeviceManagerTest.kt b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/manager/PollingDeviceManagerTest.kt
index ce65ebf60982..75ab11b0bd03 100644
--- a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/manager/PollingDeviceManagerTest.kt
+++ b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/manager/PollingDeviceManagerTest.kt
@@ -22,7 +22,9 @@ import mozilla.components.concept.sync.TabData
 import mozilla.components.support.base.observer.ObserverRegistry
 import mozilla.components.support.test.mock
 import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.mockito.Mockito.`when`
 import org.mockito.Mockito.never
@@ -65,7 +67,7 @@ class PollingDeviceManagerTest {
 
         // No events, no observers.
         `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(listOf()))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
 
         val eventsObserver = object : DeviceEventsObserver {
             var latestEvents: List<DeviceEvent>? = null
@@ -77,14 +79,14 @@ class PollingDeviceManagerTest {
 
         // No events, with an observer.
         manager.register(eventsObserver)
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
         assertEquals(listOf<DeviceEvent>(), eventsObserver.latestEvents)
 
         // Some events.
         `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(listOf(
             DeviceEvent.TabReceived(null, listOf())
         )))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
 
         var events = eventsObserver.latestEvents!!
         assertEquals(null, (events[0] as DeviceEvent.TabReceived).from)
@@ -100,7 +102,7 @@ class PollingDeviceManagerTest {
         `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(listOf(
             DeviceEvent.TabReceived(testDevice1, listOf())
         )))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
         assertNotNull(eventsObserver.latestEvents)
         assertEquals(1, eventsObserver.latestEvents!!.size)
         events = eventsObserver.latestEvents!!
@@ -111,7 +113,7 @@ class PollingDeviceManagerTest {
         `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(listOf(
             DeviceEvent.TabReceived(testDevice2, listOf(testTab1))
         )))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
 
         events = eventsObserver.latestEvents!!
         assertEquals(testDevice2, (events[0] as DeviceEvent.TabReceived).from)
@@ -121,7 +123,7 @@ class PollingDeviceManagerTest {
         `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(listOf(
                 DeviceEvent.TabReceived(testDevice2, listOf(testTab1, testTab3))
         )))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
 
         events = eventsObserver.latestEvents!!
         assertEquals(testDevice2, (events[0] as DeviceEvent.TabReceived).from)
@@ -132,13 +134,17 @@ class PollingDeviceManagerTest {
             DeviceEvent.TabReceived(testDevice2, listOf(testTab1, testTab2)),
             DeviceEvent.TabReceived(testDevice1, listOf(testTab3))
         )))
-        manager.pollAsync().await()
+        assertTrue(manager.pollAsync().await())
 
         events = eventsObserver.latestEvents!!
         assertEquals(testDevice2, (events[0] as DeviceEvent.TabReceived).from)
         assertEquals(listOf(testTab1, testTab2), (events[0] as DeviceEvent.TabReceived).entries)
         assertEquals(testDevice1, (events[1] as DeviceEvent.TabReceived).from)
         assertEquals(listOf(testTab3), (events[1] as DeviceEvent.TabReceived).entries)
+
+        // Failure to poll for events
+        `when`(constellation.pollForEventsAsync()).thenReturn(CompletableDeferred(value = null))
+        assertFalse(manager.pollAsync().await())
     }
 
     @Test
diff --git a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt b/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
index 1fc4d96c07b4..73ac7fd99701 100644
--- a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
+++ b/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
@@ -69,12 +69,16 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
                 val config = Config(CONFIG_URL, CLIENT_ID, REDIRECT_URL)
                 val acct = FirefoxAccount(config)
                 launch {
-                    try {
-                        val url = acct.beginPairingFlow(pairingUrl, scopes).await()
-                        openWebView(url)
-                    } catch (e: FxaException) {
-                        Log.log(Log.Priority.ERROR, "mozac-samples-fxa", e, "Pairing flow failed for $pairingUrl")
+                    val url = acct.beginPairingFlowAsync(pairingUrl, scopes).await()
+                    if (url == null) {
+                        Log.log(
+                            Log.Priority.ERROR,
+                            tag = "mozac-samples-fxa",
+                            message = "Pairing flow failed for $pairingUrl"
+                        )
+                        return@launch
                     }
+                    openWebView(url)
                 }
             }
         )
@@ -83,15 +87,17 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
 
         findViewById<View>(R.id.buttonCustomTabs).setOnClickListener {
             launch {
-                val url = account.beginOAuthFlow(scopes, wantsKeys).await()
-                openTab(url)
+                account.beginOAuthFlowAsync(scopes, wantsKeys).await()?.let {
+                    openTab(it)
+                }
             }
         }
 
         findViewById<View>(R.id.buttonWebView).setOnClickListener {
             launch {
-                val url = account.beginOAuthFlow(scopes, wantsKeys).await()
-                openWebView(url)
+                account.beginOAuthFlowAsync(scopes, wantsKeys).await()?.let {
+                    openWebView(it)
+                }
             }
         }
 
@@ -114,8 +120,9 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
     private fun initAccount(): FirefoxAccount {
         getAuthenticatedAccount()?.let {
             launch {
-                val profile = it.getProfile(true).await()
-                displayProfile(profile)
+                it.getProfileAsync(true).await()?.let {
+                    displayProfile(it)
+                }
             }
             return it
         }
@@ -179,9 +186,10 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
 
     private fun displayAndPersistProfile(code: String, state: String) {
         launch {
-            account.completeOAuthFlow(code, state).await()
-            val profile = account.getProfile().await()
-            displayProfile(profile)
+            account.completeOAuthFlowAsync(code, state).await()
+            account.getProfileAsync().await()?.let {
+                displayProfile(it)
+            }
             account.toJSONString().let {
                 getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE)
                         .edit().putString(FXA_STATE_KEY, it).apply()
diff --git a/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt b/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
index ef8fc16a623f..146bcb7ec93c 100644
--- a/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
+++ b/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
@@ -24,7 +24,6 @@ import mozilla.components.concept.sync.SyncStatusObserver
 import mozilla.components.service.fxa.manager.FxaAccountManager
 import mozilla.components.service.fxa.Config
 import mozilla.components.service.fxa.FirefoxAccount
-import mozilla.components.service.fxa.FxaException
 import mozilla.components.feature.sync.BackgroundSyncManager
 import mozilla.components.feature.sync.GlobalSyncableStoreProvider
 import mozilla.components.service.fxa.manager.DeviceTuple
@@ -93,10 +92,9 @@ class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener,
 
         findViewById<View>(R.id.buttonWebView).setOnClickListener {
             launch {
-                val authUrl = try {
-                    accountManager.beginAuthenticationAsync().await()
-                } catch (error: FxaException) {
-                    Toast.makeText(this@MainActivity, "Account auth error: $error", Toast.LENGTH_LONG).show()
+                val authUrl = accountManager.beginAuthenticationAsync().await()
+                if (authUrl == null) {
+                    Toast.makeText(this@MainActivity, "Account auth error", Toast.LENGTH_LONG).show()
                     return@launch
                 }
                 openWebView(authUrl)
diff --git a/android-components/samples/sync/src/main/java/org/mozilla/samples/sync/MainActivity.kt b/android-components/samples/sync/src/main/java/org/mozilla/samples/sync/MainActivity.kt
index 41692d94ef83..f7b4e9a9ec86 100644
--- a/android-components/samples/sync/src/main/java/org/mozilla/samples/sync/MainActivity.kt
+++ b/android-components/samples/sync/src/main/java/org/mozilla/samples/sync/MainActivity.kt
@@ -30,7 +30,6 @@ import mozilla.components.concept.sync.Profile
 import mozilla.components.concept.sync.SyncStatusObserver
 import mozilla.components.service.fxa.manager.FxaAccountManager
 import mozilla.components.service.fxa.Config
-import mozilla.components.service.fxa.FxaException
 import mozilla.components.feature.sync.BackgroundSyncManager
 import mozilla.components.feature.sync.GlobalSyncableStoreProvider
 import mozilla.components.service.fxa.manager.DeviceTuple
@@ -93,11 +92,10 @@ class MainActivity :
 
         findViewById<View>(R.id.buttonSignIn).setOnClickListener {
             launch {
-                val authUrl = try {
-                    accountManager.beginAuthenticationAsync().await()
-                } catch (error: FxaException) {
+                val authUrl = accountManager.beginAuthenticationAsync().await()
+                if (authUrl == null) {
                     val txtView: TextView = findViewById(R.id.fxaStatusView)
-                    txtView.text = getString(R.string.account_error, error.toString())
+                    txtView.text = getString(R.string.account_error, null)
                     return@launch
                 }
                 openWebView(authUrl)
