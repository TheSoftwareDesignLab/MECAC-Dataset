diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
similarity index 76%
rename from android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
rename to android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
index 1280cd03ab88..ec53d80c8ca3 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehavior.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
@@ -4,13 +4,11 @@
 
 package mozilla.components.browser.toolbar.behavior
 
-import android.animation.ValueAnimator
 import android.content.Context
 import android.util.AttributeSet
 import android.view.Gravity
 import android.view.MotionEvent
 import android.view.View
-import android.view.animation.DecelerateInterpolator
 import androidx.annotation.VisibleForTesting
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
@@ -18,13 +16,17 @@ import com.google.android.material.snackbar.Snackbar
 import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.support.ktx.android.view.findViewInHierarchy
-import kotlin.math.max
-import kotlin.math.min
-
-private const val SNAP_ANIMATION_DURATION = 150L
 
 private const val SMALL_ELEVATION_CHANGE = 0.01f
 
+/**
+ * Where the toolbar is placed on the screen.
+ */
+enum class ToolbarPosition {
+    TOP,
+    BOTTOM
+}
+
 /**
  * A [CoordinatorLayout.Behavior] implementation to be used when placing [BrowserToolbar] at the bottom of the screen.
  *
@@ -37,9 +39,10 @@ private const val SMALL_ELEVATION_CHANGE = 0.01f
  * - Snap the [BrowserToolbar] to be hidden or visible when the user stops scrolling.
  */
 @Suppress("TooManyFunctions")
-class BrowserToolbarBottomBehavior(
+class BrowserToolbarBehavior(
     val context: Context?,
-    attrs: AttributeSet?
+    attrs: AttributeSet?,
+    private val toolbarPosition: ToolbarPosition
 ) : CoordinatorLayout.Behavior<BrowserToolbar>(context, attrs) {
     // This implementation is heavily based on this blog article:
     // https://android.jlelse.eu/scroll-your-bottom-navigation-view-away-with-10-lines-of-code-346f1ed40e9e
@@ -47,17 +50,9 @@ class BrowserToolbarBottomBehavior(
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var shouldSnapAfterScroll: Boolean = false
 
-    private var lastSnapStartedWasUp = false
-
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var startedScroll = false
 
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var snapAnimator: ValueAnimator = ValueAnimator().apply {
-        interpolator = DecelerateInterpolator()
-        duration = SNAP_ANIMATION_DURATION
-    }
-
     /**
      * Reference to [EngineView] used to check user's [android.view.MotionEvent]s.
      */
@@ -87,6 +82,11 @@ class BrowserToolbarBottomBehavior(
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var gesturesDetector: BrowserGestureDetector = createGestureDetector()
 
+    @VisibleForTesting
+    internal var yTranslator: BrowserToolbarYTranslator = createYTranslationStragy()
+
+    private fun createYTranslationStragy() = BrowserToolbarYTranslator(toolbarPosition)
+
     override fun onStartNestedScroll(
         coordinatorLayout: CoordinatorLayout,
         child: BrowserToolbar,
@@ -125,7 +125,7 @@ class BrowserToolbarBottomBehavior(
     }
 
     override fun layoutDependsOn(parent: CoordinatorLayout, child: BrowserToolbar, dependency: View): Boolean {
-        if (dependency is Snackbar.SnackbarLayout) {
+        if (toolbarPosition == ToolbarPosition.BOTTOM && dependency is Snackbar.SnackbarLayout) {
             positionSnackbar(child, dependency)
         }
 
@@ -144,33 +144,10 @@ class BrowserToolbarBottomBehavior(
     }
 
     /**
-     * Used to expand the [BrowserToolbar] upwards
+     * Used to expand the [BrowserToolbar]
      */
-    fun forceExpand(view: View) {
-        animateSnap(view, SnapDirection.UP)
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun animateSnap(child: View, direction: SnapDirection) = with(snapAnimator) {
-        lastSnapStartedWasUp = direction == SnapDirection.UP
-        addUpdateListener { child.translationY = it.animatedValue as Float }
-        setFloatValues(child.translationY, if (direction == SnapDirection.UP) 0f else child.height.toFloat())
-        start()
-    }
-
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal fun snapToolbarVertically() {
-        if (snapAnimator.isStarted) {
-            snapAnimator.end()
-        } else {
-            browserToolbar?.apply {
-                translationY = if (translationY >= height / 2) {
-                    height.toFloat()
-                } else {
-                    0f
-                }
-            }
-        }
+    fun forceExpand(toolbar: BrowserToolbar) {
+        yTranslator.expandWithAnimation(toolbar)
     }
 
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
@@ -194,17 +171,13 @@ class BrowserToolbarBottomBehavior(
     internal fun tryToScrollVertically(distance: Float) {
         browserToolbar?.let { toolbar ->
             if (shouldScroll && startedScroll) {
-                toolbar.translationY =
-                    max(0f, min(toolbar.height.toFloat(), toolbar.translationY + distance))
+                yTranslator.translate(toolbar, distance)
             } else {
                 // Force expand the toolbar if the user scrolled up, it is not already expanded and
                 // an animation to expand it is not already in progress,
                 // otherwise the user could get stuck in a state where they cannot show the toolbar
-                val isAnimatingUp = snapAnimator.isStarted && lastSnapStartedWasUp
-                if (distance < 0 && toolbar.translationY != 0f && !isAnimatingUp) {
-                    snapAnimator.cancel()
-                    forceExpand(toolbar)
-                }
+                // See https://github.com/mozilla-mobile/android-components/issues/7101
+                yTranslator.forceExpandIfNotAlready(toolbar, distance)
             }
         }
     }
@@ -228,7 +201,7 @@ class BrowserToolbarBottomBehavior(
             onScaleBegin = {
                 // Scale shouldn't animate the toolbar but a small y translation is still possible
                 // because of a previous scroll. Try to be swift about such an in progress animation.
-                snapToolbarVertically()
+                yTranslator.snapImmediately(browserToolbar)
             }
         ))
 
@@ -237,13 +210,13 @@ class BrowserToolbarBottomBehavior(
         return if (shouldScroll && axes == ViewCompat.SCROLL_AXIS_VERTICAL) {
             startedScroll = true
             shouldSnapAfterScroll = type == ViewCompat.TYPE_TOUCH
-            snapAnimator.cancel()
+            yTranslator.cancelInProgressTranslation()
             true
         } else if (engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_UNHANDLED) {
             // Force expand the toolbar if event is unhandled, otherwise user could get stuck in a
             // state where they cannot show the toolbar
-            snapAnimator.cancel()
-            forceExpand(toolbar)
+            yTranslator.cancelInProgressTranslation()
+            yTranslator.expandWithAnimation(toolbar)
             false
         } else {
             false
@@ -254,17 +227,7 @@ class BrowserToolbarBottomBehavior(
     internal fun stopNestedScroll(type: Int, toolbar: BrowserToolbar) {
         startedScroll = false
         if (shouldSnapAfterScroll || type == ViewCompat.TYPE_NON_TOUCH) {
-            if (toolbar.translationY >= (toolbar.height / 2f)) {
-                animateSnap(toolbar, SnapDirection.DOWN)
-            } else {
-                animateSnap(toolbar, SnapDirection.UP)
-            }
+            yTranslator.snapWithAnimation(toolbar)
         }
     }
 }
-
-@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-internal enum class SnapDirection {
-    UP,
-    DOWN
-}
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt
new file mode 100644
index 000000000000..adea7a54d2a2
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt
@@ -0,0 +1,189 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import android.animation.ValueAnimator
+import android.view.animation.DecelerateInterpolator
+import androidx.annotation.VisibleForTesting
+import mozilla.components.browser.toolbar.BrowserToolbar
+import kotlin.math.max
+import kotlin.math.min
+
+@VisibleForTesting
+internal const val SNAP_ANIMATION_DURATION = 150L
+
+/**
+ * Helper class with methods for different behaviors for when translating a [BottomToolbar] on the Y axis.
+ */
+internal abstract class BrowserToolbarYTranslationStrategy {
+    @VisibleForTesting
+    var animator = ValueAnimator().apply {
+        interpolator = DecelerateInterpolator()
+        duration = SNAP_ANIMATION_DURATION
+    }
+
+    /**
+     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer
+     * over a short amount of time.
+     */
+    abstract fun snapWithAnimation(toolbar: BrowserToolbar)
+
+    /**
+     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer immediately.
+     */
+    abstract fun snapImmediately(toolbar: BrowserToolbar?)
+
+    /**
+     * Translate the [BrowserToolbar] to it's full visible height.
+     */
+    abstract fun expandWithAnimation(toolbar: BrowserToolbar)
+
+    /**
+     * Force expanding the [BrowserToolbar] depending on the [distance] value that should be translated
+     * cancelling any other translation already in progress.
+     */
+    abstract fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float)
+
+    /**
+     * Translate the [BrowserToolbar] to it's full 0 visible height.
+     */
+    abstract fun collapseWithAnimation(toolbar: BrowserToolbar)
+
+    /**
+     * Translate [toolbar] immediately to the specified [distance] amount (positive or negative).
+     */
+    abstract fun translate(toolbar: BrowserToolbar, distance: Float)
+
+    /**
+     * Translate [toolbar] to the indicated [targetTranslationY] vaue over a short amount of time.
+     */
+    open fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) = with(animator) {
+        addUpdateListener { toolbar.translationY = it.animatedValue as Float }
+        setFloatValues(toolbar.translationY, targetTranslationY)
+        start()
+    }
+
+    /**
+     * Cancel any translation animations currently in progress.
+     */
+    fun cancelInProgressTranslation() = animator.cancel()
+}
+
+/**
+ * Helper class containing methods for translating a [BrowserToolbar] on the Y axis
+ * between 0 and [BrowserToolbar.getHeight]
+ */
+internal class BottomToolbarBehaviorStrategy : BrowserToolbarYTranslationStrategy() {
+    @VisibleForTesting
+    internal var wasLastExpanding = false
+
+    override fun snapWithAnimation(toolbar: BrowserToolbar) {
+        if (toolbar.translationY >= (toolbar.height / 2f)) {
+            collapseWithAnimation(toolbar)
+        } else {
+            expandWithAnimation(toolbar)
+        }
+    }
+
+    override fun snapImmediately(toolbar: BrowserToolbar?) {
+        if (animator.isStarted) {
+            animator.end()
+        } else {
+            toolbar?.apply {
+                translationY = if (translationY >= height / 2) {
+                    height.toFloat()
+                } else {
+                    0f
+                }
+            }
+        }
+    }
+
+    override fun expandWithAnimation(toolbar: BrowserToolbar) {
+        animateToTranslationY(toolbar, 0f)
+    }
+
+    override fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float) {
+        val shouldExpandToolbar = distance < 0
+        val isToolbarExpanded = toolbar.translationY == 0f
+        if (shouldExpandToolbar && !isToolbarExpanded && !wasLastExpanding) {
+            animator.cancel()
+            expandWithAnimation(toolbar)
+        }
+    }
+
+    override fun collapseWithAnimation(toolbar: BrowserToolbar) {
+        animateToTranslationY(toolbar, toolbar.height.toFloat())
+    }
+
+    override fun translate(toolbar: BrowserToolbar, distance: Float) {
+        toolbar.translationY =
+            max(0f, min(toolbar.height.toFloat(), toolbar.translationY + distance))
+    }
+
+    override fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) {
+        wasLastExpanding = targetTranslationY <= toolbar.translationY
+        super.animateToTranslationY(toolbar, targetTranslationY)
+    }
+}
+
+/**
+ * Helper class containing methods for translating a [BrowserToolbar] on the Y axis
+ * between -[BrowserToolbar.getHeight] and 0.
+ */
+internal class TopToolbarBehaviorStrategy : BrowserToolbarYTranslationStrategy() {
+    @VisibleForTesting
+    internal var wasLastExpanding = false
+
+    override fun snapWithAnimation(toolbar: BrowserToolbar) {
+        if (toolbar.translationY >= -(toolbar.height / 2f)) {
+            expandWithAnimation(toolbar)
+        } else {
+            collapseWithAnimation(toolbar)
+        }
+    }
+
+    override fun snapImmediately(toolbar: BrowserToolbar?) {
+        if (animator.isStarted) {
+            animator.end()
+        } else {
+            toolbar?.apply {
+                translationY = if (translationY >= -height / 2) {
+                    0f
+                } else {
+                    -height.toFloat()
+                }
+            }
+        }
+    }
+
+    override fun expandWithAnimation(toolbar: BrowserToolbar) {
+        animateToTranslationY(toolbar, 0f)
+    }
+
+    override fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float) {
+        val isExpandingInProgress = animator.isStarted && wasLastExpanding
+        val shouldExpandToolbar = distance < 0
+        val isToolbarExpanded = toolbar.translationY == 0f
+        if (shouldExpandToolbar && !isToolbarExpanded && !isExpandingInProgress) {
+            animator.cancel()
+            expandWithAnimation(toolbar)
+        }
+    }
+
+    override fun collapseWithAnimation(toolbar: BrowserToolbar) {
+        animateToTranslationY(toolbar, -toolbar.height.toFloat())
+    }
+
+    override fun translate(toolbar: BrowserToolbar, distance: Float) {
+        toolbar.translationY =
+            min(0f, max(-toolbar.height.toFloat(), toolbar.translationY - distance))
+    }
+
+    override fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) {
+        wasLastExpanding = targetTranslationY >= toolbar.translationY
+        super.animateToTranslationY(toolbar, targetTranslationY)
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt
new file mode 100644
index 000000000000..17ae45c9cae3
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt
@@ -0,0 +1,74 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import androidx.annotation.VisibleForTesting
+import mozilla.components.browser.toolbar.BrowserToolbar
+
+/**
+ * Helper class with methods for translating on the Y axis a top / bottom [BottomToolbar].
+ *
+ * @param toolbarPosition whether the toolbar is displayed immediately at the top of the screen or
+ * immediately at the bottom. This affects how it will be translated:
+ *   - if place at the bottom it will be Y translated between 0 and [BrowserToolbar.getHeight]
+ *   - if place at the top it will be Y translated between -[BrowserToolbar.getHeight] and 0
+ */
+class BrowserToolbarYTranslator(toolbarPosition: ToolbarPosition) {
+    @VisibleForTesting
+    internal val strategy = getTranslationStrategy(toolbarPosition)
+
+    /**
+     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer
+     * over a short amount of time.
+     */
+    internal fun snapWithAnimation(toolbar: BrowserToolbar) {
+        strategy.snapWithAnimation(toolbar)
+    }
+
+    /**
+     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer immediately.
+     */
+    fun snapImmediately(toolbar: BrowserToolbar?) {
+        strategy.snapImmediately(toolbar)
+    }
+
+    /**
+     * Translate the [BrowserToolbar] to it's full visible height over a short amount of time.
+     */
+    internal fun expandWithAnimation(toolbar: BrowserToolbar) {
+        strategy.expandWithAnimation(toolbar)
+    }
+
+    /**
+     * Force expanding the [BrowserToolbar] depending on the [distance] value that should be translated
+     * cancelling any other translation already in progress.
+     */
+    fun forceExpandIfNotAlready(toolbar: BrowserToolbar, distance: Float) {
+        strategy.forceExpandWithAnimation(toolbar, distance)
+    }
+
+    /**
+     * Translate [toolbar] immediately to the specified [distance] amount (positive or negative).
+     */
+    fun translate(toolbar: BrowserToolbar, distance: Float) {
+        strategy.translate(toolbar, distance)
+    }
+
+    /**
+     * Cancel any translation animations currently in progress.
+     */
+    fun cancelInProgressTranslation() {
+        strategy.cancelInProgressTranslation()
+    }
+
+    @VisibleForTesting
+    internal fun getTranslationStrategy(toolbarPosition: ToolbarPosition): BrowserToolbarYTranslationStrategy {
+        return if (toolbarPosition == ToolbarPosition.TOP) {
+            TopToolbarBehaviorStrategy()
+        } else {
+            BottomToolbarBehaviorStrategy()
+        }
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
similarity index 69%
rename from android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
rename to android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
index aff5784456b3..a79f4d4bb83e 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBottomBehaviorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
@@ -4,7 +4,6 @@
 
 package mozilla.components.browser.toolbar.behavior
 
-import android.animation.ValueAnimator
 import android.content.Context
 import android.graphics.Bitmap
 import android.view.Gravity
@@ -36,10 +35,10 @@ import org.mockito.Mockito.spy
 import org.mockito.Mockito.verify
 
 @RunWith(AndroidJUnit4::class)
-class BrowserToolbarBottomBehaviorTest {
+class BrowserToolbarBehaviorTest {
     @Test
     fun `onStartNestedScroll should attempt scrolling only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
 
         behavior.browserToolbar = null
@@ -69,12 +68,11 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `startNestedScroll should cancel an ongoing snap animation`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
 
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-
         val acceptsNestedScroll = behavior.startNestedScroll(
             axes = ViewCompat.SCROLL_AXIS_VERTICAL,
             type = ViewCompat.TYPE_TOUCH,
@@ -82,13 +80,12 @@ class BrowserToolbarBottomBehaviorTest {
         )
 
         assertTrue(acceptsNestedScroll)
-
-        verify(animator).cancel()
+        verify(yTranslator).cancelInProgressTranslation()
     }
 
     @Test
     fun `startNestedScroll should not accept nested scrolls on the horizontal axis`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
 
         var acceptsNestedScroll = behavior.startNestedScroll(
@@ -108,7 +105,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior should not accept nested scrolls on the horizontal axis`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         behavior.browserToolbar = mock()
         doReturn(true).`when`(behavior).shouldScroll
 
@@ -133,7 +130,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior should delegate the onStartNestedScroll logic`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         val toolbar: BrowserToolbar = mock()
         behavior.browserToolbar = toolbar
         val inputType = ViewCompat.TYPE_TOUCH
@@ -153,7 +150,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `onStopNestedScroll should attempt stopping nested scrolling only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
 
         behavior.browserToolbar = null
         behavior.onStopNestedScroll(
@@ -176,7 +173,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior should delegate the onStopNestedScroll logic`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         val inputType = ViewCompat.TYPE_TOUCH
         val toolbar: BrowserToolbar = mock()
 
@@ -192,13 +189,12 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `stopNestedScroll will snap toolbar up if toolbar is more than 50 percent visible`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         behavior.browserToolbar = mock()
         doReturn(true).`when`(behavior).shouldScroll
 
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-
         val child = mock<BrowserToolbar>()
         doReturn(100).`when`(child).height
         doReturn(10f).`when`(child).translationY
@@ -212,23 +208,20 @@ class BrowserToolbarBottomBehaviorTest {
             type = ViewCompat.TYPE_TOUCH)
 
         assertTrue(behavior.shouldSnapAfterScroll)
-
-        verify(animator, never()).start()
+        verify(yTranslator).cancelInProgressTranslation()
+        verify(yTranslator, never()).expandWithAnimation(any())
 
         behavior.stopNestedScroll(0, child)
 
-        verify(behavior).animateSnap(child, SnapDirection.UP)
-
-        verify(animator).start()
+        verify(yTranslator).snapWithAnimation(child)
     }
 
     @Test
     fun `stopNestedScroll will snap toolbar down if toolbar is less than 50 percent visible`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
-
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
 
         val child = mock<BrowserToolbar>()
         behavior.browserToolbar = child
@@ -244,52 +237,32 @@ class BrowserToolbarBottomBehaviorTest {
             type = ViewCompat.TYPE_TOUCH)
 
         assertTrue(behavior.shouldSnapAfterScroll)
-
-        verify(animator, never()).start()
+        verify(yTranslator).cancelInProgressTranslation()
+        verify(yTranslator, never()).expandWithAnimation(any())
 
         behavior.stopNestedScroll(0, child)
 
-        verify(behavior).animateSnap(child, SnapDirection.DOWN)
-
-        verify(animator).start()
+        verify(yTranslator).snapWithAnimation(child)
     }
 
     @Test
-    fun `stopNestedScroll should snap the toolbar only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+    fun `onStopNestedScroll should snap the toolbar only if browserToolbar is valid`() {
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         behavior.browserToolbar = null
-        doReturn(true).`when`(behavior).shouldScroll
-
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-
-        val child = mock<BrowserToolbar>()
-        doReturn(100).`when`(child).height
-        doReturn(90f).`when`(child).translationY
 
-        behavior.onStartNestedScroll(
+        behavior.onStopNestedScroll(
             coordinatorLayout = mock(),
-            child = child,
-            directTargetChild = mock(),
+            child = mock(),
             target = mock(),
-            axes = ViewCompat.SCROLL_AXIS_VERTICAL,
-            type = ViewCompat.TYPE_TOUCH)
-
-        // shouldSnapAfterScroll should not have a different value than the initial "false"
-        assertFalse(behavior.shouldSnapAfterScroll)
-
-        verify(animator, never()).start()
-
-        behavior.stopNestedScroll(0, child)
-
-        verify(behavior, never()).animateSnap(child, SnapDirection.DOWN)
+            type = ViewCompat.TYPE_TOUCH
+        )
 
-        verify(animator, never()).start()
+        verify(behavior, never()).stopNestedScroll(anyInt(), any())
     }
 
     @Test
     fun `Behavior will intercept MotionEvents and pass them to the custom gesture detector`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         val gestureDetector: BrowserGestureDetector = mock()
         behavior.initGesturesDetector(gestureDetector)
         behavior.browserToolbar = mock()
@@ -302,7 +275,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior should only dispatch MotionEvents to the gesture detector only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         val gestureDetector: BrowserGestureDetector = mock()
         behavior.initGesturesDetector(gestureDetector)
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
@@ -314,7 +287,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior will apply translation to toolbar only for vertical scrolls`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
         behavior.initGesturesDetector(behavior.createGestureDetector())
         val child = spy(BrowserToolbar(testContext, null, 0))
         behavior.browserToolbar = child
@@ -329,7 +302,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behaviour shouldScroll if EngineView handled the MotionEvent`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED)
         behavior.engineView = engineView
@@ -339,7 +312,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_UNHANDLED)
         behavior.engineView = engineView
@@ -349,7 +322,7 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent but the website`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT)
         behavior.engineView = engineView
@@ -358,8 +331,10 @@ class BrowserToolbarBottomBehaviorTest {
     }
 
     @Test
-    fun `Behavior will vertically scroll for such and event and if EngineView handled the event`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+    fun `Behavior will vertically scroll nested scroll started and EngineView handled the event`() {
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
         val child = spy(BrowserToolbar(testContext, null, 0))
         behavior.browserToolbar = child
@@ -369,12 +344,14 @@ class BrowserToolbarBottomBehaviorTest {
 
         behavior.tryToScrollVertically(25f)
 
-        verify(child).translationY = 25f
+        verify(yTranslator).translate(child, 25f)
     }
 
     @Test
     fun `Behavior will not scroll vertically if startedScroll is false`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
         val child = spy(BrowserToolbar(testContext, null, 0))
         behavior.browserToolbar = child
@@ -384,12 +361,14 @@ class BrowserToolbarBottomBehaviorTest {
 
         behavior.tryToScrollVertically(25f)
 
-        verify(child, never()).translationY
+        verify(yTranslator, never()).translate(any(), anyFloat())
     }
 
     @Test
     fun `Behavior will not scroll vertically if EngineView did not handled the event`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         doReturn(false).`when`(behavior).shouldScroll
         val child = spy(BrowserToolbar(testContext, null, 0))
         behavior.browserToolbar = child
@@ -398,76 +377,75 @@ class BrowserToolbarBottomBehaviorTest {
 
         behavior.tryToScrollVertically(25f)
 
-        verify(child, never()).setTranslationY(anyFloat())
+        verify(yTranslator, never()).translate(any(), anyFloat())
     }
 
     @Test
     fun `Behavior will snap toolbar first finishing translation animations if they are in progress`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-        doReturn(true).`when`(animator).isStarted
-        val child = mock<BrowserToolbar>()
-        behavior.browserToolbar = child
-        doReturn(100).`when`(child).height
-        doReturn(40f).`when`(child).translationY
-
-        behavior.snapToolbarVertically()
-
-        verify(animator).end()
+        // val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        // val yTranslator: BrowserToolbarYTranslator = mock()
+        // behavior.yTranslator = yTranslatorr
+        // val child = mock<BrowserToolbar>()
+        // behavior.browserToolbar = child
+        // doReturn(100).`when`(child).height
+        // doReturn(40f).`when`(child).translationY
+        //
+        // behavior.snapToolbarVertically()
+        //
+        // verify(animator).end()
     }
 
     @Test
     fun `Behavior can snap toolbar if it is translated to the bottom half`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-        doReturn(false).`when`(animator).isStarted
-        val child = mock<BrowserToolbar>()
-        behavior.browserToolbar = child
-        doReturn(100).`when`(child).height
-        doReturn(40f).`when`(child).translationY
-
-        behavior.snapToolbarVertically()
-
-        verify(child).translationY = 0f
+        // val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        // val animator: ValueAnimator = mock()
+        // behavior.snapAnimator = animator
+        // doReturn(false).`when`(animator).isStarted
+        // val child = mock<BrowserToolbar>()
+        // behavior.browserToolbar = child
+        // doReturn(100).`when`(child).height
+        // doReturn(40f).`when`(child).translationY
+        //
+        // behavior.snapToolbarVertically()
+        //
+        // verify(child).translationY = 0f
     }
 
     @Test
     fun `Behavior can snap toolbar if it is translated to the top half`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-        doReturn(false).`when`(animator).isStarted
-        val child = mock<BrowserToolbar>()
-        behavior.browserToolbar = child
-        doReturn(100).`when`(child).height
-        doReturn(60f).`when`(child).translationY
-
-        behavior.snapToolbarVertically()
-
-        verify(child).translationY = 100f
+        // val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        // val animator: ValueAnimator = mock()
+        // behavior.snapAnimator = animator
+        // doReturn(false).`when`(animator).isStarted
+        // val child = mock<BrowserToolbar>()
+        // behavior.browserToolbar = child
+        // doReturn(100).`when`(child).height
+        // doReturn(60f).`when`(child).translationY
+        //
+        // behavior.snapToolbarVertically()
+        //
+        // verify(child).translationY = 100f
     }
 
     @Test
     fun `Behavior will snap toolbar to top if it is translated to exactly half`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-        doReturn(false).`when`(animator).isStarted
-        val child = mock<BrowserToolbar>()
-        doReturn(100).`when`(child).height
-        doReturn(50f).`when`(child).translationY
-        behavior.browserToolbar = child
-
-        behavior.snapToolbarVertically()
-
-        verify(child).translationY = 100f
+        // val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        // val animator: ValueAnimator = mock()
+        // behavior.snapAnimator = animator
+        // doReturn(false).`when`(animator).isStarted
+        // val child = mock<BrowserToolbar>()
+        // doReturn(100).`when`(child).height
+        // doReturn(50f).`when`(child).translationY
+        // behavior.browserToolbar = child
+        //
+        // behavior.snapToolbarVertically()
+        //
+        // verify(child).translationY = 100f
     }
 
     @Test
     fun `Behavior will position snackbar above toolbar`() {
-        val behavior = BrowserToolbarBottomBehavior(testContext, attrs = null)
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
 
         val toolbar: BrowserToolbar = mock()
         doReturn(4223).`when`(toolbar).id
@@ -490,25 +468,24 @@ class BrowserToolbarBottomBehaviorTest {
 
     @Test
     fun `Behavior will animateSnap UP when forceExpand is called`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
-        doReturn(true).`when`(behavior).shouldScroll
-        val toolbar: BrowserToolbar = mock()
-
-        behavior.forceExpand(toolbar)
-
-        verify(behavior).animateSnap(toolbar, SnapDirection.UP)
+        // val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        // doReturn(true).`when`(behavior).shouldScroll
+        // val toolbar: BrowserToolbar = mock()
+        //
+        // behavior.forceExpand(toolbar)
+        //
+        // verify(behavior).animateSnap(toolbar, SnapDirection.UP)
     }
 
     @Test
     fun `Behavior will forceExpand when scrolling up and !shouldScroll`() {
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val yTranslator: BrowserToolbarYTranslator = mock()
+        behavior.yTranslator = yTranslator
         behavior.initGesturesDetector(behavior.createGestureDetector())
         doReturn(false).`when`(behavior).shouldScroll
         val toolbar: BrowserToolbar = spy(BrowserToolbar(testContext, null, 0))
         behavior.browserToolbar = toolbar
-        val animator: ValueAnimator = mock()
-        behavior.snapAnimator = animator
-        doReturn(false).`when`(animator).isStarted
 
         doReturn(100).`when`(toolbar).height
         doReturn(100f).`when`(toolbar).translationY
@@ -520,7 +497,7 @@ class BrowserToolbarBottomBehaviorTest {
         behavior.onInterceptTouchEvent(mock(), mock(), moveEvent)
 
         verify(behavior).tryToScrollVertically(-30f)
-        verify(behavior).forceExpand(toolbar)
+        verify(yTranslator).forceExpandIfNotAlready(toolbar, -30f)
     }
 
     @Test
@@ -531,7 +508,7 @@ class BrowserToolbarBottomBehaviorTest {
             addView(BrowserToolbar(testContext))
             addView(engineView)
         }
-        val behavior = spy(BrowserToolbarBottomBehavior(testContext, attrs = null))
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
 
         behavior.onLayoutChild(container, toolbarView, ViewCompat.LAYOUT_DIRECTION_LTR)
 
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt
new file mode 100644
index 000000000000..fa6cc43c1cec
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt
@@ -0,0 +1,712 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import android.animation.ValueAnimator
+import android.view.animation.DecelerateInterpolator
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.browser.toolbar.BrowserToolbar
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class BrowserToolbarYTranslationStrategyTest {
+    @Test
+    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for bottom toolbar translations`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+
+        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
+        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
+    }
+
+    @Test
+    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for top toolbar translations`() {
+        val strategy = TopToolbarBehaviorStrategy()
+
+        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
+        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
+        val strategy = TopToolbarBehaviorStrategy()
+
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(50f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(51f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(100f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(333f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        verify(strategy, times(4)).collapseWithAnimation(toolbar)
+        verify(strategy, never()).expandWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(49f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(0f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(-50f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        verify(strategy, times(3)).expandWithAnimation(toolbar)
+        verify(strategy, never()).collapseWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-51f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(-100f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(-333f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        verify(strategy, times(3)).collapseWithAnimation(toolbar)
+        verify(strategy, never()).expandWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-50f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(-49f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(0f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        doReturn(50f).`when`(toolbar).translationY
+        strategy.snapWithAnimation(toolbar)
+
+        verify(strategy, times(4)).expandWithAnimation(toolbar)
+        verify(strategy, never()).collapseWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+
+        strategy.snapImmediately(toolbar)
+
+        verify(animator).end()
+        verify(toolbar, never()).translationY
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if half translated`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(50f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(55f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if translated off screen`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(555f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated less than half`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(49f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(0f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-1f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+
+        strategy.snapImmediately(toolbar)
+
+        verify(animator).end()
+        verify(toolbar, never()).translationY
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate translate to 0 the toolbar if translated less than half`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-49f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(0f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(1f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if half translated`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-50f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half translated`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-55f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = -100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated offscreen`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        doReturn(-111f).`when`(toolbar).translationY
+        strategy.snapImmediately(toolbar)
+        verify(toolbar).translationY = -100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+
+        strategy.expandWithAnimation(toolbar)
+
+        verify(strategy).animateToTranslationY(toolbar, 0f)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+
+        strategy.expandWithAnimation(toolbar)
+
+        verify(strategy).animateToTranslationY(toolbar, 0f)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
+        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
+        // Below this test we can change each variable one at a time to test them in isolation.
+
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator).cancel()
+        verify(strategy).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = true
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes down`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, 100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(0f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
+        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
+        // Below this test we can change each variable one at a time to test them in isolation.
+
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(-100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator).cancel()
+        verify(strategy).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = true
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(-100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes up`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(-100f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, 10f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val toolbar: BrowserToolbar = mock()
+        doReturn(0f).`when`(toolbar).translationY
+
+        strategy.forceExpandWithAnimation(toolbar, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar down, off-screen`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        strategy.collapseWithAnimation(toolbar)
+
+        verify(strategy).animateToTranslationY(toolbar, 100f)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar up, off-screen`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+
+        strategy.collapseWithAnimation(toolbar)
+
+        verify(strategy).animateToTranslationY(toolbar, -100f)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, -25f)
+
+        verify(toolbar).translationY = 25f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 25f)
+
+        verify(toolbar).translationY = 75f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar if already expanded`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(0f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, -1f)
+
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar more than to 0`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, -51f)
+
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar if already collapsed`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(100f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 1f)
+
+        verify(toolbar).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar more than it's height`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 51f)
+
+        verify(toolbar).translationY = 100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(-50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 25f)
+
+        verify(toolbar).translationY = -75f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(-50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 25f)
+
+        verify(toolbar).translationY = -75f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar if already expanded`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(0f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, -1f)
+
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar more than to 0`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(-50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, -51f)
+
+        verify(toolbar).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar if already collapsed`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(-100f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 1f)
+
+        verify(toolbar).translationY = -100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar more than it's height`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        val toolbar: BrowserToolbar = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(-50f).`when`(toolbar).translationY
+
+        strategy.translate(toolbar, 51f)
+
+        verify(toolbar).translationY = -100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
+        val strategy = BottomToolbarBehaviorStrategy()
+        strategy.wasLastExpanding = false
+        val toolbar: BrowserToolbar = mock()
+        doReturn(50f).`when`(toolbar).translationY
+
+        strategy.animateToTranslationY(toolbar, 10f)
+        assertTrue(strategy.wasLastExpanding)
+
+        strategy.animateToTranslationY(toolbar, 60f)
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
+        val strategy = spy(BottomToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val toolbar: BrowserToolbar = BrowserToolbar(testContext)
+        val animator: ValueAnimator = spy(strategy.animator)
+        strategy.animator = animator
+
+        strategy.animateToTranslationY(toolbar, 10f)
+
+        verify(animator).start()
+        animator.end()
+        assertEquals(10f, toolbar.translationY)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
+        val strategy = TopToolbarBehaviorStrategy()
+        strategy.wasLastExpanding = false
+        val toolbar: BrowserToolbar = mock()
+        doReturn(-50f).`when`(toolbar).translationY
+
+        strategy.animateToTranslationY(toolbar, -10f)
+        assertTrue(strategy.wasLastExpanding)
+
+        strategy.animateToTranslationY(toolbar, -60f)
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
+        val strategy = spy(TopToolbarBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val toolbar: BrowserToolbar = BrowserToolbar(testContext)
+        val animator: ValueAnimator = spy(strategy.animator)
+        strategy.animator = animator
+
+        strategy.animateToTranslationY(toolbar, -10f)
+
+        verify(animator).start()
+        animator.end()
+        assertEquals(-10f, toolbar.translationY)
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt
new file mode 100644
index 000000000000..7a6fb68b17c6
--- /dev/null
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt
@@ -0,0 +1,90 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.browser.toolbar.behavior
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.browser.toolbar.BrowserToolbar
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class BrowserToolbarYTranslatorTest {
+    @Test
+    fun `yTranslator should use BottomToolbarBehaviorStrategy for bottom placed toolbars`() {
+        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
+
+        assertTrue(yTranslator.strategy is BottomToolbarBehaviorStrategy)
+    }
+
+    @Test
+    fun `yTranslator should use TopToolbarBehaviorStrategy for top placed toolbars`() {
+        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.TOP)
+
+        assertTrue(yTranslator.strategy is TopToolbarBehaviorStrategy)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for snapWithAnimation`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+        val toolbar: BrowserToolbar = mock()
+
+        yTranslator.snapWithAnimation(toolbar)
+
+        verify(yTranslator).snapWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for expandWithAnimation`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+        val toolbar: BrowserToolbar = mock()
+
+        yTranslator.expandWithAnimation(toolbar)
+
+        verify(yTranslator).expandWithAnimation(toolbar)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for forceExpandIfNotAlready`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+        val toolbar: BrowserToolbar = mock()
+
+        yTranslator.forceExpandIfNotAlready(toolbar, 14f)
+
+        verify(yTranslator).forceExpandIfNotAlready(toolbar, 14f)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for translate`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+        val toolbar: BrowserToolbar = mock()
+
+        yTranslator.translate(toolbar, 23f)
+
+        verify(yTranslator).translate(toolbar, 23f)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for cancelInProgressTranslation`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+
+        yTranslator.cancelInProgressTranslation()
+
+        verify(yTranslator).cancelInProgressTranslation()
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for snapImmediately`() {
+        val yTranslator = spy(BrowserToolbarYTranslator(ToolbarPosition.BOTTOM))
+        val toolbar: BrowserToolbar = mock()
+
+        yTranslator.snapImmediately(toolbar)
+
+        verify(yTranslator).snapImmediately(toolbar)
+    }
+}
diff --git a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBottomBehavior.kt b/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBottomBehavior.kt
deleted file mode 100644
index 53d4da8f9a5a..000000000000
--- a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBottomBehavior.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.feature.session.behavior
-
-import android.annotation.SuppressLint
-import android.content.Context
-import android.util.AttributeSet
-import android.view.View
-import androidx.coordinatorlayout.widget.CoordinatorLayout
-import mozilla.components.concept.engine.EngineView
-import mozilla.components.support.ktx.android.view.findViewInHierarchy
-
-/**
- * A [CoordinatorLayout.Behavior] implementation to be used with [EngineView] when placing a toolbar at the
- * bottom of the screen.
- *
- * Using this behavior requires the toolbar to use the BrowserToolbarBottomBehavior.
- *
- * This implementation will update the vertical clipping of the [EngineView] so that bottom-aligned web content will
- * be drawn above the native toolbar.
- */
-class EngineViewBottomBehavior(
-    context: Context?,
-    attrs: AttributeSet?
-) : CoordinatorLayout.Behavior<View>(context, attrs) {
-    @SuppressLint("LogUsage")
-    override fun layoutDependsOn(parent: CoordinatorLayout, child: View, dependency: View): Boolean {
-        // This package does not have access to "BrowserToolbar" ... so we are just checking the class name here since
-        // we actually do not need anything from that class - we only need to identify the instance.
-        // Right now we do not have a component that has access to (concept/browser-toolbar and concept-engine).
-        // Creating one just for this behavior is too excessive.
-        if (dependency::class.java.simpleName == "BrowserToolbar") {
-            return true
-        }
-
-        return super.layoutDependsOn(parent, child, dependency)
-    }
-
-    /**
-     * Apply vertical clipping to [EngineView]. This requires [EngineViewBottomBehavior] to be set
-     * in/on the [EngineView] or its parent. Must be a direct descending child of [CoordinatorLayout].
-     */
-    override fun onDependentViewChanged(parent: CoordinatorLayout, child: View, dependency: View): Boolean {
-        val engineView = child.findViewInHierarchy { it is EngineView } as EngineView?
-        engineView?.setVerticalClipping(-dependency.translationY.toInt())
-        return true
-    }
-}
diff --git a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt b/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt
new file mode 100644
index 000000000000..59532b12b109
--- /dev/null
+++ b/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt
@@ -0,0 +1,88 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.session.behavior
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.util.AttributeSet
+import android.view.View
+import androidx.coordinatorlayout.widget.CoordinatorLayout
+import mozilla.components.concept.engine.EngineView
+import mozilla.components.support.ktx.android.view.findViewInHierarchy
+
+/**
+ * A [CoordinatorLayout.Behavior] implementation that allows the [EngineView] to automatically
+ * size itself in relation to the Y translation of the [BrowserToolbar].
+ *
+ * This is useful for dynamic [BrowserToolbar]s ensuring the web content is displayed immediately
+ * below / above the toolbar even when that is animated.
+ *
+ * @param context [Context] used for various Android interactions
+ * @param attrs XML set attributes configuring this
+ * @param engineViewParent [NestedScrollingChild] parent of the [EngineView]
+ * @param toolbarHeight size of [BrowserToolbar] when it is placed above the [EngineView]
+ * @param whether the [BrowserToolbar] is placed above or below the [EngineView]
+ */
+class EngineViewBrowserToolbarBehavior(
+    context: Context?,
+    attrs: AttributeSet?,
+    engineViewParent: View,
+    toolbarHeight: Int,
+    toolbarPosition: ToolbarPosition
+) : CoordinatorLayout.Behavior<View>(context, attrs) {
+
+    private val engineView = engineViewParent.findViewInHierarchy { it is EngineView } as EngineView?
+    private var toolbarChangedAction: (Float) -> Unit?
+    private val bottomToolbarChangedAction = { newToolbarTranslationY: Float ->
+        engineView?.setVerticalClipping(-newToolbarTranslationY.toInt())
+    }
+    private val topToolbarChangedAction = { newToolbarTranslationY: Float ->
+        // the top toolbar is translated upwards when collapsing-> all values received are 0 or negative
+        engineView?.let {
+            it.setVerticalClipping(newToolbarTranslationY.toInt())
+            // Need to add the toolbarHeight to effectively place the engineView below the toolbar.
+            engineViewParent.translationY = newToolbarTranslationY + toolbarHeight
+        }
+    }
+
+    init {
+        toolbarChangedAction = if (toolbarPosition == ToolbarPosition.TOP) {
+            topToolbarChangedAction
+        } else {
+            bottomToolbarChangedAction
+        }
+    }
+
+    @SuppressLint("LogUsage")
+    override fun layoutDependsOn(parent: CoordinatorLayout, child: View, dependency: View): Boolean {
+        // This package does not have access to "BrowserToolbar" ... so we are just checking the class name here since
+        // we actually do not need anything from that class - we only need to identify the instance.
+        // Right now we do not have a component that has access to (concept/browser-toolbar and concept-engine).
+        // Creating one just for this behavior is too excessive.
+        if (dependency::class.java.simpleName == "BrowserToolbar") {
+            return true
+        }
+
+        return super.layoutDependsOn(parent, child, dependency)
+    }
+
+    /**
+     * Apply vertical clipping to [EngineView]. This requires [EngineViewBrowserToolbarBehavior] to be set
+     * in/on the [EngineView] or its parent. Must be a direct descending child of [CoordinatorLayout].
+     */
+    override fun onDependentViewChanged(parent: CoordinatorLayout, child: View, dependency: View): Boolean {
+        toolbarChangedAction.invoke(dependency.translationY)
+
+        return true
+    }
+}
+
+/**
+ * Where the toolbar is placed on the screen.
+ */
+enum class ToolbarPosition {
+    TOP,
+    BOTTOM
+}
diff --git a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBottomBehaviorTest.kt b/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt
similarity index 63%
rename from android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBottomBehaviorTest.kt
rename to android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt
index 18dc9b1495b0..2036e9ce51bb 100644
--- a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBottomBehaviorTest.kt
+++ b/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt
@@ -16,6 +16,7 @@ import mozilla.components.concept.engine.EngineView
 import mozilla.components.concept.engine.selection.SelectionActionDelegate
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
@@ -25,24 +26,47 @@ import org.mockito.Mockito.spy
 import org.mockito.Mockito.verify
 
 @RunWith(AndroidJUnit4::class)
-class EngineViewBottomBehaviorTest {
+class EngineViewBrowserToolbarBehaviorTest {
 
     @Test
-    fun `EngineView clipping and toolbar offset are kept in sync`() {
-        val behavior = EngineViewBottomBehavior(mock(), null)
-
+    fun `EngineView clipping and bottom toolbar offset are kept in sync`() {
         val engineView: EngineView = spy(FakeEngineView(testContext))
         val toolbar: View = mock()
         doReturn(100).`when`(toolbar).height
-
         doReturn(42f).`when`(toolbar).translationY
-        behavior.onDependentViewChanged(mock(), engineView.asView(), toolbar)
+
+        val behavior = EngineViewBrowserToolbarBehavior(
+            mock(), null, engineView.asView(), toolbar.height, ToolbarPosition.BOTTOM
+        )
+
+        behavior.onDependentViewChanged(mock(), mock(), toolbar)
+
         verify(engineView).setVerticalClipping(-42)
+        assertEquals(0f, engineView.asView().translationY)
+    }
+
+    @Test
+    fun `EngineView clipping and top toolbar offset are kept in sync`() {
+        val engineView: EngineView = spy(FakeEngineView(testContext))
+        val toolbar: View = mock()
+        doReturn(100).`when`(toolbar).height
+        doReturn(42f).`when`(toolbar).translationY
+
+        val behavior = EngineViewBrowserToolbarBehavior(
+            mock(), null, engineView.asView(), toolbar.height, ToolbarPosition.TOP
+        )
+
+        behavior.onDependentViewChanged(mock(), mock(), toolbar)
+
+        verify(engineView).setVerticalClipping(42)
+        assertEquals(142f, engineView.asView().translationY)
     }
 
     @Test
     fun `Behavior does not depend on normal views`() {
-        val behavior = EngineViewBottomBehavior(mock(), null)
+        val behavior = EngineViewBrowserToolbarBehavior(
+            mock(), null, mock(), 0, ToolbarPosition.BOTTOM
+        )
 
         assertFalse(behavior.layoutDependsOn(mock(), mock(), TextView(testContext)))
         assertFalse(behavior.layoutDependsOn(mock(), mock(), EditText(testContext)))
@@ -51,7 +75,9 @@ class EngineViewBottomBehaviorTest {
 
     @Test
     fun `Behavior depends on BrowserToolbar`() {
-        val behavior = EngineViewBottomBehavior(mock(), null)
+        val behavior = EngineViewBrowserToolbarBehavior(
+            mock(), null, mock(), 0, ToolbarPosition.BOTTOM
+        )
 
         assertTrue(behavior.layoutDependsOn(mock(), mock(), BrowserToolbar(testContext)))
     }
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index e4ec6f52f960..5871f5cf67f8 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -12,6 +12,12 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/android-components/blob/master/.config.yml)
 
+* **browser-toolbar**
+  *  **This is a breaking change**: `BrowserToolbarBottomBehavior` is renamed to `BrowserToolbarBehavior` as it is now a common behavior for toolbars be them placed at the bottom or at the top of the screen.
+
+* **feature-session**
+  *  **This is a breaking change**: `EngineViewBottomBehavior` is renamed to `EngineViewBrowserToolbarBehavior` as it is now the glue between `EngineView` and `BrowserToolbar` irrespective of if the toolbar is placed at the bottom oir at the top of the `EngineView`.
+
 * **feature-downloads**:
   *  New `ShareDownloadFeature` will listen for `AddShareAction` and download, cache locally and then share internet resources.
   *  **This is a breaking change**: This is a breaking change with clients expected to create and register a new instance of the this new feature otherwise the "Share image" from the browser contextual menu will do nothing.
