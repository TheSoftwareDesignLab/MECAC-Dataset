diff --git a/android-components/components/service/firefox-accounts/README.md b/android-components/components/service/firefox-accounts/README.md
index c6cfc7f0c4bd..c4b3ebf53719 100644
--- a/android-components/components/service/firefox-accounts/README.md
+++ b/android-components/components/service/firefox-accounts/README.md
@@ -4,7 +4,14 @@ A library for integrating with Firefox Accounts.
 
 ## Motivation
 
-The goal of this library is to provide an API for integrating with Firefox Accounts.
+The **Firefox Accounts Android Component** provides a way for Android applications to do the following:
+
+* Obtain OAuth tokens that can be used to access the user's data in Mozilla-hosted services like Firefox Sync
+* Fetch client-side scoped keys needed for end-to-end encryption of that data
+* Fetch a user's profile to personalize the application
+
+See also the [sample app](https://github.com/mozilla-mobile/android-components/tree/master/samples/firefox-accounts)
+for help with integrating this component into your application.
 
 ## Usage
 
@@ -16,6 +23,102 @@ Use gradle to download the library from JCenter:
 implementation "org.mozilla.components:fxa:{latest-version}
 ```
 
+### Start coding
+
+> This tutorial is for version 0.15 of the FxA client.
+
+First you need some OAuth information. Generate a `client_id`, `redirectUrl` and find out the scopes for your application.
+See Firefox Account documentation for that. 
+
+Once you have the OAuth info, you can start adding `FxAClient` to your Android project.
+As part of the OAuth flow your application will be opening up a WebView or a Custom Tab.
+Currently the SDK does not provide the WebView, you have to write it yourself.
+
+Create a global `account` object: 
+
+```kotlin
+var account: FirefoxAccount? = null
+```
+
+You will need to save state for FxA in your app, this example just uses `SharedPreferences`. We suggest using the [Android Keystore]( https://developer.android.com/training/articles/keystore) for this data.
+Define variables to help save state for FxA:
+
+```kotlin
+val STATE_PREFS_KEY = "fxaAppState"
+val STATE_KEY = "fxaState"
+```
+
+Then you can write the following:
+
+```kotlin
+getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).getString(FXA_STATE_KEY, "").let {
+    FirefoxAccount.fromJSONString(it).then({
+        account = it
+        FxaResult<Void>()
+    }, {
+        Config.custom(CONFIG_URL).whenComplete { value: Config ->
+            account = FirefoxAccount(value, CLIENT_ID, REDIRECT_URL)
+        }
+        FxaResult<Void>()
+    })
+}
+```
+
+> For more info on the chainable Promise-like type `FxaResult`, check out the source code [here](https://github.com/mozilla-mobile/android-components/blob/master/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaResult.kt)
+
+The code above checks if you have some existing state for FxA, otherwise it configures it.
+
+You can now attempt to fetch the FxA profile. The first time the application starts it won't have any state, so
+`account.getProfile()` will fail and proceed to the `account.beginOAuthFlow` branch and it will open the FxA OAuth login
+in the web view.
+
+```kotlin
+account.getProfile().then({ profile: Profile ->
+    // Render the profile
+    val txtView: TextView = findViewById(R.id.txtView)
+    runOnUiThread {
+        txtView.text = profile.displayName
+    }
+    FxaResult<Void>()
+}, { exception: Exception ->
+    account?.beginOAuthFlow(scopes, wantsKeys)?.whenComplete { openWebView(it) }
+    FxaResult<Void>()
+})
+```
+
+When spawning the WebView, be sure to override the `OnPageStarted` function to intercept the redirect url and fetch the code + state parameters:
+
+```kotlin
+override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
+    if (url != null && url.startsWith(redirectUrl)) {
+        val uri = Uri.parse(url)
+        val mCode = uri.getQueryParameter("code")
+        val mState = uri.getQueryParameter("state")
+        if (mCode != null && mState != null) {
+            // Pass the code and state parameters back to your main activity
+            listener?.onLoginComplete(mCode, mState, this@LoginFragment)
+        }
+    }
+
+    super.onPageStarted(view, url, favicon)
+}
+```
+
+Finally, complete the OAuth flow, try to retrieve the profile information, then save your login state once you've gotten valid profile information:
+
+```kotlin
+account?.completeOAuthFlow(code, state)?.then {
+    account?.getProfile()
+}.whenComplete { profile: Profile ->
+    runOnUiThread {
+        txtView.text = profile.displayName
+    }
+    account?.toJSONString().let {
+        getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).edit()
+            .putString(FXA_STATE_KEY, it).apply()
+    }
+}
+```
 
 ## License
 
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Config.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Config.kt
index 1daa8d8fd618..f50cac466811 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Config.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/Config.kt
@@ -4,12 +4,19 @@
 
 package mozilla.components.service.fxa
 
+/**
+ * Config represents the server endpoint configurations needed for the
+ * authentication flow.
+ */
 class Config(override var rawPointer: RawConfig?) : RustObject<RawConfig>() {
     override fun destroy(p: RawConfig) {
         synchronized(FxaClient.INSTANCE) { FxaClient.INSTANCE.fxa_config_free(p) }
     }
 
     companion object {
+        /**
+         * Set up endpoints used in the production Firefox Accounts instance.
+         */
         fun release(): FxaResult<Config> {
             return safeAsync { e ->
                 val p = FxaClient.INSTANCE.fxa_get_release_config(e)
@@ -17,6 +24,11 @@ class Config(override var rawPointer: RawConfig?) : RustObject<RawConfig>() {
             }
         }
 
+        /**
+         * Set up endpoints used by a custom host for authentication
+         *
+         * @param content_base Hostname of the FxA auth service provider
+         */
         fun custom(content_base: String): FxaResult<Config> {
             return safeAsync { e ->
                 val p = FxaClient.INSTANCE.fxa_get_custom_config(content_base, e)
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
index e5bacd86eded..a263ae187a82 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
@@ -4,6 +4,11 @@
 
 package mozilla.components.service.fxa
 
+/**
+ * FirefoxAccount represents the authentication state of a client.
+ *
+ * @param <T> The type of the value delivered via the FxaResult.
+ */
 class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxAccount>() {
 
     constructor(config: Config, clientId: String, redirectUri: String): this(null) {
@@ -16,6 +21,13 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         safeSync { FxaClient.INSTANCE.fxa_free(p) }
     }
 
+    /**
+     * Constructs a URL used to begin the OAuth flow for the requested scopes and keys.
+     *
+     * @param scopes List of OAuth scopes for which the client wants access
+     * @param wantsKeys Fetch keys for end-to-end encryption of data from Mozilla-hosted services
+     * @return FxaResult<String> that resolves to the flow URL when complete
+     */
     fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): FxaResult<String> {
         return safeAsync { e ->
             val scope = scopes.joinToString(" ")
@@ -24,6 +36,13 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Fetches the profile object for the current client either from the existing cached account,
+     * or from the server (requires the client to have access to the profile scope).
+     *
+     * @param ignoreCache Fetch the profile information directly from the server
+     * @return FxaResult<[Profile]> representing the user's basic profile info
+     */
     fun getProfile(ignoreCache: Boolean): FxaResult<Profile> {
         return safeAsync { e ->
             val p = FxaClient.INSTANCE.fxa_profile(validPointer(), ignoreCache, e)
@@ -31,10 +50,22 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Convenience method to fetch the profile from a cached account by default, but fall back
+     * to retrieval from the server.
+     *
+     * @return FxaResult<[Profile]> representing the user's basic profile info
+     */
     fun getProfile(): FxaResult<Profile> {
         return getProfile(false)
     }
 
+    /**
+     * Creates a new SAML assertion from the account state, which can be posted to the token server
+     * endpoint fetched from [getTokenServerEndpointURL] in order to get an access token.
+     *
+     * @return String representing the SAML assertion
+     */
     fun newAssertion(audience: String): String? {
         return safeSync { e ->
             val p = FxaClient.INSTANCE.fxa_assertion_new(this.validPointer(), audience, e)
@@ -42,6 +73,9 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Fetches the token server endpoint, for authentication using the SAML bearer flow.
+     */
     fun getTokenServerEndpointURL(): String? {
         return safeSync { e ->
             val p = FxaClient.INSTANCE.fxa_get_token_server_endpoint_url(validPointer(), e)
@@ -49,6 +83,9 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Fetches keys for encryption/decryption of Firefox Sync data.
+     */
     fun getSyncKeys(): SyncKeys {
         return safeSync { e ->
             val p = FxaClient.INSTANCE.fxa_get_sync_keys(validPointer(), e)
@@ -56,6 +93,12 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Authenticates the current account using the code and state parameters fetched from the
+     * redirect URL reached after completing the sign in flow triggered by [beginOAuthFlow].
+     *
+     * Modifies the FirefoxAccount state.
+     */
     fun completeOAuthFlow(code: String, state: String): FxaResult<OAuthInfo> {
         return safeAsync { e ->
             val p = FxaClient.INSTANCE.fxa_complete_oauth_flow(validPointer(), code, state, e)
@@ -63,6 +106,13 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Fetches a new access token for the desired scopes using an internally stored refresh token.
+     *
+     * @param scopes List of OAuth scopes for which the client wants access
+     * @return FxaResult<[OAuthInfo]> that stores the token, along with its scopes and keys when complete
+     * @throws FxaException.Unauthorized if the token could not be retrieved (eg. expired refresh token)
+     */
     fun getOAuthToken(scopes: Array<String>): FxaResult<OAuthInfo> {
         return safeAsync { e ->
             val scope = scopes.joinToString(" ")
@@ -72,6 +122,13 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
         }
     }
 
+    /**
+     * Saves the current account's authentication state as a JSON string, for persistence in
+     * the Android KeyStore/shared preferences. The authentication state can be restored using
+     * [FirefoxAccount.fromJSONString].
+     *
+     * @return String containing the authentication details in JSON format
+     */
     fun toJSONString(): String? {
         return safeSync { e ->
             val p = FxaClient.INSTANCE.fxa_to_json(validPointer(), e)
@@ -93,6 +150,12 @@ class FirefoxAccount(override var rawPointer: RawFxAccount?) : RustObject<RawFxA
             }
         }
 
+        /**
+         * Restores the account's authentication state from a JSON string produced by
+         * [FirefoxAccount.toJSONString].
+         *
+         * @return FxaResult<[FirefoxAccount]> representing the authentication state
+         */
         fun fromJSONString(json: String): FxaResult<FirefoxAccount> {
             return RustObject.safeAsync { e ->
                 val p = FxaClient.INSTANCE.fxa_from_json(json, e)
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaException.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaException.kt
index 0bef6fc69ea5..d8113d0b73c2 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaException.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaException.kt
@@ -1,5 +1,9 @@
 package mozilla.components.service.fxa
 
+/**
+ * Wrapper class for the exceptions thrown in the Rust library, which ensures that the
+ * error messages will be consumed and freed properly in Rust.
+ */
 open class FxaException(message: String) : Exception(message) {
     class Unspecified(msg: String) : FxaException(msg)
     class Unauthorized(msg: String) : FxaException(msg)
diff --git a/android-components/samples/firefox-accounts/README.md b/android-components/samples/firefox-accounts/README.md
index 46e7e4a1ee53..bed28059fa0c 100644
--- a/android-components/samples/firefox-accounts/README.md
+++ b/android-components/samples/firefox-accounts/README.md
@@ -4,6 +4,111 @@
 
 A simple app showcasing the service-firefox-account component.
 
+## Concepts
+
+The main concepts shown in the sample app are:
+
+* Usage of the asynchronous result type `FxaResult`
+* Setting up a`FirefoxAccount` object, from a previous session or from scratch
+* Spawning a custom tab or a WebView to handle the user's authentication flow
+
+A minimal walkthrough is also provided in the [component README](https://github.com/mozilla-mobile/android-components/tree/master/components/service/firefox-accounts).
+
+## `FxaResult` usage
+
+`FxaResult` represents a chainable asynchronous result, and is used as a convenient method of running potentially long-running tasks (eg. network requests, crypto operations) on threads outside of the UI thread.
+
+A value or exception can be wrapped in an FxaResult:
+
+```kotlin
+val fxaValue = FxaResult.fromValue(42)
+val fxaException = FxaResult.fromException(Exception("Something went wrong"))
+```
+
+One can attach `OnValueListener`s or `OnExceptionListener`s to an `FxaResult`. There are a few ways of chaining results in Kotlin:
+
+* Passing the listeners directly via `then`, with object expressions or otherwise: 
+
+	```kotlin
+	FxaResult.fromValue(42).then(object : OnValueListener<Integer, Void> {
+		override fun onValue(value: Integer): FxaResult<Void>? {
+			// handle the value
+			return FxaResult<Void>()
+		}
+	}, object : OnExceptionListener<Void> {
+		override fun onException(exception: Exception): FxaResult<Void>? {
+			// handle the exception
+			return FxaResult<Void>()
+		}
+	})
+	```
+
+	Since Java 6 does not support simple lambda syntax, this is one of the main ways to chain `FxaResult`s in Java.
+
+* Passing lambdas via `then`:
+
+	```kotlin
+	FxaResult.fromValue(42).then({ value: Int -> // valueListener
+		// handle the value
+		return FxaResult<Void>()
+	}, { exception: Exception ->
+		// handle the exception
+		return FxaResult<Void>()
+	}
+	```
+
+* Completing a chain via `whenComplete`:
+
+	```kotlin
+	FxaResult.fromValue(42).whenComplete { value: Integer ->
+		// handle the value
+	}
+	```
+
+	Since `whenComplete` implies that the chain of promises has come to an end, there is no need to return another FxaResult at the end.
+
+## Setting up the account
+
+### From a previous session
+
+`FirefoxAccount` is a representation of the authentication state for the current client. It provides two methods for saving and restoring state: `toJSONString` and `fromJSONString`.
+
+> The state provided by `toJSONString` should be stored securely, as the credentials inside could in theory let a user stay authenticated forever.
+
+To restore an account from an existing state in shared preferences:
+
+```kotlin
+getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).getString(FXA_STATE_KEY, "").let {
+	FirefoxAccount.fromJSONString(it).whenComplete { this.account = it }
+}
+```
+
+To persist an account's state in shared preferences:
+
+```kotlin
+account?.toJSONString().let {
+    getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).edit().putString(FXA_STATE_KEY, it).apply()
+}
+```
+
+### From scratch
+
+If no previous auth state was found, we have to create a new one using some default OAuth parameters. Find the hostname, or `CONFIG_URL` for your OAuth provider, then create a `CLIENT_ID` and `REDIRECT_URL` for your application. From there, we can create a `Config` object, and finally our `FirefoxAccount` object:
+
+```kotlin
+Config.custom(CONFIG_URL).whenComplete { value: Config ->
+	this.account = FirefoxAccount(value, CLIENT_ID, REDIRECT_URL)
+}
+```
+
+## Viewing the web pages
+
+In order to complete the OAuth flow, the app can spawn a view and capture the code/state parameters in one of three ways:
+
+* Opening a custom tab, then capturing params via intent filters
+* Spawning a WebView with a page load hook
+* Spawning an EngineView (WebView/GeckoView) [WIP]
+
 ## License
 
     This Source Code Form is subject to the terms of the Mozilla Public
