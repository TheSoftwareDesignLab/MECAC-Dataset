diff --git a/android-components/README.md b/android-components/README.md
index 7fc373fdc7d1..1e781c3314fc 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -83,6 +83,8 @@ _API contracts and abstraction layers for browser components._
 
 * âšª [**Engine**](components/concept/engine/README.md) - Abstraction layer that allows hiding the actual browser engine implementation.
 
+* âšª [**Fetch**](components/concept/fetch/README.md) - An abstract definition of an HTTP client for fetching resources.
+
 * ðŸ”´ [**Storage**](components/concept/storage/README.md) - Abstract definition of a browser storage component.
 
 * ðŸ”´ [**Tabstray**](components/concept/tabstray/README.md) - Abstract definition of a tabs tray component.
diff --git a/android-components/components/concept/fetch/README.md b/android-components/components/concept/fetch/README.md
new file mode 100644
index 000000000000..f6674b8e2b87
--- /dev/null
+++ b/android-components/components/concept/fetch/README.md
@@ -0,0 +1,101 @@
+# [Android Components](../../../README.md) > Concept > Fetch
+
+The `concept-fetch` component contains interfaces for defining an abstract HTTP client for fetching resources.
+
+The primary use of this component is to hide the actual implementation of the HTTP client from components required to make HTTP requests. This allows apps to configure a single app-wide used client without the components enforcing a particular dependency.
+
+The API and name of the component is inspired by the [Web Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
+
+## Usage
+
+### Setting up the dependency
+
+Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
+
+```Groovy
+implementation "org.mozilla.components:concept-fetch:{latest-version}"
+```
+
+### Performing requests
+
+#### Get a URL
+
+```Kotlin
+val request = Request(url)
+val response = client.fetch(request)
+val body = response.string()
+```
+
+A `Response` may hold references to other resources (e.g. streams). Therefore it's important to always close the `Response` object or its `Body`. This can be done by either consuming the content of the `Body` with one of the available methods or by using Kotlin's extension methods for using `Closeable` implementations (e.g. `use()`):
+
+```Kotlin
+client.fetch(Request(url)).use { response ->
+    val body = response.body.string()
+}
+```
+
+#### Post to a URL
+
+```Kotlin
+val request = Request(
+   url = "...",
+   method = Request.Method.POST,
+   body = Request.Body.fromStream(stream))
+   
+client.fetch(request).use { response ->
+   if (response.success) {
+       // ...
+   }
+}
+```
+
+#### Github API example
+
+```Kotlin
+val request = Request(
+   url = "https://api.github.com/repos/mozilla-mobile/android-components/issues",
+   headers = MutableHeaders(
+       "User-Agent" to "AwesomeBrowser/1.0",
+       "Accept" to "application/json; q=0.5",
+       "Accept" to "application/vnd.github.v3+json"))
+
+client.fetch(request).use { response ->
+    val server = response.headers.get('Server')
+    val result = response.body.string()
+}
+```
+
+#### Posting a file
+
+```Kotlin
+val file = File("README.md")
+
+val request = Request(
+   url = "https://api.github.com/markdown/raw",
+   headers = MutableHeaders(
+       "Content-Type", "text/x-markdown; charset=utf-8"
+   ),
+   body = Request.Body.fromFile(file))
+   
+client.fetch(request).use { response ->
+   if (request.success) {
+      // Upload was successful!
+   }
+}
+   
+```
+
+#### Asynchronous requests
+
+Client implementations are synchronous. For asynchronous requests it's recommended to wrap a client in a Coroutine with a scope the calling code is in control of:
+
+```Kotlin
+val deferredResponse = async { client.fetch(request) }
+val body = deferredResponse.await().body.string()
+```
+
+## License
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/concept/fetch/build.gradle b/android-components/components/concept/fetch/build.gradle
new file mode 100644
index 000000000000..9933306aaec2
--- /dev/null
+++ b/android-components/components/concept/fetch/build.gradle
@@ -0,0 +1,39 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+android {
+    compileSdkVersion Config.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion Config.minSdkVersion
+        targetSdkVersion Config.targetSdkVersion
+
+        buildConfigField("String", "LIBRARY_VERSION", "\"" + Config.componentsVersion + "\"")
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    implementation Deps.kotlin_stdlib
+    implementation Deps.kotlin_coroutines
+
+    testImplementation Deps.testing_junit
+    testImplementation Deps.testing_robolectric
+    testImplementation Deps.testing_mockito
+    testImplementation Deps.testing_mockwebserver
+
+    testImplementation project(':support-test')
+}
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(Config.componentsGroupId, archivesBaseName, gradle.componentDescriptions[archivesBaseName])
diff --git a/android-components/components/concept/fetch/proguard-rules.pro b/android-components/components/concept/fetch/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/concept/fetch/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/concept/fetch/src/main/AndroidManifest.xml b/android-components/components/concept/fetch/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..19956e39f9ce
--- /dev/null
+++ b/android-components/components/concept/fetch/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="mozilla.components.concept.fetch" />
diff --git a/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Client.kt b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Client.kt
new file mode 100644
index 000000000000..5fe6cf3da8cf
--- /dev/null
+++ b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Client.kt
@@ -0,0 +1,59 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import java.io.IOException
+
+/**
+ * A generic [Client] for fetching resources via HTTP/s.
+ *
+ * Abstract base class / interface for clients implementing the `concept-fetch` component.
+ *
+ * The [Request]/[Response] API is inspired by the Web Fetch API:
+ * https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
+ */
+abstract class Client {
+    /**
+     * Starts the process of fetching a resource from the network as described by the [Request] object.
+     *
+     * A [Response] may keep references to open streams. Therefore it's important to always close the [Response] or
+     * its [Response.Body].
+     *
+     * Use the `use()` extension method when performing multiple operations on the [Response] object:
+     *
+     * ```Kotlin
+     * client.fetch(request).use { response ->
+     *     // Use response. Resources will get released automatically at the end of the block.
+     * }
+     * ```
+     *
+     * Alternatively you can use multiple `use*()` methods on the [Response.Body] object.
+     *
+     * @param request The request to be executed by this [Client].
+     * @return The [Response] returned by the server.
+     * @throws IOException if the request could not be executed due to cancellation, a connectivity problem or a
+     * timeout.
+     */
+    @Throws(IOException::class)
+    abstract fun fetch(request: Request): Response
+
+    /**
+     * List of default headers that should be added to every request unless overridden by the headers in the request.
+     */
+    protected val defaultHeaders: Headers = MutableHeaders(
+        // Unfortunately some implementations will always send a not removable Accept header. Let's override it with
+        // a header that accepts everything.
+        "Accept" to "*/*",
+
+        // We expect all clients to implement gzip decoding transparently.
+        "Accept-Encoding" to "gzip",
+
+        // Default User Agent. Clients are expected to append their own tokens if needed.
+        "User-Agent" to "MozacFetch/${BuildConfig.LIBRARY_VERSION}",
+
+        // We expect all clients to support and use keep-alive by default.
+        "Connection" to "keep-alive"
+    )
+}
diff --git a/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Headers.kt b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Headers.kt
new file mode 100644
index 000000000000..ee2224917c1d
--- /dev/null
+++ b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Headers.kt
@@ -0,0 +1,129 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import java.lang.IllegalArgumentException
+
+/**
+ * A collection of HTTP [Headers] (immutable) of a [Request] or [Response].
+ */
+interface Headers : Iterable<Header> {
+    /**
+     * Returns the number of headers (key / value combinations).
+     */
+    val size: Int
+
+    /**
+     * Gets the [Header] at the specified [index].
+     */
+    operator fun get(index: Int): Header
+
+    /**
+     * Returns the last values corresponding to the specified header field name. Or null if the header does not exist.
+     */
+    operator fun get(name: String): String?
+
+    /**
+     * Returns the list of values corresponding to the specified header field name.
+     */
+    fun getAll(name: String): List<String>
+
+    /**
+     * Sets the [Header] at the specified [index].
+     */
+    operator fun set(index: Int, header: Header)
+
+    /**
+     * Returns true if a [Header] with the given [name] exists.
+     */
+    operator fun contains(name: String): Boolean
+}
+
+/**
+ * Represents a [Header] containing of a [name] and [value].
+ */
+data class Header(
+    val name: String,
+    val value: String
+) {
+    init {
+        if (name.isEmpty()) {
+            throw IllegalArgumentException("Header name cannot be empty")
+        }
+    }
+}
+
+/**
+ * A collection of HTTP [Headers] (mutable) of a [Request] or [Response].
+ */
+class MutableHeaders(
+    vararg pairs: Pair<String, String>
+) : Headers, MutableIterable<Header> {
+    private val headers: MutableList<Header> = pairs.map {
+            (name, value) -> Header(name, value)
+    }.toMutableList()
+
+    /**
+     * Gets the [Header] at the specified [index].
+     */
+    override fun get(index: Int): Header = headers[index]
+
+    /**
+     * Returns the last value corresponding to the specified header field name. Or null if the header does not exist.
+     */
+    override fun get(name: String) = headers.lastOrNull { header -> header.name == name }?.value
+
+    /**
+     * Returns the list of values corresponding to the specified header field name.
+     */
+    override fun getAll(name: String): List<String> = headers
+        .filter { header -> header.name == name }
+        .map { header -> header.value }
+
+    /**
+     * Sets the [Header] at the specified [index].
+     */
+    override fun set(index: Int, header: Header) {
+        headers[index] = header
+    }
+
+    /**
+     * Returns an iterator over the headers that supports removing elements during iteration.
+     */
+    override fun iterator(): MutableIterator<Header> = headers.iterator()
+
+    /**
+     * Returns true if a [Header] with the given [name] exists.
+     */
+    override operator fun contains(name: String): Boolean = headers.firstOrNull { it.name == name } != null
+
+    /**
+     * Returns the number of headers (key / value combinations).
+     */
+    override val size: Int
+        get() = headers.size
+
+    /**
+     * Append a header without removing the headers already present.
+     */
+    fun append(name: String, value: String): MutableHeaders {
+        headers.add(Header(name, value))
+        return this
+    }
+
+    /**
+     * Set the only occurrence of the header; potentially overriding an already existing header.
+     */
+    fun set(name: String, value: String): MutableHeaders {
+        headers.forEachIndexed { index, current ->
+            if (current.name == name) {
+                headers[index] = Header(name, value)
+                return this
+            }
+        }
+
+        return append(name, value)
+    }
+}
diff --git a/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Request.kt b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Request.kt
new file mode 100644
index 000000000000..9bc41a856216
--- /dev/null
+++ b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Request.kt
@@ -0,0 +1,111 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import java.io.Closeable
+import java.io.File
+import java.io.IOException
+import java.io.InputStream
+import java.util.concurrent.TimeUnit
+
+/**
+ * The [Request] data class represents a resource request to be send by a [Client].
+ *
+ * It's API is inspired by the Request interface of the Web Fetch API:
+ * https://developer.mozilla.org/en-US/docs/Web/API/Request
+ *
+ * @property url The URL of the request.
+ * @property method The request method (GET, POST, ..)
+ * @property headers Optional HTTP headers to be send with the request.
+ * @property connectTimeout A timeout to be used when connecting to the resource.  If the timeout expires before the
+ * connection can be established, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an
+ * infinite timeout.
+ * @property readTimeout A timeout to be used when reading from the resource. If the timeout expires before there is
+ * data available for read, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an infinite
+ * timeout.
+ * @property body An optional body to be send with the request.
+ * @property redirect Whether the [Client] should follow redirects (HTTP 3xx) for this request or not.
+ */
+data class Request(
+    val url: String,
+    val method: Method = Method.GET,
+    val headers: MutableHeaders? = MutableHeaders(),
+    val connectTimeout: Pair<Long, TimeUnit>? = null,
+    val readTimeout: Pair<Long, TimeUnit>? = null,
+    val body: Body? = null,
+    val redirect: Redirect = Redirect.FOLLOW
+) {
+    /**
+     * A [Body] to be send with the [Request].
+     *
+     * @param stream A stream that will be read and send to the resource.
+     */
+    class Body(
+        private val stream: InputStream
+    ) : Closeable {
+        companion object {
+            /**
+             * Create a [Body] from the provided [String].
+             */
+            fun fromString(value: String): Body = Body(value.byteInputStream())
+
+            /**
+             * Create a [Body] from the provided [File].
+             */
+            fun fromFile(file: File): Body = Body(file.inputStream())
+        }
+
+        /**
+         * Executes the given [block] function on the body's stream and then closes it down correctly whether an
+         * exception is thrown or not.
+         */
+        fun <R> useStream(block: (InputStream) -> R): R = use {
+            block(stream)
+        }
+
+        /**
+         * Closes this body and releases any system resources associated with it.
+         */
+        override fun close() {
+            try {
+                stream.close()
+            } catch (e: IOException) {
+                // Ignore
+            }
+        }
+    }
+
+    /**
+     * Request methods.
+     *
+     * The request method token is the primary source of request semantics;
+     * it indicates the purpose for which the client has made this request
+     * and what is expected by the client as a successful result.
+     *
+     * https://tools.ietf.org/html/rfc7231#section-4
+     */
+    enum class Method {
+        GET,
+        HEAD,
+        POST,
+        PUT,
+        DELETE,
+        CONNECT,
+        OPTIONS,
+        TRACE
+    }
+
+    enum class Redirect {
+        /**
+         * Automatically follow redirects.
+         */
+        FOLLOW,
+
+        /**
+         * Do not follow redirects and let caller handle them manually.
+         */
+        MANUAL
+    }
+}
diff --git a/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Response.kt b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Response.kt
new file mode 100644
index 000000000000..94aa90c35689
--- /dev/null
+++ b/android-components/components/concept/fetch/src/main/java/mozilla/components/concept/fetch/Response.kt
@@ -0,0 +1,110 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import java.io.BufferedReader
+import java.io.Closeable
+import java.io.IOException
+import java.io.InputStream
+import java.nio.charset.Charset
+
+/**
+ * The [Response] data class represents a reponse to a [Request] send by a [Client].
+ *
+ * You can create a [Response] object using the constructor, but you are more likely to encounter a [Response] object
+ * being returned as the result of calling [Client.fetch].
+ *
+ * A [Response] may hold references to other resources (e.g. streams). Therefore it's important to always close the
+ * [Response] object or its [Body]. This can be done by either consuming the content of the [Body] with one of the
+ * available methods or by using Kotlin's extension methods for using [Closeable] implementations (like `use()`):
+ *
+ * ```Kotlin
+ * val response = ...
+ * response.use {
+ *    // Use response. Resources will get released automatically at the end of the block.
+ * }
+ * ```
+ */
+data class Response(
+    val url: String,
+    val status: Int,
+    val headers: Headers,
+    val body: Body
+) : Closeable {
+    /**
+     * Closes this [Response] and its [Body] and releases any system resources associated with it.
+     */
+    override fun close() {
+        body.close()
+    }
+
+    /**
+     * A [Body] returned along with the [Request].
+     *
+     * **The response body can be consumed only once.**.
+     */
+    open class Body(
+        private val stream: InputStream
+    ) : Closeable, AutoCloseable {
+        /**
+         * Creates a usable stream from this body.
+         *
+         * Executes the given [block] function with the stream as parameter and then closes it down correctly
+         * whether an exception is thrown or not.
+         */
+        fun <R> useStream(block: (InputStream) -> R): R = use {
+            block(stream)
+        }
+
+        /**
+         * Creates a buffered reader from this body.
+         *
+         * Executes the given [block] function with the buffered reader as parameter and then closes it down correctly
+         * whether an exception is thrown or not.
+         */
+        fun <R> useBufferedReader(charset: Charset = Charsets.UTF_8, block: (BufferedReader) -> R): R = use {
+            block(stream.bufferedReader(charset))
+        }
+
+        /**
+         * Reads this body completely as a String.
+         *
+         * Takes care of closing the body down correctly whether an exception is thrown or not.
+         */
+        fun string(charset: Charset = Charsets.UTF_8): String = useBufferedReader(charset) { it.readText() }
+
+        /**
+         * Closes this [Body] and releases any system resources associated with it.
+         */
+        override fun close() {
+            try {
+                stream.close()
+            } catch (e: IOException) {
+                // Ignore
+            }
+        }
+
+        companion object {
+            /**
+             * Creates an empty response body.
+             */
+            fun empty() = Body("".byteInputStream())
+        }
+    }
+}
+
+/**
+ * Returns true if the response was successful (status in the range 200-299) or false otherwise.
+ */
+@Suppress("MagicNumber")
+val Response.success: Boolean
+    get() = status in 200..299
+
+/**
+ * Returns true if the response was a client error (status in the range 400-499) or false otherwise.
+ */
+@Suppress("MagicNumber")
+val Response.clientError: Boolean
+    get() = status in 400..499
diff --git a/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ClientTest.kt b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ClientTest.kt
new file mode 100644
index 000000000000..2003db9a7632
--- /dev/null
+++ b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ClientTest.kt
@@ -0,0 +1,75 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import kotlinx.coroutines.async
+import kotlinx.coroutines.runBlocking
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class ClientTest {
+    @Test
+    fun `Verify default user agent format`() {
+        val client = TestClient()
+
+        val userAgent = client.exposeDefaultHeaders()["User-Agent"]
+        assertNotNull(userAgent!!)
+
+        assertTrue(userAgent.matches("MozacFetch/[0-9]+\\.[0-9]+\\.[0-9]+".toRegex()))
+    }
+
+    @Test
+    fun `Expects gzip encoding default header`() {
+        val client = TestClient()
+
+        val acceptEncoding = client.exposeDefaultHeaders().get("Accept-Encoding")
+        assertNotNull(acceptEncoding!!)
+        assertEquals("gzip", acceptEncoding)
+    }
+
+    @Test
+    fun `Expects accept all default header`() {
+        val client = TestClient()
+
+        val accept = client.exposeDefaultHeaders().get("Accept")
+        assertNotNull(accept!!)
+        assertEquals("*/*", accept)
+    }
+
+    @Test
+    fun `Expects keep-alive connection default header`() {
+        val client = TestClient()
+
+        val connection = client.exposeDefaultHeaders().get("Connection")
+        assertNotNull(connection!!)
+        assertEquals("keep-alive", connection)
+    }
+
+    @Test
+    fun `Async request with coroutines`() = runBlocking {
+        val client = TestClient(responseBody = Response.Body("Hello World".byteInputStream()))
+        val request = Request("https://www.mozilla.org")
+
+        val deferredResponse = async { client.fetch(request) }
+
+        val body = deferredResponse.await().body.string()
+        assertEquals("Hello World", body)
+    }
+}
+
+private class TestClient(
+    private val responseUrl: String? = null,
+    private val responseStatus: Int = 200,
+    private val responseHeaders: Headers = MutableHeaders(),
+    private val responseBody: Response.Body = Response.Body.empty()
+) : Client() {
+    override fun fetch(request: Request): Response {
+        return Response(responseUrl ?: request.url, responseStatus, responseHeaders, responseBody)
+    }
+
+    fun exposeDefaultHeaders() = defaultHeaders
+}
diff --git a/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/HeadersTest.kt b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/HeadersTest.kt
new file mode 100644
index 000000000000..0d0b29d232b3
--- /dev/null
+++ b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/HeadersTest.kt
@@ -0,0 +1,240 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import mozilla.components.support.test.expectException
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import java.lang.IllegalArgumentException
+
+class HeadersTest {
+    @Test
+    fun `Creating Headers using constructor`() {
+        val headers = MutableHeaders(
+            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+            "Accept-Encoding" to "gzip, deflate",
+            "Accept-Language" to "en-US,en;q=0.5",
+            "Connection" to "keep-alive",
+            "Dnt" to "1",
+            "User-Agent" to "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0"
+        )
+
+        assertEquals(6, headers.size)
+
+        assertEquals("Accept", headers[0].name)
+        assertEquals("Accept-Encoding", headers[1].name)
+        assertEquals("Accept-Language", headers[2].name)
+        assertEquals("Connection", headers[3].name)
+        assertEquals("Dnt", headers[4].name)
+        assertEquals("User-Agent", headers[5].name)
+
+        assertEquals("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", headers[0].value)
+        assertEquals("gzip, deflate", headers[1].value)
+        assertEquals("en-US,en;q=0.5", headers[2].value)
+        assertEquals("keep-alive", headers[3].value)
+        assertEquals("1", headers[4].value)
+        assertEquals("Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0", headers[5].value)
+    }
+
+    @Test
+    fun `Setting headers`() {
+        val headers = MutableHeaders()
+
+        headers.set("Accept-Encoding", "gzip, deflate")
+        headers.set("Connection", "keep-alive")
+        headers.set("Accept-Encoding", "gzip")
+        headers.set("Dnt", "1")
+
+        assertEquals(3, headers.size)
+
+        assertEquals("Accept-Encoding", headers[0].name)
+        assertEquals("Connection", headers[1].name)
+        assertEquals("Dnt", headers[2].name)
+
+        assertEquals("gzip", headers[0].value)
+        assertEquals("keep-alive", headers[1].value)
+        assertEquals("1", headers[2].value)
+    }
+
+    @Test
+    fun `Appending headers`() {
+        val headers = MutableHeaders()
+
+        headers.append("Accept-Encoding", "gzip, deflate")
+        headers.append("Connection", "keep-alive")
+        headers.append("Accept-Encoding", "gzip")
+        headers.append("Dnt", "1")
+
+        assertEquals(4, headers.size)
+
+        assertEquals("Accept-Encoding", headers[0].name)
+        assertEquals("Connection", headers[1].name)
+        assertEquals("Accept-Encoding", headers[2].name)
+        assertEquals("Dnt", headers[3].name)
+
+        assertEquals("gzip, deflate", headers[0].value)
+        assertEquals("keep-alive", headers[1].value)
+        assertEquals("gzip", headers[2].value)
+        assertEquals("1", headers[3].value)
+    }
+
+    @Test
+    fun `Overriding headers at index`() {
+        val headers = MutableHeaders().apply {
+            set("User-Agent", "Mozilla/5.0")
+            set("Connection", "keep-alive")
+            set("Accept-Encoding", "gzip")
+        }
+
+        headers[2] = Header("Dnt", "0")
+        headers[0] = Header("Accept-Language", "en-US,en;q=0.5")
+
+        assertEquals(3, headers.size)
+
+        assertEquals("Accept-Language", headers[0].name)
+        assertEquals("Connection", headers[1].name)
+        assertEquals("Dnt", headers[2].name)
+
+        assertEquals("en-US,en;q=0.5", headers[0].value)
+        assertEquals("keep-alive", headers[1].value)
+        assertEquals("0", headers[2].value)
+    }
+
+    @Test
+    fun `Contains header with name`() {
+        val headers = MutableHeaders().apply {
+            set("User-Agent", "Mozilla/5.0")
+            set("Connection", "keep-alive")
+            set("Accept-Encoding", "gzip")
+        }
+
+        assertTrue(headers.contains("User-Agent"))
+        assertTrue(headers.contains("Connection"))
+        assertTrue(headers.contains("Accept-Encoding"))
+
+        assertFalse(headers.contains("Accept-Language"))
+        assertFalse(headers.contains("Dnt"))
+        assertFalse(headers.contains("Accept"))
+    }
+
+    @Test
+    fun `Throws if header name is empty`() {
+        expectException(IllegalArgumentException::class) {
+            MutableHeaders(
+                "" to "Mozilla/5.0"
+            )
+        }
+
+        expectException(IllegalArgumentException::class) {
+            MutableHeaders()
+                .append("", "Mozilla/5.0")
+        }
+
+        expectException(IllegalArgumentException::class) {
+            MutableHeaders()
+                .set("", "Mozilla/5.0")
+        }
+
+        expectException(IllegalArgumentException::class) {
+            Header("", "Mozilla/5.0")
+        }
+    }
+
+    @Test
+    fun `Iterator usage`() {
+        val headers = MutableHeaders().apply {
+            set("User-Agent", "Mozilla/5.0")
+            set("Connection", "keep-alive")
+            set("Accept-Encoding", "gzip")
+        }
+
+        var i = 0
+        headers.forEach { _ -> i++ }
+
+        assertEquals(3, i)
+
+        assertNotNull(headers.firstOrNull { header -> header.name == "User-Agent" })
+    }
+
+    @Test
+    fun `Creating and modifying headers`() {
+        val headers = MutableHeaders(
+            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+            "Accept-Encoding" to "gzip, deflate",
+            "Accept-Language" to "en-US,en;q=0.5",
+            "Connection" to "keep-alive",
+            "Dnt" to "1",
+            "User-Agent" to "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0"
+        )
+
+        headers.set("Dnt", "0")
+        headers.set("User-Agent", "Mozilla/6.0")
+        headers.append("Accept", "*/*")
+
+        assertEquals(7, headers.size)
+
+        assertEquals("Accept", headers[0].name)
+        assertEquals("Accept-Encoding", headers[1].name)
+        assertEquals("Accept-Language", headers[2].name)
+        assertEquals("Connection", headers[3].name)
+        assertEquals("Dnt", headers[4].name)
+        assertEquals("User-Agent", headers[5].name)
+        assertEquals("Accept", headers[6].name)
+
+        assertEquals("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", headers[0].value)
+        assertEquals("gzip, deflate", headers[1].value)
+        assertEquals("en-US,en;q=0.5", headers[2].value)
+        assertEquals("keep-alive", headers[3].value)
+        assertEquals("0", headers[4].value)
+        assertEquals("Mozilla/6.0", headers[5].value)
+        assertEquals("*/*", headers[6].value)
+    }
+
+    @Test
+    fun `In operator`() {
+        val headers = MutableHeaders().apply {
+            set("User-Agent", "Mozilla/5.0")
+            set("Connection", "keep-alive")
+            set("Accept-Encoding", "gzip")
+        }
+
+        assertTrue("User-Agent" in headers)
+        assertTrue("Connection" in headers)
+        assertTrue("Accept-Encoding" in headers)
+
+        assertFalse("Accept-Language" in headers)
+        assertFalse("Accept" in headers)
+        assertFalse("Dnt" in headers)
+    }
+
+    @Test
+    fun `Get multiple headers by name`() {
+        val headers = MutableHeaders().apply {
+            append("Accept-Encoding", "gzip")
+            append("Accept-Encoding", "deflate")
+            append("Connection", "keep-alive")
+        }
+
+        val values = headers.getAll("Accept-Encoding")
+        assertEquals(2, values.size)
+        assertEquals("gzip", values[0])
+        assertEquals("deflate", values[1])
+    }
+
+    @Test
+    fun `Getting headers by name`() {
+        val headers = MutableHeaders().apply {
+            append("Accept-Encoding", "gzip")
+            append("Accept-Encoding", "deflate")
+            append("Connection", "keep-alive")
+        }
+
+        assertEquals("deflate", headers["Accept-Encoding"])
+        assertEquals("keep-alive", headers["Connection"])
+    }
+}
diff --git a/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/RequestTest.kt b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/RequestTest.kt
new file mode 100644
index 000000000000..26bde55cd4d2
--- /dev/null
+++ b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/RequestTest.kt
@@ -0,0 +1,134 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Test
+import org.mockito.Mockito.doThrow
+import org.mockito.Mockito.never
+import org.mockito.Mockito.verify
+import java.io.File
+import java.io.IOException
+import java.io.InputStream
+import java.lang.IllegalStateException
+import java.util.UUID
+import java.util.concurrent.TimeUnit
+
+class RequestTest {
+    @Test
+    fun `URL-only Request`() {
+        val request = Request("https://www.mozilla.org")
+
+        assertEquals("https://www.mozilla.org", request.url)
+        assertEquals(Request.Method.GET, request.method)
+    }
+
+    @Test
+    fun `Fully configured Request`() {
+        val request = Request(
+            url = "https://www.mozilla.org",
+            method = Request.Method.POST,
+            headers = MutableHeaders(
+                "Accept-Language" to "en-US,en;q=0.5",
+                "Connection" to "keep-alive",
+                "Dnt" to "1"
+            ),
+            connectTimeout = Pair(10, TimeUnit.SECONDS),
+            readTimeout = Pair(1, TimeUnit.MINUTES),
+            body = Request.Body.fromString("Hello World!"),
+            redirect = Request.Redirect.MANUAL
+        )
+
+        assertEquals("https://www.mozilla.org", request.url)
+        assertEquals(Request.Method.POST, request.method)
+
+        assertEquals(10, request.connectTimeout!!.first)
+        assertEquals(TimeUnit.SECONDS, request.connectTimeout!!.second)
+
+        assertEquals(1, request.readTimeout!!.first)
+        assertEquals(TimeUnit.MINUTES, request.readTimeout!!.second)
+
+        assertEquals("Hello World!", request.body!!.useStream { it.bufferedReader().readText() })
+        assertEquals(Request.Redirect.MANUAL, request.redirect)
+
+        val headers = request.headers!!
+        assertEquals(3, headers.size)
+
+        assertEquals("Accept-Language", headers[0].name)
+        assertEquals("Connection", headers[1].name)
+        assertEquals("Dnt", headers[2].name)
+
+        assertEquals("en-US,en;q=0.5", headers[0].value)
+        assertEquals("keep-alive", headers[1].value)
+        assertEquals("1", headers[2].value)
+    }
+
+    @Test
+    fun `Create request body from string`() {
+        val body = Request.Body.fromString("Hello World")
+        assertEquals("Hello World", body.useStream { it.bufferedReader().readText() })
+    }
+
+    @Test
+    fun `Create request body from file`() {
+        val file = File.createTempFile(UUID.randomUUID().toString(), UUID.randomUUID().toString())
+        file.writer().use { it.write("Banana") }
+
+        val body = Request.Body.fromFile(file)
+        assertEquals("Banana", body.useStream { it.bufferedReader().readText() })
+    }
+
+    @Test
+    fun `Closing body closes stream`() {
+        val stream: InputStream = mock()
+
+        val body = Request.Body(stream)
+
+        verify(stream, never()).close()
+
+        body.close()
+
+        verify(stream).close()
+    }
+
+    @Test
+    fun `Using stream closes stream`() {
+        val stream: InputStream = mock()
+
+        val body = Request.Body(stream)
+
+        verify(stream, never()).close()
+
+        body.useStream {
+            // Do nothing
+        }
+
+        verify(stream).close()
+    }
+
+    @Test
+    fun `Stream throwing on close`() {
+        val stream: InputStream = mock()
+        doThrow(IOException()).`when`(stream).close()
+
+        val body = Request.Body(stream)
+        body.close()
+    }
+
+    @Test(expected = IllegalStateException::class)
+    fun `useStream rethrows and closes stream`() {
+        val stream: InputStream = mock()
+        val body = Request.Body(stream)
+
+        try {
+            body.useStream {
+                throw IllegalStateException()
+            }
+        } finally {
+            verify(stream).close()
+        }
+    }
+}
diff --git a/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ResponseTest.kt b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ResponseTest.kt
new file mode 100644
index 000000000000..0fabb3aeca26
--- /dev/null
+++ b/android-components/components/concept/fetch/src/test/java/mozilla/components/concept/fetch/ResponseTest.kt
@@ -0,0 +1,207 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.fetch
+
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.mockito.Mockito
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import java.io.IOException
+import java.io.InputStream
+import java.lang.RuntimeException
+
+class ResponseTest {
+    @Test
+    fun `Creating String from Body`() {
+        val stream = "Hello World".byteInputStream()
+
+        val body = spy(Response.Body(stream))
+        assertEquals("Hello World", body.string())
+
+        verify(body).close()
+    }
+
+    @Test
+    fun `Creating BufferedReader from Body`() {
+        val stream = "Hello World".byteInputStream()
+
+        val body = spy(Response.Body(stream))
+
+        var readerUsed = false
+        body.useBufferedReader { reader ->
+            assertEquals("Hello World", reader.readText())
+            readerUsed = true
+        }
+
+        assertTrue(readerUsed)
+
+        verify(body).close()
+    }
+
+    @Test
+    fun `Using InputStream from Body`() {
+        val body = spy(Response.Body("Hello World".byteInputStream()))
+
+        var streamUsed = false
+        body.useStream { stream ->
+            assertEquals("Hello World", stream.bufferedReader().readText())
+            streamUsed = true
+        }
+
+        assertTrue(streamUsed)
+
+        verify(body).close()
+    }
+
+    @Test
+    fun `Closing Body closes stream`() {
+        val stream = spy("Hello World".byteInputStream())
+
+        val body = spy(Response.Body(stream))
+        body.close()
+
+        verify(stream).close()
+    }
+
+    @Test
+    fun `success() extension function returns true for 2xx response codes`() {
+        assertTrue(Response("https://www.mozilla.org", 200, headers = mock(), body = mock()).success)
+        assertTrue(Response("https://www.mozilla.org", 203, headers = mock(), body = mock()).success)
+
+        assertFalse(Response("https://www.mozilla.org", 404, headers = mock(), body = mock()).success)
+        assertFalse(Response("https://www.mozilla.org", 500, headers = mock(), body = mock()).success)
+        assertFalse(Response("https://www.mozilla.org", 302, headers = mock(), body = mock()).success)
+    }
+
+    @Test
+    fun `clientError() extension function returns true for 4xx response codes`() {
+        assertTrue(Response("https://www.mozilla.org", 404, headers = mock(), body = mock()).clientError)
+        assertTrue(Response("https://www.mozilla.org", 403, headers = mock(), body = mock()).clientError)
+
+        assertFalse(Response("https://www.mozilla.org", 200, headers = mock(), body = mock()).clientError)
+        assertFalse(Response("https://www.mozilla.org", 203, headers = mock(), body = mock()).clientError)
+        assertFalse(Response("https://www.mozilla.org", 500, headers = mock(), body = mock()).clientError)
+        assertFalse(Response("https://www.mozilla.org", 302, headers = mock(), body = mock()).clientError)
+    }
+
+    @Test
+    fun `Fully configured Response`() {
+        val response = Response(
+            url = "https://www.mozilla.org",
+            status = 200,
+            headers = MutableHeaders(
+                "Content-Type" to "text/html; charset=utf-8",
+                "Connection" to "Close",
+                "Expires" to "Thu, 08 Nov 2018 15:41:43 GMT"
+            ),
+            body = Response.Body("Hello World".byteInputStream())
+        )
+
+        assertEquals("https://www.mozilla.org", response.url)
+        assertEquals(200, response.status)
+        assertEquals("Hello World", response.body.string())
+
+        val headers = response.headers
+        assertEquals(3, headers.size)
+
+        assertEquals("Content-Type", headers[0].name)
+        assertEquals("Connection", headers[1].name)
+        assertEquals("Expires", headers[2].name)
+
+        assertEquals("text/html; charset=utf-8", headers[0].value)
+        assertEquals("Close", headers[1].value)
+        assertEquals("Thu, 08 Nov 2018 15:41:43 GMT", headers[2].value)
+    }
+
+    @Test
+    fun `Closing body closes stream of body`() {
+        val stream: InputStream = mock()
+        val response = Response("url", 200, MutableHeaders(), Response.Body(stream))
+
+        verify(stream, never()).close()
+
+        response.body.close()
+
+        verify(stream).close()
+    }
+
+    @Test
+    fun `Closing response closes stream of body`() {
+        val stream: InputStream = mock()
+        val response = Response("url", 200, MutableHeaders(), Response.Body(stream))
+
+        verify(stream, never()).close()
+
+        response.close()
+
+        verify(stream).close()
+    }
+
+    @Test
+    fun `Empty body`() {
+        val body = Response.Body.empty()
+        assertEquals("", body.string())
+    }
+
+    @Test
+    fun `Creating string closes stream`() {
+        val stream: InputStream = spy("".byteInputStream())
+        val body = Response.Body(stream)
+
+        verify(stream, never()).close()
+
+        body.string()
+
+        verify(stream).close()
+    }
+
+    @Test(expected = TestException::class)
+    fun `Using buffered reader closes stream`() {
+        val stream: InputStream = spy("".byteInputStream())
+        val body = Response.Body(stream)
+
+        verify(stream, never()).close()
+
+        try {
+            body.useBufferedReader {
+                throw TestException()
+            }
+        } finally {
+            verify(stream).close()
+        }
+    }
+
+    @Test(expected = TestException::class)
+    fun `Using stream closes stream`() {
+        val stream: InputStream = spy("".byteInputStream())
+        val body = Response.Body(stream)
+
+        verify(stream, never()).close()
+
+        try {
+            body.useStream {
+                throw TestException()
+            }
+        } finally {
+            verify(stream).close()
+        }
+    }
+
+    @Test
+    fun `Stream throwing on close`() {
+        val stream: InputStream = mock()
+        Mockito.doThrow(IOException()).`when`(stream).close()
+
+        val body = Response.Body(stream)
+        body.close()
+    }
+}
+
+private class TestException : RuntimeException()
diff --git a/android-components/components/concept/fetch/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/concept/fetch/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 000000000000..cf1c399ea81e
--- /dev/null
+++ b/android-components/components/concept/fetch/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1,2 @@
+mock-maker-inline
+// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/settings.gradle b/android-components/settings.gradle
index 856cdad18de0..c9ded7608fe3 100644
--- a/android-components/settings.gradle
+++ b/android-components/settings.gradle
@@ -29,6 +29,7 @@ def setupProject(name, path, description, shouldPublish = true) {
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 
 setupProject(':concept-awesomebar', 'components/concept/awesomebar', 'An abstract definition of an awesomebar component.')
+setupProject(':concept-fetch', 'components/concept/fetch', 'An abstract definition of an HTTP client for fetching resources.')
 setupProject(':concept-toolbar', 'components/concept/toolbar', 'An abstract definition of a toolbar component.')
 setupProject(':concept-tabstray', 'components/concept/tabstray', 'An abstract definition of a tabs tray component.')
 setupProject(':concept-engine', 'components/concept/engine', 'An abstract layer hiding the actual browser engine implementation.')
