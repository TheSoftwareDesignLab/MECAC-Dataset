diff --git a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt
index 169422589de6..87a55dbcc406 100644
--- a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt
+++ b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt
@@ -43,6 +43,13 @@ class QrFeature(
 ) : LifecycleAwareFeature, UserInteractionHandler, PermissionsFeature {
     private var containerViewId: Int = 0
 
+    private val qrFragment
+        get() = fragmentManager.findFragmentByTag(QR_FRAGMENT_TAG) as? QrFragment
+
+    @Suppress("MemberVisibilityCanBePrivate")
+    val isScanInProgress
+        get() = qrFragment != null
+
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal val scanCompleteListener: QrFragment.OnScanCompleteListener = object : QrFragment.OnScanCompleteListener {
         @MainThread
@@ -80,9 +87,12 @@ class QrFeature(
         this.containerViewId = containerViewId
 
         return if (context.isPermissionGranted(CAMERA)) {
-            fragmentManager.beginTransaction()
-                .add(containerViewId, QrFragment.newInstance(scanCompleteListener, scanMessage), QR_FRAGMENT_TAG)
-                .commit()
+            when (isScanInProgress) {
+                true -> qrFragment?.startScanning()
+                false -> fragmentManager.beginTransaction()
+                    .add(containerViewId, QrFragment.newInstance(scanCompleteListener, scanMessage), QR_FRAGMENT_TAG)
+                    .commit()
+            }
             true
         } else {
             onNeedToRequestPermissions(arrayOf(CAMERA))
@@ -97,6 +107,12 @@ class QrFeature(
     override fun onPermissionsResult(permissions: Array<String>, grantResults: IntArray) {
         if (context.isPermissionGranted(CAMERA)) {
             scan(containerViewId)
+        } else {
+            // It is possible that we started scanning then the user is will update
+            // the camera permission in Android settings.
+            // The client app is expected to ask again for the camera permission when the app is resumed
+            // and this request can be denied by the user so we should interrupt the in-progress scanning.
+            removeQrFragment()
         }
     }
 
@@ -106,11 +122,9 @@ class QrFeature(
      * @return true if the fragment was removed, otherwise false.
      */
     internal fun removeQrFragment(): Boolean {
-        with(fragmentManager) {
-            findFragmentByTag(QR_FRAGMENT_TAG)?.let {
-                beginTransaction().remove(it).commit()
-                return true
-            }
+        qrFragment?.let {
+            fragmentManager.beginTransaction().remove(it).commit()
+            return true
         }
         return false
     }
diff --git a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt
index 15fececdd357..6d16b3e93abb 100644
--- a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt
+++ b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt
@@ -15,6 +15,7 @@
 
 package mozilla.components.feature.qr
 
+import android.Manifest.permission
 import android.annotation.SuppressLint
 import android.content.Context
 import android.graphics.ImageFormat
@@ -63,6 +64,7 @@ import mozilla.components.feature.qr.views.AutoFitTextureView
 import mozilla.components.feature.qr.views.CustomViewFinder
 import mozilla.components.support.base.log.logger.Logger
 import mozilla.components.support.ktx.android.content.hasCamera
+import mozilla.components.support.ktx.android.content.isPermissionGranted
 import java.io.Serializable
 import java.util.ArrayList
 import java.util.Collections
@@ -83,7 +85,7 @@ import kotlin.math.min
  * https://github.com/googlesamples/android-Camera2Basic
  * https://github.com/kismkof/camera2basic
  */
-@Suppress("LargeClass")
+@Suppress("LargeClass", "TooManyFunctions")
 class QrFragment : Fragment() {
     private val logger = Logger("mozac-qr")
 
@@ -179,8 +181,11 @@ class QrFragment : Fragment() {
      * An additional thread for running tasks that shouldn't block the UI.
      * A [Handler] for running tasks in the background.
      */
-    private var backgroundThread: HandlerThread? = null
-    private var backgroundHandler: Handler? = null
+    @VisibleForTesting
+    internal var backgroundThread: HandlerThread? = null
+
+    @VisibleForTesting
+    internal var backgroundHandler: Handler? = null
 
     @VisibleForTesting
     internal var backgroundExecutor: ExecutorService? = null
@@ -241,18 +246,11 @@ class QrFragment : Fragment() {
 
     override fun onResume() {
         super.onResume()
-        startBackgroundThread()
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-            startExecutorService()
-        }
-        // When the screen is turned off and turned back on, the SurfaceTexture is already
-        // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
-        // a camera and start preview from here (otherwise, we wait until the surface is ready in
-        // the SurfaceTextureListener).
-        if (textureView.isAvailable) {
-            tryOpenCamera(textureView.width, textureView.height)
-        } else {
-            textureView.surfaceTextureListener = surfaceTextureListener
+
+        // It's possible that the Fragment is resumed to a scanning state
+        // while in the meantime the camera permission was removed. Avoid any issues.
+        if (requireContext().isPermissionGranted(permission.CAMERA)) {
+            startScanning()
         }
     }
 
@@ -270,10 +268,16 @@ class QrFragment : Fragment() {
         super.onStop()
     }
 
-    internal fun startBackgroundThread() {
-        backgroundThread = HandlerThread("CameraBackground").apply {
-            start()
-            backgroundHandler = Handler(this.looper)
+    internal fun maybeStartBackgroundThread() {
+        if (backgroundThread == null) {
+            backgroundThread = HandlerThread("CameraBackground")
+        }
+
+        backgroundThread?.let {
+            if (!it.isAlive) {
+                it.start()
+                backgroundHandler = Handler(it.looper)
+            }
         }
     }
 
@@ -288,8 +292,10 @@ class QrFragment : Fragment() {
         }
     }
 
-    internal fun startExecutorService() {
-        backgroundExecutor = Executors.newSingleThreadExecutor()
+    internal fun maybeStartExecutorService() {
+        if (backgroundExecutor == null) {
+            backgroundExecutor = Executors.newSingleThreadExecutor()
+        }
     }
 
     internal fun stopExecutorService() {
@@ -297,6 +303,27 @@ class QrFragment : Fragment() {
         backgroundExecutor = null
     }
 
+    /**
+     * Open the camera and start the qr scanning functionality.
+     * Assumes the camera permission is granted for the app.
+     * If any issues occur this will fail gracefully and show an error message.
+     */
+    fun startScanning() {
+        maybeStartBackgroundThread()
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+            maybeStartExecutorService()
+        }
+        // When the screen is turned off and turned back on, the SurfaceTexture is already
+        // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
+        // a camera and start preview from here (otherwise, we wait until the surface is ready in
+        // the SurfaceTextureListener).
+        if (textureView.isAvailable) {
+            tryOpenCamera(textureView.width, textureView.height)
+        } else {
+            textureView.surfaceTextureListener = surfaceTextureListener
+        }
+    }
+
     /**
      * Sets up member variables related to camera.
      *
@@ -386,6 +413,7 @@ class QrFragment : Fragment() {
         try {
             if (context?.hasCamera() == true || skipCheck) {
                 openCamera(width, height)
+                hideNoCameraAvailableError()
             } else {
                 showNoCameraAvailableError()
             }
@@ -399,6 +427,11 @@ class QrFragment : Fragment() {
         customViewFinder.visibility = View.GONE
     }
 
+    private fun hideNoCameraAvailableError() {
+        cameraErrorView.visibility = View.GONE
+        customViewFinder.visibility = View.VISIBLE
+    }
+
     /**
      * Opens the camera specified by [QrFragment.cameraId].
      */
@@ -539,7 +572,7 @@ class QrFragment : Fragment() {
     ) {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
             if (shouldStartExecutorService()) {
-                startExecutorService()
+                maybeStartExecutorService()
             }
             val sessionConfig = SessionConfiguration(
                 SessionConfiguration.SESSION_REGULAR,
diff --git a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt
index a65eb31cd4cb..1c8ece369c01 100644
--- a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt
+++ b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt
@@ -24,8 +24,10 @@ import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.ArgumentMatchers.anyString
 import org.mockito.Mock
+import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.never
 import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
 import org.mockito.MockitoAnnotations.openMocks
 
@@ -49,6 +51,15 @@ class QrFeatureTest {
         }
     }
 
+    fun `scanning is in progress if the scanning fragment is shown`() {
+        val feature = QrFeature(testContext, fragmentManager)
+
+        assertFalse(feature.isScanInProgress)
+
+        doReturn(mock<QrFragment>()).`when`(fragmentManager).findFragmentByTag(QR_FRAGMENT_TAG)
+        assertTrue(feature.isScanInProgress)
+    }
+
     @Test
     fun `feature requests camera permission if required`() {
         // Given
@@ -87,26 +98,43 @@ class QrFeatureTest {
         verify(fragmentManager).beginTransaction()
     }
 
+    @Test
+    fun `scan resumes qr fragment if permissions granted and scanning was already started`() {
+        grantPermission(CAMERA)
+        val feature = QrFeature(testContext, fragmentManager)
+        val qrFragment: QrFragment = mock()
+        doReturn(qrFragment).`when`(fragmentManager).findFragmentByTag(QR_FRAGMENT_TAG)
+
+        val scanResult = feature.scan()
+
+        assertTrue(scanResult)
+        verify(qrFragment).startScanning()
+    }
+
     @Test
     fun `onPermissionsResult displays scanner only if permission granted`() {
         // Given
-        val feature = QrFeature(
-            testContext,
-            fragmentManager,
+        val feature = spy(
+            QrFeature(
+                testContext,
+                fragmentManager,
+            ),
         )
 
         // When
         resolvePermissionRequestFrom(feature) { PermissionResolution.DENIED }
 
         // Then
-        verify(fragmentManager, never()).beginTransaction()
+        verify(feature, never()).scan(anyInt())
+        verify(feature).removeQrFragment()
 
         // When
         grantPermission(CAMERA)
         resolvePermissionRequestFrom(feature) { PermissionResolution.GRANTED }
 
         // Then
-        verify(fragmentManager).beginTransaction()
+        verify(feature, times(1)).scan(anyInt())
+        verify(feature, times(1)).removeQrFragment()
     }
 
     @Test
diff --git a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt
index 911f771e1637..98c58deec030 100644
--- a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt
+++ b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt
@@ -4,7 +4,9 @@
 
 package mozilla.components.feature.qr
 
+import android.Manifest.permission
 import android.content.Context
+import android.content.pm.PackageManager
 import android.hardware.camera2.CameraAccessException
 import android.hardware.camera2.CameraCaptureSession
 import android.hardware.camera2.CameraDevice
@@ -12,6 +14,8 @@ import android.hardware.camera2.CameraManager
 import android.hardware.camera2.params.SessionConfiguration
 import android.media.Image
 import android.os.Build
+import android.os.Handler
+import android.os.HandlerThread
 import android.os.Looper.getMainLooper
 import android.util.Size
 import android.view.Display
@@ -37,7 +41,9 @@ import mozilla.components.support.test.mock
 import mozilla.components.support.test.whenever
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertSame
+import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -45,6 +51,7 @@ import org.mockito.ArgumentMatchers.anyBoolean
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.ArgumentMatchers.anyString
 import org.mockito.Mockito.doNothing
+import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.never
 import org.mockito.Mockito.spy
 import org.mockito.Mockito.times
@@ -53,6 +60,7 @@ import org.mockito.Mockito.`when`
 import org.robolectric.Shadows.shadowOf
 import org.robolectric.annotation.Config
 import java.nio.ByteBuffer
+import java.util.concurrent.ExecutorService
 
 @RunWith(AndroidJUnit4::class)
 class QrFragmentTest {
@@ -80,20 +88,29 @@ class QrFragmentTest {
     @Test
     fun `onResume opens camera, starts background thread and starts executor service`() {
         val qrFragment = spy(QrFragment.newInstance(mock()))
-        whenever(qrFragment.setUpCameraOutputs(anyInt(), anyInt())).then { }
+        val context: Context = mock()
+        doReturn(PackageManager.PERMISSION_GRANTED)
+            .`when`(context).checkPermission(eq(permission.CAMERA), anyInt(), anyInt())
+        doReturn(context).`when`(qrFragment).context
+        doNothing().`when`(qrFragment).startScanning()
 
-        qrFragment.textureView = mock()
-        qrFragment.cameraErrorView = mock()
-        qrFragment.customViewFinder = mock()
         qrFragment.onResume()
-        verify(qrFragment, never()).tryOpenCamera(anyInt(), anyInt(), anyBoolean())
 
-        whenever(qrFragment.textureView.isAvailable).thenReturn(true)
-        qrFragment.cameraId = "mockCamera"
+        verify(qrFragment).startScanning()
+    }
+
+    @Test
+    fun `onResume avoids starting scanning if the camera permission is missing`() {
+        val qrFragment = spy(QrFragment.newInstance(mock()))
+        val context: Context = mock()
+        doReturn(PackageManager.PERMISSION_DENIED)
+            .`when`(context).checkPermission(eq(permission.CAMERA), anyInt(), anyInt())
+        doReturn(context).`when`(qrFragment).context
+        doNothing().`when`(qrFragment).startScanning()
+
         qrFragment.onResume()
-        verify(qrFragment, times(2)).startBackgroundThread()
-        verify(qrFragment, times(2)).startExecutorService()
-        verify(qrFragment).tryOpenCamera(anyInt(), anyInt(), anyBoolean())
+
+        verify(qrFragment, never()).startScanning()
     }
 
     @Test
@@ -105,12 +122,15 @@ class QrFragmentTest {
         qrFragment.cameraErrorView = mock()
         qrFragment.customViewFinder = mock()
         whenever(qrFragment.textureView.isAvailable).thenReturn(true)
-        doNothing().`when`(qrFragment).startBackgroundThread()
+        doNothing().`when`(qrFragment).maybeStartBackgroundThread()
         doNothing().`when`(qrFragment).tryOpenCamera(anyInt(), anyInt(), anyBoolean())
+        val context: Context = mock()
+        doReturn(PackageManager.PERMISSION_GRANTED).`when`(context).checkSelfPermission(permission.CAMERA)
+        doReturn(context).`when`(qrFragment).context
 
         qrFragment.onResume()
 
-        verify(qrFragment, never()).startExecutorService()
+        verify(qrFragment, never()).maybeStartExecutorService()
     }
 
     @Test
@@ -142,7 +162,7 @@ class QrFragmentTest {
         val surface = mock<Surface>()
         val stateCallback = mock<CameraCaptureSession.StateCallback>()
 
-        doNothing().`when`(qrFragment).startExecutorService()
+        doNothing().`when`(qrFragment).maybeStartExecutorService()
         whenever(qrFragment.shouldStartExecutorService()).thenReturn(true)
 
         qrFragment.backgroundExecutor = mock()
@@ -528,15 +548,18 @@ class QrFragmentTest {
     }
 
     @Test
-    fun `tryOpenCamera opens camera if available`() {
+    fun `tryOpenCamera opens camera if available and hides the error message is shown`() {
         val qrFragment = spy(QrFragment.newInstance(mock()))
-
         qrFragment.textureView = mock()
         qrFragment.cameraErrorView = mock()
         qrFragment.customViewFinder = mock()
+        doNothing().`when`(qrFragment).openCamera(anyInt(), anyInt())
 
         qrFragment.tryOpenCamera(0, 0, skipCheck = true)
+
         verify(qrFragment).openCamera(0, 0)
+        verify(qrFragment.cameraErrorView).visibility = View.GONE
+        verify(qrFragment.customViewFinder).visibility = View.VISIBLE
     }
 
     @Test
@@ -687,4 +710,77 @@ class QrFragmentTest {
 
         verify(mockDisplay, times(1)).getSize(any())
     }
+
+    @Test
+    fun `maybeStartBackgroundThread does nothing if the thread already exists`() {
+        val qrFragment = QrFragment()
+        val existingBackgroundThread = HandlerThread("test").apply {
+            start() // need the thread to be "alive"
+        }
+        val existingBackgroundHandler: Handler = mock()
+        qrFragment.backgroundThread = existingBackgroundThread
+        qrFragment.backgroundHandler = existingBackgroundHandler
+
+        qrFragment.maybeStartBackgroundThread()
+
+        assertSame(existingBackgroundThread, qrFragment.backgroundThread)
+        assertSame(existingBackgroundHandler, qrFragment.backgroundHandler)
+    }
+
+    @Test
+    fun `maybeStartBackgroundThread creates and starts a new background thread and handler if doesn't already exist`() {
+        val qrFragment = QrFragment()
+        qrFragment.backgroundThread = null
+        qrFragment.backgroundHandler = null
+
+        qrFragment.maybeStartBackgroundThread()
+
+        assertNotNull(qrFragment.backgroundThread)
+        assertTrue(qrFragment.backgroundThread!!.isAlive)
+        assertNotNull(qrFragment.backgroundHandler)
+    }
+
+    @Test
+    fun `maybeStartExecutorService does nothing if the executor already exists`() {
+        val qrFragment = QrFragment()
+        val existingExecutorService: ExecutorService = mock()
+        qrFragment.backgroundExecutor = existingExecutorService
+
+        qrFragment.maybeStartExecutorService()
+
+        assertSame(existingExecutorService, qrFragment.backgroundExecutor)
+    }
+
+    @Test
+    fun `maybeStartExecutorService creates a new executor service if doesn't exist already`() {
+        val qrFragment = QrFragment()
+        qrFragment.backgroundExecutor = null
+
+        qrFragment.maybeStartExecutorService()
+
+        assertNotNull(null, qrFragment.backgroundExecutor)
+    }
+
+    @Test
+    fun `startScanning opens camera, starts background thread and starts executor service`() {
+        val qrFragment = spy(QrFragment.newInstance(mock()))
+        whenever(qrFragment.setUpCameraOutputs(anyInt(), anyInt())).then { }
+        val context: Context = mock()
+        doReturn(PackageManager.PERMISSION_GRANTED)
+            .`when`(context).checkPermission(eq(permission.CAMERA), anyInt(), anyInt())
+        doReturn(context).`when`(qrFragment).context
+
+        qrFragment.textureView = mock()
+        qrFragment.cameraErrorView = mock()
+        qrFragment.customViewFinder = mock()
+        qrFragment.startScanning()
+        verify(qrFragment, never()).tryOpenCamera(anyInt(), anyInt(), anyBoolean())
+
+        whenever(qrFragment.textureView.isAvailable).thenReturn(true)
+        qrFragment.cameraId = "mockCamera"
+        qrFragment.startScanning()
+        verify(qrFragment, times(2)).maybeStartBackgroundThread()
+        verify(qrFragment, times(2)).maybeStartExecutorService()
+        verify(qrFragment).tryOpenCamera(anyInt(), anyInt(), anyBoolean())
+    }
 }
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 0abe16f5acd7..5d3516324f36 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -10,6 +10,9 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/android-components/blob/main/buildSrc/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/android-components/blob/main/.config.yml)
 
+* **feature-qr**
+  * QRFeature now allows querying if scanning is in progress with a new `isScanInProgress` property. This helps deciding on whether to resume scanning by calling `scan` in a new `QRFeature` instance as it can happen if the process is restarted as a followup to the user updating system permissions for the app.
+
 # 107.0.0
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v106.0.0..v107.0.0)
 * [Milestone](https://github.com/mozilla-mobile/android-components/milestone/154?closed=1)
