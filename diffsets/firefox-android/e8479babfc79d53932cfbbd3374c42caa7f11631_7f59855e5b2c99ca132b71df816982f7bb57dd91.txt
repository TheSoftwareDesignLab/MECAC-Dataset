diff --git a/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java b/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java
index 50326ab427ef..709f6f3f0841 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/browser/LocalizedContent.java
@@ -48,7 +48,7 @@ private static void loadAbout(@NonNull final IWebView webView, Context context)
 
         final Map<String, String> substitutionMap = new ArrayMap<>();
         final String appName = context.getResources().getString(R.string.app_name);
-        final String learnMoreURL = SupportUtils.getManifestoURL();
+        final String learnMoreURL = SupportUtils.INSTANCE.getManifestoURL();
 
         String aboutVersion = "";
         try {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
index 41233326edee..26dfef05b1cb 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/BrowserFragment.kt
@@ -1069,7 +1069,7 @@ class BrowserFragment : WebFragment(), LifecycleObserver, View.OnClickListener,
 
             R.id.help_trackers -> SessionManager.getInstance().createSession(
                 Source.MENU,
-                SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.TRACKERS)
+                SupportUtils.getSumoURLForTopic(context!!, SupportUtils.SumoTopic.TRACKERS)
             )
 
             R.id.add_to_homescreen -> {
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
index 1b48139271c2..2caf6d4ab061 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/fragment/UrlInputFragment.kt
@@ -382,7 +382,7 @@ class UrlInputFragment :
                 WhatsNew.userViewedWhatsNew(it)
 
                 SessionManager.getInstance().createSession(Source.MENU,
-                    SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.WHATS_NEW))
+                    SupportUtils.getSumoURLForTopic(it, SupportUtils.SumoTopic.WHATS_NEW))
             }
 
             R.id.settings -> (activity as LocaleAwareAppCompatActivity).openPreferences()
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.java
deleted file mode 100644
index eff6125b861b..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.menu.browser;
-
-import android.view.View;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.fragment.BrowserFragment;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.UrlUtils;
-
-import mozilla.components.support.utils.ThreadUtils;
-
-/* package-private */ class RequestDesktopCheckItemViewHolder extends BrowserMenuViewHolder implements
-        CheckBox.OnCheckedChangeListener {
-    /* package-private */ static final int LAYOUT_ID = R.layout.request_desktop_check_menu_item;
-
-    private final BrowserFragment fragment;
-    private CheckBox checkbox;
-
-    /* package */ RequestDesktopCheckItemViewHolder(View itemView, final BrowserFragment fragment) {
-        super(itemView);
-
-        this.fragment = fragment;
-
-        checkbox = itemView.findViewById(R.id.check_menu_item_checkbox);
-        checkbox.setChecked(fragment.getSession().shouldRequestDesktopSite());
-        checkbox.setOnCheckedChangeListener(this);
-    }
-
-    @Override
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        fragment.setShouldRequestDesktop(isChecked);
-        TelemetryWrapper.desktopRequestCheckEvent(isChecked);
-
-        // Delay closing the menu and reloading the website a bit so that the user can actually see
-        // the switch change its state.
-        ThreadUtils.INSTANCE.postToMainThreadDelayed(new Runnable() {
-            @Override
-            public void run() {
-                getMenu().dismiss();
-                fragment.loadUrl(UrlUtils.stripSchemeAndSubDomain(fragment.getUrl()));
-            }
-        }, /* Switch.THUMB_ANIMATION_DURATION */ 250);
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt
new file mode 100644
index 000000000000..9b3b715df083
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/browser/RequestDesktopCheckItemViewHolder.kt
@@ -0,0 +1,49 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.menu.browser
+
+import android.view.View
+import android.widget.CheckBox
+import android.widget.CompoundButton
+
+import org.mozilla.focus.R
+import org.mozilla.focus.fragment.BrowserFragment
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.utils.UrlUtils
+
+import mozilla.components.support.utils.ThreadUtils
+
+internal class RequestDesktopCheckItemViewHolder/* package */(
+    itemView: View,
+    private val fragment: BrowserFragment
+) : BrowserMenuViewHolder(itemView), CompoundButton.OnCheckedChangeListener {
+    private val checkbox: CheckBox = itemView.findViewById(R.id.check_menu_item_checkbox)
+
+    init {
+        checkbox.isChecked = fragment.session!!.shouldRequestDesktopSite()
+        checkbox.setOnCheckedChangeListener(this)
+    }
+
+    override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
+        fragment.setShouldRequestDesktop(isChecked)
+        TelemetryWrapper.desktopRequestCheckEvent(isChecked)
+
+        // Delay closing the menu and reloading the website a bit so that the user can actually see
+        // the switch change its state.
+        ThreadUtils.postToMainThreadDelayed(Runnable {
+            menu.dismiss()
+            fragment.loadUrl(UrlUtils.stripSchemeAndSubDomain(fragment.url))
+        }, ANIMATION_DURATION)
+    }
+
+    companion object {
+        const val LAYOUT_ID = R.layout.request_desktop_check_menu_item
+
+        /**
+         * Switch.THUMB_ANIMATION_DURATION
+         */
+        const val ANIMATION_DURATION = 250L
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.java b/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.java
deleted file mode 100644
index 8ca2e7ae1d11..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-package org.mozilla.focus.menu.context;
-
-import android.app.Dialog;
-import android.content.ClipData;
-import android.content.ClipboardManager;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.net.Uri;
-import android.os.Environment;
-import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
-import android.support.design.internal.NavigationMenuView;
-import android.support.design.widget.NavigationView;
-import android.support.v7.app.AlertDialog;
-import android.text.Html;
-import android.view.LayoutInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.TextView;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.session.SessionManager;
-import org.mozilla.focus.session.Source;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.telemetry.TelemetryWrapper.BrowserContextMenuValue;
-import org.mozilla.focus.utils.UrlUtils;
-import org.mozilla.focus.web.Download;
-import org.mozilla.focus.web.IWebView;
-
-/**
- * The context menu shown when long pressing a URL or an image inside the WebView.
- */
-public class WebContextMenu {
-
-    private static View createTitleView(final @NonNull Context context, final @NonNull String title) {
-        final TextView titleView = (TextView) LayoutInflater.from(context).inflate(R.layout.context_menu_title, null);
-        titleView.setText(title);
-        return titleView;
-    }
-
-    public static void show(final @NonNull Context context, final @NonNull IWebView.Callback callback, final @NonNull IWebView.HitTarget hitTarget) {
-        if (!(hitTarget.isLink || hitTarget.isImage)) {
-            // We don't support any other classes yet:
-            throw new IllegalStateException("WebContextMenu can only handle long-press on images and/or links.");
-        }
-
-        TelemetryWrapper.openWebContextMenuEvent();
-
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-
-        final View titleView;
-        if (hitTarget.isLink) {
-           titleView = createTitleView(context, hitTarget.linkURL);
-        } else if (hitTarget.isImage) {
-            titleView = createTitleView(context, hitTarget.imageURL);
-        } else {
-            throw new IllegalStateException("Unhandled long press target type");
-        }
-        builder.setCustomTitle(titleView);
-
-        final View view = LayoutInflater.from(context).inflate(R.layout.context_menu, null);
-        builder.setView(view);
-
-        builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialog) {
-                // What type of element was long-pressed
-                final BrowserContextMenuValue value;
-                if (hitTarget.isImage && hitTarget.isLink) {
-                    value = BrowserContextMenuValue.ImageWithLink;
-                } else if (hitTarget.isImage) {
-                    value = BrowserContextMenuValue.Image;
-                } else {
-                    value = BrowserContextMenuValue.Link;
-                }
-
-                // This even is only sent when the back button is pressed, or when a user
-                // taps outside of the dialog:
-                TelemetryWrapper.cancelWebContextMenuEvent(value);
-            }
-        });
-
-        final Dialog dialog = builder.create();
-        dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
-
-        final NavigationView menu = (NavigationView) view.findViewById(R.id.context_menu);
-        menu.setElevation(0);
-        NavigationMenuView navigationMenuView = (NavigationMenuView) menu.getChildAt(0);
-        if (navigationMenuView != null) {
-            navigationMenuView.setVerticalScrollBarEnabled(false);
-        }
-
-        setupMenuForHitTarget(dialog, menu, callback, hitTarget, context);
-
-        final TextView warningView = (TextView) view.findViewById(R.id.warning);
-        if (hitTarget.isImage) {
-            menu.setBackgroundResource(R.drawable.no_corners_context_menu_navigation_view_background);
-            //noinspection deprecation -- Mew API is only available on 24+
-            warningView.setText(Html.fromHtml(
-                    context.getString(R.string.contextmenu_image_warning, context.getString(R.string.app_name))));
-        } else {
-            warningView.setVisibility(View.GONE);
-        }
-
-        dialog.show();
-    }
-
-    /**
-     * Set up the correct menu contents. Note: this method can only be called once the Dialog
-     * has already been created - we need the dialog in order to be able to dismiss it in the
-     * menu callbacks.
-     */
-    private static void setupMenuForHitTarget(final @NonNull Dialog dialog,
-                                              final @NonNull NavigationView navigationView,
-                                              final @NonNull IWebView.Callback callback,
-                                              final @NonNull IWebView.HitTarget hitTarget,
-                                              final Context context) {
-        navigationView.inflateMenu(R.menu.menu_browser_context);
-
-        navigationView.getMenu().findItem(R.id.menu_new_tab).setVisible(hitTarget.isLink);
-        navigationView.getMenu().findItem(R.id.menu_link_share).setVisible(hitTarget.isLink);
-        navigationView.getMenu().findItem(R.id.menu_link_copy).setVisible(hitTarget.isLink);
-        navigationView.getMenu().findItem(R.id.menu_image_share).setVisible(hitTarget.isImage);
-        navigationView.getMenu().findItem(R.id.menu_image_copy).setVisible(hitTarget.isImage);
-
-        navigationView.getMenu().findItem(R.id.menu_image_save).setVisible(
-                hitTarget.isImage && UrlUtils.isHttpOrHttps(hitTarget.imageURL));
-
-        navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {
-            @Override
-            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
-                dialog.dismiss();
-
-                switch (item.getItemId()) {
-                    case R.id.menu_new_tab: {
-                        SessionManager.getInstance().createSession(Source.MENU, hitTarget.linkURL);
-                        TelemetryWrapper.openLinkInNewTabEvent();
-                        PreferenceManager.getDefaultSharedPreferences(context).edit()
-                                .putBoolean(context.getString(R.string.has_opened_new_tab),
-                                        true).apply();
-
-                        return true;
-                    }
-                    case R.id.menu_link_share: {
-                        TelemetryWrapper.shareLinkEvent();
-                        final Intent shareIntent = new Intent(Intent.ACTION_SEND);
-                        shareIntent.setType("text/plain");
-                        shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.linkURL);
-                        dialog.getContext().startActivity(Intent.createChooser(shareIntent, dialog.getContext().getString(R.string.share_dialog_title)));
-                        return true;
-                    }
-                    case R.id.menu_image_share: {
-                        TelemetryWrapper.shareImageEvent();
-                        final Intent shareIntent = new Intent(Intent.ACTION_SEND);
-                        shareIntent.setType("text/plain");
-                        shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.imageURL);
-                        dialog.getContext().startActivity(Intent.createChooser(shareIntent, dialog.getContext().getString(R.string.share_dialog_title)));
-                        return true;
-                    }
-                    case R.id.menu_image_save: {
-                        final Download download = new Download(hitTarget.imageURL, null, null, null, -1, Environment.DIRECTORY_PICTURES, null);
-                        callback.onDownloadStart(download);
-                        TelemetryWrapper.saveImageEvent();
-                        return true;
-                    }
-                    case R.id.menu_link_copy:
-                    case R.id.menu_image_copy:
-                        final ClipboardManager clipboard = (ClipboardManager)
-                                dialog.getContext().getSystemService(Context.CLIPBOARD_SERVICE);
-                        if (clipboard == null) {
-                            return true;
-                        }
-                        final Uri uri;
-
-                        if (item.getItemId() == R.id.menu_link_copy) {
-                            TelemetryWrapper.copyLinkEvent();
-                            uri = Uri.parse(hitTarget.linkURL);
-                        } else if (item.getItemId() == R.id.menu_image_copy) {
-                            TelemetryWrapper.copyImageEvent();
-                            uri = Uri.parse(hitTarget.imageURL);
-                        } else {
-                            throw new IllegalStateException("Unknown hitTarget type - cannot copy to clipboard");
-                        }
-
-                        final ClipData clip = ClipData.newUri(dialog.getContext().getContentResolver(), "URI", uri);
-                        clipboard.setPrimaryClip(clip);
-                        return true;
-                    default:
-                        throw new IllegalArgumentException("Unhandled menu item id=" + item.getItemId());
-                }
-            }
-        });
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt b/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt
new file mode 100644
index 000000000000..568d0b3a1c0f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/menu/context/WebContextMenu.kt
@@ -0,0 +1,199 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+package org.mozilla.focus.menu.context
+
+import android.app.Dialog
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.graphics.Color
+import android.graphics.drawable.ColorDrawable
+import android.net.Uri
+import android.os.Environment
+import android.preference.PreferenceManager
+import android.support.design.internal.NavigationMenuView
+import android.support.design.widget.NavigationView
+import android.support.v7.app.AlertDialog
+import android.text.Html
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.TextView
+import org.mozilla.focus.R
+import org.mozilla.focus.session.SessionManager
+import org.mozilla.focus.session.Source
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.telemetry.TelemetryWrapper.BrowserContextMenuValue
+import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.web.Download
+import org.mozilla.focus.web.IWebView
+
+/**
+ * The context menu shown when long pressing a URL or an image inside the WebView.
+ */
+object WebContextMenu {
+    private fun createTitleView(context: Context, title: String): View {
+        val titleView = LayoutInflater.from(context).inflate(R.layout.context_menu_title, null) as TextView
+        titleView.text = title
+        return titleView
+    }
+
+    @Suppress("ComplexMethod")
+    fun show(context: Context, callback: IWebView.Callback, hitTarget: IWebView.HitTarget) {
+        if (!(hitTarget.isLink || hitTarget.isImage)) {
+            // We don't support any other classes yet:
+            throw IllegalStateException("WebContextMenu can only handle long-press on images and/or links.")
+        }
+
+        TelemetryWrapper.openWebContextMenuEvent()
+
+        val builder = AlertDialog.Builder(context)
+
+        builder.setCustomTitle(when {
+            hitTarget.isLink -> createTitleView(context, hitTarget.linkURL)
+            hitTarget.isImage -> createTitleView(context, hitTarget.imageURL)
+            else -> throw IllegalStateException("Unhandled long press target type")
+        })
+
+        val view = LayoutInflater.from(context).inflate(R.layout.context_menu, null)
+        builder.setView(view)
+
+        builder.setOnCancelListener {
+            // What type of element was long-pressed
+            val value: BrowserContextMenuValue = if (hitTarget.isImage && hitTarget.isLink) {
+                BrowserContextMenuValue.ImageWithLink
+            } else if (hitTarget.isImage) {
+                BrowserContextMenuValue.Image
+            } else {
+                BrowserContextMenuValue.Link
+            }
+
+            // This even is only sent when the back button is pressed, or when a user
+            // taps outside of the dialog:
+            TelemetryWrapper.cancelWebContextMenuEvent(value)
+        }
+
+        val dialog = builder.create()
+        dialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
+
+        val menu = view.findViewById<View>(R.id.context_menu) as NavigationView
+        menu.elevation = 0f
+        val navigationMenuView = menu.getChildAt(0) as? NavigationMenuView
+        if (navigationMenuView != null) {
+            navigationMenuView.isVerticalScrollBarEnabled = false
+        }
+
+        setupMenuForHitTarget(dialog, menu, callback, hitTarget, context)
+
+        val warningView = view.findViewById<View>(R.id.warning) as TextView
+        if (hitTarget.isImage) {
+            menu.setBackgroundResource(R.drawable.no_corners_context_menu_navigation_view_background)
+
+            @Suppress("DEPRECATION")
+            warningView.text = Html.fromHtml(
+                context.getString(R.string.contextmenu_image_warning, context.getString(R.string.app_name))
+            )
+        } else {
+            warningView.visibility = View.GONE
+        }
+
+        dialog.show()
+    }
+
+    /**
+     * Set up the correct menu contents. Note: this method can only be called once the Dialog
+     * has already been created - we need the dialog in order to be able to dismiss it in the
+     * menu callbacks.
+     */
+    @Suppress("ComplexMethod")
+    private fun setupMenuForHitTarget(
+        dialog: Dialog,
+        navigationView: NavigationView,
+        callback: IWebView.Callback,
+        hitTarget: IWebView.HitTarget,
+        context: Context
+    ) = with(navigationView) {
+        inflateMenu(R.menu.menu_browser_context)
+
+        menu.findItem(R.id.menu_new_tab).isVisible = hitTarget.isLink
+        menu.findItem(R.id.menu_link_share).isVisible = hitTarget.isLink
+        menu.findItem(R.id.menu_link_copy).isVisible = hitTarget.isLink
+        menu.findItem(R.id.menu_image_share).isVisible = hitTarget.isImage
+        menu.findItem(R.id.menu_image_copy).isVisible = hitTarget.isImage
+
+        menu.findItem(R.id.menu_image_save).isVisible = hitTarget.isImage &&
+            UrlUtils.isHttpOrHttps(hitTarget.imageURL)
+
+        setNavigationItemSelectedListener { item ->
+            dialog.dismiss()
+
+            when (item.itemId) {
+                R.id.menu_new_tab -> {
+                    SessionManager.getInstance().createSession(Source.MENU, hitTarget.linkURL)
+                    TelemetryWrapper.openLinkInNewTabEvent()
+                    PreferenceManager.getDefaultSharedPreferences(context).edit()
+                        .putBoolean(
+                            context.getString(R.string.has_opened_new_tab),
+                            true
+                        ).apply()
+
+                    true
+                }
+                R.id.menu_link_share -> {
+                    TelemetryWrapper.shareLinkEvent()
+                    val shareIntent = Intent(Intent.ACTION_SEND)
+                    shareIntent.type = "text/plain"
+                    shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.linkURL)
+                    dialog.context.startActivity(
+                        Intent.createChooser(
+                            shareIntent,
+                            dialog.context.getString(R.string.share_dialog_title)
+                        )
+                    )
+                    true
+                }
+                R.id.menu_image_share -> {
+                    TelemetryWrapper.shareImageEvent()
+                    val shareIntent = Intent(Intent.ACTION_SEND)
+                    shareIntent.type = "text/plain"
+                    shareIntent.putExtra(Intent.EXTRA_TEXT, hitTarget.imageURL)
+                    dialog.context.startActivity(
+                        Intent.createChooser(
+                            shareIntent,
+                            dialog.context.getString(R.string.share_dialog_title)
+                        )
+                    )
+                    true
+                }
+                R.id.menu_image_save -> {
+                    val download =
+                        Download(hitTarget.imageURL, null, null, null, -1, Environment.DIRECTORY_PICTURES, null)
+                    callback.onDownloadStart(download)
+                    TelemetryWrapper.saveImageEvent()
+                    true
+                }
+                R.id.menu_link_copy, R.id.menu_image_copy -> {
+                    val clipboard = dialog.context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+                    val uri: Uri = when {
+                        item.itemId == R.id.menu_link_copy -> {
+                            TelemetryWrapper.copyLinkEvent()
+                            Uri.parse(hitTarget.linkURL)
+                        }
+                        item.itemId == R.id.menu_image_copy -> {
+                            TelemetryWrapper.copyImageEvent()
+                            Uri.parse(hitTarget.imageURL)
+                        }
+                        else -> throw IllegalStateException("Unknown hitTarget type - cannot copy to clipboard")
+                    }
+
+                    val clip = ClipData.newUri(dialog.context.contentResolver, "URI", uri)
+                    clipboard.primaryClip = clip
+                    true
+                }
+                else -> throw IllegalArgumentException("Unhandled menu item id=" + item.itemId)
+            }
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
index fc07c1cfdff9..1bc2ee4e8f55 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/searchsuggestions/ui/SearchSuggestionsFragment.kt
@@ -147,7 +147,7 @@ class SearchSuggestionsFragment : Fragment() {
 
         val learnMoreSpan = object : ClickableSpan() {
             override fun onClick(textView: View) {
-                val url = SupportUtils.getSumoURLForTopic(context, SupportUtils.SumoTopic.SEARCH_SUGGESTIONS)
+                val url = SupportUtils.getSumoURLForTopic(context!!, SupportUtils.SumoTopic.SEARCH_SUGGESTIONS)
                 SessionManager.getInstance().createSession(Source.MENU, url)
             }
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.java b/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.java
deleted file mode 100644
index 5895c45c92cc..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session;
-
-import android.content.Context;
-import android.support.annotation.NonNull;
-
-import org.mozilla.focus.architecture.NonNullObserver;
-
-import java.util.List;
-
-public class NotificationSessionObserver extends NonNullObserver<List<Session>> {
-    private final Context context;
-
-    public NotificationSessionObserver(Context context) {
-        this.context = context;
-    }
-
-    @Override
-    protected void onValueChanged(@NonNull List<Session> sessions) {
-        if (sessions.isEmpty()) {
-            SessionNotificationService.stop(context);
-        } else {
-            SessionNotificationService.start(context);
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.kt
new file mode 100644
index 000000000000..a05a4c07207f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/NotificationSessionObserver.kt
@@ -0,0 +1,19 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session
+
+import android.content.Context
+
+import org.mozilla.focus.architecture.NonNullObserver
+
+class NotificationSessionObserver(private val context: Context) : NonNullObserver<List<Session>>() {
+    override fun onValueChanged(t: List<Session>) {
+        if (t.isEmpty()) {
+            SessionNotificationService.stop(context)
+        } else {
+            SessionNotificationService.start(context)
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java
deleted file mode 100644
index f904d09770a8..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session;
-
-import android.app.Notification;
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Build;
-import android.os.IBinder;
-import android.support.annotation.Nullable;
-import android.support.v4.app.NotificationCompat;
-import android.support.v4.content.ContextCompat;
-
-import org.mozilla.focus.R;
-import org.mozilla.focus.activity.MainActivity;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-
-/**
- * As long as a session is active this service will keep the notification (and our process) alive.
- */
-public class SessionNotificationService extends Service {
-    private static final int NOTIFICATION_ID = 83;
-
-    private static final String NOTIFICATION_CHANNEL_ID = "browsing-session";
-
-    private static final String ACTION_START = "start";
-    private static final String ACTION_ERASE = "erase";
-
-    /* package */ static void start(Context context) {
-        final Intent intent = new Intent(context, SessionNotificationService.class);
-        intent.setAction(ACTION_START);
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            context.startForegroundService(intent);
-        } else {
-            context.startService(intent);
-        }
-    }
-
-    /* package */ static void stop(Context context) {
-        final Intent intent = new Intent(context, SessionNotificationService.class);
-
-        context.stopService(intent);
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        final String action = intent.getAction();
-        if (action == null) {
-            return START_NOT_STICKY;
-        }
-
-        switch (action) {
-            case ACTION_START:
-                createNotificationChannelIfNeeded();
-                startForeground(NOTIFICATION_ID, buildNotification());
-                break;
-
-            case ACTION_ERASE:
-                TelemetryWrapper.eraseNotificationEvent();
-
-                SessionManager.getInstance().removeAllSessions();
-
-                VisibilityLifeCycleCallback.finishAndRemoveTaskIfInBackground(this);
-                break;
-
-            default:
-                throw new IllegalStateException("Unknown intent: " + intent);
-        }
-
-        return START_NOT_STICKY;
-    }
-
-    @Override
-    public void onTaskRemoved(Intent rootIntent) {
-        TelemetryWrapper.eraseTaskRemoved();
-
-        SessionManager.getInstance().removeAllSessions();
-
-        stopForeground(true);
-        stopSelf();
-    }
-
-    private Notification buildNotification() {
-        return new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
-                .setOngoing(true)
-                .setSmallIcon(R.drawable.ic_notification)
-                .setContentTitle(getString(R.string.app_name))
-                .setContentText(getString(R.string.notification_erase_text))
-                .setContentIntent(createNotificationIntent())
-                .setVisibility(NotificationCompat.VISIBILITY_SECRET)
-                .setShowWhen(false)
-                .setLocalOnly(true)
-                .setColor(ContextCompat.getColor(this, R.color.colorErase))
-                .addAction(new NotificationCompat.Action(
-                        R.drawable.ic_notification,
-                        getString(R.string.notification_action_open),
-                        createOpenActionIntent()))
-                .addAction(new NotificationCompat.Action(
-                        R.drawable.ic_delete,
-                        getString(R.string.notification_action_erase_and_open),
-                        createOpenAndEraseActionIntent()))
-                .build();
-    }
-
-    private PendingIntent createNotificationIntent() {
-        final Intent intent = new Intent(this, SessionNotificationService.class);
-        intent.setAction(ACTION_ERASE);
-
-        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);
-    }
-
-    private PendingIntent createOpenActionIntent() {
-        final Intent intent = new Intent(this, MainActivity.class);
-        intent.setAction(MainActivity.ACTION_OPEN);
-
-        return PendingIntent.getActivity(this, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT);
-    }
-
-    private PendingIntent createOpenAndEraseActionIntent() {
-        final Intent intent = new Intent(this, MainActivity.class);
-
-        intent.setAction(MainActivity.ACTION_ERASE);
-        intent.putExtra(MainActivity.EXTRA_NOTIFICATION, true);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        return PendingIntent.getActivity(this, 2, intent, PendingIntent.FLAG_UPDATE_CURRENT);
-    }
-
-    public void createNotificationChannelIfNeeded() {
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
-            // Notification channels are only available on Android O or higher.
-            return;
-        }
-
-        final NotificationManager notificationManager = getSystemService(NotificationManager.class);
-        if (notificationManager == null) {
-            return;
-        }
-
-        final String notificationChannelName = getString(R.string.notification_browsing_session_channel_name);
-        final String notificationChannelDescription = getString(
-                R.string.notification_browsing_session_channel_description,
-                getString(R.string.app_name));
-
-        final NotificationChannel channel = new NotificationChannel(
-                NOTIFICATION_CHANNEL_ID, notificationChannelName, NotificationManager.IMPORTANCE_MIN);
-        channel.setImportance(NotificationManager.IMPORTANCE_LOW);
-        channel.setDescription(notificationChannelDescription);
-        channel.enableLights(false);
-        channel.enableVibration(false);
-        channel.setShowBadge(true);
-
-        notificationManager.createNotificationChannel(channel);
-    }
-
-    @Nullable
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt
new file mode 100644
index 000000000000..248724de0a9b
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/SessionNotificationService.kt
@@ -0,0 +1,165 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session
+
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.app.Service
+import android.content.Context
+import android.content.Intent
+import android.os.Build
+import android.os.IBinder
+import android.support.v4.app.NotificationCompat
+import android.support.v4.content.ContextCompat
+
+import org.mozilla.focus.R
+import org.mozilla.focus.activity.MainActivity
+import org.mozilla.focus.telemetry.TelemetryWrapper
+
+/**
+ * As long as a session is active this service will keep the notification (and our process) alive.
+ */
+class SessionNotificationService : Service() {
+    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
+        val action = intent.action ?: return Service.START_NOT_STICKY
+
+        when (action) {
+            ACTION_START -> {
+                createNotificationChannelIfNeeded()
+                startForeground(NOTIFICATION_ID, buildNotification())
+            }
+
+            ACTION_ERASE -> {
+                TelemetryWrapper.eraseNotificationEvent()
+
+                SessionManager.getInstance().removeAllSessions()
+
+                VisibilityLifeCycleCallback.finishAndRemoveTaskIfInBackground(this)
+            }
+
+            else -> throw IllegalStateException("Unknown intent: $intent")
+        }
+
+        return Service.START_NOT_STICKY
+    }
+
+    override fun onTaskRemoved(rootIntent: Intent) {
+        TelemetryWrapper.eraseTaskRemoved()
+
+        SessionManager.getInstance().removeAllSessions()
+
+        stopForeground(true)
+        stopSelf()
+    }
+
+    private fun buildNotification(): Notification {
+        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
+            .setOngoing(true)
+            .setSmallIcon(R.drawable.ic_notification)
+            .setContentTitle(getString(R.string.app_name))
+            .setContentText(getString(R.string.notification_erase_text))
+            .setContentIntent(createNotificationIntent())
+            .setVisibility(NotificationCompat.VISIBILITY_SECRET)
+            .setShowWhen(false)
+            .setLocalOnly(true)
+            .setColor(ContextCompat.getColor(this, R.color.colorErase))
+            .addAction(
+                NotificationCompat.Action(
+                    R.drawable.ic_notification,
+                    getString(R.string.notification_action_open),
+                    createOpenActionIntent()
+                )
+            )
+            .addAction(
+                NotificationCompat.Action(
+                    R.drawable.ic_delete,
+                    getString(R.string.notification_action_erase_and_open),
+                    createOpenAndEraseActionIntent()
+                )
+            )
+            .build()
+    }
+
+    private fun createNotificationIntent(): PendingIntent {
+        val intent = Intent(this, SessionNotificationService::class.java)
+        intent.action = ACTION_ERASE
+
+        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_ONE_SHOT)
+    }
+
+    private fun createOpenActionIntent(): PendingIntent {
+        val intent = Intent(this, MainActivity::class.java)
+        intent.action = MainActivity.ACTION_OPEN
+
+        return PendingIntent.getActivity(this, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT)
+    }
+
+    private fun createOpenAndEraseActionIntent(): PendingIntent {
+        val intent = Intent(this, MainActivity::class.java)
+
+        intent.action = MainActivity.ACTION_ERASE
+        intent.putExtra(MainActivity.EXTRA_NOTIFICATION, true)
+        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
+
+        return PendingIntent.getActivity(this, 2, intent, PendingIntent.FLAG_UPDATE_CURRENT)
+    }
+
+    private fun createNotificationChannelIfNeeded() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+            // Notification channels are only available on Android O or higher.
+            return
+        }
+
+        val notificationManager = getSystemService(NotificationManager::class.java) ?: return
+
+        val notificationChannelName = getString(R.string.notification_browsing_session_channel_name)
+        val notificationChannelDescription = getString(
+            R.string.notification_browsing_session_channel_description,
+            getString(R.string.app_name)
+        )
+
+        val channel = NotificationChannel(
+            NOTIFICATION_CHANNEL_ID, notificationChannelName, NotificationManager.IMPORTANCE_MIN
+        )
+        channel.importance = NotificationManager.IMPORTANCE_LOW
+        channel.description = notificationChannelDescription
+        channel.enableLights(false)
+        channel.enableVibration(false)
+        channel.setShowBadge(true)
+
+        notificationManager.createNotificationChannel(channel)
+    }
+
+    override fun onBind(intent: Intent): IBinder? {
+        return null
+    }
+
+    companion object {
+        private const val NOTIFICATION_ID = 83
+        private const val NOTIFICATION_CHANNEL_ID = "browsing-session"
+
+        private const val ACTION_START = "start"
+        private const val ACTION_ERASE = "erase"
+
+        internal fun start(context: Context) {
+            val intent = Intent(context, SessionNotificationService::class.java)
+            intent.action = ACTION_START
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                context.startForegroundService(intent)
+            } else {
+                context.startService(intent)
+            }
+        }
+
+        internal fun stop(context: Context) {
+            val intent = Intent(context, SessionNotificationService::class.java)
+
+            context.stopService(intent)
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.java b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.java
deleted file mode 100644
index fc26cb1906ab..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.session.ui;
-
-import android.arch.lifecycle.Observer;
-import android.support.v7.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import org.mozilla.focus.session.Session;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Adapter implementation to show a list of active browsing sessions and an "erase" button at the end.
- */
-public class SessionsAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> implements Observer<List<Session>> {
-    private final SessionsSheetFragment fragment;
-    private List<Session> sessions;
-
-    /* package */ SessionsAdapter(SessionsSheetFragment fragment) {
-        this.fragment = fragment;
-        this.sessions = Collections.emptyList();
-    }
-
-    @Override
-    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        final LayoutInflater inflater = LayoutInflater.from(parent.getContext());
-
-        switch (viewType) {
-            case EraseViewHolder.LAYOUT_ID:
-                return new EraseViewHolder(
-                        fragment,
-                        inflater.inflate(EraseViewHolder.LAYOUT_ID, parent, false));
-            case SessionViewHolder.LAYOUT_ID:
-                return new SessionViewHolder(
-                        fragment,
-                        (TextView) inflater.inflate(SessionViewHolder.LAYOUT_ID, parent, false));
-            default:
-                throw new IllegalStateException("Unknown viewType");
-        }
-    }
-
-    @Override
-    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
-        switch (holder.getItemViewType()) {
-            case EraseViewHolder.LAYOUT_ID:
-                // Nothing to do here.
-                break;
-            case SessionViewHolder.LAYOUT_ID:
-                ((SessionViewHolder) holder).bind(sessions.get(position));
-                break;
-            default:
-                throw new IllegalStateException("Unknown viewType");
-        }
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        if (isErasePosition(position)) {
-            return EraseViewHolder.LAYOUT_ID;
-        } else {
-            return SessionViewHolder.LAYOUT_ID;
-        }
-    }
-
-    private boolean isErasePosition(int position) {
-        return position == sessions.size();
-    }
-
-    @Override
-    public int getItemCount() {
-        return sessions.size() + 1;
-    }
-
-    @Override
-    public void onChanged(List<Session> sessions) {
-        this.sessions = new ArrayList<>(sessions);
-        notifyDataSetChanged();
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.kt b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.kt
new file mode 100644
index 000000000000..47bcafe03aae
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/session/ui/SessionsAdapter.kt
@@ -0,0 +1,72 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.session.ui
+
+import android.arch.lifecycle.Observer
+import android.support.v7.widget.RecyclerView
+import android.view.LayoutInflater
+import android.view.ViewGroup
+import android.widget.TextView
+
+import org.mozilla.focus.session.Session
+
+import java.util.ArrayList
+
+/**
+ * Adapter implementation to show a list of active browsing sessions and an "erase" button at the end.
+ */
+class SessionsAdapter/* package */ internal constructor(private val fragment: SessionsSheetFragment) :
+    RecyclerView.Adapter<RecyclerView.ViewHolder>(), Observer<List<Session>> {
+    private var sessions: List<Session>? = null
+
+    init {
+        this.sessions = emptyList()
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
+        val inflater = LayoutInflater.from(parent.context)
+
+        return when (viewType) {
+            EraseViewHolder.LAYOUT_ID -> EraseViewHolder(
+                fragment,
+                inflater.inflate(EraseViewHolder.LAYOUT_ID, parent, false)
+            )
+            SessionViewHolder.LAYOUT_ID -> SessionViewHolder(
+                fragment,
+                inflater.inflate(SessionViewHolder.LAYOUT_ID, parent, false) as TextView
+            )
+            else -> throw IllegalStateException("Unknown viewType")
+        }
+    }
+
+    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
+        when (holder.itemViewType) {
+            EraseViewHolder.LAYOUT_ID -> { /* Nothing to do */ }
+            SessionViewHolder.LAYOUT_ID -> (holder as SessionViewHolder).bind(sessions!![position])
+            else -> throw IllegalStateException("Unknown viewType")
+        }
+    }
+
+    override fun getItemViewType(position: Int): Int {
+        return if (isErasePosition(position)) {
+            EraseViewHolder.LAYOUT_ID
+        } else {
+            SessionViewHolder.LAYOUT_ID
+        }
+    }
+
+    private fun isErasePosition(position: Int): Boolean {
+        return position == sessions!!.size
+    }
+
+    override fun getItemCount(): Int {
+        return sessions!!.size + 1
+    }
+
+    override fun onChanged(sessions: List<Session>?) {
+        this.sessions = ArrayList(sessions!!)
+        notifyDataSetChanged()
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt b/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
index 877a4dff832d..6ae2d87b66d6 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/settings/ManualAddSearchEngineSettingsFragment.kt
@@ -85,7 +85,7 @@ class ManualAddSearchEngineSettingsFragment : BaseSettingsFragment() {
     override fun onOptionsItemSelected(item: MenuItem?): Boolean {
         val openLearnMore = {
             SessionManager.getInstance().createSession(Source.MENU, SupportUtils
-                .getSumoURLForTopic(activity, SupportUtils.SumoTopic.ADD_SEARCH_ENGINE))
+                .getSumoURLForTopic(activity!!, SupportUtils.SumoTopic.ADD_SEARCH_ENGINE))
             activity!!.finish()
             TelemetryWrapper.addSearchEngineLearnMoreEvent()
         }
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.java b/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.java
deleted file mode 100644
index 8d061947d18a..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.utils;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-
-import android.os.Build;
-import android.provider.Settings;
-import android.support.annotation.VisibleForTesting;
-
-import org.mozilla.focus.locale.Locales;
-import org.mozilla.focus.session.SessionManager;
-import org.mozilla.focus.session.Source;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-import java.util.Locale;
-
-public class SupportUtils {
-    public static final String HELP_URL = "https://support.mozilla.org/kb/what-firefox-focus-android";
-    public static final String DEFAULT_BROWSER_URL = "https://support.mozilla.org/kb/set-firefox-focus-default-browser-android";
-    public static final String REPORT_SITE_ISSUE_URL = "https://webcompat.com/issues/new?url=%s&label=browser-focus-geckoview";
-
-    public static final String PRIVACY_NOTICE_URL = "https://www.mozilla.org/privacy/firefox-focus/";
-    public static final String PRIVACY_NOTICE_KLAR_URL = "https://www.mozilla.org/de/privacy/firefox-klar/";
-
-    public enum SumoTopic {
-        ADD_SEARCH_ENGINE("add-search-engine"),
-        AUTOCOMPLETE("autofill-domain-android"),
-        TRACKERS("trackers"),
-        USAGE_DATA("usage-data"),
-        WHATS_NEW("whats-new-focus-android-7"),
-        SEARCH_SUGGESTIONS("search-suggestions-focus-android");
-
-        /** The final path segment for a SUMO URL - see {@see #getSumoURLForTopic} */
-        @VisibleForTesting final String topicStr;
-
-        SumoTopic(final String topicStr) {
-            this.topicStr = topicStr;
-        }
-    }
-
-    public static String getSumoURLForTopic(final Context context, final SumoTopic topic) {
-        final String escapedTopic = getEncodedTopicUTF8(topic.topicStr);
-        final String appVersion = getAppVersion(context);
-        final String osTarget = "Android";
-        final String langTag = Locales.getLanguageTag(Locale.getDefault());
-        return "https://support.mozilla.org/1/mobile/" + appVersion + "/" + osTarget + "/" + langTag + "/" + escapedTopic;
-    }
-
-    public static String getManifestoURL() {
-        final String langTag = Locales.getLanguageTag(Locale.getDefault());
-        return "https://www.mozilla.org/" + langTag + "/about/manifesto/";
-    }
-
-    private static String getEncodedTopicUTF8(final String topic) {
-        try {
-            return URLEncoder.encode(topic, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException("utf-8 should always be available", e);
-        }
-    }
-
-    private static String getAppVersion(final Context context) {
-        try {
-            return context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
-        } catch (PackageManager.NameNotFoundException e) {
-            // This should be impossible - we should always be able to get information about ourselves:
-            throw new IllegalStateException("Unable find package details for Focus", e);
-        }
-    }
-
-    public static void openDefaultBrowserSumoPage(Context context) {
-        SessionManager.getInstance().createSession(Source.MENU, SupportUtils.DEFAULT_BROWSER_URL);
-
-        if (context instanceof Activity) {
-            ((Activity) context).finish();
-        } else {
-            openDefaultBrowserSumoPage(((ContextWrapper) context).getBaseContext());
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.N)
-    public static void openDefaultAppsSettings(Context context) {
-        try {
-            Intent intent = new Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS);
-            context.startActivity(intent);
-        } catch (ActivityNotFoundException e) {
-            // In some cases, a matching Activity may not exist (according to the Android docs).
-            openDefaultBrowserSumoPage(context);
-        }
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt b/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt
new file mode 100644
index 000000000000..9247175a4c6f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/utils/SupportUtils.kt
@@ -0,0 +1,94 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.utils
+
+import android.annotation.TargetApi
+import android.app.Activity
+import android.content.ActivityNotFoundException
+import android.content.Context
+import android.content.ContextWrapper
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.os.Build
+import android.provider.Settings
+import org.mozilla.focus.locale.Locales
+import org.mozilla.focus.session.SessionManager
+import org.mozilla.focus.session.Source
+import java.io.UnsupportedEncodingException
+import java.net.URLEncoder
+import java.util.Locale
+
+object SupportUtils {
+    const val HELP_URL = "https://support.mozilla.org/kb/what-firefox-focus-android"
+    const val DEFAULT_BROWSER_URL = "https://support.mozilla.org/kb/set-firefox-focus-default-browser-android"
+    const val REPORT_SITE_ISSUE_URL = "https://webcompat.com/issues/new?url=%s&label=browser-focus-geckoview"
+    const val PRIVACY_NOTICE_URL = "https://www.mozilla.org/privacy/firefox-focus/"
+    const val PRIVACY_NOTICE_KLAR_URL = "https://www.mozilla.org/de/privacy/firefox-klar/"
+
+    val manifestoURL: String
+        get() {
+            val langTag = Locales.getLanguageTag(Locale.getDefault())
+            return "https://www.mozilla.org/$langTag/about/manifesto/"
+        }
+
+    enum class SumoTopic(
+        /** The final path segment for a SUMO URL - see {@see #getSumoURLForTopic}  */
+        internal val topicStr: String
+    ) {
+        ADD_SEARCH_ENGINE("add-search-engine"),
+        AUTOCOMPLETE("autofill-domain-android"),
+        TRACKERS("trackers"),
+        USAGE_DATA("usage-data"),
+        WHATS_NEW("whats-new-focus-android-7"),
+        SEARCH_SUGGESTIONS("search-suggestions-focus-android")
+    }
+
+    fun getSumoURLForTopic(context: Context, topic: SumoTopic): String {
+        val escapedTopic = getEncodedTopicUTF8(topic.topicStr)
+        val appVersion = getAppVersion(context)
+        val osTarget = "Android"
+        val langTag = Locales.getLanguageTag(Locale.getDefault())
+        return "https://support.mozilla.org/1/mobile/$appVersion/$osTarget/$langTag/$escapedTopic"
+    }
+
+    private fun getEncodedTopicUTF8(topic: String): String {
+        try {
+            return URLEncoder.encode(topic, "UTF-8")
+        } catch (e: UnsupportedEncodingException) {
+            throw IllegalStateException("utf-8 should always be available", e)
+        }
+    }
+
+    private fun getAppVersion(context: Context): String {
+        try {
+            return context.packageManager.getPackageInfo(context.packageName, 0).versionName
+        } catch (e: PackageManager.NameNotFoundException) {
+            // This should be impossible - we should always be able to get information about ourselves:
+            throw IllegalStateException("Unable find package details for Focus", e)
+        }
+    }
+
+    fun openDefaultBrowserSumoPage(context: Context) {
+        SessionManager.getInstance().createSession(Source.MENU, SupportUtils.DEFAULT_BROWSER_URL)
+
+        if (context is Activity) {
+            context.finish()
+        } else {
+            openDefaultBrowserSumoPage((context as ContextWrapper).baseContext)
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.N)
+    fun openDefaultAppsSettings(context: Context) {
+        try {
+            val intent = Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS)
+            context.startActivity(intent)
+        } catch (e: ActivityNotFoundException) {
+            // In some cases, a matching Activity may not exist (according to the Android docs).
+            openDefaultBrowserSumoPage(context)
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java b/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java
index 2f86c7d69f81..08d9e9c81bbe 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/web/ClassicWebViewProvider.java
@@ -39,7 +39,7 @@ public void preload(@NonNull final Context context) {
     }
 
     public void performCleanup(@NonNull final Context context) {
-        SystemWebView.deleteContentFromKnownLocations(context);
+        SystemWebView.Companion.deleteContentFromKnownLocations(context);
     }
 
     /**
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.java b/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.java
deleted file mode 100644
index a2dcd1092f8d..000000000000
--- a/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.focus.webview;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Environment;
-import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.SparseArray;
-import android.view.View;
-import android.view.autofill.AutofillValue;
-import android.view.inputmethod.EditorInfo;
-import android.view.inputmethod.InputConnection;
-import android.webkit.CookieManager;
-import android.webkit.DownloadListener;
-import android.webkit.WebBackForwardList;
-import android.webkit.WebChromeClient;
-import android.webkit.WebStorage;
-import android.webkit.WebView;
-import android.webkit.WebViewDatabase;
-
-import org.mozilla.focus.BuildConfig;
-import org.mozilla.focus.session.Session;
-import org.mozilla.focus.telemetry.TelemetryWrapper;
-import org.mozilla.focus.utils.AppConstants;
-import org.mozilla.focus.utils.FileUtils;
-import org.mozilla.focus.utils.UrlUtils;
-import org.mozilla.focus.utils.ViewUtils;
-import org.mozilla.focus.web.Download;
-import org.mozilla.focus.web.IFindListener;
-import org.mozilla.focus.web.IWebView;
-import org.mozilla.focus.web.WebViewProvider;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import mozilla.components.support.utils.ThreadUtils;
-
-public class SystemWebView extends NestedWebView implements IWebView, SharedPreferences.OnSharedPreferenceChangeListener {
-    private static final String TAG = "WebkitView";
-
-    private Callback callback;
-    private final FocusWebViewClient client;
-    private final LinkHandler linkHandler;
-
-    public SystemWebView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        client = new FocusWebViewClient(getContext().getApplicationContext());
-
-        setWebViewClient(client);
-        setWebChromeClient(createWebChromeClient());
-        setDownloadListener(createDownloadListener());
-
-        if (BuildConfig.DEBUG) {
-            setWebContentsDebuggingEnabled(true);
-        }
-
-        setLongClickable(true);
-
-        linkHandler = new LinkHandler(this);
-        setOnLongClickListener(linkHandler);
-    }
-
-    @VisibleForTesting
-    public Callback getCallback() {
-        return callback;
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-
-        PreferenceManager.getDefaultSharedPreferences(getContext()).registerOnSharedPreferenceChangeListener(this);
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            TelemetryAutofillCallback.INSTANCE.register(getContext());
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-
-        PreferenceManager.getDefaultSharedPreferences(getContext()).unregisterOnSharedPreferenceChangeListener(this);
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            TelemetryAutofillCallback.INSTANCE.unregister(getContext());
-        }
-    }
-
-    @Override
-    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
-        final InputConnection connection = super.onCreateInputConnection(outAttrs);
-        outAttrs.imeOptions |= ViewUtils.IME_FLAG_NO_PERSONALIZED_LEARNING;
-        return connection;
-    }
-
-    @Override
-    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
-        WebViewProvider.INSTANCE.applyAppSettings(getContext(), getSettings(), this);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        pauseTimers();
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        resumeTimers();
-    }
-
-    @Override
-    public void restoreWebViewState(Session session) {
-        final Bundle stateData = session.getWebViewState();
-
-        final WebBackForwardList backForwardList = stateData != null
-                ? super.restoreState(stateData)
-                : null;
-
-        final String desiredURL = session.getUrl().getValue();
-
-        client.restoreState(stateData);
-        client.notifyCurrentURL(desiredURL);
-
-        // Pages are only added to the back/forward list when loading finishes. If a new page is
-        // loading when the Activity is paused/killed, then that page won't be in the list,
-        // and needs to be restored separately to the history list. We detect this by checking
-        // whether the last fully loaded page (getCurrentItem()) matches the last page that the
-        // WebView was actively loading (which was retrieved during onSaveInstanceState():
-        // WebView.getUrl() always returns the currently loading or loaded page).
-        // If the app is paused/killed before the initial page finished loading, then the entire
-        // list will be null - so we need to additionally check whether the list even exists.
-
-        if (backForwardList != null &&
-                backForwardList.getCurrentItem().getUrl().equals(desiredURL)) {
-            // restoreState doesn't actually load the current page, it just restores navigation history,
-            // so we also need to explicitly reload in this case:
-            reload();
-        } else {
-            loadUrl(desiredURL);
-        }
-    }
-
-    @Override
-    public void saveWebViewState(@NonNull Session session) {
-        // We store the actual state into another bundle that we will keep in memory as long as this
-        // browsing session is active. The data that WebView stores in this bundle is too large for
-        // Android to save and restore as part of the state bundle.
-        final Bundle stateData = new Bundle();
-
-        super.saveState(stateData);
-        client.saveState(this, stateData);
-
-        session.saveWebViewState(stateData);
-    }
-
-    @Override
-    public void setBlockingEnabled(boolean enabled) {
-        client.setBlockingEnabled(enabled);
-        if (enabled) {
-            WebViewProvider.INSTANCE.applyAppSettings(getContext(), getSettings(), this);
-        } else {
-            WebViewProvider.INSTANCE.disableBlocking(getSettings(), this);
-        }
-
-        if (callback != null) {
-            callback.onBlockingStateChanged(enabled);
-        }
-    }
-
-    @Override
-    public void setRequestDesktop(boolean shouldRequestDesktop) {
-        if (shouldRequestDesktop) {
-            WebViewProvider.INSTANCE.requestDesktopSite(getSettings());
-        } else {
-            WebViewProvider.INSTANCE.requestMobileSite(getContext(), getSettings());
-        }
-
-        if (callback != null) {
-            callback.onRequestDesktopStateChanged(shouldRequestDesktop);
-        }
-    }
-
-    @Override
-    public void setCallback(Callback callback) {
-        this.callback = callback;
-        client.setCallback(callback);
-        linkHandler.setCallback(callback);
-    }
-
-    @Override
-    public void setFindListener(IFindListener findListener) {
-        this.setFindListener((FindListener) findListener);
-    }
-
-    public void loadUrl(String url) {
-        // We need to check external URL handling here - shouldOverrideUrlLoading() is only
-        // called by webview when clicking on a link, and not when opening a new page for the
-        // first time using loadUrl().
-        if (!client.shouldOverrideUrlLoading(this, url)) {
-            final Map<String, String> additionalHeaders = new HashMap<>();
-            additionalHeaders.put("X-Requested-With", "");
-
-            super.loadUrl(url, additionalHeaders);
-        }
-
-        client.notifyCurrentURL(url);
-    }
-
-    @Override
-    public void exitFullscreen() {}
-
-    @Override
-    public void loadData(String baseURL, String data, String mimeType, String encoding, String historyURL) {
-        loadDataWithBaseURL(baseURL, data, mimeType, encoding, historyURL);
-    }
-
-    @Override
-    public void destroy() {
-        super.destroy();
-
-        // WebView might save data to disk once it gets destroyed. In this case our cleanup call
-        // might not have been able to see this data. Let's do it again.
-        deleteContentFromKnownLocations(getContext());
-    }
-
-    @Override
-    public void cleanup() {
-        clearFormData();
-        clearHistory();
-        clearMatches();
-        clearSslPreferences();
-        clearCache(true);
-
-        // We don't care about the callback - we just want to make sure cookies are gone
-        CookieManager.getInstance().removeAllCookies(null);
-
-        WebStorage.getInstance().deleteAllData();
-
-        final WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(getContext());
-        // It isn't entirely clear how this differs from WebView.clearFormData()
-        webViewDatabase.clearFormData();
-        webViewDatabase.clearHttpAuthUsernamePassword();
-
-        deleteContentFromKnownLocations(getContext());
-    }
-
-    @Override
-    public void autofill(SparseArray<AutofillValue> values) {
-        super.autofill(values);
-
-        TelemetryWrapper.autofillPerformedEvent();
-    }
-
-    public static void deleteContentFromKnownLocations(final Context context) {
-        ThreadUtils.INSTANCE.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                // We call all methods on WebView to delete data. But some traces still remain
-                // on disk. This will wipe the whole webview directory.
-                FileUtils.deleteWebViewDirectory(context);
-
-                // WebView stores some files in the cache directory. We do not use it ourselves
-                // so let's truncate it.
-                FileUtils.truncateCacheDirectory(context);
-            }
-        });
-    }
-
-    private WebChromeClient createWebChromeClient() {
-        return new WebChromeClient() {
-            @Override
-            public void onProgressChanged(WebView view, int newProgress) {
-                if (callback != null) {
-                    // This is the earliest point where we might be able to confirm a redirected
-                    // URL: we don't necessarily get a shouldInterceptRequest() after a redirect,
-                    // so we can only check the updated url in onProgressChanges(), or in onPageFinished()
-                    // (which is even later).
-                    final String viewURL = view.getUrl();
-                    if (!UrlUtils.isInternalErrorURL(viewURL) && viewURL != null) {
-                        callback.onURLChanged(viewURL);
-                        callback.onTitleChanged(getTitle());
-                    }
-                    callback.onProgress(newProgress);
-                }
-            }
-
-            @Override
-            public void onShowCustomView(View view, final CustomViewCallback webviewCallback) {
-                final FullscreenCallback fullscreenCallback = new FullscreenCallback() {
-                    @Override
-                    public void fullScreenExited() {
-                        webviewCallback.onCustomViewHidden();
-                    }
-                };
-
-                callback.onEnterFullScreen(fullscreenCallback, view);
-            }
-
-            @Override
-            public void onHideCustomView() {
-                callback.onExitFullScreen();
-            }
-        };
-    }
-
-    private DownloadListener createDownloadListener() {
-        return new DownloadListener() {
-            @Override
-            public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) {
-                if (!AppConstants.INSTANCE.supportsDownloadingFiles()) {
-                    return;
-                }
-
-                final String scheme = Uri.parse(url).getScheme();
-                if (scheme == null || (!scheme.equals("http") && !scheme.equals("https"))) {
-                    // We are ignoring everything that is not http or https. This is a limitation of
-                    // Android's download manager. There's no reason to show a download dialog for
-                    // something we can't download anyways.
-                    Log.w(TAG, "Ignoring download from non http(s) URL: " + url);
-                    return;
-                }
-
-                if (callback != null) {
-                    final Download download = new Download(url, userAgent, contentDisposition, mimetype, contentLength, Environment.DIRECTORY_DOWNLOADS, null);
-                    callback.onDownloadStart(download);
-                }
-            }
-        };
-    }
-}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt b/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt
new file mode 100644
index 000000000000..97fd10894cc4
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt
@@ -0,0 +1,319 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.focus.webview
+
+import android.content.Context
+import android.content.SharedPreferences
+import android.net.Uri
+import android.os.Build
+import android.os.Bundle
+import android.os.Environment
+import android.preference.PreferenceManager
+import android.support.annotation.VisibleForTesting
+import android.util.AttributeSet
+import android.util.Log
+import android.util.SparseArray
+import android.view.View
+import android.view.autofill.AutofillValue
+import android.view.inputmethod.EditorInfo
+import android.view.inputmethod.InputConnection
+import android.webkit.CookieManager
+import android.webkit.DownloadListener
+import android.webkit.WebChromeClient
+import android.webkit.WebStorage
+import android.webkit.WebView
+import android.webkit.WebViewDatabase
+import mozilla.components.support.utils.ThreadUtils
+import org.mozilla.focus.BuildConfig
+import org.mozilla.focus.session.Session
+import org.mozilla.focus.telemetry.TelemetryWrapper
+import org.mozilla.focus.utils.AppConstants
+import org.mozilla.focus.utils.FileUtils
+import org.mozilla.focus.utils.UrlUtils
+import org.mozilla.focus.utils.ViewUtils
+import org.mozilla.focus.web.Download
+import org.mozilla.focus.web.IFindListener
+import org.mozilla.focus.web.IWebView
+import org.mozilla.focus.web.WebViewProvider
+import java.util.HashMap
+
+@Suppress("TooManyFunctions")
+class SystemWebView(context: Context, attrs: AttributeSet) : NestedWebView(context, attrs), IWebView,
+    SharedPreferences.OnSharedPreferenceChangeListener {
+
+    private var callback: IWebView.Callback? = null
+    private val client: FocusWebViewClient = FocusWebViewClient(getContext().applicationContext)
+    private val linkHandler: LinkHandler
+
+    init {
+
+        webViewClient = client
+        webChromeClient = createWebChromeClient()
+        setDownloadListener(createDownloadListener())
+
+        if (BuildConfig.DEBUG) {
+            WebView.setWebContentsDebuggingEnabled(true)
+        }
+
+        isLongClickable = true
+
+        linkHandler = LinkHandler(this)
+        setOnLongClickListener(linkHandler)
+    }
+
+    @VisibleForTesting
+    fun getCallback(): IWebView.Callback? {
+        return callback
+    }
+
+    override fun onAttachedToWindow() {
+        super.onAttachedToWindow()
+
+        PreferenceManager.getDefaultSharedPreferences(context).registerOnSharedPreferenceChangeListener(this)
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            TelemetryAutofillCallback.register(context)
+        }
+    }
+
+    override fun onDetachedFromWindow() {
+        super.onDetachedFromWindow()
+
+        PreferenceManager.getDefaultSharedPreferences(context).unregisterOnSharedPreferenceChangeListener(this)
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            TelemetryAutofillCallback.unregister(context)
+        }
+    }
+
+    override fun onCreateInputConnection(outAttrs: EditorInfo): InputConnection? {
+        val connection: InputConnection? = super.onCreateInputConnection(outAttrs)
+        outAttrs.imeOptions = outAttrs.imeOptions or ViewUtils.IME_FLAG_NO_PERSONALIZED_LEARNING
+        return connection
+    }
+
+    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences, key: String) {
+        WebViewProvider.applyAppSettings(context, settings, this)
+    }
+
+    override fun onPause() {
+        super.onPause()
+        pauseTimers()
+    }
+
+    override fun onResume() {
+        super.onResume()
+        resumeTimers()
+    }
+
+    override fun restoreWebViewState(session: Session) {
+        val stateData = session.webViewState
+
+        val backForwardList = if (stateData != null)
+            super.restoreState(stateData)
+        else
+            null
+
+        val desiredURL = session.url.value
+
+        client.restoreState(stateData)
+        client.notifyCurrentURL(desiredURL)
+
+        // Pages are only added to the back/forward list when loading finishes. If a new page is
+        // loading when the Activity is paused/killed, then that page won't be in the list,
+        // and needs to be restored separately to the history list. We detect this by checking
+        // whether the last fully loaded page (getCurrentItem()) matches the last page that the
+        // WebView was actively loading (which was retrieved during onSaveInstanceState():
+        // WebView.getUrl() always returns the currently loading or loaded page).
+        // If the app is paused/killed before the initial page finished loading, then the entire
+        // list will be null - so we need to additionally check whether the list even exists.
+
+        if (backForwardList != null && backForwardList.currentItem!!.url == desiredURL) {
+            // restoreState doesn't actually load the current page, it just restores navigation history,
+            // so we also need to explicitly reload in this case:
+            reload()
+        } else {
+            loadUrl(desiredURL)
+        }
+    }
+
+    override fun saveWebViewState(session: Session) {
+        // We store the actual state into another bundle that we will keep in memory as long as this
+        // browsing session is active. The data that WebView stores in this bundle is too large for
+        // Android to save and restore as part of the state bundle.
+        val stateData = Bundle()
+
+        super.saveState(stateData)
+        client.saveState(this, stateData)
+
+        session.saveWebViewState(stateData)
+    }
+
+    override fun setBlockingEnabled(enabled: Boolean) {
+        client.isBlockingEnabled = enabled
+        if (enabled) {
+            WebViewProvider.applyAppSettings(context, settings, this)
+        } else {
+            WebViewProvider.disableBlocking(settings, this)
+        }
+
+        if (callback != null) {
+            callback!!.onBlockingStateChanged(enabled)
+        }
+    }
+
+    override fun setRequestDesktop(shouldRequestDesktop: Boolean) {
+        if (shouldRequestDesktop) {
+            WebViewProvider.requestDesktopSite(settings)
+        } else {
+            WebViewProvider.requestMobileSite(context, settings)
+        }
+
+        if (callback != null) {
+            callback!!.onRequestDesktopStateChanged(shouldRequestDesktop)
+        }
+    }
+
+    override fun setCallback(callback: IWebView.Callback?) {
+        this.callback = callback
+        client.setCallback(callback)
+        linkHandler.setCallback(callback)
+    }
+
+    override fun setFindListener(findListener: IFindListener) {
+        this.setFindListener(findListener as WebView.FindListener)
+    }
+
+    override fun loadUrl(url: String?) {
+        // We need to check external URL handling here - shouldOverrideUrlLoading() is only
+        // called by webview when clicking on a link, and not when opening a new page for the
+        // first time using loadUrl().
+        @Suppress("DEPRECATION")
+        if (!client.shouldOverrideUrlLoading(this, url)) {
+            val additionalHeaders = HashMap<String, String>()
+            additionalHeaders["X-Requested-With"] = ""
+
+            super.loadUrl(url, additionalHeaders)
+        }
+
+        client.notifyCurrentURL(url)
+    }
+
+    override fun exitFullscreen() {}
+
+    override fun loadData(baseURL: String, data: String, mimeType: String, encoding: String, historyURL: String) {
+        loadDataWithBaseURL(baseURL, data, mimeType, encoding, historyURL)
+    }
+
+    override fun destroy() {
+        super.destroy()
+
+        // WebView might save data to disk once it gets destroyed. In this case our cleanup call
+        // might not have been able to see this data. Let's do it again.
+        deleteContentFromKnownLocations(context)
+    }
+
+    override fun cleanup() {
+        clearFormData()
+        clearHistory()
+        clearMatches()
+        clearSslPreferences()
+        clearCache(true)
+
+        // We don't care about the callback - we just want to make sure cookies are gone
+        CookieManager.getInstance().removeAllCookies(null)
+
+        WebStorage.getInstance().deleteAllData()
+
+        val webViewDatabase = WebViewDatabase.getInstance(context)
+        // It isn't entirely clear how this differs from WebView.clearFormData()
+        @Suppress("DEPRECATION")
+        webViewDatabase.clearFormData()
+        webViewDatabase.clearHttpAuthUsernamePassword()
+
+        deleteContentFromKnownLocations(context)
+    }
+
+    override fun autofill(values: SparseArray<AutofillValue>) {
+        super.autofill(values)
+
+        TelemetryWrapper.autofillPerformedEvent()
+    }
+
+    private fun createWebChromeClient(): WebChromeClient {
+        return object : WebChromeClient() {
+            override fun onProgressChanged(view: WebView, newProgress: Int) {
+                if (callback != null) {
+                    // This is the earliest point where we might be able to confirm a redirected
+                    // URL: we don't necessarily get a shouldInterceptRequest() after a redirect,
+                    // so we can only check the updated url in onProgressChanges(), or in onPageFinished()
+                    // (which is even later).
+                    val viewURL = view.url
+                    if (!UrlUtils.isInternalErrorURL(viewURL) && viewURL != null) {
+                        callback!!.onURLChanged(viewURL)
+                        callback!!.onTitleChanged(title)
+                    }
+                    callback!!.onProgress(newProgress)
+                }
+            }
+
+            override fun onShowCustomView(view: View, webviewCallback: WebChromeClient.CustomViewCallback) {
+                val fullscreenCallback = IWebView.FullscreenCallback { webviewCallback.onCustomViewHidden() }
+
+                callback!!.onEnterFullScreen(fullscreenCallback, view)
+            }
+
+            override fun onHideCustomView() {
+                callback!!.onExitFullScreen()
+            }
+        }
+    }
+
+    private fun createDownloadListener(): DownloadListener {
+        return DownloadListener { url, userAgent, contentDisposition, mimetype, contentLength ->
+            if (!AppConstants.supportsDownloadingFiles()) {
+                return@DownloadListener
+            }
+
+            val scheme = Uri.parse(url).scheme
+            if (scheme == null || scheme != "http" && scheme != "https") {
+                // We are ignoring everything that is not http or https. This is a limitation of
+                // Android's download manager. There's no reason to show a download dialog for
+                // something we can't download anyways.
+                Log.w(TAG, "Ignoring download from non http(s) URL: $url")
+                return@DownloadListener
+            }
+
+            if (callback != null) {
+                val download = Download(
+                    url,
+                    userAgent,
+                    contentDisposition,
+                    mimetype,
+                    contentLength,
+                    Environment.DIRECTORY_DOWNLOADS,
+                    null
+                )
+                callback!!.onDownloadStart(download)
+            }
+        }
+    }
+
+    companion object {
+        private const val TAG = "WebkitView"
+
+        fun deleteContentFromKnownLocations(context: Context) {
+            ThreadUtils.postToBackgroundThread(Runnable {
+                // We call all methods on WebView to delete data. But some traces still remain
+                // on disk. This will wipe the whole webview directory.
+                FileUtils.deleteWebViewDirectory(context)
+
+                // WebView stores some files in the cache directory. We do not use it ourselves
+                // so let's truncate it.
+                FileUtils.truncateCacheDirectory(context)
+            })
+        }
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/widget/DefaultBrowserPreference.java b/focus-android/app/src/main/java/org/mozilla/focus/widget/DefaultBrowserPreference.java
index cbc1b2d69bf9..be6ebd89e8d5 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/widget/DefaultBrowserPreference.java
+++ b/focus-android/app/src/main/java/org/mozilla/focus/widget/DefaultBrowserPreference.java
@@ -60,9 +60,9 @@ public void onClick() {
         final Context context = getContext();
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-            SupportUtils.openDefaultAppsSettings(context);
+            SupportUtils.INSTANCE.openDefaultAppsSettings(context);
         } else {
-            SupportUtils.openDefaultBrowserSumoPage(context);
+            SupportUtils.INSTANCE.openDefaultBrowserSumoPage(context);
         }
     }
 }
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.java b/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.java
deleted file mode 100644
index 3cbc2550677d..000000000000
--- a/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.mozilla.focus.utils;
-
-import android.content.Context;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-
-import java.util.Locale;
-
-import static org.junit.Assert.assertEquals;
-
-@RunWith(RobolectricTestRunner.class)
-public class SupportUtilsTest {
-
-    @Test
-    public void cleanup() {
-        // Other tests might get confused by our locale fiddling, so lets go back to the default:
-        Locale.setDefault(Locale.ENGLISH);
-    }
-
-    /*
-     * Super simple sumo URL test - it exists primarily to verify that we're setting the language
-     * and page tags correctly. appVersion is null in tests, so we just test that there's a null there,
-     * which doesn't seem too useful...
-     */
-    @Test
-    public void getSumoURLForTopic() throws Exception {
-        final Context context = RuntimeEnvironment.application;
-        final String versionName = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
-
-        final SupportUtils.SumoTopic testTopic = SupportUtils.SumoTopic.TRACKERS;
-        final String testTopicStr = testTopic.topicStr;
-
-        Locale.setDefault(Locale.GERMANY);
-        assertEquals("https://support.mozilla.org/1/mobile/" + versionName + "/Android/de-DE/" + testTopicStr,
-                SupportUtils.getSumoURLForTopic(RuntimeEnvironment.application, testTopic));
-
-        Locale.setDefault(Locale.CANADA_FRENCH);
-        assertEquals("https://support.mozilla.org/1/mobile/" + versionName + "/Android/fr-CA/" + testTopicStr,
-                SupportUtils.getSumoURLForTopic(RuntimeEnvironment.application, testTopic));
-    }
-
-    /**
-     * This is a pretty boring tests - it exists primarily to verify that we're actually setting
-     * a langtag in the manfiesto URL.
-     */
-    @Test
-    public void getManifestoURL() throws Exception {
-        Locale.setDefault(Locale.UK);
-        assertEquals("https://www.mozilla.org/en-GB/about/manifesto/",
-                SupportUtils.getManifestoURL());
-
-        Locale.setDefault(Locale.KOREA);
-        assertEquals("https://www.mozilla.org/ko-KR/about/manifesto/",
-                SupportUtils.getManifestoURL());
-    }
-
-}
\ No newline at end of file
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.kt b/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.kt
new file mode 100644
index 000000000000..eb2c0e04a388
--- /dev/null
+++ b/focus-android/app/src/test/java/org/mozilla/focus/utils/SupportUtilsTest.kt
@@ -0,0 +1,65 @@
+package org.mozilla.focus.utils
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+import java.util.Locale
+
+@RunWith(RobolectricTestRunner::class)
+class SupportUtilsTest {
+
+    @Test
+    fun cleanup() {
+        // Other tests might get confused by our locale fiddling, so lets go back to the default:
+        Locale.setDefault(Locale.ENGLISH)
+    }
+
+    /*
+     * Super simple sumo URL test - it exists primarily to verify that we're setting the language
+     * and page tags correctly. appVersion is null in tests, so we just test that there's a null there,
+     * which doesn't seem too useful...
+     */
+    @Test
+    @Throws(Exception::class)
+    fun getSumoURLForTopic() {
+        val context = RuntimeEnvironment.application
+        val versionName = context.packageManager.getPackageInfo(context.packageName, 0).versionName
+
+        val testTopic = SupportUtils.SumoTopic.TRACKERS
+        val testTopicStr = testTopic.topicStr
+
+        Locale.setDefault(Locale.GERMANY)
+        assertEquals(
+            "https://support.mozilla.org/1/mobile/$versionName/Android/de-DE/$testTopicStr",
+            SupportUtils.getSumoURLForTopic(RuntimeEnvironment.application, testTopic)
+        )
+
+        Locale.setDefault(Locale.CANADA_FRENCH)
+        assertEquals(
+            "https://support.mozilla.org/1/mobile/$versionName/Android/fr-CA/$testTopicStr",
+            SupportUtils.getSumoURLForTopic(RuntimeEnvironment.application, testTopic)
+        )
+    }
+
+    /**
+     * This is a pretty boring tests - it exists primarily to verify that we're actually setting
+     * a langtag in the manfiesto URL.
+     */
+    @Test
+    @Throws(Exception::class)
+    fun getManifestoURL() {
+        Locale.setDefault(Locale.UK)
+        assertEquals(
+            "https://www.mozilla.org/en-GB/about/manifesto/",
+            SupportUtils.manifestoURL
+        )
+
+        Locale.setDefault(Locale.KOREA)
+        assertEquals(
+            "https://www.mozilla.org/ko-KR/about/manifesto/",
+            SupportUtils.manifestoURL
+        )
+    }
+}
\ No newline at end of file
