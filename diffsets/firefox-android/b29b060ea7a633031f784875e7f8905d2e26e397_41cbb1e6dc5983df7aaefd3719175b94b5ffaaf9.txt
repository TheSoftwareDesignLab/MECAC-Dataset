diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index e5838c8b4bfd..d2e441b6cb2b 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -212,6 +212,10 @@ projects:
     path: components/lib/jexl
     description: 'Javascript Expression Language: Powerful context-based expression parser and evaluator.'
     publish: true
+  lib-publicsuffixlist:
+    path: components/lib/publicsuffixlist
+    description: 'A library for reading and using the public suffix list.'
+    publish: true
   tooling-lint:
     path: components/tooling/lint
     description: 'Custom Lint checks for using and writing components.'
diff --git a/android-components/README.md b/android-components/README.md
index c280614c97ba..fd102a27e5dc 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -178,6 +178,8 @@ _Supporting components with generic helper code._
 
 * ‚ö™ [**JEXL**](components/lib/jexl/README.md) - Javascript Expression Language: Context-based expression parser and evaluator.
 
+* ‚ö™ [**Public Suffix List**](components/lib/publicsuffixlist/README.md) - A library for reading and using the [public suffix list](https://publicsuffix.org/).
+
 ## Tooling
 
 * üîµ [**Fetch-Tests**](components/tooling/fetch-tests/README.md) - A generic test suite for components that implement [concept-fetch](concept/fetch/README.md).
diff --git a/android-components/components/lib/publicsuffixlist/README.md b/android-components/components/lib/publicsuffixlist/README.md
new file mode 100644
index 000000000000..bc620952b346
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/README.md
@@ -0,0 +1,64 @@
+# [Android Components](../../../README.md) > Libraries > Public Suffix List
+
+A library for reading and using the Public Suffix List.
+
+> A "public suffix" is one under which Internet users can (or historically could) directly register names. Some examples of public suffixes are .com, .co.uk and pvt.k12.ma.us. The Public Suffix List is a list of all known public suffixes. 
+> [https://publicsuffix.org/](https://publicsuffix.org/)
+
+## Usage
+
+### Setting up the dependency
+
+Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
+
+```Groovy
+implementation "org.mozilla.components:lib-publicsuffixlist:{latest-version}"
+```
+
+### Using the public suffix list
+
+The `PublicSuffixList` class offers multiple methods for using the public suffix list data. For every instance the list needs to be read from disk into memory once. Therefore all methods return [Deferred](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/) types.  The list data is cached in the `PublicSuffixList` and therefore it is recommended to keep a single instance in memory when frequently accessing the list. The list data can be prefetched to guarantee fast access for subsequent access.
+
+```Kotlin
+val publicSuffixList = PublicSuffixList(context)
+
+// Not needed, but allows a consumer to decide when the read is happening:
+publicSuffixList.prefetch()
+ // Optionally you can wait for the read to complete:
+publicSuffixList.prefetch().await()
+```
+
+```Kotlin
+// Extracting the effective top-level domain (eTLD)
+publicSuffixList.getPublicSuffixPlusOne("www.mozilla.org") // -> mozilla.org
+publicSuffixList.getPublicSuffixPlusOne("www.bbc.co.uk") // -> bbc.co.uk
+publicSuffixList.getPublicSuffixPlusOne("a.b.ide.kyoto.jp") // -> b.ide.kyoto.jp
+```
+
+```Kotlin
+// Checking whether a value is a public suffix:
+publicSuffixList.isPublicSuffix("org") // -> true
+publicSuffixList.isPublicSuffix("co.uk") // -> true
+publicSuffixList.isPublicSuffix("org") // -> true
+publicSuffixList.isPublicSuffix("ide.kyoto.jp") --> true
+```
+
+```Kotlin
+// Extracting the public suffix from a domain
+publicSuffixList.getPublicSuffix("www.mozilla.org") // -> org
+publicSuffixList.getPublicSuffix("www.bbc.co.uk") // -> co.uk
+publicSuffixList.getPublicSuffix("a.b.ide.kyoto.jp") // -> ide.kyoto.jp
+```
+
+```Kotlin
+// Removing the public suffix from a domain
+publicSuffixList.stripPublicSuffix("www.mozilla.org") // -> www.mozilla
+publicSuffixList.stripPublicSuffix("foobar.blogspot.com") // -> foobar
+publicSuffixList.stripPublicSuffix("www.example.pvt.k12.ma.us") // -> www.example
+```
+
+## License
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/lib/publicsuffixlist/build.gradle b/android-components/components/lib/publicsuffixlist/build.gradle
new file mode 100644
index 000000000000..fca581e95c09
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/build.gradle
@@ -0,0 +1,39 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-android-extensions'
+
+android {
+    compileSdkVersion config.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion config.minSdkVersion
+        targetSdkVersion config.targetSdkVersion
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
+
+    testImplementation project(':support-test')
+    testImplementation Dependencies.androidx_test_core
+    testImplementation Dependencies.testing_junit
+    testImplementation Dependencies.testing_robolectric
+    testImplementation Dependencies.testing_mockito
+}
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
diff --git a/android-components/components/lib/publicsuffixlist/proguard-rules.pro b/android-components/components/lib/publicsuffixlist/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/lib/publicsuffixlist/src/main/AndroidManifest.xml b/android-components/components/lib/publicsuffixlist/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..fb25329520b5
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
+   - You can obtain one at http://mozilla.org/MPL/2.0/.  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="mozilla.components.lib.publicsuffixlist" />
diff --git a/android-components/components/lib/publicsuffixlist/src/main/assets/publicsuffixes b/android-components/components/lib/publicsuffixlist/src/main/assets/publicsuffixes
new file mode 100644
index 000000000000..67f82c8a628b
Binary files /dev/null and b/android-components/components/lib/publicsuffixlist/src/main/assets/publicsuffixes differ
diff --git a/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixList.kt b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixList.kt
new file mode 100644
index 000000000000..65bd1e21b8cf
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixList.kt
@@ -0,0 +1,120 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.publicsuffixlist
+
+import android.content.Context
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.async
+
+/**
+ * API for reading and accessing the public suffix list.
+ *
+ * > A "public suffix" is one under which Internet users can (or historically could) directly register names. Some
+ * > examples of public suffixes are .com, .co.uk and pvt.k12.ma.us. The Public Suffix List is a list of all known
+ * > public suffixes.
+ *
+ * https://publicsuffix.org/
+ * https://github.com/publicsuffix/list
+ */
+class PublicSuffixList(
+    context: Context,
+    dispatcher: CoroutineDispatcher = Dispatchers.IO,
+    private val scope: CoroutineScope = CoroutineScope(dispatcher)
+) {
+    private val data: PublicSuffixListData by lazy { PublicSuffixListLoader.load(context) }
+
+    /**
+     * Prefetch the public suffix list from disk so that it is available in memory.
+     */
+    fun prefetch(): Deferred<Unit> = scope.async {
+        data.run { Unit }
+    }
+
+    /**
+     * Returns true if the given [domain] is a public suffix; false otherwise.
+     *
+     * E.g.:
+     * ```
+     *   co.uk       -> true
+     *   com         -> true
+     *   mozilla.org -> false
+     *   org         -> true
+     * ```
+     *
+     * Note that this method ignores the default "prevailing rule" described in the formal public suffix list algorithm:
+     * If a
+     */
+    fun isPublicSuffix(domain: String): Deferred<Boolean> = scope.async {
+        when (data.getPublicSuffixOffset(domain)) {
+            is PublicSuffixOffset.PublicSuffix -> true
+            else -> false
+        }
+    }
+
+    /**
+     * Returns the public suffix and one more level; known as the effective top-level domain (eTLD). Returns `null` if
+     * [domain] is a public suffix itself.
+     *
+     * E.g.:
+     * ```
+     * wwww.mozilla.org -> mozilla.org
+     * www.bcc.co.uk    -> bbc.co.uk
+     * a.b.ide.kyoto.jp -> b.ide.kyoto.jp
+     * ```
+     */
+    fun getPublicSuffixPlusOne(domain: String): Deferred<String?> = scope.async {
+        when (val offset = data.getPublicSuffixOffset(domain)) {
+            is PublicSuffixOffset.Offset -> domain
+                .split('.')
+                .drop(offset.value)
+                .joinToString(separator = ".")
+            else -> null
+        }
+    }
+
+    /**
+     * Returns the public suffix of the given [domain]. Returns `null` if the [domain] is a public suffix itself.
+     *
+     * E.g.:
+     * ```
+     * wwww.mozilla.org -> org
+     * www.bcc.co.uk    -> co.uk
+     * a.b.ide.kyoto.jp -> ide.kyoto.jp
+     * ```
+     */
+    fun getPublicSuffix(domain: String) = scope.async {
+        when (val offset = data.getPublicSuffixOffset(domain)) {
+            is PublicSuffixOffset.Offset -> domain
+                .split('.')
+                .drop(offset.value + 1)
+                .joinToString(separator = ".")
+            else -> null
+        }
+    }
+
+    /**
+     * Strips the public suffix from the given [domain]. Returns the original domain if no public suffix could be
+     * stripped.
+     *
+     * E.g.:
+     * ```
+     * wwww.mozilla.org -> www.mozilla
+     * www.bcc.co.uk    -> www.bbc
+     * a.b.ide.kyoto.jp -> a.b
+     * ```
+     */
+    fun stripPublicSuffix(domain: String) = scope.async {
+        when (val offset = data.getPublicSuffixOffset(domain)) {
+            is PublicSuffixOffset.Offset -> domain
+                .split('.')
+                .joinToString(separator = ".", limit = offset.value + 1, truncated = "")
+                .dropLast(1)
+            else -> domain
+        }
+    }
+}
diff --git a/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListData.kt b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListData.kt
new file mode 100644
index 000000000000..76bfed4e6069
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListData.kt
@@ -0,0 +1,152 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.publicsuffixlist
+
+import mozilla.components.lib.publicsuffixlist.ext.binarySearch
+import java.net.IDN
+
+/**
+ * Class wrapping the public suffix list data and offering methods for accessing rules in it.
+ */
+internal class PublicSuffixListData(
+    private val rules: ByteArray,
+    private val exceptions: ByteArray
+) {
+    private fun binarySearchRules(labels: List<ByteArray>, labelIndex: Int): String? {
+        return rules.binarySearch(labels, labelIndex)
+    }
+
+    private fun binarySearchExceptions(labels: List<ByteArray>, labelIndex: Int): String? {
+        return exceptions.binarySearch(labels, labelIndex)
+    }
+
+    fun getPublicSuffixOffset(domain: String): PublicSuffixOffset? {
+        if (domain.isEmpty()) {
+            return null
+        }
+
+        val domainLabels = IDN.toUnicode(domain).split('.')
+        val rule = findMatchingRule(domainLabels)
+
+        if (domainLabels.size == rule.size && rule[0][0] != PublicSuffixListData.EXCEPTION_MARKER) {
+            // The domain is a public suffix.
+            return if (rule == PublicSuffixListData.PREVAILING_RULE) {
+                PublicSuffixOffset.PrevailingRule
+            } else {
+                PublicSuffixOffset.PublicSuffix
+            }
+        }
+
+        return if (rule[0][0] == PublicSuffixListData.EXCEPTION_MARKER) {
+            // Exception rules hold the effective TLD plus one.
+            PublicSuffixOffset.Offset(domainLabels.size - rule.size)
+        } else {
+            // Otherwise the rule is for a public suffix, so we must take one more label.
+            PublicSuffixOffset.Offset(domainLabels.size - (rule.size + 1))
+        }
+    }
+
+    /**
+     * Find a matching rule for the given domain labels.
+     *
+     * This algorithm is based on OkHttp's PublicSuffixDatabase class:
+     * https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+     */
+    private fun findMatchingRule(domainLabels: List<String>): List<String> {
+        // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+        val domainLabelsBytes = domainLabels.map { it.toByteArray(Charsets.UTF_8) }
+
+        val exactMatch = findExactMatch(domainLabelsBytes)
+        val wildcardMatch = findWildcardMatch(domainLabelsBytes)
+        val exceptionMatch = findExceptionMatch(domainLabelsBytes, wildcardMatch)
+
+        if (exceptionMatch != null) {
+            return ("${PublicSuffixListData.EXCEPTION_MARKER}$exceptionMatch").split('.')
+        }
+
+        if (exactMatch == null && wildcardMatch == null) {
+            return PublicSuffixListData.PREVAILING_RULE
+        }
+
+        val exactRuleLabels = exactMatch?.split('.') ?: PublicSuffixListData.EMPTY_RULE
+        val wildcardRuleLabels = wildcardMatch?.split('.') ?: PublicSuffixListData.EMPTY_RULE
+
+        return if (exactRuleLabels.size > wildcardRuleLabels.size) {
+            exactRuleLabels
+        } else {
+            wildcardRuleLabels
+        }
+    }
+
+    /**
+     * Returns an exact match or null.
+     */
+    private fun findExactMatch(labels: List<ByteArray>): String? {
+        // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+        // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+
+        for (i in 0 until labels.size) {
+            val rule = binarySearchRules(labels, i)
+
+            if (rule != null) {
+                return rule
+            }
+        }
+
+        return null
+    }
+
+    /**
+     * Returns a wildcard match or null.
+     */
+    private fun findWildcardMatch(labels: List<ByteArray>): String? {
+        // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+        // In practice, wildcards are always in the leftmost position. For now, this implementation
+        // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+        // in the leftmost position. We assert this fact when we generate the public suffix file. If
+        // this assertion ever fails we'll need to refactor this implementation.
+        if (labels.size > 1) {
+            val labelsWithWildcard = labels.toMutableList()
+            for (labelIndex in 0 until labelsWithWildcard.size) {
+                labelsWithWildcard[labelIndex] = PublicSuffixListData.WILDCARD_LABEL
+                val rule = binarySearchRules(labelsWithWildcard, labelIndex)
+                if (rule != null) {
+                    return rule
+                }
+            }
+        }
+
+        return null
+    }
+
+    private fun findExceptionMatch(labels: List<ByteArray>, wildcardMatch: String?): String? {
+        // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+        if (wildcardMatch == null) {
+            return null
+        }
+
+        for (labelIndex in 0 until labels.size) {
+            val rule = binarySearchExceptions(labels, labelIndex)
+            if (rule != null) {
+                return rule
+            }
+        }
+
+        return null
+    }
+
+    companion object {
+        val WILDCARD_LABEL = byteArrayOf('*'.toByte())
+        val PREVAILING_RULE = listOf("*")
+        val EMPTY_RULE = listOf<String>()
+        const val EXCEPTION_MARKER = '!'
+    }
+}
+
+internal sealed class PublicSuffixOffset {
+    data class Offset(val value: Int) : PublicSuffixOffset()
+    object PublicSuffix : PublicSuffixOffset()
+    object PrevailingRule : PublicSuffixOffset()
+}
diff --git a/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListLoader.kt b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListLoader.kt
new file mode 100644
index 000000000000..59a671fde901
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListLoader.kt
@@ -0,0 +1,48 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.publicsuffixlist
+
+import android.content.Context
+import java.io.BufferedInputStream
+import java.io.IOException
+
+private const val PUBLIC_SUFFIX_LIST_FILE = "publicsuffixes"
+
+internal object PublicSuffixListLoader {
+    fun load(context: Context): PublicSuffixListData = context.assets.open(
+        PUBLIC_SUFFIX_LIST_FILE
+    ).buffered().use { stream ->
+        val publicSuffixSize = stream.readInt()
+        val publicSuffixBytes = stream.readFully(publicSuffixSize)
+
+        val exceptionSize = stream.readInt()
+        val exceptionBytes = stream.readFully(exceptionSize)
+
+        PublicSuffixListData(publicSuffixBytes, exceptionBytes)
+    }
+}
+
+@Suppress("MagicNumber")
+private fun BufferedInputStream.readInt(): Int {
+    return (read() and 0xff shl 24
+        or (read() and 0xff shl 16)
+        or (read() and 0xff shl 8)
+        or (read() and 0xff))
+}
+
+private fun BufferedInputStream.readFully(size: Int): ByteArray {
+    val bytes = ByteArray(size)
+
+    var offset = 0
+    while (offset < size) {
+        val read = read(bytes, offset, size - offset)
+        if (read == -1) {
+            throw IOException("Unexpected end of stream")
+        }
+        offset += read
+    }
+
+    return bytes
+}
diff --git a/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/ext/ByteArray.kt b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/ext/ByteArray.kt
new file mode 100644
index 000000000000..b594b52a1455
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/main/java/mozilla/components/lib/publicsuffixlist/ext/ByteArray.kt
@@ -0,0 +1,122 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.publicsuffixlist.ext
+
+import kotlin.experimental.and
+
+private const val BITMASK = 0xff.toByte()
+
+/**
+ * Performs a binary search for the provided [labels] on the [ByteArray]'s data.
+ *
+ * This algorithm is based on OkHttp's PublicSuffixDatabase class:
+ * https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+ */
+@Suppress("ComplexMethod", "NestedBlockDepth")
+internal fun ByteArray.binarySearch(labels: List<ByteArray>, labelIndex: Int): String? {
+    var low = 0
+    var high = size
+    var match: String? = null
+
+    while (low < high) {
+        val mid = (low + high) / 2
+        val start = findStartOfLineFromIndex(mid)
+        val end = findEndOfLineFromIndex(start)
+
+        val publicSuffixLength = start + end - start
+
+        // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+        // unsigned bytes.
+
+        var compareResult: Int
+        var currentLabelIndex = labelIndex
+        var currentLabelByteIndex = 0
+        var publicSuffixByteIndex = 0
+
+        var expectDot = false
+        while (true) {
+            val byte0: Byte = if (expectDot) {
+                expectDot = false
+                '.'.toByte()
+            } else {
+                labels[currentLabelIndex][currentLabelByteIndex] and BITMASK
+            }
+
+            val byte1 = this[start + publicSuffixByteIndex] and BITMASK
+
+            compareResult = byte0 - byte1
+            if (compareResult != 0) {
+                break
+            }
+
+            publicSuffixByteIndex++
+            currentLabelByteIndex++
+
+            if (publicSuffixByteIndex == publicSuffixLength) {
+                break
+            }
+
+            if (labels[currentLabelIndex].size == currentLabelByteIndex) {
+                // We've exhausted our current label. Either there are more labels to compare, in which
+                // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+                if (currentLabelIndex == labels.size - 1) {
+                    break
+                } else {
+                    currentLabelIndex++
+                    currentLabelByteIndex = -1
+                    expectDot = true
+                }
+            }
+        }
+
+        if (compareResult < 0) {
+            high = start - 1
+        } else if (compareResult > 0) {
+            low = start + end + 1
+        } else {
+            // We found a match, but are the lengths equal?
+            val publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex
+            var labelBytesLeft = labels[currentLabelIndex].size - currentLabelByteIndex
+            for (i in currentLabelIndex + 1 until labels.size) {
+                labelBytesLeft += labels[i].size
+            }
+
+            if (labelBytesLeft < publicSuffixBytesLeft) {
+                high = start - 1
+            } else if (labelBytesLeft > publicSuffixBytesLeft) {
+                low = start + end + 1
+            } else {
+                // Found a match.
+                match = String(this, start, publicSuffixLength, Charsets.UTF_8)
+                break
+            }
+        }
+    }
+
+    return match
+}
+
+/**
+ * Search for a '\n' that marks the start of a value. Don't go back past the start of the array.
+ */
+private fun ByteArray.findStartOfLineFromIndex(start: Int): Int {
+    var index = start
+    while (index > -1 && this[index] != '\n'.toByte()) {
+        index--
+    }
+    index++
+    return index
+}
+
+/**
+ * Search for a '\n' that marks the end of a value.
+ */
+private fun ByteArray.findEndOfLineFromIndex(start: Int): Int {
+    var end = 1
+    while (this[start + end] != '\n'.toByte()) {
+        end++
+    }
+    return end
+}
diff --git a/android-components/components/lib/publicsuffixlist/src/test/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListTest.kt b/android-components/components/lib/publicsuffixlist/src/test/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListTest.kt
new file mode 100644
index 000000000000..3678492b0309
--- /dev/null
+++ b/android-components/components/lib/publicsuffixlist/src/test/java/mozilla/components/lib/publicsuffixlist/PublicSuffixListTest.kt
@@ -0,0 +1,379 @@
+package mozilla.components.lib.publicsuffixlist
+
+import android.content.Context
+import androidx.test.core.app.ApplicationProvider
+import kotlinx.coroutines.runBlocking
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class PublicSuffixListTest {
+    private val context: Context
+        get() = ApplicationProvider.getApplicationContext()
+
+    private val publicSuffixList
+        get() = PublicSuffixList(context)
+
+    @Test
+    fun `Verify getPublicSuffixPlusOne for known domains`() = runBlocking {
+        assertEquals(
+            "mozilla.org",
+            publicSuffixList.getPublicSuffixPlusOne("www.mozilla.org").await())
+
+        assertEquals(
+            "google.com",
+            publicSuffixList.getPublicSuffixPlusOne("google.com").await())
+
+        assertEquals(
+            "foobar.blogspot.com",
+            publicSuffixList.getPublicSuffixPlusOne("foobar.blogspot.com").await())
+
+        assertEquals(
+            "independent.co.uk",
+            publicSuffixList.getPublicSuffixPlusOne("independent.co.uk").await())
+
+        assertEquals(
+            "independent.co.uk",
+            publicSuffixList.getPublicSuffixPlusOne("www.independent.co.uk").await())
+
+        assertEquals(
+            "biz.com.ua",
+            publicSuffixList.getPublicSuffixPlusOne("www.biz.com.ua").await())
+
+        assertEquals(
+            "example.org",
+            publicSuffixList.getPublicSuffixPlusOne("example.org").await())
+
+        assertEquals(
+            "example.pvt.k12.ma.us",
+            publicSuffixList.getPublicSuffixPlusOne("www.example.pvt.k12.ma.us").await())
+
+        assertEquals(
+            "Œ¥œÄŒ∏.gr",
+            publicSuffixList.getPublicSuffixPlusOne("www.ŒøœÖœÑŒøœÄŒØŒ±.Œ¥œÄŒ∏.gr").await())
+    }
+
+    @Test
+    fun `Verify getPublicSuffix for known domains`() = runBlocking {
+        assertEquals(
+            "org",
+            publicSuffixList.getPublicSuffix("www.mozilla.org").await())
+
+        assertEquals(
+            "com",
+            publicSuffixList.getPublicSuffix("google.com").await())
+
+        assertEquals(
+            "blogspot.com",
+            publicSuffixList.getPublicSuffix("foobar.blogspot.com").await())
+
+        assertEquals(
+            "co.uk",
+            publicSuffixList.getPublicSuffix("independent.co.uk").await())
+
+        assertEquals(
+            "co.uk",
+            publicSuffixList.getPublicSuffix("www.independent.co.uk").await())
+
+        assertEquals(
+            "com.ua",
+            publicSuffixList.getPublicSuffix("www.biz.com.ua").await())
+
+        assertEquals(
+            "org",
+            publicSuffixList.getPublicSuffix("example.org").await())
+
+        assertEquals(
+            "pvt.k12.ma.us",
+            publicSuffixList.getPublicSuffix("www.example.pvt.k12.ma.us").await())
+
+        assertEquals(
+            "gr",
+            publicSuffixList.getPublicSuffix("www.ŒøœÖœÑŒøœÄŒØŒ±.Œ¥œÄŒ∏.gr").await())
+    }
+
+    @Test
+    fun `Verify stripPublicSuffix for known domains`() = runBlocking {
+        assertEquals(
+            "www.mozilla",
+            publicSuffixList.stripPublicSuffix("www.mozilla.org").await())
+
+        assertEquals(
+            "google",
+            publicSuffixList.stripPublicSuffix("google.com").await())
+
+        assertEquals(
+            "foobar",
+            publicSuffixList.stripPublicSuffix("foobar.blogspot.com").await())
+
+        assertEquals(
+            "independent",
+            publicSuffixList.stripPublicSuffix("independent.co.uk").await())
+
+        assertEquals(
+            "www.independent",
+            publicSuffixList.stripPublicSuffix("www.independent.co.uk").await())
+
+        assertEquals(
+            "www.biz",
+            publicSuffixList.stripPublicSuffix("www.biz.com.ua").await())
+
+        assertEquals(
+            "example",
+            publicSuffixList.stripPublicSuffix("example.org").await())
+
+        assertEquals(
+            "www.example",
+            publicSuffixList.stripPublicSuffix("www.example.pvt.k12.ma.us").await())
+
+        assertEquals(
+            "www.ŒøœÖœÑŒøœÄŒØŒ±.Œ¥œÄŒ∏",
+            publicSuffixList.stripPublicSuffix("www.ŒøœÖœÑŒøœÄŒØŒ±.Œ¥œÄŒ∏.gr").await())
+    }
+
+    /**
+     * Short set of test data from:
+     * https://raw.githubusercontent.com/publicsuffix/list/master/tests/test_psl.txt
+     */
+    @Test
+    fun `Verify getPublicSuffixPlusOne against official test data`() = runBlocking {
+        // empty input
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("").await())
+
+        // Mixed case.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("COM").await())
+        assertEquals(
+            "example.COM",
+            publicSuffixList.getPublicSuffixPlusOne("example.COM").await())
+        assertEquals(
+            "eXample.COM",
+            publicSuffixList.getPublicSuffixPlusOne("WwW.eXample.COM").await())
+
+        // Leading dot.
+        // ArrayIndexOutOfBoundsException: assertEquals("", publicSuffixList.getPublicSuffixPlusOne(".example.com").await())
+
+        // TLD with only 1 rule.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("biz").await())
+        assertEquals(
+            "domain.biz",
+            publicSuffixList.getPublicSuffixPlusOne("domain.biz").await())
+        assertEquals(
+            "domain.biz",
+            publicSuffixList.getPublicSuffixPlusOne("b.domain.biz").await())
+        assertEquals(
+            "domain.biz",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.domain.biz").await())
+
+        // TLD with some 2-level rules.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("com").await())
+        assertEquals(
+            "example.com",
+            publicSuffixList.getPublicSuffixPlusOne("example.com").await())
+        assertEquals(
+            "example.com",
+            publicSuffixList.getPublicSuffixPlusOne("b.example.com").await())
+        assertEquals(
+            "example.com",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.example.com").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("uk.com").await())
+        assertEquals(
+            "example.uk.com",
+            publicSuffixList.getPublicSuffixPlusOne("example.uk.com").await())
+        assertEquals(
+            "example.uk.com",
+            publicSuffixList.getPublicSuffixPlusOne("b.example.uk.com").await())
+        assertEquals(
+            "example.uk.com",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.example.uk.com").await())
+        assertEquals(
+            "test.ac",
+            publicSuffixList.getPublicSuffixPlusOne("test.ac").await())
+
+        // TLD with only 1 (wildcard) rule.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("mm").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("c.mm").await())
+        assertEquals(
+            "b.c.mm",
+            publicSuffixList.getPublicSuffixPlusOne("b.c.mm").await())
+        assertEquals(
+            "b.c.mm",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.c.mm").await())
+
+        // More complex TLD.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("jp").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("ac.jp").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("kyoto.jp").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("ide.kyoto.jp").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("c.kobe.jp").await())
+        assertEquals(
+            "test.jp",
+            publicSuffixList.getPublicSuffixPlusOne("test.jp").await())
+        assertEquals(
+            "test.jp",
+            publicSuffixList.getPublicSuffixPlusOne("www.test.jp").await())
+        assertEquals(
+            "test.ac.jp",
+            publicSuffixList.getPublicSuffixPlusOne("test.ac.jp").await())
+        assertEquals(
+            "test.ac.jp",
+            publicSuffixList.getPublicSuffixPlusOne("www.test.ac.jp").await())
+        assertEquals(
+            "test.kyoto.jp",
+            publicSuffixList.getPublicSuffixPlusOne("test.kyoto.jp").await())
+        assertEquals(
+            "b.ide.kyoto.jp",
+            publicSuffixList.getPublicSuffixPlusOne("b.ide.kyoto.jp").await())
+        assertEquals(
+            "b.ide.kyoto.jp",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.ide.kyoto.jp").await())
+        assertEquals(
+            "b.c.kobe.jp",
+            publicSuffixList.getPublicSuffixPlusOne("b.c.kobe.jp").await())
+        assertEquals(
+            "b.c.kobe.jp",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.c.kobe.jp").await())
+        assertEquals(
+            "city.kobe.jp",
+            publicSuffixList.getPublicSuffixPlusOne("city.kobe.jp").await())
+        assertEquals(
+            "city.kobe.jp",
+            publicSuffixList.getPublicSuffixPlusOne("www.city.kobe.jp").await())
+
+        // TLD with a wildcard rule and exceptions.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("ck").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("test.ck").await())
+        assertEquals(
+            "b.test.ck",
+            publicSuffixList.getPublicSuffixPlusOne("b.test.ck").await())
+        assertEquals(
+            "b.test.ck",
+            publicSuffixList.getPublicSuffixPlusOne("a.b.test.ck").await())
+        assertEquals(
+            "www.ck",
+            publicSuffixList.getPublicSuffixPlusOne("www.ck").await())
+        assertEquals(
+            "www.ck",
+            publicSuffixList.getPublicSuffixPlusOne("www.www.ck").await())
+
+        // US K12.
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("us").await())
+        assertEquals(
+            "test.us",
+            publicSuffixList.getPublicSuffixPlusOne("test.us").await())
+        assertEquals(
+            "test.us",
+            publicSuffixList.getPublicSuffixPlusOne("www.test.us").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("ak.us").await())
+        assertEquals(
+            "test.ak.us",
+            publicSuffixList.getPublicSuffixPlusOne("www.test.ak.us").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("k12.ak.us").await())
+        assertEquals(
+            "test.k12.ak.us",
+            publicSuffixList.getPublicSuffixPlusOne("test.k12.ak.us").await())
+        assertEquals(
+            "test.k12.ak.us",
+            publicSuffixList.getPublicSuffixPlusOne("www.test.k12.ak.us").await())
+
+        // IDN labels.
+        assertEquals(
+            "È£üÁãÆ.com.cn",
+            publicSuffixList.getPublicSuffixPlusOne("È£üÁãÆ.com.cn").await())
+        // https://github.com/mozilla-mobile/android-components/issues/1777
+        /*
+        assertEquals(
+            "È£üÁãÆ.ÂÖ¨Âè∏.cn",
+            publicSuffixList.getPublicSuffixPlusOne("È£üÁãÆ.ÂÖ¨Âè∏.cn").await())
+        assertEquals(
+            "È£üÁãÆ.ÂÖ¨Âè∏.cn",
+            publicSuffixList.getPublicSuffixPlusOne("www.È£üÁãÆ.ÂÖ¨Âè∏.cn").await())
+        assertEquals(
+            "shishi.ÂÖ¨Âè∏.cn",
+            publicSuffixList.getPublicSuffixPlusOne("shishi.ÂÖ¨Âè∏.cn").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("ÂÖ¨Âè∏.cn").await())
+        */
+        assertEquals(
+            "È£üÁãÆ.‰∏≠ÂõΩ",
+            publicSuffixList.getPublicSuffixPlusOne("È£üÁãÆ.‰∏≠ÂõΩ").await())
+        assertEquals(
+            "È£üÁãÆ.‰∏≠ÂõΩ",
+            publicSuffixList.getPublicSuffixPlusOne("www.È£üÁãÆ.‰∏≠ÂõΩ").await())
+        assertEquals(
+            "shishi.‰∏≠ÂõΩ",
+            publicSuffixList.getPublicSuffixPlusOne("shishi.‰∏≠ÂõΩ").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("‰∏≠ÂõΩ").await())
+
+        // Same as above, but punycoded.
+        assertEquals(
+            "xn--85x722f.com.cn",
+            publicSuffixList.getPublicSuffixPlusOne("xn--85x722f.com.cn").await())
+        // https://github.com/mozilla-mobile/android-components/issues/1777
+        /*
+        assertEquals(
+            "xn--85x722f.xn--55qx5d.cn",
+            publicSuffixList.getPublicSuffixPlusOne("xn--85x722f.xn--55qx5d.cn").await())
+        assertEquals(
+            "xn--85x722f.xn--55qx5d.cn",
+            publicSuffixList.getPublicSuffixPlusOne("www.xn--85x722f.xn--55qx5d.cn").await())
+        assertEquals(
+            "shishi.xn--55qx5d.cn",
+            publicSuffixList.getPublicSuffixPlusOne("shishi.xn--55qx5d.cn").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("xn--55qx5d.cn").await())
+        */
+        assertEquals(
+            "xn--85x722f.xn--fiqs8s",
+            publicSuffixList.getPublicSuffixPlusOne("xn--85x722f.xn--fiqs8s").await())
+        assertEquals(
+            "xn--85x722f.xn--fiqs8s",
+            publicSuffixList.getPublicSuffixPlusOne("www.xn--85x722f.xn--fiqs8s").await())
+        assertEquals(
+            "shishi.xn--fiqs8s",
+            publicSuffixList.getPublicSuffixPlusOne("shishi.xn--fiqs8s").await())
+        assertNull(publicSuffixList.getPublicSuffixPlusOne("xn--fiqs8s").await())
+    }
+
+    @Test
+    fun `Accessing with and without prefetch`() = runBlocking {
+        run {
+            val publicSuffixList = PublicSuffixList(context)
+            assertEquals("org", publicSuffixList.getPublicSuffix("mozilla.org").await())
+        }
+
+        run {
+            val publicSuffixList = PublicSuffixList(context).apply {
+                prefetch().await()
+            }
+            assertEquals("org", publicSuffixList.getPublicSuffix("mozilla.org").await())
+        }
+    }
+
+    @Test
+    fun `Verify isPublicSuffix with known and unknown suffixes`() = runBlocking {
+        assertTrue(publicSuffixList.isPublicSuffix("org").await())
+        assertTrue(publicSuffixList.isPublicSuffix("com").await())
+        assertTrue(publicSuffixList.isPublicSuffix("us").await())
+        assertTrue(publicSuffixList.isPublicSuffix("de").await())
+        assertTrue(publicSuffixList.isPublicSuffix("de.com").await())
+        assertTrue(publicSuffixList.isPublicSuffix("co.uk").await())
+        assertTrue(publicSuffixList.isPublicSuffix("taxi.br").await())
+        assertTrue(publicSuffixList.isPublicSuffix("edu.cw").await())
+        assertTrue(publicSuffixList.isPublicSuffix("chirurgiens-dentistes.fr").await())
+        assertTrue(publicSuffixList.isPublicSuffix("trani-andria-barletta.it").await())
+        assertTrue(publicSuffixList.isPublicSuffix("yabuki.fukushima.jp").await())
+        assertTrue(publicSuffixList.isPublicSuffix("research.museum").await())
+        assertTrue(publicSuffixList.isPublicSuffix("lamborghini").await())
+        assertTrue(publicSuffixList.isPublicSuffix("reisen").await())
+        assertTrue(publicSuffixList.isPublicSuffix("github.io").await())
+
+        assertFalse(publicSuffixList.isPublicSuffix("").await())
+        assertFalse(publicSuffixList.isPublicSuffix("mozilla").await())
+        assertFalse(publicSuffixList.isPublicSuffix("mozilla.org").await())
+        assertFalse(publicSuffixList.isPublicSuffix("ork").await())
+        assertFalse(publicSuffixList.isPublicSuffix("us.com.uk").await())
+    }
+}
