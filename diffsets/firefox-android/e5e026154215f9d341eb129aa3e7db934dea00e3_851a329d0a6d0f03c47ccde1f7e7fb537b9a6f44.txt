diff --git a/android-components/components/feature/accounts-push/src/main/java/mozilla/components/feature/accounts/push/FxaPushSupportFeature.kt b/android-components/components/feature/accounts-push/src/main/java/mozilla/components/feature/accounts/push/FxaPushSupportFeature.kt
index 1264f2e8f5c0..ca9048847e18 100644
--- a/android-components/components/feature/accounts-push/src/main/java/mozilla/components/feature/accounts/push/FxaPushSupportFeature.kt
+++ b/android-components/components/feature/accounts-push/src/main/java/mozilla/components/feature/accounts/push/FxaPushSupportFeature.kt
@@ -17,7 +17,6 @@ import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.launch
 import mozilla.components.concept.base.crash.Breadcrumb
 import mozilla.components.concept.base.crash.CrashReporting
-import mozilla.components.concept.push.exceptions.SubscriptionException
 import mozilla.components.concept.sync.AuthType
 import mozilla.components.concept.sync.ConstellationState
 import mozilla.components.concept.sync.Device
@@ -25,7 +24,6 @@ import mozilla.components.concept.sync.DeviceConstellation
 import mozilla.components.concept.sync.DeviceConstellationObserver
 import mozilla.components.concept.sync.DevicePushSubscription
 import mozilla.components.concept.sync.OAuthAccount
-import mozilla.components.feature.accounts.push.ext.redactPartialUri
 import mozilla.components.feature.push.AutoPushFeature
 import mozilla.components.feature.push.AutoPushSubscription
 import mozilla.components.feature.push.PushScope
@@ -67,6 +65,9 @@ class FxaPushSupportFeature(
      * A unique scope for the FxA push subscription that is generated once and stored in SharedPreferences.
      *
      * This scope is randomly generated and unique to the account on that particular device.
+     * (why this uuid? Note it is *not* reset on logout!)
+     * (isn't this racey? Different observers reference it)
+     * (maybe you just want the acct uid?)
      */
     private val fxaPushScope: String by lazy {
         val prefs = preference(context)
@@ -137,26 +138,6 @@ internal class AccountObserver(
             crashReporter = crashReporter
         )
 
-        // We need a new subscription only when we have a new account.
-        // The subscription is removed when an account logs out.
-        if (authType != AuthType.Existing && authType != AuthType.Recovered) {
-            logger.debug("Subscribing for FxaPushScope ($fxaPushScope) events.")
-
-            push.subscribe(
-                scope = fxaPushScope,
-                onSubscribeError = { e ->
-                    crashReporter?.recordCrashBreadcrumb(Breadcrumb("Subscribing to FxA push failed at login."))
-                    logger.info("Subscribing to FxA push failed at login.", e)
-                },
-                onSubscribe = { subscription ->
-                    logger.info("Created a new subscription: $subscription")
-                    CoroutineScope(Dispatchers.Main).launch {
-                        account.deviceConstellation().setDevicePushSubscription(subscription.into())
-                    }
-                }
-            )
-        }
-
         // NB: can we just expose registerDeviceObserver on account manager?
         // registration could happen after onDevicesUpdate has been called, without having to tie this
         // into the account "auth lifecycle".
@@ -172,13 +153,56 @@ internal class AccountObserver(
 
         push.unsubscribe(fxaPushScope)
 
-        // Delete cached value of last verified timestamp and scope when we log out.
+        // Delete cached value of last verified timestamp when we log out.
         preference(context).edit()
             .remove(PREF_LAST_VERIFIED)
             .apply()
     }
 }
 
+/**
+ * Subscribes to the AutoPushFeature, and updates the FxA device record if necessary.
+ * Note that if the subscription already exists, then this doesn't hit any servers, so
+ * it's OK to call this somewhat frequently.
+ */
+internal fun pushSubscribe(
+    push: AutoPushFeature,
+    account: OAuthAccount,
+    scope: String,
+    crashReporter: CrashReporting?,
+    logContext: String
+) {
+    val logger = Logger("FxaPushSupportFeature")
+    val currentDevice = account.deviceConstellation().state()?.currentDevice
+    if (currentDevice == null) {
+        logger.warn("Can't subscribe to account push notifications as there's no current device")
+        return
+    }
+    logger.debug("Subscribing for FxaPushScope ($scope) events.")
+    push.subscribe(
+        scope,
+        onSubscribeError = { e ->
+            crashReporter?.recordCrashBreadcrumb(Breadcrumb("Subscribing to FxA push failed."))
+            logger.warn("Subscribing to FxA push failed: $logContext: ", e)
+        },
+        onSubscribe = { subscription ->
+            logger.info("Created a new subscription: $logContext: $subscription")
+            // Apparently `subscriptionExpired` typically means just the FCM token is wrong, so
+            // after getting a new one, our push endpoint will remain the same as it was. So here
+            // we always update the endpoint if `subscriptionExpired` is true, even when the
+            // subscription matches, just to ensure `subscriptionExpired` is reset.
+            if (currentDevice.subscriptionExpired ||
+                currentDevice.subscription?.endpoint != subscription.endpoint
+            ) {
+                logger.info("Updating account with new subscription info.")
+                CoroutineScope(Dispatchers.Main).launch {
+                    account.deviceConstellation().setDevicePushSubscription(subscription.into())
+                }
+            }
+        }
+    )
+}
+
 /**
  * A [DeviceConstellation] observer to know when we should notify the push feature to begin the registration renewal
  * when notified by the FxA server. See [Device.subscriptionExpired].
@@ -196,83 +220,29 @@ internal class ConstellationObserver(
 
     override fun onDevicesUpdate(constellation: ConstellationState) {
         logger.info("onDevicesUpdate triggered.")
-        val updateSubscription = constellation.currentDevice?.let {
-            it.subscription == null || it.subscriptionExpired
-        } ?: false
-
-        // If our subscription has not expired, we do nothing.
-        // If our last check was recent (see: PERIODIC_INTERVAL_MILLISECONDS), we do nothing.
-        val allowedToRenew = verifier.allowedToRenew()
-        if (!updateSubscription || !allowedToRenew) {
-            logger.info(
-                "Short-circuiting onDevicesUpdate: " +
-                    "updateSubscription($updateSubscription), allowedToRenew($allowedToRenew)"
-            )
-            return
-        } else {
-            logger.info("Proceeding to renew registration")
-        }
-
-        logger.info("Our push subscription either doesn't exist or is expired; renewing registration.")
-        push.renewRegistration()
-
-        logger.info("Incrementing verifier")
-        logger.info("Verifier state before: timestamp=${verifier.innerTimestamp}, count=${verifier.innerCount}")
-        verifier.increment()
-        logger.info("Verifier state after: timestamp=${verifier.innerTimestamp}, count=${verifier.innerCount}")
-    }
-
-    internal fun onSubscribe(constellation: ConstellationState, subscription: AutoPushSubscription) {
-
-        logger.info("Created a new subscription: $subscription")
 
-        val oldEndpoint = constellation.currentDevice?.subscription?.endpoint
-        if (subscription.endpoint == oldEndpoint) {
-            val exception = SubscriptionException(
-                "New push endpoint matches existing one",
-                Throwable(
-                    "Endpoint: ${subscription.endpoint.redactPartialUri()}"
-                )
-            )
-
-            logger.warn("Push endpoints match!", exception)
-
-            crashReporter?.submitCaughtException(exception)
-        }
-
-        CoroutineScope(Dispatchers.Main).launch {
-            account.deviceConstellation().setDevicePushSubscription(subscription.into())
+        val currentDevice = constellation.currentDevice ?: return
+        if (currentDevice.subscriptionExpired) {
+            if (verifier.allowedToRenew()) {
+                // This smells wrong - the fact FxaPushSupportFeature needs to detect a
+                // subscription problem implies non-FxA users will never detect this and
+                // remain broken?
+                logger.info("Our push subscription is expired; renewing FCM registration.")
+                push.renewRegistration()
+
+                logger.info("Incrementing verifier")
+                logger.debug("Verifier state before: timestamp=${verifier.innerTimestamp}, count=${verifier.innerCount}")
+                verifier.increment()
+                logger.debug("Verifier state after: timestamp=${verifier.innerTimestamp}, count=${verifier.innerCount}")
+            } else {
+                logger.info("Short-circuiting onDevicesUpdate: rate-limited")
+            }
         }
-    }
-
-    internal fun onSubscribeError(e: Exception) {
-        val errorMessage = "Re-subscribing failed; FxA push events will not be received."
 
-        logger.warn(errorMessage, e)
-        crashReporter?.submitCaughtException(SubscriptionException(errorMessage, e))
-    }
-
-    internal fun onUnsubscribeError(e: Exception) {
-        val errorMessage = "Un-subscribing to failed FxA push after subscriptionExpired"
-
-        logger.warn(errorMessage, e)
-        crashReporter?.recordCrashBreadcrumb(
-            Breadcrumb(
-                category = ConstellationObserver::class.java.simpleName,
-                message = errorMessage,
-                data = mapOf(
-                    "exception" to e.javaClass.name,
-                    "message" to e.message.orEmpty()
-                )
-            )
-        )
-    }
-
-    private fun onUnsubscribeResult(success: Boolean) {
-        logger.info("Un-subscribing successful: $success")
-        if (success) {
-            logger.info("Subscribe call should give you a new endpoint.")
-        }
+        // And unconditionally subscribe - if our local DB already has a subscription it will
+        // be returned without hitting the server. If some other problem meant our subscription
+        // was dropped or never made, it will hit the server and deliver a new end-point.
+        pushSubscribe(push, account, scope, crashReporter, "onDevicesUpdate")
     }
 }
 
@@ -310,18 +280,12 @@ internal class AutoPushObserver(
 
         logger.info("Our sync push scope ($scope) has expired. Re-subscribing..")
 
-        pushFeature.subscribe(fxaPushScope) { subscription ->
-            val account = accountManager.authenticatedAccount()
-
-            if (account == null) {
-                logger.info("We don't have any account to pass the push subscription to.")
-                return@subscribe
-            }
-
-            CoroutineScope(Dispatchers.Main).launch {
-                account.deviceConstellation().setDevicePushSubscription(subscription.into())
-            }
+        val account = accountManager.authenticatedAccount()
+        if (account == null) {
+            logger.info("We don't have any account to pass the push subscription to.")
+            return
         }
+        pushSubscribe(pushFeature, account, fxaPushScope, null, "onSubscriptionChanged")
     }
 }
 
diff --git a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AccountObserverTest.kt b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AccountObserverTest.kt
index b2fa4aa668ec..dd91bd63fd98 100644
--- a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AccountObserverTest.kt
+++ b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AccountObserverTest.kt
@@ -6,19 +6,16 @@ package mozilla.components.feature.accounts.push
 
 import androidx.lifecycle.Lifecycle
 import androidx.lifecycle.LifecycleOwner
-import kotlinx.coroutines.runBlocking
 import mozilla.components.concept.base.crash.CrashReporting
 import mozilla.components.concept.sync.AuthType
 import mozilla.components.concept.sync.DeviceConstellation
 import mozilla.components.concept.sync.OAuthAccount
 import mozilla.components.feature.push.AutoPushFeature
-import mozilla.components.feature.push.AutoPushSubscription
 import mozilla.components.feature.push.PushConfig
 import mozilla.components.service.fxa.manager.FxaAccountManager
 import mozilla.components.support.test.any
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.mock
-import mozilla.components.support.test.nullable
 import mozilla.components.support.test.robolectric.testContext
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
@@ -30,7 +27,6 @@ import org.mockito.Mockito.`when`
 import org.mockito.Mockito.reset
 import org.mockito.Mockito.verify
 import org.mockito.Mockito.verifyNoMoreInteractions
-import org.mockito.stubbing.OngoingStubbing
 import org.robolectric.RobolectricTestRunner
 
 @RunWith(RobolectricTestRunner::class)
@@ -102,45 +98,7 @@ class AccountObserverTest {
     }
 
     @Test
-    fun `feature invoked on new account authenticated`() {
-        val observer = AccountObserver(
-            testContext,
-            pushFeature,
-            pushScope,
-            crashReporter,
-            mock(),
-            false
-        )
-
-        observer.onAuthenticated(account, AuthType.Signin)
-
-        verify(pushFeature).config
-        verify(pushFeature).subscribe(eq(pushScope), nullable(), any(), any())
-        verify(constellation).registerDeviceObserver(any(), any(), anyBoolean())
-
-        verifyNoMoreInteractions(pushFeature)
-    }
-
-    @Test
-    fun `feature and service are not invoked if not provided`() {
-        val observer = AccountObserver(
-            testContext,
-            pushFeature,
-            pushScope,
-            crashReporter,
-            mock(),
-            false
-        )
-
-        observer.onAuthenticated(account, AuthType.Signup)
-        observer.onLoggedOut()
-
-        verify(pushFeature).subscribe(eq(pushScope), nullable(), any(), any())
-        verify(constellation).registerDeviceObserver(any(), any(), anyBoolean())
-    }
-
-    @Test
-    fun `feature does not subscribe if not a new account`() {
+    fun `feature does not subscribe when authenticating`() {
         val observer = AccountObserver(
             testContext,
             pushFeature,
@@ -159,44 +117,14 @@ class AccountObserverTest {
         observer.onAuthenticated(account, AuthType.Recovered)
 
         verifyNoMoreInteractions(pushFeature)
-    }
 
-    @Test
-    fun `notify account of new subscriptions`() = runBlocking {
-        val observer = AccountObserver(
-            testContext,
-            pushFeature,
-            pushScope,
-            crashReporter,
-            mock(),
-            false
-        )
-
-        whenSubscribe()
-
-        observer.onAuthenticated(account, AuthType.Signin)
-
-        verify(constellation).setDevicePushSubscription(any())
-        Unit
-    }
-
-    @Test
-    fun `notify crash reporter on subscription error`() = runBlocking {
-        val observer = AccountObserver(
-            testContext,
-            pushFeature,
-            pushScope,
-            crashReporter,
-            mock(),
-            false
-        )
+        observer.onAuthenticated(account, AuthType.Signup)
 
-        whenSubscribeError()
+        verifyNoMoreInteractions(pushFeature)
 
         observer.onAuthenticated(account, AuthType.Signin)
 
-        verify(crashReporter).recordCrashBreadcrumb(any())
-        Unit
+        verifyNoMoreInteractions(pushFeature)
     }
 
     @Test
@@ -232,32 +160,4 @@ class AccountObserverTest {
         verify(pushFeature).config
         verifyNoMoreInteractions(pushFeature)
     }
-
-    @Suppress("UNCHECKED_CAST")
-    private fun whenSubscribe(): OngoingStubbing<Unit>? {
-        return `when`(pushFeature.subscribe(any(), nullable(), any(), any())).thenAnswer {
-
-            // Invoke the `onSubscribe` lambda with a fake subscription.
-            (it.arguments[3] as ((AutoPushSubscription) -> Unit)).invoke(
-                AutoPushSubscription(
-                    scope = "test",
-                    endpoint = "https://foo",
-                    publicKey = "p256dh",
-                    authKey = "auth",
-                    appServerKey = null
-                )
-            )
-        }
-    }
-
-    @Suppress("UNCHECKED_CAST")
-    private fun whenSubscribeError(): OngoingStubbing<Unit>? {
-        return `when`(pushFeature.subscribe(any(), nullable(), any(), any())).thenAnswer {
-
-            // Invoke the `onSubscribe` lambda with a fake subscription.
-            (it.arguments[2] as ((Exception) -> Unit)).invoke(
-                IllegalStateException("test")
-            )
-        }
-    }
 }
diff --git a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AutoPushObserverTest.kt b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AutoPushObserverTest.kt
index beceabe907e6..58576df74ade 100644
--- a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AutoPushObserverTest.kt
+++ b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/AutoPushObserverTest.kt
@@ -9,6 +9,8 @@ import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.runBlocking
 import kotlinx.coroutines.test.TestCoroutineDispatcher
 import kotlinx.coroutines.test.setMain
+import mozilla.components.concept.sync.ConstellationState
+import mozilla.components.concept.sync.Device
 import mozilla.components.concept.sync.DeviceConstellation
 import mozilla.components.concept.sync.OAuthAccount
 import mozilla.components.feature.push.AutoPushFeature
@@ -76,6 +78,11 @@ class AutoPushObserverTest {
 
         `when`(manager.authenticatedAccount()).thenReturn(account)
         `when`(account.deviceConstellation()).thenReturn(constellation)
+        val state: ConstellationState = mock()
+        val device: Device = mock()
+        `when`(constellation.state()).thenReturn(state)
+        `when`(state.currentDevice).thenReturn(device)
+        `when`(device.subscriptionExpired).thenReturn(true)
 
         observer.onSubscriptionChanged("test")
 
diff --git a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/ConstellationObserverTest.kt b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/ConstellationObserverTest.kt
index 4b0becee6fb2..abc6b1064fa0 100644
--- a/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/ConstellationObserverTest.kt
+++ b/android-components/components/feature/accounts-push/src/test/java/mozilla/components/feature/accounts/push/ConstellationObserverTest.kt
@@ -8,8 +8,8 @@ package mozilla.components.feature.accounts.push
 
 import android.content.Context
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import kotlinx.coroutines.runBlocking
 import mozilla.components.concept.base.crash.CrashReporting
-import mozilla.components.concept.push.exceptions.SubscriptionException
 import mozilla.components.concept.sync.ConstellationState
 import mozilla.components.concept.sync.Device
 import mozilla.components.concept.sync.DeviceConstellation
@@ -20,7 +20,9 @@ import mozilla.components.feature.push.AutoPushSubscription
 import mozilla.components.support.test.any
 import mozilla.components.support.test.eq
 import mozilla.components.support.test.mock
+import mozilla.components.support.test.nullable
 import mozilla.components.support.test.rule.MainCoroutineRule
+import org.junit.Before
 import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
@@ -28,6 +30,8 @@ import org.junit.runner.RunWith
 import org.mockito.Mockito.`when`
 import org.mockito.Mockito.verify
 import org.mockito.Mockito.verifyNoInteractions
+import org.mockito.Mockito.verifyNoMoreInteractions
+import org.mockito.stubbing.OngoingStubbing
 
 @RunWith(AndroidJUnit4::class)
 class ConstellationObserverTest {
@@ -38,115 +42,114 @@ class ConstellationObserverTest {
     private val device: Device = mock()
     private val context: Context = mock()
     private val account: OAuthAccount = mock()
+    private val constellation: DeviceConstellation = mock()
     private val crashReporter: CrashReporting = mock()
 
+    @Before
+    fun setup() {
+        `when`(state.currentDevice).thenReturn(device)
+        `when`(device.subscriptionExpired).thenReturn(false)
+        `when`(account.deviceConstellation()).thenReturn(constellation)
+        `when`(constellation.state()).thenReturn(state)
+    }
+
     @get:Rule
     val coroutinesTestRule = MainCoroutineRule()
 
     @Test
-    fun `do nothing if subscription has not expired`() {
+    fun `first subscribe works`() = runBlocking {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
 
-        observer.onDevicesUpdate(state)
-
         verifyNoInteractions(push)
 
-        `when`(state.currentDevice).thenReturn(device)
-        `when`(device.subscriptionExpired).thenReturn(false)
+        whenSubscribe()
 
         observer.onDevicesUpdate(state)
 
-        verifyNoInteractions(push)
+        verify(push).subscribe(eq("testScope"), any(), any(), any())
+        verifyNoMoreInteractions(push)
+        // We should have told the constellation of the new subscription.
+        verify(constellation).setDevicePushSubscription(any())
+
+        Unit
     }
 
     @Test
-    fun `do nothing if verifier is false`() {
+    fun `re-subscribe doesn't update constellation on same endpoint`() = runBlocking {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
 
-        observer.onDevicesUpdate(state)
-
-        verifyNoInteractions(push)
-
-        `when`(state.currentDevice).thenReturn(device)
-        `when`(device.subscriptionExpired).thenReturn(true)
-        `when`(verifier.allowedToRenew()).thenReturn(false)
-
         verifyNoInteractions(push)
 
-        `when`(device.subscriptionExpired).thenReturn(true)
+        whenAlreadySubscribed()
+        whenSubscribe()
 
         observer.onDevicesUpdate(state)
 
-        verifyNoInteractions(push)
+        verify(push).subscribe(eq("testScope"), any(), any(), any())
+        verifyNoMoreInteractions(push)
+        // We should not have told the constellation of the subscription as it matches
+        verify(constellation).state()
+        verifyNoMoreInteractions(constellation)
+        Unit
     }
 
     @Test
-    fun `invoke registration renewal`() {
+    fun `re-subscribe update constellations on same endpoint if expired`() = runBlocking {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
 
-        `when`(state.currentDevice).thenReturn(device)
-        `when`(device.subscriptionExpired).thenReturn(true)
-        `when`(verifier.allowedToRenew()).thenReturn(true)
+        verifyNoInteractions(push)
+
+        whenAlreadySubscribed(true)
+        whenSubscribe()
 
         observer.onDevicesUpdate(state)
 
-        verify(push).renewRegistration()
-        verify(verifier).increment()
+        verify(push).subscribe(eq("testScope"), any(), any(), any())
+        verifyNoMoreInteractions(push)
+        // We should have told the constellation of the same end-point subscription to clear the
+        // expired flag on the server.
+        verify(constellation).setDevicePushSubscription(any())
+        Unit
     }
 
-    /**
-     * Remove this test in the future. See [invoke registration renewal] test.
-     */
-    @Test
-    @Ignore("If we don't fix #7143, we may need this.")
-    fun `re-subscribe for push in onDevicesUpdate`() {
+    // @Test
+    fun `notify crash reporter if subscribe error occurs`() {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
 
-        `when`(state.currentDevice).thenReturn(device)
-        `when`(device.subscriptionExpired).thenReturn(true)
-        `when`(verifier.allowedToRenew()).thenReturn(true)
-
+        whenSubscribeError()
         observer.onDevicesUpdate(state)
 
-        verify(push).unsubscribe(eq("testScope"), any(), any())
-        verify(push).subscribe(eq("testScope"), any(), any(), any())
-        verify(verifier).increment()
+        verify(crashReporter).recordCrashBreadcrumb(any())
     }
 
     @Test
-    fun `notify crash reporter if old and new subscription matches`() {
+    fun `no FCM renewal if verifier is false`() {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
-        val constellation: DeviceConstellation = mock()
-        val state: ConstellationState = mock()
-        val device: Device = mock()
-        val subscription: DevicePushSubscription = mock()
-
-        `when`(account.deviceConstellation()).thenReturn(constellation)
-        `when`(state.currentDevice).thenReturn(device)
-        `when`(device.subscription).thenReturn(subscription)
-        `when`(subscription.endpoint).thenReturn("https://example.com/foobar")
 
-        observer.onSubscribe(state, testSubscription())
-
-        verify(crashReporter).submitCaughtException(any())
-    }
+        verifyNoInteractions(push)
 
-    @Test
-    fun `notify crash reporter if re-subscribe error occurs`() {
-        val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
+        `when`(device.subscriptionExpired).thenReturn(true)
+        `when`(verifier.allowedToRenew()).thenReturn(false)
 
-        observer.onSubscribeError(mock())
+        observer.onDevicesUpdate(state)
 
-        verify(crashReporter).submitCaughtException(any<SubscriptionException>())
+        // The verifier prevents us fetching a new FCM token but doesn't prevent
+        // us calling .subscribe() on the push service.
+        verify(push).subscribe(eq("testScope"), any(), any(), any())
+        verifyNoMoreInteractions(push)
     }
 
     @Test
-    fun `notify crash reporter if un-subscribe error occurs`() {
+    fun `invoke registration renewal`() {
         val observer = ConstellationObserver(context, push, "testScope", account, verifier, crashReporter)
 
-        observer.onUnsubscribeError(mock())
+        `when`(device.subscriptionExpired).thenReturn(true)
+        `when`(verifier.allowedToRenew()).thenReturn(true)
 
-        verify(crashReporter).recordCrashBreadcrumb(any())
+        observer.onDevicesUpdate(state)
+
+        verify(push).renewRegistration()
+        verify(verifier).increment()
     }
 
     private fun testSubscription() = AutoPushSubscription(
@@ -156,4 +159,33 @@ class ConstellationObserverTest {
         authKey = "",
         appServerKey = null
     )
+
+    @Suppress("UNCHECKED_CAST")
+    private fun whenSubscribe(): OngoingStubbing<Unit>? {
+        return `when`(push.subscribe(any(), nullable(), any(), any())).thenAnswer {
+
+            // Invoke the `onSubscribe` lambda with a fake subscription.
+            (it.arguments[3] as ((AutoPushSubscription) -> Unit)).invoke(
+                testSubscription()
+            )
+        }
+    }
+
+    @Suppress("UNCHECKED_CAST")
+    private fun whenSubscribeError(): OngoingStubbing<Unit>? {
+        return `when`(push.subscribe(any(), nullable(), any(), any())).thenAnswer {
+
+            // Invoke the `onSubscribeError` lambda with a fake exception.
+            (it.arguments[2] as ((Exception) -> Unit)).invoke(
+                IllegalStateException("test")
+            )
+        }
+    }
+
+    private fun whenAlreadySubscribed(expired: Boolean = false) {
+        val subscription: DevicePushSubscription = mock()
+        `when`(device.subscriptionExpired).thenReturn(expired)
+        `when`(device.subscription).thenReturn(subscription)
+        `when`(subscription.endpoint).thenReturn(testSubscription().endpoint)
+    }
 }
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
index a6f43bb5aeec..389878ee7d90 100644
--- a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/AutoPushFeature.kt
@@ -66,10 +66,10 @@ import kotlin.coroutines.CoroutineContext
  * ```
  *
  * @param context the application [Context].
- * @param service A [PushService] bridge that receives the encrypted push messages.
+ * @param service A [PushService] bridge that receives the encrypted push messages - eg, Firebase.
  * @param config An instance of [PushConfig] to configure the feature.
  * @param coroutineContext An instance of [CoroutineContext] used for executing async push tasks.
- * @param connection An implementation of [PushConnection] to communicate with any native layer.
+ * @param connection An implementation of [PushConnection] to communicate with autopush - eg, app-services component.
  * @param crashReporter An optional instance of a [CrashReporting].
  */
 @Suppress("LargeClass", "LongParameterList")
@@ -101,27 +101,21 @@ class AutoPushFeature(
 
     private val coroutineScope = CoroutineScope(coroutineContext) + SupervisorJob() + exceptionHandler { onError(it) }
 
-    init {
-        // If we have a token, initialize the rust component first.
-        coroutineScope.launch {
-            prefToken?.let { token ->
-                logger.debug("Initializing native component with the cached token.")
-
-                connection.updateToken(token)
-            }
-        }
-    }
-
     /**
      * Starts the push feature and initialization work needed. Also starts the [PushService] to ensure new messages
      * come through.
      */
     override fun initialize() {
-        // Starts the push feature so that we receive messages if the service is not already started (safe call).
+        // If we have a token, initialize the rust component on a different thread.
+        coroutineScope.launch {
+            prefToken?.let { token ->
+                logger.debug("Initializing rust component with the cached token.")
+                connection.updateToken(token)
+                tryVerifySubscriptions()
+            }
+        }
+        // Starts the (FCM) push feature so that we receive messages if the service is not already started (safe call).
         service.start(context)
-
-        // Starts verification of push subscription endpoints.
-        tryVerifySubscriptions()
     }
 
     /**
@@ -151,15 +145,11 @@ class AutoPushFeature(
         coroutineScope.launchAndTry {
             logger.info("Received a new registration token from push service.")
 
-            // Implementation notes: We create a fake subscription, since receiving another token before
-            // a subscription will cause a fatal crash. See https://github.com/mozilla/application-services/issues/2490
-            if (prefToken.isNullOrEmpty()) {
-                subscribe("fake")
-            }
+            saveToken(context, newToken)
 
+            // Tell the autopush service about it and update subscriptions.
             connection.updateToken(newToken)
-
-            saveToken(context, newToken)
+            tryVerifySubscriptions()
         }
     }
 
@@ -274,11 +264,14 @@ class AutoPushFeature(
     }
 
     /**
-     * Deletes the registration token locally so that it forces the service to get a new one the
+     * Deletes the FCM registration token locally so that it forces the service to get a new one the
      * next time hits it's messaging server.
+     * XXX - this is suspect - the only caller of this is FxA, and it calls it when the device
+     * record indicates the end-point is expired. If that's truly necessary, then it will mean
+     * push never recovers for non-FxA users. If that's not truly necessary, we should remove it!
      */
     override fun renewRegistration() {
-        logger.warn("Forcing registration renewal by deleting our (cached) token.")
+        logger.warn("Forcing FCM registration renewal by deleting our (cached) token.")
 
         // Remove the cached token we have.
         deleteToken(context)
diff --git a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
index 3628cc632bc3..684e5dc8ceb2 100644
--- a/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
+++ b/android-components/components/feature/push/src/main/java/mozilla/components/feature/push/Connection.kt
@@ -167,7 +167,7 @@ internal class RustPushConnection(
 
     @GuardedBy("this")
     override suspend fun updateToken(token: String): Boolean = synchronized(this) {
-        val pushApi = api
+        var pushApi = api
         if (pushApi == null) {
             api = PushManager(
                 senderId = senderId,
@@ -177,7 +177,9 @@ internal class RustPushConnection(
                 registrationId = token,
                 databasePath = databasePath
             )
-            return true
+            pushApi = api!!
+            // This may be a new token, so we must tell the server about it even if this is the
+            // push being initialized for the first time in this process.
         }
         // This call will fail if we haven't 'subscribed' yet.
         return try {
@@ -185,8 +187,13 @@ internal class RustPushConnection(
         } catch (e: GeneralException) {
             val fakeChannelId = "fake".toChannelId()
             // It's possible that we have a race (on a first run) between 'subscribing' and setting a token.
+            // (Or even more likely is that we have no subscriptions, but are still trying to
+            // initialize this service with a new FCM token)
             // 'update' expects that we've called 'subscribe' (which would obtain a 'uaid' from an autopush
             // server), which we need to have in order to call 'update' on the library.
+            // Note also: this work-around means we are making 2 connections to the push server
+            // even when there are zero subscriptions actually desired, so it's wildly inefficient
+            // for the majority of users.
             // In https://github.com/mozilla/application-services/issues/2490 this will be fixed, and we
             // can clean up this work-around.
             pushApi.subscribe(fakeChannelId)
diff --git a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt
index 259ce8664a58..d8a3c4c156ec 100644
--- a/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt
+++ b/android-components/components/feature/push/src/test/java/mozilla/components/feature/push/AutoPushFeatureTest.kt
@@ -87,10 +87,11 @@ class AutoPushFeatureTest {
     fun `updateToken called if token is in prefs`() = runBlockingTest {
         preference(testContext).edit().putString(PREF_TOKEN, "token").apply()
 
-        AutoPushFeature(
+        val feature = AutoPushFeature(
             testContext, mock(), mock(), connection = connection,
             coroutineContext = coroutineContext
         )
+        feature.initialize()
 
         verify(connection).updateToken("token")
     }
@@ -122,18 +123,6 @@ class AutoPushFeatureTest {
         assertEquals("token", pref)
     }
 
-    @Test
-    fun `onNewToken updates subscriptions if token does not already exists`() = runBlockingTest {
-        val connection: PushConnection = spy(TestPushConnection(true))
-        val feature = spy(AutoPushFeature(testContext, mock(), mock(), coroutineContext, connection))
-
-        feature.onNewToken("token")
-        verify(feature, times(1)).subscribe(anyString(), nullable(String::class.java), any(), any())
-
-        feature.onNewToken("token")
-        verify(feature, times(1)).subscribe(anyString(), nullable(String::class.java), any(), any())
-    }
-
     @Test
     fun `onMessageReceived decrypts message and notifies observers`() = runBlockingTest {
         val encryptedMessage: EncryptedPushMessage = mock()
@@ -383,12 +372,16 @@ class AutoPushFeatureTest {
                 service = mock(),
                 config = mock(),
                 coroutineContext = coroutineContext,
-                connection = mock()
+                connection = mock(),
             )
         )
 
         lastVerified = System.currentTimeMillis() - VERIFY_NOW
 
+        // We want the feature to find a token so it initializes, as that must happen before verify.
+        val prefs = testContext.getSharedPreferences("mozac_feature_push", Context.MODE_PRIVATE)
+        prefs.edit().putString(PREF_TOKEN, "test-token").apply()
+
         feature.initialize()
 
         verify(feature).tryVerifySubscriptions()
@@ -408,32 +401,41 @@ class AutoPushFeatureTest {
 
         lastVerified = System.currentTimeMillis() - SKIP_INTERVAL
 
+        // We want the feature to find a token so it initializes, as that must happen before verify.
+        // For this test, we want the token check to succeed so the ratelimiting check
+        // must also work correctly.
+        val prefs = testContext.getSharedPreferences("mozac_feature_push", Context.MODE_PRIVATE)
+        prefs.edit().putString(PREF_TOKEN, "test-token").apply()
+
         feature.initialize()
 
         verify(feature, never()).verifyActiveSubscriptions()
     }
 
     @Test
-    fun `initialize does execute verifyActiveSubscription with rate-limiting disabled`() = runBlockingTest {
+    fun `new FCM token executes verifyActiveSubscription`() = runBlockingTest {
         val feature = spy(
             AutoPushFeature(
                 context = testContext,
                 service = mock(),
-                config = PushConfig(senderId = "push-test", disableRateLimit = true),
+                config = mock(),
                 coroutineContext = coroutineContext,
                 connection = mock()
             )
         )
 
-        lastVerified = System.currentTimeMillis() - SKIP_INTERVAL
-
+        lastVerified = 0
         feature.initialize()
+        // no token yet so should not have even tried.
+        verify(feature, never()).verifyActiveSubscriptions()
 
+        // new token == "check now"
+        feature.onNewToken("test-token")
         verify(feature).verifyActiveSubscriptions()
     }
 
     @Test
-    fun `verification always happens on first attempt`() = runBlockingTest {
+    fun `verification doesn't happen until we've got the token`() = runBlockingTest {
         val feature = spy(
             AutoPushFeature(
                 context = testContext,
@@ -446,7 +448,7 @@ class AutoPushFeatureTest {
 
         feature.initialize()
 
-        verify(feature).verifyActiveSubscriptions()
+        verify(feature, never()).verifyActiveSubscriptions()
     }
 
     @Test
