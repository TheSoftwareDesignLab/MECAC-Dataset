diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java b/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
new file mode 100644
index 000000000000..f1c74bf801af
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/BlocklistProcessor.java
@@ -0,0 +1,84 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+package org.mozilla.focus.webkit.matcher;
+
+import android.util.JsonReader;
+import android.util.JsonToken;
+
+import java.io.IOException;
+
+public class BlocklistProcessor {
+
+    final UrlMatcher matcher;
+
+    public BlocklistProcessor(final JsonReader reader, final UrlMatcher matcher) throws IOException {
+        this.matcher = matcher;
+
+        // TODO: refactor this class to match the EntityListProcessor example of a static method
+        // returning a Trie of blacklisted URLs.
+        reader.beginObject();
+
+        while (reader.hasNext()) {
+            JsonToken token = reader.peek();
+
+            final String name = reader.nextName();
+
+            if (name.equals("categories")) {
+                extractCategories(reader);
+            } else {
+                reader.skipValue();
+            }
+
+        }
+
+        reader.endObject();
+    }
+
+    private void extractCategories(final JsonReader reader) throws IOException {
+        reader.beginObject();
+
+        while (reader.hasNext()) {
+            final String categoryName = reader.nextName();
+
+            extractCategory(reader);
+        }
+
+        reader.endObject();
+    }
+
+    private void extractCategory(final JsonReader reader) throws IOException {
+        reader.beginArray();
+
+        while (reader.hasNext()) {
+            extractSite(reader);
+        }
+
+        reader.endArray();
+    }
+
+    private void extractSite(final JsonReader reader) throws IOException {
+        reader.beginObject();
+
+        final String siteName = reader.nextName();
+        {
+            reader.beginObject();
+            final String siteURL = reader.nextName();
+            {
+                reader.beginArray();
+
+                while (reader.hasNext()) {
+                    final String blockURL = reader.nextString();
+                    matcher.putURL(blockURL);
+                }
+
+                reader.endArray();
+            }
+
+            reader.endObject();
+        }
+
+        reader.endObject();
+    }
+}
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java b/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
new file mode 100644
index 000000000000..074d5878f07f
--- /dev/null
+++ b/focus-android/app/src/main/java/org/mozilla/focus/webkit/matcher/UrlMatcher.java
@@ -0,0 +1,100 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+package org.mozilla.focus.webkit.matcher;
+
+
+import android.content.Context;
+import android.util.JsonReader;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.HashSet;
+
+public class UrlMatcher {
+
+    private final Trie rootTrie = Trie.createRootNode();
+
+    private final EntityList entityList;
+    private final HashSet<String> previouslyMatched = new HashSet<>();
+    private final HashSet<String> previouslyUnmatched = new HashSet<>();
+
+    public UrlMatcher(final Context context, final int blockListFile, final int entityListFile) {
+        {
+            InputStream inputStream = context.getResources().openRawResource(blockListFile);
+            JsonReader jsonReader = new JsonReader(new InputStreamReader(inputStream));
+
+            try {
+                new BlocklistProcessor(jsonReader, this);
+
+                jsonReader.close();
+            } catch (IOException e) {
+                throw new IllegalStateException("Unable to parse blacklist");
+            }
+        }
+
+        {
+            InputStream inputStream = context.getResources().openRawResource(entityListFile);
+            JsonReader jsonReader = new JsonReader(new InputStreamReader(inputStream));
+
+            try {
+                entityList = EntityListProcessor.getEntityMapFromJSON(jsonReader);
+            } catch (IOException e) {
+                throw new IllegalStateException("Unable to parse entity list");
+            }
+
+        }
+    }
+
+
+    /* Test-only */
+    /* package-private */ UrlMatcher(final String[] patterns) {
+        buildMatcher(patterns);
+
+        entityList = null;
+    }
+
+    private void buildMatcher(String[] patterns) {
+        // TODO: metrics for load time?
+        for (final String pattern : patterns) {
+            rootTrie.put(pattern);
+        }
+    }
+
+    /* package-private */ void putURL(final String url) {
+        rootTrie.put(url);
+    }
+
+    public boolean matches(final String resourceURLString, final String pageURLString) {
+        // TODO: metrics for lookup time?
+
+        // Cached whitelisted items can be permitted now (but blacklisted needs to wait for the override / entity list)
+        if (previouslyUnmatched.contains(resourceURLString)) {
+            return false;
+        }
+
+
+        if (entityList != null &&
+                entityList.isWhiteListed(pageURLString, resourceURLString)) {
+            // We must not cache entityList items (abd/or if we did, we'd have to clear the cache
+            // on every single location change)
+            return false;
+        }
+
+        if (previouslyMatched.contains(resourceURLString)) {
+            return true;
+        }
+
+        for (int i = 0; i < resourceURLString.length() - 1; i++) {
+            if (rootTrie.findNode(resourceURLString.substring(i)) != null) {
+                previouslyMatched.add(resourceURLString);
+                return true;
+            }
+        }
+
+        previouslyUnmatched.add(resourceURLString);
+        return false;
+    }
+}
