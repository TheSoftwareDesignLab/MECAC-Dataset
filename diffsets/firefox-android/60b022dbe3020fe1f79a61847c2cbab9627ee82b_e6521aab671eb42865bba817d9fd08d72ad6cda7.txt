diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index 4544ac581217..c8a03c3ab507 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -269,6 +269,7 @@ projects:
     - ui-autocomplete
     - ui-colors
     - ui-icons
+    - ui-widgets
   compose-awesomebar:
     description: An awesomebar component showing search results matching text entered
       into the toolbar.
@@ -601,7 +602,9 @@ projects:
     path: components/feature/autofill
     publish: true
     upstream_dependencies:
+    - browser-errorpages
     - concept-base
+    - concept-engine
     - concept-fetch
     - concept-storage
     - lib-fetch-okhttp
@@ -756,6 +759,7 @@ projects:
     - ui-colors
     - ui-icons
     - ui-tabcounter
+    - ui-widgets
   feature-downloads:
     description: Feature implementation for apps that want to use Android downloads
       manager.
@@ -1029,6 +1033,7 @@ projects:
     - ui-colors
     - ui-icons
     - ui-tabcounter
+    - ui-widgets
   feature-qr:
     description: A feature that provides functionality for scanning QR codes.
     path: components/feature/qr
@@ -1863,6 +1868,7 @@ projects:
     - ui-colors
     - ui-icons
     - ui-tabcounter
+    - ui-widgets
   service-contile:
     description: A library to communicate with the Contile services API
     path: components/service/contile
@@ -2261,9 +2267,17 @@ projects:
     path: components/ui/widgets
     publish: true
     upstream_dependencies:
+    - browser-errorpages
     - concept-base
+    - concept-engine
+    - concept-fetch
+    - concept-storage
+    - lib-publicsuffixlist
     - support-base
+    - support-ktx
     - support-test
+    - support-test-fakes
+    - support-utils
     - tooling-lint
     - ui-colors
     - ui-icons
diff --git a/android-components/components/browser/toolbar/build.gradle b/android-components/components/browser/toolbar/build.gradle
index 449317e20bfa..d18b1ebd4895 100644
--- a/android-components/components/browser/toolbar/build.gradle
+++ b/android-components/components/browser/toolbar/build.gradle
@@ -33,6 +33,7 @@ dependencies {
     implementation project(':browser-menu2')
     implementation project(':ui-icons')
     implementation project(':ui-colors')
+    implementation project(':ui-widgets')
     implementation project(':support-ktx')
 
     implementation ComponentsDependencies.androidx_appcompat
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
index 488fdf628854..a993014590b6 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
@@ -25,7 +25,6 @@ import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.cancelChildren
 import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.browser.toolbar.edit.EditToolbar
 import mozilla.components.concept.toolbar.AutocompleteDelegate
@@ -38,6 +37,7 @@ import mozilla.components.support.ktx.kotlin.trimmed
 import mozilla.components.ui.autocomplete.AutocompleteView
 import mozilla.components.ui.autocomplete.InlineAutocompleteEditText
 import mozilla.components.ui.autocomplete.OnFilterListener
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
 import kotlin.coroutines.CoroutineContext
 
 internal fun ImageView.setTintResource(@ColorRes tintColorResource: Int) {
@@ -387,26 +387,26 @@ class BrowserToolbar @JvmOverloads constructor(
     override fun enableScrolling() {
         // Behavior can be changed without us knowing. Not safe to use a memoized value.
         (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.enableScrolling()
+            (behavior as? EngineViewScrollingBehavior)?.enableScrolling()
         }
     }
 
     override fun disableScrolling() {
         // Behavior can be changed without us knowing. Not safe to use a memoized value.
         (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.disableScrolling()
+            (behavior as? EngineViewScrollingBehavior)?.disableScrolling()
         }
     }
 
     override fun expand() {
         (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.forceExpand(this@BrowserToolbar)
+            (behavior as? EngineViewScrollingBehavior)?.forceExpand(this@BrowserToolbar)
         }
     }
 
     override fun collapse() {
         (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.forceCollapse(this@BrowserToolbar)
+            (behavior as? EngineViewScrollingBehavior)?.forceCollapse(this@BrowserToolbar)
         }
     }
 
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt
deleted file mode 100644
index adea7a54d2a2..000000000000
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategy.kt
+++ /dev/null
@@ -1,189 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.toolbar.behavior
-
-import android.animation.ValueAnimator
-import android.view.animation.DecelerateInterpolator
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.toolbar.BrowserToolbar
-import kotlin.math.max
-import kotlin.math.min
-
-@VisibleForTesting
-internal const val SNAP_ANIMATION_DURATION = 150L
-
-/**
- * Helper class with methods for different behaviors for when translating a [BottomToolbar] on the Y axis.
- */
-internal abstract class BrowserToolbarYTranslationStrategy {
-    @VisibleForTesting
-    var animator = ValueAnimator().apply {
-        interpolator = DecelerateInterpolator()
-        duration = SNAP_ANIMATION_DURATION
-    }
-
-    /**
-     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer
-     * over a short amount of time.
-     */
-    abstract fun snapWithAnimation(toolbar: BrowserToolbar)
-
-    /**
-     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer immediately.
-     */
-    abstract fun snapImmediately(toolbar: BrowserToolbar?)
-
-    /**
-     * Translate the [BrowserToolbar] to it's full visible height.
-     */
-    abstract fun expandWithAnimation(toolbar: BrowserToolbar)
-
-    /**
-     * Force expanding the [BrowserToolbar] depending on the [distance] value that should be translated
-     * cancelling any other translation already in progress.
-     */
-    abstract fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float)
-
-    /**
-     * Translate the [BrowserToolbar] to it's full 0 visible height.
-     */
-    abstract fun collapseWithAnimation(toolbar: BrowserToolbar)
-
-    /**
-     * Translate [toolbar] immediately to the specified [distance] amount (positive or negative).
-     */
-    abstract fun translate(toolbar: BrowserToolbar, distance: Float)
-
-    /**
-     * Translate [toolbar] to the indicated [targetTranslationY] vaue over a short amount of time.
-     */
-    open fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) = with(animator) {
-        addUpdateListener { toolbar.translationY = it.animatedValue as Float }
-        setFloatValues(toolbar.translationY, targetTranslationY)
-        start()
-    }
-
-    /**
-     * Cancel any translation animations currently in progress.
-     */
-    fun cancelInProgressTranslation() = animator.cancel()
-}
-
-/**
- * Helper class containing methods for translating a [BrowserToolbar] on the Y axis
- * between 0 and [BrowserToolbar.getHeight]
- */
-internal class BottomToolbarBehaviorStrategy : BrowserToolbarYTranslationStrategy() {
-    @VisibleForTesting
-    internal var wasLastExpanding = false
-
-    override fun snapWithAnimation(toolbar: BrowserToolbar) {
-        if (toolbar.translationY >= (toolbar.height / 2f)) {
-            collapseWithAnimation(toolbar)
-        } else {
-            expandWithAnimation(toolbar)
-        }
-    }
-
-    override fun snapImmediately(toolbar: BrowserToolbar?) {
-        if (animator.isStarted) {
-            animator.end()
-        } else {
-            toolbar?.apply {
-                translationY = if (translationY >= height / 2) {
-                    height.toFloat()
-                } else {
-                    0f
-                }
-            }
-        }
-    }
-
-    override fun expandWithAnimation(toolbar: BrowserToolbar) {
-        animateToTranslationY(toolbar, 0f)
-    }
-
-    override fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float) {
-        val shouldExpandToolbar = distance < 0
-        val isToolbarExpanded = toolbar.translationY == 0f
-        if (shouldExpandToolbar && !isToolbarExpanded && !wasLastExpanding) {
-            animator.cancel()
-            expandWithAnimation(toolbar)
-        }
-    }
-
-    override fun collapseWithAnimation(toolbar: BrowserToolbar) {
-        animateToTranslationY(toolbar, toolbar.height.toFloat())
-    }
-
-    override fun translate(toolbar: BrowserToolbar, distance: Float) {
-        toolbar.translationY =
-            max(0f, min(toolbar.height.toFloat(), toolbar.translationY + distance))
-    }
-
-    override fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) {
-        wasLastExpanding = targetTranslationY <= toolbar.translationY
-        super.animateToTranslationY(toolbar, targetTranslationY)
-    }
-}
-
-/**
- * Helper class containing methods for translating a [BrowserToolbar] on the Y axis
- * between -[BrowserToolbar.getHeight] and 0.
- */
-internal class TopToolbarBehaviorStrategy : BrowserToolbarYTranslationStrategy() {
-    @VisibleForTesting
-    internal var wasLastExpanding = false
-
-    override fun snapWithAnimation(toolbar: BrowserToolbar) {
-        if (toolbar.translationY >= -(toolbar.height / 2f)) {
-            expandWithAnimation(toolbar)
-        } else {
-            collapseWithAnimation(toolbar)
-        }
-    }
-
-    override fun snapImmediately(toolbar: BrowserToolbar?) {
-        if (animator.isStarted) {
-            animator.end()
-        } else {
-            toolbar?.apply {
-                translationY = if (translationY >= -height / 2) {
-                    0f
-                } else {
-                    -height.toFloat()
-                }
-            }
-        }
-    }
-
-    override fun expandWithAnimation(toolbar: BrowserToolbar) {
-        animateToTranslationY(toolbar, 0f)
-    }
-
-    override fun forceExpandWithAnimation(toolbar: BrowserToolbar, distance: Float) {
-        val isExpandingInProgress = animator.isStarted && wasLastExpanding
-        val shouldExpandToolbar = distance < 0
-        val isToolbarExpanded = toolbar.translationY == 0f
-        if (shouldExpandToolbar && !isToolbarExpanded && !isExpandingInProgress) {
-            animator.cancel()
-            expandWithAnimation(toolbar)
-        }
-    }
-
-    override fun collapseWithAnimation(toolbar: BrowserToolbar) {
-        animateToTranslationY(toolbar, -toolbar.height.toFloat())
-    }
-
-    override fun translate(toolbar: BrowserToolbar, distance: Float) {
-        toolbar.translationY =
-            min(0f, max(-toolbar.height.toFloat(), toolbar.translationY - distance))
-    }
-
-    override fun animateToTranslationY(toolbar: BrowserToolbar, targetTranslationY: Float) {
-        wasLastExpanding = targetTranslationY >= toolbar.translationY
-        super.animateToTranslationY(toolbar, targetTranslationY)
-    }
-}
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt
deleted file mode 100644
index 70db1d93cf4e..000000000000
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslator.kt
+++ /dev/null
@@ -1,81 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.toolbar.behavior
-
-import androidx.annotation.VisibleForTesting
-import mozilla.components.browser.toolbar.BrowserToolbar
-
-/**
- * Helper class with methods for translating on the Y axis a top / bottom [BottomToolbar].
- *
- * @param toolbarPosition whether the toolbar is displayed immediately at the top of the screen or
- * immediately at the bottom. This affects how it will be translated:
- *   - if place at the bottom it will be Y translated between 0 and [BrowserToolbar.getHeight]
- *   - if place at the top it will be Y translated between -[BrowserToolbar.getHeight] and 0
- */
-class BrowserToolbarYTranslator(toolbarPosition: ToolbarPosition) {
-    @VisibleForTesting
-    internal var strategy = getTranslationStrategy(toolbarPosition)
-
-    /**
-     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer
-     * over a short amount of time.
-     */
-    internal fun snapWithAnimation(toolbar: BrowserToolbar) {
-        strategy.snapWithAnimation(toolbar)
-    }
-
-    /**
-     * Snap the [BrowserToolbar] to be collapsed or expanded, depending on whatever state is closer immediately.
-     */
-    fun snapImmediately(toolbar: BrowserToolbar?) {
-        strategy.snapImmediately(toolbar)
-    }
-
-    /**
-     * Translate the [BrowserToolbar] to it's full visible height over a short amount of time.
-     */
-    internal fun expandWithAnimation(toolbar: BrowserToolbar) {
-        strategy.expandWithAnimation(toolbar)
-    }
-
-    /**
-     * Translate the [BrowserToolbar] to be hidden from view over a short amount of time.
-     */
-    internal fun collapseWithAnimation(toolbar: BrowserToolbar) {
-        strategy.collapseWithAnimation(toolbar)
-    }
-
-    /**
-     * Force expanding the [BrowserToolbar] depending on the [distance] value that should be translated
-     * cancelling any other translation already in progress.
-     */
-    fun forceExpandIfNotAlready(toolbar: BrowserToolbar, distance: Float) {
-        strategy.forceExpandWithAnimation(toolbar, distance)
-    }
-
-    /**
-     * Translate [toolbar] immediately to the specified [distance] amount (positive or negative).
-     */
-    fun translate(toolbar: BrowserToolbar, distance: Float) {
-        strategy.translate(toolbar, distance)
-    }
-
-    /**
-     * Cancel any translation animations currently in progress.
-     */
-    fun cancelInProgressTranslation() {
-        strategy.cancelInProgressTranslation()
-    }
-
-    @VisibleForTesting
-    internal fun getTranslationStrategy(toolbarPosition: ToolbarPosition): BrowserToolbarYTranslationStrategy {
-        return if (toolbarPosition == ToolbarPosition.TOP) {
-            TopToolbarBehaviorStrategy()
-        } else {
-            BottomToolbarBehaviorStrategy()
-        }
-    }
-}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
index 33b7352a1728..9f69e5b40237 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
@@ -17,8 +17,6 @@ import androidx.core.view.inputmethod.EditorInfoCompat
 import androidx.core.view.isGone
 import androidx.core.view.isVisible
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
-import mozilla.components.browser.toolbar.behavior.ToolbarPosition
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.browser.toolbar.display.DisplayToolbarViews
 import mozilla.components.browser.toolbar.display.MenuButton
@@ -32,6 +30,8 @@ import mozilla.components.support.test.argumentCaptor
 import mozilla.components.support.test.mock
 import mozilla.components.support.test.robolectric.testContext
 import mozilla.components.support.test.whenever
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
+import mozilla.components.ui.widgets.behavior.ViewPosition
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNotEquals
@@ -911,7 +911,7 @@ class BrowserToolbarTest {
     fun `enable scrolling is forwarded to the toolbar behavior`() {
         // Seems like real instances are needed for things to be set properly
         val toolbar = BrowserToolbar(testContext)
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val params = CoordinatorLayout.LayoutParams(10, 10).apply {
             this.behavior = behavior
         }
@@ -926,7 +926,7 @@ class BrowserToolbarTest {
     fun `disable scrolling is forwarded to the toolbar behavior`() {
         // Seems like real instances are needed for things to be set properly
         val toolbar = BrowserToolbar(testContext)
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val params = CoordinatorLayout.LayoutParams(10, 10).apply {
             this.behavior = behavior
         }
@@ -941,7 +941,7 @@ class BrowserToolbarTest {
     fun `expand is forwarded to the toolbar behavior`() {
         // Seems like real instances are needed for things to be set properly
         val toolbar = BrowserToolbar(testContext)
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val params = CoordinatorLayout.LayoutParams(10, 10).apply {
             this.behavior = behavior
         }
@@ -956,7 +956,7 @@ class BrowserToolbarTest {
     fun `collapse is forwarded to the toolbar behavior`() {
         // Seems like real instances are needed for things to be set properly
         val toolbar = BrowserToolbar(testContext)
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val params = CoordinatorLayout.LayoutParams(10, 10).apply {
             this.behavior = behavior
         }
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt
deleted file mode 100644
index fa6cc43c1cec..000000000000
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslationStrategyTest.kt
+++ /dev/null
@@ -1,712 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.toolbar.behavior
-
-import android.animation.ValueAnimator
-import android.view.animation.DecelerateInterpolator
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.support.test.any
-import mozilla.components.support.test.mock
-import mozilla.components.support.test.robolectric.testContext
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.doReturn
-import org.mockito.Mockito.never
-import org.mockito.Mockito.spy
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-
-@RunWith(AndroidJUnit4::class)
-class BrowserToolbarYTranslationStrategyTest {
-    @Test
-    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for bottom toolbar translations`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-
-        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
-        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
-    }
-
-    @Test
-    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for top toolbar translations`() {
-        val strategy = TopToolbarBehaviorStrategy()
-
-        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
-        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-
-        assertFalse(strategy.wasLastExpanding)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
-        val strategy = TopToolbarBehaviorStrategy()
-
-        assertFalse(strategy.wasLastExpanding)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(50f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(51f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(100f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(333f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        verify(strategy, times(4)).collapseWithAnimation(toolbar)
-        verify(strategy, never()).expandWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(49f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(0f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(-50f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        verify(strategy, times(3)).expandWithAnimation(toolbar)
-        verify(strategy, never()).collapseWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-51f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(-100f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(-333f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        verify(strategy, times(3)).collapseWithAnimation(toolbar)
-        verify(strategy, never()).expandWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-50f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(-49f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(0f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        doReturn(50f).`when`(toolbar).translationY
-        strategy.snapWithAnimation(toolbar)
-
-        verify(strategy, times(4)).expandWithAnimation(toolbar)
-        verify(strategy, never()).collapseWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(true).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-
-        strategy.snapImmediately(toolbar)
-
-        verify(animator).end()
-        verify(toolbar, never()).translationY
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if half translated`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(50f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(55f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if translated off screen`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(555f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated less than half`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(49f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(0f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-1f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(true).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-
-        strategy.snapImmediately(toolbar)
-
-        verify(animator).end()
-        verify(toolbar, never()).translationY
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate translate to 0 the toolbar if translated less than half`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-49f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(0f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(1f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if half translated`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-50f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half translated`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-55f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = -100f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated offscreen`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        doReturn(-111f).`when`(toolbar).translationY
-        strategy.snapImmediately(toolbar)
-        verify(toolbar).translationY = -100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-
-        strategy.expandWithAnimation(toolbar)
-
-        verify(strategy).animateToTranslationY(toolbar, 0f)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-
-        strategy.expandWithAnimation(toolbar)
-
-        verify(strategy).animateToTranslationY(toolbar, 0f)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
-        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
-        // Below this test we can change each variable one at a time to test them in isolation.
-
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator).cancel()
-        verify(strategy).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = true
-        val animator: ValueAnimator = mock()
-        doReturn(true).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes down`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, 100f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(0f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
-        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
-        // Below this test we can change each variable one at a time to test them in isolation.
-
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(-100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator).cancel()
-        verify(strategy).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = true
-        val animator: ValueAnimator = mock()
-        doReturn(true).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(-100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes up`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(-100f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, 10f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val animator: ValueAnimator = mock()
-        doReturn(false).`when`(animator).isStarted
-        strategy.animator = animator
-        val toolbar: BrowserToolbar = mock()
-        doReturn(0f).`when`(toolbar).translationY
-
-        strategy.forceExpandWithAnimation(toolbar, -100f)
-
-        verify(strategy.animator, never()).cancel()
-        verify(strategy, never()).expandWithAnimation(any())
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar down, off-screen`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        strategy.collapseWithAnimation(toolbar)
-
-        verify(strategy).animateToTranslationY(toolbar, 100f)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar up, off-screen`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-
-        strategy.collapseWithAnimation(toolbar)
-
-        verify(strategy).animateToTranslationY(toolbar, -100f)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, -25f)
-
-        verify(toolbar).translationY = 25f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 25f)
-
-        verify(toolbar).translationY = 75f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar if already expanded`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(0f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, -1f)
-
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar more than to 0`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, -51f)
-
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar if already collapsed`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(100f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 1f)
-
-        verify(toolbar).translationY = 100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar more than it's height`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 51f)
-
-        verify(toolbar).translationY = 100f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(-50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 25f)
-
-        verify(toolbar).translationY = -75f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(-50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 25f)
-
-        verify(toolbar).translationY = -75f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar if already expanded`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(0f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, -1f)
-
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar more than to 0`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(-50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, -51f)
-
-        verify(toolbar).translationY = 0f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar if already collapsed`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(-100f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 1f)
-
-        verify(toolbar).translationY = -100f
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar more than it's height`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        val toolbar: BrowserToolbar = mock()
-        doReturn(100).`when`(toolbar).height
-        doReturn(-50f).`when`(toolbar).translationY
-
-        strategy.translate(toolbar, 51f)
-
-        verify(toolbar).translationY = -100f
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
-        val strategy = BottomToolbarBehaviorStrategy()
-        strategy.wasLastExpanding = false
-        val toolbar: BrowserToolbar = mock()
-        doReturn(50f).`when`(toolbar).translationY
-
-        strategy.animateToTranslationY(toolbar, 10f)
-        assertTrue(strategy.wasLastExpanding)
-
-        strategy.animateToTranslationY(toolbar, 60f)
-        assertFalse(strategy.wasLastExpanding)
-    }
-
-    @Test
-    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
-        val strategy = spy(BottomToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val toolbar: BrowserToolbar = BrowserToolbar(testContext)
-        val animator: ValueAnimator = spy(strategy.animator)
-        strategy.animator = animator
-
-        strategy.animateToTranslationY(toolbar, 10f)
-
-        verify(animator).start()
-        animator.end()
-        assertEquals(10f, toolbar.translationY)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
-        val strategy = TopToolbarBehaviorStrategy()
-        strategy.wasLastExpanding = false
-        val toolbar: BrowserToolbar = mock()
-        doReturn(-50f).`when`(toolbar).translationY
-
-        strategy.animateToTranslationY(toolbar, -10f)
-        assertTrue(strategy.wasLastExpanding)
-
-        strategy.animateToTranslationY(toolbar, -60f)
-        assertFalse(strategy.wasLastExpanding)
-    }
-
-    @Test
-    fun `TopToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
-        val strategy = spy(TopToolbarBehaviorStrategy())
-        strategy.wasLastExpanding = false
-        val toolbar: BrowserToolbar = BrowserToolbar(testContext)
-        val animator: ValueAnimator = spy(strategy.animator)
-        strategy.animator = animator
-
-        strategy.animateToTranslationY(toolbar, -10f)
-
-        verify(animator).start()
-        animator.end()
-        assertEquals(-10f, toolbar.translationY)
-    }
-}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt
deleted file mode 100644
index eeca64c7e73a..000000000000
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarYTranslatorTest.kt
+++ /dev/null
@@ -1,113 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.toolbar.behavior
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.support.test.mock
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.verify
-
-@RunWith(AndroidJUnit4::class)
-class BrowserToolbarYTranslatorTest {
-    @Test
-    fun `yTranslator should use BottomToolbarBehaviorStrategy for bottom placed toolbars`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-
-        assertTrue(yTranslator.strategy is BottomToolbarBehaviorStrategy)
-    }
-
-    @Test
-    fun `yTranslator should use TopToolbarBehaviorStrategy for top placed toolbars`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.TOP)
-
-        assertTrue(yTranslator.strategy is TopToolbarBehaviorStrategy)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for snapWithAnimation`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.snapWithAnimation(toolbar)
-
-        verify(strategy).snapWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for expandWithAnimation`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.expandWithAnimation(toolbar)
-
-        verify(strategy).expandWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for collapseWithAnimation`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.collapseWithAnimation(toolbar)
-
-        verify(strategy).collapseWithAnimation(toolbar)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for forceExpandIfNotAlready`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.forceExpandIfNotAlready(toolbar, 14f)
-
-        verify(strategy).forceExpandWithAnimation(toolbar, 14f)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for translate`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.translate(toolbar, 23f)
-
-        verify(strategy).translate(toolbar, 23f)
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for cancelInProgressTranslation`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-
-        yTranslator.cancelInProgressTranslation()
-
-        verify(strategy).cancelInProgressTranslation()
-    }
-
-    @Test
-    fun `yTranslator should delegate it's strategy for snapImmediately`() {
-        val yTranslator = BrowserToolbarYTranslator(ToolbarPosition.BOTTOM)
-        val strategy: BrowserToolbarYTranslationStrategy = mock()
-        yTranslator.strategy = strategy
-        val toolbar: BrowserToolbar = mock()
-
-        yTranslator.snapImmediately(toolbar)
-
-        verify(strategy).snapImmediately(toolbar)
-    }
-}
diff --git a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/ScrollableToolbar.kt b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/ScrollableToolbar.kt
new file mode 100644
index 000000000000..86af351c26e2
--- /dev/null
+++ b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/ScrollableToolbar.kt
@@ -0,0 +1,34 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.concept.toolbar
+
+/**
+ * Interface to be implemented by components that provide hiding-on-scroll toolbar functionality.
+ */
+interface ScrollableToolbar {
+
+    /**
+     * Enable scrolling of the dynamic toolbar. Restore this functionality after [disableScrolling] stopped it.
+     *
+     * The toolbar may have other intrinsic checks depending on which the toolbar will be animated or not.
+     */
+    fun enableScrolling()
+
+    /**
+     * Completely disable scrolling of the dynamic toolbar.
+     * Use [enableScrolling] to restore the functionality.
+     */
+    fun disableScrolling()
+
+    /**
+     * Force the toolbar to expand.
+     */
+    fun expand()
+
+    /**
+     * Force the toolbar to collapse. Only if dynamic.
+     */
+    fun collapse()
+}
diff --git a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
index 16c0e7c6655f..398acca62d72 100644
--- a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
+++ b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
@@ -26,7 +26,7 @@ import java.lang.ref.WeakReference
  * Interface to be implemented by components that provide browser toolbar functionality.
  */
 @Suppress("TooManyFunctions")
-interface Toolbar {
+interface Toolbar : ScrollableToolbar {
     /**
      * Sets/Gets the title to be displayed on the toolbar.
      */
@@ -211,29 +211,6 @@ interface Toolbar {
      */
     fun dismissMenu()
 
-    /**
-     * Enable scrolling of the dynamic toolbar. Restore this functionality after [disableScrolling] stopped it.
-     *
-     * The toolbar may have other intrinsic checks depending on which the toolbar will be animated or not.
-     */
-    fun enableScrolling()
-
-    /**
-     * Completely disable scrolling of the dynamic toolbar.
-     * Use [enableScrolling] to restore the functionality.
-     */
-    fun disableScrolling()
-
-    /**
-     * Force the toolbar to expand.
-     */
-    fun expand()
-
-    /**
-     * Force the toolbar to collapse. Only if dynamic.
-     */
-    fun collapse()
-
     /**
      * Listener to be invoked when the user edits the URL.
      */
diff --git a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt
index 4fbc4333547c..7928f1ac64ce 100644
--- a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt
+++ b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt
@@ -12,17 +12,17 @@ import kotlinx.coroutines.flow.mapNotNull
 import mozilla.components.browser.state.action.ContentAction
 import mozilla.components.browser.state.selector.findCustomTabOrSelectedTab
 import mozilla.components.browser.state.store.BrowserStore
-import mozilla.components.concept.toolbar.Toolbar
+import mozilla.components.concept.toolbar.ScrollableToolbar
 import mozilla.components.lib.state.ext.flowScoped
 
 /**
- * Controls how the dynamic toolbar should behave based on the current tab state.
+ * Controls how a dynamic toolbar should behave based on the current tab state.
  *
  * Responsible to enforce the following:
  * - toolbar should not be scrollable if the page has not finished loading
  */
 class ToolbarBehaviorController(
-    private val toolbar: Toolbar,
+    private val toolbar: ScrollableToolbar,
     private val store: BrowserStore,
     private val customTabId: String? = null,
 ) {
diff --git a/android-components/components/ui/widgets/build.gradle b/android-components/components/ui/widgets/build.gradle
index 4a16d26c758c..bc0d98e0e975 100644
--- a/android-components/components/ui/widgets/build.gradle
+++ b/android-components/components/ui/widgets/build.gradle
@@ -25,8 +25,11 @@ android {
 }
 
 dependencies {
+    implementation project(':concept-base')
+    implementation project(':concept-engine')
     implementation project(':ui-colors')
     implementation project(':ui-icons')
+    implementation project(':support-ktx')
 
     implementation ComponentsDependencies.androidx_appcompat
     implementation ComponentsDependencies.androidx_constraintlayout
@@ -35,6 +38,7 @@ dependencies {
     implementation ComponentsDependencies.androidx_swiperefreshlayout
 
     testImplementation project(":support-test")
+    testImplementation project(':support-test-fakes')
 
     testImplementation ComponentsDependencies.androidx_test_junit
     testImplementation ComponentsDependencies.testing_robolectric
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetector.kt
similarity index 99%
rename from android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
rename to android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetector.kt
index 038e5ed6e5f3..b15df650780a 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetector.kt
+++ b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetector.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.browser.toolbar.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.content.Context
 import android.view.GestureDetector
diff --git a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehavior.kt
similarity index 96%
rename from android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt
rename to android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehavior.kt
index d50b65589bd6..7ffe1166c555 100644
--- a/android-components/components/feature/session/src/main/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehavior.kt
+++ b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehavior.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.feature.session.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.annotation.SuppressLint
 import android.content.Context
@@ -27,7 +27,7 @@ import kotlin.math.roundToInt
  * @param toolbarHeight size of [BrowserToolbar] when it is placed above the [EngineView]
  * @param whether the [BrowserToolbar] is placed above or below the [EngineView]
  */
-class EngineViewBrowserToolbarBehavior(
+class EngineViewClippingBehavior(
     context: Context?,
     attrs: AttributeSet?,
     engineViewParent: View,
@@ -76,7 +76,7 @@ class EngineViewBrowserToolbarBehavior(
     }
 
     /**
-     * Apply vertical clipping to [EngineView]. This requires [EngineViewBrowserToolbarBehavior] to be set
+     * Apply vertical clipping to [EngineView]. This requires [EngineViewClippingBehavior] to be set
      * in/on the [EngineView] or its parent. Must be a direct descending child of [CoordinatorLayout].
      */
     override fun onDependentViewChanged(parent: CoordinatorLayout, child: View, dependency: View): Boolean {
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehavior.kt
similarity index 70%
rename from android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
rename to android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehavior.kt
index b79c448eeffa..08da7e5064c0 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
+++ b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehavior.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.browser.toolbar.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.content.Context
 import android.util.AttributeSet
@@ -11,35 +11,34 @@ import android.view.View
 import androidx.annotation.VisibleForTesting
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
-import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.base.crash.CrashReporting
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.support.ktx.android.view.findViewInHierarchy
 
 /**
- * Where the toolbar is placed on the screen.
+ * Where the view is placed on the screen.
  */
-enum class ToolbarPosition {
+enum class ViewPosition {
     TOP,
     BOTTOM,
 }
 
 /**
- * A [CoordinatorLayout.Behavior] implementation to be used when placing [BrowserToolbar] at the bottom of the screen.
+ * A [CoordinatorLayout.Behavior] implementation to be used when placing [View] at the bottom of the screen.
  *
- * This is safe to use even if the [BrowserToolbar] may be added / removed from a parent layout later
+ * This is safe to use even if the [View] may be added / removed from a parent layout later
  * or if it could have Visibility.GONE set.
  *
  * This implementation will:
- * - Show/Hide the [BrowserToolbar] automatically when scrolling vertically.
- * - Snap the [BrowserToolbar] to be hidden or visible when the user stops scrolling.
+ * - Show/Hide the [View] automatically when scrolling vertically.
+ * - Snap the [View] to be hidden or visible when the user stops scrolling.
  */
-class BrowserToolbarBehavior(
+class EngineViewScrollingBehavior(
     val context: Context?,
     attrs: AttributeSet?,
-    private val toolbarPosition: ToolbarPosition,
+    private val viewPosition: ViewPosition,
     private val crashReporting: CrashReporting? = null,
-) : CoordinatorLayout.Behavior<BrowserToolbar>(context, attrs) {
+) : CoordinatorLayout.Behavior<View>(context, attrs) {
     // This implementation is heavily based on this blog article:
     // https://android.jlelse.eu/scroll-your-bottom-navigation-view-away-with-10-lines-of-code-346f1ed40e9e
 
@@ -59,10 +58,10 @@ class BrowserToolbarBehavior(
     internal var engineView: EngineView? = null
 
     /**
-     * Reference to the actual [BrowserToolbar] that we'll animate.
+     * Reference to the actual [View] that we'll animate.
      */
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-    internal var browserToolbar: BrowserToolbar? = null
+    internal var dynamicScrollView: View? = null
 
     /**
      * Depending on how user's touch was consumed by EngineView / current website,
@@ -84,19 +83,19 @@ class BrowserToolbarBehavior(
     internal var gesturesDetector: BrowserGestureDetector = createGestureDetector()
 
     @VisibleForTesting
-    internal var yTranslator: BrowserToolbarYTranslator = createYTranslationStragy()
+    internal var yTranslator: ViewYTranslator = createYTranslationStrategy()
 
-    private fun createYTranslationStragy() = BrowserToolbarYTranslator(toolbarPosition)
+    private fun createYTranslationStrategy() = ViewYTranslator(viewPosition)
 
     override fun onStartNestedScroll(
         coordinatorLayout: CoordinatorLayout,
-        child: BrowserToolbar,
+        child: View,
         directTargetChild: View,
         target: View,
         axes: Int,
         type: Int,
     ): Boolean {
-        return if (browserToolbar != null) {
+        return if (dynamicScrollView != null) {
             startNestedScroll(axes, type, child)
         } else {
             return false // not interested in subsequent scroll events
@@ -105,21 +104,21 @@ class BrowserToolbarBehavior(
 
     override fun onStopNestedScroll(
         coordinatorLayout: CoordinatorLayout,
-        child: BrowserToolbar,
+        child: View,
         target: View,
         type: Int,
     ) {
-        if (browserToolbar != null) {
+        if (dynamicScrollView != null) {
             stopNestedScroll(type, child)
         }
     }
 
     override fun onInterceptTouchEvent(
         parent: CoordinatorLayout,
-        child: BrowserToolbar,
+        child: View,
         ev: MotionEvent,
     ): Boolean {
-        if (browserToolbar != null) {
+        if (dynamicScrollView != null) {
             gesturesDetector.handleTouchEvent(ev)
         }
         return false // allow events to be passed to below listeners
@@ -127,31 +126,31 @@ class BrowserToolbarBehavior(
 
     override fun onLayoutChild(
         parent: CoordinatorLayout,
-        child: BrowserToolbar,
+        child: View,
         layoutDirection: Int,
     ): Boolean {
-        browserToolbar = child
+        dynamicScrollView = child
         engineView = parent.findViewInHierarchy { it is EngineView } as? EngineView
 
         return super.onLayoutChild(parent, child, layoutDirection)
     }
 
     /**
-     * Used to expand the [BrowserToolbar]
+     * Used to expand the [View]
      */
-    fun forceExpand(toolbar: BrowserToolbar) {
-        yTranslator.expandWithAnimation(toolbar)
+    fun forceExpand(view: View) {
+        yTranslator.expandWithAnimation(view)
     }
 
     /**
-     * Used to collapse the [BrowserToolbar]
+     * Used to collapse the [View]
      */
-    fun forceCollapse(toolbar: BrowserToolbar) {
-        yTranslator.collapseWithAnimation(toolbar)
+    fun forceCollapse(view: View) {
+        yTranslator.collapseWithAnimation(view)
     }
 
     /**
-     * Allow this toolbar can be animated.
+     * Allow this view to be animated.
      *
      * @see disableScrolling
      */
@@ -160,7 +159,7 @@ class BrowserToolbarBehavior(
     }
 
     /**
-     * Disable scrolling this toolbar irrespective of the intrinsic checks.
+     * Disable scrolling of the view irrespective of the intrinsic checks.
      *
      * @see enableScrolling
      */
@@ -170,15 +169,15 @@ class BrowserToolbarBehavior(
 
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal fun tryToScrollVertically(distance: Float) {
-        browserToolbar?.let { toolbar ->
+        dynamicScrollView?.let { view ->
             if (shouldScroll && startedScroll) {
-                yTranslator.translate(toolbar, distance)
+                yTranslator.translate(view, distance)
             } else if (engineView?.getInputResultDetail()?.isTouchHandlingUnknown() == false) {
-                // Force expand the toolbar if the user scrolled up, it is not already expanded and
+                // Force expand the view if the user scrolled up, it is not already expanded and
                 // an animation to expand it is not already in progress,
-                // otherwise the user could get stuck in a state where they cannot show the toolbar
+                // otherwise the user could get stuck in a state where they cannot show the view
                 // See https://github.com/mozilla-mobile/android-components/issues/7101
-                yTranslator.forceExpandIfNotAlready(toolbar, distance)
+                yTranslator.forceExpandIfNotAlready(view, distance)
             }
         }
     }
@@ -202,26 +201,26 @@ class BrowserToolbarBehavior(
             BrowserGestureDetector.GesturesListener(
                 onVerticalScroll = ::tryToScrollVertically,
                 onScaleBegin = {
-                    // Scale shouldn't animate the toolbar but a small y translation is still possible
+                    // Scale shouldn't animate the view but a small y translation is still possible
                     // because of a previous scroll. Try to be swift about such an in progress animation.
-                    yTranslator.snapImmediately(browserToolbar)
+                    yTranslator.snapImmediately(dynamicScrollView)
                 },
             ),
             crashReporting = crashReporting,
         )
 
     @VisibleForTesting
-    internal fun startNestedScroll(axes: Int, type: Int, toolbar: BrowserToolbar): Boolean {
+    internal fun startNestedScroll(axes: Int, type: Int, view: View): Boolean {
         return if (shouldScroll && axes == ViewCompat.SCROLL_AXIS_VERTICAL) {
             startedScroll = true
             shouldSnapAfterScroll = type == ViewCompat.TYPE_TOUCH
             yTranslator.cancelInProgressTranslation()
             true
         } else if (engineView?.getInputResultDetail()?.isTouchUnhandled() == true) {
-            // Force expand the toolbar if event is unhandled, otherwise user could get stuck in a
-            // state where they cannot show the toolbar
+            // Force expand the view if event is unhandled, otherwise user could get stuck in a
+            // state where they cannot show the view
             yTranslator.cancelInProgressTranslation()
-            yTranslator.expandWithAnimation(toolbar)
+            yTranslator.expandWithAnimation(view)
             false
         } else {
             false
@@ -229,10 +228,10 @@ class BrowserToolbarBehavior(
     }
 
     @VisibleForTesting
-    internal fun stopNestedScroll(type: Int, toolbar: BrowserToolbar) {
+    internal fun stopNestedScroll(type: Int, view: View) {
         startedScroll = false
         if (shouldSnapAfterScroll || type == ViewCompat.TYPE_NON_TOUCH) {
-            yTranslator.snapWithAnimation(toolbar)
+            yTranslator.snapWithAnimation(view)
         }
     }
 }
diff --git a/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategy.kt b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategy.kt
new file mode 100644
index 000000000000..8311f2d21a0c
--- /dev/null
+++ b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategy.kt
@@ -0,0 +1,189 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.widgets.behavior
+
+import android.animation.ValueAnimator
+import android.view.View
+import android.view.animation.DecelerateInterpolator
+import androidx.annotation.VisibleForTesting
+import kotlin.math.max
+import kotlin.math.min
+
+@VisibleForTesting
+internal const val SNAP_ANIMATION_DURATION = 150L
+
+/**
+ * Helper class with methods for different behaviors for when translating a [View] on the Y axis.
+ */
+internal abstract class ViewYTranslationStrategy {
+    @VisibleForTesting
+    var animator = ValueAnimator().apply {
+        interpolator = DecelerateInterpolator()
+        duration = SNAP_ANIMATION_DURATION
+    }
+
+    /**
+     * Snap the [View] to be collapsed or expanded, depending on whatever state is closer
+     * over a short amount of time.
+     */
+    abstract fun snapWithAnimation(view: View)
+
+    /**
+     * Snap the [View] to be collapsed or expanded, depending on whatever state is closer immediately.
+     */
+    abstract fun snapImmediately(view: View?)
+
+    /**
+     * Translate the [View] to it's full visible height.
+     */
+    abstract fun expandWithAnimation(view: View)
+
+    /**
+     * Force expanding the [View] depending on the [distance] value that should be translated
+     * cancelling any other translation already in progress.
+     */
+    abstract fun forceExpandWithAnimation(view: View, distance: Float)
+
+    /**
+     * Translate the [View] to it's full 0 visible height.
+     */
+    abstract fun collapseWithAnimation(view: View)
+
+    /**
+     * Translate [view] immediately to the specified [distance] amount (positive or negative).
+     */
+    abstract fun translate(view: View, distance: Float)
+
+    /**
+     * Translate [view] to the indicated [targetTranslationY] vaue over a short amount of time.
+     */
+    open fun animateToTranslationY(view: View, targetTranslationY: Float) = with(animator) {
+        addUpdateListener { view.translationY = it.animatedValue as Float }
+        setFloatValues(view.translationY, targetTranslationY)
+        start()
+    }
+
+    /**
+     * Cancel any translation animations currently in progress.
+     */
+    fun cancelInProgressTranslation() = animator.cancel()
+}
+
+/**
+ * Helper class containing methods for translating a [View] on the Y axis
+ * between 0 and [View.getHeight]
+ */
+internal class BottomViewBehaviorStrategy : ViewYTranslationStrategy() {
+    @VisibleForTesting
+    internal var wasLastExpanding = false
+
+    override fun snapWithAnimation(view: View) {
+        if (view.translationY >= (view.height / 2f)) {
+            collapseWithAnimation(view)
+        } else {
+            expandWithAnimation(view)
+        }
+    }
+
+    override fun snapImmediately(view: View?) {
+        if (animator.isStarted) {
+            animator.end()
+        } else {
+            view?.apply {
+                translationY = if (translationY >= height / 2) {
+                    height.toFloat()
+                } else {
+                    0f
+                }
+            }
+        }
+    }
+
+    override fun expandWithAnimation(view: View) {
+        animateToTranslationY(view, 0f)
+    }
+
+    override fun forceExpandWithAnimation(view: View, distance: Float) {
+        val shouldExpandToolbar = distance < 0
+        val isToolbarExpanded = view.translationY == 0f
+        if (shouldExpandToolbar && !isToolbarExpanded && !wasLastExpanding) {
+            animator.cancel()
+            expandWithAnimation(view)
+        }
+    }
+
+    override fun collapseWithAnimation(view: View) {
+        animateToTranslationY(view, view.height.toFloat())
+    }
+
+    override fun translate(view: View, distance: Float) {
+        view.translationY =
+            max(0f, min(view.height.toFloat(), view.translationY + distance))
+    }
+
+    override fun animateToTranslationY(view: View, targetTranslationY: Float) {
+        wasLastExpanding = targetTranslationY <= view.translationY
+        super.animateToTranslationY(view, targetTranslationY)
+    }
+}
+
+/**
+ * Helper class containing methods for translating a [View] on the Y axis
+ * between -[View.getHeight] and 0.
+ */
+internal class TopViewBehaviorStrategy : ViewYTranslationStrategy() {
+    @VisibleForTesting
+    internal var wasLastExpanding = false
+
+    override fun snapWithAnimation(view: View) {
+        if (view.translationY >= -(view.height / 2f)) {
+            expandWithAnimation(view)
+        } else {
+            collapseWithAnimation(view)
+        }
+    }
+
+    override fun snapImmediately(view: View?) {
+        if (animator.isStarted) {
+            animator.end()
+        } else {
+            view?.apply {
+                translationY = if (translationY >= -height / 2) {
+                    0f
+                } else {
+                    -height.toFloat()
+                }
+            }
+        }
+    }
+
+    override fun expandWithAnimation(view: View) {
+        animateToTranslationY(view, 0f)
+    }
+
+    override fun forceExpandWithAnimation(view: View, distance: Float) {
+        val isExpandingInProgress = animator.isStarted && wasLastExpanding
+        val shouldExpandToolbar = distance < 0
+        val isToolbarExpanded = view.translationY == 0f
+        if (shouldExpandToolbar && !isToolbarExpanded && !isExpandingInProgress) {
+            animator.cancel()
+            expandWithAnimation(view)
+        }
+    }
+
+    override fun collapseWithAnimation(view: View) {
+        animateToTranslationY(view, -view.height.toFloat())
+    }
+
+    override fun translate(view: View, distance: Float) {
+        view.translationY =
+            min(0f, max(-view.height.toFloat(), view.translationY - distance))
+    }
+
+    override fun animateToTranslationY(view: View, targetTranslationY: Float) {
+        wasLastExpanding = targetTranslationY >= view.translationY
+        super.animateToTranslationY(view, targetTranslationY)
+    }
+}
diff --git a/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslator.kt b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslator.kt
new file mode 100644
index 000000000000..042b810b40ef
--- /dev/null
+++ b/android-components/components/ui/widgets/src/main/java/mozilla/components/ui/widgets/behavior/ViewYTranslator.kt
@@ -0,0 +1,81 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.widgets.behavior
+
+import android.view.View
+import androidx.annotation.VisibleForTesting
+
+/**
+ * Helper class with methods for translating on the Y axis a top / bottom [View].
+ *
+ * @param viewPosition whether the view is displayed immediately at the top of the screen or
+ * immediately at the bottom. This affects how it will be translated:
+ *   - if place at the bottom it will be Y translated between 0 and [View.getHeight]
+ *   - if place at the top it will be Y translated between -[View.getHeight] and 0
+ */
+class ViewYTranslator(viewPosition: ViewPosition) {
+    @VisibleForTesting
+    internal var strategy = getTranslationStrategy(viewPosition)
+
+    /**
+     * Snap the [View] to be collapsed or expanded, depending on whatever state is closer
+     * over a short amount of time.
+     */
+    internal fun snapWithAnimation(view: View) {
+        strategy.snapWithAnimation(view)
+    }
+
+    /**
+     * Snap the [View] to be collapsed or expanded, depending on whatever state is closer immediately.
+     */
+    fun snapImmediately(view: View?) {
+        strategy.snapImmediately(view)
+    }
+
+    /**
+     * Translate the [View] to it's full visible height over a short amount of time.
+     */
+    internal fun expandWithAnimation(view: View) {
+        strategy.expandWithAnimation(view)
+    }
+
+    /**
+     * Translate the [View] to be hidden from view over a short amount of time.
+     */
+    internal fun collapseWithAnimation(view: View) {
+        strategy.collapseWithAnimation(view)
+    }
+
+    /**
+     * Force expanding the [View] depending on the [distance] value that should be translated
+     * cancelling any other translation already in progress.
+     */
+    fun forceExpandIfNotAlready(view: View, distance: Float) {
+        strategy.forceExpandWithAnimation(view, distance)
+    }
+
+    /**
+     * Translate [view] immediately to the specified [distance] amount (positive or negative).
+     */
+    fun translate(view: View, distance: Float) {
+        strategy.translate(view, distance)
+    }
+
+    /**
+     * Cancel any translation animations currently in progress.
+     */
+    fun cancelInProgressTranslation() {
+        strategy.cancelInProgressTranslation()
+    }
+
+    @VisibleForTesting
+    internal fun getTranslationStrategy(viewPosition: ViewPosition): ViewYTranslationStrategy {
+        return if (viewPosition == ViewPosition.TOP) {
+            TopViewBehaviorStrategy()
+        } else {
+            BottomViewBehaviorStrategy()
+        }
+    }
+}
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetectorTest.kt
similarity index 99%
rename from android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
rename to android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetectorTest.kt
index 56847252da72..66c4b826ff7e 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserGestureDetectorTest.kt
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/BrowserGestureDetectorTest.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.browser.toolbar.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.view.GestureDetector
 import android.view.MotionEvent
diff --git a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehaviorTest.kt
similarity index 89%
rename from android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt
rename to android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehaviorTest.kt
index 3b8a8aaecb83..a589f90b5bf2 100644
--- a/android-components/components/feature/session/src/test/java/mozilla/components/feature/session/behavior/EngineViewBrowserToolbarBehaviorTest.kt
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewClippingBehaviorTest.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.feature.session.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.content.Context
 import android.view.View
@@ -24,7 +24,7 @@ import org.mockito.Mockito.spy
 import org.mockito.Mockito.verify
 
 @RunWith(AndroidJUnit4::class)
-class EngineViewBrowserToolbarBehaviorTest {
+class EngineViewClippingBehaviorTest {
 
     @Test
     fun `EngineView clipping and bottom toolbar offset are kept in sync`() {
@@ -33,7 +33,7 @@ class EngineViewBrowserToolbarBehaviorTest {
         doReturn(100).`when`(toolbar).height
         doReturn(42f).`when`(toolbar).translationY
 
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView.asView(),
@@ -54,7 +54,7 @@ class EngineViewBrowserToolbarBehaviorTest {
         doReturn(100).`when`(toolbar).height
         doReturn(42f).`when`(toolbar).translationY
 
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView.asView(),
@@ -70,7 +70,7 @@ class EngineViewBrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior does not depend on normal views`() {
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             mock(),
@@ -85,7 +85,7 @@ class EngineViewBrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior depends on BrowserToolbar`() {
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             mock(),
@@ -99,7 +99,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a bottom toolbar WHEN translation has below a half decimal THEN set vertical clipping with the floor value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -115,7 +115,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a bottom toolbar WHEN translation has exactly half of a decimal THEN set vertical clipping with the ceiling value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -131,7 +131,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a bottom toolbar WHEN translation has more than a half decimal THEN set vertical clipping with the ceiling value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -147,7 +147,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a top toolbar WHEN translation has below a half decimal THEN set vertical clipping with the floor value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -163,7 +163,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a top toolbar WHEN translation has exactly half of a decimal THEN set vertical clipping with the ceiling value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -179,7 +179,7 @@ class EngineViewBrowserToolbarBehaviorTest {
     @Test
     fun `GIVEN a top toolbar WHEN translation has more than a half decimal THEN set vertical clipping with the ceiling value`() {
         val engineView: FakeEngineView = mock()
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView,
@@ -199,7 +199,7 @@ class EngineViewBrowserToolbarBehaviorTest {
         doReturn(100).`when`(toolbar).height
         doReturn(Float.NaN).`when`(toolbar).translationY
 
-        val behavior = EngineViewBrowserToolbarBehavior(
+        val behavior = EngineViewClippingBehavior(
             mock(),
             null,
             engineView.asView(),
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehaviorTest.kt
similarity index 74%
rename from android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
rename to android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehaviorTest.kt
index 6f8c427cad36..0f0c10b71ad4 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/EngineViewScrollingBehaviorTest.kt
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.browser.toolbar.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.content.Context
 import android.graphics.Bitmap
 import android.view.MotionEvent.ACTION_DOWN
 import android.view.MotionEvent.ACTION_MOVE
+import android.view.View
 import android.widget.FrameLayout
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.ViewCompat
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import mozilla.components.browser.toolbar.BrowserToolbar
 import mozilla.components.concept.engine.EngineSession
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.concept.engine.INPUT_UNHANDLED
@@ -35,13 +35,13 @@ import org.mockito.Mockito.verify
 import org.mockito.Mockito.`when`
 
 @RunWith(AndroidJUnit4::class)
-class BrowserToolbarBehaviorTest {
+class EngineViewScrollingBehaviorTest {
     @Test
     fun `onStartNestedScroll should attempt scrolling only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
 
-        behavior.browserToolbar = null
+        behavior.dynamicScrollView = null
         var acceptsNestedScroll = behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
@@ -53,7 +53,7 @@ class BrowserToolbarBehaviorTest {
         assertFalse(acceptsNestedScroll)
         verify(behavior, never()).startNestedScroll(anyInt(), anyInt(), any())
 
-        behavior.browserToolbar = mock()
+        behavior.dynamicScrollView = mock()
         acceptsNestedScroll = behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
@@ -68,15 +68,15 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `startNestedScroll should cancel an ongoing snap animation`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
 
         val acceptsNestedScroll = behavior.startNestedScroll(
             axes = ViewCompat.SCROLL_AXIS_VERTICAL,
             type = ViewCompat.TYPE_TOUCH,
-            toolbar = mock(),
+            view = mock(),
         )
 
         assertTrue(acceptsNestedScroll)
@@ -85,30 +85,30 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `startNestedScroll should not accept nested scrolls on the horizontal axis`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
 
         var acceptsNestedScroll = behavior.startNestedScroll(
             axes = ViewCompat.SCROLL_AXIS_VERTICAL,
             type = ViewCompat.TYPE_TOUCH,
-            toolbar = mock(),
+            view = mock(),
         )
         assertTrue(acceptsNestedScroll)
 
         acceptsNestedScroll = behavior.startNestedScroll(
             axes = ViewCompat.SCROLL_AXIS_HORIZONTAL,
             type = ViewCompat.TYPE_TOUCH,
-            toolbar = mock(),
+            view = mock(),
         )
         assertFalse(acceptsNestedScroll)
     }
 
     @Test
     fun `GIVEN a gesture that doesn't scroll the toolbar WHEN startNestedScroll THEN toolbar is expanded and nested scroll not accepted`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val engineView: EngineView = mock()
         val inputResultDetail: InputResultDetail = mock()
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         doReturn(false).`when`(behavior).shouldScroll
         doReturn(true).`when`(inputResultDetail).isTouchUnhandled()
@@ -118,7 +118,7 @@ class BrowserToolbarBehaviorTest {
         val acceptsNestedScroll = behavior.startNestedScroll(
             axes = ViewCompat.SCROLL_AXIS_VERTICAL,
             type = ViewCompat.TYPE_TOUCH,
-            toolbar = mock(),
+            view = mock(),
         )
 
         verify(yTranslator).cancelInProgressTranslation()
@@ -128,8 +128,8 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior should not accept nested scrolls on the horizontal axis`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        behavior.browserToolbar = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        behavior.dynamicScrollView = mock()
         doReturn(true).`when`(behavior).shouldScroll
 
         var acceptsNestedScroll = behavior.onStartNestedScroll(
@@ -155,29 +155,29 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior should delegate the onStartNestedScroll logic`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val toolbar: BrowserToolbar = mock()
-        behavior.browserToolbar = toolbar
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val view: View = mock()
+        behavior.dynamicScrollView = view
         val inputType = ViewCompat.TYPE_TOUCH
         val axes = ViewCompat.SCROLL_AXIS_VERTICAL
 
         behavior.onStartNestedScroll(
             coordinatorLayout = mock(),
-            child = toolbar,
+            child = view,
             directTargetChild = mock(),
             target = mock(),
             axes = axes,
             type = inputType,
         )
 
-        verify(behavior).startNestedScroll(axes, inputType, toolbar)
+        verify(behavior).startNestedScroll(axes, inputType, view)
     }
 
     @Test
     fun `onStopNestedScroll should attempt stopping nested scrolling only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
 
-        behavior.browserToolbar = null
+        behavior.dynamicScrollView = null
         behavior.onStopNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
@@ -186,7 +186,7 @@ class BrowserToolbarBehaviorTest {
         )
         verify(behavior, never()).stopNestedScroll(anyInt(), any())
 
-        behavior.browserToolbar = mock()
+        behavior.dynamicScrollView = mock()
         behavior.onStopNestedScroll(
             coordinatorLayout = mock(),
             child = mock(),
@@ -198,29 +198,29 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior should delegate the onStopNestedScroll logic`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val inputType = ViewCompat.TYPE_TOUCH
-        val toolbar: BrowserToolbar = mock()
+        val view: View = mock()
 
-        behavior.browserToolbar = null
+        behavior.dynamicScrollView = null
         behavior.onStopNestedScroll(
             coordinatorLayout = mock(),
-            child = toolbar,
+            child = view,
             target = mock(),
             type = inputType,
         )
-        verify(behavior, never()).stopNestedScroll(inputType, toolbar)
+        verify(behavior, never()).stopNestedScroll(inputType, view)
     }
 
     @Test
     fun `stopNestedScroll will snap toolbar up if toolbar is more than 50 percent visible`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
-        behavior.browserToolbar = mock()
+        behavior.dynamicScrollView = mock()
         doReturn(true).`when`(behavior).shouldScroll
 
-        val child = mock<BrowserToolbar>()
+        val child = mock<View>()
         doReturn(100).`when`(child).height
         doReturn(10f).`when`(child).translationY
 
@@ -245,13 +245,13 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `stopNestedScroll will snap toolbar down if toolbar is less than 50 percent visible`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         doReturn(true).`when`(behavior).shouldScroll
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
 
-        val child = mock<BrowserToolbar>()
-        behavior.browserToolbar = child
+        val child = mock<View>()
+        behavior.dynamicScrollView = child
         doReturn(100).`when`(child).height
         doReturn(90f).`when`(child).translationY
 
@@ -276,8 +276,8 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `onStopNestedScroll should snap the toolbar only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        behavior.browserToolbar = null
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        behavior.dynamicScrollView = null
 
         behavior.onStopNestedScroll(
             coordinatorLayout = mock(),
@@ -291,10 +291,10 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior will intercept MotionEvents and pass them to the custom gesture detector`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val gestureDetector: BrowserGestureDetector = mock()
         behavior.initGesturesDetector(gestureDetector)
-        behavior.browserToolbar = mock()
+        behavior.dynamicScrollView = mock()
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
 
         behavior.onInterceptTouchEvent(mock(), mock(), downEvent)
@@ -304,7 +304,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior should only dispatch MotionEvents to the gesture detector only if browserToolbar is valid`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         val gestureDetector: BrowserGestureDetector = mock()
         behavior.initGesturesDetector(gestureDetector)
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN)
@@ -316,10 +316,10 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior will apply translation to toolbar only for vertical scrolls`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
         behavior.initGesturesDetector(behavior.createGestureDetector())
-        val child = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = child
+        val child = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = child
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN, 0f, 0f)
         val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 100f, downEvent)
 
@@ -331,7 +331,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `GIVEN a null InputResultDetail from the EngineView WHEN shouldScroll is called THEN it returns false`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         behavior.engineView = null
         assertFalse(behavior.shouldScroll)
         behavior.engineView = mock()
@@ -342,7 +342,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `GIVEN an InputResultDetail with the right values and scroll enabled WHEN shouldScroll is called THEN it returns true`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         val engineView: EngineView = mock()
         behavior.engineView = engineView
         behavior.isScrollEnabled = true
@@ -364,7 +364,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `GIVEN an InputResultDetail with the right values but with scroll disabled WHEN shouldScroll is called THEN it returns false`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         behavior.engineView = mock()
         behavior.isScrollEnabled = false
         val validInputResultDetail: InputResultDetail = mock()
@@ -376,7 +376,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `GIVEN scroll enabled but EngineView cannot scroll to bottom WHEN shouldScroll is called THEN it returns false`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         behavior.engineView = mock()
         behavior.isScrollEnabled = true
         val validInputResultDetail: InputResultDetail = mock()
@@ -388,7 +388,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `GIVEN scroll enabled but EngineView cannot scroll to top WHEN shouldScroll is called THEN it returns false`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         behavior.engineView = mock()
         behavior.isScrollEnabled = true
         val validInputResultDetail: InputResultDetail = mock()
@@ -400,12 +400,12 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior will vertically scroll nested scroll started and EngineView handled the event`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
-        val child = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = child
+        val child = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = child
         doReturn(100).`when`(child).height
         doReturn(0f).`when`(child).translationY
         behavior.startedScroll = true
@@ -417,12 +417,12 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior will not scroll vertically if startedScroll is false`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         doReturn(true).`when`(behavior).shouldScroll
-        val child = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = child
+        val child = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = child
         doReturn(100).`when`(child).height
         doReturn(0f).`when`(child).translationY
         behavior.startedScroll = false
@@ -434,12 +434,12 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `Behavior will not scroll vertically if EngineView did not handled the event`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         doReturn(false).`when`(behavior).shouldScroll
-        val child = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = child
+        val child = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = child
         doReturn(100).`when`(child).height
         doReturn(0f).`when`(child).translationY
 
@@ -450,43 +450,43 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `forceExpand should delegate the translator`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
-        val toolbar: BrowserToolbar = mock()
+        val view: View = mock()
 
-        behavior.forceExpand(toolbar)
+        behavior.forceExpand(view)
 
-        verify(yTranslator).expandWithAnimation(toolbar)
+        verify(yTranslator).expandWithAnimation(view)
     }
 
     @Test
     fun `forceCollapse should delegate the translator`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
-        val toolbar: BrowserToolbar = mock()
+        val view: View = mock()
 
-        behavior.forceCollapse(toolbar)
+        behavior.forceCollapse(view)
 
-        verify(yTranslator).collapseWithAnimation(toolbar)
+        verify(yTranslator).collapseWithAnimation(view)
     }
 
     @Test
     fun `Behavior will forceExpand when scrolling up and !shouldScroll if the touch was handled in the browser`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         behavior.initGesturesDetector(behavior.createGestureDetector())
-        val toolbar: BrowserToolbar = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = toolbar
+        val view: View = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = view
         val engineView: EngineView = mock()
         behavior.engineView = engineView
         val handledTouchInput = InputResultDetail.newInstance().copy(INPUT_UNHANDLED)
         doReturn(handledTouchInput).`when`(engineView).getInputResultDetail()
 
-        doReturn(100).`when`(toolbar).height
-        doReturn(100f).`when`(toolbar).translationY
+        doReturn(100).`when`(view).height
+        doReturn(100f).`when`(view).translationY
 
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN, 0f, 0f)
         val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 30f, downEvent)
@@ -495,24 +495,24 @@ class BrowserToolbarBehaviorTest {
         behavior.onInterceptTouchEvent(mock(), mock(), moveEvent)
 
         verify(behavior).tryToScrollVertically(-30f)
-        verify(yTranslator).forceExpandIfNotAlready(toolbar, -30f)
+        verify(yTranslator).forceExpandIfNotAlready(view, -30f)
     }
 
     @Test
     fun `Behavior will not forceExpand when scrolling up and !shouldScroll if the touch was not yet handled in the browser`() {
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
-        val yTranslator: BrowserToolbarYTranslator = mock()
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
+        val yTranslator: ViewYTranslator = mock()
         behavior.yTranslator = yTranslator
         behavior.initGesturesDetector(behavior.createGestureDetector())
-        val toolbar: BrowserToolbar = spy(BrowserToolbar(testContext, null, 0))
-        behavior.browserToolbar = toolbar
+        val view: View = spy(View(testContext, null, 0))
+        behavior.dynamicScrollView = view
         val engineView: EngineView = mock()
         behavior.engineView = engineView
         val handledTouchInput = InputResultDetail.newInstance()
         doReturn(handledTouchInput).`when`(engineView).getInputResultDetail()
 
-        doReturn(100).`when`(toolbar).height
-        doReturn(100f).`when`(toolbar).translationY
+        doReturn(100).`when`(view).height
+        doReturn(100f).`when`(view).translationY
 
         val downEvent = TestUtils.getMotionEvent(ACTION_DOWN, 0f, 0f)
         val moveEvent = TestUtils.getMotionEvent(ACTION_MOVE, 0f, 30f, downEvent)
@@ -521,28 +521,28 @@ class BrowserToolbarBehaviorTest {
         behavior.onInterceptTouchEvent(mock(), mock(), moveEvent)
 
         verify(behavior).tryToScrollVertically(-30f)
-        verify(yTranslator, never()).forceExpandIfNotAlready(toolbar, -30f)
+        verify(yTranslator, never()).forceExpandIfNotAlready(view, -30f)
     }
 
     @Test
     fun `onLayoutChild initializes browserToolbar and engineView`() {
-        val toolbarView = BrowserToolbar(testContext)
+        val view = View(testContext)
         val engineView = createDummyEngineView(testContext).asView()
         val container = CoordinatorLayout(testContext).apply {
-            addView(BrowserToolbar(testContext))
+            addView(View(testContext))
             addView(engineView)
         }
-        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val behavior = spy(EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM))
 
-        behavior.onLayoutChild(container, toolbarView, ViewCompat.LAYOUT_DIRECTION_LTR)
+        behavior.onLayoutChild(container, view, ViewCompat.LAYOUT_DIRECTION_LTR)
 
-        assertEquals(toolbarView, behavior.browserToolbar)
+        assertEquals(view, behavior.dynamicScrollView)
         assertEquals(engineView, behavior.engineView)
     }
 
     @Test
     fun `enableScrolling sets isScrollEnabled to true`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
 
         assertFalse(behavior.isScrollEnabled)
         behavior.enableScrolling()
@@ -552,7 +552,7 @@ class BrowserToolbarBehaviorTest {
 
     @Test
     fun `disableScrolling sets isScrollEnabled to false`() {
-        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val behavior = EngineViewScrollingBehavior(testContext, null, ViewPosition.BOTTOM)
         behavior.isScrollEnabled = true
 
         assertTrue(behavior.isScrollEnabled)
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/TestUtils.kt
similarity index 93%
rename from android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt
rename to android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/TestUtils.kt
index d08b38729c6c..2e5bbaa9dfd4 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/TestUtils.kt
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/TestUtils.kt
@@ -2,7 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package mozilla.components.browser.toolbar.behavior
+package mozilla.components.ui.widgets.behavior
 
 import android.view.MotionEvent
 
@@ -23,7 +23,7 @@ object TestUtils {
             pointerCount = 1
         }
 
-        val properties = Array(pointerCount, ::getPointerProperties)
+        val properties = Array(pointerCount, TestUtils::getPointerProperties)
         val pointerCoords = getPointerCoords(x, y, pointerCount)
 
         return MotionEvent.obtain(
diff --git a/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategyTest.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategyTest.kt
new file mode 100644
index 000000000000..62d152f7f602
--- /dev/null
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslationStrategyTest.kt
@@ -0,0 +1,712 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.widgets.behavior
+
+import android.animation.ValueAnimator
+import android.view.View
+import android.view.animation.DecelerateInterpolator
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class ViewYTranslationStrategyTest {
+    @Test
+    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for bottom toolbar translations`() {
+        val strategy = BottomViewBehaviorStrategy()
+
+        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
+        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
+    }
+
+    @Test
+    fun `snapAnimator should use a DecelerateInterpolator with SNAP_ANIMATION_DURATION for top toolbar translations`() {
+        val strategy = TopViewBehaviorStrategy()
+
+        assertTrue(strategy.animator.interpolator is DecelerateInterpolator)
+        assertEquals(SNAP_ANIMATION_DURATION, strategy.animator.duration)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
+        val strategy = BottomViewBehaviorStrategy()
+
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy should start with isToolbarExpanding = false`() {
+        val strategy = TopViewBehaviorStrategy()
+
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(50f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(51f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(100f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(333f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        verify(strategy, times(4)).collapseWithAnimation(view)
+        verify(strategy, never()).expandWithAnimation(view)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(49f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(0f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(-50f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        verify(strategy, times(3)).expandWithAnimation(view)
+        verify(strategy, never()).collapseWithAnimation(view)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapWithAnimation should collapse toolbar if more than half hidden`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-51f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(-100f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(-333f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        verify(strategy, times(3)).collapseWithAnimation(view)
+        verify(strategy, never()).expandWithAnimation(view)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapWithAnimation should expand toolbar if more than half visible`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-50f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(-49f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(0f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        doReturn(50f).`when`(view).translationY
+        strategy.snapWithAnimation(view)
+
+        verify(strategy, times(4)).expandWithAnimation(view)
+        verify(strategy, never()).collapseWithAnimation(view)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+
+        strategy.snapImmediately(view)
+
+        verify(animator).end()
+        verify(view, never()).translationY
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if half translated`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(50f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(55f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if translated off screen`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(555f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated less than half`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(49f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(0f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-1f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should end translations animations if in progress`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+
+        strategy.snapImmediately(view)
+
+        verify(animator).end()
+        verify(view, never()).translationY
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate translate to 0 the toolbar if translated less than half`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-49f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated 0`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(0f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated inside the screen`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(1f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if half translated`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-50f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate away the toolbar if more than half translated`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-55f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = -100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - snapImmediately should translate to 0 the toolbar if translated offscreen`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        doReturn(-111f).`when`(view).translationY
+        strategy.snapImmediately(view)
+        verify(view).translationY = -100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val view: View = mock()
+
+        strategy.expandWithAnimation(view)
+
+        verify(strategy).animateToTranslationY(view, 0f)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - expandWithAnimation should translate the toolbar to to y 0`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val view: View = mock()
+
+        strategy.expandWithAnimation(view)
+
+        verify(strategy).animateToTranslationY(view, 0f)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
+        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
+        // Below this test we can change each variable one at a time to test them in isolation.
+
+        val strategy = spy(BottomViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator).cancel()
+        verify(strategy).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        strategy.wasLastExpanding = true
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes down`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, 100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(0f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should expand toolbar`() {
+        // Setting the scenario in which forceExpandWithAnimation will actually do what the name says.
+        // Below this test we can change each variable one at a time to test them in isolation.
+
+        val strategy = spy(TopViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(-100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator).cancel()
+        verify(strategy).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not force expand the toolbar if not currently collapsing`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        strategy.wasLastExpanding = true
+        val animator: ValueAnimator = mock()
+        doReturn(true).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(-100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand if user swipes up`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(-100f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, 10f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - forceExpandWithAnimation should not expand the toolbar if it is already expanded`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val animator: ValueAnimator = mock()
+        doReturn(false).`when`(animator).isStarted
+        strategy.animator = animator
+        val view: View = mock()
+        doReturn(0f).`when`(view).translationY
+
+        strategy.forceExpandWithAnimation(view, -100f)
+
+        verify(strategy.animator, never()).cancel()
+        verify(strategy, never()).expandWithAnimation(any())
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar down, off-screen`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        strategy.collapseWithAnimation(view)
+
+        verify(strategy).animateToTranslationY(view, 100f)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - collapseWithAnimation should animate translating the toolbar up, off-screen`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+
+        strategy.collapseWithAnimation(view)
+
+        verify(strategy).animateToTranslationY(view, -100f)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(50f).`when`(view).translationY
+
+        strategy.translate(view, -25f)
+
+        verify(view).translationY = 25f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(50f).`when`(view).translationY
+
+        strategy.translate(view, 25f)
+
+        verify(view).translationY = 75f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar if already expanded`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(0f).`when`(view).translationY
+
+        strategy.translate(view, -1f)
+
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate up the toolbar more than to 0`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(50f).`when`(view).translationY
+
+        strategy.translate(view, -51f)
+
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar if already collapsed`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(100f).`when`(view).translationY
+
+        strategy.translate(view, 1f)
+
+        verify(view).translationY = 100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - translate should not translate down the toolbar more than it's height`() {
+        val strategy = BottomViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(50f).`when`(view).translationY
+
+        strategy.translate(view, 51f)
+
+        verify(view).translationY = 100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should translate down the toolbar with the distance parameter`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(-50f).`when`(view).translationY
+
+        strategy.translate(view, 25f)
+
+        verify(view).translationY = -75f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should translate up the toolbar with the distance parameter`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(-50f).`when`(view).translationY
+
+        strategy.translate(view, 25f)
+
+        verify(view).translationY = -75f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar if already expanded`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(0f).`when`(view).translationY
+
+        strategy.translate(view, -1f)
+
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate down the toolbar more than to 0`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(-50f).`when`(view).translationY
+
+        strategy.translate(view, -51f)
+
+        verify(view).translationY = 0f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar if already collapsed`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(-100f).`when`(view).translationY
+
+        strategy.translate(view, 1f)
+
+        verify(view).translationY = -100f
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - translate should not translate up the toolbar more than it's height`() {
+        val strategy = TopViewBehaviorStrategy()
+        val view: View = mock()
+        doReturn(100).`when`(view).height
+        doReturn(-50f).`when`(view).translationY
+
+        strategy.translate(view, 51f)
+
+        verify(view).translationY = -100f
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
+        val strategy = BottomViewBehaviorStrategy()
+        strategy.wasLastExpanding = false
+        val view: View = mock()
+        doReturn(50f).`when`(view).translationY
+
+        strategy.animateToTranslationY(view, 10f)
+        assertTrue(strategy.wasLastExpanding)
+
+        strategy.animateToTranslationY(view, 60f)
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `BottomToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
+        val strategy = spy(BottomViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val view = View(testContext)
+        val animator: ValueAnimator = spy(strategy.animator)
+        strategy.animator = animator
+
+        strategy.animateToTranslationY(view, 10f)
+
+        verify(animator).start()
+        animator.end()
+        assertEquals(10f, view.translationY)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - animateToTranslationY should set wasLastExpanding if expanding`() {
+        val strategy = TopViewBehaviorStrategy()
+        strategy.wasLastExpanding = false
+        val view: View = mock()
+        doReturn(-50f).`when`(view).translationY
+
+        strategy.animateToTranslationY(view, -10f)
+        assertTrue(strategy.wasLastExpanding)
+
+        strategy.animateToTranslationY(view, -60f)
+        assertFalse(strategy.wasLastExpanding)
+    }
+
+    @Test
+    fun `TopToolbarBehaviorStrategy - animateToTranslationY should animate to the indicated y translation`() {
+        val strategy = spy(TopViewBehaviorStrategy())
+        strategy.wasLastExpanding = false
+        val view = View(testContext)
+        val animator: ValueAnimator = spy(strategy.animator)
+        strategy.animator = animator
+
+        strategy.animateToTranslationY(view, -10f)
+
+        verify(animator).start()
+        animator.end()
+        assertEquals(-10f, view.translationY)
+    }
+}
diff --git a/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslatorTest.kt b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslatorTest.kt
new file mode 100644
index 000000000000..6a3a908adc55
--- /dev/null
+++ b/android-components/components/ui/widgets/src/test/java/mozilla/components/ui/widgets/behavior/ViewYTranslatorTest.kt
@@ -0,0 +1,113 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.ui.widgets.behavior
+
+import android.view.View
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class ViewYTranslatorTest {
+    @Test
+    fun `yTranslator should use BottomToolbarBehaviorStrategy for bottom placed toolbars`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+
+        assertTrue(yTranslator.strategy is BottomViewBehaviorStrategy)
+    }
+
+    @Test
+    fun `yTranslator should use TopToolbarBehaviorStrategy for top placed toolbars`() {
+        val yTranslator = ViewYTranslator(ViewPosition.TOP)
+
+        assertTrue(yTranslator.strategy is TopViewBehaviorStrategy)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for snapWithAnimation`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.snapWithAnimation(view)
+
+        verify(strategy).snapWithAnimation(view)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for expandWithAnimation`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.expandWithAnimation(view)
+
+        verify(strategy).expandWithAnimation(view)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for collapseWithAnimation`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.collapseWithAnimation(view)
+
+        verify(strategy).collapseWithAnimation(view)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for forceExpandIfNotAlready`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.forceExpandIfNotAlready(view, 14f)
+
+        verify(strategy).forceExpandWithAnimation(view, 14f)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for translate`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.translate(view, 23f)
+
+        verify(strategy).translate(view, 23f)
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for cancelInProgressTranslation`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+
+        yTranslator.cancelInProgressTranslation()
+
+        verify(strategy).cancelInProgressTranslation()
+    }
+
+    @Test
+    fun `yTranslator should delegate it's strategy for snapImmediately`() {
+        val yTranslator = ViewYTranslator(ViewPosition.BOTTOM)
+        val strategy: ViewYTranslationStrategy = mock()
+        yTranslator.strategy = strategy
+        val view: View = mock()
+
+        yTranslator.snapImmediately(view)
+
+        verify(strategy).snapImmediately(view)
+    }
+}
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/browser/BaseBrowserFragment.kt b/fenix/app/src/main/java/org/mozilla/fenix/browser/BaseBrowserFragment.kt
index db23b580b01f..c90ccb91bc0a 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/browser/BaseBrowserFragment.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/browser/BaseBrowserFragment.kt
@@ -91,7 +91,6 @@ import mozilla.components.feature.session.PictureInPictureFeature
 import mozilla.components.feature.session.ScreenOrientationFeature
 import mozilla.components.feature.session.SessionFeature
 import mozilla.components.feature.session.SwipeRefreshFeature
-import mozilla.components.feature.session.behavior.EngineViewBrowserToolbarBehavior
 import mozilla.components.feature.sitepermissions.SitePermissionsFeature
 import mozilla.components.feature.webauthn.WebAuthnFeature
 import mozilla.components.lib.state.ext.consumeFlow
@@ -111,6 +110,7 @@ import mozilla.components.support.ktx.android.view.hideKeyboard
 import mozilla.components.support.ktx.kotlin.getOrigin
 import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifAnyChanged
 import mozilla.components.support.locale.ActivityContextWrapper
+import mozilla.components.ui.widgets.behavior.EngineViewClippingBehavior
 import mozilla.components.ui.widgets.withCenterAlignedButtons
 import org.mozilla.fenix.BuildConfig
 import org.mozilla.fenix.FeatureFlags
@@ -168,7 +168,7 @@ import org.mozilla.fenix.utils.allowUndo
 import org.mozilla.fenix.wifi.SitePermissionsWifiIntegration
 import java.lang.ref.WeakReference
 import kotlin.coroutines.cancellation.CancellationException
-import mozilla.components.feature.session.behavior.ToolbarPosition as MozacToolbarPosition
+import mozilla.components.ui.widgets.behavior.ToolbarPosition as MozacToolbarPosition
 
 /**
  * Base fragment extended by [BrowserFragment].
@@ -1154,7 +1154,7 @@ abstract class BaseBrowserFragment :
                 MozacToolbarPosition.TOP
             }
             (getSwipeRefreshLayout().layoutParams as CoordinatorLayout.LayoutParams).behavior =
-                EngineViewBrowserToolbarBehavior(
+                EngineViewClippingBehavior(
                     context,
                     null,
                     getSwipeRefreshLayout(),
diff --git a/fenix/app/src/main/java/org/mozilla/fenix/components/toolbar/BrowserToolbarView.kt b/fenix/app/src/main/java/org/mozilla/fenix/components/toolbar/BrowserToolbarView.kt
index 6668191599d8..1e3fc7a98cb2 100644
--- a/fenix/app/src/main/java/org/mozilla/fenix/components/toolbar/BrowserToolbarView.kt
+++ b/fenix/app/src/main/java/org/mozilla/fenix/components/toolbar/BrowserToolbarView.kt
@@ -19,9 +19,9 @@ import mozilla.components.browser.state.selector.selectedTab
 import mozilla.components.browser.state.state.CustomTabSessionState
 import mozilla.components.browser.state.state.ExternalAppType
 import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.support.ktx.util.URLStringUtils
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
 import org.mozilla.fenix.R
 import org.mozilla.fenix.components.toolbar.interactor.BrowserToolbarInteractor
 import org.mozilla.fenix.customtabs.CustomTabToolbarIntegration
@@ -32,7 +32,7 @@ import org.mozilla.fenix.theme.ThemeManager
 import org.mozilla.fenix.utils.Settings
 import org.mozilla.fenix.utils.ToolbarPopupWindow
 import java.lang.ref.WeakReference
-import mozilla.components.browser.toolbar.behavior.ToolbarPosition as MozacToolbarPosition
+import mozilla.components.ui.widgets.behavior.ViewPosition as MozacToolbarPosition
 
 @SuppressWarnings("LargeClass")
 class BrowserToolbarView(
@@ -53,8 +53,7 @@ class BrowserToolbarView(
     private val layout = LayoutInflater.from(context)
         .inflate(toolbarLayout, container, true)
 
-    @VisibleForTesting
-    internal var view: BrowserToolbar = layout
+    var view: BrowserToolbar = layout
         .findViewById(R.id.toolbar)
 
     val toolbarIntegration: ToolbarIntegration
@@ -191,7 +190,7 @@ class BrowserToolbarView(
         }
 
         (view.layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.forceExpand(view)
+            (behavior as? EngineViewScrollingBehavior)?.forceExpand(view)
         }
     }
 
@@ -202,7 +201,7 @@ class BrowserToolbarView(
         }
 
         (view.layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            (behavior as? BrowserToolbarBehavior)?.forceCollapse(view)
+            (behavior as? EngineViewScrollingBehavior)?.forceCollapse(view)
         }
     }
 
@@ -255,7 +254,7 @@ class BrowserToolbarView(
     @VisibleForTesting
     internal fun setDynamicToolbarBehavior(toolbarPosition: MozacToolbarPosition) {
         (view.layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
-            behavior = BrowserToolbarBehavior(view.context, null, toolbarPosition)
+            behavior = EngineViewScrollingBehavior(view.context, null, toolbarPosition)
         }
     }
 
diff --git a/fenix/app/src/test/java/org/mozilla/fenix/browser/BaseBrowserFragmentTest.kt b/fenix/app/src/test/java/org/mozilla/fenix/browser/BaseBrowserFragmentTest.kt
index 9db600442229..4a7e37e36c10 100644
--- a/fenix/app/src/test/java/org/mozilla/fenix/browser/BaseBrowserFragmentTest.kt
+++ b/fenix/app/src/test/java/org/mozilla/fenix/browser/BaseBrowserFragmentTest.kt
@@ -16,8 +16,8 @@ import mozilla.components.browser.state.state.SessionState
 import mozilla.components.concept.engine.EngineView
 import mozilla.components.concept.engine.permission.SitePermissions
 import mozilla.components.feature.contextmenu.ContextMenuCandidate
-import mozilla.components.feature.session.behavior.EngineViewBrowserToolbarBehavior
 import mozilla.components.ui.widgets.VerticalSwipeRefreshLayout
+import mozilla.components.ui.widgets.behavior.EngineViewClippingBehavior
 import org.junit.Before
 import org.junit.Test
 import org.mozilla.fenix.ext.components
@@ -88,17 +88,17 @@ class BaseBrowserFragmentTest {
     }
 
     @Test
-    fun `initializeEngineView should set EngineViewBrowserToolbarBehavior when dynamic toolbar is enabled`() {
+    fun `initializeEngineView should set EngineViewClippingBehavior when dynamic toolbar is enabled`() {
         every { settings.shouldUseFixedTopToolbar } returns false
         every { settings.isDynamicToolbarEnabled } returns true
         val params: CoordinatorLayout.LayoutParams = mockk(relaxed = true)
         every { params.behavior } returns mockk(relaxed = true)
         every { swipeRefreshLayout.layoutParams } returns params
-        val behavior = slot<EngineViewBrowserToolbarBehavior>()
+        val behavior = slot<EngineViewClippingBehavior>()
 
         fragment.initializeEngineView(13)
 
-        // EngineViewBrowserToolbarBehavior constructor parameters are not properties, we cannot check them.
+        // EngineViewClippingBehavior constructor parameters are not properties, we cannot check them.
         // Ensure just that the right behavior is set.
         verify { params.behavior = capture(behavior) }
     }
diff --git a/fenix/app/src/test/java/org/mozilla/fenix/components/toolbar/BrowserToolbarViewTest.kt b/fenix/app/src/test/java/org/mozilla/fenix/components/toolbar/BrowserToolbarViewTest.kt
index 8ad2f685416f..2fad1a270c4c 100644
--- a/fenix/app/src/test/java/org/mozilla/fenix/components/toolbar/BrowserToolbarViewTest.kt
+++ b/fenix/app/src/test/java/org/mozilla/fenix/components/toolbar/BrowserToolbarViewTest.kt
@@ -11,9 +11,9 @@ import io.mockk.mockk
 import io.mockk.spyk
 import io.mockk.verify
 import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
 import mozilla.components.lib.publicsuffixlist.PublicSuffixList
 import mozilla.components.support.test.robolectric.testContext
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
 import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertNull
 import org.junit.Before
@@ -22,20 +22,20 @@ import org.junit.runner.RunWith
 import org.mozilla.fenix.ext.components
 import org.mozilla.fenix.helpers.FenixRobolectricTestRunner
 import org.mozilla.fenix.utils.Settings
-import mozilla.components.browser.toolbar.behavior.ToolbarPosition as MozacToolbarPosition
+import mozilla.components.ui.widgets.behavior.ViewPosition as MozacToolbarPosition
 
 @RunWith(FenixRobolectricTestRunner::class)
 class BrowserToolbarViewTest {
     private lateinit var toolbarView: BrowserToolbarView
     private lateinit var toolbar: BrowserToolbar
-    private lateinit var behavior: BrowserToolbarBehavior
+    private lateinit var behavior: EngineViewScrollingBehavior
     private lateinit var settings: Settings
 
     @Before
     fun setup() {
         toolbar = BrowserToolbar(testContext)
         toolbar.layoutParams = CoordinatorLayout.LayoutParams(100, 100)
-        behavior = spyk(BrowserToolbarBehavior(testContext, null, MozacToolbarPosition.BOTTOM))
+        behavior = spyk(EngineViewScrollingBehavior(testContext, null, MozacToolbarPosition.BOTTOM))
         (toolbar.layoutParams as CoordinatorLayout.LayoutParams).behavior = behavior
         settings = mockk(relaxed = true)
         every { testContext.components.useCases } returns mockk(relaxed = true)
@@ -217,7 +217,7 @@ class BrowserToolbarViewTest {
     }
 
     @Test
-    fun `setDynamicToolbarBehavior should set a BrowserToolbarBehavior for the bottom toolbar`() {
+    fun `setDynamicToolbarBehavior should set a ViewHideOnScrollBehavior for the bottom toolbar`() {
         val toolbarViewSpy = spyk(toolbarView)
         (toolbar.layoutParams as CoordinatorLayout.LayoutParams).behavior = null
 
@@ -227,7 +227,7 @@ class BrowserToolbarViewTest {
     }
 
     @Test
-    fun `setDynamicToolbarBehavior should set a BrowserToolbarBehavior for the top toolbar`() {
+    fun `setDynamicToolbarBehavior should set a ViewHideOnScrollBehavior for the top toolbar`() {
         val toolbarViewSpy = spyk(toolbarView)
         (toolbar.layoutParams as CoordinatorLayout.LayoutParams).behavior = null
 
diff --git a/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt b/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
index 35a50fa3005c..e719986a9d60 100644
--- a/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
+++ b/focus-android/app/src/main/java/org/mozilla/focus/ext/BrowserToolbar.kt
@@ -8,12 +8,12 @@ import android.content.Context
 import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.isVisible
 import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
 import mozilla.components.concept.engine.EngineView
-import mozilla.components.feature.session.behavior.EngineViewBrowserToolbarBehavior
+import mozilla.components.ui.widgets.behavior.EngineViewClippingBehavior
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
 import org.mozilla.focus.R
-import mozilla.components.browser.toolbar.behavior.ToolbarPosition as browserToolbarPosition
-import mozilla.components.feature.session.behavior.ToolbarPosition as engineToolbarPosition
+import mozilla.components.ui.widgets.behavior.ToolbarPosition as engineToolbarPosition
+import mozilla.components.ui.widgets.behavior.ViewPosition as browserToolbarPosition
 
 /**
  * Collapse the toolbar and block it from appearing until calling [enableDynamicBehavior].
@@ -38,7 +38,7 @@ fun BrowserToolbar.disableDynamicBehavior(engineView: EngineView) {
  * @param engineView [EngineView] that should react to toolbar's dynamic behavior.
  */
 fun BrowserToolbar.enableDynamicBehavior(context: Context, engineView: EngineView) {
-    (layoutParams as? CoordinatorLayout.LayoutParams)?.behavior = BrowserToolbarBehavior(
+    (layoutParams as? CoordinatorLayout.LayoutParams)?.behavior = EngineViewScrollingBehavior(
         context,
         null,
         browserToolbarPosition.TOP,
@@ -48,7 +48,7 @@ fun BrowserToolbar.enableDynamicBehavior(context: Context, engineView: EngineVie
     engineView.setDynamicToolbarMaxHeight(toolbarHeight)
     (engineView.asView().layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
         topMargin = 0
-        behavior = EngineViewBrowserToolbarBehavior(
+        behavior = EngineViewClippingBehavior(
             context,
             null,
             engineView.asView(),
diff --git a/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt b/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
index 3134a75b03db..4407e03a76b3 100644
--- a/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
+++ b/focus-android/app/src/test/java/org/mozilla/focus/ext/BrowserToolbarTest.kt
@@ -8,9 +8,9 @@ import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.isVisible
 import mozilla.components.browser.engine.gecko.GeckoEngineView
 import mozilla.components.browser.toolbar.BrowserToolbar
-import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
-import mozilla.components.feature.session.behavior.EngineViewBrowserToolbarBehavior
 import mozilla.components.support.test.robolectric.testContext
+import mozilla.components.ui.widgets.behavior.EngineViewClippingBehavior
+import mozilla.components.ui.widgets.behavior.EngineViewScrollingBehavior
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNull
 import org.junit.Assert.assertTrue
@@ -42,8 +42,8 @@ internal class BrowserToolbarTest {
 
         toolbar.enableDynamicBehavior(testContext, engineView)
 
-        assertTrue((toolbar.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is BrowserToolbarBehavior)
-        assertTrue((engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is EngineViewBrowserToolbarBehavior)
+        assertTrue((toolbar.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is EngineViewScrollingBehavior)
+        assertTrue((engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior is EngineViewClippingBehavior)
         assertEquals(0, (engineView.layoutParams as? CoordinatorLayout.LayoutParams)?.topMargin)
         verify(engineView).setDynamicToolbarMaxHeight(toolbarHeight)
     }
