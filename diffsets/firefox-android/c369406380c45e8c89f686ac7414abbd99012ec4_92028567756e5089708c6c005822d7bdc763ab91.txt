diff --git a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/error/ErrorRecording.kt b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/error/ErrorRecording.kt
index 0a135c16f052..7913e72c7348 100644
--- a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/error/ErrorRecording.kt
+++ b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/error/ErrorRecording.kt
@@ -41,12 +41,15 @@ object ErrorRecording {
      *     ping.  It does not need to include the metric name, as that is automatically
      *     prepended to the message.
      * @param logger The [Logger] instance to display the warning.
+     * @param numErrors The optional number of errors to report for this [ErrorType].
      */
+    @Suppress("LongMethod")
     internal fun recordError(
         metricData: CommonMetricData,
         errorType: ErrorType,
         message: String,
-        logger: Logger
+        logger: Logger,
+        numErrors: Int? = null
     ) {
         val errorName = GLEAN_ERROR_NAMES[errorType]!!
 
@@ -82,7 +85,7 @@ object ErrorRecording {
         // in the __other__ category.
         CountersStorageEngine.record(
             errorMetric,
-            amount = 1
+            amount = numErrors ?: 1
         )
     }
 
diff --git a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/HistogramBase.kt b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/HistogramBase.kt
new file mode 100644
index 000000000000..dc0b4439f8ff
--- /dev/null
+++ b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/HistogramBase.kt
@@ -0,0 +1,24 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.service.glean.private
+
+/**
+ * A common interface to be implemented by all the histogram-like metric types
+ * supported by the Glean SDK.
+ */
+interface HistogramBase {
+    /**
+     * Accumulates the provided samples in the metric.
+     *
+     * Please note that this assumes that the provided samples are already in the
+     * "unit" declared by the instance of the implementing metric type (e.g. if the
+     * implementing class is a [TimingDistributionMetricType] and the instance this
+     * method was called on is using [TimeUnit.Second], then `samples` are assumed
+     * to be in that unit).
+     *
+     * @param samples the [LongArray] holding the samples to be recorded by the metric.
+     */
+    fun accumulateSamples(samples: LongArray)
+}
diff --git a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/TimingDistributionMetricType.kt b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/TimingDistributionMetricType.kt
index 5df9286ec0cb..e77d9785d21d 100644
--- a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/TimingDistributionMetricType.kt
+++ b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/private/TimingDistributionMetricType.kt
@@ -25,7 +25,7 @@ data class TimingDistributionMetricType(
     override val name: String,
     override val sendInPings: List<String>,
     val timeUnit: TimeUnit
-) : CommonMetricData {
+) : CommonMetricData, HistogramBase {
 
     private val logger = Logger("glean/TimingDistributionMetricType")
 
@@ -85,6 +85,21 @@ data class TimingDistributionMetricType(
         TimingManager.cancel(this, timerId)
     }
 
+    override fun accumulateSamples(samples: LongArray) {
+        if (!shouldRecord(logger)) {
+            return
+        }
+
+        @Suppress("EXPERIMENTAL_API_USAGE")
+        Dispatchers.API.launch {
+            TimingDistributionsStorageEngine.accumulateSamples(
+                metricData = this@TimingDistributionMetricType,
+                samples = samples,
+                timeUnit = timeUnit
+            )
+        }
+    }
+
     /**
      * Tests whether a value is stored for the metric for testing purposes only. This function will
      * attempt to await the last task (if any) writing to the the metric's storage engine before
diff --git a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/storages/TimingDistributionsStorageEngine.kt b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/storages/TimingDistributionsStorageEngine.kt
index ba545bd55c3a..ee07f5981f01 100644
--- a/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/storages/TimingDistributionsStorageEngine.kt
+++ b/android-components/components/service/glean/src/main/java/mozilla/components/service/glean/storages/TimingDistributionsStorageEngine.kt
@@ -59,7 +59,8 @@ internal open class TimingDistributionsStorageEngineImplementation(
      * Accumulate value for the provided metric.
      *
      * @param metricData the metric information for the timing distribution
-     * @param sample the value to accumulate
+     * @param sample the value to accumulate, in nanoseconds
+     * @param timeUnit the [TimeUnit] the sample will be converted to
      */
     @Synchronized
     fun accumulate(
@@ -67,6 +68,9 @@ internal open class TimingDistributionsStorageEngineImplementation(
         sample: Long,
         timeUnit: TimeUnit
     ) {
+        // We're checking for errors in `accumulateSamples` already, but
+        // we need to check it here too anyway because `getAdjustedTime` would
+        // throw otherwise.
         if (sample < 0) {
             ErrorRecording.recordError(
                 metricData,
@@ -78,21 +82,53 @@ internal open class TimingDistributionsStorageEngineImplementation(
         }
 
         val sampleInUnit = getAdjustedTime(timeUnit, sample)
+        accumulateSamples(metricData, longArrayOf(sampleInUnit), timeUnit)
+    }
+
+    /**
+     * Accumulate an array of samples for the provided metric.
+     *
+     * @param metricData the metric information for the timing distribution
+     * @param samples the values to accumulate, provided in the metric's [TimeUnit] (they won't
+     *        be truncated nor converted)
+     * @param timeUnit the [TimeUnit] the samples are in
+     */
+    @Suppress("LongMethod")
+    @Synchronized
+    fun accumulateSamples(
+        metricData: CommonMetricData,
+        samples: LongArray,
+        timeUnit: TimeUnit
+    ) {
+        val validSamples = samples.filter { sample -> sample >= 0 }
+        val numNegativeSamples = samples.size - validSamples.size
+        if (numNegativeSamples > 0) {
+            ErrorRecording.recordError(
+                metricData,
+                ErrorRecording.ErrorType.InvalidValue,
+                "Accumulate $numNegativeSamples negative samples",
+                logger,
+                numNegativeSamples
+            )
+            return
+        }
 
         // Since the custom combiner closure captures this value, we need to just create a dummy
         // value here that won't be used by the combine function, and create a fresh
         // TimingDistributionData for each value that doesn't have an existing current value.
         val dummy = TimingDistributionData(category = metricData.category, name = metricData.name,
             timeUnit = timeUnit)
-        super.recordMetric(metricData, dummy, null) { currentValue, _ ->
-            currentValue?.let {
-                it.accumulate(sampleInUnit)
-                it
-            } ?: let {
-                val newTD = TimingDistributionData(category = metricData.category, name = metricData.name,
-                    timeUnit = timeUnit)
-                newTD.accumulate(sampleInUnit)
-                return@let newTD
+        validSamples.forEach { sample ->
+            super.recordMetric(metricData, dummy, null) { currentValue, _ ->
+                currentValue?.let {
+                    it.accumulate(sample)
+                    it
+                } ?: let {
+                    val newTD = TimingDistributionData(category = metricData.category, name = metricData.name,
+                        timeUnit = timeUnit)
+                    newTD.accumulate(sample)
+                    return@let newTD
+                }
             }
         }
     }
@@ -124,7 +160,8 @@ internal open class TimingDistributionsStorageEngineImplementation(
  * @param category of the metric
  * @param name of the metric
  * @param bucketCount total number of buckets
- * @param range an array always containing 2 elements: the minimum and maximum bucket values
+ * @param rangeMin the minimum value that can be represented
+ * @param rangeMax the maximum value that can be represented
  * @param histogramType the [HistogramType] representing the bucket layout
  * @param values a map containing the bucket index mapped to the accumulated count
  * @param sum the accumulated sum of all the samples in the timing distribution
diff --git a/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/error/ErrorRecordingTest.kt b/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/error/ErrorRecordingTest.kt
index d93a2a808037..9c7fa907ee8b 100644
--- a/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/error/ErrorRecordingTest.kt
+++ b/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/error/ErrorRecordingTest.kt
@@ -35,6 +35,11 @@ class ErrorRecordingTest {
             sendInPings = listOf("store1", "store2")
         )
 
+        val expectedErrors = mapOf(
+            ErrorRecording.ErrorType.InvalidValue to 1,
+            ErrorRecording.ErrorType.InvalidLabel to 2
+        )
+
         ErrorRecording.recordError(
             stringMetric,
             ErrorRecording.ErrorType.InvalidValue,
@@ -46,16 +51,14 @@ class ErrorRecordingTest {
             stringMetric,
             ErrorRecording.ErrorType.InvalidLabel,
             "Invalid label",
-            logger
+            logger,
+            numErrors = expectedErrors[ErrorRecording.ErrorType.InvalidLabel]
         )
 
         for (storeName in listOf("store1", "store2", "metrics")) {
-            for (errorType in listOf(
-                ErrorRecording.ErrorType.InvalidValue,
-                ErrorRecording.ErrorType.InvalidLabel
-            )) {
+            for (errorType in expectedErrors.keys) {
                 assertEquals(
-                    1,
+                    expectedErrors[errorType],
                     ErrorRecording.testGetNumRecordedErrors(stringMetric, errorType, storeName)
                 )
             }
diff --git a/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/private/TimingDistributionMetricTypeTest.kt b/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/private/TimingDistributionMetricTypeTest.kt
index 856c96806113..4e1d362711cc 100644
--- a/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/private/TimingDistributionMetricTypeTest.kt
+++ b/android-components/components/service/glean/src/test/java/mozilla/components/service/glean/private/TimingDistributionMetricTypeTest.kt
@@ -148,4 +148,33 @@ class TimingDistributionMetricTypeTest {
         // Check that the 3L fell into the third bucket
         assertEquals(1L, snapshot2.values[3])
     }
+
+    @Test
+    fun `The accumulateSamples API correctly stores timing values`() {
+        // Define a timing distribution metric which will be stored in multiple stores
+        val metric = TimingDistributionMetricType(
+            disabled = false,
+            category = "telemetry",
+            lifetime = Lifetime.Ping,
+            name = "timing_distribution_samples",
+            sendInPings = listOf("store1"),
+            timeUnit = TimeUnit.Second
+        )
+
+        // Accumulate a few values
+        val testSamples = (1L..3L).toList().toLongArray()
+        metric.accumulateSamples(testSamples)
+
+        // Check that data was properly recorded in the second ping.
+        assertTrue(metric.testHasValue("store1"))
+        val snapshot = metric.testGetValue("store1")
+        // Check the sum
+        assertEquals(6L, snapshot.sum)
+        // Check that the 1L fell into the first bucket
+        assertEquals(1L, snapshot.values[1])
+        // Check that the 2L fell into the second bucket
+        assertEquals(1L, snapshot.values[2])
+        // Check that the 3L fell into the third bucket
+        assertEquals(1L, snapshot.values[3])
+    }
 }
