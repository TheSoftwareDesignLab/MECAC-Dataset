diff --git a/android-components/components/compose/cfr/src/main/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayout.kt b/android-components/components/compose/cfr/src/main/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayout.kt
index 1c1cac0233b2..09411d855bd1 100644
--- a/android-components/components/compose/cfr/src/main/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayout.kt
+++ b/android-components/components/compose/cfr/src/main/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayout.kt
@@ -248,6 +248,7 @@ internal class CFRPopupFullscreenLayout(
         val arrowIndicatorHalfWidth = arrowIndicatorWidth.value / 2
         val popupPadding = Pixels(CFRPopup.DEFAULT_EXTRA_HORIZONTAL_PADDING.dp.toPx())
         val leftInsets = Pixels(getLeftInsets())
+        val popupWidth = Pixels(properties.popupWidth.toPx())
 
         return if (layoutDirection == View.LAYOUT_DIRECTION_LTR) {
             var startCoord = when (properties.popupAlignment) {
@@ -255,8 +256,11 @@ internal class CFRPopupFullscreenLayout(
                     Pixels(anchor.x.roundToInt() + leftInsets.value)
                 }
                 BODY_TO_ANCHOR_CENTER -> {
-                    val popupWidth = (properties.popupWidth + CFRPopup.DEFAULT_EXTRA_HORIZONTAL_PADDING.dp).toPx()
-                    Pixels(((anchor.x.roundToInt() + anchor.width) - popupWidth) / 2)
+                    Pixels(
+                        anchor.x.roundToInt()
+                            .plus((anchor.width - popupWidth.value) / 2)
+                            .plus(leftInsets.value),
+                    )
                 }
                 INDICATOR_CENTERED_IN_ANCHOR -> {
                     // Push the popup as far to the start as needed including any needed paddings.
@@ -272,7 +276,7 @@ internal class CFRPopupFullscreenLayout(
                 INDICATOR_CENTERED_IN_ANCHOR -> {
                     var maybeEndCoord = Pixels(
                         startCoord.value
-                            .plus(properties.popupWidth.toPx())
+                            .plus(popupWidth.value)
                             .plus(popupPadding.value),
                     )
                     // Handle the scenario in which the popup would get pass the end of the screen.
@@ -292,7 +296,7 @@ internal class CFRPopupFullscreenLayout(
                 else -> {
                     Pixels(
                         startCoord.value
-                            .plus(properties.popupWidth.toPx())
+                            .plus(popupWidth.value)
                             .plus(popupPadding.value)
                             .coerceAtMost(screenWidth.value + leftInsets.value),
                     )
@@ -309,8 +313,12 @@ internal class CFRPopupFullscreenLayout(
                     Pixels(anchor.x.roundToInt() + anchor.width + leftInsets.value)
                 }
                 BODY_TO_ANCHOR_CENTER -> {
-                    val popupWidth = (properties.popupWidth + CFRPopup.DEFAULT_EXTRA_HORIZONTAL_PADDING.dp).toPx()
-                    Pixels(screenWidth.value - ((anchor.x.roundToInt() + anchor.width) - popupWidth) / 2)
+                    val anchorEndCoord = anchor.x.roundToInt() + anchor.width
+                    Pixels(
+                        anchorEndCoord
+                            .minus((anchor.width - popupWidth.value) / 2)
+                            .plus(leftInsets.value),
+                    )
                 }
                 INDICATOR_CENTERED_IN_ANCHOR -> {
                     Pixels(
@@ -327,7 +335,7 @@ internal class CFRPopupFullscreenLayout(
                 INDICATOR_CENTERED_IN_ANCHOR -> {
                     var maybeEndCoord = Pixels(
                         startCoord.value
-                            .minus(properties.popupWidth.toPx())
+                            .minus(popupWidth.value)
                             .minus(popupPadding.value),
                     )
                     val endCoordOverflow = leftInsets.value - maybeEndCoord.value
@@ -347,7 +355,7 @@ internal class CFRPopupFullscreenLayout(
                 else -> {
                     Pixels(
                         startCoord.value
-                            .minus(properties.popupWidth.toPx())
+                            .minus(popupWidth.value)
                             .minus(popupPadding.value)
                             .coerceAtLeast(leftInsets.value),
                     )
diff --git a/android-components/components/compose/cfr/src/test/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayoutTest.kt b/android-components/components/compose/cfr/src/test/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayoutTest.kt
index d7bb6212f048..59d047ae14c2 100644
--- a/android-components/components/compose/cfr/src/test/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayoutTest.kt
+++ b/android-components/components/compose/cfr/src/test/java/mozilla/components/compose/cfr/CFRPopupFullscreenLayoutTest.kt
@@ -344,4 +344,96 @@ class CFRPopupFullscreenLayoutTest {
         assertEquals(600, result.startCoord.value)
         assertEquals(390, result.endCoord.value)
     }
+
+    @Test
+    fun `GIVEN LTR and BODY_TO_ANCHOR_CENTER WHEN computing popup bounds THEN return the right X coordinates`() {
+        val anchor = spy(View(testContext))
+        doReturn(600).`when`(anchor).width
+        doReturn(200f).`when`(anchor).x
+        val properties = CFRPopupProperties(
+            popupWidth = 400.dp,
+            popupAlignment = PopupAlignment.BODY_TO_ANCHOR_CENTER,
+            indicatorArrowStartOffset = 0.dp,
+        )
+        val popupView = CFRPopupFullscreenLayout(anchor, properties, mock(), { }, { })
+
+        val result = popupView.computePopupHorizontalBounds(
+            anchorMiddleXCoord = Pixels(400),
+            arrowIndicatorWidth = Pixels(20),
+            screenWidth = Pixels(1000),
+            layoutDirection = View.LAYOUT_DIRECTION_LTR,
+        )
+
+        assertEquals(300, result.startCoord.value)
+        assertEquals(710, result.endCoord.value)
+    }
+
+    @Test
+    fun `GIVEN LTR and BODY_TO_ANCHOR_CENTER WHEN computing popup bounds THEN return the right X coordinates and don't account for the provided indicator offset`() {
+        val anchor = spy(View(testContext))
+        doReturn(600).`when`(anchor).width
+        doReturn(200f).`when`(anchor).x
+        val properties = CFRPopupProperties(
+            popupWidth = 400.dp,
+            popupAlignment = PopupAlignment.BODY_TO_ANCHOR_CENTER,
+            indicatorArrowStartOffset = 50.dp,
+        )
+        val popupView = CFRPopupFullscreenLayout(anchor, properties, mock(), { }, { })
+
+        val result = popupView.computePopupHorizontalBounds(
+            anchorMiddleXCoord = Pixels(400),
+            arrowIndicatorWidth = Pixels(20),
+            screenWidth = Pixels(1000),
+            layoutDirection = View.LAYOUT_DIRECTION_LTR,
+        )
+
+        assertEquals(300, result.startCoord.value)
+        assertEquals(710, result.endCoord.value)
+    }
+
+    @Test
+    fun `GIVEN RTL and BODY_TO_ANCHOR_CENTER WHEN computing popup bounds THEN return the right X coordinates`() {
+        val anchor = spy(View(testContext))
+        doReturn(600).`when`(anchor).width
+        doReturn(200f).`when`(anchor).x
+        val properties = CFRPopupProperties(
+            popupWidth = 400.dp,
+            popupAlignment = PopupAlignment.BODY_TO_ANCHOR_CENTER,
+            indicatorArrowStartOffset = 0.dp,
+        )
+        val popupView = CFRPopupFullscreenLayout(anchor, properties, mock(), { }, { })
+
+        val result = popupView.computePopupHorizontalBounds(
+            anchorMiddleXCoord = Pixels(300),
+            arrowIndicatorWidth = Pixels(20),
+            screenWidth = Pixels(1000),
+            layoutDirection = View.LAYOUT_DIRECTION_RTL,
+        )
+
+        assertEquals(700, result.startCoord.value)
+        assertEquals(290, result.endCoord.value)
+    }
+
+    @Test
+    fun `GIVEN RTL and BODY_TO_ANCHOR_CENTER WHEN computing popup bounds THEN return the right X coordinates and don't account for the provided indicator offset`() {
+        val anchor = spy(View(testContext))
+        doReturn(600).`when`(anchor).width
+        doReturn(200f).`when`(anchor).x
+        val properties = CFRPopupProperties(
+            popupWidth = 400.dp,
+            popupAlignment = PopupAlignment.BODY_TO_ANCHOR_CENTER,
+            indicatorArrowStartOffset = 50.dp,
+        )
+        val popupView = CFRPopupFullscreenLayout(anchor, properties, mock(), { }, { })
+
+        val result = popupView.computePopupHorizontalBounds(
+            anchorMiddleXCoord = Pixels(300),
+            arrowIndicatorWidth = Pixels(20),
+            screenWidth = Pixels(1000),
+            layoutDirection = View.LAYOUT_DIRECTION_RTL,
+        )
+
+        assertEquals(700, result.startCoord.value)
+        assertEquals(290, result.endCoord.value)
+    }
 }
diff --git a/docs/changelog.md b/docs/changelog.md
index 85816ba8f1bf..d49413c61479 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -9,6 +9,9 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/firefox-android/blob/main/android-components/plugins/dependencies/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/firefox-android/blob/main/android-components/.config.yml)
 
+* **compose-cfr**
+  * ðŸš’ Bug fixed [bug #1809592](https://bugzilla.mozilla.org/show_bug.cgi?id=1809592). Improve screen alignment for Contextual Feature Recommendation popups.
+
 * **service-pocket**
   * ðŸŒŸ Added `country` and `city` parameters to Pocket sponsored stories fetch request. These can be overwritten using `PocketStoriesConfig`, allowing clients to specify a location and receive sponsored stories when outside countries where Pocket is enabled based on IP location. [Bug 1811537](https://bugzilla.mozilla.org/show_bug.cgi?id=1811537).
 
