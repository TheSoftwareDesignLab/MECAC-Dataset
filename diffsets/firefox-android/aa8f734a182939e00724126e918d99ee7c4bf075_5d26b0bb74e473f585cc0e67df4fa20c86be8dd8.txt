diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index f86b1299841f..74687dcdeeb0 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -89,13 +89,17 @@ projects:
     description: 'Feature implementation for Progressive Web Apps (PWA).'
     publish: true
   feature-findinpage:
-      path: components/feature/findinpage
-      description: 'Feature that will subscribe to the selected session and show an UI for results of find in page.'
-      publish: true
+    path: components/feature/findinpage
+    description: 'Feature that will subscribe to the selected session and show an UI for results of find in page.'
+    publish: true
   feature-sitepermissions:
     path: components/feature/sitepermissions
     description: 'A feature for showing site permission request prompts.'
     publish: true
+  feature-qr:
+    path: components/feature/qr
+    description: 'A feature that provides functionality for scanning QR codes.'
+    publish: true
   browser-awesomebar:
     path: components/browser/awesomebar
     description: 'A customizable awesomebar component for browsers.'
diff --git a/android-components/README.md b/android-components/README.md
index f635f16db2b2..9af80a9fd900 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -118,6 +118,8 @@ _Combined components to implement feature-specific use cases._
 
 * ðŸ”´ [**Progressive Web Apps (PWA)**](components/feature/pwa/README.md) - A component that provides functionality for supporting Progressive Web Apps (PWA).
 
+* âšª [**QR**](components/feature/qr/README.md) - A component that provides functionality for scanning QR codes.
+
 * ðŸ”´ [**Search**](components/feature/search/README.md) - A component that connects an (concept) engine implementation with the browser search module.
 
 * âšª [**Session**](components/feature/session/README.md) - A component that connects an (concept) engine implementation with the browser session and storage modules.
diff --git a/android-components/buildSrc/src/main/java/Dependencies.kt b/android-components/buildSrc/src/main/java/Dependencies.kt
index ccc5ce396510..97facdacedb0 100644
--- a/android-components/buildSrc/src/main/java/Dependencies.kt
+++ b/android-components/buildSrc/src/main/java/Dependencies.kt
@@ -32,6 +32,7 @@ object Versions {
 
     const val room = "1.1.1"
     const val paging = "1.0.1"
+    const val zxing = "3.3.0"
 
     const val mozilla_appservices = "0.22.0"
     const val servo = "0.0.1.20181017.aa95911"
@@ -94,4 +95,5 @@ object Dependencies {
     const val thirdparty_okhttp = "com.squareup.okhttp3:okhttp:${Versions.okhttp}"
     const val thirdparty_okhttp_urlconnection = "com.squareup.okhttp3:okhttp-urlconnection:${Versions.okhttp}"
     const val thirdparty_sentry = "io.sentry:sentry-android:${Versions.sentry}"
+    const val thirdparty_zxing = "com.google.zxing:core:${Versions.zxing}"
 }
diff --git a/android-components/components/feature/qr/README.md b/android-components/components/feature/qr/README.md
new file mode 100644
index 000000000000..531cd6f8e445
--- /dev/null
+++ b/android-components/components/feature/qr/README.md
@@ -0,0 +1,42 @@
+# [Android Components](../../../README.md) > Libraries > QR
+
+A component that provides functionality for scanning QR coes.
+
+## Usage
+
+### Setting up the dependency
+
+Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
+
+```Groovy
+implementation "org.mozilla.components:feature-qr:{latest-version}"
+```
+
+### Integration
+
+Initializing the feature:
+
+```kotlin
+qrFeature = QrFeature(
+    context,
+    fragmentManager = supportFragmentManager,
+    onNeedToRequestPermissions = { permissions ->
+        requestPermissions(this, permissions, REQUEST_CODE_CAMERA_PERMISSIONS)
+    },
+    onScanResult = { result ->
+        // result is a String (e.g. a URL) returned by the QR scanner.
+    }
+)
+```
+
+When ready to scan use the following:
+
+```kotlin
+qrFeature.scan()
+```
+
+## License
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/feature/qr/build.gradle b/android-components/components/feature/qr/build.gradle
new file mode 100644
index 000000000000..06b4f4aa3ff7
--- /dev/null
+++ b/android-components/components/feature/qr/build.gradle
@@ -0,0 +1,47 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-android-extensions'
+
+android {
+    compileSdkVersion config.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion config.minSdkVersion
+        targetSdkVersion config.targetSdkVersion
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
+
+    implementation Dependencies.support_appcompat
+
+    implementation project(':support-ktx')
+    implementation project(':support-base')
+
+    implementation Dependencies.thirdparty_zxing
+    testImplementation Dependencies.thirdparty_zxing
+
+    testImplementation project(':support-test')
+    testImplementation Dependencies.androidx_test_core
+    testImplementation Dependencies.testing_junit
+    testImplementation Dependencies.testing_robolectric
+    testImplementation Dependencies.testing_mockito
+}
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
diff --git a/android-components/components/feature/qr/proguard-rules.pro b/android-components/components/feature/qr/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/feature/qr/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/feature/qr/src/main/AndroidManifest.xml b/android-components/components/feature/qr/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..36a1a54a530e
--- /dev/null
+++ b/android-components/components/feature/qr/src/main/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
+   - You can obtain one at http://mozilla.org/MPL/2.0/.  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="mozilla.components.feature.qr">
+
+    <uses-permission android:name="android.permission.CAMERA" />
+</manifest>
diff --git a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt
new file mode 100644
index 000000000000..869892c50c36
--- /dev/null
+++ b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFeature.kt
@@ -0,0 +1,115 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.qr
+
+import android.Manifest.permission.CAMERA
+import android.content.Context
+import android.support.annotation.MainThread
+import android.support.annotation.VisibleForTesting
+import android.support.v4.app.FragmentManager
+import mozilla.components.support.base.feature.BackHandler
+import mozilla.components.support.base.feature.LifecycleAwareFeature
+import mozilla.components.support.ktx.android.content.isPermissionGranted
+
+typealias OnScanResult = (result: String) -> Unit
+typealias OnNeedToRequestPermissions = (permissions: Array<String>) -> Unit
+
+/**
+ * Feature implementation that provides QR scanning functionality via the [QrFragment].
+ *
+ * @property context a reference to the context.
+ * @property fragmentManager a reference to a [FragmentManager], used to start
+ * the [QrFragment].
+ * @property onScanResult a callback invoked with the result of the QR scan.
+ * The callback will always be invoked on the main thread.
+ * @property onNeedToRequestPermissions a callback invoked when permissions
+ * need to be requested before a QR scan can be performed. Once the request
+ * is completed, [onPermissionsResult] needs to be invoked. This feature
+ * will request [android.Manifest.permission.CAMERA].
+ */
+class QrFeature(
+    private val context: Context,
+    private val fragmentManager: FragmentManager,
+    private val onScanResult: OnScanResult = { },
+    private val onNeedToRequestPermissions: OnNeedToRequestPermissions = { }
+) : LifecycleAwareFeature, BackHandler {
+    private var containerViewId: Int = 0
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal val scanCompleteListener: QrFragment.OnScanCompleteListener = object : QrFragment.OnScanCompleteListener {
+        @MainThread
+        override fun onScanComplete(result: String) {
+            removeQrFragment()
+            onScanResult(result)
+        }
+    }
+
+    override fun start() {
+        (fragmentManager.findFragmentByTag(QR_FRAGMENT_TAG) as? QrFragment)?.let {
+            it.scanCompleteListener = scanCompleteListener
+        }
+    }
+
+    override fun stop() {
+        // Nothing to do here for now.
+    }
+
+    override fun onBackPressed(): Boolean {
+        return removeQrFragment()
+    }
+
+    /**
+     * Starts the QR scanner fragment and listens for scan results.
+     *
+     * @param containerViewId optional id of the container this fragment is to
+     * be placed in, defaults to [android.R.id.content].
+     *
+     * @return true if the scanner was started or false if permissions still
+     * need to be requested.
+     */
+    fun scan(containerViewId: Int = android.R.id.content): Boolean {
+        this.containerViewId = containerViewId
+
+        return if (context.isPermissionGranted(CAMERA)) {
+            fragmentManager.beginTransaction()
+                .add(containerViewId, QrFragment.newInstance(scanCompleteListener), QR_FRAGMENT_TAG)
+                .commit()
+            true
+        } else {
+            onNeedToRequestPermissions(arrayOf(CAMERA))
+            false
+        }
+    }
+
+    /**
+     * Notifies the feature that the permission request was completed. If the
+     * requested permissions were granted it will open the QR scanner.
+     */
+    @Suppress("UNUSED_PARAMETER")
+    fun onPermissionsResult(permissions: Array<String>, grantResults: IntArray) {
+        if (context.isPermissionGranted(CAMERA)) {
+            this.scan(containerViewId)
+        }
+    }
+
+    /**
+     * Removes the QR fragment.
+     *
+     * @return true if the fragment was removed, otherwise false.
+     */
+    internal fun removeQrFragment(): Boolean {
+        with(fragmentManager) {
+            findFragmentByTag(QR_FRAGMENT_TAG)?.let {
+                beginTransaction().remove(it).commit()
+                return true
+            }
+        }
+        return false
+    }
+
+    companion object {
+        internal const val QR_FRAGMENT_TAG = "MOZAC_QR_FRAGMENT"
+    }
+}
diff --git a/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt
new file mode 100644
index 000000000000..6bda0b4a96c2
--- /dev/null
+++ b/android-components/components/feature/qr/src/main/java/mozilla/components/feature/qr/QrFragment.kt
@@ -0,0 +1,548 @@
+/*
+ * Copyright 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. */
+
+package mozilla.components.feature.qr
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.res.Configuration
+import android.graphics.ImageFormat
+import android.graphics.Matrix
+import android.graphics.Point
+import android.graphics.RectF
+import android.graphics.SurfaceTexture
+import android.hardware.camera2.CameraCaptureSession
+import android.hardware.camera2.CameraCharacteristics
+import android.hardware.camera2.CameraDevice
+import android.hardware.camera2.CameraManager
+import android.hardware.camera2.CaptureRequest
+import android.media.Image
+import android.media.ImageReader
+import android.os.AsyncTask
+import android.os.Bundle
+import android.os.Handler
+import android.os.HandlerThread
+import android.os.Looper
+import android.support.v4.app.Fragment
+import android.util.Size
+import android.view.LayoutInflater
+import android.view.Surface
+import android.view.TextureView
+import android.view.View
+import android.view.ViewGroup
+
+import com.google.zxing.BinaryBitmap
+import com.google.zxing.MultiFormatReader
+import com.google.zxing.NotFoundException
+import com.google.zxing.PlanarYUVLuminanceSource
+import com.google.zxing.common.HybridBinarizer
+import mozilla.components.support.base.android.view.AutoFitTextureView
+import mozilla.components.support.base.log.Log
+import java.io.Serializable
+import java.lang.IllegalStateException
+
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Collections
+import java.util.Comparator
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+
+/**
+ * A [Fragment] that displays a QR scanner.
+ *
+ * This class is based on Camera2BasicFragment from:
+ *
+ * https://github.com/googlesamples/android-Camera2Basic
+ * https://github.com/kismkof/camera2basic
+ */
+@Suppress("TooManyFunctions")
+class QrFragment : Fragment() {
+    /**
+     * [TextureView.SurfaceTextureListener] handles several lifecycle events on a [TextureView].
+     */
+    private val surfaceTextureListener = object : TextureView.SurfaceTextureListener {
+
+        override fun onSurfaceTextureAvailable(texture: SurfaceTexture, width: Int, height: Int) {
+            openCamera(width, height)
+        }
+
+        override fun onSurfaceTextureSizeChanged(texture: SurfaceTexture, width: Int, height: Int) {
+            configureTransform(width, height)
+        }
+
+        override fun onSurfaceTextureUpdated(texture: SurfaceTexture) { }
+
+        override fun onSurfaceTextureDestroyed(texture: SurfaceTexture): Boolean {
+            return true
+        }
+    }
+
+    internal lateinit var textureView: AutoFitTextureView
+    private var cameraId: String? = null
+    private var captureSession: CameraCaptureSession? = null
+    internal var cameraDevice: CameraDevice? = null
+    private var previewSize: Size? = null
+
+    /**
+     * Listener invoked when the QR scan completed successfully.
+     */
+    interface OnScanCompleteListener : Serializable {
+        /**
+         * Invoked to provide access to the result of the QR scan.
+         */
+        fun onScanComplete(result: String)
+    }
+
+    @Volatile internal var scanCompleteListener: OnScanCompleteListener? = null
+        set(value) {
+            field = object : OnScanCompleteListener {
+                override fun onScanComplete(result: String) {
+                    Handler(Looper.getMainLooper()).apply {
+                        post {
+                            value?.onScanComplete(result)
+                        }
+                    }
+                }
+            }
+        }
+
+    /**
+     * [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.
+     */
+    internal val stateCallback = object : CameraDevice.StateCallback() {
+
+        override fun onOpened(cameraDevice: CameraDevice) {
+            cameraOpenCloseLock.release()
+            this@QrFragment.cameraDevice = cameraDevice
+            createCameraPreviewSession()
+        }
+
+        override fun onDisconnected(cameraDevice: CameraDevice) {
+            cameraOpenCloseLock.release()
+            cameraDevice.close()
+            this@QrFragment.cameraDevice = null
+        }
+
+        override fun onError(cameraDevice: CameraDevice, error: Int) {
+            cameraOpenCloseLock.release()
+            cameraDevice.close()
+            this@QrFragment.cameraDevice = null
+        }
+    }
+
+    /**
+     * An additional thread for running tasks that shouldn't block the UI.
+     * A [Handler] for running tasks in the background.
+     */
+    private var backgroundThread: HandlerThread? = null
+    private var backgroundHandler: Handler? = null
+    private var previewRequestBuilder: CaptureRequest.Builder? = null
+    private var previewRequest: CaptureRequest? = null
+
+    /**
+     * A [Semaphore] to prevent the app from exiting before closing the camera.
+     */
+    private val cameraOpenCloseLock = Semaphore(1)
+
+    /**
+     * Orientation of the camera sensor
+     */
+    private var sensorOrientation: Int = 0
+
+    /**
+     * An [ImageReader] that handles still image capture.
+     * This is the output file for our picture.
+     */
+    private var imageReader: ImageReader? = null
+    private var data: ByteArray? = null
+    private val imageAvailableListener = object : ImageReader.OnImageAvailableListener {
+
+        private var image: Image? = null
+
+        override fun onImageAvailable(reader: ImageReader) {
+            try {
+                image = reader.acquireNextImage()
+                val availableImage = image
+                if (availableImage != null) {
+                    val buffer = availableImage.planes[0].buffer
+                    data = ByteArray(buffer.remaining())
+                    buffer.get(data)
+                    val width = availableImage.width
+                    val height = availableImage.height
+                    val source = PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false)
+                    val bitmap = BinaryBitmap(HybridBinarizer(source))
+                    if (qrState == STATE_FIND_QRCODE) {
+                        qrState = STATE_DECODE_PROGRESS
+                        AsyncScanningTask(scanCompleteListener).execute(bitmap)
+                    }
+                }
+            } finally {
+                image?.close()
+            }
+        }
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        return inflater.inflate(R.layout.fragment_layout, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        textureView = view.findViewById<View>(R.id.texture) as AutoFitTextureView
+        qrState = STATE_FIND_QRCODE
+    }
+
+    override fun onResume() {
+        super.onResume()
+        startBackgroundThread()
+        // When the screen is turned off and turned back on, the SurfaceTexture is already
+        // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
+        // a camera and start preview from here (otherwise, we wait until the surface is ready in
+        // the SurfaceTextureListener).
+        if (textureView.isAvailable) {
+            openCamera(textureView.width, textureView.height)
+        } else {
+            textureView.surfaceTextureListener = surfaceTextureListener
+        }
+    }
+
+    override fun onPause() {
+        closeCamera()
+        stopBackgroundThread()
+        super.onPause()
+    }
+
+    internal fun startBackgroundThread() {
+        backgroundThread = HandlerThread("CameraBackground").apply {
+            start()
+            backgroundHandler = Handler(this.looper)
+        }
+    }
+
+    internal fun stopBackgroundThread() {
+        backgroundThread?.quitSafely()
+        try {
+            backgroundThread?.join()
+            backgroundThread = null
+            backgroundHandler = null
+        } catch (e: InterruptedException) {
+            Log.log(Log.Priority.DEBUG, "mozac-qr", e, "Interrupted while stopping background thread")
+        }
+    }
+
+    /**
+     * Sets up member variables related to camera.
+     *
+     * @param width The width of available size for camera preview
+     * @param height The height of available size for camera preview
+     */
+    @Suppress("ComplexMethod", "MagicNumber")
+    internal fun setUpCameraOutputs(width: Int, height: Int) {
+        val manager = activity?.getSystemService(Context.CAMERA_SERVICE) as CameraManager? ?: return
+
+        for (cameraId in manager.cameraIdList) {
+            val characteristics = manager.getCameraCharacteristics(cameraId)
+
+            val facing = characteristics.get(CameraCharacteristics.LENS_FACING)
+            if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {
+                continue
+            }
+
+            val map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP) ?: continue
+            val largest = Collections.max(map.getOutputSizes(ImageFormat.YUV_420_888).asList(), CompareSizesByArea())
+            imageReader = ImageReader.newInstance(MAX_PREVIEW_WIDTH, MAX_PREVIEW_HEIGHT, ImageFormat.YUV_420_888, 2)
+                .apply { setOnImageAvailableListener(imageAvailableListener, backgroundHandler) }
+
+            // Find out if we need to swap dimension to get the preview size relative to sensor coordinate.
+            val displayRotation = activity?.windowManager?.defaultDisplay?.rotation
+
+            sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION) as Int
+            var swappedDimensions = false
+            when (displayRotation) {
+                Surface.ROTATION_0, Surface.ROTATION_180 -> if (sensorOrientation == 90 || sensorOrientation == 270) {
+                    swappedDimensions = true
+                }
+                Surface.ROTATION_90, Surface.ROTATION_270 -> if (sensorOrientation == 0 || sensorOrientation == 180) {
+                    swappedDimensions = true
+                }
+            }
+
+            val displaySize = Point()
+            activity?.windowManager?.defaultDisplay?.getSize(displaySize)
+            var rotatedPreviewWidth = width
+            var rotatedPreviewHeight = height
+            var maxPreviewWidth = displaySize.x
+            var maxPreviewHeight = displaySize.y
+
+            if (swappedDimensions) {
+                rotatedPreviewWidth = height
+                rotatedPreviewHeight = width
+                maxPreviewWidth = displaySize.y
+                maxPreviewHeight = displaySize.x
+            }
+
+            if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {
+                maxPreviewWidth = MAX_PREVIEW_WIDTH
+            }
+
+            if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
+                maxPreviewHeight = MAX_PREVIEW_HEIGHT
+            }
+
+            previewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture::class.java),
+                    rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
+                    maxPreviewHeight, largest)
+
+            val size = previewSize as Size
+            // We fit the aspect ratio of TextureView to the size of preview we picked.
+            val orientation = resources.configuration.orientation
+            if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
+                textureView.setAspectRatio(size.width, size.height)
+            } else {
+                textureView.setAspectRatio(size.height, size.width)
+            }
+
+            this.cameraId = cameraId
+            return
+        }
+    }
+
+    /**
+     * Opens the camera specified by [QrFragment.cameraId].
+     */
+    @SuppressLint("MissingPermission")
+    internal fun openCamera(width: Int, height: Int) {
+        setUpCameraOutputs(width, height)
+        configureTransform(width, height)
+
+        val activity = activity
+        val manager = activity?.getSystemService(Context.CAMERA_SERVICE) as CameraManager?
+        try {
+            if (!cameraOpenCloseLock.tryAcquire(CAMERA_CLOSE_LOCK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
+                throw IllegalStateException("Time out waiting to lock camera opening.")
+            }
+            manager?.openCamera(cameraId as String, stateCallback, backgroundHandler)
+        } catch (e: InterruptedException) {
+            throw IllegalStateException("Interrupted while trying to lock camera opening.", e)
+        }
+    }
+
+    /**
+     * Closes the current [CameraDevice].
+     */
+    internal fun closeCamera() {
+        try {
+            cameraOpenCloseLock.acquire()
+            captureSession?.close()
+            captureSession = null
+            cameraDevice?.close()
+            cameraDevice = null
+            imageReader?.close()
+            imageReader = null
+        } catch (e: InterruptedException) {
+            throw IllegalStateException("Interrupted while trying to lock camera closing.", e)
+        } finally {
+            cameraOpenCloseLock.release()
+        }
+    }
+
+    /**
+     * Configures the necessary [android.graphics.Matrix] transformation to `textureView`.
+     * This method should be called after the camera preview size is determined in
+     * setUpCameraOutputs and also the size of `textureView` is fixed.
+     *
+     * @param viewWidth The width of `textureView`
+     * @param viewHeight The height of `textureView`
+     */
+    @Suppress("MagicNumber")
+    private fun configureTransform(viewWidth: Int, viewHeight: Int) {
+        val activity = activity
+        if (null == previewSize || null == activity) {
+            return
+        }
+        val size = previewSize as Size
+        val rotation = activity.windowManager.defaultDisplay.rotation
+        val matrix = Matrix()
+        val viewRect = RectF(0f, 0f, viewWidth.toFloat(), viewHeight.toFloat())
+        val bufferRect = RectF(0f, 0f, size.height.toFloat(), size.width.toFloat())
+        val centerX = viewRect.centerX()
+        val centerY = viewRect.centerY()
+        if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {
+            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY())
+            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL)
+            val scale = Math.max(viewHeight.toFloat() / size.height, viewWidth.toFloat() / size.width)
+            matrix.postScale(scale, scale, centerX, centerY)
+            matrix.postRotate((90 * (rotation - 2)).toFloat(), centerX, centerY)
+        } else if (Surface.ROTATION_180 == rotation) {
+            matrix.postRotate(180f, centerX, centerY)
+        }
+        textureView.setTransform(matrix)
+    }
+
+    /**
+     * Creates a new [CameraCaptureSession] for camera preview.
+     */
+    private fun createCameraPreviewSession() {
+        val texture = textureView.surfaceTexture
+
+        val size = previewSize as Size
+        // We configure the size of default buffer to be the size of camera preview we want.
+        texture.setDefaultBufferSize(size.width, size.height)
+
+        val surface = Surface(texture)
+        val mImageSurface = imageReader?.surface
+        cameraDevice?.let {
+            previewRequestBuilder = it.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW).apply {
+                addTarget(mImageSurface as Surface)
+                addTarget(surface)
+            }
+
+            it.createCaptureSession(Arrays.asList(mImageSurface, surface),
+                object : CameraCaptureSession.StateCallback() {
+
+                    override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {
+                        if (null == cameraDevice) return
+
+                        previewRequestBuilder?.set(CaptureRequest.CONTROL_AF_MODE,
+                                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
+
+                        previewRequest = previewRequestBuilder?.build()
+
+                        captureSession = cameraCaptureSession
+                        cameraCaptureSession.setRepeatingRequest(previewRequest as CaptureRequest,
+                            object : CameraCaptureSession.CaptureCallback() {},
+                            backgroundHandler
+                        )
+                    }
+
+                    override fun onConfigureFailed(cameraCaptureSession: CameraCaptureSession) {
+                        Log.log(Log.Priority.ERROR, "mozac-qr", message = "Failed to configure CameraCaptureSession")
+                    }
+                }, null
+            )
+        }
+    }
+
+    /**
+     * Compares two `Size`s based on their areas.
+     */
+    internal class CompareSizesByArea : Comparator<Size> {
+        override fun compare(lhs: Size, rhs: Size): Int {
+            return java.lang.Long.signum(lhs.width.toLong() * lhs.height - rhs.width.toLong() * rhs.height)
+        }
+    }
+
+    companion object {
+        internal const val STATE_FIND_QRCODE = 0
+        internal const val STATE_DECODE_PROGRESS = 1
+        internal const val STATE_QRCODE_EXIST = 2
+
+        internal const val MAX_PREVIEW_WIDTH = 1920
+        internal const val MAX_PREVIEW_HEIGHT = 1080
+
+        private const val CAMERA_CLOSE_LOCK_TIMEOUT_MS = 2500L
+
+        fun newInstance(listener: OnScanCompleteListener): QrFragment {
+            return QrFragment().apply {
+                scanCompleteListener = listener
+            }
+        }
+
+        /**
+         * Given `choices` of `Size`s supported by a camera, choose the smallest one that
+         * is at least as large as the respective texture view size, and that is at most as large as the
+         * respective max size, and whose aspect ratio matches with the specified value. If such size
+         * doesn't exist, choose the largest one that is at most as large as the respective max size,
+         * and whose aspect ratio matches with the specified value.
+         *
+         * @param choices The list of sizes that the camera supports for the intended output class
+         * @param textureViewWidth The width of the texture view relative to sensor coordinate
+         * @param textureViewHeight The height of the texture view relative to sensor coordinate
+         * @param maxWidth The maximum width that can be chosen
+         * @param maxHeight The maximum height that can be chosen
+         * @param aspectRatio The aspect ratio
+         * @return The optimal `Size`, or an arbitrary one if none were big enough.
+         */
+        @Suppress("LongParameterList")
+        internal fun chooseOptimalSize(
+            choices: Array<Size>,
+            textureViewWidth: Int,
+            textureViewHeight: Int,
+            maxWidth: Int,
+            maxHeight: Int,
+            aspectRatio: Size
+        ): Size {
+
+            // Collect the supported resolutions that are at least as big as the preview Surface
+            val bigEnough = ArrayList<Size>()
+            // Collect the supported resolutions that are smaller than the preview Surface
+            val notBigEnough = ArrayList<Size>()
+            val w = aspectRatio.width
+            val h = aspectRatio.height
+            for (option in choices) {
+                if (option.width <= maxWidth && option.height <= maxHeight &&
+                        option.height == option.width * h / w) {
+                    if (option.width >= textureViewWidth && option.height >= textureViewHeight) {
+                        bigEnough.add(option)
+                    } else {
+                        notBigEnough.add(option)
+                    }
+                }
+            }
+
+            // Pick the smallest of those big enough. If there is no one big enough, pick the
+            // largest of those not big enough.
+            return when {
+                bigEnough.size > 0 -> Collections.min(bigEnough, CompareSizesByArea())
+                notBigEnough.size > 0 -> Collections.max(notBigEnough, CompareSizesByArea())
+                else -> choices[0]
+            }
+        }
+
+        @Volatile internal var qrState: Int = 0
+    }
+
+    internal class AsyncScanningTask(
+        private val scanCompleteListener: OnScanCompleteListener?,
+        private val multiFormatReader: MultiFormatReader = MultiFormatReader()
+    ) : AsyncTask<BinaryBitmap, Void, Void>() {
+
+        override fun doInBackground(vararg bitmaps: BinaryBitmap): Void? {
+            return processImage(bitmaps[0])
+        }
+
+        @Suppress("MagicNumber")
+        fun processImage(bitmap: BinaryBitmap): Void? {
+            if (qrState != STATE_DECODE_PROGRESS) {
+                return null
+            }
+
+            try {
+                val image = bitmap.crop(bitmap.width / 4, bitmap.height / 4, bitmap.width / 2, bitmap.height / 2)
+                val rawResult = multiFormatReader.decodeWithState(image)
+                if (rawResult != null) {
+                    qrState = STATE_QRCODE_EXIST
+                    scanCompleteListener?.onScanComplete(rawResult.toString())
+                }
+            } catch (e: NotFoundException) {
+                qrState = STATE_FIND_QRCODE
+            } finally {
+                multiFormatReader.reset()
+            }
+
+            return null
+        }
+    }
+}
diff --git a/android-components/components/feature/qr/src/main/res/drawable-hdpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-hdpi/qr_cam_focus.png
new file mode 100755
index 000000000000..fbe2f518acd7
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-hdpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/drawable-ldpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-ldpi/qr_cam_focus.png
new file mode 100755
index 000000000000..743d53207aba
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-ldpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/drawable-mdpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-mdpi/qr_cam_focus.png
new file mode 100755
index 000000000000..bc49ec7ad487
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-mdpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/drawable-xhdpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-xhdpi/qr_cam_focus.png
new file mode 100755
index 000000000000..efc58327d727
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-xhdpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/drawable-xxhdpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-xxhdpi/qr_cam_focus.png
new file mode 100755
index 000000000000..195c12d8a602
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-xxhdpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/drawable-xxxhdpi/qr_cam_focus.png b/android-components/components/feature/qr/src/main/res/drawable-xxxhdpi/qr_cam_focus.png
new file mode 100755
index 000000000000..d99e291c6665
Binary files /dev/null and b/android-components/components/feature/qr/src/main/res/drawable-xxxhdpi/qr_cam_focus.png differ
diff --git a/android-components/components/feature/qr/src/main/res/layout/fragment_layout.xml b/android-components/components/feature/qr/src/main/res/layout/fragment_layout.xml
new file mode 100644
index 000000000000..0657024f4057
--- /dev/null
+++ b/android-components/components/feature/qr/src/main/res/layout/fragment_layout.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@android:color/background_dark"
+    tools:ignore="Overdraw">
+
+    <mozilla.components.support.base.android.view.AutoFitTextureView
+        android:id="@+id/texture"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_centerInParent="true" />
+
+    <ImageView
+        android:contentDescription="@string/mozac_feature_qr_scanner"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:src="@drawable/qr_cam_focus"
+        android:layout_centerInParent="true" />
+
+</RelativeLayout>
diff --git a/android-components/components/feature/qr/src/main/res/values/strings.xml b/android-components/components/feature/qr/src/main/res/values/strings.xml
new file mode 100644
index 000000000000..845027f82187
--- /dev/null
+++ b/android-components/components/feature/qr/src/main/res/values/strings.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<resources>
+
+    <!-- Content description (not visible, for screen readers etc.): Description of an image view. -->
+    <string name="mozac_feature_qr_scanner">QR scanner</string>
+
+</resources>
diff --git a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt
new file mode 100644
index 000000000000..9de8e4b3adc6
--- /dev/null
+++ b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFeatureTest.kt
@@ -0,0 +1,140 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.qr
+
+import android.Manifest
+import android.content.Context
+import android.content.pm.PackageManager
+import android.support.v4.app.FragmentManager
+import android.support.v4.app.FragmentTransaction
+import androidx.test.core.app.ApplicationProvider
+import mozilla.components.feature.qr.QrFeature.Companion.QR_FRAGMENT_TAG
+import mozilla.components.support.test.any
+import org.junit.Assert.assertTrue
+import mozilla.components.support.test.robolectric.grantPermission
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.anyInt
+import org.mockito.ArgumentMatchers.anyString
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class QrFeatureTest {
+
+    private val context: Context
+        get() = ApplicationProvider.getApplicationContext()
+
+    @Test
+    fun `feature requests permission if required`() {
+        val fragmentManager = mockFragmentManager()
+
+        var permissionRequested = false
+
+        val feature = QrFeature(context,
+            fragmentManager = fragmentManager,
+            onNeedToRequestPermissions = { permissionRequested = true }
+        )
+
+        assertFalse(feature.scan())
+        assertTrue(permissionRequested)
+    }
+
+    @Test
+    fun `scan starts qr fragment if permissions granted`() {
+        val fragmentManager = mockFragmentManager()
+        grantPermission(Manifest.permission.CAMERA)
+
+        val feature = QrFeature(context,
+            fragmentManager = fragmentManager,
+            onNeedToRequestPermissions = { },
+            onScanResult = { }
+        )
+
+        assertTrue(feature.scan(123))
+        verify(fragmentManager).beginTransaction()
+    }
+
+    @Test
+    fun `onPermissionsResult displays scanner only if permission granted`() {
+        val fragmentManager = mockFragmentManager()
+
+        val feature = QrFeature(context, fragmentManager = fragmentManager)
+
+        assertFalse(feature.scan())
+
+        feature.onPermissionsResult(emptyArray(), IntArray(1) { PackageManager.PERMISSION_DENIED })
+        verify(fragmentManager, never()).beginTransaction()
+
+        grantPermission(Manifest.permission.CAMERA)
+        feature.onPermissionsResult(emptyArray(), IntArray(1) { PackageManager.PERMISSION_GRANTED })
+        verify(fragmentManager).beginTransaction()
+    }
+
+    @Test
+    fun `scan result is forwarded to caller`() {
+        var scanResultReceived = ""
+
+        val feature = QrFeature(context,
+            fragmentManager = mockFragmentManager(),
+            onScanResult = { result -> scanResultReceived = result }
+        )
+
+        feature.scan()
+        feature.scanCompleteListener.onScanComplete("result")
+
+        assertEquals("result", scanResultReceived)
+    }
+
+    @Test
+    fun `qr fragment is removed on back pressed`() {
+        val fragmentManager = mockFragmentManager()
+        val fragment: QrFragment = mock()
+        `when`(fragmentManager.findFragmentByTag(QR_FRAGMENT_TAG)).thenReturn(fragment)
+
+        val feature = spy(
+            QrFeature(
+                context,
+                fragmentManager = fragmentManager,
+                onScanResult = { }
+            )
+        )
+
+        feature.onBackPressed()
+        verify(feature).removeQrFragment()
+    }
+
+    @Test
+    fun `start attaches scan complete listener`() {
+        val fragmentManager = mockFragmentManager()
+
+        val feature = QrFeature(context, fragmentManager = fragmentManager, onScanResult = { })
+        feature.start()
+
+        val fragment: QrFragment = mock()
+        `when`(fragmentManager.findFragmentByTag(QR_FRAGMENT_TAG)).thenReturn(fragment)
+        feature.start()
+
+        verify(fragment).scanCompleteListener = feature.scanCompleteListener
+    }
+
+    private fun mockFragmentManager(): FragmentManager {
+        val fragmentManager: FragmentManager = mock()
+
+        val transaction: FragmentTransaction = mock()
+        doReturn(transaction).`when`(fragmentManager).beginTransaction()
+        doReturn(transaction).`when`(transaction).add(anyInt(), any(), anyString())
+        doReturn(transaction).`when`(transaction).remove(any())
+
+        return fragmentManager
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt
new file mode 100644
index 000000000000..38d8373cf99c
--- /dev/null
+++ b/android-components/components/feature/qr/src/test/java/mozilla/components/feature/qr/QrFragmentTest.kt
@@ -0,0 +1,197 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.qr
+
+import android.hardware.camera2.CameraDevice
+import android.util.Size
+import com.google.zxing.BarcodeFormat
+import com.google.zxing.BinaryBitmap
+import com.google.zxing.MultiFormatReader
+import com.google.zxing.NotFoundException
+import mozilla.components.support.base.android.view.AutoFitTextureView
+import mozilla.components.support.test.any
+import mozilla.components.support.test.eq
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNull
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.anyInt
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+import org.robolectric.RobolectricTestRunner
+
+@RunWith(RobolectricTestRunner::class)
+class QrFragmentTest {
+
+    @Test
+    fun `initialize QR fragment`() {
+        val scanCompleteListener = mock(QrFragment.OnScanCompleteListener::class.java)
+        val qrFragment = spy(QrFragment.newInstance(scanCompleteListener))
+
+        qrFragment.scanCompleteListener?.onScanComplete("result")
+        verify(scanCompleteListener).onScanComplete("result")
+    }
+
+    @Test
+    fun `onPause closes camera and stops background thread`() {
+        val qrFragment = spy(QrFragment.newInstance(mock(QrFragment.OnScanCompleteListener::class.java)))
+        qrFragment.onPause()
+
+        verify(qrFragment).stopBackgroundThread()
+        verify(qrFragment).closeCamera()
+    }
+
+    @Test
+    fun `onResume opens camera and starts background thread`() {
+        val qrFragment = spy(QrFragment.newInstance(mock(QrFragment.OnScanCompleteListener::class.java)))
+        `when`(qrFragment.setUpCameraOutputs(anyInt(), anyInt())).then { }
+
+        qrFragment.textureView = mock()
+        qrFragment.onResume()
+        verify(qrFragment, never()).openCamera(anyInt(), anyInt())
+
+        `when`(qrFragment.textureView.isAvailable).thenReturn(true)
+        qrFragment.onResume()
+        verify(qrFragment, times(2)).startBackgroundThread()
+        verify(qrFragment).openCamera(anyInt(), anyInt())
+    }
+
+    @Test
+    fun `onViewCreated sets initial state`() {
+        val qrFragment = QrFragment.newInstance(mock(QrFragment.OnScanCompleteListener::class.java))
+        val view: AutoFitTextureView = mock()
+        `when`(view.findViewById<AutoFitTextureView>(anyInt())).thenReturn(mock())
+
+        qrFragment.onViewCreated(view, mock())
+        assertEquals(QrFragment.STATE_FIND_QRCODE, QrFragment.qrState)
+    }
+
+    @Test
+    fun `async scanning task invokes listener on successful qr scan`() {
+        val listener = mock(QrFragment.OnScanCompleteListener::class.java)
+        val reader = mock(MultiFormatReader::class.java)
+        val task = QrFragment.AsyncScanningTask(listener, reader)
+
+        val bitmap = mock(BinaryBitmap::class.java)
+        val result = com.google.zxing.Result("qrcode-result", ByteArray(0), emptyArray(), BarcodeFormat.ITF)
+        `when`(reader.decodeWithState(any())).thenReturn(result)
+
+        QrFragment.qrState = QrFragment.STATE_DECODE_PROGRESS
+        task.processImage(bitmap)
+
+        verify(listener).onScanComplete(eq("qrcode-result"))
+        assertEquals(QrFragment.STATE_QRCODE_EXIST, QrFragment.qrState)
+    }
+
+    @Test
+    fun `async scanning task resets state on error`() {
+        val listener = mock(QrFragment.OnScanCompleteListener::class.java)
+        val reader = mock(MultiFormatReader::class.java)
+        val task = QrFragment.AsyncScanningTask(listener, reader)
+
+        val bitmap = mock(BinaryBitmap::class.java)
+        `when`(reader.decodeWithState(any())).thenThrow(NotFoundException::class.java)
+
+        QrFragment.qrState = QrFragment.STATE_DECODE_PROGRESS
+        task.processImage(bitmap)
+
+        assertEquals(QrFragment.STATE_FIND_QRCODE, QrFragment.qrState)
+    }
+
+    @Test
+    fun `async scanning task does nothing if decoding not in progress`() {
+        val listener = mock(QrFragment.OnScanCompleteListener::class.java)
+        val reader = mock(MultiFormatReader::class.java)
+        val task = QrFragment.AsyncScanningTask(listener, reader)
+
+        val bitmap = mock(BinaryBitmap::class.java)
+        `when`(reader.decodeWithState(any())).thenThrow(NotFoundException::class.java)
+
+        QrFragment.qrState = QrFragment.STATE_FIND_QRCODE
+        assertNull(task.processImage(bitmap))
+        verify(reader, never()).decodeWithState(any())
+    }
+
+    @Test
+    fun `camera is closed on disconnect and error`() {
+        val qrFragment = spy(QrFragment.newInstance(mock(QrFragment.OnScanCompleteListener::class.java)))
+
+        var camera: CameraDevice = mock()
+        qrFragment.stateCallback.onDisconnected(camera)
+        verify(camera).close()
+
+        camera = mock()
+        qrFragment.stateCallback.onError(camera, 0)
+        verify(camera).close()
+    }
+
+    @Test
+    fun `choose optimal size`() {
+        var size = QrFragment.chooseOptimalSize(
+            arrayOf(Size(640, 480), Size(1024, 768)),
+            640,
+            480,
+            QrFragment.MAX_PREVIEW_WIDTH,
+            QrFragment.MAX_PREVIEW_HEIGHT,
+            Size(16, 9)
+        )
+
+        assertEquals(640, size.width)
+        assertEquals(480, size.height)
+
+        size = QrFragment.chooseOptimalSize(
+            arrayOf(Size(1024, 768), Size(640, 480)),
+            1024,
+            768,
+            QrFragment.MAX_PREVIEW_WIDTH,
+            QrFragment.MAX_PREVIEW_HEIGHT,
+            Size(4, 3)
+        )
+
+        assertEquals(1024, size.width)
+        assertEquals(768, size.height)
+
+        size = QrFragment.chooseOptimalSize(
+            arrayOf(Size(1024, 768), Size(640, 480), Size(320, 240)),
+            2048,
+            768,
+            QrFragment.MAX_PREVIEW_WIDTH,
+            QrFragment.MAX_PREVIEW_HEIGHT,
+            Size(4, 3)
+        )
+
+        assertEquals(1024, size.width)
+        assertEquals(768, size.height)
+
+        size = QrFragment.chooseOptimalSize(
+            arrayOf(Size(1024, 768), Size(640, 480), Size(320, 240)),
+            1024,
+            1024,
+            QrFragment.MAX_PREVIEW_WIDTH,
+            QrFragment.MAX_PREVIEW_HEIGHT,
+            Size(4, 3)
+        )
+
+        assertEquals(1024, size.width)
+        assertEquals(768, size.height)
+
+        size = QrFragment.chooseOptimalSize(
+            arrayOf(Size(1024, 768), Size(640, 480), Size(320, 240)),
+            2048,
+            1024,
+            QrFragment.MAX_PREVIEW_WIDTH,
+            QrFragment.MAX_PREVIEW_HEIGHT,
+            Size(16, 9)
+        )
+
+        assertEquals(1024, size.width)
+        assertEquals(768, size.height)
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/qr/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/feature/qr/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 000000000000..cf1c399ea81e
--- /dev/null
+++ b/android-components/components/feature/qr/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1,2 @@
+mock-maker-inline
+// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/components/support/base/src/main/java/mozilla/components/support/base/android/view/AutoFitTextureView.kt b/android-components/components/support/base/src/main/java/mozilla/components/support/base/android/view/AutoFitTextureView.kt
new file mode 100644
index 000000000000..6156d02897b9
--- /dev/null
+++ b/android-components/components/support/base/src/main/java/mozilla/components/support/base/android/view/AutoFitTextureView.kt
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. */
+
+package mozilla.components.support.base.android.view
+
+import android.content.Context
+import android.support.annotation.VisibleForTesting
+import android.util.AttributeSet
+import android.view.TextureView
+import android.view.View
+
+/**
+ * A [TextureView] that can be adjusted to a specified aspect ratio.
+ */
+open class AutoFitTextureView @JvmOverloads constructor(
+    context: Context,
+    attrs: AttributeSet? = null,
+    defStyle: Int = 0
+) : TextureView(context, attrs, defStyle) {
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal var mRatioWidth = 0
+        private set
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal var mRatioHeight = 0
+        private set
+
+    /**
+     * Sets the aspect ratio for this view. The size of the view will be measured based on the ratio
+     * calculated from the parameters. Note that the actual sizes of parameters don't matter, that
+     * is, calling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.
+     *
+     * @param width Relative horizontal size
+     * @param height Relative vertical size
+     */
+    fun setAspectRatio(width: Int, height: Int) {
+        if (width < 0 || height < 0) {
+            throw IllegalArgumentException("Size cannot be negative.")
+        }
+        mRatioWidth = width
+        mRatioHeight = height
+        requestLayout()
+    }
+
+    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
+        val width = View.MeasureSpec.getSize(widthMeasureSpec)
+        val height = View.MeasureSpec.getSize(heightMeasureSpec)
+        if (0 == mRatioWidth || 0 == mRatioHeight) {
+            setMeasuredDimension(width, height)
+        } else {
+            if (width < height * mRatioWidth / mRatioHeight) {
+                setMeasuredDimension(width, width * mRatioHeight / mRatioWidth)
+            } else {
+                setMeasuredDimension(height * mRatioWidth / mRatioHeight, height)
+            }
+        }
+    }
+}
diff --git a/android-components/components/support/base/src/test/java/mozilla/components/support/base/android/view/AutoFitTextureViewTest.kt b/android-components/components/support/base/src/test/java/mozilla/components/support/base/android/view/AutoFitTextureViewTest.kt
new file mode 100644
index 000000000000..d0617484bac3
--- /dev/null
+++ b/android-components/components/support/base/src/test/java/mozilla/components/support/base/android/view/AutoFitTextureViewTest.kt
@@ -0,0 +1,83 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.support.base.android.view
+
+import android.view.View
+import androidx.test.core.app.ApplicationProvider
+import org.junit.Assert.assertEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.verify
+import org.robolectric.RobolectricTestRunner
+import java.lang.IllegalArgumentException
+
+@RunWith(RobolectricTestRunner::class)
+class AutoFitTextureViewTest {
+
+    @Test
+    fun `set aspect ratio`() {
+        val view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(16, 9)
+
+        assertEquals(16, view.mRatioWidth)
+        assertEquals(9, view.mRatioHeight)
+        verify(view).requestLayout()
+    }
+
+    @Test(expected = IllegalArgumentException::class)
+    fun `width must not be negative when setting aspect ratio`() {
+        val view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(-1, 0)
+    }
+
+    @Test(expected = IllegalArgumentException::class)
+    fun `height must not be negative when setting aspect ratio`() {
+        val view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(0, -1)
+    }
+
+    @Test(expected = IllegalArgumentException::class)
+    fun `width and height must not be negative when setting aspect ratio`() {
+        val view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(-1, -1)
+    }
+
+    @Test
+    fun `measure`() {
+        val width = View.MeasureSpec.getSize(640)
+        val height = View.MeasureSpec.getSize(480)
+
+        var view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(0, 0)
+        view.measure(width, height)
+        assertEquals(width, view.measuredWidth)
+        assertEquals(height, view.measuredHeight)
+
+        view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(640, 0)
+        view.measure(width, height)
+        assertEquals(width, view.measuredWidth)
+        assertEquals(height, view.measuredHeight)
+
+        view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(0, 480)
+        view.measure(width, height)
+        assertEquals(width, view.measuredWidth)
+        assertEquals(height, view.measuredHeight)
+
+        view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(16, 9)
+        view.measure(width, height)
+        assertEquals(width, view.measuredWidth)
+        assertEquals(360, view.measuredHeight)
+
+        view = spy(AutoFitTextureView(ApplicationProvider.getApplicationContext()))
+        view.setAspectRatio(4, 3)
+        view.measure(width, height)
+        assertEquals(width, view.measuredWidth)
+        assertEquals(height, view.measuredHeight)
+    }
+}
\ No newline at end of file
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index fcfdb8cd9cbf..e4c6fb56ca58 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -84,6 +84,23 @@ permalink: /changelog/
 * **browser-storage-sync**
   * Implementations of `concept-storage`/`BookmarksStorage` expose the newly added APIs.
 
+  * **feature-qr**
+  * ðŸ†• New component/feature that provides functionality for scanning QR codes.
+    ```kotlin
+      val qrFeature = QrFeature(
+          context,
+          fragmentManager = supportFragmentManager,
+          onNeedToRequestPermissions = { permissions ->
+              requestPermissions(this, permissions, REQUEST_CODE_CAMERA_PERMISSIONS)
+          },
+          onScanResult = { qrScanResult ->
+              // qrScanResult is a String (e.g. a URL) returned by the QR scanner
+          }
+      )
+      // When ready to scan simply call
+      qrFeature.scan()
+    ```
+
 # 0.47.0
 
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v0.46.0...v0.47.0)
diff --git a/android-components/samples/firefox-accounts/build.gradle b/android-components/samples/firefox-accounts/build.gradle
index a689f329118d..4d450f248867 100644
--- a/android-components/samples/firefox-accounts/build.gradle
+++ b/android-components/samples/firefox-accounts/build.gradle
@@ -37,11 +37,10 @@ android {
 
 dependencies {
     implementation project(':service-firefox-accounts')
+    implementation project(':feature-qr')
+    implementation project(':support-base')
 
     implementation Dependencies.support_constraintlayout
-    implementation ('me.dm7.barcodescanner:zxing:1.9.8') {
-        exclude module: 'support-v4'
-    }
 
     implementation Dependencies.kotlin_stdlib
     implementation Dependencies.kotlin_coroutines
diff --git a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt b/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
index 416df2326e53..730c966eb873 100644
--- a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
+++ b/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/MainActivity.kt
@@ -11,6 +11,7 @@ import android.support.v7.app.AppCompatActivity
 import android.support.customtabs.CustomTabsIntent
 import android.view.View
 import android.content.Intent
+import android.support.v4.app.ActivityCompat
 import android.widget.CheckBox
 import android.widget.TextView
 import kotlinx.coroutines.CoroutineScope
@@ -18,19 +19,24 @@ import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.launch
 import mozilla.components.concept.sync.Profile
+import mozilla.components.feature.qr.QrFeature
 import mozilla.components.service.fxa.FirefoxAccount
 import mozilla.components.service.fxa.FxaException
 import mozilla.components.service.fxa.Config
+import mozilla.components.support.base.log.Log
+import mozilla.components.support.base.log.sink.AndroidLogSink
 import kotlin.coroutines.CoroutineContext
 
+@Suppress("TooManyFunctions")
 open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener, CoroutineScope {
-
     private lateinit var account: FirefoxAccount
     private var scopesWithoutKeys: Array<String> = arrayOf("profile")
     private var scopesWithKeys: Array<String> = arrayOf("profile", "https://identity.mozilla.com/apps/oldsync")
     private var scopes: Array<String> = scopesWithoutKeys
     private var wantsKeys: Boolean = false
 
+    private lateinit var qrFeature: QrFeature
+
     private lateinit var job: Job
     override val coroutineContext: CoroutineContext
         get() = Dispatchers.Main + job
@@ -39,17 +45,42 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
         const val CLIENT_ID = "12cc4070a481bc73"
         const val REDIRECT_URL = "fxaclient://android.redirect"
         const val CONFIG_URL = "https://latest.dev.lcip.org"
-        const val CONFIG_URL_PAIRING = "https://pairsona.dev.lcip.org"
         const val FXA_STATE_PREFS_KEY = "fxaAppState"
         const val FXA_STATE_KEY = "fxaState"
+        private const val REQUEST_CODE_CAMERA_PERMISSIONS = 1
     }
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
+
+        Log.addSink(AndroidLogSink())
+
         setContentView(R.layout.activity_main)
         job = Job()
         account = initAccount()
 
+        qrFeature = QrFeature(
+            this,
+            fragmentManager = supportFragmentManager,
+            onNeedToRequestPermissions = { permissions ->
+                ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_CAMERA_PERMISSIONS)
+            },
+            onScanResult = { pairingUrl ->
+                val config = Config(CONFIG_URL, CLIENT_ID, REDIRECT_URL)
+                val acct = FirefoxAccount(config)
+                launch {
+                    try {
+                        val url = acct.beginPairingFlow(pairingUrl, scopes).await()
+                        openWebView(url)
+                    } catch (e: FxaException) {
+                        Log.log(Log.Priority.ERROR, "mozac-samples-fxa", e, "Pairing flow failed for $pairingUrl")
+                    }
+                }
+            }
+        )
+
+        lifecycle.addObserver(qrFeature)
+
         findViewById<View>(R.id.buttonCustomTabs).setOnClickListener {
             launch {
                 val url = account.beginOAuthFlow(scopes, wantsKeys).await()
@@ -65,8 +96,7 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
         }
 
         findViewById<View>(R.id.buttonPair).setOnClickListener {
-            val intent = Intent(this@MainActivity, ScanActivity::class.java)
-            startActivity(intent)
+            qrFeature.scan()
         }
 
         findViewById<View>(R.id.buttonLogout).setOnClickListener {
@@ -90,16 +120,6 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
             return it
         }
 
-        intent.extras?.getString("pairingUrl")?.let { pairingUrl ->
-            val config = Config(CONFIG_URL_PAIRING, CLIENT_ID, REDIRECT_URL)
-            val acct = FirefoxAccount(config)
-            launch {
-                val url = acct.beginPairingFlow(pairingUrl, scopes).await()
-                openWebView(url)
-            }
-            return acct
-        }
-
         val config = Config(CONFIG_URL, CLIENT_ID, REDIRECT_URL)
         return FirefoxAccount(config)
     }
@@ -173,4 +193,16 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
         val txtView: TextView = findViewById(R.id.txtView)
         txtView.text = getString(R.string.signed_in, "${profile.displayName ?: ""} ${profile.email}")
     }
+
+    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
+        when (requestCode) {
+            REQUEST_CODE_CAMERA_PERMISSIONS -> qrFeature.onPermissionsResult(permissions, grantResults)
+        }
+    }
+
+    override fun onBackPressed() {
+        if (!qrFeature.onBackPressed()) {
+            super.onBackPressed()
+        }
+    }
 }
diff --git a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/ScanActivity.kt b/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/ScanActivity.kt
deleted file mode 100644
index 4b1bb6679c59..000000000000
--- a/android-components/samples/firefox-accounts/src/main/java/org/mozilla/samples/fxa/ScanActivity.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.mozilla.samples.fxa
-
-import android.Manifest
-import android.content.Intent
-import android.content.pm.PackageManager
-import android.support.v7.app.AppCompatActivity
-import android.os.Bundle
-import android.support.v4.app.ActivityCompat
-import android.support.v4.content.ContextCompat
-import com.google.zxing.Result
-import me.dm7.barcodescanner.zxing.ZXingScannerView
-
-class ScanActivity : AppCompatActivity(), ZXingScannerView.ResultHandler {
-
-    private lateinit var mScannerView: ZXingScannerView
-
-    public override fun onCreate(state: Bundle?) {
-        super.onCreate(state)
-        val cameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
-        if (cameraPermission != PackageManager.PERMISSION_GRANTED) {
-            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), 1)
-        }
-
-        mScannerView = ZXingScannerView(this)
-        setContentView(mScannerView)
-    }
-
-    public override fun onResume() {
-        super.onResume()
-        mScannerView.setResultHandler(this)
-        mScannerView.startCamera()
-    }
-
-    public override fun onPause() {
-        super.onPause()
-        mScannerView.stopCamera()
-    }
-
-    override fun handleResult(rawResult: Result) {
-        val i = Intent(this, MainActivity::class.java)
-        i.putExtra("pairingUrl", rawResult.text)
-        startActivityForResult(i, 1)
-    }
-}
