diff --git a/android-components/.buildconfig.yml b/android-components/.buildconfig.yml
index ebb0441f49ea..7efc06555a46 100644
--- a/android-components/.buildconfig.yml
+++ b/android-components/.buildconfig.yml
@@ -288,6 +288,10 @@ projects:
     path: components/lib/push-firebase
     description: 'An implementation of concept-push for the Firebase Message Service.'
     publish: true
+  lib-state:
+    path: components/lib/state
+    description: 'A library for maintaining application state.'
+    publish: true
   tooling-lint:
     path: components/tooling/lint
     description: 'Custom Lint checks for using and writing components.'
diff --git a/android-components/README.md b/android-components/README.md
index 748916e36677..3db9fa61ab93 100644
--- a/android-components/README.md
+++ b/android-components/README.md
@@ -206,6 +206,8 @@ _Supporting components with generic helper code._
 
 * âšª [**Public Suffix List**](components/lib/publicsuffixlist/README.md) - A library for reading and using the [public suffix list](https://publicsuffix.org/).
 
+* âšª [**State**](components/lib/state/README.md) - A library for maintaining application state.
+
 * ðŸ”´ [**Push-Firebase**](components/lib/push-firebase/README.md) - A [concept-push](concept/push/README.md) implementation using [Firebase Cloud Messaging](https://firebase.google.com/products/cloud-messaging/).
 
 ## Tooling
diff --git a/android-components/components/browser/state/build.gradle b/android-components/components/browser/state/build.gradle
index 82eb2359ad04..277acf3f9050 100644
--- a/android-components/components/browser/state/build.gradle
+++ b/android-components/components/browser/state/build.gradle
@@ -25,6 +25,7 @@ dependencies {
     implementation project(':concept-engine')
     implementation project(':support-utils')
     implementation project(':support-ktx')
+    implementation project(':lib-state')
 
     implementation Dependencies.kotlin_stdlib
     implementation Dependencies.kotlin_coroutines
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/Action.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/Action.kt
deleted file mode 100644
index ad139b9365d2..000000000000
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/Action.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.session.action
-
-import mozilla.components.browser.session.store.BrowserStore
-import mozilla.components.browser.session.state.BrowserState
-
-/**
- * Generic interface for actions to be dispatched on a [BrowserStore].
- *
- * Actions are used to send data from the application to a [BrowserStore]. The [BrowserStore] will use the [Action] to
- * derive a new [BrowserState].
- */
-interface Action
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/BrowserAction.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/BrowserAction.kt
index 70fe2558c153..ca455a431c6f 100644
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/BrowserAction.kt
+++ b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/action/BrowserAction.kt
@@ -7,6 +7,7 @@ package mozilla.components.browser.session.action
 import mozilla.components.browser.session.state.SessionState
 import mozilla.components.browser.session.state.BrowserState
 import mozilla.components.concept.engine.HitResult
+import mozilla.components.lib.state.Action
 
 /**
  * [Action] implementation related to [BrowserState].
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/ext/StoreExtensions.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/ext/StoreExtensions.kt
deleted file mode 100644
index 8e2ae0715a28..000000000000
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/ext/StoreExtensions.kt
+++ /dev/null
@@ -1,76 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.session.ext
-
-import android.view.View
-import androidx.lifecycle.Lifecycle
-import androidx.lifecycle.LifecycleObserver
-import androidx.lifecycle.LifecycleOwner
-import androidx.lifecycle.OnLifecycleEvent
-import mozilla.components.browser.session.store.BrowserStore
-import mozilla.components.browser.session.store.Observer
-
-/**
- * Registers an [Observer] function that will be invoked whenever the state changes. The [BrowserStore.Subscription]
- * will be bound to the passed in [LifecycleOwner]. Once the [Lifecycle] state changes to DESTROYED the [Observer] will
- * be unregistered automatically.
- */
-fun BrowserStore.observe(
-    owner: LifecycleOwner,
-    receiveInitialState: Boolean = true,
-    observer: Observer
-): BrowserStore.Subscription {
-    return observe(receiveInitialState, observer).apply {
-        binding = LifecycleBoundObserver(owner, this)
-    }
-}
-
-/**
- * Registers an [Observer] function that will be invoked whenever the state changes. The [BrowserStore.Subscription]
- * will be bound to the passed in [View]. Once the [View] gets detached the [Observer] will be unregistered
- * automatically.
- */
-fun BrowserStore.observe(
-    view: View,
-    observer: Observer,
-    receiveInitialState: Boolean = true
-): BrowserStore.Subscription {
-    return observe(receiveInitialState, observer).apply {
-        binding = ViewBoundObserver(view, this)
-    }
-}
-
-/**
- * GenericLifecycleObserver implementation to bind an observer to a Lifecycle.
- */
-private class LifecycleBoundObserver(
-    private val owner: LifecycleOwner,
-    private val subscription: BrowserStore.Subscription
-) : LifecycleObserver, BrowserStore.Subscription.Binding {
-    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
-    override fun unbind() {
-        subscription.unsubscribe()
-
-        owner.lifecycle.removeObserver(this)
-    }
-}
-
-/**
- * View.OnAttachStateChangeListener implementation to bind an observer to a View.
- */
-private class ViewBoundObserver(
-    private val view: View,
-    private val subscription: BrowserStore.Subscription
-) : View.OnAttachStateChangeListener, BrowserStore.Subscription.Binding {
-    override fun onViewAttachedToWindow(v: View?) = Unit
-
-    override fun onViewDetachedFromWindow(view: View) {
-        subscription.unsubscribe()
-    }
-
-    override fun unbind() {
-        view.removeOnAttachStateChangeListener(this)
-    }
-}
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/helper/Helpers.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/helper/Helpers.kt
deleted file mode 100644
index ca4f151674b6..000000000000
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/helper/Helpers.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package mozilla.components.browser.session.helper
-
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.GlobalScope
-import kotlinx.coroutines.launch
-import mozilla.components.browser.session.state.BrowserState
-import mozilla.components.browser.session.store.Observer
-
-/**
- * Creates an [Observer] that will map the received [BrowserState] to [T] (using [map]) and will invoke the callback
- * [then] only if the value has changed from the last mapped value.
- *
- * @param onMainThread Whether or not the [then] function should be executed on the main thread.
- * @param map A function that maps [BrowserState] to the value we want to observe for changes.
- * @param then Function that gets invoked whenever the mapped value changed.
- */
-@Suppress("FunctionNaming")
-fun <T> onlyIfChanged(
-    onMainThread: Boolean = false,
-    map: (BrowserState) -> T?,
-    then: (BrowserState, T) -> Unit
-): Observer {
-    var lastValue: T? = null
-
-    return fun (value: BrowserState) {
-        val mapped = map(value)
-
-        if (mapped !== null && mapped !== lastValue) {
-            if (onMainThread) {
-                GlobalScope.launch(Dispatchers.Main) {
-                    then(value, mapped)
-                }
-            } else {
-                then(value, mapped)
-            }
-            lastValue = mapped
-        }
-    }
-}
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/reducer/BrowserReducers.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/reducer/BrowserReducers.kt
index f5fdab5b9d71..83467fab5a1d 100644
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/reducer/BrowserReducers.kt
+++ b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/reducer/BrowserReducers.kt
@@ -4,7 +4,6 @@
 
 package mozilla.components.browser.session.reducer
 
-import mozilla.components.browser.session.action.Action
 import mozilla.components.browser.session.action.BrowserAction
 import mozilla.components.browser.session.action.SessionAction
 import mozilla.components.browser.session.action.SessionListAction
@@ -12,7 +11,7 @@ import mozilla.components.browser.session.selector.findSession
 import mozilla.components.browser.session.state.BrowserState
 import mozilla.components.browser.session.state.SessionState
 import mozilla.components.browser.session.store.BrowserStore
-import mozilla.components.browser.session.store.Reducer
+import mozilla.components.lib.state.Action
 
 /**
  * Reducers for [BrowserStore].
@@ -21,15 +20,7 @@ import mozilla.components.browser.session.store.Reducer
  * [BrowserState].
  */
 internal object BrowserReducers {
-    fun get(): List<Reducer> = listOf(
-        ::reduce
-    )
-
-    private fun reduce(state: BrowserState, action: Action): BrowserState {
-        if (action !is BrowserAction) {
-            return state
-        }
-
+    fun reduce(state: BrowserState, action: BrowserAction): BrowserState {
         return when (action) {
             is SessionListAction -> reduceSessionListAction(state, action)
             is SessionAction -> reduceSessionAction(state, action)
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/state/BrowserState.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/state/BrowserState.kt
index 209630c95ac0..b64d9fda9e4b 100644
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/state/BrowserState.kt
+++ b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/state/BrowserState.kt
@@ -4,6 +4,8 @@
 
 package mozilla.components.browser.session.state
 
+import mozilla.components.lib.state.State
+
 /**
  * Value type that represents the complete state of the browser/engine.
  *
@@ -13,4 +15,4 @@ package mozilla.components.browser.session.state
 data class BrowserState(
     val sessions: List<SessionState> = emptyList(),
     val selectedSessionId: String? = null
-)
+) : State
diff --git a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/store/BrowserStore.kt b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/store/BrowserStore.kt
index 124040ce9ce7..65f7fde1209b 100644
--- a/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/store/BrowserStore.kt
+++ b/android-components/components/browser/state/src/main/java/mozilla/components/browser/session/store/BrowserStore.kt
@@ -4,16 +4,11 @@
 
 package mozilla.components.browser.session.store
 
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.asCoroutineDispatcher
-import kotlinx.coroutines.launch
-import mozilla.components.browser.session.action.Action
+import mozilla.components.browser.session.action.BrowserAction
 import mozilla.components.browser.session.reducer.BrowserReducers
 import mozilla.components.browser.session.state.BrowserState
-import java.util.concurrent.Executors
-
-typealias Reducer = (BrowserState, Action) -> BrowserState
-typealias Observer = (BrowserState) -> Unit
+import mozilla.components.lib.state.Action
+import mozilla.components.lib.state.Store
 
 /**
  * The [BrowserStore] holds the [BrowserState] (state tree).
@@ -22,98 +17,7 @@ typealias Observer = (BrowserState) -> Unit
  */
 class BrowserStore(
     initialState: BrowserState
-) {
-    private val reducers: List<Reducer> = BrowserReducers.get()
-    private val storeContext = Executors.newSingleThreadExecutor().asCoroutineDispatcher()
-    private val storeScope = CoroutineScope(storeContext)
-    private val subscriptions: MutableList<Subscription> = mutableListOf()
-    private var currentState = initialState
-
-    /**
-     * Dispatch an [Action] to the store in order to trigger a [BrowserState] change.
-     *
-     *
-     */
-    fun dispatch(action: Action) = storeScope.launch(storeContext) {
-        dispatchInternal(action)
-    }
-
-    @Synchronized
-    private fun dispatchInternal(action: Action) {
-        val newState = reduceState(currentState, action, reducers)
-
-        if (newState == currentState) {
-            // Nothing has changed.
-            return
-        }
-
-        currentState = newState
-
-        synchronized(subscriptions) {
-            subscriptions.forEach { it.observer.invoke(currentState) }
-        }
-    }
-
-    /**
-     * Returns the current state.
-     */
-    val state: BrowserState
-        get() = currentState
-
-    /**
-     * Registers an observer function that will be invoked whenever the state changes.
-     *
-     * @param receiveInitialState If true the observer function will be invoked immediately with the current state.
-     * @return A subscription object that can be used to unsubscribe from further state changes.
-     */
-    fun observe(receiveInitialState: Boolean = true, observer: Observer): Subscription {
-        val subscription = Subscription(observer, store = this)
-
-        synchronized(subscriptions) {
-            subscriptions.add(subscription)
-        }
-
-        if (receiveInitialState) {
-            observer.invoke(currentState)
-        }
-
-        return subscription
-    }
-
-    private fun removeSubscription(subscription: Subscription) {
-        synchronized(subscriptions) {
-            subscriptions.remove(subscription)
-        }
-    }
-
-    /**
-     * A [Subscription] is returned whenever an observer is registered via the [observe] method. Calling [unsubscribe]
-     * on the [Subscription] will unregister the observer.
-     */
-    class Subscription internal constructor(
-        internal val observer: Observer,
-        private val store: BrowserStore
-    ) {
-        var binding: Binding? = null
-
-        fun unsubscribe() {
-            store.removeSubscription(this)
-
-            binding?.unbind()
-        }
-
-        interface Binding {
-            fun unbind()
-        }
-    }
-}
-
-private fun reduceState(state: BrowserState, action: Action, reducers: List<Reducer>): BrowserState {
-    var current = state
-
-    reducers.forEach { reducer ->
-        current = reducer.invoke(current, action)
-    }
-
-    return current
-}
+) : Store<BrowserState, BrowserAction>(
+    initialState,
+    BrowserReducers::reduce
+)
diff --git a/android-components/components/lib/state/README.md b/android-components/components/lib/state/README.md
new file mode 100644
index 000000000000..987a9a07c3c3
--- /dev/null
+++ b/android-components/components/lib/state/README.md
@@ -0,0 +1,19 @@
+# [Android Components](../../../README.md) > Libraries > State
+
+A generic library for maintaining the state of a component, screen or application.
+
+## Usage
+
+### Setting up the dependency
+
+Use Gradle to download the library from [maven.mozilla.org](https://maven.mozilla.org/) ([Setup repository](../../../README.md#maven-repository)):
+
+```Groovy
+implementation "org.mozilla.components:lib-state:{latest-version}"
+```
+
+## License
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/
diff --git a/android-components/components/lib/state/build.gradle b/android-components/components/lib/state/build.gradle
new file mode 100644
index 000000000000..3b1819b61eba
--- /dev/null
+++ b/android-components/components/lib/state/build.gradle
@@ -0,0 +1,42 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-android-extensions'
+
+android {
+    compileSdkVersion config.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion config.minSdkVersion
+        targetSdkVersion config.targetSdkVersion
+
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    implementation Dependencies.kotlin_stdlib
+    implementation Dependencies.kotlin_coroutines
+
+    implementation Dependencies.androidx_lifecycle_extensions
+
+    testImplementation project(':support-test')
+    testImplementation Dependencies.androidx_test_core
+    testImplementation Dependencies.androidx_test_junit
+    testImplementation Dependencies.testing_robolectric
+    testImplementation Dependencies.testing_coroutines
+    testImplementation Dependencies.testing_mockito
+}
+
+apply from: '../../../publish.gradle'
+ext.configurePublish(config.componentsGroupId, archivesBaseName, project.ext.description)
diff --git a/android-components/components/lib/state/proguard-rules.pro b/android-components/components/lib/state/proguard-rules.pro
new file mode 100644
index 000000000000..f1b424510da5
--- /dev/null
+++ b/android-components/components/lib/state/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/android-components/components/lib/state/src/main/AndroidManifest.xml b/android-components/components/lib/state/src/main/AndroidManifest.xml
new file mode 100644
index 000000000000..37393c55ec2c
--- /dev/null
+++ b/android-components/components/lib/state/src/main/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
+   - You can obtain one at http://mozilla.org/MPL/2.0/.  -->
+<manifest package="mozilla.components.lib.state">
+
+    <application />
+
+</manifest>
diff --git a/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Action.kt b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Action.kt
new file mode 100644
index 000000000000..a03fe8d706a0
--- /dev/null
+++ b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Action.kt
@@ -0,0 +1,13 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state
+
+/**
+ * Generic interface for actions to be dispatched on a [Store].
+ *
+ * Actions are used to send data from the application to a [Store]. The [Store] will use the [Action] to
+ * derive a new [State].
+ */
+interface Action
diff --git a/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/State.kt b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/State.kt
new file mode 100644
index 000000000000..3318ddffe896
--- /dev/null
+++ b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/State.kt
@@ -0,0 +1,10 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state
+
+/**
+ * Generic interface for a [State] maintained by a [Store].
+ */
+interface State
diff --git a/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Store.kt b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Store.kt
new file mode 100644
index 000000000000..06ecf616e9ba
--- /dev/null
+++ b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/Store.kt
@@ -0,0 +1,117 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state
+
+import androidx.annotation.CheckResult
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.launch
+import java.lang.ref.WeakReference
+import java.util.concurrent.Executors
+
+typealias Reducer<S, A> = (S, A) -> S
+typealias Observer<S> = (S) -> Unit
+
+/**
+ * A generic store holding an immutable [State].
+ *
+ * The [State] can only be modified by dispatching [Action]s which will create a new state and notify all registered
+ * [Observer]s.
+ *
+ * @param initialState The initial state until a dispatched [Action] creates a new state.
+ * @param reducer A function that gets the current [State] and [Action] passed in and will return a new [State].
+ */
+open class Store<S : State, A : Action>(
+    initialState: S,
+    private val reducer: Reducer<S, A>
+) {
+    private val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()
+    private val scope = CoroutineScope(dispatcher)
+    private val subscriptions: MutableSet<Subscription<S, A>> = mutableSetOf()
+    private var currentState = initialState
+
+    /**
+     * The current [State].
+     */
+    val state: S
+        @Synchronized
+        get() = currentState
+
+    /**
+     * Registers an [Observer] function that will be invoked whenever the [State] changes.
+     *
+     * Right after registering the [Observer] will be invoked with the current [State].
+     *
+     * It's the responsibility of the caller to keep track of the returned [Subscription] and call
+     * [Subscription.unsubscribe] to stop observing and avoid potentially leaking memory by keeping an unused [Observer]
+     * registered. It's is recommend to use one of the `observe` extension methods that unsubscribe automatically.
+     *
+     * @return A [Subscription] object that can be used to unsubscribe from further state changes.
+     */
+    @CheckResult(suggest = "observe")
+    @Synchronized
+    fun observeManually(observer: Observer<S>): Subscription<S, A> {
+        val subscription = Subscription(observer, store = this)
+
+        synchronized(subscriptions) {
+            subscriptions.add(subscription)
+        }
+
+        observer.invoke(currentState)
+
+        return subscription
+    }
+
+    /**
+     * Dispatch an [Action] to the store in order to trigger a [State] change.
+     */
+    fun dispatch(action: A) = scope.launch(dispatcher) {
+        dispatchInternal(action)
+    }
+
+    @Synchronized
+    private fun dispatchInternal(action: A) {
+        val newState = reducer(currentState, action)
+
+        if (newState == currentState) {
+            // Nothing has changed.
+            return
+        }
+
+        currentState = newState
+
+        synchronized(subscriptions) {
+            subscriptions.forEach { it.observer.invoke(currentState) }
+        }
+    }
+
+    private fun removeSubscription(subscription: Subscription<S, A>) {
+        synchronized(subscriptions) {
+            subscriptions.remove(subscription)
+        }
+    }
+
+    /**
+     * A [Subscription] is returned whenever an observer is registered via the [observeManually] method. Calling
+     * [unsubscribe] on the [Subscription] will unregister the observer.
+     */
+    class Subscription<S : State, A : Action> internal constructor(
+        internal val observer: Observer<S>,
+        store: Store<S, A>
+    ) {
+        private val storeReference = WeakReference(store)
+        internal var binding: Binding? = null
+
+        fun unsubscribe() {
+            storeReference.get()?.removeSubscription(this)
+
+            binding?.unbind()
+        }
+
+        interface Binding {
+            fun unbind()
+        }
+    }
+}
diff --git a/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/ext/StoreExtensions.kt b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/ext/StoreExtensions.kt
new file mode 100644
index 000000000000..1b929c978004
--- /dev/null
+++ b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/ext/StoreExtensions.kt
@@ -0,0 +1,103 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state.ext
+
+import android.view.View
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LifecycleObserver
+import androidx.lifecycle.LifecycleOwner
+import androidx.lifecycle.OnLifecycleEvent
+import androidx.lifecycle.ProcessLifecycleOwner
+import mozilla.components.lib.state.Action
+import mozilla.components.lib.state.Observer
+import mozilla.components.lib.state.State
+import mozilla.components.lib.state.Store
+
+/**
+ * Registers an [Observer] function that will be invoked whenever the state changes. The [Store.Subscription]
+ * will be bound to the passed in [LifecycleOwner]. Once the [Lifecycle] state changes to DESTROYED the [Observer] will
+ * be unregistered automatically.
+ *
+ * Right after registering the [Observer] will be invoked with the current [State].
+ */
+fun <S : State, A : Action> Store<S, A>.observe(
+    owner: LifecycleOwner,
+    observer: Observer<S>
+) {
+    if (owner.lifecycle.currentState == Lifecycle.State.DESTROYED) {
+        // This owner is already destroyed. No need to register.
+        return
+    }
+
+    val subscription = observeManually(observer)
+
+    subscription.binding = SubscriptionLifecycleBinding(owner, subscription).apply {
+        owner.lifecycle.addObserver(this)
+    }
+}
+
+/**
+ * Registers an [Observer] function that will be invoked whenever the state changes. The [Store.Subscription]
+ * will be bound to the passed in [View]. Once the [View] gets detached the [Observer] will be unregistered
+ * automatically.
+ *
+ * Right after registering the [Observer] will be invoked with the current [State].
+ */
+fun <S : State, A : Action> Store<S, A>.observe(
+    view: View,
+    observer: Observer<S>
+) {
+    val subscription = observeManually(observer)
+
+    subscription.binding = SubscriptionViewBinding(view, subscription).apply {
+        view.addOnAttachStateChangeListener(this)
+    }
+}
+
+/**
+ * Registers an [Observer] function that will observe the store indefinitely.
+ *
+ * Right after registering the [Observer] will be invoked with the current [State].
+ */
+fun <S : State, A : Action> Store<S, A>.observeForever(
+    observer: Observer<S>
+) {
+    observe(ProcessLifecycleOwner.get(), observer)
+}
+
+/**
+ * GenericLifecycleObserver implementation to bind an observer to a Lifecycle.
+ */
+private class SubscriptionLifecycleBinding<S : State, A : Action>(
+    private val owner: LifecycleOwner,
+    private val subscription: Store.Subscription<S, A>
+) : LifecycleObserver, Store.Subscription.Binding {
+    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
+    fun onDestroy() {
+        subscription.unsubscribe()
+    }
+
+    override fun unbind() {
+        owner.lifecycle.removeObserver(this)
+    }
+}
+
+/**
+ * View.OnAttachStateChangeListener implementation to bind an observer to a View.
+ */
+private class SubscriptionViewBinding<S : State, A : Action>(
+    private val view: View,
+    private val subscription: Store.Subscription<S, A>
+) : View.OnAttachStateChangeListener, Store.Subscription.Binding {
+    override fun onViewAttachedToWindow(v: View?) = Unit
+
+    override fun onViewDetachedFromWindow(view: View) {
+        subscription.unsubscribe()
+    }
+
+    override fun unbind() {
+        view.removeOnAttachStateChangeListener(this)
+    }
+}
diff --git a/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/helpers/Helpers.kt b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/helpers/Helpers.kt
new file mode 100644
index 000000000000..46465dfa4cc9
--- /dev/null
+++ b/android-components/components/lib/state/src/main/java/mozilla/components/lib/state/helpers/Helpers.kt
@@ -0,0 +1,41 @@
+package mozilla.components.lib.state.helpers
+
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.launch
+import mozilla.components.lib.state.Observer
+import mozilla.components.lib.state.State
+
+/**
+ * Creates an [Observer] that will map the received [State] to [T] (using [map]) and will invoke the callback
+ * [then] only if the value has changed from the last mapped value.
+ *
+ * @param onMainThread Whether or not the [then] function should be executed on the main thread.
+ * @param map A function that maps [State] to the value we want to observe for changes.
+ * @param then Function that gets invoked whenever the mapped value changed.
+ */
+@Suppress("FunctionNaming")
+fun <S : State, T> onlyIfChanged(
+    onMainThread: Boolean = false,
+    map: (S) -> T?,
+    then: (S, T) -> Unit,
+    scope: CoroutineScope = GlobalScope
+): Observer<S> {
+    var lastValue: T? = null
+
+    return fun (value: S) {
+        val mapped = map(value)
+
+        if (mapped !== null && mapped !== lastValue) {
+            if (onMainThread) {
+                scope.launch(Dispatchers.Main) {
+                    then(value, mapped)
+                }
+            } else {
+                then(value, mapped)
+            }
+            lastValue = mapped
+        }
+    }
+}
diff --git a/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/StoreTest.kt b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/StoreTest.kt
new file mode 100644
index 000000000000..c8fe9c8c43ea
--- /dev/null
+++ b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/StoreTest.kt
@@ -0,0 +1,132 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state
+
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.runBlocking
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class StoreTest {
+    @Test
+    fun `Dispatching Action executes reducers and creates new State`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+
+        assertEquals(24, store.state.counter)
+
+        store.dispatch(TestAction.DecrementAction).joinBlocking()
+        store.dispatch(TestAction.DecrementAction).joinBlocking()
+
+        assertEquals(22, store.state.counter)
+    }
+
+    @Test
+    fun `Observer gets notified about state changes`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var observedValue = 0
+
+        store.observeManually { state -> observedValue = state.counter }
+
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+
+        assertEquals(24, observedValue)
+    }
+
+    @Test
+    fun `Observer gets initial value before state changes`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var observedValue = 0
+
+        store.observeManually { state -> observedValue = state.counter }
+
+        assertEquals(23, observedValue)
+    }
+
+    @Test
+    fun `Observer does not get notified if state does not change`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var stateChangeObserved = false
+
+        store.observeManually { stateChangeObserved = true }
+
+        // Initial state observed
+        assertTrue(stateChangeObserved)
+        stateChangeObserved = false
+
+        store.dispatch(TestAction.DoNothingAction).joinBlocking()
+
+        assertFalse(stateChangeObserved)
+    }
+
+    @Test
+    fun `Observer does not get notified after unsubscribe`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var observedValue = 0
+
+        val subscription = store.observeManually { state ->
+            observedValue = state.counter
+        }
+
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+
+        assertEquals(24, observedValue)
+
+        store.dispatch(TestAction.DecrementAction).joinBlocking()
+
+        assertEquals(23, observedValue)
+
+        subscription.unsubscribe()
+
+        store.dispatch(TestAction.DecrementAction).joinBlocking()
+
+        assertEquals(23, observedValue)
+        assertEquals(22, store.state.counter)
+    }
+}
+
+fun Job.joinBlocking() {
+    runBlocking { join() }
+}
+
+fun reducer(state: TestState, action: TestAction): TestState = when (action) {
+    is TestAction.IncrementAction -> state.copy(counter = state.counter + 1)
+    is TestAction.DecrementAction -> state.copy(counter = state.counter - 1)
+    is TestAction.SetValueAction -> state.copy(counter = action.value)
+    is TestAction.DoNothingAction -> state
+}
+
+data class TestState(
+    val counter: Int
+) : State
+
+sealed class TestAction : Action {
+    object IncrementAction : TestAction()
+    object DecrementAction : TestAction()
+    object DoNothingAction : TestAction()
+    data class SetValueAction(val value: Int) : TestAction()
+}
diff --git a/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/ext/StoreExtensionsKtTest.kt b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/ext/StoreExtensionsKtTest.kt
new file mode 100644
index 000000000000..c6bfcb58e5d3
--- /dev/null
+++ b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/ext/StoreExtensionsKtTest.kt
@@ -0,0 +1,168 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state.ext
+
+import android.app.Activity
+import android.view.View
+import android.view.WindowManager
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LifecycleOwner
+import androidx.lifecycle.LifecycleRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.lib.state.Store
+import mozilla.components.lib.state.TestAction
+import mozilla.components.lib.state.TestState
+import mozilla.components.lib.state.joinBlocking
+import mozilla.components.lib.state.reducer
+import mozilla.components.support.test.robolectric.testContext
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.Robolectric
+
+@RunWith(AndroidJUnit4::class)
+class StoreExtensionsKtTest {
+    @Test
+    fun `Observer will not get registered if lifecycle is already destroyed`() {
+        val owner = MockedLifecycleOwner(Lifecycle.State.DESTROYED)
+
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var stateObserved = false
+
+        store.observe(owner) { stateObserved = true }
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+
+        assertFalse(stateObserved)
+    }
+
+    @Test
+    fun `Observer will get unregistered if lifecycle gets destroyed`() {
+        val owner = MockedLifecycleOwner(Lifecycle.State.STARTED)
+
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var stateObserved = false
+        store.observe(owner) { stateObserved = true }
+        assertTrue(stateObserved)
+
+        stateObserved = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.DESTROYED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertFalse(stateObserved)
+    }
+
+    @Test
+    fun `non-destroy lifecycle changes do not affect observer registration`() {
+        val owner = MockedLifecycleOwner(Lifecycle.State.INITIALIZED)
+
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var stateObserved = false
+        store.observe(owner) { stateObserved = true }
+        assertTrue(stateObserved)
+
+        // CREATED
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.CREATED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        // STARTED
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.STARTED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        // RESUMED
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.RESUMED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        // CREATED
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.CREATED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        // DESTROYED
+        stateObserved = false
+        owner.lifecycleRegistry.markState(Lifecycle.State.DESTROYED)
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertFalse(stateObserved)
+    }
+
+    @Test
+    fun `Observer registered with observeForever will get notified about state changes`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var observedValue = 0
+
+        store.observeForever { state -> observedValue = state.counter }
+        assertEquals(23, observedValue)
+
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertEquals(24, observedValue)
+
+        store.dispatch(TestAction.DecrementAction).joinBlocking()
+        assertEquals(23, observedValue)
+    }
+
+    @Test
+    fun `Observer bound to view will get unsubscribed if view gets detached`() {
+        val activity = Robolectric.buildActivity(Activity::class.java).create().get()
+        val view = View(testContext)
+        activity.windowManager.addView(view, WindowManager.LayoutParams(100, 100))
+
+        assertTrue(view.isAttachedToWindow)
+
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var stateObserved = false
+        store.observe(view) { stateObserved = true }
+        assertTrue(stateObserved)
+
+        stateObserved = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(stateObserved)
+
+        activity.windowManager.removeView(view)
+        assertFalse(view.isAttachedToWindow)
+
+        stateObserved = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertFalse(stateObserved)
+    }
+}
+
+private class MockedLifecycleOwner(initialState: Lifecycle.State) : LifecycleOwner {
+    val lifecycleRegistry = LifecycleRegistry(this).apply {
+        markState(initialState)
+    }
+
+    override fun getLifecycle(): Lifecycle = lifecycleRegistry
+}
diff --git a/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/helpers/HelpersKtTest.kt b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/helpers/HelpersKtTest.kt
new file mode 100644
index 000000000000..06cb8d6eb134
--- /dev/null
+++ b/android-components/components/lib/state/src/test/java/mozilla/components/lib/state/helpers/HelpersKtTest.kt
@@ -0,0 +1,91 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.lib.state.helpers
+
+import mozilla.components.lib.state.Store
+import mozilla.components.lib.state.TestAction
+import mozilla.components.lib.state.TestState
+import mozilla.components.lib.state.joinBlocking
+import mozilla.components.lib.state.reducer
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class HelpersKtTest {
+    @Test
+    fun `onlyIfChanged observer only invokes "then" lambda if value has changed`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var callbackExecuted = false
+        var callbackValue = false
+
+        store.observeManually(onlyIfChanged<TestState, Boolean>(
+            map = { state -> state.counter % 2 == 0 },
+            then = { _, _isEven ->
+                callbackExecuted = true
+                callbackValue = _isEven
+            }
+        ))
+
+        // Initial notify
+        assertTrue(callbackExecuted)
+        assertFalse(callbackValue)
+
+        // Mapped value changed
+        callbackExecuted = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(callbackExecuted)
+        assertTrue(callbackValue)
+
+        // Mapped value stays the same
+        callbackExecuted = false
+        store.dispatch(TestAction.SetValueAction(22)).joinBlocking()
+        assertFalse(callbackExecuted)
+
+        // Mapped value changes again
+        callbackExecuted = false
+        store.dispatch(TestAction.SetValueAction(21)).joinBlocking()
+        assertTrue(callbackExecuted)
+        assertFalse(callbackValue)
+    }
+
+    @Test
+    fun `onlyIfChanged observer will not invoke "then" lambda if mapped value is null`() {
+        val store = Store(
+            TestState(counter = 23),
+            ::reducer
+        )
+
+        var callbackExecuted = false
+
+        store.observeManually(onlyIfChanged<TestState, TestState>(
+            map = { state -> if (state.counter % 2 == 0) null else state },
+            then = { _, _ ->
+                callbackExecuted = true
+            }
+        ))
+
+        assertTrue(callbackExecuted)
+
+        callbackExecuted = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertFalse(callbackExecuted)
+
+        callbackExecuted = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(callbackExecuted)
+
+        callbackExecuted = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertFalse(callbackExecuted)
+
+        callbackExecuted = false
+        store.dispatch(TestAction.IncrementAction).joinBlocking()
+        assertTrue(callbackExecuted)
+    }
+}
diff --git a/android-components/components/lib/state/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/android-components/components/lib/state/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 000000000000..cf1c399ea81e
--- /dev/null
+++ b/android-components/components/lib/state/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1,2 @@
+mock-maker-inline
+// This allows mocking final classes (classes are final by default in Kotlin)
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index 67374902b2cc..a237c569d35e 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -12,6 +12,9 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Config.kt)
 
+* **lib-state**
+  * A new component for maintaining application, screen or component state via a redux-style `Store`. This component provides the architectural foundation for the `browser-state` component (in development). 
+
 # 1.0.0
 
 * [Commits](https://github.com/mozilla-mobile/android-components/compare/v0.56.0...v1.0.0)
