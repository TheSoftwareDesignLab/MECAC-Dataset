diff --git a/android-components/components/service/firefox-accounts/build.gradle b/android-components/components/service/firefox-accounts/build.gradle
index 775cf5d3e2f2..83d09eeeaed6 100644
--- a/android-components/components/service/firefox-accounts/build.gradle
+++ b/android-components/components/service/firefox-accounts/build.gradle
@@ -31,9 +31,13 @@ dependencies {
     // Parts of this dependency are typealiase'd or are otherwise part of this module's public API.
     api Dependencies.mozilla_fxa
 
+    // Observable is part of public API of the FxaAccountManager.
+    api project(':support-base')
+
     implementation Dependencies.kotlin_stdlib
     implementation Dependencies.kotlin_coroutines
 
+    testImplementation project(':support-test')
     testImplementation Dependencies.testing_junit
     testImplementation Dependencies.testing_robolectric
     testImplementation Dependencies.testing_mockito
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/AccountStorage.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/AccountStorage.kt
new file mode 100644
index 000000000000..54901a9dffc1
--- /dev/null
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/AccountStorage.kt
@@ -0,0 +1,49 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.service.fxa
+
+import android.content.Context
+import android.content.SharedPreferences
+
+const val FXA_STATE_PREFS_KEY = "fxaAppState"
+const val FXA_STATE_KEY = "fxaState"
+
+interface AccountStorage {
+    @Throws(Exception::class)
+    fun read(): FirefoxAccountShaped?
+    fun write(account: FirefoxAccountShaped)
+    fun clear()
+}
+
+class SharedPrefAccountStorage(val context: Context) : AccountStorage {
+    /**
+     * @throws FxaException if JSON failed to parse into a [FirefoxAccount].
+     */
+    override fun read(): FirefoxAccountShaped? {
+        val savedJSON = accountPreferences().getString(FXA_STATE_KEY, null)
+                ?: return null
+
+        // May throw a generic FxaException if it fails to process saved JSON.
+        return FirefoxAccount.fromJSONString(savedJSON)
+    }
+
+    override fun write(account: FirefoxAccountShaped) {
+        accountPreferences()
+            .edit()
+            .putString(FXA_STATE_KEY, account.toJSONString())
+            .apply()
+    }
+
+    override fun clear() {
+        accountPreferences()
+            .edit()
+            .remove(FXA_STATE_KEY)
+            .apply()
+    }
+
+    private fun accountPreferences(): SharedPreferences {
+        return context.getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE)
+    }
+}
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
index 461b33641402..0baf243bb376 100644
--- a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FirefoxAccount.kt
@@ -16,15 +16,21 @@ import org.mozilla.fxaclient.internal.FxaException.Unauthorized as Unauthorized
 /**
  * Facilitates testing consumers of FirefoxAccount.
  */
-interface FirefoxAccountShaped {
+interface FirefoxAccountShaped : AutoCloseable {
+    fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String>
+    fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String>
+    fun getProfile(ignoreCache: Boolean): Deferred<Profile>
+    fun getProfile(): Deferred<Profile>
+    fun completeOAuthFlow(code: String, state: String): Deferred<Unit>
     fun getAccessToken(singleScope: String): Deferred<AccessTokenInfo>
     fun getTokenServerEndpointURL(): String
+    fun toJSONString(): String
 }
 
 /**
  * FirefoxAccount represents the authentication state of a client.
  */
-class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : AutoCloseable, FirefoxAccountShaped {
+class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : FirefoxAccountShaped {
 
     private val job = SupervisorJob()
     private val scope = CoroutineScope(Dispatchers.IO) + job
@@ -50,11 +56,11 @@ class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : A
      * @param wantsKeys Fetch keys for end-to-end encryption of data from Mozilla-hosted services
      * @return Deferred<String> that resolves to the flow URL when complete
      */
-    fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String> {
+    override fun beginOAuthFlow(scopes: Array<String>, wantsKeys: Boolean): Deferred<String> {
         return scope.async { inner.beginOAuthFlow(scopes, wantsKeys) }
     }
 
-    fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String> {
+    override fun beginPairingFlow(pairingUrl: String, scopes: Array<String>): Deferred<String> {
         return scope.async { inner.beginPairingFlow(pairingUrl, scopes) }
     }
 
@@ -67,7 +73,7 @@ class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : A
      * @throws Unauthorized We couldn't find any suitable access token to make that call.
      * The caller should then start the OAuth Flow again with the "profile" scope.
      */
-    fun getProfile(ignoreCache: Boolean): Deferred<Profile> {
+    override fun getProfile(ignoreCache: Boolean): Deferred<Profile> {
         return scope.async {
             val internalProfile = inner.getProfile(ignoreCache)
             Profile(
@@ -87,7 +93,7 @@ class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : A
      * @throws Unauthorized We couldn't find any suitable access token to make that call.
      * The caller should then start the OAuth Flow again with the "profile" scope.
      */
-    fun getProfile(): Deferred<Profile> = getProfile(false)
+    override fun getProfile(): Deferred<Profile> = getProfile(false)
 
     /**
      * Fetches the token server endpoint, for authentication using the SAML bearer flow.
@@ -109,7 +115,7 @@ class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : A
      *
      * Modifies the FirefoxAccount state.
      */
-    fun completeOAuthFlow(code: String, state: String): Deferred<Unit> {
+    override fun completeOAuthFlow(code: String, state: String): Deferred<Unit> {
         return scope.async { inner.completeOAuthFlow(code, state) }
     }
 
@@ -135,7 +141,7 @@ class FirefoxAccount internal constructor(private val inner: InternalFxAcct) : A
      *
      * @return String containing the authentication details in JSON format
      */
-    fun toJSONString(): String = inner.toJSONString()
+    override fun toJSONString(): String = inner.toJSONString()
 
     companion object {
         /**
diff --git a/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaAccountManager.kt b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaAccountManager.kt
new file mode 100644
index 000000000000..28eada8a2695
--- /dev/null
+++ b/android-components/components/service/firefox-accounts/src/main/java/mozilla/components/service/fxa/FxaAccountManager.kt
@@ -0,0 +1,426 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.service.fxa
+
+import android.content.Context
+import android.support.annotation.VisibleForTesting
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.SupervisorJob
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.async
+import java.util.concurrent.ConcurrentLinkedQueue
+import kotlin.coroutines.CoroutineContext
+
+import mozilla.components.support.base.log.Log
+import mozilla.components.support.base.observer.Observable
+import mozilla.components.support.base.observer.ObserverRegistry
+import java.io.Closeable
+import java.util.concurrent.Executors
+
+enum class AccountState {
+    Start,
+    NotAuthenticated,
+    AuthenticatedNoProfile,
+    AuthenticatedWithProfile
+}
+
+/**
+ * Base class for account manager state machine events.
+ * Events aren't a simple enum class because we might want to pass data along with some of the events.
+ */
+internal sealed class Event {
+    override fun toString(): String {
+        // For a better logcat experience.
+        return this.javaClass.simpleName
+    }
+
+    internal object Init : Event()
+
+    object AccountNotFound : Event()
+    object AccountRestored : Event()
+
+    object Authenticate : Event()
+    data class Authenticated(val code: String, val state: String) : Event() {
+        override fun toString(): String {
+            // data classes define their own toString, so we override it here as well as in the base
+            // class to avoid exposing 'code' and 'state' in logs.
+            return this.javaClass.simpleName
+        }
+    }
+    object FetchProfile : Event()
+    object FetchedProfile : Event()
+
+    object FailedToAuthenticate : Event()
+    object FailedToFetchProfile : Event()
+
+    object Logout : Event()
+}
+
+/**
+ * Propagated via [AccountObserver.onError] if we fail to load a locally stored account during
+ * initialization. No action is necessary from consumers.
+ * Account state has been re-initialized.
+ *
+ * @param cause Optional original cause of failure.
+ */
+class FailedToLoadAccountException(cause: Exception?) : Exception(cause)
+
+/**
+ * Observer interface which lets its consumers respond to authentication requests.
+ */
+private interface OAuthObserver {
+    /**
+     * Account manager is requesting for an OAUTH flow to begin.
+     * @param authUrl Starting point for the OAUTH flow.
+     */
+    fun onBeginOAuthFlow(authUrl: String)
+
+    /**
+     * Account manager encountered an error during authentication. Inspect [error] for details.
+     * @param error A specific FxA error encountered.
+     */
+    fun onError(error: FxaException)
+}
+
+/**
+ * Observer interface which lets its users monitor account state changes and major events.
+ */
+interface AccountObserver {
+    /**
+     * Account just got logged out.
+     */
+    fun onLoggedOut()
+
+    /**
+     * Account was successfully authenticated.
+     * @param account An authenticated instance of a [FirefoxAccountShaped].
+     */
+    fun onAuthenticated(account: FirefoxAccountShaped)
+
+    /**
+     * Account's profile is now available.
+     * @param profile A fresh version of account's [Profile].
+     */
+    fun onProfileUpdated(profile: Profile)
+
+    /**
+     * Account manager encountered an error. Inspect [error] for details.
+     * @param error A specific error encountered.
+     */
+    fun onError(error: Exception)
+}
+
+/**
+ * An account manager which encapsulates various internal details of an account lifecycle and provides
+ * an observer interface along with a public API for interacting with an account.
+ * The internal state machine abstracts over state space as exposed by the fxaclient library, not
+ * the internal states experienced by lower-level representation of a Firefox Account; those are opaque to us.
+ *
+ * Class is 'open' to facilitate testing.
+ *
+ * @param context A [Context] instance that's used for internal messaging and interacting with local storage.
+ * @param config A [Config] used for account initialization.
+ * @param scopes A list of scopes which will be requested during account authentication.
+ */
+@Suppress("TooManyFunctions")
+open class FxaAccountManager(
+    private val context: Context,
+    private val config: Config,
+    private val scopes: Array<String>,
+    private val accountStorage: AccountStorage = SharedPrefAccountStorage(context)
+) : Closeable, Observable<AccountObserver> by ObserverRegistry() {
+    private val logTag = "FirefoxAccountStateMachine"
+
+    private val oauth = object : Observable<OAuthObserver> by ObserverRegistry() {}
+
+    companion object {
+        /**
+         * State transition matrix. It's in the companion object to enforce purity.
+         * @return An optional [AccountState] if provided state+event combination results in a
+         * state transition. Note that states may transition into themselves.
+         */
+        @Suppress("ComplexMethod")
+        internal fun nextState(state: AccountState, event: Event): AccountState? {
+            return when (state) {
+                AccountState.Start -> {
+                    when (event) {
+                        Event.Init -> AccountState.Start
+                        Event.AccountNotFound -> AccountState.NotAuthenticated
+                        Event.AccountRestored -> AccountState.AuthenticatedNoProfile
+                        else -> null
+                    }
+                }
+                AccountState.NotAuthenticated -> {
+                    when (event) {
+                        Event.Authenticate -> AccountState.NotAuthenticated
+                        Event.FailedToAuthenticate -> AccountState.NotAuthenticated
+                        is Event.Authenticated -> AccountState.AuthenticatedNoProfile
+                        else -> null
+                    }
+                }
+                AccountState.AuthenticatedNoProfile -> {
+                    when (event) {
+                        Event.FetchProfile -> AccountState.AuthenticatedNoProfile
+                        Event.FetchedProfile -> AccountState.AuthenticatedWithProfile
+                        Event.FailedToFetchProfile -> AccountState.AuthenticatedNoProfile
+                        Event.Logout -> AccountState.NotAuthenticated
+                        else -> null
+                    }
+                }
+                AccountState.AuthenticatedWithProfile -> {
+                    when (event) {
+                        Event.Logout -> AccountState.NotAuthenticated
+                        else -> null
+                    }
+                }
+            }
+        }
+    }
+
+    private val job = SupervisorJob()
+    // We want a single-threaded execution model for our account-related "actions" (state machine side-effects).
+    // That is, we want to ensure a sequential execution flow, but on a background thread.
+    private val coroutineContext: CoroutineContext
+        get() = Executors.newSingleThreadExecutor().asCoroutineDispatcher() + job
+
+    // 'account' is initialized during processing of an 'Init' event.
+    // Note on threading: we use a single-threaded executor, so there's no concurrent access possible.
+    // However, that executor doesn't guarantee that it'll always use the same thread, and so vars
+    // are marked as volatile for across-thread visibility. Similarly, event queue uses a concurrent
+    // list, although that's probably an overkill.
+    @Volatile private lateinit var account: FirefoxAccountShaped
+    @Volatile private var profile: Profile? = null
+    @Volatile private var state = AccountState.Start
+    private val eventQueue = ConcurrentLinkedQueue<Event>()
+
+    /**
+     * Call this after registering your observers, and before interacting with this class.
+     */
+    fun init(): Deferred<Unit> {
+        return processQueue(Event.Init)
+    }
+
+    fun authenticatedAccount(): FirefoxAccountShaped? {
+        return when (state) {
+            AccountState.AuthenticatedWithProfile,
+            AccountState.AuthenticatedNoProfile -> account
+            else -> null
+        }
+    }
+
+    fun accountProfile(): Profile? {
+        return when (state) {
+            AccountState.AuthenticatedWithProfile -> profile
+            else -> null
+        }
+    }
+
+    fun updateProfile(): Deferred<Unit> {
+        return processQueue(Event.FetchProfile)
+    }
+
+    fun beginAuthentication(): Deferred<String> {
+        val deferredAuthUrl: CompletableDeferred<String> = CompletableDeferred()
+
+        oauth.register(object : OAuthObserver {
+            override fun onBeginOAuthFlow(authUrl: String) {
+                oauth.unregister(this)
+                deferredAuthUrl.complete(authUrl)
+            }
+
+            override fun onError(error: FxaException) {
+                oauth.unregister(this)
+                deferredAuthUrl.completeExceptionally(error)
+            }
+        })
+
+        processQueue(Event.Authenticate)
+
+        return deferredAuthUrl
+    }
+
+    fun finishAuthentication(code: String, state: String): Deferred<Unit> {
+        return processQueue(Event.Authenticated(code, state))
+    }
+
+    fun logout(): Deferred<Unit> {
+        return processQueue(Event.Logout)
+    }
+
+    override fun close() {
+        job.cancel()
+        account.close()
+    }
+
+    /**
+     * Pumps the state machine until all events are processed and their side-effects resolve.
+     */
+    private fun processQueue(event: Event): Deferred<Unit> = CoroutineScope(coroutineContext).async {
+        eventQueue.add(event)
+        do {
+            val toProcess = eventQueue.poll()
+            val transitionInto = nextState(state, toProcess)
+
+            if (transitionInto == null) {
+                Log.log(
+                    tag = logTag,
+                    message = "Got invalid event $toProcess for state $state."
+                )
+                continue
+            }
+
+            Log.log(
+                tag = logTag,
+                message = "Processing event $toProcess for state $state. Next state is $transitionInto"
+            )
+
+            state = transitionInto
+
+            stateActions(state, toProcess)?.let { successiveEvent ->
+                Log.log(
+                    tag = logTag,
+                    message = "Ran '$toProcess' side-effects for state $state, got successive event $successiveEvent"
+                )
+                eventQueue.add(successiveEvent)
+            }
+        } while (!eventQueue.isEmpty())
+    }
+
+    /**
+     * Side-effects matrix. Defines non-pure operations that must take place for state+event combinations.
+     */
+    @Suppress("ComplexMethod")
+    private suspend fun stateActions(forState: AccountState, via: Event): Event? {
+        // We're about to enter a new state ('forState') via some event ('via').
+        // States will have certain side-effects associated with different event transitions.
+        // In other words, the same state may have different side-effects depending on the event
+        // which caused a transition.
+        // For example, a "NotAuthenticated" state may be entered after a logout, and its side-effects
+        // will include clean-up and re-initialization of an account. Alternatively, it may be entered
+        // after we've checked local disk, and didn't find a persisted authenticated account.
+        return when (forState) {
+            AccountState.Start -> {
+                when (via) {
+                    Event.Init -> {
+                        // Locally corrupt accounts are simply treated as 'absent'.
+                        val savedAccount = try {
+                            accountStorage.read()
+                        } catch (e: FxaException) {
+                            Log.log(
+                                tag = logTag,
+                                priority = Log.Priority.ERROR,
+                                throwable = e,
+                                message = "Failed to load saved account."
+                            )
+
+                            notifyObservers { onError(FailedToLoadAccountException(e)) }
+
+                            null
+                        }
+
+                        if (savedAccount == null) {
+                            Event.AccountNotFound
+                        } else {
+                            account = savedAccount
+                            Event.AccountRestored
+                        }
+                    }
+                    else -> null
+                }
+            }
+            AccountState.NotAuthenticated -> {
+                when (via) {
+                    Event.Logout -> {
+                        // Clean up resources.
+                        profile = null
+                        account.close()
+                        // Delete persisted state.
+                        accountStorage.clear()
+                        // Re-initialize account.
+                        account = createAccount(config)
+
+                        notifyObservers { onLoggedOut() }
+
+                        null
+                    }
+                    Event.AccountNotFound -> {
+                        account = createAccount(config)
+
+                        notifyObservers { onLoggedOut() }
+
+                        null
+                    }
+                    Event.Authenticate -> {
+                        val url = try {
+                            account.beginOAuthFlow(scopes, true).await()
+                        } catch (e: FxaException) {
+                            oauth.notifyObservers { onError(e) }
+                            return Event.FailedToAuthenticate
+                        }
+                        oauth.notifyObservers { onBeginOAuthFlow(url) }
+                        null
+                    }
+                    else -> null
+                }
+            }
+            AccountState.AuthenticatedNoProfile -> {
+                when (via) {
+                    is Event.Authenticated -> {
+                        account.completeOAuthFlow(via.code, via.state).await()
+                        accountStorage.write(account)
+
+                        notifyObservers { onAuthenticated(account) }
+
+                        Event.FetchProfile
+                    }
+                    Event.AccountRestored -> {
+                        notifyObservers { onAuthenticated(account) }
+
+                        Event.FetchProfile
+                    }
+                    Event.FetchProfile -> {
+                        // Profile fetching and account authentication issues:
+                        // https://github.com/mozilla/application-services/issues/483
+                        Log.log(tag = logTag, message = "Fetching profile...")
+                        profile = try {
+                            account.getProfile(true).await()
+                        } catch (e: FxaException) {
+                            Log.log(
+                                Log.Priority.ERROR,
+                                message = "Failed to get profile for authenticated account",
+                                throwable = e,
+                                tag = logTag
+                            )
+
+                            notifyObservers { onError(e) }
+
+                            return Event.FailedToFetchProfile
+                        }
+                        Event.FetchedProfile
+                    }
+                    else -> null
+                }
+            }
+            AccountState.AuthenticatedWithProfile -> {
+                when (via) {
+                    Event.FetchedProfile -> {
+                        notifyObservers {
+                            onProfileUpdated(profile!!)
+                        }
+                        null
+                    }
+                    else -> null
+                }
+            }
+        }
+    }
+
+    @VisibleForTesting
+    open fun createAccount(config: Config): FirefoxAccountShaped {
+        return FirefoxAccount(config)
+    }
+}
diff --git a/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt
new file mode 100644
index 000000000000..4a6c163ef8b2
--- /dev/null
+++ b/android-components/components/service/firefox-accounts/src/test/java/mozilla/components/service/fxa/FxaAccountManagerTest.kt
@@ -0,0 +1,485 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.service.fxa
+
+import android.content.Context
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.runBlocking
+import mozilla.components.support.test.any
+import mozilla.components.support.test.mock
+import org.junit.Test
+
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers
+import org.mockito.Mockito.`when`
+import org.mockito.Mockito.never
+import org.mockito.Mockito.reset
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+
+// Same as the actual account manager, except we get to control how FirefoxAccountShaped instances
+// are created. This is necessary because due to some build issues (native dependencies not available
+// within the test environment) we can't use fxaclient supplied implementation of FirefoxAccountShaped.
+// Instead, we express all of our account-related operations over an interface.
+class TestableFxaAccountManager(
+    context: Context,
+    config: Config,
+    scopes: Array<String>,
+    accountStorage: AccountStorage = SharedPrefAccountStorage(context),
+    val block: () -> FirefoxAccountShaped = { mock() }
+) : FxaAccountManager(context, config, scopes, accountStorage) {
+    override fun createAccount(config: Config): FirefoxAccountShaped {
+        return block()
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class FxaAccountManagerTest {
+    @Test
+    fun `state transitions`() {
+        // State 'Start'.
+        var state = AccountState.Start
+
+        assertEquals(AccountState.Start, FxaAccountManager.nextState(state, Event.Init))
+        assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.AccountNotFound))
+        assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.AccountRestored))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticate))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticated("code", "state")))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchedProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
+        assertNull(FxaAccountManager.nextState(state, Event.Logout))
+
+        // State 'NotAuthenticated'.
+        state = AccountState.NotAuthenticated
+        assertNull(FxaAccountManager.nextState(state, Event.Init))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountNotFound))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountRestored))
+        assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Authenticate))
+        assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.Authenticated("code", "state")))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchedProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
+        assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
+        assertNull(FxaAccountManager.nextState(state, Event.Logout))
+
+        // State 'AuthenticatedNoProfile'.
+        state = AccountState.AuthenticatedNoProfile
+        assertNull(FxaAccountManager.nextState(state, Event.Init))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountNotFound))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountRestored))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticate))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticated("code", "state")))
+        assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.FetchProfile))
+        assertEquals(AccountState.AuthenticatedWithProfile, FxaAccountManager.nextState(state, Event.FetchedProfile))
+        assertEquals(AccountState.AuthenticatedNoProfile, FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
+        assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Logout))
+
+        // State 'AuthenticatedWithProfile'.
+        state = AccountState.AuthenticatedWithProfile
+        assertNull(FxaAccountManager.nextState(state, Event.Init))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountNotFound))
+        assertNull(FxaAccountManager.nextState(state, Event.AccountRestored))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticate))
+        assertNull(FxaAccountManager.nextState(state, Event.Authenticated("code", "state")))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FetchedProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToFetchProfile))
+        assertNull(FxaAccountManager.nextState(state, Event.FailedToAuthenticate))
+        assertEquals(AccountState.NotAuthenticated, FxaAccountManager.nextState(state, Event.Logout))
+    }
+
+    @Test
+    fun `error reading persisted account`() {
+        val accountStorage = mock<AccountStorage>()
+        val readException = FxaException("pretend we failed to parse the account")
+        `when`(accountStorage.read()).thenThrow(readException)
+
+        val manager = TestableFxaAccountManager(
+            RuntimeEnvironment.application,
+            Config.release("dummyId", "bad://url"),
+            arrayOf("profile"),
+            accountStorage
+        )
+
+        var onLoggedOutCalled = false
+        var onErrorCalled = false
+
+        val accountObserver = object : AccountObserver {
+            override fun onLoggedOut() {
+                assertFalse(onLoggedOutCalled)
+                onLoggedOutCalled = true
+            }
+
+            override fun onAuthenticated(account: FirefoxAccountShaped) {
+                fail()
+            }
+
+            override fun onProfileUpdated(profile: Profile) {
+                fail()
+            }
+
+            override fun onError(error: Exception) {
+                assertFalse(onErrorCalled)
+                onErrorCalled = true
+                assertTrue(error is FailedToLoadAccountException)
+                assertEquals(error.cause, readException)
+            }
+        }
+
+        manager.register(accountObserver)
+
+        runBlocking {
+            manager.init().await()
+        }
+
+        assertTrue(onErrorCalled)
+        assertTrue(onLoggedOutCalled)
+    }
+
+    @Test
+    fun `no persisted account`() = runBlocking {
+        val accountStorage = mock<AccountStorage>()
+        // There's no account at the start.
+        `when`(accountStorage.read()).thenReturn(null)
+
+        val manager = TestableFxaAccountManager(
+                RuntimeEnvironment.application,
+                Config.release("dummyId", "bad://url"),
+                arrayOf("profile"),
+                accountStorage
+        )
+
+        val accountObserver: AccountObserver = mock()
+
+        manager.register(accountObserver)
+        manager.init().await()
+
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, never()).onAuthenticated(any())
+        verify(accountObserver, never()).onProfileUpdated(any())
+        verify(accountObserver, times(1)).onLoggedOut()
+
+        verify(accountStorage, times(1)).read()
+        verify(accountStorage, never()).write(any())
+        verify(accountStorage, never()).clear()
+
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+    }
+
+    @Test
+    fun `with persisted account and profile`() = runBlocking {
+        val accountStorage = mock<AccountStorage>()
+        val mockAccount: FirefoxAccountShaped = mock()
+        val profile = Profile(
+                "testUid", "test@example.com", null, "Test Profile")
+        `when`(mockAccount.getProfile(ArgumentMatchers.anyBoolean())).thenReturn(CompletableDeferred(profile))
+        // We have an account at the start.
+        `when`(accountStorage.read()).thenReturn(mockAccount)
+
+        val manager = TestableFxaAccountManager(
+                RuntimeEnvironment.application,
+                Config.release("dummyId", "bad://url"),
+                arrayOf("profile"),
+                accountStorage
+        )
+
+        val accountObserver: AccountObserver = mock()
+
+        manager.register(accountObserver)
+
+        manager.init().await()
+
+        // Make sure that account and profile observers are fired exactly once.
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, times(1)).onAuthenticated(mockAccount)
+        verify(accountObserver, times(1)).onProfileUpdated(profile)
+        verify(accountObserver, never()).onLoggedOut()
+
+        verify(accountStorage, times(1)).read()
+        verify(accountStorage, never()).write(any())
+        verify(accountStorage, never()).clear()
+
+        assertEquals(mockAccount, manager.authenticatedAccount())
+        assertEquals(profile, manager.accountProfile())
+
+        // Make sure 'logout' clears out state and fires correct observers.
+        reset(accountObserver)
+        reset(accountStorage)
+        manager.logout().await()
+
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, never()).onAuthenticated(any())
+        verify(accountObserver, never()).onProfileUpdated(any())
+        verify(accountObserver, times(1)).onLoggedOut()
+
+        verify(accountStorage, never()).read()
+        verify(accountStorage, never()).write(any())
+        verify(accountStorage, times(1)).clear()
+
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        manager.close()
+
+        verify(mockAccount, times(1)).close()
+    }
+
+    @Test
+    fun `happy authentication and profile flow`() {
+        val accountStorage = mock<AccountStorage>()
+        val mockAccount: FirefoxAccountShaped = mock()
+
+        val profile = Profile(
+            uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
+
+        `when`(mockAccount.getProfile(ArgumentMatchers.anyBoolean())).thenReturn(CompletableDeferred(profile))
+        `when`(mockAccount.beginOAuthFlow(any(), ArgumentMatchers.anyBoolean()))
+                .thenReturn(CompletableDeferred("auth://url"))
+        // This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
+        // and threads will deadlock since it'll never be resolved while state machine is waiting for it.
+        // So we manually complete it here!
+        val unitDeferred = CompletableDeferred<Unit>()
+        unitDeferred.complete(Unit)
+        `when`(mockAccount.completeOAuthFlow(
+            ArgumentMatchers.anyString(), ArgumentMatchers.anyString())
+        ).thenReturn(unitDeferred)
+        // There's no account at the start.
+        `when`(accountStorage.read()).thenReturn(null)
+
+        val manager = TestableFxaAccountManager(
+                RuntimeEnvironment.application,
+                Config.release("dummyId", "bad://url"),
+                arrayOf("profile", "test-scope"),
+                accountStorage
+        ) {
+            mockAccount
+        }
+
+        val accountObserver: AccountObserver = mock()
+
+        manager.register(accountObserver)
+
+        runBlocking {
+            manager.init().await()
+        }
+
+        // We start off as logged-out.
+        verify(accountObserver, times(1)).onLoggedOut()
+
+        reset(accountObserver)
+        runBlocking {
+            assertEquals("auth://url", manager.beginAuthentication().await())
+        }
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        runBlocking {
+            manager.finishAuthentication("dummyCode", "dummyState").await()
+        }
+
+        verify(accountStorage, times(1)).read()
+        // Confirm account is persisted after authentication.
+        verify(accountStorage, times(1)).write(mockAccount)
+        verify(accountStorage, never()).clear()
+
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, times(1)).onAuthenticated(mockAccount)
+        verify(accountObserver, times(1)).onProfileUpdated(profile)
+        verify(accountObserver, never()).onLoggedOut()
+
+        assertEquals(mockAccount, manager.authenticatedAccount())
+        assertEquals(profile, manager.accountProfile())
+    }
+
+    @Test
+    fun `unhappy authentication flow`() {
+        val accountStorage = mock<AccountStorage>()
+        val mockAccount: FirefoxAccountShaped = mock()
+
+        val profile = Profile(
+                uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
+
+        `when`(mockAccount.getProfile(ArgumentMatchers.anyBoolean())).thenReturn(CompletableDeferred(profile))
+
+        // Pretend we have a network problem while initiating an auth flow.
+        val exceptionalDeferred = CompletableDeferred<String>()
+        val fxaException = FxaNetworkException("network problem")
+        exceptionalDeferred.completeExceptionally(fxaException)
+
+        `when`(mockAccount.beginOAuthFlow(any(), ArgumentMatchers.anyBoolean()))
+                .thenReturn(exceptionalDeferred)
+
+        // This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
+        // and threads will deadlock since it'll never be resolved while state machine is waiting for it.
+        // So we manually complete it here!
+        val unitDeferred = CompletableDeferred<Unit>()
+        unitDeferred.complete(Unit)
+        `when`(mockAccount.completeOAuthFlow(
+                ArgumentMatchers.anyString(), ArgumentMatchers.anyString())
+        ).thenReturn(unitDeferred)
+        // There's no account at the start.
+        `when`(accountStorage.read()).thenReturn(null)
+
+        val manager = TestableFxaAccountManager(
+                RuntimeEnvironment.application,
+                Config.release("dummyId", "bad://url"),
+                arrayOf("profile", "test-scope"),
+                accountStorage
+        ) {
+            mockAccount
+        }
+
+        val accountObserver: AccountObserver = mock()
+
+        manager.register(accountObserver)
+
+        runBlocking {
+            manager.init().await()
+        }
+
+        // We start off as logged-out.
+        verify(accountObserver, times(1)).onLoggedOut()
+
+        reset(accountObserver)
+        runBlocking {
+            try {
+                manager.beginAuthentication().await()
+                fail()
+            } catch (e: FxaNetworkException) {
+                assertEquals(fxaException, e)
+            }
+        }
+        // Confirm that account state observable doesn't receive authentication errors.
+        verify(accountObserver, never()).onError(any())
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        // Try again, without any network problems this time.
+        exceptionalDeferred.completeExceptionally(fxaException)
+        `when`(mockAccount.beginOAuthFlow(any(), ArgumentMatchers.anyBoolean()))
+                .thenReturn(CompletableDeferred("auth://url"))
+
+        runBlocking {
+            assertEquals("auth://url", manager.beginAuthentication().await())
+        }
+
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        runBlocking {
+            manager.finishAuthentication("dummyCode", "dummyState").await()
+        }
+
+        verify(accountStorage, times(1)).read()
+        // Confirm account is persisted after authentication.
+        verify(accountStorage, times(1)).write(mockAccount)
+        verify(accountStorage, never()).clear()
+
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, times(1)).onAuthenticated(mockAccount)
+        verify(accountObserver, times(1)).onProfileUpdated(profile)
+        verify(accountObserver, never()).onLoggedOut()
+
+        assertEquals(mockAccount, manager.authenticatedAccount())
+        assertEquals(profile, manager.accountProfile())
+    }
+
+    @Test
+    fun `unhappy profile fetching flow`() {
+        val accountStorage = mock<AccountStorage>()
+        val mockAccount: FirefoxAccountShaped = mock()
+
+        val exceptionalProfile = CompletableDeferred<Profile>()
+        val fxaException = FxaException("test exception")
+        exceptionalProfile.completeExceptionally(fxaException)
+
+        `when`(mockAccount.getProfile(ArgumentMatchers.anyBoolean())).thenReturn(exceptionalProfile)
+        `when`(mockAccount.beginOAuthFlow(any(), ArgumentMatchers.anyBoolean()))
+                .thenReturn(CompletableDeferred("auth://url"))
+        // This ceremony is necessary because CompletableDeferred<Unit>() is created in an _active_ state,
+        // and threads will deadlock since it'll never be resolved while state machine is waiting for it.
+        // So we manually complete it here!
+        val unitDeferred = CompletableDeferred<Unit>()
+        unitDeferred.complete(Unit)
+        `when`(mockAccount.completeOAuthFlow(
+                ArgumentMatchers.anyString(), ArgumentMatchers.anyString())
+        ).thenReturn(unitDeferred)
+        // There's no account at the start.
+        `when`(accountStorage.read()).thenReturn(null)
+
+        val manager = TestableFxaAccountManager(
+                RuntimeEnvironment.application,
+                Config.release("dummyId", "bad://url"),
+                arrayOf("profile", "test-scope"),
+                accountStorage
+        ) {
+            mockAccount
+        }
+
+        val accountObserver: AccountObserver = mock()
+
+        manager.register(accountObserver)
+
+        runBlocking {
+            manager.init().await()
+        }
+
+        // We start off as logged-out.
+        verify(accountObserver, times(1)).onLoggedOut()
+
+        reset(accountObserver)
+        runBlocking {
+            assertEquals("auth://url", manager.beginAuthentication().await())
+        }
+        assertNull(manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        runBlocking {
+            manager.finishAuthentication("dummyCode", "dummyState").await()
+        }
+
+        verify(accountStorage, times(1)).read()
+        // Confirm account is persisted after authentication.
+        verify(accountStorage, times(1)).write(mockAccount)
+        verify(accountStorage, never()).clear()
+
+        verify(accountObserver, times(1)).onError(fxaException)
+        verify(accountObserver, times(1)).onAuthenticated(mockAccount)
+        verify(accountObserver, never()).onProfileUpdated(any())
+        verify(accountObserver, never()).onLoggedOut()
+
+        assertEquals(mockAccount, manager.authenticatedAccount())
+        assertNull(manager.accountProfile())
+
+        // Make sure we can re-try fetching a profile. This time, let's have it succeed.
+        reset(accountObserver)
+        val profile = Profile(
+            uid = "testUID", avatar = null, email = "test@example.com", displayName = "test profile")
+
+        `when`(mockAccount.getProfile(ArgumentMatchers.anyBoolean())).thenReturn(CompletableDeferred(profile))
+
+        runBlocking {
+            manager.updateProfile().await()
+        }
+
+        verify(accountObserver, times(1)).onProfileUpdated(profile)
+        verify(accountObserver, never()).onError(any())
+        verify(accountObserver, never()).onAuthenticated(any())
+        verify(accountObserver, never()).onLoggedOut()
+        assertEquals(profile, manager.accountProfile())
+    }
+}
diff --git a/android-components/samples/sync-history/src/main/java/org/mozilla/samples/sync/history/MainActivity.kt b/android-components/samples/sync-history/src/main/java/org/mozilla/samples/sync/history/MainActivity.kt
index 7fb7bb1e8976..eb2464049e50 100644
--- a/android-components/samples/sync-history/src/main/java/org/mozilla/samples/sync/history/MainActivity.kt
+++ b/android-components/samples/sync-history/src/main/java/org/mozilla/samples/sync/history/MainActivity.kt
@@ -4,7 +4,6 @@
 
 package org.mozilla.samples.sync.history
 
-import android.content.Context
 import android.os.Bundle
 import android.support.v7.app.AppCompatActivity
 import android.view.View
@@ -20,19 +19,29 @@ import mozilla.components.browser.storage.sync.SyncAuthInfo
 import mozilla.components.concept.storage.SyncError
 import mozilla.components.feature.sync.FirefoxSyncFeature
 import mozilla.components.feature.sync.SyncStatusObserver
-import mozilla.components.service.fxa.FirefoxAccount
-import mozilla.components.service.fxa.FxaException
+import mozilla.components.service.fxa.FxaAccountManager
+import mozilla.components.service.fxa.AccountObserver
 import mozilla.components.service.fxa.Config
+import mozilla.components.service.fxa.FirefoxAccountShaped
+import mozilla.components.service.fxa.FxaException
 import mozilla.components.service.fxa.Profile
+import mozilla.components.support.base.log.Log
+import mozilla.components.support.base.log.sink.AndroidLogSink
+import java.lang.Exception
 import kotlin.coroutines.CoroutineContext
 
 class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener, CoroutineScope {
 
-    private lateinit var account: FirefoxAccount
-    private val scopes: Array<String> = arrayOf("profile", "https://identity.mozilla.com/apps/oldsync")
-
     private val historyStoreName = "placesHistory"
     private val historyStorage by lazy { PlacesHistoryStorage(applicationContext) }
+
+    private val accountManager by lazy {
+        FxaAccountManager(
+            this,
+            Config.release(CLIENT_ID, REDIRECT_URL),
+            arrayOf("profile", "https://identity.mozilla.com/apps/oldsync")
+        )
+    }
     private val featureSync by lazy {
         FirefoxSyncFeature(
             mapOf(historyStoreName to historyStorage)
@@ -46,98 +55,85 @@ class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener,
         }
     }
 
-    private lateinit var job: Job
+    private var job = Job()
     override val coroutineContext: CoroutineContext
         get() = Dispatchers.Main + job
 
     companion object {
         const val CLIENT_ID = "3c49430b43dfba77"
-        const val REDIRECT_URL = "https://accounts.firefox.com/oauth/success/3c49430b43dfba77"
-        const val FXA_STATE_PREFS_KEY = "fxaAppState"
-        const val FXA_STATE_KEY = "fxaState"
+        const val REDIRECT_URL = "https://accounts.firefox.com/oauth/success/$CLIENT_ID"
     }
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
+
+        Log.addSink(AndroidLogSink())
+
         setContentView(R.layout.activity_main)
-        job = Job()
-        account = initAccount()
 
         findViewById<View>(R.id.buttonSignIn).setOnClickListener {
             launch {
-                val url = account.beginOAuthFlow(scopes, true).await()
-                openWebView(url)
+                val authUrl = try {
+                    accountManager.beginAuthentication().await()
+                } catch (error: FxaException) {
+                    val txtView: TextView = findViewById(R.id.fxaStatusView)
+                    txtView.text = getString(R.string.account_error, error.toString())
+                    return@launch
+                }
+                openWebView(authUrl)
             }
         }
 
         findViewById<View>(R.id.buttonLogout).setOnClickListener {
-            getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).edit().putString(FXA_STATE_KEY, "").apply()
-            val txtView: TextView = findViewById(R.id.fxaStatusView)
-            txtView.text = getString(R.string.logged_out)
+            launch { accountManager.logout().await() }
         }
 
         // NB: ObserverRegistry takes care of unregistering this observer when appropriate, and
         // cleaning up any internal references to 'observer' and 'owner'.
         featureSync.register(syncObserver, owner = this, autoPause = true)
+        // Observe changes to the account and profile.
+        accountManager.register(accountObserver, owner = this, autoPause = true)
+
+        // Now that our account state observer is registered, we can kick off the account manager.
+        launch { accountManager.init().await() }
 
         findViewById<View>(R.id.buttonSyncHistory).setOnClickListener {
-            getAuthenticatedAccount()?.let { account ->
-                val txtView: TextView = findViewById(R.id.historySyncResult)
-
-                launch {
-                    val syncResult = CoroutineScope(Dispatchers.IO + job).async {
-                        featureSync.sync(account)
-                    }.await()
-
-                    check(historyStoreName in syncResult) { "Expected to synchronize a history store" }
-
-                    val historySyncStatus = syncResult[historyStoreName]!!.status
-                    if (historySyncStatus is SyncError) {
-                        txtView.text = getString(R.string.sync_error, historySyncStatus.exception)
-                    } else {
-                        val visitedCount = historyStorage.getVisited().size
-                        // visitedCount is passed twice: to get the correct plural form, and then as
-                        // an argument for string formatting.
-                        txtView.text = resources.getQuantityString(
-                            R.plurals.visited_url_count, visitedCount, visitedCount
-                        )
-                    }
-                }
-            }
-        }
-    }
+            val account = accountManager.authenticatedAccount() ?: return@setOnClickListener
+
+            val txtView: TextView = findViewById(R.id.historySyncResult)
 
-    private fun initAccount(): FirefoxAccount {
-        getAuthenticatedAccount()?.let {
             launch {
-                val profile = it.getProfile(true).await()
-                displayProfile(profile)
+                val syncResult = CoroutineScope(Dispatchers.IO + job).async {
+                    featureSync.sync(account)
+                }.await()
+
+                check(historyStoreName in syncResult) { "Expected to synchronize a history store" }
+
+                val historySyncStatus = syncResult[historyStoreName]!!.status
+                if (historySyncStatus is SyncError) {
+                    txtView.text = getString(R.string.sync_error, historySyncStatus.exception)
+                } else {
+                    val visitedCount = historyStorage.getVisited().size
+                    // visitedCount is passed twice: to get the correct plural form, and then as
+                    // an argument for string formatting.
+                    txtView.text = resources.getQuantityString(
+                        R.plurals.visited_url_count, visitedCount, visitedCount
+                    )
+                }
             }
-            return it
         }
-
-        return FirefoxAccount(Config.release(CLIENT_ID, REDIRECT_URL))
     }
 
     override fun onDestroy() {
         super.onDestroy()
-        account.close()
+        accountManager.close()
         job.cancel()
     }
 
     override fun onLoginComplete(code: String, state: String, fragment: LoginFragment) {
-        displayAndPersistProfile(code, state)
-        supportFragmentManager?.popBackStack()
-    }
-
-    private fun getAuthenticatedAccount(): FirefoxAccount? {
-        val savedJSON = getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).getString(FXA_STATE_KEY, "")
-        return savedJSON?.let {
-            try {
-                FirefoxAccount.fromJSONString(it)
-            } catch (e: FxaException) {
-                null
-            }
+        launch {
+            supportFragmentManager?.popBackStack()
+            accountManager.finishAuthentication(code, state).await()
         }
     }
 
@@ -149,21 +145,45 @@ class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener,
         }
     }
 
-    private fun displayAndPersistProfile(code: String, state: String) {
-        launch {
-            account.completeOAuthFlow(code, state).await()
-            val profile = account.getProfile().await()
-            displayProfile(profile)
-            account.toJSONString().let {
-                getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE)
-                        .edit().putString(FXA_STATE_KEY, it).apply()
+    private val accountObserver = object : AccountObserver {
+        override fun onLoggedOut() {
+            launch {
+                val txtView: TextView = findViewById(R.id.fxaStatusView)
+                txtView.text = getString(R.string.logged_out)
+
+                findViewById<View>(R.id.buttonLogout).visibility = View.INVISIBLE
+                findViewById<View>(R.id.buttonSignIn).visibility = View.VISIBLE
+                findViewById<View>(R.id.buttonSyncHistory).visibility = View.INVISIBLE
+            }
+        }
+
+        override fun onAuthenticated(account: FirefoxAccountShaped) {
+            launch {
+                val txtView: TextView = findViewById(R.id.fxaStatusView)
+                txtView.text = getString(R.string.signed_in_waiting_for_profile)
+
+                findViewById<View>(R.id.buttonLogout).visibility = View.VISIBLE
+                findViewById<View>(R.id.buttonSignIn).visibility = View.INVISIBLE
+                findViewById<View>(R.id.buttonSyncHistory).visibility = View.VISIBLE
             }
         }
-    }
 
-    private fun displayProfile(profile: Profile) {
-        val txtView: TextView = findViewById(R.id.fxaStatusView)
-        txtView.text = getString(R.string.signed_in, "${profile.displayName ?: ""} ${profile.email}")
+        override fun onProfileUpdated(profile: Profile) {
+            launch {
+                val txtView: TextView = findViewById(R.id.fxaStatusView)
+                txtView.text = getString(
+                    R.string.signed_in_with_profile,
+                    "${profile.displayName ?: ""} ${profile.email}"
+                )
+            }
+        }
+
+        override fun onError(error: Exception) {
+            launch {
+                val txtView: TextView = findViewById(R.id.fxaStatusView)
+                txtView.text = getString(R.string.account_error, error.toString())
+            }
+        }
     }
 
     private val syncObserver = object : SyncStatusObserver {
diff --git a/android-components/samples/sync-history/src/main/res/values/strings.xml b/android-components/samples/sync-history/src/main/res/values/strings.xml
index be20486052e4..4101d6a08944 100644
--- a/android-components/samples/sync-history/src/main/res/values/strings.xml
+++ b/android-components/samples/sync-history/src/main/res/values/strings.xml
@@ -5,7 +5,9 @@
 <resources>
     <string name="app_name">Firefox Sync History Demo</string>
     <string name="sign_in">FxA sign in</string>
-    <string name="signed_in">Signed in: %1$s</string>
+    <string name="signed_in_waiting_for_profile">Signed in; waiting for profile</string>
+    <string name="signed_in_with_profile">Signed in: %1$s</string>
+    <string name="account_error">FxA error: %1$s</string>
     <string name="sync_idle">Sync is idle</string>
     <string name="syncing">Syncing&#8230;</string>
     <string name="sync_error">Sync error: %1$s</string>
diff --git a/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt b/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
index 0121d1329fbd..1c91a51fd114 100644
--- a/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
+++ b/android-components/samples/sync-logins/src/main/java/org/mozilla/samples/sync/logins/MainActivity.kt
@@ -4,7 +4,6 @@
 
 package org.mozilla.samples.sync.logins
 
-import android.content.Context
 import android.os.Bundle
 import android.support.v7.app.AppCompatActivity
 import android.view.View
@@ -19,19 +18,25 @@ import kotlinx.coroutines.async
 import kotlinx.coroutines.launch
 import mozilla.components.concept.storage.SyncError
 import mozilla.components.feature.sync.FirefoxSyncFeature
+import mozilla.components.service.fxa.FxaAccountManager
+import mozilla.components.service.fxa.AccountObserver
 import mozilla.components.service.fxa.Config
 import mozilla.components.service.fxa.FirefoxAccount
+import mozilla.components.service.fxa.FirefoxAccountShaped
 import mozilla.components.service.fxa.FxaException
+import mozilla.components.service.fxa.Profile
 import mozilla.components.service.sync.logins.AsyncLoginsStorageAdapter
 import mozilla.components.service.sync.logins.SyncableLoginsStore
 import mozilla.components.service.sync.logins.SyncUnlockInfo
+import mozilla.components.support.base.log.Log
+import mozilla.components.support.base.log.sink.AndroidLogSink
 import java.io.File
 import kotlin.coroutines.CoroutineContext
 
-open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener, CoroutineScope {
-    private var scopes: Array<String> = arrayOf("profile", "https://identity.mozilla.com/apps/oldsync")
-    private var wantsKeys: Boolean = true
+const val CLIENT_ID = "3c49430b43dfba77"
+const val REDIRECT_URL = "https://accounts.firefox.com/oauth/success/$CLIENT_ID"
 
+open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteListener, CoroutineScope {
     private val loginsStoreName: String = "placesLogins"
     private val loginsStore by lazy {
         SyncableLoginsStore(
@@ -56,20 +61,23 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
     private lateinit var adapter: ArrayAdapter<String>
     private lateinit var activityContext: MainActivity
     private lateinit var account: FirefoxAccount
+    private val accountManager by lazy {
+        FxaAccountManager(
+            applicationContext,
+            Config.release(CLIENT_ID, REDIRECT_URL),
+            arrayOf("profile", "https://identity.mozilla.com/apps/oldsync")
+        )
+    }
 
     private lateinit var job: Job
     override val coroutineContext: CoroutineContext
-        get() = Dispatchers.Main + job
-
-    companion object {
-        const val CLIENT_ID = "3c49430b43dfba77"
-        const val REDIRECT_URL = "https://accounts.firefox.com/oauth/success/3c49430b43dfba77"
-        const val FXA_STATE_PREFS_KEY = "fxaAppState"
-        const val FXA_STATE_KEY = "fxaState"
-    }
+    get() = Dispatchers.Main + job
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
+
+        Log.addSink(AndroidLogSink())
+
         setContentView(R.layout.activity_main)
         job = Job()
 
@@ -77,23 +85,36 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
         adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1)
         listView.adapter = adapter
         activityContext = this
-        account = getAuthenticatedAccount() ?: FirefoxAccount(Config.release(CLIENT_ID, REDIRECT_URL))
+
+        accountManager.register(accountObserver, owner = this, autoPause = true)
+
+        launch { accountManager.init().await() }
 
         findViewById<View>(R.id.buttonWebView).setOnClickListener {
             launch {
-                val url = account.beginOAuthFlow(scopes, wantsKeys).await()
-                openWebView(url)
+                val authUrl = try {
+                    accountManager.beginAuthentication().await()
+                } catch (error: FxaException) {
+                    Toast.makeText(this@MainActivity, "Account auth error: $error", Toast.LENGTH_LONG).show()
+                    return@launch
+                }
+                openWebView(authUrl)
             }
         }
     }
 
-    private fun getAuthenticatedAccount(): FirefoxAccount? {
-        val savedJSON = getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE).getString(FXA_STATE_KEY, "")
-        return savedJSON?.let {
-            try {
-                FirefoxAccount.fromJSONString(it)
-            } catch (e: FxaException) {
-                null
+    private val accountObserver = object : AccountObserver {
+        override fun onLoggedOut() {}
+
+        override fun onAuthenticated(account: FirefoxAccountShaped) {
+            launch { syncLogins(account) }
+        }
+
+        override fun onProfileUpdated(profile: Profile) {}
+
+        override fun onError(error: Exception) {
+            launch {
+                Toast.makeText(this@MainActivity, "Account error: $error", Toast.LENGTH_LONG).show()
             }
         }
     }
@@ -114,19 +135,12 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
 
     override fun onLoginComplete(code: String, state: String, fragment: LoginFragment) {
         launch {
-            account.completeOAuthFlow(code, state).await()
-            account.toJSONString().let {
-                getSharedPreferences(FXA_STATE_PREFS_KEY, Context.MODE_PRIVATE)
-                        .edit().putString(FXA_STATE_KEY, it).apply()
-            }
-
-            syncLogins(account)
-
+            accountManager.finishAuthentication(code, state).await()
             supportFragmentManager?.popBackStack()
         }
     }
 
-    private suspend fun syncLogins(account: FirefoxAccount) {
+    private suspend fun syncLogins(account: FirefoxAccountShaped) {
         val syncResult = CoroutineScope(Dispatchers.IO + job).async {
             featureSync.sync(account)
         }.await()
@@ -136,9 +150,9 @@ open class MainActivity : AppCompatActivity(), LoginFragment.OnLoginCompleteList
         val loginsSyncStatus = syncResult[loginsStoreName]!!.status
         if (loginsSyncStatus is SyncError) {
             Toast.makeText(
-                this@MainActivity,
-                "Logins sync error: " + loginsSyncStatus.exception.localizedMessage,
-                Toast.LENGTH_SHORT
+                    this@MainActivity,
+                    "Logins sync error: " + loginsSyncStatus.exception.localizedMessage,
+                    Toast.LENGTH_SHORT
             ).show()
         } else {
             Toast.makeText(this@MainActivity, "Logins sync success", Toast.LENGTH_SHORT).show()
