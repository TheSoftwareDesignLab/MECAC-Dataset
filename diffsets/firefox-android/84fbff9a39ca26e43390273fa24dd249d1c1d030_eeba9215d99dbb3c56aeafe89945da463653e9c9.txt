diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
index f8bff7fdc340..3f322641dd1b 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/BrowserToolbar.kt
@@ -14,12 +14,14 @@ import android.widget.ImageButton
 import androidx.annotation.DrawableRes
 import androidx.annotation.VisibleForTesting
 import androidx.annotation.VisibleForTesting.PRIVATE
+import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.forEach
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.cancelChildren
 import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
+import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.browser.toolbar.edit.EditToolbar
 import mozilla.components.concept.toolbar.AutocompleteDelegate
@@ -319,6 +321,20 @@ class BrowserToolbar @JvmOverloads constructor(
         display.views.menu.dismissMenu()
     }
 
+    override fun enableScrolling() {
+        // Behavior can be changed without us knowing. Not safe to use a memoized value.
+        (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
+            (behavior as? BrowserToolbarBehavior)?.enableScrolling()
+        }
+    }
+
+    override fun disableScrolling() {
+        // Behavior can be changed without us knowing. Not safe to use a memoized value.
+        (layoutParams as? CoordinatorLayout.LayoutParams)?.apply {
+            (behavior as? BrowserToolbarBehavior)?.disableScrolling()
+        }
+    }
+
     internal fun onUrlEntered(url: String) {
         if (urlCommitListener?.invoke(url) != false) {
             // Return to display mode if there's no urlCommitListener or if it returned true. This lets
diff --git a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
index a9b2c6e99913..dbcdfced7a31 100644
--- a/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
+++ b/android-components/components/browser/toolbar/src/main/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehavior.kt
@@ -53,6 +53,9 @@ class BrowserToolbarBehavior(
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var startedScroll = false
 
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    internal var isScrollEnabled = false
+
     /**
      * Reference to [EngineView] used to check user's [android.view.MotionEvent]s.
      */
@@ -77,7 +80,7 @@ class BrowserToolbarBehavior(
      */
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal val shouldScroll: Boolean
-        get() = engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_HANDLED
+        get() = engineView?.getInputResult() == EngineView.InputResult.INPUT_RESULT_HANDLED && isScrollEnabled
 
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal var gesturesDetector: BrowserGestureDetector = createGestureDetector()
@@ -157,6 +160,24 @@ class BrowserToolbarBehavior(
         yTranslator.collapseWithAnimation(toolbar)
     }
 
+    /**
+     * Allow this toolbar can be animated.
+     *
+     * @see disableScrolling
+     */
+    fun enableScrolling() {
+        isScrollEnabled = true
+    }
+
+    /**
+     * Disable scrolling this toolbar irrespective of the intrinsic checks.
+     *
+     * @see enableScrolling
+     */
+    fun disableScrolling() {
+        isScrollEnabled = false
+    }
+
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     internal fun positionSnackbar(child: View, snackbarLayout: Snackbar.SnackbarLayout) {
         val params = snackbarLayout.layoutParams as CoordinatorLayout.LayoutParams
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
index a937308b3ed6..b0a058f3a162 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/BrowserToolbarTest.kt
@@ -12,10 +12,13 @@ import android.view.ViewParent
 import android.view.accessibility.AccessibilityEvent
 import android.view.accessibility.AccessibilityManager
 import android.widget.ImageButton
+import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.core.view.inputmethod.EditorInfoCompat
 import androidx.core.view.isGone
 import androidx.core.view.isVisible
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import mozilla.components.browser.toolbar.behavior.BrowserToolbarBehavior
+import mozilla.components.browser.toolbar.behavior.ToolbarPosition
 import mozilla.components.browser.toolbar.display.DisplayToolbar
 import mozilla.components.browser.toolbar.display.DisplayToolbarViews
 import mozilla.components.browser.toolbar.display.MenuButton
@@ -729,4 +732,34 @@ class BrowserToolbarTest {
         toolbar.dismissMenu()
         verify(menuButton).dismissMenu()
     }
+
+    @Test
+    fun `enable scrolling is forwarded to the toolbar behavior`() {
+        // Seems like real instances are needed for things to be set properly
+        val toolbar = BrowserToolbar(testContext)
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val params = CoordinatorLayout.LayoutParams(10, 10).apply {
+            this.behavior = behavior
+        }
+        toolbar.layoutParams = params
+
+        toolbar.enableScrolling()
+
+        verify(behavior).enableScrolling()
+    }
+
+    @Test
+    fun `disable scrolling is forwarded to the toolbar behavior`() {
+        // Seems like real instances are needed for things to be set properly
+        val toolbar = BrowserToolbar(testContext)
+        val behavior = spy(BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM))
+        val params = CoordinatorLayout.LayoutParams(10, 10).apply {
+            this.behavior = behavior
+        }
+        toolbar.layoutParams = params
+
+        toolbar.disableScrolling()
+
+        verify(behavior).disableScrolling()
+    }
 }
diff --git a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
index 8ec11ebf35ad..71a3b091d63f 100644
--- a/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
+++ b/android-components/components/browser/toolbar/src/test/java/mozilla/components/browser/toolbar/behavior/BrowserToolbarBehaviorTest.kt
@@ -303,31 +303,67 @@ class BrowserToolbarBehaviorTest {
     }
 
     @Test
-    fun `Behaviour shouldScroll if EngineView handled the MotionEvent`() {
+    fun `Behaviour shouldScroll if EngineView handled the MotionEvent and scrolling is enabled`() {
         val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED)
         behavior.engineView = engineView
+        behavior.isScrollEnabled = true
 
         assertTrue(behavior.shouldScroll)
     }
 
     @Test
-    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent`() {
+    fun `Behaviour !shouldScroll if EngineView handled the MotionEvent and scrolling is !enabled`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED)
+        behavior.engineView = engineView
+        behavior.isScrollEnabled = false
+
+        assertFalse(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent and scrolling is enabled`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_UNHANDLED)
+        behavior.engineView = engineView
+        behavior.isScrollEnabled = true
+
+        assertFalse(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent and scrolling is !enabled`() {
         val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_UNHANDLED)
         behavior.engineView = engineView
+        behavior.isScrollEnabled = false
 
         assertFalse(behavior.shouldScroll)
     }
 
     @Test
-    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent but the website`() {
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent but the website and scrolling is enabled`() {
         val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
         val engineView: EngineView = mock()
         `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT)
         behavior.engineView = engineView
+        behavior.isScrollEnabled = true
+
+        assertFalse(behavior.shouldScroll)
+    }
+
+    @Test
+    fun `Behaviour !shouldScroll if EngineView didn't handle the MotionEvent but the website and scrolling is !enabled`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        val engineView: EngineView = mock()
+        `when`(engineView.getInputResult()).thenReturn(EngineView.InputResult.INPUT_RESULT_HANDLED_CONTENT)
+        behavior.engineView = engineView
+        behavior.isScrollEnabled = false
 
         assertFalse(behavior.shouldScroll)
     }
@@ -479,6 +515,27 @@ class BrowserToolbarBehaviorTest {
         assertEquals(engineView, behavior.engineView)
     }
 
+    @Test
+    fun `enableScrolling sets isScrollEnabled to true`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+
+        assertFalse(behavior.isScrollEnabled)
+        behavior.enableScrolling()
+
+        assertTrue(behavior.isScrollEnabled)
+    }
+
+    @Test
+    fun `disableScrolling sets isScrollEnabled to false`() {
+        val behavior = BrowserToolbarBehavior(testContext, null, ToolbarPosition.BOTTOM)
+        behavior.isScrollEnabled = true
+
+        assertTrue(behavior.isScrollEnabled)
+        behavior.disableScrolling()
+
+        assertFalse(behavior.isScrollEnabled)
+    }
+
     private fun createDummyEngineView(context: Context): EngineView = DummyEngineView(context)
 
     open class DummyEngineView(context: Context) : FrameLayout(context), EngineView {
diff --git a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
index b2f0f50c230d..03a5ec8612a2 100644
--- a/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
+++ b/android-components/components/concept/toolbar/src/main/java/mozilla/components/concept/toolbar/Toolbar.kt
@@ -172,6 +172,19 @@ interface Toolbar {
      */
     fun dismissMenu()
 
+    /**
+     * Enable scrolling of the dynamic toolbar. Restore this functionality after [disableScrolling] stopped it.
+     *
+     * The toolbar may have other intrinsic checks depending on which the toolbar will be animated or not.
+     */
+    fun enableScrolling()
+
+    /**
+     * Completely disable scrolling of the dynamic toolbar.
+     * Use [enableScrolling] to restore the functionality.
+     */
+    fun disableScrolling()
+
     /**
      * Listener to be invoked when the user edits the URL.
      */
diff --git a/android-components/components/feature/customtabs/src/test/java/mozilla/components/feature/customtabs/feature/CustomTabSessionTitleObserverTest.kt b/android-components/components/feature/customtabs/src/test/java/mozilla/components/feature/customtabs/feature/CustomTabSessionTitleObserverTest.kt
index 9749b31c114b..4dcdc0da1f63 100644
--- a/android-components/components/feature/customtabs/src/test/java/mozilla/components/feature/customtabs/feature/CustomTabSessionTitleObserverTest.kt
+++ b/android-components/components/feature/customtabs/src/test/java/mozilla/components/feature/customtabs/feature/CustomTabSessionTitleObserverTest.kt
@@ -92,6 +92,8 @@ class CustomTabSessionTitleObserverTest {
         override fun displayMode() = Unit
         override fun editMode() = Unit
         override fun dismissMenu() = Unit
+        override fun enableScrolling() = Unit
+        override fun disableScrolling() = Unit
     }
 }
 
diff --git a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt
new file mode 100644
index 000000000000..13db0a844f41
--- /dev/null
+++ b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarBehaviorController.kt
@@ -0,0 +1,67 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.toolbar
+
+import androidx.annotation.VisibleForTesting
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.flow.mapNotNull
+import mozilla.components.browser.state.selector.findCustomTabOrSelectedTab
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.concept.toolbar.Toolbar
+import mozilla.components.lib.state.ext.flowScoped
+import mozilla.components.support.ktx.kotlinx.coroutines.flow.ifChanged
+
+/**
+ * Controls how the dynamic toolbar should behave based on the current tab state.
+ *
+ * Responsible to enforce the following:
+ * - toolbar should not be scrollable if the page has not finished loading
+ */
+class ToolbarBehaviorController(
+    private val toolbar: Toolbar,
+    private val store: BrowserStore,
+    private val customTabId: String? = null
+) {
+    @VisibleForTesting
+    internal var updatesScope: CoroutineScope? = null
+
+    /**
+     * Starts listening for changes in the current tab and updates how the toolbar should behave.
+     */
+    fun start() {
+        updatesScope = store.flowScoped { flow ->
+            flow.mapNotNull { state ->
+                state.findCustomTabOrSelectedTab(customTabId)
+            }.ifChanged { tab ->
+                tab.content.loading
+            }.collect { state ->
+                if (state.content.loading) {
+                    disableScrolling()
+                } else {
+                    enableScrolling()
+                }
+            }
+        }
+    }
+
+    /**
+     * Stop listening for changes in the current tab.
+     */
+    fun stop() {
+        updatesScope?.cancel()
+    }
+
+    @VisibleForTesting
+    internal fun disableScrolling() {
+        toolbar.disableScrolling()
+    }
+
+    @VisibleForTesting
+    internal fun enableScrolling() {
+        toolbar.enableScrolling()
+    }
+}
diff --git a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarFeature.kt b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarFeature.kt
index b0d644236767..22624954114d 100644
--- a/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarFeature.kt
+++ b/android-components/components/feature/toolbar/src/main/java/mozilla/components/feature/toolbar/ToolbarFeature.kt
@@ -5,12 +5,13 @@
 package mozilla.components.feature.toolbar
 
 import androidx.annotation.ColorInt
+import androidx.annotation.VisibleForTesting
 import mozilla.components.browser.state.store.BrowserStore
 import mozilla.components.concept.toolbar.Toolbar
 import mozilla.components.feature.session.SessionUseCases
 import mozilla.components.lib.publicsuffixlist.PublicSuffixList
-import mozilla.components.support.base.feature.UserInteractionHandler
 import mozilla.components.support.base.feature.LifecycleAwareFeature
+import mozilla.components.support.base.feature.UserInteractionHandler
 
 /**
  * A function representing the search use case, accepting
@@ -29,8 +30,12 @@ class ToolbarFeature(
     customTabId: String? = null,
     urlRenderConfiguration: UrlRenderConfiguration? = null
 ) : LifecycleAwareFeature, UserInteractionHandler {
-    private val presenter = ToolbarPresenter(toolbar, store, customTabId, urlRenderConfiguration)
-    private val interactor = ToolbarInteractor(toolbar, loadUrlUseCase, searchUseCase)
+    @VisibleForTesting
+    internal var presenter = ToolbarPresenter(toolbar, store, customTabId, urlRenderConfiguration)
+    @VisibleForTesting
+    internal var interactor = ToolbarInteractor(toolbar, loadUrlUseCase, searchUseCase)
+    @VisibleForTesting
+    internal var controller = ToolbarBehaviorController(toolbar, store, customTabId)
 
     /**
      * Start feature: App is in the foreground.
@@ -38,6 +43,7 @@ class ToolbarFeature(
     override fun start() {
         interactor.start()
         presenter.start()
+        controller.start()
     }
 
     /**
@@ -52,6 +58,7 @@ class ToolbarFeature(
      */
     override fun stop() {
         presenter.stop()
+        controller.stop()
         toolbar.onStop()
     }
 
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
index 62d6d0c61403..135c041eddcb 100644
--- a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarAutocompleteFeatureTest.kt
@@ -113,6 +113,14 @@ class ToolbarAutocompleteFeatureTest {
         override fun dismissMenu() {
             fail()
         }
+
+        override fun enableScrolling() {
+            fail()
+        }
+
+        override fun disableScrolling() {
+            fail()
+        }
     }
 
     @Test
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarBehaviorControllerTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarBehaviorControllerTest.kt
new file mode 100644
index 000000000000..17b57bab1764
--- /dev/null
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarBehaviorControllerTest.kt
@@ -0,0 +1,130 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package mozilla.components.feature.toolbar
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import kotlinx.coroutines.isActive
+import mozilla.components.browser.state.state.BrowserState
+import mozilla.components.browser.state.state.ContentState
+import mozilla.components.browser.state.state.CustomTabSessionState
+import mozilla.components.browser.state.state.TabSessionState
+import mozilla.components.browser.state.store.BrowserStore
+import mozilla.components.concept.toolbar.Toolbar
+import mozilla.components.support.test.mock
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.never
+import org.mockito.Mockito.spy
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+@RunWith(AndroidJUnit4::class)
+class ToolbarBehaviorControllerTest {
+
+    @Test
+    fun `Controller should check the status of the provided custom tab id`() {
+        val customTabContent: ContentState = mock()
+        val normalTabContent: ContentState = mock()
+        val state = spy(BrowserState(
+            tabs = listOf(TabSessionState("123", normalTabContent)),
+            customTabs = listOf(CustomTabSessionState("ct", customTabContent, config = mock())),
+            selectedTabId = "123"
+        ))
+        val store = BrowserStore(state)
+        val controller = ToolbarBehaviorController(mock(), store, "ct")
+
+        assertNull(controller.updatesScope)
+
+        controller.start()
+
+        assertNotNull(controller.updatesScope)
+        verify(customTabContent, times(2)).loading
+        verify(normalTabContent, never()).loading
+    }
+
+    @Test
+    fun `Controller should check the status of the currently selected tab if not initialized with a custom tab id`() {
+        val customTabContent: ContentState = mock()
+        val normalTabContent: ContentState = mock()
+        val state = spy(BrowserState(
+            tabs = listOf(TabSessionState("123", normalTabContent)),
+            customTabs = listOf(CustomTabSessionState("ct", customTabContent, config = mock())),
+            selectedTabId = "123"
+        ))
+        val store = BrowserStore(state)
+        val controller = ToolbarBehaviorController(mock(), store)
+
+        assertNull(controller.updatesScope)
+
+        controller.start()
+
+        assertNotNull(controller.updatesScope)
+        verify(customTabContent, never()).loading
+        verify(normalTabContent, times(2)).loading
+    }
+
+    @Test
+    fun `Controller should disableScrolling if the current tab is loading`() {
+        val normalTabContent = ContentState("url", loading = true)
+        val store = BrowserStore(BrowserState(
+            tabs = listOf(TabSessionState("123", normalTabContent)),
+            selectedTabId = "123"
+        ))
+        val controller = spy(ToolbarBehaviorController(mock(), store))
+
+        controller.start()
+
+        verify(controller).disableScrolling()
+    }
+
+    @Test
+    fun `Controller should enableScrolling if the current tab is not loading`() {
+        val normalTabContent = ContentState("url", loading = false)
+        val store = BrowserStore(BrowserState(
+            tabs = listOf(TabSessionState("123", normalTabContent)),
+            selectedTabId = "123"
+        ))
+        val controller = spy(ToolbarBehaviorController(mock(), store))
+
+        controller.start()
+
+        verify(controller).enableScrolling()
+    }
+
+    @Test
+    fun `Controller should listening for tab updates if stop is called`() {
+        val controller = spy(ToolbarBehaviorController(mock(), BrowserStore(BrowserState())))
+
+        controller.start()
+        assertTrue(controller.updatesScope!!.isActive)
+
+        controller.stop()
+        assertFalse(controller.updatesScope!!.isActive)
+    }
+
+    @Test
+    fun `Controller should disable toolbar scrolling when disableScrolling is called`() {
+        val toolbar: Toolbar = mock()
+        val controller = spy(ToolbarBehaviorController(toolbar, mock()))
+
+        controller.disableScrolling()
+
+        verify(toolbar).disableScrolling()
+    }
+
+    @Test
+    fun `Controller should enable toolbar scrolling when enableScrolling is called`() {
+        val toolbar: Toolbar = mock()
+        val controller = spy(ToolbarBehaviorController(toolbar, mock()))
+
+        controller.enableScrolling()
+
+        verify(toolbar).enableScrolling()
+    }
+}
\ No newline at end of file
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarFeatureTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarFeatureTest.kt
index 0075d77d23ff..4c460ff6aaa9 100644
--- a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarFeatureTest.kt
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarFeatureTest.kt
@@ -20,4 +20,81 @@ class ToolbarFeatureTest {
 
         verify(toolbar).onStop()
     }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN start() is called THEN it should call controller#start()`() {
+        val mockedController: ToolbarBehaviorController = mock()
+        val feature = ToolbarFeature(mock(), mock(), mock()).apply {
+            controller = mockedController
+            // mock other dependencies to limit real code running and error-ing.
+            presenter = mock()
+            interactor = mock()
+        }
+
+        feature.start()
+
+        verify(mockedController).start()
+    }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN start() is called THEN it should call presenter#start()`() {
+        val mockedPresenter: ToolbarPresenter = mock()
+        val feature = ToolbarFeature(mock(), mock(), mock()).apply {
+            controller = mock()
+            presenter = mockedPresenter
+            interactor = mock()
+        }
+
+        feature.start()
+
+        verify(mockedPresenter).start()
+    }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN start() is called THEN it should call interactor#start()`() {
+        val mockedInteractor: ToolbarInteractor = mock()
+        val feature = ToolbarFeature(mock(), mock(), mock()).apply {
+            controller = mock()
+            presenter = mock()
+            interactor = mockedInteractor
+        }
+
+        feature.start()
+
+        verify(mockedInteractor).start()
+    }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN stop() is called THEN it should call controller#stop()`() {
+        val mockedController: ToolbarBehaviorController = mock()
+        val feature = ToolbarFeature(mock(), mock(), mock()).apply {
+            controller = mockedController
+        }
+
+        feature.stop()
+
+        verify(mockedController).stop()
+    }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN stop() is called THEN it should call presenter#stop()`() {
+        val mockedPresenter: ToolbarPresenter = mock()
+        val feature = ToolbarFeature(mock(), mock(), mock()).apply {
+            presenter = mockedPresenter
+        }
+
+        feature.stop()
+
+        verify(mockedPresenter).stop()
+    }
+
+    @Test
+    fun `GIVEN ToolbarFeature, WHEN onBackPressed() is called THEN it should call toolbar#onBackPressed()`() {
+        val toolbar: Toolbar = mock()
+        val feature = ToolbarFeature(toolbar, store = mock(), loadUrlUseCase = mock())
+
+        feature.onBackPressed()
+
+        verify(toolbar).onBackPressed()
+    }
 }
diff --git a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
index 1a43fb1e4e27..cc10c9d7a59d 100644
--- a/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
+++ b/android-components/components/feature/toolbar/src/test/java/mozilla/components/feature/toolbar/ToolbarInteractorTest.kt
@@ -96,6 +96,14 @@ class ToolbarInteractorTest {
         override fun dismissMenu() {
             fail()
         }
+
+        override fun enableScrolling() {
+            fail()
+        }
+
+        override fun disableScrolling() {
+            fail()
+        }
     }
 
     @Test
diff --git a/android-components/docs/changelog.md b/android-components/docs/changelog.md
index cd775b68e3c6..26c1ec35ef7c 100644
--- a/android-components/docs/changelog.md
+++ b/android-components/docs/changelog.md
@@ -12,6 +12,9 @@ permalink: /changelog/
 * [Gecko](https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Gecko.kt)
 * [Configuration](https://github.com/mozilla-mobile/android-components/blob/master/.config.yml)
 
+* **browser-toolbar**
+  * üåüÔ∏è Added `ToolbarBehaviorController` to automatically block the `BrowserToolbar` being animated by the `BrowserToolbarBehavior` while the tab is loading. This new class just has to be initialized by AC clients, similar to `ToolbarPresenter`.
+
 * **feature-downloads**:
   * üöí Bug fixed [issue #9757](https://github.com/mozilla-mobile/android-components/issues/9757) - Remove downloads notification when private tabs are closed.
 
