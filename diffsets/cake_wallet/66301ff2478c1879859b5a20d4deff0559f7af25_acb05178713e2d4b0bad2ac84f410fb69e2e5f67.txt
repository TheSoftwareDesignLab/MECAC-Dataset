diff --git a/.github/workflows/pr_test_build.yml b/.github/workflows/pr_test_build.yml
index af03c5e307..5434429b22 100644
--- a/.github/workflows/pr_test_build.yml
+++ b/.github/workflows/pr_test_build.yml
@@ -42,6 +42,7 @@ jobs:
           cd cake_wallet/scripts/android/
           ./install_ndk.sh
           source ./app_env.sh cakewallet
+          chmod +x pubspec_gen.sh
           ./app_config.sh
 
       - name: Cache Externals
@@ -92,6 +93,7 @@ jobs:
           cd cw_bitcoin && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
           cd cw_haven && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
           cd cw_ethereum && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
+          cd cw_bitcoin_cash && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
           cd cw_nano && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
           flutter packages pub run build_runner build --delete-conflicting-outputs
 
@@ -141,18 +143,18 @@ jobs:
           cd /opt/android/cake_wallet
           flutter build apk --release
 
-      #      - name: Push to App Center
-      #        run: |
-      #          echo 'Installing App Center CLI tools'
-      #          npm install -g appcenter-cli
-      #          echo "Publishing test to App Center"
-      #          appcenter distribute release \
-      #              --group "Testers" \
-      #              --file "/opt/android/cake_wallet/build/app/outputs/apk/release/app-release.apk" \
-      #              --release-notes ${GITHUB_HEAD_REF} \
-      #              --app Cake-Labs/Cake-Wallet \
-      #              --token ${{ secrets.APP_CENTER_TOKEN }} \
-      #              --quiet
+#            - name: Push to App Center
+#              run: |
+#                echo 'Installing App Center CLI tools'
+#                npm install -g appcenter-cli
+#                echo "Publishing test to App Center"
+#                appcenter distribute release \
+#                    --group "Testers" \
+#                    --file "/opt/android/cake_wallet/build/app/outputs/apk/release/app-release.apk" \
+#                    --release-notes ${GITHUB_HEAD_REF} \
+#                    --app Cake-Labs/Cake-Wallet \
+#                    --token ${{ secrets.APP_CENTER_TOKEN }} \
+#                    --quiet
 
       - name: Rename apk file
         run: |
diff --git a/.gitignore b/.gitignore
index e8fb0048c4..c735d40585 100644
--- a/.gitignore
+++ b/.gitignore
@@ -124,6 +124,7 @@ lib/bitcoin/bitcoin.dart
 lib/monero/monero.dart
 lib/haven/haven.dart
 lib/ethereum/ethereum.dart
+lib/bitcoin_cash/bitcoin_cash.dart
 lib/nano/nano.dart
 
 ios/Runner/Assets.xcassets/AppIcon.appiconset/app_icon_180.png
diff --git a/android/gradle.properties b/android/gradle.properties
index a5965ab8dc..38c8d4544f 100644
--- a/android/gradle.properties
+++ b/android/gradle.properties
@@ -1,4 +1,4 @@
 org.gradle.jvmargs=-Xmx1536M
 android.enableR8=true
 android.useAndroidX=true
-android.enableJetifier=true
\ No newline at end of file
+android.enableJetifier=true
diff --git a/assets/bitcoin_cash_electrum_server_list.yml b/assets/bitcoin_cash_electrum_server_list.yml
new file mode 100644
index 0000000000..d766681695
--- /dev/null
+++ b/assets/bitcoin_cash_electrum_server_list.yml
@@ -0,0 +1,3 @@
+-
+  uri: bitcoincash.stackwallet.com:50002
+  is_default: true
\ No newline at end of file
diff --git a/configure_cake_wallet_android.sh b/configure_cake_wallet_android.sh
index 792159f29a..b8aa433deb 100755
--- a/configure_cake_wallet_android.sh
+++ b/configure_cake_wallet_android.sh
@@ -8,4 +8,5 @@ cd cw_bitcoin && flutter pub get && flutter packages pub run build_runner build
 cd cw_haven && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 cd cw_ethereum && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 cd cw_nano && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
+cd cw_bitcoin_cash && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 flutter packages pub run build_runner build --delete-conflicting-outputs
diff --git a/cw_bitcoin/lib/bitcoin_transaction_priority.dart b/cw_bitcoin/lib/bitcoin_transaction_priority.dart
index d82ea429ef..10953a2e0c 100644
--- a/cw_bitcoin/lib/bitcoin_transaction_priority.dart
+++ b/cw_bitcoin/lib/bitcoin_transaction_priority.dart
@@ -1,5 +1,4 @@
 import 'package:cw_core/transaction_priority.dart';
-//import 'package:cake_wallet/generated/i18n.dart';
 
 class BitcoinTransactionPriority extends TransactionPriority {
   const BitcoinTransactionPriority({required String title, required int raw})
@@ -98,6 +97,57 @@ class LitecoinTransactionPriority extends BitcoinTransactionPriority {
         break;
     }
 
+    return label;
+  }
+
+}
+class BitcoinCashTransactionPriority extends BitcoinTransactionPriority {
+  const BitcoinCashTransactionPriority({required String title, required int raw})
+      : super(title: title, raw: raw);
+
+  static const List<BitcoinCashTransactionPriority> all = [fast, medium, slow];
+  static const BitcoinCashTransactionPriority slow =
+  BitcoinCashTransactionPriority(title: 'Slow', raw: 0);
+  static const BitcoinCashTransactionPriority medium =
+  BitcoinCashTransactionPriority(title: 'Medium', raw: 1);
+  static const BitcoinCashTransactionPriority fast =
+  BitcoinCashTransactionPriority(title: 'Fast', raw: 2);
+
+  static BitcoinCashTransactionPriority deserialize({required int raw}) {
+    switch (raw) {
+      case 0:
+        return slow;
+      case 1:
+        return medium;
+      case 2:
+        return fast;
+      default:
+        throw Exception('Unexpected token: $raw for BitcoinCashTransactionPriority deserialize');
+    }
+  }
+
+  @override
+  String get units => 'Satoshi';
+
+  @override
+  String toString() {
+    var label = '';
+
+    switch (this) {
+      case BitcoinCashTransactionPriority.slow:
+        label = 'Slow'; // S.current.transaction_priority_slow;
+        break;
+      case BitcoinCashTransactionPriority.medium:
+        label = 'Medium'; // S.current.transaction_priority_medium;
+        break;
+      case BitcoinCashTransactionPriority.fast:
+        label = 'Fast'; // S.current.transaction_priority_fast;
+        break;
+      default:
+        break;
+    }
+
     return label;
   }
 }
+
diff --git a/cw_bitcoin/lib/bitcoin_unspent.dart b/cw_bitcoin/lib/bitcoin_unspent.dart
index e5a0e8cac2..9c198c27cd 100644
--- a/cw_bitcoin/lib/bitcoin_unspent.dart
+++ b/cw_bitcoin/lib/bitcoin_unspent.dart
@@ -1,24 +1,15 @@
 import 'package:cw_bitcoin/bitcoin_address_record.dart';
+import 'package:cw_core/unspent_transaction_output.dart';
 
-class BitcoinUnspent {
-  BitcoinUnspent(this.address, this.hash, this.value, this.vout)
-      : isSending = true,
-        isFrozen = false,
-        note = '';
+class BitcoinUnspent extends Unspent {
+  BitcoinUnspent(BitcoinAddressRecord addressRecord, String hash, int value, int vout)
+      : bitcoinAddressRecord = addressRecord,
+        super(addressRecord.address, hash, value, vout, null);
 
   factory BitcoinUnspent.fromJSON(
-          BitcoinAddressRecord address, Map<String, dynamic> json) =>
+      BitcoinAddressRecord address, Map<String, dynamic> json) =>
       BitcoinUnspent(address, json['tx_hash'] as String, json['value'] as int,
           json['tx_pos'] as int);
 
-  final BitcoinAddressRecord address;
-  final String hash;
-  final int value;
-  final int vout;
-
-  bool get isP2wpkh =>
-      address.address.startsWith('bc') || address.address.startsWith('ltc');
-  bool isSending;
-  bool isFrozen;
-  String note;
+  final BitcoinAddressRecord bitcoinAddressRecord;
 }
diff --git a/cw_bitcoin/lib/bitcoin_wallet_addresses.dart b/cw_bitcoin/lib/bitcoin_wallet_addresses.dart
index de3fdfbca4..36d37127d0 100644
--- a/cw_bitcoin/lib/bitcoin_wallet_addresses.dart
+++ b/cw_bitcoin/lib/bitcoin_wallet_addresses.dart
@@ -1,39 +1,34 @@
 import 'package:bitcoin_flutter/bitcoin_flutter.dart' as bitcoin;
-import 'package:cw_bitcoin/electrum.dart';
-import 'package:cw_bitcoin/utils.dart';
 import 'package:cw_bitcoin/bitcoin_address_record.dart';
+import 'package:cw_bitcoin/electrum.dart';
 import 'package:cw_bitcoin/electrum_wallet_addresses.dart';
+import 'package:cw_bitcoin/utils.dart';
 import 'package:cw_core/wallet_info.dart';
-import 'package:flutter/foundation.dart';
 import 'package:mobx/mobx.dart';
 
 part 'bitcoin_wallet_addresses.g.dart';
 
-class BitcoinWalletAddresses = BitcoinWalletAddressesBase
-    with _$BitcoinWalletAddresses;
+class BitcoinWalletAddresses = BitcoinWalletAddressesBase with _$BitcoinWalletAddresses;
 
-abstract class BitcoinWalletAddressesBase extends ElectrumWalletAddresses
-    with Store {
-  BitcoinWalletAddressesBase(
-      WalletInfo walletInfo,
+abstract class BitcoinWalletAddressesBase extends ElectrumWalletAddresses with Store {
+  BitcoinWalletAddressesBase(WalletInfo walletInfo,
       {required bitcoin.HDWallet mainHd,
-        required bitcoin.HDWallet sideHd,
-        required bitcoin.NetworkType networkType,
-        required ElectrumClient electrumClient,
-        List<BitcoinAddressRecord>? initialAddresses,
-        int initialRegularAddressIndex = 0,
-        int initialChangeAddressIndex = 0})
-      : super(
-        walletInfo,
-        initialAddresses: initialAddresses,
-        initialRegularAddressIndex: initialRegularAddressIndex,
-        initialChangeAddressIndex: initialChangeAddressIndex,
-        mainHd: mainHd,
-        sideHd: sideHd,
-        electrumClient: electrumClient,
-        networkType: networkType);
+      required bitcoin.HDWallet sideHd,
+      required bitcoin.NetworkType networkType,
+      required ElectrumClient electrumClient,
+      List<BitcoinAddressRecord>? initialAddresses,
+      int initialRegularAddressIndex = 0,
+      int initialChangeAddressIndex = 0})
+      : super(walletInfo,
+            initialAddresses: initialAddresses,
+            initialRegularAddressIndex: initialRegularAddressIndex,
+            initialChangeAddressIndex: initialChangeAddressIndex,
+            mainHd: mainHd,
+            sideHd: sideHd,
+            electrumClient: electrumClient,
+            networkType: networkType);
 
   @override
   String getAddress({required int index, required bitcoin.HDWallet hd}) =>
       generateP2WPKHAddress(hd: hd, index: index, networkType: networkType);
-}
\ No newline at end of file
+}
diff --git a/cw_bitcoin/lib/electrum_wallet.dart b/cw_bitcoin/lib/electrum_wallet.dart
index 1c0a1e4e36..804b53379f 100644
--- a/cw_bitcoin/lib/electrum_wallet.dart
+++ b/cw_bitcoin/lib/electrum_wallet.dart
@@ -2,7 +2,9 @@ import 'dart:async';
 import 'dart:convert';
 import 'dart:io';
 import 'dart:math';
+import 'package:cw_core/pending_transaction.dart';
 import 'package:cw_core/unspent_coins_info.dart';
+import 'package:cw_core/wallet_type.dart';
 import 'package:hive/hive.dart';
 import 'package:cw_bitcoin/electrum_wallet_addresses.dart';
 import 'package:mobx/mobx.dart';
@@ -34,45 +36,52 @@ import 'package:cw_bitcoin/electrum.dart';
 import 'package:hex/hex.dart';
 import 'package:cw_core/crypto_currency.dart';
 import 'package:collection/collection.dart';
+import 'package:bip32/bip32.dart';
 
 part 'electrum_wallet.g.dart';
 
 class ElectrumWallet = ElectrumWalletBase with _$ElectrumWallet;
 
-abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
-    ElectrumTransactionHistory, ElectrumTransactionInfo> with Store {
+abstract class ElectrumWalletBase
+    extends WalletBase<ElectrumBalance, ElectrumTransactionHistory, ElectrumTransactionInfo>
+    with Store {
   ElectrumWalletBase(
       {required String password,
-      required WalletInfo walletInfo,
-      required Box<UnspentCoinsInfo> unspentCoinsInfo,
-      required this.networkType,
-      required this.mnemonic,
-      required Uint8List seedBytes,
-      List<BitcoinAddressRecord>? initialAddresses,
-      ElectrumClient? electrumClient,
-      ElectrumBalance? initialBalance,
-      CryptoCurrency? currency})
-      : hd = bitcoin.HDWallet.fromSeed(seedBytes, network: networkType)
-            .derivePath("m/0'/0"),
+        required WalletInfo walletInfo,
+        required Box<UnspentCoinsInfo> unspentCoinsInfo,
+        required this.networkType,
+        required this.mnemonic,
+        required Uint8List seedBytes,
+        List<BitcoinAddressRecord>? initialAddresses,
+        ElectrumClient? electrumClient,
+        ElectrumBalance? initialBalance,
+        CryptoCurrency? currency})
+      : hd = currency == CryptoCurrency.bch
+      ? bitcoinCashHDWallet(seedBytes)
+      : bitcoin.HDWallet.fromSeed(seedBytes, network: networkType).derivePath("m/0'/0"),
         syncStatus = NotConnectedSyncStatus(),
         _password = password,
         _feeRates = <int>[],
         _isTransactionUpdating = false,
         unspentCoins = [],
         _scripthashesUpdateSubject = {},
-        balance = ObservableMap<CryptoCurrency, ElectrumBalance>.of(
-          currency != null
-           ? {currency: initialBalance ?? const ElectrumBalance(confirmed: 0, unconfirmed: 0,
-          frozen: 0)}
-           : {}),
+        balance = ObservableMap<CryptoCurrency, ElectrumBalance>.of(currency != null
+            ? {
+          currency:
+          initialBalance ?? const ElectrumBalance(confirmed: 0, unconfirmed: 0, frozen: 0)
+        }
+            : {}),
         this.unspentCoinsInfo = unspentCoinsInfo,
         super(walletInfo) {
     this.electrumClient = electrumClient ?? ElectrumClient();
     this.walletInfo = walletInfo;
-    transactionHistory =
-        ElectrumTransactionHistory(walletInfo: walletInfo, password: password);
+    transactionHistory = ElectrumTransactionHistory(walletInfo: walletInfo, password: password);
   }
 
+  static bitcoin.HDWallet bitcoinCashHDWallet(Uint8List seedBytes) =>
+      bitcoin.HDWallet.fromSeed(seedBytes)
+          .derivePath("m/44'/145'/0'/0");
+
   static int estimatedTransactionSize(int inputsCount, int outputsCounts) =>
       inputsCount * 146 + outputsCounts * 33 + 8;
 
@@ -98,9 +107,9 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       .toList();
 
   List<String> get publicScriptHashes => walletAddresses.addresses
-    .where((addr) => !addr.isHidden)
-    .map((addr) => scriptHash(addr.address, networkType: networkType))
-    .toList();
+      .where((addr) => !addr.isHidden)
+      .map((addr) => scriptHash(addr.address, networkType: networkType))
+      .toList();
 
   String get xpub => hd.base58!;
 
@@ -110,8 +119,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   bitcoin.NetworkType networkType;
 
   @override
-  BitcoinWalletKeys get keys => BitcoinWalletKeys(
-      wif: hd.wif!, privateKey: hd.privKey!, publicKey: hd.pubKey!);
+  BitcoinWalletKeys get keys =>
+      BitcoinWalletKeys(wif: hd.wif!, privateKey: hd.privKey!, publicKey: hd.pubKey!);
 
   String _password;
   List<BitcoinUnspent> unspentCoins;
@@ -139,8 +148,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       await updateBalance();
       _feeRates = await electrumClient.feeRates();
 
-      Timer.periodic(const Duration(minutes: 1),
-          (timer) async => _feeRates = await electrumClient.feeRates());
+      Timer.periodic(
+          const Duration(minutes: 1), (timer) async => _feeRates = await electrumClient.feeRates());
 
       syncStatus = SyncedSyncStatus();
     } catch (e, stacktrace) {
@@ -169,8 +178,7 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   }
 
   @override
-  Future<PendingBitcoinTransaction> createTransaction(
-      Object credentials) async {
+  Future<PendingTransaction> createTransaction(Object credentials) async {
     const minAmount = 546;
     final transactionCredentials = credentials as BitcoinTransactionCredentials;
     final inputs = <BitcoinUnspent>[];
@@ -204,13 +212,11 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     var fee = 0;
 
     if (hasMultiDestination) {
-      if (outputs.any((item) => item.sendAll
-          || item.formattedCryptoAmount! <= 0)) {
+      if (outputs.any((item) => item.sendAll || item.formattedCryptoAmount! <= 0)) {
         throw BitcoinTransactionWrongBalanceException(currency);
       }
 
-      credentialsAmount = outputs.fold(0, (acc, value) =>
-          acc + value.formattedCryptoAmount!);
+      credentialsAmount = outputs.fold(0, (acc, value) => acc + value.formattedCryptoAmount!);
 
       if (allAmount - credentialsAmount < minAmount) {
         throw BitcoinTransactionWrongBalanceException(currency);
@@ -227,9 +233,7 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       }
     } else {
       final output = outputs.first;
-      credentialsAmount = !output.sendAll
-          ? output.formattedCryptoAmount!
-          : 0;
+      credentialsAmount = !output.sendAll ? output.formattedCryptoAmount! : 0;
 
       if (credentialsAmount > allAmount) {
         throw BitcoinTransactionWrongBalanceException(currency);
@@ -291,8 +295,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
         final p2wpkh = bitcoin
             .P2WPKH(
             data: generatePaymentData(
-              hd: input.address.isHidden ? walletAddresses.sideHd : walletAddresses.mainHd,
-              index: input.address.index),
+                hd: input.bitcoinAddressRecord.isHidden ? walletAddresses.sideHd : walletAddresses.mainHd,
+                index: input.bitcoinAddressRecord.index),
             network: networkType)
             .data;
 
@@ -303,19 +307,12 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     });
 
     outputs.forEach((item) {
-      final outputAmount = hasMultiDestination
-          ? item.formattedCryptoAmount
-          : amount;
-      final outputAddress = item.isParsedAddress
-          ? item.extractedAddress!
-          : item.address;
-      txb.addOutput(
-          addressToOutputScript(outputAddress, networkType),
-          outputAmount!);
+      final outputAmount = hasMultiDestination ? item.formattedCryptoAmount : amount;
+      final outputAddress = item.isParsedAddress ? item.extractedAddress! : item.address;
+      txb.addOutput(addressToOutputScript(outputAddress, networkType), outputAmount!);
     });
 
-    final estimatedSize =
-      estimatedTransactionSize(inputs.length, outputs.length + 1);
+    final estimatedSize = estimatedTransactionSize(inputs.length, outputs.length + 1);
     var feeAmount = 0;
 
     if (transactionCredentials.feeRate != null) {
@@ -333,8 +330,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     for (var i = 0; i < inputs.length; i++) {
       final input = inputs[i];
       final keyPair = generateKeyPair(
-          hd: input.address.isHidden ? walletAddresses.sideHd : walletAddresses.mainHd,
-          index: input.address.index,
+          hd: input.bitcoinAddressRecord.isHidden ? walletAddresses.sideHd : walletAddresses.mainHd,
+          index: input.bitcoinAddressRecord.index,
           network: networkType);
       final witnessValue = input.isP2wpkh ? input.value : null;
 
@@ -350,12 +347,12 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   }
 
   String toJSON() => json.encode({
-        'mnemonic': mnemonic,
-        'account_index': walletAddresses.currentReceiveAddressIndex.toString(),
-        'change_address_index': walletAddresses.currentChangeAddressIndex.toString(),
-        'addresses': walletAddresses.addresses.map((addr) => addr.toJSON()).toList(),
-        'balance': balance[currency]?.toJSON()
-      });
+    'mnemonic': mnemonic,
+    'account_index': walletAddresses.currentReceiveAddressIndex.toString(),
+    'change_address_index': walletAddresses.currentChangeAddressIndex.toString(),
+    'addresses': walletAddresses.addresses.map((addr) => addr.toJSON()).toList(),
+    'balance': balance[currency]?.toJSON()
+  });
 
   int feeRate(TransactionPriority priority) {
     try {
@@ -364,34 +361,29 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       }
 
       return 0;
-    } catch(_) {
+    } catch (_) {
       return 0;
     }
   }
 
-  int feeAmountForPriority(BitcoinTransactionPriority priority, int inputsCount,
-          int outputsCount) =>
+  int feeAmountForPriority(
+      BitcoinTransactionPriority priority, int inputsCount, int outputsCount) =>
       feeRate(priority) * estimatedTransactionSize(inputsCount, outputsCount);
 
-  int feeAmountWithFeeRate(int feeRate, int inputsCount,
-          int outputsCount) =>
+  int feeAmountWithFeeRate(int feeRate, int inputsCount, int outputsCount) =>
       feeRate * estimatedTransactionSize(inputsCount, outputsCount);
 
   @override
-  int calculateEstimatedFee(TransactionPriority? priority, int? amount,
-    {int? outputsCount}) {
+  int calculateEstimatedFee(TransactionPriority? priority, int? amount, {int? outputsCount}) {
     if (priority is BitcoinTransactionPriority) {
-      return calculateEstimatedFeeWithFeeRate(
-        feeRate(priority),
-        amount,
-        outputsCount: outputsCount);
+      return calculateEstimatedFeeWithFeeRate(feeRate(priority), amount,
+          outputsCount: outputsCount);
     }
 
     return 0;
   }
 
-  int calculateEstimatedFeeWithFeeRate(int feeRate, int? amount,
-  {int? outputsCount}) {
+  int calculateEstimatedFeeWithFeeRate(int feeRate, int? amount, {int? outputsCount}) {
     int inputsCount = 0;
 
     if (amount != null) {
@@ -420,8 +412,7 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     // If send all, then we have no change value
     final _outputsCount = outputsCount ?? (amount != null ? 2 : 1);
 
-    return feeAmountWithFeeRate(
-        feeRate, inputsCount, _outputsCount);
+    return feeAmountWithFeeRate(feeRate, inputsCount, _outputsCount);
   }
 
   @override
@@ -436,8 +427,7 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     final currentWalletPath = await pathForWallet(name: walletInfo.name, type: type);
     final currentWalletFile = File(currentWalletPath);
 
-    final currentDirPath =
-        await pathForWalletDir(name: walletInfo.name, type: type);
+    final currentDirPath = await pathForWalletDir(name: walletInfo.name, type: type);
     final currentTransactionsFile = File('$currentDirPath/$transactionsHistoryFileName');
 
     // Copies current wallet files into new wallet name's dir and files
@@ -474,21 +464,20 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     } catch (_) {}
   }
 
-  Future<String> makePath() async =>
-      pathForWallet(name: walletInfo.name, type: walletInfo.type);
+  Future<String> makePath() async => pathForWallet(name: walletInfo.name, type: walletInfo.type);
 
   Future<void> updateUnspent() async {
     final unspent = await Future.wait(walletAddresses
         .addresses.map((address) => electrumClient
         .getListUnspentWithAddress(address.address, networkType)
         .then((unspent) => unspent
-            .map((unspent) {
-              try {
-                return BitcoinUnspent.fromJSON(address, unspent);
-              } catch(_) {
-                return null;
-              }
-            }).whereNotNull())));
+        .map((unspent) {
+      try {
+        return BitcoinUnspent.fromJSON(address, unspent);
+      } catch(_) {
+        return null;
+      }
+    }).whereNotNull())));
     unspentCoins = unspent.expand((e) => e).toList();
 
     if (unspentCoinsInfo.isEmpty) {
@@ -498,8 +487,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
 
     if (unspentCoins.isNotEmpty) {
       unspentCoins.forEach((coin) {
-        final coinInfoList = unspentCoinsInfo.values.where((element) =>
-          element.walletId.contains(id) && element.hash.contains(coin.hash));
+        final coinInfoList = unspentCoinsInfo.values
+            .where((element) => element.walletId.contains(id) && element.hash.contains(coin.hash));
 
         if (coinInfoList.isNotEmpty) {
           final coinInfo = coinInfoList.first;
@@ -518,14 +507,14 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
 
   Future<void> _addCoinInfo(BitcoinUnspent coin) async {
     final newInfo = UnspentCoinsInfo(
-        walletId: id,
-        hash: coin.hash,
-        isFrozen: coin.isFrozen,
-        isSending: coin.isSending,
-        noteRaw: coin.note,
-        address: coin.address.address,
-        value: coin.value,
-        vout: coin.vout,
+      walletId: id,
+      hash: coin.hash,
+      isFrozen: coin.isFrozen,
+      isSending: coin.isSending,
+      noteRaw: coin.note,
+      address: coin.bitcoinAddressRecord.address,
+      value: coin.value,
+      vout: coin.vout,
     );
 
     await unspentCoinsInfo.add(newInfo);
@@ -534,8 +523,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   Future<void> _refreshUnspentCoinsInfo() async {
     try {
       final List<dynamic> keys = <dynamic>[];
-      final currentWalletUnspentCoins = unspentCoinsInfo.values
-          .where((element) => element.walletId.contains(id));
+      final currentWalletUnspentCoins =
+      unspentCoinsInfo.values.where((element) => element.walletId.contains(id));
 
       if (currentWalletUnspentCoins.isNotEmpty) {
         currentWalletUnspentCoins.forEach((element) {
@@ -571,27 +560,19 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       ins.add(tx);
     }
 
-    return ElectrumTransactionBundle(
-      original,
-      ins: ins,
-      time: time,
-      confirmations: confirmations);
+    return ElectrumTransactionBundle(original, ins: ins, time: time, confirmations: confirmations);
   }
 
   Future<ElectrumTransactionInfo?> fetchTransactionInfo(
       {required String hash, required int height}) async {
-        try {
-    final tx = await getTransactionExpanded(hash: hash, height: height);
-    final addresses = walletAddresses.addresses.map((addr) => addr.address).toSet();
-    return ElectrumTransactionInfo.fromElectrumBundle(
-      tx,
-      walletInfo.type,
-      networkType,
-      addresses: addresses,
-      height: height);
-      } catch(_) {
-        return null;
-      }
+    try {
+      final tx = await getTransactionExpanded(hash: hash, height: height);
+      final addresses = walletAddresses.addresses.map((addr) => addr.address).toSet();
+      return ElectrumTransactionInfo.fromElectrumBundle(tx, walletInfo.type, networkType,
+          addresses: addresses, height: height);
+    } catch (_) {
+      return null;
+    }
   }
 
   @override
@@ -602,10 +583,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       final sh = scriptHash(addressRecord.address, networkType: networkType);
       addressHashes[sh] = addressRecord;
     });
-    final histories =
-        addressHashes.keys.map((scriptHash) => electrumClient
-          .getHistory(scriptHash)
-          .then((history) => {scriptHash: history}));
+    final histories = addressHashes.keys.map((scriptHash) =>
+        electrumClient.getHistory(scriptHash).then((history) => {scriptHash: history}));
     final historyResults = await Future.wait(histories);
     historyResults.forEach((history) {
       history.entries.forEach((historyItem) {
@@ -616,19 +595,16 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
         }
       });
     });
-    final historiesWithDetails = await Future.wait(
-      normalizedHistories
-        .map((transaction) {
-          try {
-            return fetchTransactionInfo(
-              hash: transaction['tx_hash'] as String,
-              height: transaction['height'] as int);
-          } catch(_) {
-            return Future.value(null);
-          }
-        }));
-    return historiesWithDetails.fold<Map<String, ElectrumTransactionInfo>>(
-        <String, ElectrumTransactionInfo>{}, (acc, tx) {
+    final historiesWithDetails = await Future.wait(normalizedHistories.map((transaction) {
+      try {
+        return fetchTransactionInfo(
+            hash: transaction['tx_hash'] as String, height: transaction['height'] as int);
+      } catch (_) {
+        return Future.value(null);
+      }
+    }));
+    return historiesWithDetails
+        .fold<Map<String, ElectrumTransactionInfo>>(<String, ElectrumTransactionInfo>{}, (acc, tx) {
       if (tx == null) {
         return acc;
       }
@@ -680,9 +656,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   Future<ElectrumBalance> _fetchBalances() async {
     final addresses = walletAddresses.addresses.toList();
     final balanceFutures = <Future<Map<String, dynamic>>>[];
-
     for (var i = 0; i < addresses.length; i++) {
-      final addressRecord = addresses[i];
+      final addressRecord = addresses[i] ;
       final sh = scriptHash(addressRecord.address, networkType: networkType);
       final balanceFuture = electrumClient.getBalance(sh);
       balanceFutures.add(balanceFuture);
@@ -691,8 +666,10 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
     var totalFrozen = 0;
     unspentCoinsInfo.values.forEach((info) {
       unspentCoins.forEach((element) {
-        if (element.hash == info.hash && info.isFrozen && element.address.address == info.address
-            && element.value == info.value) {
+        if (element.hash == info.hash &&
+            info.isFrozen &&
+            element.bitcoinAddressRecord.address == info.address &&
+            element.value == info.value) {
           totalFrozen += element.value;
         }
       });
@@ -715,8 +692,8 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
       }
     }
 
-    return ElectrumBalance(confirmed: totalConfirmed, unconfirmed: totalUnconfirmed,
-    frozen: totalFrozen);
+    return ElectrumBalance(
+        confirmed: totalConfirmed, unconfirmed: totalUnconfirmed, frozen: totalFrozen);
   }
 
   Future<void> updateBalance() async {
@@ -727,9 +704,7 @@ abstract class ElectrumWalletBase extends WalletBase<ElectrumBalance,
   String getChangeAddress() {
     const minCountOfHiddenAddresses = 5;
     final random = Random();
-    var addresses = walletAddresses.addresses
-      .where((addr) => addr.isHidden)
-      .toList();
+    var addresses = walletAddresses.addresses.where((addr) => addr.isHidden).toList();
 
     if (addresses.length < minCountOfHiddenAddresses) {
       addresses = walletAddresses.addresses.toList();
diff --git a/cw_bitcoin/lib/electrum_wallet_addresses.dart b/cw_bitcoin/lib/electrum_wallet_addresses.dart
index 741c2fe1cd..ab99a875c1 100644
--- a/cw_bitcoin/lib/electrum_wallet_addresses.dart
+++ b/cw_bitcoin/lib/electrum_wallet_addresses.dart
@@ -1,9 +1,11 @@
 import 'package:bitcoin_flutter/bitcoin_flutter.dart' as bitcoin;
+import 'package:bitbox/bitbox.dart' as bitbox;
 import 'package:cw_bitcoin/bitcoin_address_record.dart';
 import 'package:cw_bitcoin/electrum.dart';
 import 'package:cw_bitcoin/script_hash.dart';
 import 'package:cw_core/wallet_addresses.dart';
 import 'package:cw_core/wallet_info.dart';
+import 'package:cw_core/wallet_type.dart';
 import 'package:mobx/mobx.dart';
 
 part 'electrum_wallet_addresses.g.dart';
@@ -38,6 +40,8 @@ abstract class ElectrumWalletAddressesBase extends WalletAddresses with Store {
   static const defaultChangeAddressesCount = 17;
   static const gap = 20;
 
+  static String toCashAddr(String address) => bitbox.Address.toCashAddress(address);
+
   final ObservableList<BitcoinAddressRecord> addresses;
   final ObservableList<BitcoinAddressRecord> receiveAddresses;
   final ObservableList<BitcoinAddressRecord> changeAddresses;
@@ -50,10 +54,12 @@ abstract class ElectrumWalletAddressesBase extends WalletAddresses with Store {
   @computed
   String get address {
     if (receiveAddresses.isEmpty) {
-      return generateNewAddress().address;
+      final address = generateNewAddress().address;
+      return walletInfo.type == WalletType.bitcoinCash ? toCashAddr(address) : address;
     }
+    final receiveAddress = receiveAddresses.first.address;
 
-    return receiveAddresses.first.address;
+    return walletInfo.type == WalletType.bitcoinCash ? toCashAddr(receiveAddress) : receiveAddress;
   }
 
   @override
@@ -105,10 +111,9 @@ abstract class ElectrumWalletAddressesBase extends WalletAddresses with Store {
   @action
   Future<String> getChangeAddress() async {
     updateChangeAddresses();
-    
+
     if (changeAddresses.isEmpty) {
-      final newAddresses = await _createNewAddresses(
-        gap,
+      final newAddresses = await _createNewAddresses(gap,
         hd: sideHd,
         startIndex: totalCountOfChangeAddresses > 0
           ? totalCountOfChangeAddresses -  1
@@ -179,7 +184,7 @@ abstract class ElectrumWalletAddressesBase extends WalletAddresses with Store {
     } else {
       addrs = await _createNewAddresses(
           isHidden
-            ? defaultChangeAddressesCount
+            ?  defaultChangeAddressesCount
             : defaultReceiveAddressesCount,
           startIndex: 0,
           hd: hd,
diff --git a/cw_bitcoin/pubspec.lock b/cw_bitcoin/pubspec.lock
index 843daa7714..eb75227b6d 100644
--- a/cw_bitcoin/pubspec.lock
+++ b/cw_bitcoin/pubspec.lock
@@ -66,6 +66,15 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.0.6"
+  bitbox:
+    dependency: "direct main"
+    description:
+      path: "."
+      ref: master
+      resolved-ref: ea65073efbaf395a5557e8cd7bd72f195cd7eb11
+      url: "https://github.com/cake-tech/bitbox-flutter.git"
+    source: git
+    version: "1.0.1"
   bitcoin_flutter:
     dependency: "direct main"
     description:
diff --git a/cw_bitcoin/pubspec.yaml b/cw_bitcoin/pubspec.yaml
index dae0af39b3..693d5af7ae 100644
--- a/cw_bitcoin/pubspec.yaml
+++ b/cw_bitcoin/pubspec.yaml
@@ -23,6 +23,10 @@ dependencies:
     git:
       url: https://github.com/cake-tech/bitcoin_flutter.git
       ref: cake-update-v3
+  bitbox:
+    git:
+      url: https://github.com/cake-tech/bitbox-flutter.git
+      ref: master
   rxdart: ^0.27.5
   unorm_dart: ^0.2.0
   cryptography: ^2.0.5
diff --git a/cw_bitcoin_cash/.gitignore b/cw_bitcoin_cash/.gitignore
new file mode 100644
index 0000000000..96486fd930
--- /dev/null
+++ b/cw_bitcoin_cash/.gitignore
@@ -0,0 +1,30 @@
+# Miscellaneous
+*.class
+*.log
+*.pyc
+*.swp
+.DS_Store
+.atom/
+.buildlog/
+.history
+.svn/
+migrate_working_dir/
+
+# IntelliJ related
+*.iml
+*.ipr
+*.iws
+.idea/
+
+# The .vscode folder contains launch configuration and tasks you configure in
+# VS Code which you may wish to be included in version control, so this line
+# is commented out by default.
+#.vscode/
+
+# Flutter/Dart/Pub related
+# Libraries should not include pubspec.lock, per https://dart.dev/guides/libraries/private-files#pubspeclock.
+/pubspec.lock
+**/doc/api/
+.dart_tool/
+.packages
+build/
diff --git a/cw_bitcoin_cash/.metadata b/cw_bitcoin_cash/.metadata
new file mode 100644
index 0000000000..4161da6ea4
--- /dev/null
+++ b/cw_bitcoin_cash/.metadata
@@ -0,0 +1,10 @@
+# This file tracks properties of this Flutter project.
+# Used by Flutter tool to assess capabilities and perform upgrades etc.
+#
+# This file should be version controlled and should not be manually edited.
+
+version:
+  revision: b06b8b2710955028a6b562f5aa6fe62941d6febf
+  channel: stable
+
+project_type: package
diff --git a/cw_bitcoin_cash/CHANGELOG.md b/cw_bitcoin_cash/CHANGELOG.md
new file mode 100644
index 0000000000..41cc7d8192
--- /dev/null
+++ b/cw_bitcoin_cash/CHANGELOG.md
@@ -0,0 +1,3 @@
+## 0.0.1
+
+* TODO: Describe initial release.
diff --git a/cw_bitcoin_cash/LICENSE b/cw_bitcoin_cash/LICENSE
new file mode 100644
index 0000000000..ba75c69f7f
--- /dev/null
+++ b/cw_bitcoin_cash/LICENSE
@@ -0,0 +1 @@
+TODO: Add your license here.
diff --git a/cw_bitcoin_cash/README.md b/cw_bitcoin_cash/README.md
new file mode 100644
index 0000000000..02fe8ecabc
--- /dev/null
+++ b/cw_bitcoin_cash/README.md
@@ -0,0 +1,39 @@
+<!--
+This README describes the package. If you publish this package to pub.dev,
+this README's contents appear on the landing page for your package.
+
+For information about how to write a good package README, see the guide for
+[writing package pages](https://dart.dev/guides/libraries/writing-package-pages).
+
+For general information about developing packages, see the Dart guide for
+[creating packages](https://dart.dev/guides/libraries/create-library-packages)
+and the Flutter guide for
+[developing packages and plugins](https://flutter.dev/developing-packages).
+-->
+
+TODO: Put a short description of the package here that helps potential users
+know whether this package might be useful for them.
+
+## Features
+
+TODO: List what your package can do. Maybe include images, gifs, or videos.
+
+## Getting started
+
+TODO: List prerequisites and provide or point to information on how to
+start using the package.
+
+## Usage
+
+TODO: Include short and useful examples for package users. Add longer examples
+to `/example` folder.
+
+```dart
+const like = 'sample';
+```
+
+## Additional information
+
+TODO: Tell users more about the package: where to find more information, how to
+contribute to the package, how to file issues, what response they can expect
+from the package authors, and more.
diff --git a/cw_bitcoin_cash/analysis_options.yaml b/cw_bitcoin_cash/analysis_options.yaml
new file mode 100644
index 0000000000..a5744c1cfb
--- /dev/null
+++ b/cw_bitcoin_cash/analysis_options.yaml
@@ -0,0 +1,4 @@
+include: package:flutter_lints/flutter.yaml
+
+# Additional information about this file can be found at
+# https://dart.dev/guides/language/analysis-options
diff --git a/cw_bitcoin_cash/lib/cw_bitcoin_cash.dart b/cw_bitcoin_cash/lib/cw_bitcoin_cash.dart
new file mode 100644
index 0000000000..732474ac41
--- /dev/null
+++ b/cw_bitcoin_cash/lib/cw_bitcoin_cash.dart
@@ -0,0 +1,9 @@
+library cw_bitcoin_cash;
+
+export 'src/bitcoin_cash_base.dart';
+
+/// A Calculator.
+class Calculator {
+  /// Returns [value] plus 1.
+  int addOne(int value) => value + 1;
+}
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_address_utils.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_address_utils.dart
new file mode 100644
index 0000000000..ca47ea9f6c
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_address_utils.dart
@@ -0,0 +1,5 @@
+import 'package:bitbox/bitbox.dart' as bitbox;
+
+class AddressUtils {
+  static String getCashAddrFormat(String address) => bitbox.Address.toCashAddress(address);
+}
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_base.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_base.dart
new file mode 100644
index 0000000000..4699b1649e
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_base.dart
@@ -0,0 +1,7 @@
+export 'bitcoin_cash_wallet.dart';
+export 'bitcoin_cash_wallet_addresses.dart';
+export 'bitcoin_cash_wallet_creation_credentials.dart';
+export 'bitcoin_cash_wallet_service.dart';
+export 'exceptions/exceptions.dart';
+export 'mnemonic.dart';
+export 'bitcoin_cash_address_utils.dart';
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet.dart
new file mode 100644
index 0000000000..b4924e2db2
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet.dart
@@ -0,0 +1,297 @@
+import 'package:bitbox/bitbox.dart' as bitbox;
+import 'package:bitcoin_flutter/bitcoin_flutter.dart' as bitcoin;
+import 'package:cw_bitcoin/bitcoin_address_record.dart';
+import 'package:cw_bitcoin/bitcoin_transaction_credentials.dart';
+import 'package:cw_bitcoin/bitcoin_transaction_no_inputs_exception.dart';
+import 'package:cw_bitcoin/bitcoin_transaction_priority.dart';
+import 'package:cw_bitcoin/bitcoin_transaction_wrong_balance_exception.dart';
+import 'package:cw_bitcoin/bitcoin_unspent.dart';
+import 'package:cw_bitcoin/electrum_balance.dart';
+import 'package:cw_bitcoin/electrum_wallet.dart';
+import 'package:cw_bitcoin/electrum_wallet_snapshot.dart';
+import 'package:cw_bitcoin_cash/src/pending_bitcoin_cash_transaction.dart';
+import 'package:cw_core/crypto_currency.dart';
+import 'package:cw_core/transaction_priority.dart';
+import 'package:cw_core/unspent_coins_info.dart';
+import 'package:cw_core/wallet_info.dart';
+import 'package:flutter/foundation.dart';
+import 'package:hive/hive.dart';
+import 'package:mobx/mobx.dart';
+
+import 'bitcoin_cash_base.dart';
+
+part 'bitcoin_cash_wallet.g.dart';
+
+class BitcoinCashWallet = BitcoinCashWalletBase with _$BitcoinCashWallet;
+
+abstract class BitcoinCashWalletBase extends ElectrumWallet with Store {
+  BitcoinCashWalletBase(
+      {required String mnemonic,
+      required String password,
+      required WalletInfo walletInfo,
+      required Box<UnspentCoinsInfo> unspentCoinsInfo,
+      required Uint8List seedBytes,
+      List<BitcoinAddressRecord>? initialAddresses,
+      ElectrumBalance? initialBalance,
+      int initialRegularAddressIndex = 0,
+      int initialChangeAddressIndex = 0})
+      : super(
+            mnemonic: mnemonic,
+            password: password,
+            walletInfo: walletInfo,
+            unspentCoinsInfo: unspentCoinsInfo,
+            networkType: bitcoin.bitcoin,
+            initialAddresses: initialAddresses,
+            initialBalance: initialBalance,
+            seedBytes: seedBytes,
+            currency: CryptoCurrency.bch) {
+    walletAddresses = BitcoinCashWalletAddresses(walletInfo,
+        electrumClient: electrumClient,
+        initialAddresses: initialAddresses,
+        initialRegularAddressIndex: initialRegularAddressIndex,
+        initialChangeAddressIndex: initialChangeAddressIndex,
+        mainHd: hd,
+        sideHd: bitcoin.HDWallet.fromSeed(seedBytes)
+            .derivePath("m/44'/145'/0'/1"),
+        networkType: networkType);
+  }
+
+
+  static Future<BitcoinCashWallet> create(
+      {required String mnemonic,
+      required String password,
+      required WalletInfo walletInfo,
+      required Box<UnspentCoinsInfo> unspentCoinsInfo,
+      List<BitcoinAddressRecord>? initialAddresses,
+      ElectrumBalance? initialBalance,
+      int initialRegularAddressIndex = 0,
+      int initialChangeAddressIndex = 0}) async {
+    return BitcoinCashWallet(
+        mnemonic: mnemonic,
+        password: password,
+        walletInfo: walletInfo,
+        unspentCoinsInfo: unspentCoinsInfo,
+        initialAddresses: initialAddresses,
+        initialBalance: initialBalance,
+        seedBytes: await Mnemonic.toSeed(mnemonic),
+        initialRegularAddressIndex: initialRegularAddressIndex,
+        initialChangeAddressIndex: initialChangeAddressIndex);
+  }
+
+  static Future<BitcoinCashWallet> open({
+    required String name,
+    required WalletInfo walletInfo,
+    required Box<UnspentCoinsInfo> unspentCoinsInfo,
+    required String password,
+  }) async {
+    final snp = await ElectrumWallletSnapshot.load(name, walletInfo.type, password);
+    return BitcoinCashWallet(
+        mnemonic: snp.mnemonic,
+        password: password,
+        walletInfo: walletInfo,
+        unspentCoinsInfo: unspentCoinsInfo,
+        initialAddresses: snp.addresses,
+        initialBalance: snp.balance,
+        seedBytes: await Mnemonic.toSeed(snp.mnemonic),
+        initialRegularAddressIndex: snp.regularAddressIndex,
+        initialChangeAddressIndex: snp.changeAddressIndex);
+  }
+
+  @override
+  Future<PendingBitcoinCashTransaction> createTransaction(Object credentials) async {
+    const minAmount = 546;
+    final transactionCredentials = credentials as BitcoinTransactionCredentials;
+    final inputs = <BitcoinUnspent>[];
+    final outputs = transactionCredentials.outputs;
+    final hasMultiDestination = outputs.length > 1;
+
+    var allInputsAmount = 0;
+
+    if (unspentCoins.isEmpty) await updateUnspent();
+
+    for (final utx in unspentCoins) {
+      if (utx.isSending) {
+        allInputsAmount += utx.value;
+        inputs.add(utx);
+      }
+    }
+
+    if (inputs.isEmpty) throw BitcoinTransactionNoInputsException();
+
+    final allAmountFee = transactionCredentials.feeRate != null
+        ? feeAmountWithFeeRate(transactionCredentials.feeRate!, inputs.length, outputs.length)
+        : feeAmountForPriority(transactionCredentials.priority!, inputs.length, outputs.length);
+
+    final allAmount = allInputsAmount - allAmountFee;
+
+    var credentialsAmount = 0;
+    var amount = 0;
+    var fee = 0;
+
+    if (hasMultiDestination) {
+      if (outputs.any((item) => item.sendAll || item.formattedCryptoAmount! <= 0)) {
+        throw BitcoinTransactionWrongBalanceException(currency);
+      }
+
+      credentialsAmount = outputs.fold(0, (acc, value) => acc + value.formattedCryptoAmount!);
+
+      if (allAmount - credentialsAmount < minAmount) {
+        throw BitcoinTransactionWrongBalanceException(currency);
+      }
+
+      amount = credentialsAmount;
+
+      if (transactionCredentials.feeRate != null) {
+        fee = calculateEstimatedFeeWithFeeRate(transactionCredentials.feeRate!, amount,
+            outputsCount: outputs.length + 1);
+      } else {
+        fee = calculateEstimatedFee(transactionCredentials.priority, amount,
+            outputsCount: outputs.length + 1);
+      }
+    } else {
+      final output = outputs.first;
+      credentialsAmount = !output.sendAll ? output.formattedCryptoAmount! : 0;
+
+      if (credentialsAmount > allAmount) {
+        throw BitcoinTransactionWrongBalanceException(currency);
+      }
+
+      amount = output.sendAll || allAmount - credentialsAmount < minAmount
+          ? allAmount
+          : credentialsAmount;
+
+      if (output.sendAll || amount == allAmount) {
+        fee = allAmountFee;
+      } else if (transactionCredentials.feeRate != null) {
+        fee = calculateEstimatedFeeWithFeeRate(transactionCredentials.feeRate!, amount);
+      } else {
+        fee = calculateEstimatedFee(transactionCredentials.priority, amount);
+      }
+    }
+
+    if (fee == 0) {
+      throw BitcoinTransactionWrongBalanceException(currency);
+    }
+
+    final totalAmount = amount + fee;
+
+    if (totalAmount > balance[currency]!.confirmed || totalAmount > allInputsAmount) {
+      throw BitcoinTransactionWrongBalanceException(currency);
+    }
+    final txb = bitbox.Bitbox.transactionBuilder(testnet: false);
+
+    final changeAddress = await walletAddresses.getChangeAddress();
+    var leftAmount = totalAmount;
+    var totalInputAmount = 0;
+
+    inputs.clear();
+
+    for (final utx in unspentCoins) {
+      if (utx.isSending) {
+        leftAmount = leftAmount - utx.value;
+        totalInputAmount += utx.value;
+        inputs.add(utx);
+
+        if (leftAmount <= 0) {
+          break;
+        }
+      }
+    }
+
+    if (inputs.isEmpty) throw BitcoinTransactionNoInputsException();
+
+    if (amount <= 0 || totalInputAmount < totalAmount) {
+      throw BitcoinTransactionWrongBalanceException(currency);
+    }
+
+    inputs.forEach((input) {
+      txb.addInput(input.hash, input.vout);
+    });
+
+    outputs.forEach((item) {
+      final outputAmount = hasMultiDestination ? item.formattedCryptoAmount : amount;
+      final outputAddress = item.isParsedAddress ? item.extractedAddress! : item.address;
+      txb.addOutput(outputAddress, outputAmount!);
+    });
+
+    final estimatedSize = bitbox.BitcoinCash.getByteCount(inputs.length, outputs.length + 1);
+
+    var feeAmount = 0;
+
+    if (transactionCredentials.feeRate != null) {
+      feeAmount = transactionCredentials.feeRate! * estimatedSize;
+    } else {
+      feeAmount = feeRate(transactionCredentials.priority!) * estimatedSize;
+    }
+
+    final changeValue = totalInputAmount - amount - feeAmount;
+
+    if (changeValue > minAmount) {
+      txb.addOutput(changeAddress, changeValue);
+    }
+
+    for (var i = 0; i < inputs.length; i++) {
+      final input = inputs[i];
+      final keyPair = generateKeyPair(
+          hd: input.bitcoinAddressRecord.isHidden ? walletAddresses.sideHd : walletAddresses.mainHd,
+          index: input.bitcoinAddressRecord.index);
+      txb.sign(i, keyPair, input.value);
+    }
+
+    // Build the transaction
+    final tx = txb.build();
+
+    return PendingBitcoinCashTransaction(tx, type,
+        electrumClient: electrumClient, amount: amount, fee: fee);
+  }
+
+  bitbox.ECPair generateKeyPair(
+          {required bitcoin.HDWallet hd,
+          required int index}) =>
+      bitbox.ECPair.fromWIF(hd.derive(index).wif!);
+
+  @override
+  int feeAmountForPriority(
+          BitcoinTransactionPriority priority, int inputsCount, int outputsCount) =>
+      feeRate(priority) * bitbox.BitcoinCash.getByteCount(inputsCount, outputsCount);
+
+  int feeAmountWithFeeRate(int feeRate, int inputsCount, int outputsCount) =>
+      feeRate * bitbox.BitcoinCash.getByteCount(inputsCount, outputsCount);
+
+  int calculateEstimatedFeeWithFeeRate(int feeRate, int? amount, {int? outputsCount}) {
+    int inputsCount = 0;
+    int totalValue = 0;
+
+    for (final input in unspentCoins) {
+      if (input.isSending) {
+        inputsCount++;
+        totalValue += input.value;
+      }
+      if (amount != null && totalValue >= amount) {
+        break;
+      }
+    }
+
+    if (amount != null && totalValue < amount) return 0;
+
+    final _outputsCount = outputsCount ?? (amount != null ? 2 : 1);
+
+    return feeAmountWithFeeRate(feeRate, inputsCount, _outputsCount);
+  }
+
+  @override
+  int feeRate(TransactionPriority priority) {
+    if (priority is BitcoinCashTransactionPriority) {
+      switch (priority) {
+        case BitcoinCashTransactionPriority.slow:
+          return 1;
+        case BitcoinCashTransactionPriority.medium:
+          return 5;
+        case BitcoinCashTransactionPriority.fast:
+          return 10;
+      }
+    }
+
+    return 0;
+  }
+}
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_addresses.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_addresses.dart
new file mode 100644
index 0000000000..1709c4d8f1
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_addresses.dart
@@ -0,0 +1,34 @@
+import 'package:bitcoin_flutter/bitcoin_flutter.dart' as bitcoin;
+import 'package:cw_bitcoin/bitcoin_address_record.dart';
+import 'package:cw_bitcoin/electrum.dart';
+import 'package:cw_bitcoin/electrum_wallet_addresses.dart';
+import 'package:cw_bitcoin/utils.dart';
+import 'package:cw_core/wallet_info.dart';
+import 'package:mobx/mobx.dart';
+
+part 'bitcoin_cash_wallet_addresses.g.dart';
+
+class BitcoinCashWalletAddresses = BitcoinCashWalletAddressesBase with _$BitcoinCashWalletAddresses;
+
+abstract class BitcoinCashWalletAddressesBase extends ElectrumWalletAddresses with Store {
+  BitcoinCashWalletAddressesBase(WalletInfo walletInfo,
+      {required bitcoin.HDWallet mainHd,
+      required bitcoin.HDWallet sideHd,
+      required bitcoin.NetworkType networkType,
+      required ElectrumClient electrumClient,
+      List<BitcoinAddressRecord>? initialAddresses,
+      int initialRegularAddressIndex = 0,
+      int initialChangeAddressIndex = 0})
+      : super(walletInfo,
+            initialAddresses: initialAddresses,
+            initialRegularAddressIndex: initialRegularAddressIndex,
+            initialChangeAddressIndex: initialChangeAddressIndex,
+            mainHd: mainHd,
+            sideHd: sideHd,
+            electrumClient: electrumClient,
+            networkType: networkType);
+
+  @override
+  String getAddress({required int index, required bitcoin.HDWallet hd}) =>
+      generateP2PKHAddress(hd: hd, index: index, networkType: networkType);
+}
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_creation_credentials.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_creation_credentials.dart
new file mode 100644
index 0000000000..72caa6c58f
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_creation_credentials.dart
@@ -0,0 +1,26 @@
+import 'package:cw_core/wallet_credentials.dart';
+import 'package:cw_core/wallet_info.dart';
+
+class BitcoinCashNewWalletCredentials extends WalletCredentials {
+  BitcoinCashNewWalletCredentials({required String name, WalletInfo? walletInfo})
+      : super(name: name, walletInfo: walletInfo);
+}
+
+class BitcoinCashRestoreWalletFromSeedCredentials extends WalletCredentials {
+  BitcoinCashRestoreWalletFromSeedCredentials(
+      {required String name,
+      required String password,
+      required this.mnemonic,
+      WalletInfo? walletInfo})
+      : super(name: name, password: password, walletInfo: walletInfo);
+
+  final String mnemonic;
+}
+
+class BitcoinCashRestoreWalletFromWIFCredentials extends WalletCredentials {
+  BitcoinCashRestoreWalletFromWIFCredentials(
+      {required String name, required String password, required this.wif, WalletInfo? walletInfo})
+      : super(name: name, password: password, walletInfo: walletInfo);
+
+  final String wif;
+}
diff --git a/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_service.dart b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_service.dart
new file mode 100644
index 0000000000..fa572b38b2
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/bitcoin_cash_wallet_service.dart
@@ -0,0 +1,107 @@
+import 'dart:io';
+
+import 'package:bip39/bip39.dart';
+import 'package:cw_bitcoin_cash/cw_bitcoin_cash.dart';
+import 'package:cw_core/balance.dart';
+import 'package:cw_core/pathForWallet.dart';
+import 'package:cw_core/transaction_history.dart';
+import 'package:cw_core/transaction_info.dart';
+import 'package:cw_core/unspent_coins_info.dart';
+import 'package:cw_core/wallet_base.dart';
+import 'package:cw_core/wallet_info.dart';
+import 'package:cw_core/wallet_service.dart';
+import 'package:cw_core/wallet_type.dart';
+import 'package:collection/collection.dart';
+import 'package:hive/hive.dart';
+
+class BitcoinCashWalletService extends WalletService<BitcoinCashNewWalletCredentials,
+    BitcoinCashRestoreWalletFromSeedCredentials,
+    BitcoinCashRestoreWalletFromWIFCredentials> {
+  BitcoinCashWalletService(this.walletInfoSource, this.unspentCoinsInfoSource);
+
+  final Box<WalletInfo> walletInfoSource;
+  final Box<UnspentCoinsInfo> unspentCoinsInfoSource;
+
+  @override
+  WalletType getType() => WalletType.bitcoinCash;
+
+  @override
+  Future<bool> isWalletExit(String name) async =>
+      File(await pathForWallet(name: name, type: getType())).existsSync();
+
+  @override
+  Future<BitcoinCashWallet> create(
+      credentials) async {
+    final wallet = await BitcoinCashWalletBase.create(
+        mnemonic: await Mnemonic.generate(),
+        password: credentials.password!,
+        walletInfo: credentials.walletInfo!,
+        unspentCoinsInfo: unspentCoinsInfoSource);
+    await wallet.save();
+    await wallet.init();
+    return wallet;
+  }
+
+  @override
+  Future<BitcoinCashWallet> openWallet(String name, String password) async {
+    final walletInfo = walletInfoSource.values.firstWhereOrNull(
+            (info) => info.id == WalletBase.idFor(name, getType()))!;
+    final wallet = await BitcoinCashWalletBase.open(
+        password: password, name: name, walletInfo: walletInfo,
+        unspentCoinsInfo: unspentCoinsInfoSource);
+    await wallet.init();
+    return wallet;
+  }
+
+  @override
+  Future<void> remove(String wallet) async {
+    File(await pathForWalletDir(name: wallet, type: getType()))
+        .delete(recursive: true);
+    final walletInfo = walletInfoSource.values.firstWhereOrNull(
+            (info) => info.id == WalletBase.idFor(wallet, getType()))!;
+    await walletInfoSource.delete(walletInfo.key);
+  }
+
+  @override
+  Future<void> rename(String currentName, String password, String newName) async {
+    final currentWalletInfo = walletInfoSource.values.firstWhereOrNull(
+            (info) => info.id == WalletBase.idFor(currentName, getType()))!;
+    final currentWallet = await BitcoinCashWalletBase.open(
+        password: password,
+        name: currentName,
+        walletInfo: currentWalletInfo,
+        unspentCoinsInfo: unspentCoinsInfoSource);
+
+    await currentWallet.renameWalletFiles(newName);
+
+    final newWalletInfo = currentWalletInfo;
+    newWalletInfo.id = WalletBase.idFor(newName, getType());
+    newWalletInfo.name = newName;
+
+    await walletInfoSource.put(currentWalletInfo.key, newWalletInfo);
+  }
+
+  @override
+  Future<BitcoinCashWallet>
+  restoreFromKeys(credentials) {
+    // TODO: implement restoreFromKeys
+    throw UnimplementedError('restoreFromKeys() is not implemented');
+  }
+
+  @override
+  Future<BitcoinCashWallet> restoreFromSeed(
+      BitcoinCashRestoreWalletFromSeedCredentials credentials) async {
+    if (!validateMnemonic(credentials.mnemonic)) {
+      throw BitcoinCashMnemonicIsIncorrectException();
+    }
+
+    final wallet = await BitcoinCashWalletBase.create(
+        password: credentials.password!,
+        mnemonic: credentials.mnemonic,
+        walletInfo: credentials.walletInfo!,
+        unspentCoinsInfo: unspentCoinsInfoSource);
+    await wallet.save();
+    await wallet.init();
+    return wallet;
+  }
+}
diff --git a/cw_bitcoin_cash/lib/src/exceptions/bitcoin_cash_mnemonic_is_incorrect_exception.dart b/cw_bitcoin_cash/lib/src/exceptions/bitcoin_cash_mnemonic_is_incorrect_exception.dart
new file mode 100644
index 0000000000..7cce59085e
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/exceptions/bitcoin_cash_mnemonic_is_incorrect_exception.dart
@@ -0,0 +1,5 @@
+class BitcoinCashMnemonicIsIncorrectException implements Exception {
+  @override
+  String toString() =>
+      'Bitcoin Cash mnemonic has incorrect format. Mnemonic should contain 12 or 24 words separated by space.';
+}
diff --git a/cw_bitcoin_cash/lib/src/exceptions/exceptions.dart b/cw_bitcoin_cash/lib/src/exceptions/exceptions.dart
new file mode 100644
index 0000000000..746e3248a8
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/exceptions/exceptions.dart
@@ -0,0 +1 @@
+export 'bitcoin_cash_mnemonic_is_incorrect_exception.dart';
\ No newline at end of file
diff --git a/cw_bitcoin_cash/lib/src/mnemonic.dart b/cw_bitcoin_cash/lib/src/mnemonic.dart
new file mode 100644
index 0000000000..b1f1ee984e
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/mnemonic.dart
@@ -0,0 +1,11 @@
+import 'dart:typed_data';
+
+import 'package:bip39/bip39.dart' as bip39;
+
+class Mnemonic {
+  /// Generate bip39 mnemonic
+  static String generate({int strength = 128}) => bip39.generateMnemonic(strength: strength);
+
+  /// Create root seed from mnemonic
+  static Uint8List toSeed(String mnemonic) => bip39.mnemonicToSeed(mnemonic);
+}
diff --git a/cw_bitcoin_cash/lib/src/pending_bitcoin_cash_transaction.dart b/cw_bitcoin_cash/lib/src/pending_bitcoin_cash_transaction.dart
new file mode 100644
index 0000000000..d5ac36ce25
--- /dev/null
+++ b/cw_bitcoin_cash/lib/src/pending_bitcoin_cash_transaction.dart
@@ -0,0 +1,62 @@
+import 'package:cw_bitcoin/bitcoin_commit_transaction_exception.dart';
+import 'package:bitbox/bitbox.dart' as bitbox;
+import 'package:cw_core/pending_transaction.dart';
+import 'package:cw_bitcoin/electrum.dart';
+import 'package:cw_bitcoin/bitcoin_amount_format.dart';
+import 'package:cw_bitcoin/electrum_transaction_info.dart';
+import 'package:cw_core/transaction_direction.dart';
+import 'package:cw_core/wallet_type.dart';
+
+class PendingBitcoinCashTransaction with PendingTransaction {
+  PendingBitcoinCashTransaction(this._tx, this.type,
+      {required this.electrumClient,
+      required this.amount,
+      required this.fee})
+      : _listeners = <void Function(ElectrumTransactionInfo transaction)>[];
+
+  final WalletType type;
+  final bitbox.Transaction _tx;
+  final ElectrumClient electrumClient;
+  final int amount;
+  final int fee;
+
+  @override
+  String get id => _tx.getId();
+
+  @override
+  String get hex => _tx.toHex();
+
+  @override
+  String get amountFormatted => bitcoinAmountToString(amount: amount);
+
+  @override
+  String get feeFormatted => bitcoinAmountToString(amount: fee);
+
+  final List<void Function(ElectrumTransactionInfo transaction)> _listeners;
+
+  @override
+  Future<void> commit() async {
+    final result =
+      await electrumClient.broadcastTransaction(transactionRaw: _tx.toHex());
+
+    if (result.isEmpty) {
+      throw BitcoinCommitTransactionException();
+    }
+
+    _listeners?.forEach((listener) => listener(transactionInfo()));
+  }
+
+  void addListener(
+          void Function(ElectrumTransactionInfo transaction) listener) =>
+      _listeners.add(listener);
+
+  ElectrumTransactionInfo transactionInfo() => ElectrumTransactionInfo(type,
+      id: id,
+      height: 0,
+      amount: amount,
+      direction: TransactionDirection.outgoing,
+      date: DateTime.now(),
+      isPending: true,
+      confirmations: 0,
+      fee: fee);
+}
diff --git a/cw_bitcoin_cash/linux/flutter/ephemeral/.plugin_symlinks/path_provider_linux b/cw_bitcoin_cash/linux/flutter/ephemeral/.plugin_symlinks/path_provider_linux
new file mode 120000
index 0000000000..7d9244fbe6
--- /dev/null
+++ b/cw_bitcoin_cash/linux/flutter/ephemeral/.plugin_symlinks/path_provider_linux
@@ -0,0 +1 @@
+C:/Users/borod/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_linux-2.2.0/
\ No newline at end of file
diff --git a/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.cc b/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.cc
new file mode 100644
index 0000000000..e71a16d23d
--- /dev/null
+++ b/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.cc
@@ -0,0 +1,11 @@
+//
+//  Generated file. Do not edit.
+//
+
+// clang-format off
+
+#include "generated_plugin_registrant.h"
+
+
+void fl_register_plugins(FlPluginRegistry* registry) {
+}
diff --git a/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.h b/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.h
new file mode 100644
index 0000000000..e0f0a47bc0
--- /dev/null
+++ b/cw_bitcoin_cash/linux/flutter/generated_plugin_registrant.h
@@ -0,0 +1,15 @@
+//
+//  Generated file. Do not edit.
+//
+
+// clang-format off
+
+#ifndef GENERATED_PLUGIN_REGISTRANT_
+#define GENERATED_PLUGIN_REGISTRANT_
+
+#include <flutter_linux/flutter_linux.h>
+
+// Registers Flutter plugins.
+void fl_register_plugins(FlPluginRegistry* registry);
+
+#endif  // GENERATED_PLUGIN_REGISTRANT_
diff --git a/cw_bitcoin_cash/linux/flutter/generated_plugins.cmake b/cw_bitcoin_cash/linux/flutter/generated_plugins.cmake
new file mode 100644
index 0000000000..2e1de87a7e
--- /dev/null
+++ b/cw_bitcoin_cash/linux/flutter/generated_plugins.cmake
@@ -0,0 +1,23 @@
+#
+# Generated file, do not edit.
+#
+
+list(APPEND FLUTTER_PLUGIN_LIST
+)
+
+list(APPEND FLUTTER_FFI_PLUGIN_LIST
+)
+
+set(PLUGIN_BUNDLED_LIBRARIES)
+
+foreach(plugin ${FLUTTER_PLUGIN_LIST})
+  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
+  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
+endforeach(plugin)
+
+foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
+  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
+endforeach(ffi_plugin)
diff --git a/cw_bitcoin_cash/macos/Flutter/GeneratedPluginRegistrant.swift b/cw_bitcoin_cash/macos/Flutter/GeneratedPluginRegistrant.swift
new file mode 100644
index 0000000000..e777c67df2
--- /dev/null
+++ b/cw_bitcoin_cash/macos/Flutter/GeneratedPluginRegistrant.swift
@@ -0,0 +1,12 @@
+//
+//  Generated file. Do not edit.
+//
+
+import FlutterMacOS
+import Foundation
+
+import path_provider_foundation
+
+func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
+  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
+}
diff --git a/cw_bitcoin_cash/macos/Flutter/ephemeral/Flutter-Generated.xcconfig b/cw_bitcoin_cash/macos/Flutter/ephemeral/Flutter-Generated.xcconfig
new file mode 100644
index 0000000000..2f46994d33
--- /dev/null
+++ b/cw_bitcoin_cash/macos/Flutter/ephemeral/Flutter-Generated.xcconfig
@@ -0,0 +1,11 @@
+// This is a generated file; do not edit or check into version control.
+FLUTTER_ROOT=C:\Users\borod\flutter
+FLUTTER_APPLICATION_PATH=C:\cake_wallet\cw_bitcoin_cash
+COCOAPODS_PARALLEL_CODE_SIGN=true
+FLUTTER_BUILD_DIR=build
+FLUTTER_BUILD_NAME=0.0.1
+FLUTTER_BUILD_NUMBER=0.0.1
+DART_OBFUSCATION=false
+TRACK_WIDGET_CREATION=true
+TREE_SHAKE_ICONS=false
+PACKAGE_CONFIG=.dart_tool/package_config.json
diff --git a/cw_bitcoin_cash/macos/Flutter/ephemeral/flutter_export_environment.sh b/cw_bitcoin_cash/macos/Flutter/ephemeral/flutter_export_environment.sh
new file mode 100644
index 0000000000..2a3bcca5a6
--- /dev/null
+++ b/cw_bitcoin_cash/macos/Flutter/ephemeral/flutter_export_environment.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+# This is a generated file; do not edit or check into version control.
+export "FLUTTER_ROOT=C:\Users\borod\flutter"
+export "FLUTTER_APPLICATION_PATH=C:\cake_wallet\cw_bitcoin_cash"
+export "COCOAPODS_PARALLEL_CODE_SIGN=true"
+export "FLUTTER_BUILD_DIR=build"
+export "FLUTTER_BUILD_NAME=0.0.1"
+export "FLUTTER_BUILD_NUMBER=0.0.1"
+export "DART_OBFUSCATION=false"
+export "TRACK_WIDGET_CREATION=true"
+export "TREE_SHAKE_ICONS=false"
+export "PACKAGE_CONFIG=.dart_tool/package_config.json"
diff --git a/cw_bitcoin_cash/pubspec.yaml b/cw_bitcoin_cash/pubspec.yaml
new file mode 100644
index 0000000000..30ed49e80c
--- /dev/null
+++ b/cw_bitcoin_cash/pubspec.yaml
@@ -0,0 +1,76 @@
+name: cw_bitcoin_cash
+description: A new Flutter package project.
+version: 0.0.1
+publish_to: none
+author: Cake Wallet
+homepage: https://cakewallet.com
+
+environment:
+  sdk: '>=2.19.0 <3.0.0'
+  flutter: ">=1.17.0"
+
+dependencies:
+  flutter:
+    sdk: flutter
+  bip39: ^1.0.6
+  bip32: ^2.0.0
+  path_provider: ^2.0.11
+  mobx: ^2.0.7+4
+  flutter_mobx: ^2.0.6+1
+  cw_core:
+    path: ../cw_core
+  cw_bitcoin:
+    path: ../cw_bitcoin
+  bitcoin_flutter:
+    git:
+      url: https://github.com/cake-tech/bitcoin_flutter.git
+      ref: cake-update-v3
+  bitbox:
+    git:
+      url: https://github.com/cake-tech/bitbox-flutter.git
+      ref: master
+
+
+
+dev_dependencies:
+  flutter_test:
+    sdk: flutter
+  build_runner: ^2.1.11
+  mobx_codegen: ^2.0.7
+  hive_generator: ^1.1.3
+
+# For information on the generic Dart part of this file, see the
+# following page: https://dart.dev/tools/pub/pubspec
+
+# The following section is specific to Flutter packages.
+flutter:
+
+# To add assets to your package, add an assets section, like this:
+# assets:
+#   - images/a_dot_burr.jpeg
+#   - images/a_dot_ham.jpeg
+#
+# For details regarding assets in packages, see
+# https://flutter.dev/assets-and-images/#from-packages
+#
+# An image asset can refer to one or more resolution-specific "variants", see
+# https://flutter.dev/assets-and-images/#resolution-aware
+
+# To add custom fonts to your package, add a fonts section here,
+# in this "flutter" section. Each entry in this list should have a
+# "family" key with the font family name, and a "fonts" key with a
+# list giving the asset and other descriptors for the font. For
+# example:
+# fonts:
+#   - family: Schyler
+#     fonts:
+#       - asset: fonts/Schyler-Regular.ttf
+#       - asset: fonts/Schyler-Italic.ttf
+#         style: italic
+#   - family: Trajan Pro
+#     fonts:
+#       - asset: fonts/TrajanPro.ttf
+#       - asset: fonts/TrajanPro_Bold.ttf
+#         weight: 700
+#
+
diff --git a/cw_bitcoin_cash/test/cw_bitcoin_cash_test.dart b/cw_bitcoin_cash/test/cw_bitcoin_cash_test.dart
new file mode 100644
index 0000000000..f06646a8f3
--- /dev/null
+++ b/cw_bitcoin_cash/test/cw_bitcoin_cash_test.dart
@@ -0,0 +1,12 @@
+import 'package:flutter_test/flutter_test.dart';
+
+import 'package:cw_bitcoin_cash/cw_bitcoin_cash.dart';
+
+void main() {
+  test('adds one to input values', () {
+    final calculator = Calculator();
+    expect(calculator.addOne(2), 3);
+    expect(calculator.addOne(-7), -6);
+    expect(calculator.addOne(0), 1);
+  });
+}
diff --git a/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.cc b/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.cc
new file mode 100644
index 0000000000..8b6d4680af
--- /dev/null
+++ b/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.cc
@@ -0,0 +1,11 @@
+//
+//  Generated file. Do not edit.
+//
+
+// clang-format off
+
+#include "generated_plugin_registrant.h"
+
+
+void RegisterPlugins(flutter::PluginRegistry* registry) {
+}
diff --git a/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.h b/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.h
new file mode 100644
index 0000000000..dc139d85a9
--- /dev/null
+++ b/cw_bitcoin_cash/windows/flutter/generated_plugin_registrant.h
@@ -0,0 +1,15 @@
+//
+//  Generated file. Do not edit.
+//
+
+// clang-format off
+
+#ifndef GENERATED_PLUGIN_REGISTRANT_
+#define GENERATED_PLUGIN_REGISTRANT_
+
+#include <flutter/plugin_registry.h>
+
+// Registers Flutter plugins.
+void RegisterPlugins(flutter::PluginRegistry* registry);
+
+#endif  // GENERATED_PLUGIN_REGISTRANT_
diff --git a/cw_bitcoin_cash/windows/flutter/generated_plugins.cmake b/cw_bitcoin_cash/windows/flutter/generated_plugins.cmake
new file mode 100644
index 0000000000..b93c4c30c1
--- /dev/null
+++ b/cw_bitcoin_cash/windows/flutter/generated_plugins.cmake
@@ -0,0 +1,23 @@
+#
+# Generated file, do not edit.
+#
+
+list(APPEND FLUTTER_PLUGIN_LIST
+)
+
+list(APPEND FLUTTER_FFI_PLUGIN_LIST
+)
+
+set(PLUGIN_BUNDLED_LIBRARIES)
+
+foreach(plugin ${FLUTTER_PLUGIN_LIST})
+  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
+  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
+endforeach(plugin)
+
+foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
+  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
+  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
+endforeach(ffi_plugin)
diff --git a/cw_core/lib/amount_converter.dart b/cw_core/lib/amount_converter.dart
index a11907ef2f..6fd43dd821 100644
--- a/cw_core/lib/amount_converter.dart
+++ b/cw_core/lib/amount_converter.dart
@@ -80,6 +80,7 @@ class AmountConverter {
       case CryptoCurrency.xmr:
         return _moneroAmountToString(amount);
       case CryptoCurrency.btc:
+      case CryptoCurrency.bch:
         return _bitcoinAmountToString(amount);
       case CryptoCurrency.xhv:
       case CryptoCurrency.xag:
diff --git a/cw_core/lib/currency_for_wallet_type.dart b/cw_core/lib/currency_for_wallet_type.dart
index 2db858b305..4c330b0732 100644
--- a/cw_core/lib/currency_for_wallet_type.dart
+++ b/cw_core/lib/currency_for_wallet_type.dart
@@ -13,6 +13,8 @@ CryptoCurrency currencyForWalletType(WalletType type) {
       return CryptoCurrency.xhv;
     case WalletType.ethereum:
       return CryptoCurrency.eth;
+    case WalletType.bitcoinCash:
+      return CryptoCurrency.bch;
     case WalletType.nano:
       return CryptoCurrency.nano;
     case WalletType.banano:
diff --git a/cw_core/lib/node.dart b/cw_core/lib/node.dart
index a07030d646..dc3620ec2c 100644
--- a/cw_core/lib/node.dart
+++ b/cw_core/lib/node.dart
@@ -78,6 +78,8 @@ class Node extends HiveObject with Keyable {
         return Uri.http(uriRaw, '');
       case WalletType.ethereum:
         return Uri.https(uriRaw, '');
+      case WalletType.bitcoinCash:
+        return createUriFromElectrumAddress(uriRaw);
       case WalletType.nano:
       case WalletType.banano:
         if (isSSL) {
@@ -138,6 +140,8 @@ class Node extends HiveObject with Keyable {
           return requestMoneroNode();
         case WalletType.ethereum:
           return requestElectrumServer();
+        case WalletType.bitcoinCash:
+          return requestElectrumServer();
         case WalletType.nano:
         case WalletType.banano:
           return requestNanoNode();
diff --git a/lib/entities/unspent_transaction_output.dart b/cw_core/lib/unspent_transaction_output.dart
similarity index 100%
rename from lib/entities/unspent_transaction_output.dart
rename to cw_core/lib/unspent_transaction_output.dart
diff --git a/cw_core/lib/wallet_type.dart b/cw_core/lib/wallet_type.dart
index 0125facaf6..debf92e112 100644
--- a/cw_core/lib/wallet_type.dart
+++ b/cw_core/lib/wallet_type.dart
@@ -10,6 +10,7 @@ const walletTypes = [
   WalletType.litecoin,
   WalletType.haven,
   WalletType.ethereum,
+  WalletType.bitcoinCash,
   WalletType.nano,
   WalletType.banano,
 ];
@@ -39,6 +40,10 @@ enum WalletType {
 
   @HiveField(7)
   banano,
+
+  @HiveField(8)
+  bitcoinCash,
+
 }
 
 int serializeToInt(WalletType type) {
@@ -57,6 +62,8 @@ int serializeToInt(WalletType type) {
       return 5;
     case WalletType.banano:
       return 6;
+    case WalletType.bitcoinCash:
+      return 7;
     default:
       return -1;
   }
@@ -78,6 +85,8 @@ WalletType deserializeFromInt(int raw) {
       return WalletType.nano;
     case 6:
       return WalletType.banano;
+    case 7:
+      return WalletType.bitcoinCash;
     default:
       throw Exception('Unexpected token: $raw for WalletType deserializeFromInt');
   }
@@ -95,6 +104,8 @@ String walletTypeToString(WalletType type) {
       return 'Haven';
     case WalletType.ethereum:
       return 'Ethereum';
+    case WalletType.bitcoinCash:
+      return 'Bitcoin Cash';
     case WalletType.nano:
       return 'Nano';
     case WalletType.banano:
@@ -116,6 +127,8 @@ String walletTypeToDisplayName(WalletType type) {
       return 'Haven (XHV)';
     case WalletType.ethereum:
       return 'Ethereum (ETH)';
+    case WalletType.bitcoinCash:
+      return 'Bitcoin Cash (BCH)';
     case WalletType.nano:
       return 'Nano (XNO)';
     case WalletType.banano:
@@ -137,6 +150,8 @@ CryptoCurrency walletTypeToCryptoCurrency(WalletType type) {
       return CryptoCurrency.xhv;
     case WalletType.ethereum:
       return CryptoCurrency.eth;
+    case WalletType.bitcoinCash:
+      return CryptoCurrency.bch;
     case WalletType.nano:
       return CryptoCurrency.nano;
     case WalletType.banano:
diff --git a/lib/bitcoin/cw_bitcoin.dart b/lib/bitcoin/cw_bitcoin.dart
index 3534589371..dd713fd154 100644
--- a/lib/bitcoin/cw_bitcoin.dart
+++ b/lib/bitcoin/cw_bitcoin.dart
@@ -44,6 +44,7 @@ class CWBitcoin extends Bitcoin {
 	List<TransactionPriority> getTransactionPriorities() 
 		=> BitcoinTransactionPriority.all;
 
+	@override
 	List<TransactionPriority> getLitecoinTransactionPriorities()
 		=> LitecoinTransactionPriority.all;
 
@@ -121,16 +122,9 @@ class CWBitcoin extends Bitcoin {
     => (priority as BitcoinTransactionPriority).labelWithRate(rate);
 
 	@override
-	List<Unspent> getUnspents(Object wallet) {
+	List<BitcoinUnspent> getUnspents(Object wallet) {
 		final bitcoinWallet = wallet as ElectrumWallet;
-		return bitcoinWallet.unspentCoins
-			.map((BitcoinUnspent bitcoinUnspent) => Unspent(
-				bitcoinUnspent.address.address,
-				bitcoinUnspent.hash,
-				bitcoinUnspent.value,
-				bitcoinUnspent.vout,
-				null))
-			.toList();
+		return bitcoinWallet.unspentCoins;
 	}
 
 	void updateUnspents(Object wallet) async {
diff --git a/lib/bitcoin_cash/cw_bitcoin_cash.dart b/lib/bitcoin_cash/cw_bitcoin_cash.dart
new file mode 100644
index 0000000000..7dbb8614fe
--- /dev/null
+++ b/lib/bitcoin_cash/cw_bitcoin_cash.dart
@@ -0,0 +1,45 @@
+part of 'bitcoin_cash.dart';
+
+class CWBitcoinCash extends BitcoinCash {
+  @override
+  String getMnemonic(int? strength) => Mnemonic.generate();
+
+  @override
+  Uint8List getSeedFromMnemonic(String seed) => Mnemonic.toSeed(seed);
+
+  @override
+  String getCashAddrFormat(String address) => AddressUtils.getCashAddrFormat(address);
+
+  @override
+  WalletService createBitcoinCashWalletService(
+      Box<WalletInfo> walletInfoSource, Box<UnspentCoinsInfo> unspentCoinSource) {
+    return BitcoinCashWalletService(walletInfoSource, unspentCoinSource);
+  }
+
+  @override
+  WalletCredentials createBitcoinCashNewWalletCredentials({
+    required String name,
+    WalletInfo? walletInfo,
+  }) =>
+      BitcoinCashNewWalletCredentials(name: name, walletInfo: walletInfo);
+
+  @override
+  WalletCredentials createBitcoinCashRestoreWalletFromSeedCredentials(
+          {required String name, required String mnemonic, required String password}) =>
+      BitcoinCashRestoreWalletFromSeedCredentials(
+          name: name, mnemonic: mnemonic, password: password);
+
+  @override
+  TransactionPriority deserializeBitcoinCashTransactionPriority(int raw) =>
+      BitcoinCashTransactionPriority.deserialize(raw: raw);
+
+  @override
+  TransactionPriority getDefaultTransactionPriority() => BitcoinCashTransactionPriority.medium;
+
+  @override
+  List<TransactionPriority> getTransactionPriorities() => BitcoinCashTransactionPriority.all;
+
+  @override
+  TransactionPriority getBitcoinCashTransactionPrioritySlow() =>
+      BitcoinCashTransactionPriority.slow;
+}
diff --git a/lib/buy/onramper/onramper_buy_provider.dart b/lib/buy/onramper/onramper_buy_provider.dart
index 91309a2caf..872fcebf56 100644
--- a/lib/buy/onramper/onramper_buy_provider.dart
+++ b/lib/buy/onramper/onramper_buy_provider.dart
@@ -27,6 +27,8 @@ class OnRamperBuyProvider {
         return "LTC_LITECOIN";
       case CryptoCurrency.xmr:
         return "XMR_MONERO";
+      case CryptoCurrency.bch:
+        return "BCH_BITCOINCASH";
       case CryptoCurrency.nano:
         return "XNO_NANO";
       default:
diff --git a/lib/core/address_validator.dart b/lib/core/address_validator.dart
index d039a40a70..fcb881943c 100644
--- a/lib/core/address_validator.dart
+++ b/lib/core/address_validator.dart
@@ -88,7 +88,9 @@ class AddressValidator extends TextValidator {
       case CryptoCurrency.dai:
       case CryptoCurrency.dash:
       case CryptoCurrency.eos:
+      return '[0-9a-zA-Z]';
       case CryptoCurrency.bch:
+        return '^(?!bitcoincash:)[0-9a-zA-Z]*\$|^(?!bitcoincash:)q[0-9a-zA-Z]{41}\$|^(?!bitcoincash:)q[0-9a-zA-Z]{42}\$|^bitcoincash:q[0-9a-zA-Z]{41}\$|^bitcoincash:q[0-9a-zA-Z]{42}\$';
       case CryptoCurrency.bnb:
         return '[0-9a-zA-Z]';
       case CryptoCurrency.ltc:
@@ -172,7 +174,9 @@ class AddressValidator extends TextValidator {
       case CryptoCurrency.steth:
       case CryptoCurrency.shib:
       case CryptoCurrency.avaxc:
+        return [42];
       case CryptoCurrency.bch:
+        return [42, 43, 44, 54, 55];
       case CryptoCurrency.bnb:
         return [42];
       case CryptoCurrency.ltc:
@@ -271,6 +275,11 @@ class AddressValidator extends TextValidator {
         return 'nano_[0-9a-zA-Z]{60}';
       case CryptoCurrency.banano:
         return 'ban_[0-9a-zA-Z]{60}';
+      case CryptoCurrency.bch:
+        return 'bitcoincash:q[0-9a-zA-Z]{41}([^0-9a-zA-Z]|\$)'
+            '|bitcoincash:q[0-9a-zA-Z]{42}([^0-9a-zA-Z]|\$)'
+            '|([^0-9a-zA-Z]|^)q[0-9a-zA-Z]{41}([^0-9a-zA-Z]|\$)'
+            '|([^0-9a-zA-Z]|^)q[0-9a-zA-Z]{42}([^0-9a-zA-Z]|\$)';
       default:
         return null;
     }
diff --git a/lib/core/seed_validator.dart b/lib/core/seed_validator.dart
index 1c6e7cd202..95ccf89ac1 100644
--- a/lib/core/seed_validator.dart
+++ b/lib/core/seed_validator.dart
@@ -29,6 +29,8 @@ class SeedValidator extends Validator<MnemonicItem> {
         return haven!.getMoneroWordList(language);
       case WalletType.ethereum:
         return ethereum!.getEthereumWordList(language);
+      case WalletType.bitcoinCash:
+        return getBitcoinWordList(language);
       case WalletType.nano:
       case WalletType.banano:
         return nano!.getNanoWordList(language);
diff --git a/lib/di.dart b/lib/di.dart
index b871e6a6b9..1576c378b8 100644
--- a/lib/di.dart
+++ b/lib/di.dart
@@ -2,6 +2,7 @@ import 'package:cake_wallet/anonpay/anonpay_api.dart';
 import 'package:cake_wallet/anonpay/anonpay_info_base.dart';
 import 'package:cake_wallet/anonpay/anonpay_invoice_info.dart';
 import 'package:cake_wallet/buy/onramper/onramper_buy_provider.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/buy/payfura/payfura_buy_provider.dart';
 import 'package:cake_wallet/core/wallet_connect/wallet_connect_key_service.dart';
 import 'package:cake_wallet/core/wallet_connect/wc_bottom_sheet_service.dart';
@@ -820,6 +821,8 @@ Future<void> setup({
         return bitcoin!.createLitecoinWalletService(_walletInfoSource, _unspentCoinsInfoSource);
       case WalletType.ethereum:
         return ethereum!.createEthereumWalletService(_walletInfoSource);
+      case WalletType.bitcoinCash:
+        return bitcoinCash!.createBitcoinCashWalletService(_walletInfoSource, _unspentCoinsInfoSource!);
       case WalletType.nano:
         return nano!.createNanoWalletService(_walletInfoSource);
       default:
diff --git a/lib/entities/default_settings_migration.dart b/lib/entities/default_settings_migration.dart
index 690a5e9eb8..94283302d4 100644
--- a/lib/entities/default_settings_migration.dart
+++ b/lib/entities/default_settings_migration.dart
@@ -26,6 +26,7 @@ const cakeWalletBitcoinElectrumUri = 'electrum.cakewallet.com:50002';
 const cakeWalletLitecoinElectrumUri = 'ltc-electrum.cakewallet.com:50002';
 const havenDefaultNodeUri = 'nodes.havenprotocol.org:443';
 const ethereumDefaultNodeUri = 'ethereum.publicnode.com';
+const cakeWalletBitcoinCashDefaultNodeUri = 'bitcoincash.stackwallet.com:50002';
 const nanoDefaultNodeUri = 'rpc.nano.to';
 const nanoDefaultPowNodeUri = 'rpc.nano.to';
 
@@ -81,7 +82,10 @@ Future<void> defaultSettingsMigration(
               sharedPreferences: sharedPreferences, nodes: nodes);
           await changeLitecoinCurrentElectrumServerToDefault(
               sharedPreferences: sharedPreferences, nodes: nodes);
-          await changeHavenCurrentNodeToDefault(sharedPreferences: sharedPreferences, nodes: nodes);
+          await changeHavenCurrentNodeToDefault(
+              sharedPreferences: sharedPreferences, nodes: nodes);
+          await changeBitcoinCashCurrentNodeToDefault(
+              sharedPreferences: sharedPreferences, nodes: nodes);
 
           break;
         case 2:
@@ -166,6 +170,11 @@ Future<void> defaultSettingsMigration(
           await changeNanoCurrentPowNodeToDefault(
               sharedPreferences: sharedPreferences, nodes: powNodes);
           break;
+        case 23:
+          await addBitcoinCashElectrumServerList(nodes: nodes);
+          await changeBitcoinCurrentElectrumServerToDefault(
+              sharedPreferences: sharedPreferences, nodes: nodes);
+          break;
 
         default:
           break;
@@ -323,6 +332,12 @@ Node? getNanoDefaultPowNode({required Box<Node> nodes}) {
       nodes.values.firstWhereOrNull((node) => (node.type == WalletType.nano));
 }
 
+Node? getBitcoinCashDefaultElectrumServer({required Box<Node> nodes}) {
+  return nodes.values.firstWhereOrNull(
+          (Node node) => node.uriRaw == cakeWalletBitcoinCashDefaultNodeUri)
+      ?? nodes.values.firstWhereOrNull((node) => node.type == WalletType.bitcoinCash);
+}
+
 Node getMoneroDefaultNode({required Box<Node> nodes}) {
   final timeZone = DateTime.now().timeZoneOffset.inHours;
   var nodeUri = '';
@@ -358,6 +373,15 @@ Future<void> changeLitecoinCurrentElectrumServerToDefault(
   await sharedPreferences.setInt(PreferencesKey.currentLitecoinElectrumSererIdKey, serverId);
 }
 
+Future<void> changeBitcoinCashCurrentNodeToDefault(
+    {required SharedPreferences sharedPreferences,
+      required Box<Node> nodes}) async {
+  final server = getBitcoinCashDefaultElectrumServer(nodes: nodes);
+  final serverId = server?.key as int ?? 0;
+
+  await sharedPreferences.setInt(PreferencesKey.currentBitcoinCashNodeIdKey, serverId);
+}
+
 Future<void> changeHavenCurrentNodeToDefault(
     {required SharedPreferences sharedPreferences, required Box<Node> nodes}) async {
   final node = getHavenDefaultNode(nodes: nodes);
@@ -411,6 +435,15 @@ Future<void> addLitecoinElectrumServerList({required Box<Node> nodes}) async {
   }
 }
 
+Future<void> addBitcoinCashElectrumServerList({required Box<Node> nodes}) async {
+  final serverList = await loadBitcoinCashElectrumServerList();
+  for (var node in serverList) {
+    if (nodes.values.firstWhereOrNull((element) => element.uriRaw == node.uriRaw) == null) {
+      await nodes.add(node);
+    }
+  }
+}
+
 Future<void> addHavenNodeList({required Box<Node> nodes}) async {
   final nodeList = await loadDefaultHavenNodes();
   for (var node in nodeList) {
@@ -497,27 +530,34 @@ Future<void> checkCurrentNodes(
   final currentMoneroNodeId = sharedPreferences.getInt(PreferencesKey.currentNodeIdKey);
   final currentBitcoinElectrumSeverId =
       sharedPreferences.getInt(PreferencesKey.currentBitcoinElectrumSererIdKey);
-  final currentLitecoinElectrumSeverId =
-      sharedPreferences.getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
-  final currentHavenNodeId = sharedPreferences.getInt(PreferencesKey.currentHavenNodeIdKey);
-  final currentEthereumNodeId = sharedPreferences.getInt(PreferencesKey.currentEthereumNodeIdKey);
-  final currentNanoNodeId = sharedPreferences.getInt(PreferencesKey.currentNanoNodeIdKey);
-  final currentNanoPowNodeId = sharedPreferences.getInt(PreferencesKey.currentNanoPowNodeIdKey);
-  final currentMoneroNode =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentMoneroNodeId);
-  final currentBitcoinElectrumServer =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentBitcoinElectrumSeverId);
-  final currentLitecoinElectrumServer =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentLitecoinElectrumSeverId);
-  final currentHavenNodeServer =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentHavenNodeId);
-  final currentEthereumNodeServer =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentEthereumNodeId);
+  final currentLitecoinElectrumSeverId = sharedPreferences
+      .getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
+  final currentHavenNodeId = sharedPreferences
+      .getInt(PreferencesKey.currentHavenNodeIdKey);
+  final currentEthereumNodeId = sharedPreferences
+      .getInt(PreferencesKey.currentEthereumNodeIdKey);
+  final currentNanoNodeId = sharedPreferences
+      .getInt(PreferencesKey.currentNanoNodeIdKey);
+  final currentNanoPowNodeId = sharedPreferences
+      .getInt(PreferencesKey.currentNanoPowNodeIdKey);
+  final currentBitcoinCashNodeId = sharedPreferences
+      .getInt(PreferencesKey.currentBitcoinCashNodeIdKey);
+  final currentMoneroNode = nodeSource.values.firstWhereOrNull(
+      (node) => node.key == currentMoneroNodeId);
+  final currentBitcoinElectrumServer = nodeSource.values.firstWhereOrNull(
+      (node) => node.key == currentBitcoinElectrumSeverId);
+  final currentLitecoinElectrumServer = nodeSource.values.firstWhereOrNull(
+      (node) => node.key == currentLitecoinElectrumSeverId);
+  final currentHavenNodeServer = nodeSource.values.firstWhereOrNull(
+      (node) => node.key == currentHavenNodeId);
+  final currentEthereumNodeServer = nodeSource.values.firstWhereOrNull(
+      (node) => node.key == currentEthereumNodeId);
   final currentNanoNodeServer =
-      nodeSource.values.firstWhereOrNull((node) => node.key == currentNanoNodeId);
+  nodeSource.values.firstWhereOrNull((node) => node.key == currentNanoNodeId);
   final currentNanoPowNodeServer =
-      powNodeSource.values.firstWhereOrNull((node) => node.key == currentNanoPowNodeId);
-
+  powNodeSource.values.firstWhereOrNull((node) => node.key == currentNanoPowNodeId);
+  final currentBitcoinCashNodeServer = nodeSource.values.firstWhereOrNull(
+          (node) => node.key == currentBitcoinCashNodeId);
   if (currentMoneroNode == null) {
     final newCakeWalletNode = Node(uri: newCakeWalletMoneroUri, type: WalletType.monero);
     await nodeSource.add(newCakeWalletNode);
@@ -565,6 +605,13 @@ Future<void> checkCurrentNodes(
     }
     await sharedPreferences.setInt(PreferencesKey.currentNanoPowNodeIdKey, node.key as int);
   }
+
+  if (currentBitcoinCashNodeServer == null) {
+    final node = Node(uri: cakeWalletBitcoinCashDefaultNodeUri, type: WalletType.bitcoinCash);
+    await nodeSource.add(node);
+    await sharedPreferences.setInt(
+        PreferencesKey.currentBitcoinCashNodeIdKey, node.key as int);
+  }
 }
 
 Future<void> resetBitcoinElectrumServer(
diff --git a/lib/entities/main_actions.dart b/lib/entities/main_actions.dart
index 48beab32b1..d2c67ef95a 100644
--- a/lib/entities/main_actions.dart
+++ b/lib/entities/main_actions.dart
@@ -52,6 +52,7 @@ class MainActions {
         case WalletType.bitcoin:
         case WalletType.litecoin:
         case WalletType.ethereum:
+        case WalletType.bitcoinCash:
         case WalletType.nano:
         case WalletType.banano:
           switch (defaultBuyProvider) {
@@ -123,6 +124,7 @@ class MainActions {
         case WalletType.bitcoin:
         case WalletType.litecoin:
         case WalletType.ethereum:
+        case WalletType.bitcoinCash:
           if (viewModel.isEnabledSellAction) {
             final moonPaySellProvider = MoonPaySellProvider();
             final uri = await moonPaySellProvider.requestUrl(
diff --git a/lib/entities/node_list.dart b/lib/entities/node_list.dart
index 0641c0846b..53facf18c2 100644
--- a/lib/entities/node_list.dart
+++ b/lib/entities/node_list.dart
@@ -84,6 +84,23 @@ Future<List<Node>> loadDefaultEthereumNodes() async {
   return nodes;
 }
 
+Future<List<Node>> loadBitcoinCashElectrumServerList() async {
+  final serverListRaw =
+  await rootBundle.loadString('assets/bitcoin_cash_electrum_server_list.yml');
+  final loadedServerList = loadYaml(serverListRaw) as YamlList;
+  final serverList = <Node>[];
+
+  for (final raw in loadedServerList) {
+    if (raw is Map) {
+      final node = Node.fromMap(Map<String, Object>.from(raw));
+      node.type = WalletType.bitcoinCash;
+      serverList.add(node);
+    }
+  }
+
+  return serverList;
+}
+
 Future<List<Node>> loadDefaultNanoNodes() async {
   final nodesRaw = await rootBundle.loadString('assets/nano_node_list.yml');
   final loadedNodes = loadYaml(nodesRaw) as YamlList;
@@ -116,10 +133,11 @@ Future<List<Node>> loadDefaultNanoPowNodes() async {
   return nodes;
 }
 
-Future resetToDefault(Box<Node> nodeSource) async {
+Future<void> resetToDefault(Box<Node> nodeSource) async {
   final moneroNodes = await loadDefaultNodes();
   final bitcoinElectrumServerList = await loadBitcoinElectrumServerList();
   final litecoinElectrumServerList = await loadLitecoinElectrumServerList();
+  final bitcoinCashElectrumServerList = await loadBitcoinCashElectrumServerList();
   final havenNodes = await loadDefaultHavenNodes();
   final ethereumNodes = await loadDefaultEthereumNodes();
   final nanoNodes = await loadDefaultNanoNodes();
@@ -129,13 +147,14 @@ Future resetToDefault(Box<Node> nodeSource) async {
       litecoinElectrumServerList +
       havenNodes +
       ethereumNodes +
+      bitcoinCashElectrumServerList +
       nanoNodes;
 
   await nodeSource.clear();
   await nodeSource.addAll(nodes);
 }
 
-Future resetPowToDefault(Box<Node> powNodeSource) async {
+Future<void> resetPowToDefault(Box<Node> powNodeSource) async {
   final nanoPowNodes = await loadDefaultNanoPowNodes();
   final nodes = nanoPowNodes;
   await powNodeSource.clear();
diff --git a/lib/entities/preferences_key.dart b/lib/entities/preferences_key.dart
index ce2db7cdfd..cbd12d777a 100644
--- a/lib/entities/preferences_key.dart
+++ b/lib/entities/preferences_key.dart
@@ -11,6 +11,7 @@ class PreferencesKey {
   static const currentBananoNodeIdKey = 'current_node_id_banano';
   static const currentBananoPowNodeIdKey = 'current_node_id_banano_pow';
   static const currentFiatCurrencyKey = 'current_fiat_currency';
+  static const currentBitcoinCashNodeIdKey = 'current_node_id_bch';
   static const currentTransactionPriorityKeyLegacy = 'current_fee_priority';
   static const currentBalanceDisplayModeKey = 'current_balance_display_mode';
   static const shouldSaveRecipientAddressKey = 'save_recipient_address';
@@ -36,6 +37,7 @@ class PreferencesKey {
   static const havenTransactionPriority = 'current_fee_priority_haven';
   static const litecoinTransactionPriority = 'current_fee_priority_litecoin';
   static const ethereumTransactionPriority = 'current_fee_priority_ethereum';
+  static const bitcoinCashTransactionPriority = 'current_fee_priority_bitcoin_cash';
   static const shouldShowReceiveWarning = 'should_show_receive_warning';
   static const shouldShowYatPopup = 'should_show_yat_popup';
   static const moneroWalletPasswordUpdateV1Base = 'monero_wallet_update_v1';
diff --git a/lib/entities/priority_for_wallet_type.dart b/lib/entities/priority_for_wallet_type.dart
index 378cf0ea23..bf6f8157dd 100644
--- a/lib/entities/priority_for_wallet_type.dart
+++ b/lib/entities/priority_for_wallet_type.dart
@@ -1,4 +1,5 @@
 import 'package:cake_wallet/bitcoin/bitcoin.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/ethereum/ethereum.dart';
 import 'package:cake_wallet/haven/haven.dart';
 import 'package:cake_wallet/monero/monero.dart';
@@ -17,6 +18,8 @@ List<TransactionPriority> priorityForWalletType(WalletType type) {
       return haven!.getTransactionPriorities();
     case WalletType.ethereum:
       return ethereum!.getTransactionPriorities();
+    case WalletType.bitcoinCash:
+      return bitcoinCash!.getTransactionPriorities();
     // no such thing for nano/banano:
     case WalletType.nano:
     case WalletType.banano:
diff --git a/lib/ethereum/cw_ethereum.dart b/lib/ethereum/cw_ethereum.dart
index 602db2d49c..abafc2f267 100644
--- a/lib/ethereum/cw_ethereum.dart
+++ b/lib/ethereum/cw_ethereum.dart
@@ -50,6 +50,9 @@ class CWEthereum extends Ethereum {
   @override
   TransactionPriority getDefaultTransactionPriority() => EthereumTransactionPriority.medium;
 
+  @override
+  TransactionPriority getEthereumTransactionPrioritySlow() => EthereumTransactionPriority.slow;
+
   @override
   List<TransactionPriority> getTransactionPriorities() => EthereumTransactionPriority.all;
 
diff --git a/lib/main.dart b/lib/main.dart
index c50c16f61c..2d76196c3c 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -159,7 +159,7 @@ Future<void> initializeAppConfigs() async {
       transactionDescriptions: transactionDescriptions,
       secureStorage: secureStorage,
       anonpayInvoiceInfo: anonpayInvoiceInfo,
-      initialMigrationVersion: 22);
+      initialMigrationVersion: 23);
   }
 
 Future<void> initialSetup(
diff --git a/lib/src/screens/dashboard/desktop_widgets/desktop_wallet_selection_dropdown.dart b/lib/src/screens/dashboard/desktop_widgets/desktop_wallet_selection_dropdown.dart
index b22acdc8bc..1aa7f6c4a0 100644
--- a/lib/src/screens/dashboard/desktop_widgets/desktop_wallet_selection_dropdown.dart
+++ b/lib/src/screens/dashboard/desktop_widgets/desktop_wallet_selection_dropdown.dart
@@ -33,6 +33,7 @@ class _DesktopWalletSelectionDropDownState extends State<DesktopWalletSelectionD
   final litecoinIcon = Image.asset('assets/images/litecoin_icon.png', height: 24, width: 24);
   final havenIcon = Image.asset('assets/images/haven_logo.png', height: 24, width: 24);
   final ethereumIcon = Image.asset('assets/images/eth_icon.png', height: 24, width: 24);
+  final bitcoinCashIcon = Image.asset('assets/images/bch_icon.png', height: 24, width: 24);
   final nanoIcon = Image.asset('assets/images/nano_icon.png', height: 24, width: 24);
   final bananoIcon = Image.asset('assets/images/nano_icon.png', height: 24, width: 24);
   final nonWalletTypeIcon = Image.asset('assets/images/close.png', height: 24, width: 24);
@@ -143,6 +144,8 @@ class _DesktopWalletSelectionDropDownState extends State<DesktopWalletSelectionD
         return havenIcon;
       case WalletType.ethereum:
         return ethereumIcon;
+      case WalletType.bitcoinCash:
+        return bitcoinCashIcon;
       case WalletType.nano:
         return nanoIcon;
       case WalletType.banano:
diff --git a/lib/src/screens/dashboard/widgets/menu_widget.dart b/lib/src/screens/dashboard/widgets/menu_widget.dart
index d9e4d0f7c8..bf001eb325 100644
--- a/lib/src/screens/dashboard/widgets/menu_widget.dart
+++ b/lib/src/screens/dashboard/widgets/menu_widget.dart
@@ -31,7 +31,8 @@ class MenuWidgetState extends State<MenuWidget> {
       this.havenIcon = Image.asset('assets/images/haven_menu.png'),
       this.ethereumIcon = Image.asset('assets/images/eth_icon.png'),
       this.nanoIcon = Image.asset('assets/images/nano_icon.png'),
-      this.bananoIcon = Image.asset('assets/images/nano_icon.png');
+      this.bananoIcon = Image.asset('assets/images/nano_icon.png'),
+      this.bitcoinCashIcon = Image.asset('assets/images/bch_icon.png');
 
 
   final largeScreen = 731;
@@ -50,10 +51,10 @@ class MenuWidgetState extends State<MenuWidget> {
   Image litecoinIcon;
   Image havenIcon;
   Image ethereumIcon;
+  Image bitcoinCashIcon;
   Image nanoIcon;
   Image bananoIcon;
 
-
   @override
   void initState() {
     menuWidth = 0;
@@ -212,6 +213,8 @@ class MenuWidgetState extends State<MenuWidget> {
         return havenIcon;
       case WalletType.ethereum:
         return ethereumIcon;
+      case WalletType.bitcoinCash:
+        return bitcoinCashIcon;
       case WalletType.nano:
         return nanoIcon;
       case WalletType.banano:
diff --git a/lib/src/screens/seed/pre_seed_page.dart b/lib/src/screens/seed/pre_seed_page.dart
index a73e7bbff7..7e6bfb1ded 100644
--- a/lib/src/screens/seed/pre_seed_page.dart
+++ b/lib/src/screens/seed/pre_seed_page.dart
@@ -73,6 +73,7 @@ class PreSeedPage extends BasePage {
       case WalletType.monero:
         return 25;
       case WalletType.ethereum:
+      case WalletType.bitcoinCash:
         return 12;
       default:
         return 24;
diff --git a/lib/src/screens/unspent_coins/unspent_coins_list_page.dart b/lib/src/screens/unspent_coins/unspent_coins_list_page.dart
index 1c1fbfa5d4..1a173f62a2 100644
--- a/lib/src/screens/unspent_coins/unspent_coins_list_page.dart
+++ b/lib/src/screens/unspent_coins/unspent_coins_list_page.dart
@@ -1,8 +1,10 @@
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/routes.dart';
 import 'package:cake_wallet/src/screens/unspent_coins/widgets/unspent_coins_list_item.dart';
 import 'package:cake_wallet/src/widgets/alert_with_one_action.dart';
 import 'package:cake_wallet/utils/show_pop_up.dart';
 import 'package:cake_wallet/view_model/unspent_coins/unspent_coins_list_view_model.dart';
+import 'package:cw_core/wallet_type.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter/cupertino.dart';
 import 'package:cake_wallet/src/screens/base_page.dart';
@@ -79,6 +81,9 @@ class UnspentCoinsListFormState extends State<UnspentCoinsListForm> {
                 itemBuilder: (_, int index) {
                   return Observer(builder: (_) {
                     final item = unspentCoinsListViewModel.items[index];
+                    final address = unspentCoinsListViewModel.wallet.type == WalletType.bitcoinCash
+                        ? bitcoinCash!.getCashAddrFormat(item.address)
+                        : item.address;
 
                     return GestureDetector(
                         onTap: () =>
@@ -88,7 +93,7 @@ class UnspentCoinsListFormState extends State<UnspentCoinsListForm> {
                         child: UnspentCoinsListItem(
                             note: item.note,
                             amount: item.amount,
-                            address: item.address,
+                            address: address,
                             isSending: item.isSending,
                             isFrozen: item.isFrozen,
                             onCheckBoxTap: item.isFrozen
diff --git a/lib/src/screens/wallet_list/wallet_list_page.dart b/lib/src/screens/wallet_list/wallet_list_page.dart
index a0b44f3751..11b3944606 100644
--- a/lib/src/screens/wallet_list/wallet_list_page.dart
+++ b/lib/src/screens/wallet_list/wallet_list_page.dart
@@ -48,6 +48,7 @@ class WalletListBodyState extends State<WalletListBody> {
   final nonWalletTypeIcon = Image.asset('assets/images/close.png', height: 24, width: 24);
   final havenIcon = Image.asset('assets/images/haven_logo.png', height: 24, width: 24);
   final ethereumIcon = Image.asset('assets/images/eth_icon.png', height: 24, width: 24);
+  final bitcoinCashIcon = Image.asset('assets/images/bch_icon.png', height: 24, width: 24);
   final nanoIcon = Image.asset('assets/images/nano_icon.png', height: 24, width: 24);
   final scrollController = ScrollController();
   final double tileHeight = 60;
@@ -243,6 +244,8 @@ class WalletListBodyState extends State<WalletListBody> {
         return havenIcon;
       case WalletType.ethereum:
         return ethereumIcon;
+      case WalletType.bitcoinCash:
+        return bitcoinCashIcon;
       case WalletType.nano:
         return nanoIcon;
       default:
diff --git a/lib/store/settings_store.dart b/lib/store/settings_store.dart
index 939d724d60..a2e2570e05 100644
--- a/lib/store/settings_store.dart
+++ b/lib/store/settings_store.dart
@@ -1,6 +1,7 @@
 import 'dart:io';
 
 import 'package:cake_wallet/bitcoin/bitcoin.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/entities/auto_generate_subaddress_status.dart';
 import 'package:cake_wallet/entities/buy_provider_types.dart';
 import 'package:cake_wallet/entities/cake_2fa_preset_options.dart';
@@ -85,7 +86,8 @@ abstract class SettingsStoreBase with Store {
       TransactionPriority? initialMoneroTransactionPriority,
       TransactionPriority? initialHavenTransactionPriority,
       TransactionPriority? initialLitecoinTransactionPriority,
-      TransactionPriority? initialEthereumTransactionPriority})
+      TransactionPriority? initialEthereumTransactionPriority,
+      TransactionPriority? initialBitcoinCashTransactionPriority})
       : nodes = ObservableMap<WalletType, Node>.of(nodes),
         powNodes = ObservableMap<WalletType, Node>.of(powNodes),
         _sharedPreferences = sharedPreferences,
@@ -146,6 +148,10 @@ abstract class SettingsStoreBase with Store {
       priority[WalletType.ethereum] = initialEthereumTransactionPriority;
     }
 
+    if (initialBitcoinCashTransactionPriority != null) {
+      priority[WalletType.bitcoinCash] = initialBitcoinCashTransactionPriority;
+    }
+
     reaction(
         (_) => fiatCurrency,
         (FiatCurrency fiatCurrency) => sharedPreferences.setString(
@@ -174,6 +180,9 @@ abstract class SettingsStoreBase with Store {
         case WalletType.ethereum:
           key = PreferencesKey.ethereumTransactionPriority;
           break;
+        case WalletType.bitcoinCash:
+          key = PreferencesKey.bitcoinCashTransactionPriority;
+          break;
         default:
           key = null;
       }
@@ -526,12 +535,13 @@ abstract class SettingsStoreBase with Store {
     TransactionPriority? moneroTransactionPriority = monero?.deserializeMoneroTransactionPriority(
         raw: sharedPreferences.getInt(PreferencesKey.moneroTransactionPriority)!);
     TransactionPriority? bitcoinTransactionPriority =
-        bitcoin?.deserializeBitcoinTransactionPriority(
-            sharedPreferences.getInt(PreferencesKey.bitcoinTransactionPriority)!);
+    bitcoin?.deserializeBitcoinTransactionPriority(
+        sharedPreferences.getInt(PreferencesKey.bitcoinTransactionPriority)!);
 
     TransactionPriority? havenTransactionPriority;
     TransactionPriority? litecoinTransactionPriority;
     TransactionPriority? ethereumTransactionPriority;
+    TransactionPriority? bitcoinCashTransactionPriority;
 
     if (sharedPreferences.getInt(PreferencesKey.havenTransactionPriority) != null) {
       havenTransactionPriority = monero?.deserializeMoneroTransactionPriority(
@@ -545,12 +555,17 @@ abstract class SettingsStoreBase with Store {
       ethereumTransactionPriority = bitcoin?.deserializeLitecoinTransactionPriority(
           sharedPreferences.getInt(PreferencesKey.ethereumTransactionPriority)!);
     }
+    if (sharedPreferences.getInt(PreferencesKey.bitcoinCashTransactionPriority) != null) {
+      bitcoinCashTransactionPriority = bitcoinCash?.deserializeBitcoinCashTransactionPriority(
+          sharedPreferences.getInt(PreferencesKey.bitcoinCashTransactionPriority)!);
+    }
 
     moneroTransactionPriority ??= monero?.getDefaultTransactionPriority();
     bitcoinTransactionPriority ??= bitcoin?.getMediumTransactionPriority();
     havenTransactionPriority ??= monero?.getDefaultTransactionPriority();
     litecoinTransactionPriority ??= bitcoin?.getLitecoinTransactionPriorityMedium();
     ethereumTransactionPriority ??= ethereum?.getDefaultTransactionPriority();
+    bitcoinCashTransactionPriority ??= bitcoinCash?.getDefaultTransactionPriority();
 
     final currentBalanceDisplayMode = BalanceDisplayMode.deserialize(
         raw: sharedPreferences.getInt(PreferencesKey.currentBalanceDisplayModeKey)!);
@@ -560,7 +575,8 @@ abstract class SettingsStoreBase with Store {
     final isAppSecure = sharedPreferences.getBool(PreferencesKey.isAppSecureKey) ?? false;
     final disableBuy = sharedPreferences.getBool(PreferencesKey.disableBuyKey) ?? false;
     final disableSell = sharedPreferences.getBool(PreferencesKey.disableSellKey) ?? false;
-    final defaultBuyProvider = BuyProviderType.values[sharedPreferences.getInt(PreferencesKey.defaultBuyProvider) ?? 0];
+    final defaultBuyProvider = BuyProviderType.values[sharedPreferences.getInt(
+        PreferencesKey.defaultBuyProvider) ?? 0];
     final currentFiatApiMode = FiatApiMode.deserialize(
         raw: sharedPreferences.getInt(PreferencesKey.currentFiatApiModeKey) ??
             FiatApiMode.enabled.raw);
@@ -579,7 +595,7 @@ abstract class SettingsStoreBase with Store {
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForSendsToInternalWallets) ??
             false;
     final shouldRequireTOTP2FAForExchangesToInternalWallets = sharedPreferences
-            .getBool(PreferencesKey.shouldRequireTOTP2FAForExchangesToInternalWallets) ??
+        .getBool(PreferencesKey.shouldRequireTOTP2FAForExchangesToInternalWallets) ??
         false;
     final shouldRequireTOTP2FAForAddingContacts =
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForAddingContacts) ?? false;
@@ -587,7 +603,7 @@ abstract class SettingsStoreBase with Store {
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForCreatingNewWallets) ??
             false;
     final shouldRequireTOTP2FAForAllSecurityAndBackupSettings = sharedPreferences
-            .getBool(PreferencesKey.shouldRequireTOTP2FAForAllSecurityAndBackupSettings) ??
+        .getBool(PreferencesKey.shouldRequireTOTP2FAForAllSecurityAndBackupSettings) ??
         false;
     final useTOTP2FA = sharedPreferences.getBool(PreferencesKey.useTOTP2FA) ?? false;
     final totpSecretKey = sharedPreferences.getString(PreferencesKey.totpSecretKey) ?? '';
@@ -612,7 +628,7 @@ abstract class SettingsStoreBase with Store {
         ? PinCodeRequiredDuration.deserialize(raw: timeOutDuration)
         : defaultPinCodeTimeOutDuration;
     final sortBalanceBy =
-        SortBalanceBy.values[sharedPreferences.getInt(PreferencesKey.sortBalanceBy) ?? 0];
+    SortBalanceBy.values[sharedPreferences.getInt(PreferencesKey.sortBalanceBy) ?? 0];
     final pinNativeTokenAtTop =
         sharedPreferences.getBool(PreferencesKey.pinNativeTokenAtTop) ?? true;
     final useEtherscan = sharedPreferences.getBool(PreferencesKey.useEtherscan) ?? true;
@@ -626,9 +642,11 @@ abstract class SettingsStoreBase with Store {
         await LanguageService.localeDetection();
     final nodeId = sharedPreferences.getInt(PreferencesKey.currentNodeIdKey);
     final bitcoinElectrumServerId =
-        sharedPreferences.getInt(PreferencesKey.currentBitcoinElectrumSererIdKey);
+    sharedPreferences.getInt(PreferencesKey.currentBitcoinElectrumSererIdKey);
     final litecoinElectrumServerId =
-        sharedPreferences.getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
+    sharedPreferences.getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
+    final bitcoinCashElectrumServerId =
+    sharedPreferences.getInt(PreferencesKey.currentBitcoinCashNodeIdKey);
     final havenNodeId = sharedPreferences.getInt(PreferencesKey.currentHavenNodeIdKey);
     final ethereumNodeId = sharedPreferences.getInt(PreferencesKey.currentEthereumNodeIdKey);
     final nanoNodeId = sharedPreferences.getInt(PreferencesKey.currentNanoNodeIdKey);
@@ -638,13 +656,14 @@ abstract class SettingsStoreBase with Store {
     final litecoinElectrumServer = nodeSource.get(litecoinElectrumServerId);
     final havenNode = nodeSource.get(havenNodeId);
     final ethereumNode = nodeSource.get(ethereumNodeId);
+    final bitcoinCashElectrumServer = nodeSource.get(bitcoinCashElectrumServerId);
     final nanoNode = nodeSource.get(nanoNodeId);
     final nanoPowNode = powNodeSource.get(nanoPowNodeId);
     final packageInfo = await PackageInfo.fromPlatform();
     final deviceName = await _getDeviceName() ?? '';
     final shouldShowYatPopup = sharedPreferences.getBool(PreferencesKey.shouldShowYatPopup) ?? true;
     final generateSubaddresses =
-        sharedPreferences.getInt(PreferencesKey.autoGenerateSubaddressStatusKey);
+    sharedPreferences.getInt(PreferencesKey.autoGenerateSubaddressStatusKey);
 
     final autoGenerateSubaddressStatus = generateSubaddresses != null
         ? AutoGenerateSubaddressStatus.deserialize(raw: generateSubaddresses)
@@ -672,70 +691,76 @@ abstract class SettingsStoreBase with Store {
       nodes[WalletType.ethereum] = ethereumNode;
     }
 
+    if (bitcoinCashElectrumServer != null) {
+      nodes[WalletType.bitcoinCash] = bitcoinCashElectrumServer;
+    }
+
     if (nanoNode != null) {
       nodes[WalletType.nano] = nanoNode;
     }
+
     if (nanoPowNode != null) {
       powNodes[WalletType.nano] = nanoPowNode;
     }
 
-    final savedSyncMode = SyncMode.all.firstWhere((element) {
-      return element.type.index == (sharedPreferences.getInt(PreferencesKey.syncModeKey) ?? 1);
-    });
-    final savedSyncAll = sharedPreferences.getBool(PreferencesKey.syncAllKey) ?? true;
-
-    return SettingsStore(
-        sharedPreferences: sharedPreferences,
-        initialShouldShowMarketPlaceInDashboard: shouldShowMarketPlaceInDashboard,
-        nodes: nodes,
-        powNodes: powNodes,
-        appVersion: packageInfo.version,
-        deviceName: deviceName,
-        isBitcoinBuyEnabled: isBitcoinBuyEnabled,
-        initialFiatCurrency: currentFiatCurrency,
-        initialBalanceDisplayMode: currentBalanceDisplayMode,
-        initialSaveRecipientAddress: shouldSaveRecipientAddress,
-        initialAutoGenerateSubaddressStatus: autoGenerateSubaddressStatus,
-        initialAppSecure: isAppSecure,
-        initialDisableBuy: disableBuy,
-        initialDisableSell: disableSell,
-        initialDefaultBuyProvider: defaultBuyProvider,
-        initialFiatMode: currentFiatApiMode,
-        initialAllowBiometricalAuthentication: allowBiometricalAuthentication,
-        initialCake2FAPresetOptions: selectedCake2FAPreset,
-        initialUseTOTP2FA: useTOTP2FA,
-        initialTotpSecretKey: totpSecretKey,
-        initialFailedTokenTrial: tokenTrialNumber,
-        initialExchangeStatus: exchangeStatus,
-        initialTheme: savedTheme,
-        actionlistDisplayMode: actionListDisplayMode,
-        initialPinLength: pinLength,
-        pinTimeOutDuration: pinCodeTimeOutDuration,
-        initialLanguageCode: savedLanguageCode,
-        sortBalanceBy: sortBalanceBy,
-        pinNativeTokenAtTop: pinNativeTokenAtTop,
-        useEtherscan: useEtherscan,
-        initialMoneroTransactionPriority: moneroTransactionPriority,
-        initialBitcoinTransactionPriority: bitcoinTransactionPriority,
-        initialHavenTransactionPriority: havenTransactionPriority,
-        initialLitecoinTransactionPriority: litecoinTransactionPriority,
-        initialShouldRequireTOTP2FAForAccessingWallet: shouldRequireTOTP2FAForAccessingWallet,
-        initialShouldRequireTOTP2FAForSendsToContact: shouldRequireTOTP2FAForSendsToContact,
-        initialShouldRequireTOTP2FAForSendsToNonContact: shouldRequireTOTP2FAForSendsToNonContact,
-        initialShouldRequireTOTP2FAForSendsToInternalWallets:
-            shouldRequireTOTP2FAForSendsToInternalWallets,
-        initialShouldRequireTOTP2FAForExchangesToInternalWallets:
-            shouldRequireTOTP2FAForExchangesToInternalWallets,
-        initialShouldRequireTOTP2FAForAddingContacts: shouldRequireTOTP2FAForAddingContacts,
-        initialShouldRequireTOTP2FAForCreatingNewWallets: shouldRequireTOTP2FAForCreatingNewWallets,
-        initialShouldRequireTOTP2FAForAllSecurityAndBackupSettings:
-            shouldRequireTOTP2FAForAllSecurityAndBackupSettings,
-        initialEthereumTransactionPriority: ethereumTransactionPriority,
-        backgroundTasks: backgroundTasks,
-        initialSyncMode: savedSyncMode,
-        initialSyncAll: savedSyncAll,
-        shouldShowYatPopup: shouldShowYatPopup);
-  }
+      final savedSyncMode = SyncMode.all.firstWhere((element) {
+        return element.type.index == (sharedPreferences.getInt(PreferencesKey.syncModeKey) ?? 1);
+      });
+      final savedSyncAll = sharedPreferences.getBool(PreferencesKey.syncAllKey) ?? true;
+
+      return SettingsStore(
+          sharedPreferences: sharedPreferences,
+          initialShouldShowMarketPlaceInDashboard: shouldShowMarketPlaceInDashboard,
+          nodes: nodes,
+          powNodes: powNodes,
+          appVersion: packageInfo.version,
+          deviceName: deviceName,
+          isBitcoinBuyEnabled: isBitcoinBuyEnabled,
+          initialFiatCurrency: currentFiatCurrency,
+          initialBalanceDisplayMode: currentBalanceDisplayMode,
+          initialSaveRecipientAddress: shouldSaveRecipientAddress,
+          initialAutoGenerateSubaddressStatus: autoGenerateSubaddressStatus,
+          initialAppSecure: isAppSecure,
+          initialDisableBuy: disableBuy,
+          initialDisableSell: disableSell,
+          initialDefaultBuyProvider: defaultBuyProvider,
+          initialFiatMode: currentFiatApiMode,
+          initialAllowBiometricalAuthentication: allowBiometricalAuthentication,
+          initialCake2FAPresetOptions: selectedCake2FAPreset,
+          initialUseTOTP2FA: useTOTP2FA,
+          initialTotpSecretKey: totpSecretKey,
+          initialFailedTokenTrial: tokenTrialNumber,
+          initialExchangeStatus: exchangeStatus,
+          initialTheme: savedTheme,
+          actionlistDisplayMode: actionListDisplayMode,
+          initialPinLength: pinLength,
+          pinTimeOutDuration: pinCodeTimeOutDuration,
+          initialLanguageCode: savedLanguageCode,
+          sortBalanceBy: sortBalanceBy,
+          pinNativeTokenAtTop: pinNativeTokenAtTop,
+          useEtherscan: useEtherscan,
+          initialMoneroTransactionPriority: moneroTransactionPriority,
+          initialBitcoinTransactionPriority: bitcoinTransactionPriority,
+          initialHavenTransactionPriority: havenTransactionPriority,
+          initialLitecoinTransactionPriority: litecoinTransactionPriority,
+          initialBitcoinCashTransactionPriority: bitcoinCashTransactionPriority,
+          initialShouldRequireTOTP2FAForAccessingWallet: shouldRequireTOTP2FAForAccessingWallet,
+          initialShouldRequireTOTP2FAForSendsToContact: shouldRequireTOTP2FAForSendsToContact,
+          initialShouldRequireTOTP2FAForSendsToNonContact: shouldRequireTOTP2FAForSendsToNonContact,
+          initialShouldRequireTOTP2FAForSendsToInternalWallets:
+          shouldRequireTOTP2FAForSendsToInternalWallets,
+          initialShouldRequireTOTP2FAForExchangesToInternalWallets:
+          shouldRequireTOTP2FAForExchangesToInternalWallets,
+          initialShouldRequireTOTP2FAForAddingContacts: shouldRequireTOTP2FAForAddingContacts,
+          initialShouldRequireTOTP2FAForCreatingNewWallets: shouldRequireTOTP2FAForCreatingNewWallets,
+          initialShouldRequireTOTP2FAForAllSecurityAndBackupSettings:
+          shouldRequireTOTP2FAForAllSecurityAndBackupSettings,
+          initialEthereumTransactionPriority: ethereumTransactionPriority,
+          backgroundTasks: backgroundTasks,
+          initialSyncMode: savedSyncMode,
+          initialSyncAll: savedSyncAll,
+          shouldShowYatPopup: shouldShowYatPopup);
+    }
 
   Future<void> reload({required Box<Node> nodeSource}) async {
     final sharedPreferences = await getIt.getAsync<SharedPreferences>();
@@ -744,30 +769,35 @@ abstract class SettingsStoreBase with Store {
         raw: sharedPreferences.getString(PreferencesKey.currentFiatCurrencyKey)!);
 
     priority[WalletType.monero] = monero?.deserializeMoneroTransactionPriority(
-            raw: sharedPreferences.getInt(PreferencesKey.moneroTransactionPriority)!) ??
+        raw: sharedPreferences.getInt(PreferencesKey.moneroTransactionPriority)!) ??
         priority[WalletType.monero]!;
     priority[WalletType.bitcoin] = bitcoin?.deserializeBitcoinTransactionPriority(
-            sharedPreferences.getInt(PreferencesKey.moneroTransactionPriority)!) ??
+        sharedPreferences.getInt(PreferencesKey.moneroTransactionPriority)!) ??
         priority[WalletType.bitcoin]!;
 
     if (sharedPreferences.getInt(PreferencesKey.havenTransactionPriority) != null) {
       priority[WalletType.haven] = monero?.deserializeMoneroTransactionPriority(
-              raw: sharedPreferences.getInt(PreferencesKey.havenTransactionPriority)!) ??
+          raw: sharedPreferences.getInt(PreferencesKey.havenTransactionPriority)!) ??
           priority[WalletType.haven]!;
     }
     if (sharedPreferences.getInt(PreferencesKey.litecoinTransactionPriority) != null) {
       priority[WalletType.litecoin] = bitcoin?.deserializeLitecoinTransactionPriority(
-              sharedPreferences.getInt(PreferencesKey.litecoinTransactionPriority)!) ??
+          sharedPreferences.getInt(PreferencesKey.litecoinTransactionPriority)!) ??
           priority[WalletType.litecoin]!;
     }
     if (sharedPreferences.getInt(PreferencesKey.ethereumTransactionPriority) != null) {
       priority[WalletType.ethereum] = ethereum?.deserializeEthereumTransactionPriority(
-              sharedPreferences.getInt(PreferencesKey.ethereumTransactionPriority)!) ??
+          sharedPreferences.getInt(PreferencesKey.ethereumTransactionPriority)!) ??
           priority[WalletType.ethereum]!;
     }
+    if (sharedPreferences.getInt(PreferencesKey.bitcoinCashTransactionPriority) != null) {
+      priority[WalletType.bitcoinCash] = bitcoinCash?.deserializeBitcoinCashTransactionPriority(
+          sharedPreferences.getInt(PreferencesKey.bitcoinCashTransactionPriority)!) ??
+          priority[WalletType.bitcoinCash]!;
+    }
 
     final generateSubaddresses =
-        sharedPreferences.getInt(PreferencesKey.autoGenerateSubaddressStatusKey);
+    sharedPreferences.getInt(PreferencesKey.autoGenerateSubaddressStatusKey);
 
     autoGenerateSubaddressStatus = generateSubaddresses != null
         ? AutoGenerateSubaddressStatus.deserialize(raw: generateSubaddresses)
@@ -785,7 +815,8 @@ abstract class SettingsStoreBase with Store {
     isAppSecure = sharedPreferences.getBool(PreferencesKey.isAppSecureKey) ?? isAppSecure;
     disableBuy = sharedPreferences.getBool(PreferencesKey.disableBuyKey) ?? disableBuy;
     disableSell = sharedPreferences.getBool(PreferencesKey.disableSellKey) ?? disableSell;
-    defaultBuyProvider = BuyProviderType.values[sharedPreferences.getInt(PreferencesKey.defaultBuyProvider) ?? 0];
+    defaultBuyProvider =
+    BuyProviderType.values[sharedPreferences.getInt(PreferencesKey.defaultBuyProvider) ?? 0];
     allowBiometricalAuthentication =
         sharedPreferences.getBool(PreferencesKey.allowBiometricalAuthenticationKey) ??
             allowBiometricalAuthentication;
@@ -802,7 +833,7 @@ abstract class SettingsStoreBase with Store {
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForSendsToInternalWallets) ??
             false;
     shouldRequireTOTP2FAForExchangesToInternalWallets = sharedPreferences
-            .getBool(PreferencesKey.shouldRequireTOTP2FAForExchangesToInternalWallets) ??
+        .getBool(PreferencesKey.shouldRequireTOTP2FAForExchangesToInternalWallets) ??
         false;
     shouldRequireTOTP2FAForAddingContacts =
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForAddingContacts) ?? false;
@@ -810,7 +841,7 @@ abstract class SettingsStoreBase with Store {
         sharedPreferences.getBool(PreferencesKey.shouldRequireTOTP2FAForCreatingNewWallets) ??
             false;
     shouldRequireTOTP2FAForAllSecurityAndBackupSettings = sharedPreferences
-            .getBool(PreferencesKey.shouldRequireTOTP2FAForAllSecurityAndBackupSettings) ??
+        .getBool(PreferencesKey.shouldRequireTOTP2FAForAllSecurityAndBackupSettings) ??
         false;
     shouldShowMarketPlaceInDashboard =
         sharedPreferences.getBool(PreferencesKey.shouldShowMarketPlaceInDashboard) ??
@@ -846,9 +877,11 @@ abstract class SettingsStoreBase with Store {
 
     final nodeId = sharedPreferences.getInt(PreferencesKey.currentNodeIdKey);
     final bitcoinElectrumServerId =
-        sharedPreferences.getInt(PreferencesKey.currentBitcoinElectrumSererIdKey);
+    sharedPreferences.getInt(PreferencesKey.currentBitcoinElectrumSererIdKey);
     final litecoinElectrumServerId =
-        sharedPreferences.getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
+    sharedPreferences.getInt(PreferencesKey.currentLitecoinElectrumSererIdKey);
+    final bitcoinCashElectrumServerId =
+    sharedPreferences.getInt(PreferencesKey.currentBitcoinCashNodeIdKey);
     final havenNodeId = sharedPreferences.getInt(PreferencesKey.currentHavenNodeIdKey);
     final ethereumNodeId = sharedPreferences.getInt(PreferencesKey.currentEthereumNodeIdKey);
     final nanoNodeId = sharedPreferences.getInt(PreferencesKey.currentNanoNodeIdKey);
@@ -858,6 +891,7 @@ abstract class SettingsStoreBase with Store {
     final litecoinElectrumServer = nodeSource.get(litecoinElectrumServerId);
     final havenNode = nodeSource.get(havenNodeId);
     final ethereumNode = nodeSource.get(ethereumNodeId);
+    final bitcoinCashNode = nodeSource.get(bitcoinCashElectrumServerId);
     final nanoNode = nodeSource.get(nanoNodeId);
 
     if (moneroNode != null) {
@@ -880,6 +914,10 @@ abstract class SettingsStoreBase with Store {
       nodes[WalletType.ethereum] = ethereumNode;
     }
 
+    if (bitcoinCashNode != null) {
+      nodes[WalletType.bitcoinCash] = bitcoinCashNode;
+    }
+
     if (nanoNode != null) {
       nodes[WalletType.nano] = nanoNode;
     }
@@ -904,6 +942,9 @@ abstract class SettingsStoreBase with Store {
       case WalletType.ethereum:
         await _sharedPreferences.setInt(PreferencesKey.currentEthereumNodeIdKey, node.key as int);
         break;
+      case WalletType.bitcoinCash:
+        await _sharedPreferences.setInt(PreferencesKey.currentBitcoinCashNodeIdKey, node.key as int);
+        break;
       case WalletType.nano:
         await _sharedPreferences.setInt(PreferencesKey.currentNanoNodeIdKey, node.key as int);
         break;
diff --git a/lib/view_model/dashboard/transaction_list_item.dart b/lib/view_model/dashboard/transaction_list_item.dart
index e7e640afca..4e1c1aae0b 100644
--- a/lib/view_model/dashboard/transaction_list_item.dart
+++ b/lib/view_model/dashboard/transaction_list_item.dart
@@ -72,6 +72,7 @@ class TransactionListItem extends ActionListItem with Keyable {
         break;
       case WalletType.bitcoin:
       case WalletType.litecoin:
+      case WalletType.bitcoinCash:
         amount = calculateFiatAmountRaw(
             cryptoAmount: bitcoin!.formatterBitcoinAmountToDouble(amount: transaction.amount),
             price: price);
diff --git a/lib/view_model/exchange/exchange_view_model.dart b/lib/view_model/exchange/exchange_view_model.dart
index 47b408bc26..7bc7927dfc 100644
--- a/lib/view_model/exchange/exchange_view_model.dart
+++ b/lib/view_model/exchange/exchange_view_model.dart
@@ -2,10 +2,12 @@ import 'dart:async';
 import 'dart:collection';
 import 'dart:convert';
 
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/core/wallet_change_listener_view_model.dart';
 import 'package:cake_wallet/entities/exchange_api_mode.dart';
 import 'package:cake_wallet/entities/preferences_key.dart';
 import 'package:cake_wallet/entities/wallet_contact.dart';
+import 'package:cake_wallet/ethereum/ethereum.dart';
 import 'package:cake_wallet/exchange/exolix/exolix_exchange_provider.dart';
 import 'package:cake_wallet/exchange/exolix/exolix_request.dart';
 import 'package:cake_wallet/exchange/sideshift/sideshift_exchange_provider.dart';
@@ -265,8 +267,10 @@ abstract class ExchangeViewModelBase extends WalletChangeListenerViewModel with
   }
 
   bool get hasAllAmount =>
-      (wallet.type == WalletType.bitcoin || wallet.type == WalletType.litecoin) &&
-      depositCurrency == wallet.currency;
+      (wallet.type == WalletType.bitcoin ||
+          wallet.type == WalletType.litecoin ||
+          wallet.type == WalletType.bitcoinCash) &&
+          depositCurrency == wallet.currency;
 
   bool get isMoneroWallet => wallet.type == WalletType.monero;
 
@@ -278,7 +282,14 @@ abstract class ExchangeViewModelBase extends WalletChangeListenerViewModel with
       case WalletType.bitcoin:
         return transactionPriority == bitcoin!.getBitcoinTransactionPrioritySlow();
       case WalletType.litecoin:
-        return transactionPriority == bitcoin!.getLitecoinTransactionPrioritySlow();
+        return transactionPriority ==
+            bitcoin!.getLitecoinTransactionPrioritySlow();
+      case WalletType.ethereum:
+        return transactionPriority ==
+            ethereum!.getEthereumTransactionPrioritySlow();
+      case WalletType.bitcoinCash:
+        return transactionPriority ==
+            bitcoinCash!.getBitcoinCashTransactionPrioritySlow();
       default:
         return false;
     }
@@ -619,7 +630,7 @@ abstract class ExchangeViewModelBase extends WalletChangeListenerViewModel with
 
   @action
   void calculateDepositAllAmount() {
-    if (wallet.type == WalletType.bitcoin || wallet.type == WalletType.litecoin) {
+    if (wallet.type == WalletType.bitcoin || wallet.type == WalletType.litecoin || wallet.type == WalletType.bitcoinCash) {
       final availableBalance = wallet.balance[wallet.currency]!.available;
       final priority = _settingsStore.priority[wallet.type]!;
       final fee = wallet.calculateEstimatedFee(priority, null);
@@ -694,6 +705,10 @@ abstract class ExchangeViewModelBase extends WalletChangeListenerViewModel with
         depositCurrency = CryptoCurrency.ltc;
         receiveCurrency = CryptoCurrency.xmr;
         break;
+      case WalletType.bitcoinCash:
+        depositCurrency = CryptoCurrency.bch;
+        receiveCurrency = CryptoCurrency.xmr;
+        break;
       case WalletType.haven:
         depositCurrency = CryptoCurrency.xhv;
         receiveCurrency = CryptoCurrency.btc;
@@ -789,6 +804,12 @@ abstract class ExchangeViewModelBase extends WalletChangeListenerViewModel with
       case WalletType.litecoin:
         _settingsStore.priority[wallet.type] = bitcoin!.getLitecoinTransactionPriorityMedium();
         break;
+      case WalletType.ethereum:
+        _settingsStore.priority[wallet.type] = ethereum!.getDefaultTransactionPriority();
+        break;
+      case WalletType.bitcoinCash:
+        _settingsStore.priority[wallet.type] = bitcoinCash!.getDefaultTransactionPriority();
+        break;
       default:
         break;
     }
diff --git a/lib/view_model/node_list/node_list_view_model.dart b/lib/view_model/node_list/node_list_view_model.dart
index fb1198c410..ae0edba30f 100644
--- a/lib/view_model/node_list/node_list_view_model.dart
+++ b/lib/view_model/node_list/node_list_view_model.dart
@@ -66,6 +66,9 @@ abstract class NodeListViewModelBase with Store {
       case WalletType.ethereum:
         node = getEthereumDefaultNode(nodes: _nodeSource)!;
         break;
+      case WalletType.bitcoinCash:
+        node = getBitcoinCashDefaultElectrumServer(nodes: _nodeSource)!;
+        break;
       case WalletType.nano:
         node = getNanoDefaultNode(nodes: _nodeSource)!;
         break;
diff --git a/lib/view_model/restore/restore_from_qr_vm.dart b/lib/view_model/restore/restore_from_qr_vm.dart
index 39a7b682f2..2bc5954691 100644
--- a/lib/view_model/restore/restore_from_qr_vm.dart
+++ b/lib/view_model/restore/restore_from_qr_vm.dart
@@ -1,4 +1,5 @@
 import 'package:cake_wallet/bitcoin/bitcoin.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/ethereum/ethereum.dart';
 import 'package:cake_wallet/view_model/restore/restore_mode.dart';
 import 'package:cake_wallet/view_model/restore/restore_wallet.dart';
@@ -84,6 +85,9 @@ abstract class WalletRestorationFromQRVMBase extends WalletCreationVM with Store
           case WalletType.litecoin:
             return bitcoin!.createBitcoinRestoreWalletFromSeedCredentials(
                 name: name, mnemonic: restoreWallet.mnemonicSeed ?? '', password: password);
+          case WalletType.bitcoinCash:
+            return bitcoinCash!.createBitcoinCashRestoreWalletFromSeedCredentials(
+                name: name, mnemonic: restoreWallet.mnemonicSeed ?? '', password: password);
           case WalletType.ethereum:
             return ethereum!.createEthereumRestoreWalletFromSeedCredentials(
                 name: name, mnemonic: restoreWallet.mnemonicSeed ?? '', password: password);
diff --git a/lib/view_model/restore/wallet_restore_from_qr_code.dart b/lib/view_model/restore/wallet_restore_from_qr_code.dart
index e9aed55c61..dd138b66ce 100644
--- a/lib/view_model/restore/wallet_restore_from_qr_code.dart
+++ b/lib/view_model/restore/wallet_restore_from_qr_code.dart
@@ -72,8 +72,13 @@ class WalletRestoreFromQRCode {
       case 'litecoin':
       case 'litecoin-wallet':
         return WalletType.litecoin;
+      case 'bitcoincash':
+      case 'bitcoinCash-wallet':
+        return WalletType.bitcoinCash;
       case 'ethereum-wallet':
         return WalletType.ethereum;
+      case 'nano-wallet':
+        return WalletType.nano;
       default:
         throw Exception('Unexpected wallet type: ${scheme.toString()}');
     }
@@ -107,6 +112,7 @@ class WalletRestoreFromQRCode {
       case WalletType.bitcoin:
       case WalletType.litecoin:
       case WalletType.ethereum:
+      case WalletType.bitcoinCash:
         RegExp regex24 = RegExp(r'\b(\S+\b\s+){23}\S+\b');
         RegExp regex18 = RegExp(r'\b(\S+\b\s+){17}\S+\b');
         RegExp regex12 = RegExp(r'\b(\S+\b\s+){11}\S+\b');
diff --git a/lib/view_model/send/output.dart b/lib/view_model/send/output.dart
index 8008812ba3..2e696e16ff 100644
--- a/lib/view_model/send/output.dart
+++ b/lib/view_model/send/output.dart
@@ -81,10 +81,8 @@ abstract class OutputBase with Store {
             _amount = monero!.formatterMoneroParseAmount(amount: _cryptoAmount);
             break;
           case WalletType.bitcoin:
-            _amount =
-                bitcoin!.formatterStringDoubleToBitcoinAmount(_cryptoAmount);
-            break;
           case WalletType.litecoin:
+          case WalletType.bitcoinCash:
             _amount =
                 bitcoin!.formatterStringDoubleToBitcoinAmount(_cryptoAmount);
             break;
@@ -116,7 +114,8 @@ abstract class OutputBase with Store {
           _settingsStore.priority[_wallet.type]!, formattedCryptoAmount);
 
       if (_wallet.type == WalletType.bitcoin ||
-          _wallet.type == WalletType.litecoin) {
+          _wallet.type == WalletType.litecoin ||
+          _wallet.type == WalletType.bitcoinCash) {
         return bitcoin!.formatterBitcoinAmountToDouble(amount: fee);
       }
 
@@ -234,6 +233,9 @@ abstract class OutputBase with Store {
       case WalletType.litecoin:
         maximumFractionDigits = 8;
         break;
+      case WalletType.bitcoinCash:
+        maximumFractionDigits = 8;
+        break;
       case WalletType.haven:
         maximumFractionDigits = 12;
         break;
diff --git a/lib/view_model/send/send_view_model.dart b/lib/view_model/send/send_view_model.dart
index 2ba6dc7841..7192986754 100644
--- a/lib/view_model/send/send_view_model.dart
+++ b/lib/view_model/send/send_view_model.dart
@@ -185,12 +185,15 @@ abstract class SendViewModelBase extends WalletChangeListenerViewModel with Stor
   @computed
   bool get hasCoinControl =>
       wallet.type == WalletType.bitcoin ||
-      wallet.type == WalletType.litecoin ||
-      wallet.type == WalletType.monero;
+          wallet.type == WalletType.litecoin ||
+          wallet.type == WalletType.monero ||
+          wallet.type == WalletType.bitcoinCash;
 
   @computed
   bool get isElectrumWallet =>
-      wallet.type == WalletType.bitcoin || wallet.type == WalletType.litecoin;
+      wallet.type == WalletType.bitcoin ||
+          wallet.type == WalletType.litecoin ||
+          wallet.type == WalletType.bitcoinCash;
 
   @computed
   bool get hasFees => wallet.type != WalletType.nano && wallet.type != WalletType.banano;
@@ -345,41 +348,24 @@ abstract class SendViewModelBase extends WalletChangeListenerViewModel with Stor
       _settingsStore.priority[wallet.type] = priority;
 
   Object _credentials() {
-    switch (wallet.type) {
-      case WalletType.bitcoin:
-        final priority = _settingsStore.priority[wallet.type];
+    final priority = _settingsStore.priority[wallet.type];
 
-        if (priority == null) {
-          throw Exception('Priority is null for wallet type: ${wallet.type}');
-        }
+    if (priority == null) throw Exception('Priority is null for wallet type: ${wallet.type}');
 
-        return bitcoin!.createBitcoinTransactionCredentials(outputs, priority: priority);
+    switch (wallet.type) {
+      case WalletType.bitcoin:
       case WalletType.litecoin:
-        final priority = _settingsStore.priority[wallet.type];
-
-        if (priority == null) {
-          throw Exception('Priority is null for wallet type: ${wallet.type}');
-        }
-
+      case WalletType.bitcoinCash:
         return bitcoin!.createBitcoinTransactionCredentials(outputs, priority: priority);
-      case WalletType.monero:
-        final priority = _settingsStore.priority[wallet.type];
-
-        if (priority == null) {
-          throw Exception('Priority is null for wallet type: ${wallet.type}');
-        }
 
+      case WalletType.monero:
         return monero!
             .createMoneroTransactionCreationCredentials(outputs: outputs, priority: priority);
-      case WalletType.haven:
-        final priority = _settingsStore.priority[wallet.type];
-
-        if (priority == null) {
-          throw Exception('Priority is null for wallet type: ${wallet.type}');
-        }
 
+      case WalletType.haven:
         return haven!.createHavenTransactionCreationCredentials(
             outputs: outputs, priority: priority, assetType: selectedCryptoCurrency.title);
+
       case WalletType.ethereum:
         final priority = _settingsStore.priority[wallet.type];
 
@@ -390,9 +376,7 @@ abstract class SendViewModelBase extends WalletChangeListenerViewModel with Stor
         return ethereum!.createEthereumTransactionCredentials(outputs,
             priority: priority, currency: selectedCryptoCurrency);
       case WalletType.nano:
-        return nano!.createNanoTransactionCredentials(
-          outputs,
-        );
+        return nano!.createNanoTransactionCredentials(outputs);
       default:
         throw Exception('Unexpected wallet type: ${wallet.type}');
     }
diff --git a/lib/view_model/settings/other_settings_view_model.dart b/lib/view_model/settings/other_settings_view_model.dart
index 587e8723ba..b4ca46f709 100644
--- a/lib/view_model/settings/other_settings_view_model.dart
+++ b/lib/view_model/settings/other_settings_view_model.dart
@@ -63,7 +63,9 @@ abstract class OtherSettingsViewModelBase with Store {
   String getDisplayPriority(dynamic priority) {
     final _priority = priority as TransactionPriority;
 
-    if (_wallet.type == WalletType.bitcoin || _wallet.type == WalletType.litecoin) {
+    if (_wallet.type == WalletType.bitcoin ||
+        _wallet.type == WalletType.litecoin ||
+        _wallet.type == WalletType.bitcoinCash) {
       final rate = bitcoin!.getFeeRate(_wallet, _priority);
       return bitcoin!.bitcoinTransactionPriorityWithLabel(_priority, rate);
     }
diff --git a/lib/view_model/transaction_details_view_model.dart b/lib/view_model/transaction_details_view_model.dart
index fd001125fe..a8c8922844 100644
--- a/lib/view_model/transaction_details_view_model.dart
+++ b/lib/view_model/transaction_details_view_model.dart
@@ -39,6 +39,7 @@ abstract class TransactionDetailsViewModelBase with Store {
         break;
       case WalletType.bitcoin:
       case WalletType.litecoin:
+      case WalletType.bitcoinCash:
         _addElectrumListItems(tx, dateFormat);
         break;
       case WalletType.haven:
@@ -115,6 +116,8 @@ abstract class TransactionDetailsViewModelBase with Store {
         return 'https://mempool.space/tx/${txId}';
       case WalletType.litecoin:
         return 'https://blockchair.com/litecoin/transaction/${txId}';
+      case WalletType.bitcoinCash:
+        return 'https://blockchair.com/bitcoin-cash/transaction/${txId}';
       case WalletType.haven:
         return 'https://explorer.havenprotocol.org/search?value=${txId}';
       case WalletType.ethereum:
@@ -135,6 +138,7 @@ abstract class TransactionDetailsViewModelBase with Store {
       case WalletType.bitcoin:
         return S.current.view_transaction_on + 'mempool.space';
       case WalletType.litecoin:
+      case WalletType.bitcoinCash:
         return S.current.view_transaction_on + 'Blockchair.com';
       case WalletType.haven:
         return S.current.view_transaction_on + 'explorer.havenprotocol.org';
diff --git a/lib/view_model/unspent_coins/unspent_coins_details_view_model.dart b/lib/view_model/unspent_coins/unspent_coins_details_view_model.dart
index 992991147b..4da43c241e 100644
--- a/lib/view_model/unspent_coins/unspent_coins_details_view_model.dart
+++ b/lib/view_model/unspent_coins/unspent_coins_details_view_model.dart
@@ -1,9 +1,10 @@
+import 'package:cake_wallet/generated/i18n.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:cake_wallet/src/screens/transaction_details/blockexplorer_list_item.dart';
 import 'package:cake_wallet/src/screens/transaction_details/standart_list_item.dart';
 import 'package:cake_wallet/src/screens/transaction_details/textfield_list_item.dart';
 import 'package:cake_wallet/src/screens/transaction_details/transaction_details_list_item.dart';
 import 'package:cake_wallet/view_model/unspent_coins/unspent_coins_item.dart';
-import 'package:cake_wallet/generated/i18n.dart';
 import 'package:cake_wallet/view_model/unspent_coins/unspent_coins_list_view_model.dart';
 import 'package:cake_wallet/view_model/unspent_coins/unspent_coins_switch_item.dart';
 import 'package:cw_core/wallet_type.dart';
@@ -19,12 +20,14 @@ abstract class UnspentCoinsDetailsViewModelBase with Store {
   UnspentCoinsDetailsViewModelBase(
       {required this.unspentCoinsItem, required this.unspentCoinsListViewModel})
       : items = <TransactionDetailsListItem>[],
+        _type = unspentCoinsListViewModel.wallet.type,
         isFrozen = unspentCoinsItem.isFrozen,
         note = unspentCoinsItem.note {
     items = [
       StandartListItem(title: S.current.transaction_details_amount, value: unspentCoinsItem.amount),
-      StandartListItem(title: S.current.transaction_details_transaction_id, value: unspentCoinsItem.hash),
-      StandartListItem(title: S.current.widgets_address, value: unspentCoinsItem.address),
+      StandartListItem(
+          title: S.current.transaction_details_transaction_id, value: unspentCoinsItem.hash),
+      StandartListItem(title: S.current.widgets_address, value: formattedAddress),
       TextFieldListItem(
           title: S.current.note_tap_to_change,
           value: note,
@@ -46,14 +49,13 @@ abstract class UnspentCoinsDetailsViewModelBase with Store {
           })
     ];
 
-    if ([WalletType.bitcoin, WalletType.litecoin].contains(unspentCoinsListViewModel.wallet.type)) {
+    if ([WalletType.bitcoin, WalletType.litecoin, WalletType.bitcoinCash].contains(_type)) {
       items.add(BlockExplorerListItem(
         title: S.current.view_in_block_explorer,
-        value: _explorerDescription(unspentCoinsListViewModel.wallet.type),
+        value: _explorerDescription(_type),
         onTap: () {
           try {
-            final url = Uri.parse(
-                _explorerUrl(unspentCoinsListViewModel.wallet.type, unspentCoinsItem.hash));
+            final url = Uri.parse(_explorerUrl(_type, unspentCoinsItem.hash));
             return launchUrl(url);
           } catch (e) {}
         },
@@ -67,6 +69,8 @@ abstract class UnspentCoinsDetailsViewModelBase with Store {
         return 'https://ordinals.com/tx/${txId}';
       case WalletType.litecoin:
         return 'https://litecoin.earlyordies.com/tx/${txId}';
+      case WalletType.bitcoinCash:
+        return 'https://blockchair.com/bitcoin-cash/transaction/${txId}';
       default:
         return '';
     }
@@ -78,6 +82,8 @@ abstract class UnspentCoinsDetailsViewModelBase with Store {
         return S.current.view_transaction_on + 'Ordinals.com';
       case WalletType.litecoin:
         return S.current.view_transaction_on + 'Earlyordies.com';
+      case WalletType.bitcoinCash:
+        return S.current.view_transaction_on + 'Blockchair.com';
       default:
         return '';
     }
@@ -91,5 +97,10 @@ abstract class UnspentCoinsDetailsViewModelBase with Store {
 
   final UnspentCoinsItem unspentCoinsItem;
   final UnspentCoinsListViewModel unspentCoinsListViewModel;
+  final WalletType _type;
   List<TransactionDetailsListItem> items;
+
+  String get formattedAddress => WalletType.bitcoinCash == _type
+      ? bitcoinCash!.getCashAddrFormat(unspentCoinsItem.address)
+      : unspentCoinsItem.address;
 }
diff --git a/lib/view_model/unspent_coins/unspent_coins_list_view_model.dart b/lib/view_model/unspent_coins/unspent_coins_list_view_model.dart
index 657a0cb743..709c50562a 100644
--- a/lib/view_model/unspent_coins/unspent_coins_list_view_model.dart
+++ b/lib/view_model/unspent_coins/unspent_coins_list_view_model.dart
@@ -1,9 +1,10 @@
 import 'package:collection/collection.dart';
 import 'package:cake_wallet/bitcoin/bitcoin.dart';
-import 'package:cake_wallet/entities/unspent_transaction_output.dart';
+import 'package:cw_core/unspent_transaction_output.dart';
 import 'package:cake_wallet/monero/monero.dart';
 import 'package:cake_wallet/view_model/unspent_coins/unspent_coins_item.dart';
 import 'package:cw_core/unspent_coins_info.dart';
+import 'package:cw_core/wallet_addresses.dart';
 import 'package:cw_core/wallet_base.dart';
 import 'package:cw_core/wallet_type.dart';
 import 'package:hive/hive.dart';
@@ -24,11 +25,11 @@ abstract class UnspentCoinsListViewModelBase with Store {
   final Box<UnspentCoinsInfo> _unspentCoinsInfo;
 
   @computed
-  ObservableList<UnspentCoinsItem> get items =>
-      ObservableList.of(_getUnspents().map((elem) {
+  ObservableList<UnspentCoinsItem> get items => ObservableList.of(_getUnspents().map((elem) {
         final amount = formatAmountToString(elem.value) + ' ${wallet.currency.title}';
 
-        final info = getUnspentCoinInfo(elem.hash, elem.address, elem.value, elem.vout, elem.keyImage);
+        final info =
+            getUnspentCoinInfo(elem.hash, elem.address, elem.value, elem.vout, elem.keyImage);
 
         return UnspentCoinsItem(
             address: elem.address,
@@ -39,13 +40,13 @@ abstract class UnspentCoinsListViewModelBase with Store {
             isSending: info?.isSending ?? true,
             amountRaw: elem.value,
             vout: elem.vout,
-          keyImage: elem.keyImage
-        );
+            keyImage: elem.keyImage);
       }));
 
   Future<void> saveUnspentCoinInfo(UnspentCoinsItem item) async {
     try {
-      final info = getUnspentCoinInfo(item.hash, item.address, item.amountRaw, item.vout, item.keyImage);
+      final info =
+          getUnspentCoinInfo(item.hash, item.address, item.amountRaw, item.vout, item.keyImage);
       if (info == null) {
         final newInfo = UnspentCoinsInfo(
             walletId: wallet.id,
@@ -56,8 +57,7 @@ abstract class UnspentCoinsListViewModelBase with Store {
             isFrozen: item.isFrozen,
             isSending: item.isSending,
             noteRaw: item.note,
-            keyImage: item.keyImage
-        );
+            keyImage: item.keyImage);
 
         await _unspentCoinsInfo.add(newInfo);
         _updateUnspents();
@@ -76,37 +76,34 @@ abstract class UnspentCoinsListViewModelBase with Store {
     }
   }
 
-  UnspentCoinsInfo? getUnspentCoinInfo(String hash, String address, int value, int vout, String? keyImage) {
+  UnspentCoinsInfo? getUnspentCoinInfo(
+      String hash, String address, int value, int vout, String? keyImage) {
     return _unspentCoinsInfo.values.firstWhereOrNull((element) =>
         element.walletId == wallet.id &&
         element.hash == hash &&
         element.address == address &&
         element.value == value &&
         element.vout == vout &&
-        element.keyImage == keyImage
-    );
+        element.keyImage == keyImage);
   }
 
   String formatAmountToString(int fullBalance) {
     if (wallet.type == WalletType.monero)
       return monero!.formatterMoneroAmountToString(amount: fullBalance);
-    if ([WalletType.bitcoin, WalletType.litecoin].contains(wallet.type))
+    if ([WalletType.bitcoin, WalletType.litecoin, WalletType.bitcoinCash].contains(wallet.type))
       return bitcoin!.formatterBitcoinAmountToString(amount: fullBalance);
     return '';
   }
 
-
   void _updateUnspents() {
-    if (wallet.type == WalletType.monero)
-      return monero!.updateUnspents(wallet);
-    if ([WalletType.bitcoin, WalletType.litecoin].contains(wallet.type))
+    if (wallet.type == WalletType.monero) return monero!.updateUnspents(wallet);
+    if ([WalletType.bitcoin, WalletType.litecoin, WalletType.bitcoinCash].contains(wallet.type))
       return bitcoin!.updateUnspents(wallet);
   }
 
   List<Unspent> _getUnspents() {
-    if (wallet.type == WalletType.monero)
-      return monero!.getUnspents(wallet);
-    if ([WalletType.bitcoin, WalletType.litecoin].contains(wallet.type))
+    if (wallet.type == WalletType.monero) return monero!.getUnspents(wallet);
+    if ([WalletType.bitcoin, WalletType.litecoin, WalletType.bitcoinCash].contains(wallet.type))
       return bitcoin!.getUnspents(wallet);
     return List.empty();
   }
diff --git a/lib/view_model/wallet_address_list/wallet_address_edit_or_create_view_model.dart b/lib/view_model/wallet_address_list/wallet_address_edit_or_create_view_model.dart
index a4eb3d3866..9e2aa71877 100644
--- a/lib/view_model/wallet_address_list/wallet_address_edit_or_create_view_model.dart
+++ b/lib/view_model/wallet_address_list/wallet_address_edit_or_create_view_model.dart
@@ -66,7 +66,8 @@ abstract class WalletAddressEditOrCreateViewModelBase with Store {
     final wallet = _wallet;
 
     if (wallet.type == WalletType.bitcoin
-        || wallet.type == WalletType.litecoin) {
+        || wallet.type == WalletType.litecoin
+        || wallet.type == WalletType.bitcoinCash) {
       await bitcoin!.generateNewAddress(wallet);
       await wallet.save();
     }
diff --git a/lib/view_model/wallet_address_list/wallet_address_list_view_model.dart b/lib/view_model/wallet_address_list/wallet_address_list_view_model.dart
index a24e1635fb..4d5eefdb74 100644
--- a/lib/view_model/wallet_address_list/wallet_address_list_view_model.dart
+++ b/lib/view_model/wallet_address_list/wallet_address_list_view_model.dart
@@ -107,6 +107,23 @@ class EthereumURI extends PaymentURI {
   }
 }
 
+class BitcoinCashURI extends PaymentURI {
+  BitcoinCashURI({required String amount, required String address})
+    : super(amount: amount, address: address);
+  @override
+  String toString() {
+    var base = address;
+
+    if (amount.isNotEmpty) {
+      base += '?amount=${amount.replaceAll(',', '.')}';
+    }
+
+    return base;
+  }
+  }
+
+
+
 class NanoURI extends PaymentURI {
   NanoURI({required String amount, required String address})
       : super(amount: amount, address: address);
@@ -114,7 +131,6 @@ class NanoURI extends PaymentURI {
   @override
   String toString() {
     var base = 'nano:' + address;
-
     if (amount.isNotEmpty) {
       base += '?amount=${amount.replaceAll(',', '.')}';
     }
@@ -192,6 +208,10 @@ abstract class WalletAddressListViewModelBase extends WalletChangeListenerViewMo
       return EthereumURI(amount: amount, address: address.address);
     }
 
+    if (wallet.type == WalletType.bitcoinCash) {
+      return BitcoinCashURI(amount: amount, address: address.address);
+    }
+
     if (wallet.type == WalletType.nano) {
       return NanoURI(amount: amount, address: address.address);
     }
@@ -280,7 +300,9 @@ abstract class WalletAddressListViewModelBase extends WalletChangeListenerViewMo
 
   @computed
   bool get showElectrumAddressDisclaimer =>
-      wallet.type == WalletType.bitcoin || wallet.type == WalletType.litecoin;
+      wallet.type == WalletType.bitcoin ||
+          wallet.type == WalletType.litecoin ||
+          wallet.type == WalletType.bitcoinCash;
 
   List<ListItem> _baseItems;
 
diff --git a/lib/view_model/wallet_keys_view_model.dart b/lib/view_model/wallet_keys_view_model.dart
index e2938c74e5..e106126bc7 100644
--- a/lib/view_model/wallet_keys_view_model.dart
+++ b/lib/view_model/wallet_keys_view_model.dart
@@ -19,6 +19,7 @@ abstract class WalletKeysViewModelBase with Store {
   WalletKeysViewModelBase(this._appStore)
       : title = _appStore.wallet!.type == WalletType.bitcoin ||
                 _appStore.wallet!.type == WalletType.litecoin ||
+                _appStore.wallet!.type == WalletType.bitcoinCash ||
                 _appStore.wallet!.type == WalletType.ethereum
             ? S.current.wallet_seed
             : S.current.wallet_keys,
@@ -91,7 +92,8 @@ abstract class WalletKeysViewModelBase with Store {
     }
 
     if (_appStore.wallet!.type == WalletType.bitcoin ||
-        _appStore.wallet!.type == WalletType.litecoin) {
+        _appStore.wallet!.type == WalletType.litecoin ||
+        _appStore.wallet!.type == WalletType.bitcoinCash) {
       items.addAll([
         StandartListItem(title: S.current.wallet_seed, value: _appStore.wallet!.seed!),
       ]);
@@ -145,6 +147,8 @@ abstract class WalletKeysViewModelBase with Store {
         return 'haven-wallet';
       case WalletType.ethereum:
         return 'ethereum-wallet';
+      case WalletType.bitcoinCash:
+        return 'bitcoinCash-wallet';
       case WalletType.nano:
         return 'nano-wallet';
       case WalletType.banano:
diff --git a/lib/view_model/wallet_new_vm.dart b/lib/view_model/wallet_new_vm.dart
index 04da7190eb..9b1f0834d6 100644
--- a/lib/view_model/wallet_new_vm.dart
+++ b/lib/view_model/wallet_new_vm.dart
@@ -1,6 +1,7 @@
 import 'package:cake_wallet/view_model/restore/restore_wallet.dart';
 import 'package:cake_wallet/ethereum/ethereum.dart';
 import 'package:flutter/foundation.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:hive/hive.dart';
 import 'package:mobx/mobx.dart';
 import 'package:cake_wallet/monero/monero.dart';
@@ -46,10 +47,12 @@ abstract class WalletNewVMBase extends WalletCreationVM with Store {
             name: name, language: options as String);
       case WalletType.ethereum:
         return ethereum!.createEthereumNewWalletCredentials(name: name);
+      case WalletType.bitcoinCash:
+        return bitcoinCash!.createBitcoinCashNewWalletCredentials(name: name);
       case WalletType.nano:
         return nano!.createNanoNewWalletCredentials(name: name);
       default:
-        throw Exception('Unexpected type: ${type.toString()}');;
+        throw Exception('Unexpected type: ${type.toString()}');
     }
   }
 
diff --git a/lib/view_model/wallet_restore_view_model.dart b/lib/view_model/wallet_restore_view_model.dart
index 4eb69e48ff..058948c2fb 100644
--- a/lib/view_model/wallet_restore_view_model.dart
+++ b/lib/view_model/wallet_restore_view_model.dart
@@ -2,6 +2,7 @@ import 'package:cake_wallet/bitcoin/bitcoin.dart';
 import 'package:cake_wallet/di.dart';
 import 'package:cake_wallet/nano/nano.dart';
 import 'package:cake_wallet/ethereum/ethereum.dart';
+import 'package:cake_wallet/bitcoin_cash/bitcoin_cash.dart';
 import 'package:hive/hive.dart';
 import 'package:mobx/mobx.dart';
 import 'package:cake_wallet/store/app_store.dart';
@@ -92,14 +93,20 @@ abstract class WalletRestoreViewModelBase extends WalletCreationVM with Store {
               name: name, height: height, mnemonic: seed, password: password);
         case WalletType.ethereum:
           return ethereum!.createEthereumRestoreWalletFromSeedCredentials(
-              name: name, mnemonic: seed, password: password);
+              name: name,
+              mnemonic: seed,
+              password: password);
+        case WalletType.bitcoinCash:
+          return bitcoinCash!.createBitcoinCashRestoreWalletFromSeedCredentials(
+              name: name,
+              mnemonic: seed,
+              password: password);
         case WalletType.nano:
           return nano!.createNanoRestoreWalletFromSeedCredentials(
             name: name,
             mnemonic: seed,
             password: password,
-            derivationType: derivationType,
-          );
+            derivationType: derivationType);
         default:
           break;
       }
@@ -145,8 +152,7 @@ abstract class WalletRestoreViewModelBase extends WalletCreationVM with Store {
             name: name,
             password: password,
             seedKey: options['private_key'] as String,
-            derivationType: options["derivationType"] as DerivationType,
-          );
+            derivationType: options["derivationType"] as DerivationType);
         default:
           break;
       }
@@ -167,8 +173,7 @@ abstract class WalletRestoreViewModelBase extends WalletCreationVM with Store {
         return nanoUtil!.compareDerivationMethods(
           mnemonic: mnemonic,
           privateKey: seedKey,
-          node: node,
-        );
+          node: node);
       default:
         break;
     }
diff --git a/model_generator.sh b/model_generator.sh
old mode 100755
new mode 100644
index 0e4345c25d..50cb3d353c
--- a/model_generator.sh
+++ b/model_generator.sh
@@ -4,4 +4,5 @@ cd cw_bitcoin && flutter pub get && flutter packages pub run build_runner build
 cd cw_haven && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 cd cw_ethereum && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 cd cw_nano && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
+cd cw_bitcoin_cash && flutter pub get && flutter packages pub run build_runner build --delete-conflicting-outputs && cd ..
 flutter packages pub run build_runner build --delete-conflicting-outputs
\ No newline at end of file
diff --git a/pubspec_base.yaml b/pubspec_base.yaml
index 1e5a2df26e..6f8d51615c 100644
--- a/pubspec_base.yaml
+++ b/pubspec_base.yaml
@@ -129,6 +129,7 @@ flutter:
     - assets/bitcoin_electrum_server_list.yml
     - assets/litecoin_electrum_server_list.yml
     - assets/ethereum_server_list.yml
+    - assets/bitcoin_cash_electrum_server_list.yml
     - assets/nano_node_list.yml
     - assets/nano_pow_node_list.yml
     - assets/text/
diff --git a/scripts/android/app_config.sh b/scripts/android/app_config.sh
index 01edb14a46..e2cbd72da5 100755
--- a/scripts/android/app_config.sh
+++ b/scripts/android/app_config.sh
@@ -9,4 +9,4 @@ fi
 ./app_icon.sh
 ./pubspec_gen.sh
 ./manifest.sh
-./inject_app_details.sh
\ No newline at end of file
+./inject_app_details.sh
diff --git a/scripts/android/pubspec_gen.sh b/scripts/android/pubspec_gen.sh
index c74108bf1a..dd98520724 100755
--- a/scripts/android/pubspec_gen.sh
+++ b/scripts/android/pubspec_gen.sh
@@ -10,7 +10,7 @@ case $APP_ANDROID_TYPE in
                 CONFIG_ARGS="--monero"
                 ;;
         $CAKEWALLET)
-                CONFIG_ARGS="--monero --bitcoin --haven --ethereum --nano"
+                CONFIG_ARGS="--monero --bitcoin --haven --ethereum --nano --bitcoinCash"
                 ;;
         $HAVEN)
                 CONFIG_ARGS="--haven"
diff --git a/scripts/ios/app_config.sh b/scripts/ios/app_config.sh
old mode 100755
new mode 100644
index e62b065485..8d999f594b
--- a/scripts/ios/app_config.sh
+++ b/scripts/ios/app_config.sh
@@ -28,9 +28,11 @@ case $APP_IOS_TYPE in
 		CONFIG_ARGS="--monero"
 		;;
         $CAKEWALLET)
-		CONFIG_ARGS="--monero --bitcoin --haven --ethereum --nano"
+		CONFIG_ARGS="--monero --bitcoin --haven --ethereum --nano --bitcoinCash"
 		;;
 	$HAVEN)
+
+
 		CONFIG_ARGS="--haven"
 		;;
 esac
diff --git a/scripts/macos/app_config.sh b/scripts/macos/app_config.sh
index 2af1014854..48b6803306 100755
--- a/scripts/macos/app_config.sh
+++ b/scripts/macos/app_config.sh
@@ -23,7 +23,7 @@ CONFIG_ARGS=""
 
 case $APP_MACOS_TYPE in
         $CAKEWALLET)
-		CONFIG_ARGS="--monero --bitcoin --ethereum --nano";; #--haven
+		CONFIG_ARGS="--monero --bitcoin --ethereum --nano --bitcoinCash";; #--haven
 esac
 
 cp -rf pubspec_description.yaml pubspec.yaml
diff --git a/tool/configure.dart b/tool/configure.dart
index f7b9dc1263..534aeef57f 100644
--- a/tool/configure.dart
+++ b/tool/configure.dart
@@ -4,6 +4,7 @@ const bitcoinOutputPath = 'lib/bitcoin/bitcoin.dart';
 const moneroOutputPath = 'lib/monero/monero.dart';
 const havenOutputPath = 'lib/haven/haven.dart';
 const ethereumOutputPath = 'lib/ethereum/ethereum.dart';
+const bitcoinCashOutputPath = 'lib/bitcoin_cash/bitcoin_cash.dart';
 const nanoOutputPath = 'lib/nano/nano.dart';
 const walletTypesPath = 'lib/wallet_types.g.dart';
 const pubspecDefaultPath = 'pubspec_default.yaml';
@@ -15,6 +16,7 @@ Future<void> main(List<String> args) async {
   final hasMonero = args.contains('${prefix}monero');
   final hasHaven = args.contains('${prefix}haven');
   final hasEthereum = args.contains('${prefix}ethereum');
+  final hasBitcoinCash = args.contains('${prefix}bitcoinCash');
   final hasNano = args.contains('${prefix}nano');
   final hasBanano = args.contains('${prefix}banano');
 
@@ -22,6 +24,7 @@ Future<void> main(List<String> args) async {
   await generateMonero(hasMonero);
   await generateHaven(hasHaven);
   await generateEthereum(hasEthereum);
+  await generateBitcoinCash(hasBitcoinCash);
   await generateNano(hasNano);
   // await generateBanano(hasEthereum);
 
@@ -32,6 +35,7 @@ Future<void> main(List<String> args) async {
     hasEthereum: hasEthereum,
     hasNano: hasNano,
     hasBanano: hasBanano,
+    hasBitcoinCash: hasBitcoinCash,
   );
   await generateWalletTypes(
     hasMonero: hasMonero,
@@ -40,13 +44,13 @@ Future<void> main(List<String> args) async {
     hasEthereum: hasEthereum,
     hasNano: hasNano,
     hasBanano: hasBanano,
+    hasBitcoinCash: hasBitcoinCash,
   );
 }
 
 Future<void> generateBitcoin(bool hasImplementation) async {
   final outputFile = File(bitcoinOutputPath);
   const bitcoinCommonHeaders = """
-import 'package:cake_wallet/entities/unspent_transaction_output.dart';
 import 'package:cw_core/wallet_credentials.dart';
 import 'package:cw_core/wallet_info.dart';
 import 'package:cw_core/transaction_priority.dart';
@@ -60,7 +64,6 @@ import 'package:cw_bitcoin/electrum_wallet.dart';
 import 'package:cw_bitcoin/bitcoin_unspent.dart';
 import 'package:cw_bitcoin/bitcoin_mnemonic.dart';
 import 'package:cw_bitcoin/bitcoin_transaction_priority.dart';
-import 'package:cw_bitcoin/bitcoin_wallet.dart';
 import 'package:cw_bitcoin/bitcoin_wallet_service.dart';
 import 'package:cw_bitcoin/bitcoin_wallet_creation_credentials.dart';
 import 'package:cw_bitcoin/bitcoin_amount_format.dart';
@@ -80,8 +83,8 @@ abstract class Bitcoin {
   Map<String, String> getWalletKeys(Object wallet);
   List<TransactionPriority> getTransactionPriorities();
   List<TransactionPriority> getLitecoinTransactionPriorities();
-  TransactionPriority deserializeBitcoinTransactionPriority(int raw); 
-  TransactionPriority deserializeLitecoinTransactionPriority(int raw); 
+  TransactionPriority deserializeBitcoinTransactionPriority(int raw);
+  TransactionPriority deserializeLitecoinTransactionPriority(int raw);
   int getFeeRate(Object wallet, TransactionPriority priority);
   Future<void> generateNewAddress(Object wallet);
   Object createBitcoinTransactionCredentials(List<Output> outputs, {required TransactionPriority priority, int? feeRate});
@@ -95,7 +98,7 @@ abstract class Bitcoin {
   int formatterStringDoubleToBitcoinAmount(String amount);
   String bitcoinTransactionPriorityWithLabel(TransactionPriority priority, int rate);
 
-  List<Unspent> getUnspents(Object wallet);
+  List<BitcoinUnspent> getUnspents(Object wallet);
   void updateUnspents(Object wallet);
   WalletService createBitcoinWalletService(Box<WalletInfo> walletInfoSource, Box<UnspentCoinsInfo> unspentCoinSource);
   WalletService createLitecoinWalletService(Box<WalletInfo> walletInfoSource, Box<UnspentCoinsInfo> unspentCoinSource);
@@ -126,7 +129,7 @@ abstract class Bitcoin {
 Future<void> generateMonero(bool hasImplementation) async {
   final outputFile = File(moneroOutputPath);
   const moneroCommonHeaders = """
-import 'package:cake_wallet/entities/unspent_transaction_output.dart';
+import 'package:cw_core/unspent_transaction_output.dart';
 import 'package:cw_core/unspent_coins_info.dart';
 import 'package:cw_monero/monero_unspent.dart';
 import 'package:mobx/mobx.dart';
@@ -521,6 +524,7 @@ abstract class Ethereum {
   String getPrivateKey(WalletBase wallet);
   String getPublicKey(WalletBase wallet);
   TransactionPriority getDefaultTransactionPriority();
+  TransactionPriority getEthereumTransactionPrioritySlow();
   List<TransactionPriority> getTransactionPriorities();
   TransactionPriority deserializeEthereumTransactionPriority(int raw);
 
@@ -568,6 +572,67 @@ abstract class Ethereum {
   await outputFile.writeAsString(output);
 }
 
+Future<void> generateBitcoinCash(bool hasImplementation) async {
+  final outputFile = File(bitcoinCashOutputPath);
+  const bitcoinCashCommonHeaders = """
+import 'dart:typed_data';
+
+import 'package:cw_bitcoin/bitcoin_transaction_priority.dart';
+import 'package:cw_core/transaction_priority.dart';
+import 'package:cw_core/unspent_coins_info.dart';
+import 'package:cw_core/wallet_credentials.dart';
+import 'package:cw_core/wallet_info.dart';
+import 'package:cw_core/wallet_service.dart';
+import 'package:hive/hive.dart';
+""";
+  const bitcoinCashCWHeaders = """
+import 'package:cw_bitcoin_cash/cw_bitcoin_cash.dart';
+""";
+  const bitcoinCashCwPart = "part 'cw_bitcoin_cash.dart';";
+  const bitcoinCashContent = """
+abstract class BitcoinCash {
+  String getMnemonic(int? strength);
+
+  Uint8List getSeedFromMnemonic(String seed);
+
+  String getCashAddrFormat(String address);
+
+  WalletService createBitcoinCashWalletService(
+      Box<WalletInfo> walletInfoSource, Box<UnspentCoinsInfo> unspentCoinSource);
+
+  WalletCredentials createBitcoinCashNewWalletCredentials(
+      {required String name, WalletInfo? walletInfo});
+
+  WalletCredentials createBitcoinCashRestoreWalletFromSeedCredentials(
+      {required String name, required String mnemonic, required String password});
+
+  TransactionPriority deserializeBitcoinCashTransactionPriority(int raw);
+
+  TransactionPriority getDefaultTransactionPriority();
+
+  List<TransactionPriority> getTransactionPriorities();
+  
+  TransactionPriority getBitcoinCashTransactionPrioritySlow();
+}
+  """;
+
+  const bitcoinCashEmptyDefinition = 'BitcoinCash? bitcoinCash;\n';
+  const bitcoinCashCWDefinition = 'BitcoinCash? bitcoinCash = CWBitcoinCash();\n';
+
+  final output = '$bitcoinCashCommonHeaders\n' +
+      (hasImplementation ? '$bitcoinCashCWHeaders\n' : '\n') +
+      (hasImplementation ? '$bitcoinCashCwPart\n\n' : '\n') +
+      (hasImplementation ? bitcoinCashCWDefinition : bitcoinCashEmptyDefinition) +
+      '\n' +
+      bitcoinCashContent;
+
+  if (outputFile.existsSync()) {
+    await outputFile.delete();
+  }
+
+  await outputFile.writeAsString(output);
+}
+
 Future<void> generateNano(bool hasImplementation) async {
   final outputFile = File(nanoOutputPath);
   const nanoCommonHeaders = """
@@ -710,14 +775,14 @@ abstract class NanoUtil {
   await outputFile.writeAsString(output);
 }
 
-Future<void> generatePubspec({
-  required bool hasMonero,
-  required bool hasBitcoin,
-  required bool hasHaven,
-  required bool hasEthereum,
-  required bool hasNano,
-  required bool hasBanano,
-}) async {
+Future<void> generatePubspec(
+    {required bool hasMonero,
+    required bool hasBitcoin,
+    required bool hasHaven,
+    required bool hasEthereum,
+    required bool hasNano,
+    required bool hasBanano,
+    required bool hasBitcoinCash}) async {
   const cwCore = """
   cw_core:
     path: ./cw_core
@@ -742,6 +807,10 @@ Future<void> generatePubspec({
   cw_ethereum:
     path: ./cw_ethereum
   """;
+  const cwBitcoinCash = """
+  cw_bitcoin_cash:
+    path: ./cw_bitcoin_cash
+  """;
   const cwNano = """
   cw_nano:
     path: ./cw_nano
@@ -776,6 +845,10 @@ Future<void> generatePubspec({
     output += '\n$cwBanano';
   }
 
+  if (hasBitcoinCash) {
+    output += '\n$cwBitcoinCash';
+  }
+
   if (hasHaven && !hasMonero) {
     output += '\n$cwSharedExternal\n$cwHaven';
   } else if (hasHaven) {
@@ -794,14 +867,14 @@ Future<void> generatePubspec({
   await outputFile.writeAsString(outputContent);
 }
 
-Future<void> generateWalletTypes({
-  required bool hasMonero,
-  required bool hasBitcoin,
-  required bool hasHaven,
-  required bool hasEthereum,
-  required bool hasNano,
-  required bool hasBanano,
-}) async {
+Future<void> generateWalletTypes(
+    {required bool hasMonero,
+    required bool hasBitcoin,
+    required bool hasHaven,
+    required bool hasEthereum,
+    required bool hasNano,
+    required bool hasBanano,
+    required bool hasBitcoinCash}) async {
   final walletTypesFile = File(walletTypesPath);
 
   if (walletTypesFile.existsSync()) {
@@ -828,6 +901,10 @@ Future<void> generateWalletTypes({
     outputContent += '\tWalletType.litecoin,\n';
   }
 
+  if (hasBitcoinCash) {
+    outputContent += '\tWalletType.bitcoinCash,\n';
+  }
+
   if (hasNano) {
     outputContent += '\tWalletType.nano,\n';
   }
