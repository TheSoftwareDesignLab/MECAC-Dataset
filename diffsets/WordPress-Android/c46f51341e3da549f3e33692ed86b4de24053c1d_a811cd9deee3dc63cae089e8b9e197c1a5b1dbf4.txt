diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/ReaderPostListFragment.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/ReaderPostListFragment.kt
index 02429bcd93ce..ed8877b311d9 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/ReaderPostListFragment.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/ReaderPostListFragment.kt
@@ -2180,12 +2180,12 @@ class ReaderPostListFragment : ViewPagerFragment(), OnPostSelectedListener, OnFo
             return false
         }
 
-        var tagName = tagPreviewHistory.pop()
+        var tagName = tagPreviewHistory.pop().orEmpty()
         if (isCurrentTagName(tagName)) {
             if (tagPreviewHistory.empty()) {
                 return false
             }
-            tagName = tagPreviewHistory.pop()
+            tagName = tagPreviewHistory.pop().orEmpty()
         }
 
         val newTag = ReaderUtils.getTagFromTagName(tagName, ReaderTagType.FOLLOWED)
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.java b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.java
deleted file mode 100644
index 12f36e575d3f..000000000000
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.java
+++ /dev/null
@@ -1,552 +0,0 @@
-package org.wordpress.android.ui.reader.utils;
-
-import android.content.Context;
-import android.net.Uri;
-import android.text.TextUtils;
-import android.view.View;
-
-import androidx.annotation.NonNull;
-
-import org.apache.commons.text.StringEscapeUtils;
-import org.wordpress.android.R;
-import org.wordpress.android.datasets.ReaderCommentTable;
-import org.wordpress.android.datasets.ReaderPostTable;
-import org.wordpress.android.datasets.ReaderTagTable;
-import org.wordpress.android.models.ReaderTag;
-import org.wordpress.android.models.ReaderTagList;
-import org.wordpress.android.models.ReaderTagType;
-import org.wordpress.android.ui.FilteredRecyclerView;
-import org.wordpress.android.ui.reader.ReaderConstants;
-import org.wordpress.android.ui.reader.services.update.TagUpdateClientUtilsProvider;
-import org.wordpress.android.util.FormatUtils;
-import org.wordpress.android.util.PhotonUtils;
-import org.wordpress.android.util.StringUtils;
-import org.wordpress.android.util.UrlUtils;
-
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-public class ReaderUtils {
-    public static String getResizedImageUrl(final String imageUrl, int width, int height, boolean isPrivate,
-                                            boolean isPrivateAtomic) {
-        return getResizedImageUrl(imageUrl, width, height, isPrivate, isPrivateAtomic, PhotonUtils.Quality.MEDIUM);
-    }
-
-    public static String getResizedImageUrl(final String imageUrl,
-                                            int width,
-                                            int height,
-                                            boolean isPrivate,
-                                            boolean isPrivateAtomic,
-                                            PhotonUtils.Quality quality) {
-        final String unescapedUrl = StringEscapeUtils.unescapeHtml4(imageUrl);
-
-
-        if (isPrivate && !isPrivateAtomic) {
-            return getImageForDisplayWithoutPhoton(unescapedUrl, width, height, true);
-        } else {
-            return PhotonUtils.getPhotonImageUrl(unescapedUrl, width, height, quality, isPrivateAtomic);
-        }
-    }
-
-    public static String getResizedImageUrl(final String imageUrl,
-                                            int width,
-                                            int height,
-                                            SiteAccessibilityInfo siteAccessibilityInfo) {
-        return getResizedImageUrl(imageUrl, width, height, siteAccessibilityInfo, PhotonUtils.Quality.MEDIUM);
-    }
-
-    public static String getResizedImageUrl(final String imageUrl,
-                                            int width,
-                                            int height,
-                                            SiteAccessibilityInfo siteAccessibilityInfo,
-                                            PhotonUtils.Quality quality) {
-        final String unescapedUrl = StringEscapeUtils.unescapeHtml4(imageUrl);
-
-        if (siteAccessibilityInfo.isPhotonCapable()) {
-            return PhotonUtils.getPhotonImageUrl(
-                    unescapedUrl,
-                    width,
-                    height,
-                    quality,
-                    siteAccessibilityInfo.getSiteVisibility() == SiteVisibility.PRIVATE_ATOMIC
-            );
-        } else {
-            return getImageForDisplayWithoutPhoton(
-                    unescapedUrl,
-                    width,
-                    height,
-                    siteAccessibilityInfo.getSiteVisibility() == SiteVisibility.PRIVATE
-            );
-        }
-    }
-
-    /*
-     * use this to request a reduced size image from not photon capable sites
-     * (i.e. a private post - images in private posts can't use photon
-     * but these are usually wp images so they support the h= and w= query params)
-     */
-    private static String getImageForDisplayWithoutPhoton(
-            final String imageUrl,
-            int width,
-            int height,
-            boolean forceHttps
-    ) {
-        if (TextUtils.isEmpty(imageUrl)) {
-            return "";
-        }
-
-        final String query;
-        if (width > 0 && height > 0) {
-            query = "?w=" + width + "&h=" + height;
-        } else if (width > 0) {
-            query = "?w=" + width;
-        } else if (height > 0) {
-            query = "?h=" + height;
-        } else {
-            query = "";
-        }
-
-        if (forceHttps) {
-            // remove the existing query string, add the new one, and make sure the url is https:
-            return UrlUtils.removeQuery(UrlUtils.makeHttps(imageUrl)) + query;
-        } else {
-            // remove the existing query string, add the new one
-            return UrlUtils.removeQuery(imageUrl) + query;
-        }
-    }
-
-    /*
-     * returns the passed string formatted for use with our API - see sanitize_title_with_dashes
-     * https://git.io/JqUEP
-     * http://stackoverflow.com/a/1612015/1673548
-     */
-    public static String sanitizeWithDashes(final String title) {
-        if (title == null) {
-            return "";
-        }
-
-        String trimmedTitle = title.trim();
-        if (isValidUrlEncodedString(trimmedTitle)) {
-            return trimmedTitle;
-        } else {
-            return trimmedTitle
-                        .replaceAll("&[^\\s]*;", "") // remove html entities
-                        .replaceAll("[\\.\\s]+", "-") // replace periods and whitespace with a dash
-                        .replaceAll("[^\\p{L}\\p{Nd}\\-]+",
-                                "") // remove remaining non-alphanum/non-dash chars (Unicode aware)
-                        .replaceAll("--", "-"); // reduce double dashes potentially added above
-        }
-    }
-
-    @NonNull
-    private static boolean isValidUrlEncodedString(String title) {
-        try {
-            URI.create(title);
-        } catch (IllegalArgumentException e) {
-            return false;
-        }
-        return true;
-    }
-
-    /*
-     * returns the long text to use for a like label ("Liked by 3 people", etc.)
-     */
-    public static String getLongLikeLabelText(Context context, int numLikes, boolean isLikedByCurrentUser) {
-        if (isLikedByCurrentUser) {
-            switch (numLikes) {
-                case 1:
-                    return context.getString(R.string.reader_likes_only_you);
-                case 2:
-                    return context.getString(R.string.reader_likes_you_and_one);
-                default:
-                    String youAndMultiLikes = context.getString(R.string.reader_likes_you_and_multi);
-                    return String.format(youAndMultiLikes, numLikes - 1);
-            }
-        } else {
-            if (numLikes == 1) {
-                return context.getString(R.string.reader_likes_one);
-            } else {
-                String likes = context.getString(R.string.reader_likes_multi);
-                return String.format(likes, numLikes);
-            }
-        }
-    }
-
-    /*
-     * short like text ("1 like," "5 likes," etc.)
-     */
-    public static String getShortLikeLabelText(Context context, int numLikes) {
-        switch (numLikes) {
-            case 0:
-                return context.getString(R.string.reader_short_like_count_none);
-            case 1:
-                return context.getString(R.string.reader_short_like_count_one);
-            default:
-                String count = FormatUtils.formatInt(numLikes);
-                return String.format(context.getString(R.string.reader_short_like_count_multi), count);
-        }
-    }
-
-    public static String getShortCommentLabelText(Context context, int numComments) {
-        switch (numComments) {
-            case 1:
-                return context.getString(R.string.reader_short_comment_count_one);
-            default:
-                String count = FormatUtils.formatInt(numComments);
-                return String.format(context.getString(R.string.reader_short_comment_count_multi), count);
-        }
-    }
-
-    public static String getTextForCommentSnippet(Context context, int numComments) {
-        switch (numComments) {
-            case 0:
-                return context.getString(R.string.comments);
-            case 1:
-                return context.getString(R.string.reader_short_comment_count_one);
-            default:
-                String count = FormatUtils.formatInt(numComments);
-                return String.format(context.getString(R.string.reader_short_comment_count_multi), count);
-        }
-    }
-
-    /*
-     * returns true if a ReaderPost and ReaderComment exist for the passed Ids
-     */
-    public static boolean postAndCommentExists(long blogId, long postId, long commentId) {
-        return ReaderPostTable.postExists(blogId, postId)
-               && ReaderCommentTable.commentExists(blogId, postId, commentId);
-    }
-
-    /*
-     * used by Discover site picks to add a "Visit [BlogName]" link which shows the
-     * native blog preview for that blog
-     */
-    public static String makeBlogPreviewUrl(long blogId) {
-        return "wordpress://blogpreview?blogId=" + Long.toString(blogId);
-    }
-
-    public static boolean isBlogPreviewUrl(String url) {
-        return (url != null && url.startsWith("wordpress://blogpreview"));
-    }
-
-    public static long getBlogIdFromBlogPreviewUrl(String url) {
-        if (isBlogPreviewUrl(url)) {
-            String strBlogId = Uri.parse(url).getQueryParameter("blogId");
-            return StringUtils.stringToLong(strBlogId);
-        } else {
-            return 0;
-        }
-    }
-
-    public static boolean isTagUrl(String url) {
-        return (url != null && url.matches("^https?://wordpress\\.com/tag/[^/]+$"));
-    }
-
-    public static String getTagFromTagUrl(String url) {
-        if (isTagUrl(url)) {
-            return url.substring(url.lastIndexOf("/") + 1);
-        } else {
-            return "";
-        }
-    }
-
-    /*
-     * set the background of the passed view to the round ripple drawable - only works on
-     * Lollipop or later, does nothing on earlier Android versions
-     */
-    public static void setBackgroundToRoundRipple(View view) {
-        if (view != null) {
-            view.setBackgroundResource(R.drawable.ripple_oval);
-        }
-    }
-
-    /*
-     * returns a tag object from the passed endpoint if tag is in database, otherwise null
-     */
-    public static ReaderTag getTagFromEndpoint(String endpoint) {
-        return ReaderTagTable.getTagFromEndpoint(endpoint);
-    }
-
-    /*
-     * returns a tag object from the passed tag name - first checks for it in the tag db
-     * (so we can also get its title & endpoint), returns a new tag if that fails
-     */
-    public static ReaderTag getTagFromTagName(String tagName, ReaderTagType tagType) {
-        return getTagFromTagName(tagName, tagType, false);
-    }
-
-    public static ReaderTag getTagFromTagName(String tagName, ReaderTagType tagType, boolean markDefaultIfInMemory) {
-        ReaderTag tag = ReaderTagTable.getTag(tagName, tagType);
-        if (tag != null) {
-            return tag;
-        } else {
-            return createTagFromTagName(tagName, tagType, markDefaultIfInMemory);
-        }
-    }
-
-    public static ReaderTag createTagFromTagName(String tagName, ReaderTagType tagType) {
-        return createTagFromTagName(tagName, tagType, false);
-    }
-
-    public static ReaderTag createTagFromTagName(String tagName, ReaderTagType tagType, boolean isDefaultInMemoryTag) {
-        String tagSlug = sanitizeWithDashes(tagName).toLowerCase(Locale.ROOT);
-        String tagDisplayName = tagType == ReaderTagType.DEFAULT ? tagName : tagSlug;
-        return new ReaderTag(
-                tagSlug,
-                tagDisplayName,
-                tagName,
-                null,
-                tagType,
-                isDefaultInMemoryTag
-        );
-    }
-
-    /*
-     * returns the default tag, which is the one selected by default in the reader when
-     * the user hasn't already chosen one
-     */
-    public static ReaderTag getDefaultTag() {
-        ReaderTag defaultTag = getTagFromEndpoint(ReaderTag.TAG_ENDPOINT_DEFAULT);
-        if (defaultTag == null) {
-            defaultTag = getTagFromTagName(ReaderTag.TAG_TITLE_DEFAULT, ReaderTagType.DEFAULT, true);
-        }
-        return defaultTag;
-    }
-
-    public static @NonNull ReaderTag getDefaultTagFromDbOrCreateInMemory(
-            @NonNull Context context,
-            TagUpdateClientUtilsProvider clientUtilsProvider
-    ) {
-        // getDefaultTag() tries to get the default tag from reader db by tag endpoint or tag name.
-        // In case it cannot get the default tag from db, it creates it in memory with createTagFromTagName
-        ReaderTag tag = getDefaultTag();
-
-        if (tag.isDefaultInMemoryTag()) {
-            // if the tag was created in memory from createTagFromTagName
-            // we need to set some fields as below before to use it
-            tag.setTagTitle(context.getString(R.string.reader_subscribed_display_name));
-            tag.setTagDisplayName(context.getString(R.string.reader_subscribed_display_name));
-
-            String baseUrl = clientUtilsProvider.getTagUpdateEndpointURL();
-
-            if (baseUrl.endsWith("/")) {
-                baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
-            }
-
-            tag.setEndpoint(baseUrl + ReaderTag.FOLLOWING_PATH);
-        }
-
-        return tag;
-    }
-
-    /*
-     * used when storing search results in the reader post table
-     */
-    public static ReaderTag getTagForSearchQuery(@NonNull String query) {
-        String trimQuery = query != null ? query.trim() : "";
-        String slug = ReaderUtils.sanitizeWithDashes(trimQuery);
-        return new ReaderTag(slug, trimQuery, trimQuery, null, ReaderTagType.SEARCH);
-    }
-
-    public static Map<String, TagInfo> getDefaultTagInfo() {
-        // Note that the following is the desired order in the tabs
-        // (see usage in prependDefaults)
-        Map<String, TagInfo> defaultTagInfo = new LinkedHashMap<>();
-
-        defaultTagInfo.put(ReaderConstants.KEY_FOLLOWING, new TagInfo(ReaderTagType.DEFAULT, ReaderTag.FOLLOWING_PATH));
-        defaultTagInfo.put(ReaderConstants.KEY_DISCOVER, new TagInfo(ReaderTagType.DEFAULT, ReaderTag.DISCOVER_PATH));
-        defaultTagInfo.put(ReaderConstants.KEY_LIKES, new TagInfo(ReaderTagType.DEFAULT, ReaderTag.LIKED_PATH));
-        defaultTagInfo.put(ReaderConstants.KEY_SAVED, new TagInfo(ReaderTagType.BOOKMARKED, ""));
-
-        return defaultTagInfo;
-    }
-
-    private static boolean putIfAbsentDone(Map<String, ReaderTag> defaultTags, String key, ReaderTag tag) {
-        boolean insertionDone = false;
-
-        if (defaultTags.get(key) == null) {
-            defaultTags.put(key, tag);
-            insertionDone = true;
-        }
-
-        return insertionDone;
-    }
-
-    private static void prependDefaults(
-            Map<String, ReaderTag> defaultTags,
-            ReaderTagList orderedTagList,
-            Map<String, TagInfo> defaultTagInfo
-    ) {
-        if (defaultTags.isEmpty()) return;
-
-        List<String> reverseOrderedKeys = new ArrayList<>(defaultTagInfo.keySet());
-        Collections.reverse(reverseOrderedKeys);
-
-        for (String key : reverseOrderedKeys) {
-            if (defaultTags.containsKey(key)) {
-                ReaderTag tag = defaultTags.get(key);
-
-                orderedTagList.add(0, tag);
-            }
-        }
-    }
-
-    private static boolean defaultTagFoundAndAdded(
-            Map<String, TagInfo> defaultTagInfos,
-            ReaderTag tag,
-            Map<String, ReaderTag> defaultTags
-    ) {
-        boolean foundAndAdded = false;
-
-        for (String key : defaultTagInfos.keySet()) {
-            if (defaultTagInfos.get(key).isDesiredTag(tag)) {
-                if (putIfAbsentDone(defaultTags, key, tag)) {
-                    foundAndAdded = true;
-                }
-                break;
-            }
-        }
-
-        return foundAndAdded;
-    }
-
-    public static ReaderTagList getOrderedTagsList(ReaderTagList tagList, Map<String, TagInfo> defaultTagInfos) {
-        ReaderTagList orderedTagList = new ReaderTagList();
-        Map<String, ReaderTag> defaultTags = new HashMap<>();
-
-        for (ReaderTag tag : tagList) {
-            if (defaultTagFoundAndAdded(defaultTagInfos, tag, defaultTags)) continue;
-
-            orderedTagList.add(tag);
-        }
-        prependDefaults(defaultTags, orderedTagList, defaultTagInfos);
-
-        return orderedTagList;
-    }
-
-    public static boolean isTagManagedInFollowingTab(
-            ReaderTag tag,
-            boolean isTopLevelReader,
-            FilteredRecyclerView recyclerView
-    ) {
-        if (isTopLevelReader) {
-            if (ReaderUtils.isDefaultInMemoryTag(tag)) {
-                return true;
-            }
-
-            boolean isSpecialTag = tag != null
-                                   &&
-                                   (tag.isDiscover() || tag.isPostsILike() || tag.isBookmarked());
-
-            boolean tabsInitializingNow = recyclerView != null && recyclerView.getCurrentFilter() == null;
-
-            boolean tagIsFollowedSitesOrAFollowedTag = tag != null
-                                                       && (
-                                                               tag.isFollowedSites()
-                                                               || tag.tagType == ReaderTagType.FOLLOWED
-                                                       );
-
-            if (isSpecialTag) {
-                return false;
-            } else if (tabsInitializingNow) {
-                return tagIsFollowedSitesOrAFollowedTag;
-            } else if (recyclerView != null && recyclerView.getCurrentFilter() instanceof ReaderTag) {
-                if (recyclerView.isValidFilter(tag)) {
-                    return tag.isFollowedSites();
-                } else {
-                    // If we reach here it means we are setting a followed tag or site in the Following tab
-                    return true;
-                }
-            } else {
-                return false;
-            }
-        } else {
-            return tag != null && tag.isFollowedSites();
-        }
-    }
-
-    public static @NonNull ReaderTag getValidTagForSharedPrefs(
-            @NonNull ReaderTag tag,
-            boolean isTopLevelReader,
-            FilteredRecyclerView recyclerView,
-            @NonNull ReaderTag defaultTag
-    ) {
-        if (!isTopLevelReader) {
-            return tag;
-        }
-
-        boolean isValidFilter = (recyclerView != null && recyclerView.isValidFilter(tag));
-        boolean isSpecialTag = tag.isDiscover() || tag.isPostsILike() || tag.isBookmarked();
-        if (!isSpecialTag && !isValidFilter && isTagManagedInFollowingTab(tag, isTopLevelReader, recyclerView)) {
-            return defaultTag;
-        }
-
-        return tag;
-    }
-
-    public static boolean isDefaultInMemoryTag(ReaderTag tag) {
-        return tag != null && tag.isDefaultInMemoryTag();
-    }
-
-    public static String getCommaSeparatedTagSlugs(ReaderTagList tags) {
-        StringBuilder slugs = new StringBuilder();
-        for (ReaderTag tag : tags) {
-            if (slugs.length() > 0) {
-                slugs.append(",");
-            }
-            final String tagNameForApi = ReaderUtils.sanitizeWithDashes(tag.getTagSlug());
-            slugs.append(tagNameForApi);
-        }
-        return slugs.toString();
-    }
-
-    public static ReaderTagList getTagsFromCommaSeparatedSlugs(@NonNull String commaSeparatedTagSlugs) {
-        ReaderTagList tags = new ReaderTagList();
-        if (!commaSeparatedTagSlugs.trim().equals("")) {
-            for (String slug : commaSeparatedTagSlugs.split(",", -1)) {
-                ReaderTag tag = ReaderUtils.getTagFromTagName(slug, ReaderTagType.DEFAULT);
-                tags.add(tag);
-            }
-        }
-        return tags;
-    }
-
-    /**
-    * isExternalFeed identifies an external RSS feed
-     * blogId will be empty for feeds and in some instances, it is explicitly
-     * setting blogId equal to the feedId
-     */
-    public static boolean isExternalFeed(long blogId, long feedId) {
-         return (blogId == 0 && feedId != 0) || blogId == feedId;
-    }
-
-    public static String getReportPostUrl(String blogUrl) {
-        return "https://wordpress.com/abuse/?report_url=" + blogUrl;
-    }
-
-    public static String getReportUserUrl(String blogUrl, long userId) {
-        return getReportPostUrl(blogUrl) + "&report_user_id=" + userId;
-    }
-
-    public static boolean postExists(long blogId, long postId) {
-        return ReaderPostTable.postExists(blogId, postId);
-    }
-
-    public static boolean commentExists(long blogId, long postId, long commentId) {
-        return ReaderCommentTable.commentExists(blogId, postId, commentId);
-    }
-
-    /**
-     * Self-hosted sites have a site id of 0, but we use -1 to indicate a self-hosted site
-     * @param authorBlogId  site id of the post's author
-     */
-    public static boolean isSelfHosted(long authorBlogId) {
-        return authorBlogId < 1;
-    }
-}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.kt
new file mode 100644
index 000000000000..56768be4dfd0
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtils.kt
@@ -0,0 +1,605 @@
+package org.wordpress.android.ui.reader.utils
+
+import android.content.Context
+import org.apache.commons.text.StringEscapeUtils
+import org.wordpress.android.R
+import org.wordpress.android.datasets.ReaderCommentTable
+import org.wordpress.android.datasets.ReaderPostTable
+import org.wordpress.android.datasets.ReaderTagTable
+import org.wordpress.android.models.ReaderTag
+import org.wordpress.android.models.ReaderTagList
+import org.wordpress.android.models.ReaderTagType
+import org.wordpress.android.ui.FilteredRecyclerView
+import org.wordpress.android.ui.reader.ReaderConstants
+import org.wordpress.android.ui.reader.services.update.TagUpdateClientUtilsProvider
+import org.wordpress.android.util.FormatUtils
+import org.wordpress.android.util.PhotonUtils
+import org.wordpress.android.util.StringUtils
+import org.wordpress.android.util.UrlUtils
+import java.net.URI
+import androidx.core.net.toUri
+
+object ReaderUtils {
+    @JvmStatic
+    fun getResizedImageUrl(
+        imageUrl: String,
+        width: Int,
+        height: Int,
+        isPrivate: Boolean,
+        isPrivateAtomic: Boolean
+    ): String {
+        return getResizedImageUrl(
+            imageUrl = imageUrl,
+            width = width,
+            height = height,
+            isPrivate = isPrivate,
+            isPrivateAtomic = isPrivateAtomic,
+            quality = PhotonUtils.Quality.MEDIUM
+        )
+    }
+
+    @JvmStatic
+    @Suppress("LongParameterList")
+    fun getResizedImageUrl(
+        imageUrl: String,
+        width: Int,
+        height: Int,
+        isPrivate: Boolean,
+        isPrivateAtomic: Boolean,
+        quality: PhotonUtils.Quality
+    ): String {
+        val unescapedUrl = StringEscapeUtils.unescapeHtml4(imageUrl)
+        return if (isPrivate && !isPrivateAtomic) {
+            getImageForDisplayWithoutPhoton(
+                imageUrl = unescapedUrl,
+                width = width,
+                height = height,
+                forceHttps = true
+            )
+        } else {
+            PhotonUtils.getPhotonImageUrl(
+                unescapedUrl,
+                width,
+                height,
+                quality,
+                isPrivateAtomic
+            )
+        }
+    }
+
+    fun getResizedImageUrl(
+        imageUrl: String,
+        width: Int,
+        height: Int,
+        siteAccessibilityInfo: SiteAccessibilityInfo
+    ): String {
+        return getResizedImageUrl(
+            imageUrl = imageUrl,
+            width = width,
+            height = height,
+            siteAccessibilityInfo = siteAccessibilityInfo,
+            quality = PhotonUtils.Quality.MEDIUM
+        )
+    }
+
+    fun getResizedImageUrl(
+        imageUrl: String,
+        width: Int,
+        height: Int,
+        siteAccessibilityInfo: SiteAccessibilityInfo,
+        quality: PhotonUtils.Quality
+    ): String {
+        val unescapedUrl = StringEscapeUtils.unescapeHtml4(imageUrl)
+
+        return if (siteAccessibilityInfo.isPhotonCapable) {
+            PhotonUtils.getPhotonImageUrl(
+                unescapedUrl,
+                width,
+                height,
+                quality,
+                siteAccessibilityInfo.siteVisibility == SiteVisibility.PRIVATE_ATOMIC
+            )
+        } else {
+            getImageForDisplayWithoutPhoton(
+                imageUrl = unescapedUrl,
+                width = width,
+                height = height,
+                forceHttps = siteAccessibilityInfo.siteVisibility == SiteVisibility.PRIVATE
+            )
+        }
+    }
+
+    /*
+     * use this to request a reduced size image from not photon capable sites
+     * (i.e. a private post - images in private posts can't use photon
+     * but these are usually wp images so they support the h= and w= query params)
+     */
+    private fun getImageForDisplayWithoutPhoton(
+        imageUrl: String,
+        width: Int,
+        height: Int,
+        forceHttps: Boolean
+    ): String {
+        if (imageUrl.isEmpty()) {
+            return ""
+        }
+        val query = if (width > 0 && height > 0) {
+            "?w=$width&h=$height"
+        } else if (width > 0) {
+            "?w=$width"
+        } else if (height > 0) {
+            "?h=$height"
+        } else {
+            ""
+        }
+
+        return if (forceHttps) {
+            // remove the existing query string, add the new one, and make sure the url is https:
+            UrlUtils.removeQuery(UrlUtils.makeHttps(imageUrl)) + query
+        } else {
+            // remove the existing query string, add the new one
+            UrlUtils.removeQuery(imageUrl) + query
+        }
+    }
+
+    /*
+     * returns the passed string formatted for use with our API - see sanitize_title_with_dashes
+     * https://git.io/JqUEP
+     * http://stackoverflow.com/a/1612015/1673548
+     */
+    @JvmStatic
+    fun sanitizeWithDashes(title: String): String {
+        val trimmedTitle = title.trim()
+        return if (isValidUrlEncodedString(trimmedTitle)
+        ) {
+            trimmedTitle
+        } else {
+            trimmedTitle
+                .replace("&[^\\s]*;".toRegex(), "") // remove html entities
+                .replace("[\\.\\s]+".toRegex(), "-") // replace periods and whitespace with a dash
+                .replace(
+                    "[^\\p{L}\\p{Nd}\\-]+".toRegex(),
+                    ""
+                ) // remove remaining non-alphanumeric/non-dash chars (Unicode aware)
+                .replace("--".toRegex(), "-") // reduce double dashes potentially added above
+        }
+    }
+
+    @Suppress("SwallowedException")
+    private fun isValidUrlEncodedString(title: String): Boolean {
+        try {
+            URI.create(title)
+            return true
+        } catch (e: IllegalArgumentException) {
+            return false
+        }
+    }
+
+    /*
+     * returns the long text to use for a like label ("Liked by 3 people", etc.)
+     */
+    @JvmStatic
+    fun getLongLikeLabelText(
+        context: Context,
+        numLikes: Int,
+        isLikedByCurrentUser: Boolean
+    ): String {
+        return if (isLikedByCurrentUser) {
+            when (numLikes) {
+                1 -> context.getString(R.string.reader_likes_only_you)
+                2 -> context.getString(R.string.reader_likes_you_and_one)
+                else -> {
+                    val youAndMultiLikes = context.getString(R.string.reader_likes_you_and_multi)
+                    String.format(youAndMultiLikes, numLikes - 1)
+                }
+            }
+        } else if (numLikes == 1) {
+            context.getString(R.string.reader_likes_one)
+        } else {
+            val likes = context.getString(R.string.reader_likes_multi)
+            String.format(likes, numLikes)
+        }
+    }
+
+    /*
+     * short like text ("1 like," "5 likes," etc.)
+     */
+    @JvmStatic
+    fun getShortLikeLabelText(context: Context, numLikes: Int): String {
+        return when (numLikes) {
+            0 -> context.getString(R.string.reader_short_like_count_none)
+            1 -> context.getString(R.string.reader_short_like_count_one)
+            else -> {
+                val count = FormatUtils.formatInt(numLikes)
+                String.format(
+                    context.getString(R.string.reader_short_like_count_multi),
+                    count
+                )
+            }
+        }
+    }
+
+    fun getShortCommentLabelText(context: Context, numComments: Int): String {
+        return if (numComments == 1) {
+            context.getString(R.string.reader_short_comment_count_one)
+        } else {
+            val count = FormatUtils.formatInt(numComments)
+            String.format(context.getString(R.string.reader_short_comment_count_multi), count)
+        }
+    }
+
+    fun getTextForCommentSnippet(context: Context, numComments: Int): String {
+        return when (numComments) {
+            0 -> context.getString(R.string.comments)
+            1 -> context.getString(R.string.reader_short_comment_count_one)
+            else -> {
+                val count = FormatUtils.formatInt(numComments)
+                String.format(
+                    context.getString(R.string.reader_short_comment_count_multi),
+                    count
+                )
+            }
+        }
+    }
+
+    /*
+     * returns true if a ReaderPost and ReaderComment exist for the passed Ids
+     */
+    fun postAndCommentExists(blogId: Long, postId: Long, commentId: Long): Boolean {
+        return ReaderPostTable.postExists(blogId, postId)
+                && ReaderCommentTable.commentExists(blogId, postId, commentId)
+    }
+
+    /*
+     * used by Discover site picks to add a "Visit [BlogName]" link which shows the
+     * native blog preview for that blog
+     */
+    fun makeBlogPreviewUrl(blogId: Long): String {
+        return "wordpress://blogpreview?blogId=$blogId"
+    }
+
+    fun isBlogPreviewUrl(url: String): Boolean {
+        return url.startsWith("wordpress://blogpreview")
+    }
+
+    fun getBlogIdFromBlogPreviewUrl(url: String): Long {
+        if (isBlogPreviewUrl(url)) {
+            val strBlogId = url.toUri().getQueryParameter("blogId")
+            return StringUtils.stringToLong(strBlogId)
+        } else {
+            return 0
+        }
+    }
+
+    fun isTagUrl(url: String): Boolean {
+        return url.matches("^https?://wordpress\\.com/tag/[^/]+$".toRegex())
+    }
+
+    fun getTagFromTagUrl(url: String): String {
+        return if (isTagUrl(url)) {
+            url.substring(url.lastIndexOf("/") + 1)
+        } else {
+            ""
+        }
+    }
+
+    /*
+     * returns a tag object from the passed endpoint if tag is in database, otherwise null
+     */
+    fun getTagFromEndpoint(endpoint: String): ReaderTag? {
+        return ReaderTagTable.getTagFromEndpoint(endpoint)
+    }
+
+    /*
+     * returns a tag object from the passed tag name - first checks for it in the tag db
+     * (so we can also get its title & endpoint), returns a new tag if that fails
+     */
+    @JvmStatic
+    fun getTagFromTagName(
+        tagName: String,
+        tagType: ReaderTagType
+    ): ReaderTag {
+        return getTagFromTagName(
+            tagName = tagName,
+            tagType = tagType,
+            markDefaultIfInMemory = false
+        )
+    }
+
+    @JvmStatic
+    fun getTagFromTagName(
+        tagName: String,
+        tagType: ReaderTagType,
+        markDefaultIfInMemory: Boolean
+    ): ReaderTag {
+        val tag = ReaderTagTable.getTag(tagName, tagType)
+        return tag
+            ?: createTagFromTagName(
+                tagName = tagName,
+                tagType = tagType,
+                isDefaultInMemoryTag = markDefaultIfInMemory
+            )
+    }
+
+    @JvmOverloads
+    @JvmStatic
+    fun createTagFromTagName(
+        tagName: String,
+        tagType: ReaderTagType,
+        isDefaultInMemoryTag: Boolean = false
+    ): ReaderTag {
+        val tagSlug = sanitizeWithDashes(tagName).lowercase()
+        val tagDisplayName = if (tagType == ReaderTagType.DEFAULT) tagName else tagSlug
+        return ReaderTag(
+            tagSlug,
+            tagDisplayName,
+            tagName,
+            null,
+            tagType,
+            isDefaultInMemoryTag
+        )
+    }
+
+    /*
+     * returns the default tag, which is the one selected by default in the reader when
+     * the user hasn't already chosen one
+     */
+    fun getDefaultTag(): ReaderTag {
+        var defaultTag =
+            getTagFromEndpoint(ReaderTag.TAG_ENDPOINT_DEFAULT)
+        if (defaultTag == null) {
+            defaultTag = getTagFromTagName(
+                ReaderTag.TAG_TITLE_DEFAULT,
+                ReaderTagType.DEFAULT,
+                true
+            )
+        }
+        return defaultTag
+    }
+
+    fun getDefaultTagFromDbOrCreateInMemory(
+        context: Context,
+        clientUtilsProvider: TagUpdateClientUtilsProvider
+    ): ReaderTag {
+        // getDefaultTag() tries to get the default tag from reader db by tag endpoint or tag name.
+        // In case it cannot get the default tag from db, it creates it in memory with createTagFromTagName
+        val tag = getDefaultTag()
+
+        if (tag.isDefaultInMemoryTag) {
+            // if the tag was created in memory from createTagFromTagName
+            // we need to set some fields as below before to use it
+            tag.tagTitle =
+                context.getString(R.string.reader_subscribed_display_name)
+            tag.tagDisplayName =
+                context.getString(R.string.reader_subscribed_display_name)
+
+            var baseUrl = clientUtilsProvider.getTagUpdateEndpointURL()
+
+            if (baseUrl.endsWith("/")) {
+                baseUrl = baseUrl.substring(0, baseUrl.length - 1)
+            }
+
+            tag.endpoint = baseUrl + ReaderTag.FOLLOWING_PATH
+        }
+
+        return tag
+    }
+
+    /*
+     * used when storing search results in the reader post table
+     */
+    @JvmStatic
+    fun getTagForSearchQuery(query: String): ReaderTag {
+        val trimQuery = query.trim()
+        val slug = sanitizeWithDashes(trimQuery)
+        return ReaderTag(slug, trimQuery, trimQuery, null, ReaderTagType.SEARCH)
+    }
+
+    fun getDefaultTagInfo(): Map<String, TagInfo> {
+        // Note that the following is the desired order in the tabs
+        // (see usage in prependDefaults)
+        val defaultTagInfo: MutableMap<String, TagInfo> =
+            LinkedHashMap()
+
+        defaultTagInfo[ReaderConstants.KEY_FOLLOWING] =
+            TagInfo(ReaderTagType.DEFAULT, ReaderTag.FOLLOWING_PATH)
+        defaultTagInfo[ReaderConstants.KEY_DISCOVER] =
+            TagInfo(ReaderTagType.DEFAULT, ReaderTag.DISCOVER_PATH)
+        defaultTagInfo[ReaderConstants.KEY_LIKES] =
+            TagInfo(ReaderTagType.DEFAULT, ReaderTag.LIKED_PATH)
+        defaultTagInfo[ReaderConstants.KEY_SAVED] = TagInfo(ReaderTagType.BOOKMARKED, "")
+
+        return defaultTagInfo
+    }
+
+    private fun putIfAbsentDone(
+        defaultTags: MutableMap<String, ReaderTag>,
+        key: String,
+        tag: ReaderTag
+    ): Boolean {
+        var insertionDone = false
+
+        if (defaultTags[key] == null) {
+            defaultTags[key] = tag
+            insertionDone = true
+        }
+
+        return insertionDone
+    }
+
+    private fun prependDefaults(
+        defaultTags: Map<String, ReaderTag>,
+        orderedTagList: ReaderTagList,
+        defaultTagInfo: Map<String, TagInfo>
+    ) {
+        if (defaultTags.isEmpty()) return
+
+        val reverseOrderedKeys = ArrayList(defaultTagInfo.keys)
+        reverseOrderedKeys.reverse()
+
+        for (key in reverseOrderedKeys) {
+            if (defaultTags.containsKey(key)) {
+                val tag = defaultTags[key]
+                orderedTagList.add(0, tag)
+            }
+        }
+    }
+
+    private fun defaultTagFoundAndAdded(
+        defaultTagInfos: Map<String, TagInfo>,
+        tag: ReaderTag,
+        defaultTags: MutableMap<String, ReaderTag>
+    ): Boolean {
+        var foundAndAdded = false
+
+        for (key in defaultTagInfos.keys) {
+            if (defaultTagInfos[key]!!.isDesiredTag(tag)) {
+                if (putIfAbsentDone(defaultTags, key, tag)) {
+                    foundAndAdded = true
+                }
+                break
+            }
+        }
+
+        return foundAndAdded
+    }
+
+    fun getOrderedTagsList(
+        tagList: ReaderTagList,
+        defaultTagInfos: Map<String, TagInfo>
+    ): ReaderTagList {
+        val orderedTagList = ReaderTagList()
+        val defaultTags: MutableMap<String, ReaderTag> = HashMap()
+
+        for (tag in tagList) {
+            if (defaultTagFoundAndAdded(defaultTagInfos, tag, defaultTags)) {
+                continue
+            }
+            orderedTagList.add(tag)
+        }
+        prependDefaults(defaultTags, orderedTagList, defaultTagInfos)
+
+        return orderedTagList
+    }
+
+    @Suppress("ReturnCount")
+    fun isTagManagedInFollowingTab(
+        tag: ReaderTag,
+        isTopLevelReader: Boolean,
+        recyclerView: FilteredRecyclerView
+    ): Boolean {
+        if (isTopLevelReader) {
+            if (tag.isDefaultInMemoryTag) {
+                return true
+            }
+
+            val isSpecialTag = tag.isDiscover || tag.isPostsILike || tag.isBookmarked
+            val tabsInitializingNow = recyclerView.currentFilter == null
+            val tagIsFollowedSitesOrAFollowedTag =
+                tag.isFollowedSites || tag.tagType == ReaderTagType.FOLLOWED
+
+            return if (isSpecialTag) {
+                false
+            } else if (tabsInitializingNow) {
+                tagIsFollowedSitesOrAFollowedTag
+            } else if (recyclerView.currentFilter is ReaderTag) {
+                if (recyclerView.isValidFilter(tag)) {
+                    tag.isFollowedSites
+                } else {
+                    // If we reach here it means we are setting a followed tag or site in the Following tab
+                    true
+                }
+            } else {
+                false
+            }
+        } else {
+            return tag.isFollowedSites
+        }
+    }
+
+    @Suppress("ReturnCount")
+    fun getValidTagForSharedPrefs(
+        tag: ReaderTag,
+        isTopLevelReader: Boolean,
+        recyclerView: FilteredRecyclerView,
+        defaultTag: ReaderTag
+    ): ReaderTag {
+        if (!isTopLevelReader) {
+            return tag
+        }
+
+        val isValidFilter = recyclerView.isValidFilter(tag)
+        val isSpecialTag = tag.isDiscover || tag.isPostsILike || tag.isBookmarked
+        if (!isSpecialTag && !isValidFilter && isTagManagedInFollowingTab(
+                tag = tag,
+                isTopLevelReader = isTopLevelReader,
+                recyclerView = recyclerView
+            )
+        ) {
+            return defaultTag
+        }
+
+        return tag
+    }
+
+    @JvmStatic
+    fun getCommaSeparatedTagSlugs(tags: ReaderTagList): String {
+        val slugs = StringBuilder()
+        tags.forEach { tag ->
+            if (slugs.isNotEmpty()) {
+                slugs.append(",")
+            }
+            val tagNameForApi = sanitizeWithDashes(tag.tagSlug)
+            slugs.append(tagNameForApi)
+        }
+        return slugs.toString()
+    }
+
+    @JvmStatic
+    fun getTagsFromCommaSeparatedSlugs(commaSeparatedTagSlugs: String): ReaderTagList {
+        val tags = ReaderTagList()
+        if (commaSeparatedTagSlugs.trim().isNotEmpty()) {
+            val slugs = commaSeparatedTagSlugs.split(",".toRegex())
+            slugs.forEach { slug ->
+                val tag = getTagFromTagName(slug, ReaderTagType.DEFAULT)
+                tags.add(tag)
+            }
+        }
+        return tags
+    }
+
+    /**
+     * isExternalFeed identifies an external RSS feed
+     * blogId will be empty for feeds and in some instances, it is explicitly
+     * setting blogId equal to the feedId
+     */
+    @JvmStatic
+    fun isExternalFeed(blogId: Long, feedId: Long): Boolean {
+        return (blogId == 0L && feedId != 0L) || blogId == feedId
+    }
+
+    fun getReportPostUrl(blogUrl: String): String {
+        return "https://wordpress.com/abuse/?report_url=$blogUrl"
+    }
+
+    fun getReportUserUrl(blogUrl: String, userId: Long): String {
+        return getReportPostUrl(blogUrl) + "&report_user_id=" + userId
+    }
+
+    fun postExists(blogId: Long, postId: Long): Boolean {
+        return ReaderPostTable.postExists(blogId, postId)
+    }
+
+    fun commentExists(blogId: Long, postId: Long, commentId: Long): Boolean {
+        return ReaderCommentTable.commentExists(blogId, postId, commentId)
+    }
+
+    /**
+     * Self-hosted sites have a site id of 0, but we use -1 to indicate a self-hosted site
+     *
+     * @param authorBlogId site id of the post's author
+     */
+    fun isSelfHosted(authorBlogId: Long): Boolean {
+        return authorBlogId < 1
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtilsWrapper.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtilsWrapper.kt
index aacaf2d52eae..9643c91019c1 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtilsWrapper.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderUtilsWrapper.kt
@@ -18,15 +18,15 @@ class ReaderUtilsWrapper @Inject constructor(
     private val contextProvider: ContextProvider,
     private val tagUpdateClientUtilsProvider: TagUpdateClientUtilsProvider
 ) {
-    fun getResizedImageUrl(imageUrl: String?, width: Int, height: Int, isPrivate: Boolean, isAtomic: Boolean): String? =
+    fun getResizedImageUrl(imageUrl: String, width: Int, height: Int, isPrivate: Boolean, isAtomic: Boolean): String =
         ReaderUtils.getResizedImageUrl(imageUrl, width, height, isPrivate, isAtomic)
 
     fun getResizedImageUrl(
-        imageUrl: String?,
+        imageUrl: String,
         width: Int,
         height: Int,
         siteAccessibilityInfo: SiteAccessibilityInfo
-    ): String? = ReaderUtils.getResizedImageUrl(imageUrl, width, height, siteAccessibilityInfo)
+    ): String = ReaderUtils.getResizedImageUrl(imageUrl, width, height, siteAccessibilityInfo)
 
     fun getTagFromTagName(tagName: String, tagType: ReaderTagType): ReaderTag =
         ReaderUtils.getTagFromTagName(tagName, tagType)
@@ -55,7 +55,7 @@ class ReaderUtilsWrapper @Inject constructor(
         commentId: Long
     ) = ReaderUtils.commentExists(blogId, postId, commentId)
 
-    fun getTextForCommentSnippet(numComments: Int): String? = ReaderUtils.getTextForCommentSnippet(
+    fun getTextForCommentSnippet(numComments: Int): String = ReaderUtils.getTextForCommentSnippet(
         contextProvider.getContext(),
         numComments
     )
diff --git a/WordPress/src/main/java/org/wordpress/android/viewmodel/posts/PostListViewModel.kt b/WordPress/src/main/java/org/wordpress/android/viewmodel/posts/PostListViewModel.kt
index 2d4e25ae1a2a..6f06e71d321f 100644
--- a/WordPress/src/main/java/org/wordpress/android/viewmodel/posts/PostListViewModel.kt
+++ b/WordPress/src/main/java/org/wordpress/android/viewmodel/posts/PostListViewModel.kt
@@ -401,7 +401,7 @@ class PostListViewModel @Inject constructor(
 
     private fun convertToPhotonUrlIfPossible(featuredImageUrl: String?): String? =
         readerUtilsWrapper.getResizedImageUrl(
-            featuredImageUrl,
+            featuredImageUrl.orEmpty(),
             photonWidth,
             photonHeight,
             SiteUtils.getAccessibilityInfoFromSite(connector.site)
diff --git a/WordPress/src/test/java/org/wordpress/android/ui/reader/utils/ReaderUtilsTest.kt b/WordPress/src/test/java/org/wordpress/android/ui/reader/utils/ReaderUtilsTest.kt
index 62ba038adb61..4ef50d2abffd 100644
--- a/WordPress/src/test/java/org/wordpress/android/ui/reader/utils/ReaderUtilsTest.kt
+++ b/WordPress/src/test/java/org/wordpress/android/ui/reader/utils/ReaderUtilsTest.kt
@@ -65,9 +65,9 @@ class ReaderUtilsTest {
     @Test
     fun `isFollowing is based on currentTag status if is not top level reader`() {
         whenever(currentTag.isFollowedSites).thenReturn(true)
-        assertThat(ReaderUtils.isTagManagedInFollowingTab(currentTag, false, null)).isEqualTo(true)
+        assertThat(ReaderUtils.isTagManagedInFollowingTab(currentTag, false, filteredRecyclerView)).isEqualTo(true)
         whenever(currentTag.isFollowedSites).thenReturn(false)
-        assertThat(ReaderUtils.isTagManagedInFollowingTab(currentTag, false, null)).isEqualTo(false)
+        assertThat(ReaderUtils.isTagManagedInFollowingTab(currentTag, false, filteredRecyclerView)).isEqualTo(false)
     }
 
     @Test
