diff --git a/WordPress/src/main/java/org/wordpress/android/ui/ActivityLauncherWrapper.kt b/WordPress/src/main/java/org/wordpress/android/ui/ActivityLauncherWrapper.kt
new file mode 100644
index 000000000000..e4f76bda4a59
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/ActivityLauncherWrapper.kt
@@ -0,0 +1,31 @@
+package org.wordpress.android.ui
+
+import android.app.Activity
+import android.content.Context
+import org.wordpress.android.fluxc.model.PostModel
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.ui.posts.RemotePreviewLogicHelper.RemotePreviewType
+import javax.inject.Inject
+import javax.inject.Singleton
+
+/**
+ * Injectable wrapper around ActivityLauncher.
+ *
+ * ActivityLauncher interface is consisted of static methods, which make the client code difficult to test/mock.
+ * Main purpose of this wrapper is to make testing easier.
+ *
+ */
+@Singleton
+class ActivityLauncherWrapper @Inject constructor() {
+    fun showActionableEmptyView(
+        context: Context,
+        actionableState: WPWebViewActivity.ActionableReusableState
+    ) = ActivityLauncher.showActionableEmptyView(context, actionableState)
+
+    fun previewPostOrPageForResult(
+        activity: Activity,
+        site: SiteModel,
+        post: PostModel,
+        remotePreviewType: RemotePreviewType
+    ) = ActivityLauncher.previewPostOrPageForResult(activity, site, post, remotePreviewType)
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.java b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.java
index 39f14e5ec303..ec471e6b6fb9 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.java
+++ b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.java
@@ -130,6 +130,7 @@
 import org.wordpress.android.ui.posts.PostEditorAnalyticsSession.Editor;
 import org.wordpress.android.ui.posts.PostEditorAnalyticsSession.Outcome;
 import org.wordpress.android.ui.posts.PromoDialog.PromoDialogClickInterface;
+import org.wordpress.android.ui.posts.RemotePreviewLogicHelper.PreviewLogicOperationResult;
 import org.wordpress.android.ui.posts.services.AztecImageLoader;
 import org.wordpress.android.ui.posts.services.AztecVideoLoader;
 import org.wordpress.android.ui.prefs.AppPrefs;
@@ -397,12 +398,18 @@ public static PostLoadingState fromInt(int value) {
     @Inject ZendeskHelper mZendeskHelper;
     @Inject ImageManager mImageManager;
     @Inject UiHelpers mUiHelpers;
+    @Inject RemotePreviewLogicHelper mRemotePreviewLogicHelper;
 
     private SiteModel mSite;
 
     // for keeping the media uri while asking for permissions
     private ArrayList<Uri> mDroppedMediaUris;
 
+    private boolean isRemotePreviewing() {
+        return (mPostLoadingState == PostLoadingState.UPLOADING_FOR_PREVIEW
+                || mPostLoadingState == PostLoadingState.REMOTE_AUTO_SAVING_FOR_PREVIEW);
+    }
+
     private boolean isModernEditor() {
         return mShowNewEditor || mShowAztecEditor || mShowGutenbergEditor;
     }
@@ -1195,7 +1202,6 @@ public boolean onPrepareOptionsMenu(Menu menu) {
             showMenuItems = false;
         }
 
-
         MenuItem saveAsDraftMenuItem = menu.findItem(R.id.menu_save_as_draft_or_publish);
         MenuItem previewMenuItem = menu.findItem(R.id.menu_preview_post);
         MenuItem viewHtmlModeMenuItem = menu.findItem(R.id.menu_html_mode);
@@ -1356,6 +1362,70 @@ private boolean handleBackPressed() {
         return true;
     }
 
+    private RemotePreviewLogicHelper.RemotePreviewHelperFunctions getEditPostActivityStrategyFunctions() {
+       return new RemotePreviewLogicHelper.RemotePreviewHelperFunctions() {
+            @Override
+            public boolean isNewPost() {
+                return EditPostActivity.this.isNewPost();
+            }
+
+            @Override
+            public void notifyNoNetwork() {
+                UploadUtils.showSnackbar(findViewById(R.id.editor_activity), R.string.no_network_message);
+            }
+
+            @Override
+            public boolean notifyUploadInProgress(PostModel post) {
+                if (UploadService.hasInProgressMediaUploadsForPost(post)) {
+                    ToastUtils.showToast(EditPostActivity.this,
+                            getString(R.string.editor_toast_uploading_please_wait), Duration.SHORT);
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            @Nullable
+            @Override
+            public PostModel updatePostIfNeeded() {
+                updatePostObject();
+                return mPost;
+            }
+
+            @Override
+            public boolean canDiscard() {
+                return isDiscardable();
+            }
+
+            @Override
+            public void notifyEmptyDraft() {
+                ToastUtils.showToast(EditPostActivity.this,
+                        getString(R.string.error_preview_empty_draft), Duration.SHORT);
+            }
+
+            @Override
+            public void startUploading(boolean isRemoteAutoSave, @Nullable PostModel post) {
+                if (isRemoteAutoSave) {
+                    updatePostLoadingAndDialogState(PostLoadingState.REMOTE_AUTO_SAVING_FOR_PREVIEW, post);
+                    savePostAndOptionallyFinish(false, true);
+                } else {
+                    updatePostLoadingAndDialogState(PostLoadingState.UPLOADING_FOR_PREVIEW, post);
+                    savePostAndOptionallyFinish(false);
+                }
+            }
+
+            @Override
+            public void notifyEmptyPost() {
+                String message = getString(
+                        mIsPage
+                                ? R.string.error_preview_empty_page
+                                : R.string.error_preview_empty_post
+                );
+                ToastUtils.showToast(EditPostActivity.this, message, Duration.SHORT);
+            }
+        };
+    }
+
     // Menu actions
     @Override
     public boolean onOptionsItemSelected(final MenuItem item) {
@@ -1387,7 +1457,27 @@ public boolean onOptionsItemSelected(final MenuItem item) {
                 ActivityUtils.hideKeyboard(this);
                 mViewPager.setCurrentItem(PAGE_HISTORY);
             } else if (itemId == R.id.menu_preview_post) {
-                mViewPager.setCurrentItem(PAGE_PREVIEW);
+                if (mPost.isPage()) {
+                    mViewPager.setCurrentItem(PAGE_PREVIEW);
+                } else {
+                    PreviewLogicOperationResult opResult =
+                            mRemotePreviewLogicHelper.runPostPreviewLogic(
+                            this,
+                            mSite,
+                            mPost,
+                            getEditPostActivityStrategyFunctions()
+                    );
+
+                    if (
+                            opResult == PreviewLogicOperationResult.MEDIA_UPLOAD_IN_PROGRESS
+                            || opResult == PreviewLogicOperationResult.CANNOT_SAVE_EMPTY_DRAFT
+                            || opResult == PreviewLogicOperationResult.CANNOT_REMOTE_AUTO_SAVE_EMPTY_POST
+                    ) {
+                        return false;
+                    } else if (opResult == PreviewLogicOperationResult.OPENING_PREVIEW) {
+                        updatePostLoadingAndDialogState(PostLoadingState.PREVIEWING, mPost);
+                    }
+                }
             } else if (itemId == R.id.menu_post_settings) {
                 if (mEditPostSettingsFragment != null) {
                     mEditPostSettingsFragment.refreshViews();
@@ -1592,11 +1682,16 @@ private void showGutenbergInformativeDialog() {
         }
     }
 
+    private void savePostOnlineAndFinishAsync(boolean isFirstTimePublish, boolean doFinishActivity) {
+        savePostOnlineAndFinishAsync(isFirstTimePublish, doFinishActivity, false);
+    }
+
     private void savePostOnlineAndFinishAsync(
             boolean isFirstTimePublish,
-            boolean doFinishActivity
+            boolean doFinishActivity,
+            boolean isRemoteAutoSave
     ) {
-        new SavePostOnlineAndFinishTask(isFirstTimePublish, doFinishActivity)
+        new SavePostOnlineAndFinishTask(isFirstTimePublish, doFinishActivity, isRemoteAutoSave)
                 .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
@@ -1950,10 +2045,12 @@ private boolean userCanPublishPosts() {
     private class SavePostOnlineAndFinishTask extends AsyncTask<Void, Void, Void> {
         boolean mIsFirstTimePublish;
         boolean mDoFinishActivity;
+        boolean mIsRemoteAutoSave;
 
-        SavePostOnlineAndFinishTask(boolean isFirstTimePublish, boolean doFinishActivity) {
+        SavePostOnlineAndFinishTask(boolean isFirstTimePublish, boolean doFinishActivity, boolean isRemoteAutoSave) {
             this.mIsFirstTimePublish = isFirstTimePublish;
             this.mDoFinishActivity = doFinishActivity;
+            this.mIsRemoteAutoSave = isRemoteAutoSave;
         }
 
         @Override
@@ -1971,9 +2068,9 @@ protected Void doInBackground(Void... params) {
 
             UploadService.setLegacyMode(!isModernEditor());
             if (mIsFirstTimePublish) {
-                UploadService.uploadPostAndTrackAnalytics(EditPostActivity.this, mPost);
+                UploadService.uploadPostAndTrackAnalytics(EditPostActivity.this, mPost, mIsRemoteAutoSave);
             } else {
-                UploadService.uploadPost(EditPostActivity.this, mPost);
+                UploadService.uploadPost(EditPostActivity.this, mPost, mIsRemoteAutoSave);
             }
 
             PendingDraftsNotificationsUtils.cancelPendingDraftAlarms(EditPostActivity.this, mPost.getId());
@@ -2170,6 +2267,10 @@ private void showRemoveFailedUploadsDialog() {
     }
 
     private void savePostAndOptionallyFinish(final boolean doFinish) {
+        savePostAndOptionallyFinish(doFinish, false);
+    }
+
+    private void savePostAndOptionallyFinish(final boolean doFinish, final boolean isRemoteAutoSave) {
         // Update post, save to db and post online in its own Thread, because 1. update can be pretty slow with a lot of
         // text 2. better not to call `updatePostObject()` from the UI thread due to weird thread blocking behavior
         // on API 16 (and 21) with the visual editor.
@@ -2189,7 +2290,7 @@ public void run() {
                 boolean isPublishable = PostUtils.isPublishable(mPost);
 
                 // if post was modified or has unpublished local changes, save it
-                boolean shouldSave = shouldSavePost();
+                boolean shouldSave = shouldSavePost() || isRemoteAutoSave;
 
                 // if post is publishable or not new, sync it
                 boolean shouldSync = isPublishable || !isNewPost();
@@ -2203,13 +2304,19 @@ public void run() {
                 if (shouldSave) {
                     PostStatus status = PostStatus.fromPost(mPost);
                     boolean isNotRestarting = mRestartEditorOption == RestartEditorOptions.NO_RESTART;
-                    if ((status == PostStatus.DRAFT || status == PostStatus.PENDING) && isPublishable
-                        && !hasFailedMedia() && NetworkUtils.isNetworkAvailable(getBaseContext()) && isNotRestarting) {
+                    if ((status == PostStatus.DRAFT || status == PostStatus.PENDING
+                            || (isRemotePreviewing() && status == PostStatus.SCHEDULED)) && isPublishable
+                            && !hasFailedMedia() && NetworkUtils.isNetworkAvailable(getBaseContext())
+                            && isNotRestarting) {
                         mPostEditorAnalyticsSession.setOutcome(Outcome.SAVE);
-                        savePostOnlineAndFinishAsync(isFirstTimePublish, doFinish);
+                        savePostOnlineAndFinishAsync(isFirstTimePublish, doFinish, isRemoteAutoSave);
                     } else {
                         mPostEditorAnalyticsSession.setOutcome(Outcome.SAVE);
-                        savePostLocallyAndFinishAsync(doFinish);
+                        if (isRemoteAutoSave) {
+                            savePostOnlineAndFinishAsync(false, false, isRemoteAutoSave);
+                        } else {
+                            savePostLocallyAndFinishAsync(doFinish);
+                        }
                     }
                 } else {
                     // discard post if new & empty
@@ -3053,6 +3160,13 @@ public void run() {
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
 
+        // In case of Remote Preview we need to change state even if (resultCode != Activity.RESULT_OK)
+        // so placing this here before the check
+        if (requestCode == RequestCodes.REMOTE_PREVIEW_POST) {
+            updatePostLoadingAndDialogState(PostLoadingState.NONE);
+            return;
+        }
+
         if (resultCode != Activity.RESULT_OK) {
             return;
         }
@@ -4009,21 +4123,59 @@ public void onPostChanged(OnPostChanged event) {
                 updatePostLoadingAndDialogState(PostLoadingState.NONE);
                 AppLog.e(AppLog.T.POSTS, "UPDATE_POST failed: " + event.error.type + " - " + event.error.message);
             }
+        } else if (event.causeOfChange instanceof CauseOfOnPostChanged.RemoteAutoSavePost) {
+            if (!event.isError()) {
+                mPost = mPostStore.getPostByLocalPostId(mPost.getId());
+            } else {
+                AppLog.e(T.POSTS, "REMOTE_AUTO_SAVE_POST failed: " + event.error.type + " - " + event.error.message);
+                updatePostLoadingAndDialogState(PostLoadingState.REMOTE_AUTO_SAVE_PREVIEW_ERROR, mPost);
+            }
+            RemotePostPayload payload = new RemotePostPayload(mPost, mSite);
+            mDispatcher.dispatch(UploadActionBuilder.newPushedPostAction(payload));
         }
     }
 
+
     @SuppressWarnings("unused")
     @Subscribe(threadMode = ThreadMode.MAIN)
     public void onPostUploaded(OnPostUploaded event) {
         final PostModel post = event.post;
         if (post != null && post.getId() == mPost.getId()) {
-            View snackbarAttachView = findViewById(R.id.editor_activity);
-            UploadUtils.onPostUploadedSnackbarHandler(this, snackbarAttachView, event.isError(), post,
-                    event.isError() ? event.error.message : null, getSite(), mDispatcher);
-            if (!event.isError()) {
-                mPost = post;
-                mIsNewPost = false;
-                invalidateOptionsMenu();
+            if (!(mPostLoadingState == PostLoadingState.UPLOADING_FOR_PREVIEW)
+                    && !(mPostLoadingState == PostLoadingState.REMOTE_AUTO_SAVING_FOR_PREVIEW)
+                    && !(mPostLoadingState == PostLoadingState.PREVIEWING)
+                    && !(mPostLoadingState == PostLoadingState.REMOTE_AUTO_SAVE_PREVIEW_ERROR)
+            ) {
+                View snackbarAttachView = findViewById(R.id.editor_activity);
+                UploadUtils.onPostUploadedSnackbarHandler(this, snackbarAttachView, event.isError(), post,
+                        event.isError() ? event.error.message : null, getSite(), mDispatcher);
+                if (!event.isError()) {
+                    mPost = post;
+                    mIsNewPost = false;
+                    invalidateOptionsMenu();
+                }
+            } else {
+                if (!event.isError()
+                        && !(mPostLoadingState == PostLoadingState.PREVIEWING)
+                        && !(mPostLoadingState == PostLoadingState.REMOTE_AUTO_SAVE_PREVIEW_ERROR)
+                ) {
+                    mPost = post;
+                    mIsNewPost = false;
+                    invalidateOptionsMenu();
+                    ActivityLauncher.previewPostOrPageForResult(
+                            EditPostActivity.this,
+                            mSite,
+                            mPost,
+                            mPostLoadingState == PostLoadingState.UPLOADING_FOR_PREVIEW
+                                    ? RemotePreviewLogicHelper.RemotePreviewType.REMOTE_PREVIEW
+                                    : RemotePreviewLogicHelper.RemotePreviewType.REMOTE_PREVIEW_WITH_REMOTE_AUTO_SAVE
+                            );
+                    updatePostLoadingAndDialogState(PostLoadingState.PREVIEWING, mPost);
+                } else if (event.isError() || (mPostLoadingState == PostLoadingState.REMOTE_AUTO_SAVE_PREVIEW_ERROR)) {
+                    updatePostLoadingAndDialogState(PostLoadingState.NONE);
+                    UploadUtils.showSnackbarError(findViewById(R.id.editor_activity),
+                            getString(R.string.remote_preview_operation_error));
+                }
             }
         }
     }
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/posts/RemotePreviewLogicHelper.kt b/WordPress/src/main/java/org/wordpress/android/ui/posts/RemotePreviewLogicHelper.kt
index 443d21d631ae..710e16f83a96 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/posts/RemotePreviewLogicHelper.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/posts/RemotePreviewLogicHelper.kt
@@ -1,13 +1,103 @@
 package org.wordpress.android.ui.posts
 
+import android.app.Activity
+import org.wordpress.android.fluxc.model.PostModel
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.ui.WPWebViewActivity
+import org.wordpress.android.fluxc.model.post.PostStatus
+import org.wordpress.android.ui.ActivityLauncherWrapper
+import org.wordpress.android.util.NetworkUtilsWrapper
 import javax.inject.Inject
 import javax.inject.Singleton
 
 @Singleton
-class RemotePreviewLogicHelper @Inject constructor() {
+class RemotePreviewLogicHelper @Inject constructor(
+    private val networkUtilsWrapper: NetworkUtilsWrapper,
+    private val activityLauncherWrapper: ActivityLauncherWrapper
+) {
     enum class RemotePreviewType {
         NOT_A_REMOTE_PREVIEW,
         REMOTE_PREVIEW,
         REMOTE_PREVIEW_WITH_REMOTE_AUTO_SAVE
     }
+
+    enum class PreviewLogicOperationResult {
+        PREVIEW_NOT_AVAILABLE,
+        NETWORK_NOT_AVAILABLE,
+        MEDIA_UPLOAD_IN_PROGRESS,
+        CANNOT_SAVE_EMPTY_DRAFT,
+        GENERATING_PREVIEW,
+        OPENING_PREVIEW,
+        CANNOT_REMOTE_AUTO_SAVE_EMPTY_POST
+    }
+
+    interface RemotePreviewHelperFunctions {
+        fun isNewPost() = false
+        fun notifyNoNetwork()
+        fun notifyUploadInProgress(post: PostModel): Boolean
+        fun updatePostIfNeeded(): PostModel? = null
+        fun canDiscard(): Boolean = false
+        fun notifyEmptyDraft() {}
+        fun startUploading(isRemoteAutoSave: Boolean, post: PostModel)
+        fun notifyEmptyPost() {}
+    }
+
+    fun runPostPreviewLogic(
+        activity: Activity,
+        site: SiteModel,
+        post: PostModel,
+        helperFunctions: RemotePreviewHelperFunctions
+    ): PreviewLogicOperationResult {
+        if (!site.isUsingWpComRestApi) {
+            activityLauncherWrapper.showActionableEmptyView(
+                    activity,
+                    WPWebViewActivity.ActionableReusableState.REMOTE_PREVIEW_NOT_AVAILABLE
+            )
+            return PreviewLogicOperationResult.PREVIEW_NOT_AVAILABLE
+        } else if (!networkUtilsWrapper.isNetworkAvailable()) {
+            helperFunctions.notifyNoNetwork()
+            return PreviewLogicOperationResult.NETWORK_NOT_AVAILABLE
+        } else {
+            if (helperFunctions.notifyUploadInProgress(post)) {
+                return PreviewLogicOperationResult.MEDIA_UPLOAD_IN_PROGRESS
+            }
+
+            val updatedPost = helperFunctions.updatePostIfNeeded() ?: post
+
+            if (shouldSave(helperFunctions::isNewPost, updatedPost)) {
+                if (helperFunctions.canDiscard()) {
+                    helperFunctions.notifyEmptyDraft()
+                    return PreviewLogicOperationResult.CANNOT_SAVE_EMPTY_DRAFT
+                }
+
+                helperFunctions.startUploading(false, updatedPost)
+            } else if (shouldRemoteAutoSave(helperFunctions::isNewPost, updatedPost)) {
+                if (helperFunctions.canDiscard()) {
+                    helperFunctions.notifyEmptyPost()
+                    return PreviewLogicOperationResult.CANNOT_REMOTE_AUTO_SAVE_EMPTY_POST
+                }
+                helperFunctions.startUploading(true, updatedPost)
+            } else {
+                activityLauncherWrapper.previewPostOrPageForResult(
+                        activity,
+                        site,
+                        updatedPost,
+                        RemotePreviewType.REMOTE_PREVIEW
+                )
+                return PreviewLogicOperationResult.OPENING_PREVIEW
+            }
+        }
+        return PreviewLogicOperationResult.GENERATING_PREVIEW
+    }
+
+    private fun shouldSave(isNewPost: () -> Boolean, post: PostModel): Boolean {
+        val status = PostStatus.fromPost(post)
+        return (isNewPost() || post.isLocalDraft ||
+                ((status == PostStatus.DRAFT || status == PostStatus.SCHEDULED) && post.isLocallyChanged))
+    }
+
+    private fun shouldRemoteAutoSave(isNewPost: () -> Boolean, post: PostModel): Boolean {
+        val status = PostStatus.fromPost(post)
+        return (!isNewPost() && (status == PostStatus.PUBLISHED) && post.isLocallyChanged)
+    }
 }
\ No newline at end of file
diff --git a/WordPress/src/main/res/values/strings.xml b/WordPress/src/main/res/values/strings.xml
index cd9aec184c4e..7447f2806ac0 100644
--- a/WordPress/src/main/res/values/strings.xml
+++ b/WordPress/src/main/res/values/strings.xml
@@ -1454,8 +1454,12 @@
     <!-- Post Remote Preview -->
     <string name="post_preview_saving_draft">Saving&#8230;</string>
     <string name="post_preview_remote_auto_saving_post">Generating Preview&#8230;</string>
+    <string name="remote_preview_operation_error">Error during remote preview preparation.\nPlease try again.</string>
     <string name="preview_unavailable_self_hosted_sites">Preview Unavailable</string>
-    
+    <string name="error_preview_empty_post">Can\'t preview an empty post</string>
+    <string name="error_preview_empty_page">Can\'t preview an empty page</string>
+    <string name="error_preview_empty_draft">Can\'t preview an empty draft</string>
+
     <!-- message on post preview explaining what local changes, local drafts and drafts are -->
     <string name="local_changes_explainer">This post has local changes which haven\'t been published</string>
     <string name="local_draft_explainer">This post is a local draft which hasn\'t been published</string>
