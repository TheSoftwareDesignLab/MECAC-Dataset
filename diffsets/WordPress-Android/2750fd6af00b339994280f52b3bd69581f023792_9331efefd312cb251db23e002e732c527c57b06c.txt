diff --git a/WordPressUtils/build.gradle b/WordPressUtils/build.gradle
index 367730e2f5ec..60f4e40adee4 100644
--- a/WordPressUtils/build.gradle
+++ b/WordPressUtils/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.1'
+        classpath 'com.android.tools.build:gradle:2.3.2'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
@@ -18,7 +18,7 @@ repositories {
 dependencies {
     compile 'org.apache.commons:commons-lang3:3.5'
     compile 'com.mcxiaoke.volley:library:1.0.18'
-    compile 'com.android.support:support-v13:25.1.1'
+    compile 'com.android.support:support-v13:25.3.1'
 }
 
 android {
@@ -27,10 +27,10 @@ android {
     publishNonDefault true
 
     compileSdkVersion 25
-    buildToolsVersion "25.0.2"
+    buildToolsVersion "25.0.3"
 
     defaultConfig {
-        versionName "1.15.0"
+        versionName "1.17.0"
         minSdkVersion 14
         targetSdkVersion 25
     }
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/AppLog.java b/WordPressUtils/src/main/java/org/wordpress/android/util/AppLog.java
index 1b05a2fd2abc..b0f0975c181d 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/AppLog.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/AppLog.java
@@ -305,7 +305,7 @@ public static ArrayList<String> toHtmlList(Context context) {
      * @param context
      * @return The log as plain text
      */
-    public static String toPlainText(Context context) {
+    public synchronized static String toPlainText(Context context) {
         StringBuilder sb = new StringBuilder();
 
         // add version & device info
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/HtmlUtils.java b/WordPressUtils/src/main/java/org/wordpress/android/util/HtmlUtils.java
index b510a5cb86c4..f8846de31a2f 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/HtmlUtils.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/HtmlUtils.java
@@ -132,6 +132,7 @@ public static String stripScript(final String text) {
      * @param  wpImageGetter
      */
     public static SpannableStringBuilder fromHtml(String source, WPImageGetter wpImageGetter) {
+        source = replaceListTagsWithCustomTags(source);
         SpannableStringBuilder html;
         try {
             html = (SpannableStringBuilder) Html.fromHtml(source, wpImageGetter, new WPHtmlTagHandler());
@@ -150,6 +151,15 @@ public static SpannableStringBuilder fromHtml(String source, WPImageGetter wpIma
         return html;
     }
 
+    private static String replaceListTagsWithCustomTags(String source) {
+        return source.replace("<ul", "<WPUL")
+                .replace("</ul>", "</WPUL>")
+                .replace("<ol", "<WPOL")
+                .replace("</ol>", "</WPOL>")
+                .replace("<li", "<WPLI")
+                .replace("</li>", "</WPLI>");
+    }
+
     public static Spanned fromHtml(String source) {
         return fromHtml(source, null);
     }
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/ImageUtils.java b/WordPressUtils/src/main/java/org/wordpress/android/util/ImageUtils.java
index cd681f4a56e1..47ddc9b4409a 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/ImageUtils.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/ImageUtils.java
@@ -74,6 +74,10 @@ public static int[] getImageSize(Uri uri, Context context){
 
     // Read the orientation from ContentResolver. If it fails, read from EXIF.
     public static int getImageOrientation(Context ctx, String filePath) {
+        if (TextUtils.isEmpty(filePath) || ctx == null) {
+            AppLog.w(AppLog.T.UTILS, "Can't read orientation. Passed context or file is null or empty.");
+            return 0;
+        }
         Uri curStream;
         int orientation = 0;
 
@@ -94,7 +98,7 @@ public static int getImageOrientation(Context ctx, String filePath) {
                 cur.close();
             }
         } catch (Exception errReadingContentResolver) {
-            AppLog.e(AppLog.T.UTILS, errReadingContentResolver);
+            AppLog.e(AppLog.T.UTILS, "Error reading orientation of the file: " + filePath, errReadingContentResolver);
         }
 
         if (orientation == 0) {
@@ -106,11 +110,15 @@ public static int getImageOrientation(Context ctx, String filePath) {
 
 
     public static int getExifOrientation(String path) {
+        if (TextUtils.isEmpty(path)) {
+            AppLog.w(AppLog.T.UTILS, "Can't read EXIF orientation. Passed path is empty.");
+            return 0;
+        }
         ExifInterface exif;
         try {
             exif = new ExifInterface(path);
         } catch (IOException e) {
-            AppLog.e(AppLog.T.UTILS, e);
+            AppLog.e(AppLog.T.UTILS, "Can't read EXIF orientation.", e);
             return 0;
         }
 
@@ -329,12 +337,7 @@ public static Bitmap getWPImageSpanThumbnailFromFilePath(Context context, String
             return null;
         }
 
-        Uri curUri;
-        if (!filePath.contains("content://")) {
-            curUri = Uri.parse("content://media" + filePath);
-        } else {
-            curUri = Uri.parse(filePath);
-        }
+        Uri curUri = Uri.parse(filePath);
 
         if (filePath.contains("video")) {
             // Load the video thumbnail from the MediaStore
@@ -399,37 +402,6 @@ public static Bitmap getScaledBitmapAtLongestSide(Bitmap bitmap, int targetSize)
         return Bitmap.createScaledBitmap(bitmap, targetWidth, targetHeight, true);
     }
 
-    private static String getRealFilePath(Context context, Uri imageUri) {
-        if (context == null || imageUri == null) {
-            return null;
-        }
-
-        String filePath = null;
-        if (imageUri.toString().contains("content:")) {
-            String[] projection = new String[] { MediaStore.Images.Media.DATA };
-            Cursor cur = null;
-            try {
-                cur = context.getContentResolver().query(imageUri, projection, null, null, null);
-                if (cur != null && cur.moveToFirst()) {
-                    int dataColumn = cur.getColumnIndex(MediaStore.Images.Media.DATA);
-                    filePath = cur.getString(dataColumn);
-                }
-            } catch (IllegalStateException stateException) {
-                Log.d(ImageUtils.class.getName(), "IllegalStateException querying content:" + imageUri);
-            } finally {
-                SqlUtils.closeCursor(cur);
-            }
-        }
-
-        if (TextUtils.isEmpty(filePath)) {
-            //access the file directly
-            filePath = imageUri.toString().replace("content://media", "");
-            filePath = filePath.replace("file://", "");
-        }
-
-        return  filePath;
-    }
-
     private static boolean resizeImageAndWriteToStream(Context context,
                                                     Uri imageUri,
                                                     String fileExtension,
@@ -438,7 +410,7 @@ private static boolean resizeImageAndWriteToStream(Context context,
                                                     int quality,
                                                     OutputStream outStream) throws OutOfMemoryError, IOException {
 
-        String realFilePath = getRealFilePath(context, imageUri);
+        String realFilePath = MediaUtils.getRealPathFromURI(context, imageUri);
 
         // get just the image bounds
         BitmapFactory.Options optBounds = new BitmapFactory.Options();
@@ -719,4 +691,144 @@ public static int getMaximumThumbnailWidthForEditor(Context context) {
         maximumThumbnailWidthForEditor -= padding;
         return maximumThumbnailWidthForEditor;
     }
+
+    /**
+     * Given the path to an image, rotate it by using EXIF info
+     * @param context the passed context
+     * @param path the path to the original image
+     * @return the path to the rotated image or null
+     */
+    public static String rotateImageIfNecessary(Context context, String path) {
+        if (context == null || TextUtils.isEmpty(path)) {
+            return null;
+        }
+
+        File file = new File(path);
+        if (!file.exists()) {
+            return null;
+        }
+
+        int orientation = getImageOrientation(context, path);
+        // Do not rotate portrait pictures
+        if (orientation == 0) {
+            return  null;
+        }
+
+        String mimeType = MediaUtils.getMediaFileMimeType(file);
+        if (mimeType.equals("image/gif")) {
+            // Don't rotate gifs to maintain their quality
+            return null;
+        }
+
+        Uri srcImageUri = Uri.parse(path);
+        if (srcImageUri == null) {
+            return null;
+        }
+
+        String fileName = MediaUtils.getMediaFileName(file, mimeType);
+        String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase();
+
+        int selectedWidth = getImageSize(srcImageUri, context)[0];
+        if (selectedWidth == 0) {
+            // Can't read the src dimensions.
+            return null;
+        }
+
+        File rotatedImageFile;
+        FileOutputStream out;
+
+        try {
+            // try to re-use the same name as prefix of the temp file
+            String prefix;
+            int dotPos = fileName.indexOf('.');
+            if (dotPos > 0) {
+                prefix = fileName.substring(0, dotPos);
+            } else {
+                prefix = fileName;
+            }
+
+            if (prefix.length() < 3) {
+                // prefix must be at least 3 characters
+                prefix = "wp-image";
+            }
+
+            rotatedImageFile = File.createTempFile(prefix, "." + fileExtension);
+            out = new FileOutputStream(rotatedImageFile);
+        } catch (IOException e) {
+            AppLog.e(AppLog.T.MEDIA, "Failed to create the temp file on storage.");
+            return null;
+        } catch (SecurityException e) {
+            AppLog.e(AppLog.T.MEDIA, "Can't write the tmp file due to security restrictions.");
+            return null;
+        }
+
+        try {
+            boolean res = resizeImageAndWriteToStream(context, srcImageUri, fileExtension, selectedWidth, orientation, 85, out);
+            if (!res) {
+                AppLog.w(AppLog.T.MEDIA, "Failed to compress the rotates image.");
+                return null;
+            }
+        } catch (IOException e) {
+            AppLog.e(AppLog.T.MEDIA, "Failed to create rotated image.");
+            return null;
+        } catch (OutOfMemoryError e) {
+            AppLog.e(AppLog.T.MEDIA, "Can't rotate the picture due to low memory.");
+            return null;
+        } finally {
+            // close the stream
+            try {
+                out.flush();
+                out.close();
+            } catch (IOException e) {
+                //nope
+            }
+        }
+
+        String tempFilePath = rotatedImageFile.getPath();
+        if (!TextUtils.isEmpty(tempFilePath)) {
+            return tempFilePath;
+        } else {
+            AppLog.e(AppLog.T.MEDIA, "Failed to create rotated image.");
+        }
+
+        return null;
+    }
+
+
+    /**
+     * This is a wrapper around MediaStore.Images.Thumbnails.getThumbnail that takes in consideration
+     * the orientation of the picture.
+     *
+     * @param contentResolver ContentResolver used to dispatch queries to MediaProvider.
+     * @param id Original image id associated with thumbnail of interest.
+     * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
+     *
+     * @return A Bitmap instance. It could be null if the original image
+     *         associated with origId doesn't exist or memory is not enough.
+     */
+    public static Bitmap getThumbnail(ContentResolver contentResolver, long id, int kind) {
+        Cursor cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+                new String[]{MediaStore.Images.Media.DATA}, // Which columns to return
+                MediaStore.Images.Media._ID + "=?",       // Which rows to return
+                new String[]{String.valueOf(id)},       // Selection arguments
+                null);// order
+
+        if (cursor != null && cursor.getCount() > 0) {
+            cursor.moveToFirst();
+            String filepath = cursor.getString(0);
+            cursor.close();
+            int rotation = getExifOrientation(filepath);
+            Bitmap bitmap = MediaStore.Images.Thumbnails.getThumbnail(contentResolver, id, kind, null);
+
+            if (rotation != 0 && bitmap != null) {
+                Matrix matrix = new Matrix();
+                matrix.setRotate(rotation);
+                bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
+            }
+
+            return bitmap;
+        }
+
+        return null;
+    }
 }
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/MediaUtils.java b/WordPressUtils/src/main/java/org/wordpress/android/util/MediaUtils.java
index ba337804babb..60880a89efdf 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/MediaUtils.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/MediaUtils.java
@@ -315,7 +315,13 @@ public static String getMediaFileMimeType(File mediaFile) {
                 }
                 URL urlForGuessingMime = new URL(filePathForGuessingMime);
                 URLConnection uc = urlForGuessingMime.openConnection();
-                String guessedContentType = uc.getContentType(); //internally calls guessContentTypeFromName(url.getFile()); and guessContentTypeFromStream(is);
+                String guessedContentType = null;
+                try {
+                    guessedContentType = uc.getContentType(); //internally calls guessContentTypeFromName(url.getFile()); and guessContentTypeFromStream(is);
+                } catch (StringIndexOutOfBoundsException e) {
+                    // Ref: https://github.com/wordpress-mobile/WordPress-Android/issues/5699
+                    AppLog.e(AppLog.T.MEDIA, "Error getting the content type for " + mediaFile.getPath() +" by using URLConnection.getContentType", e);
+                }
                 // check if returned "content/unknown"
                 if (!TextUtils.isEmpty(guessedContentType) && !guessedContentType.equals("content/unknown")) {
                     mimeType = guessedContentType;
@@ -389,6 +395,18 @@ public static String getExtensionForMimeType(String mimeType) {
         return fileExtensionFromMimeType.toLowerCase();
     }
 
+    public static String getRealPathFromURI(final Context context, Uri uri) {
+        String path;
+        if ("content".equals(uri.getScheme())) {
+            path = MediaUtils.getPath(context, uri);
+        } else if ("file".equals(uri.getScheme())) {
+            path = uri.getPath();
+        } else {
+            path = uri.toString();
+        }
+        return path;
+    }
+
     /**
      * Get a file path from a Uri. This will get the the path for Storage Access
      * Framework Documents, as well as the _data field for the MediaStore and
@@ -399,7 +417,7 @@ public static String getExtensionForMimeType(String mimeType) {
      * @param context The context.
      * @param uri The Uri to query.
      */
-    public static String getPath(final Context context, final Uri uri) {
+    private static String getPath(final Context context, final Uri uri) {
         String path = getDocumentProviderPathKitkatOrHigher(context, uri);
 
         if (path != null) {
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/PermissionUtils.java b/WordPressUtils/src/main/java/org/wordpress/android/util/PermissionUtils.java
index 3b8d9f569525..bf424167da9d 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/PermissionUtils.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/PermissionUtils.java
@@ -19,7 +19,7 @@ public class PermissionUtils {
      *
      * @return true if permissions are already granted, else request them and return false.
      */
-    private static boolean checkAndRequestPermissions(Activity activity, int requestCode, String[] permissionList) {
+    public static boolean checkAndRequestPermissions(Activity activity, int requestCode, String[] permissionList) {
         List<String> toRequest = new ArrayList<>();
         for (String permission : permissionList) {
             if (ContextCompat.checkSelfPermission(activity, permission) != PackageManager.PERMISSION_GRANTED) {
diff --git a/WordPressUtils/src/main/java/org/wordpress/android/util/helpers/WPHtmlTagHandler.java b/WordPressUtils/src/main/java/org/wordpress/android/util/helpers/WPHtmlTagHandler.java
index e3453194a096..e9f45c05e180 100644
--- a/WordPressUtils/src/main/java/org/wordpress/android/util/helpers/WPHtmlTagHandler.java
+++ b/WordPressUtils/src/main/java/org/wordpress/android/util/helpers/WPHtmlTagHandler.java
@@ -25,15 +25,29 @@ public class WPHtmlTagHandler implements Html.TagHandler {
     public void handleTag(final boolean opening, final String tag, Editable output,
                           final XMLReader xmlReader) {
         if (tag != null) {
-            if (tag.equals("ul") || tag.equals("ol") || tag.equals("dd")) {
-                if (opening) {
-                    mListParents.add(tag);
-                } else {
-                    mListParents.remove(tag);
-                }
-                mListItemCount = 0;
-            } else if (tag.equals("li") && !opening) {
-                handleListTag(output);
+            switch (tag) {
+                case "WPUL":
+                    if (opening)
+                        mListParents.add("ul");
+                    else
+                        mListParents.remove("ul");
+                    break;
+                case "WPOL":
+                    if (opening)
+                        mListParents.add("ol");
+                    else
+                        mListParents.remove("ol");
+                    break;
+                case "WPLI":
+                    if (!opening)
+                        handleListTag(output);
+                    break;
+                case "dd":
+                    if (opening)
+                        mListParents.add("dd");
+                    else
+                        mListParents.remove("dd");
+                    break;
             }
         }
     }
