diff --git a/WordPress/src/main/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModel.kt b/WordPress/src/main/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModel.kt
new file mode 100644
index 000000000000..cb89c6f31b7b
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModel.kt
@@ -0,0 +1,48 @@
+package org.wordpress.android.ui.bloggingprompts.promptslist
+
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.flow.update
+import org.wordpress.android.modules.BG_THREAD
+import org.wordpress.android.ui.bloggingprompts.promptslist.model.BloggingPromptsListItemModel
+import org.wordpress.android.ui.bloggingprompts.promptslist.usecase.FetchBloggingPromptsListUseCase
+import org.wordpress.android.util.NetworkUtilsWrapper
+import org.wordpress.android.viewmodel.ScopedViewModel
+import javax.inject.Inject
+import javax.inject.Named
+
+class BloggingPromptsListViewModel @Inject constructor(
+    private val fetchBloggingPromptsList: FetchBloggingPromptsListUseCase,
+    private val networkUtilsWrapper: NetworkUtilsWrapper,
+    @Named(BG_THREAD) private val bgDispatcher: CoroutineDispatcher,
+) : ScopedViewModel(bgDispatcher) {
+    private val _uiStateFlow = MutableStateFlow<UiState>(UiState.None)
+    val uiStateFlow = _uiStateFlow.asStateFlow()
+
+    fun fetchPrompts() {
+        launch {
+            if (!networkUtilsWrapper.isNetworkAvailable()) {
+                _uiStateFlow.update { UiState.NetworkError }
+                return@launch
+            }
+
+            _uiStateFlow.update { UiState.Loading }
+
+            try {
+                val prompts = fetchBloggingPromptsList.execute()
+                _uiStateFlow.update { UiState.Content(prompts) }
+            } catch (e: Exception) {
+                _uiStateFlow.update { UiState.FetchError }
+            }
+        }
+    }
+
+    sealed interface UiState {
+        object None : UiState
+        object Loading : UiState
+        data class Content(val content: List<BloggingPromptsListItemModel>) : UiState
+        object FetchError : UiState
+        object NetworkError : UiState
+    }
+}
diff --git a/WordPress/src/test/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModelTest.kt b/WordPress/src/test/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModelTest.kt
new file mode 100644
index 000000000000..36d258bd9120
--- /dev/null
+++ b/WordPress/src/test/java/org/wordpress/android/ui/bloggingprompts/promptslist/BloggingPromptsListViewModelTest.kt
@@ -0,0 +1,89 @@
+package org.wordpress.android.ui.bloggingprompts.promptslist
+
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.delay
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Test
+import org.mockito.Mock
+import org.mockito.kotlin.doSuspendableAnswer
+import org.mockito.kotlin.whenever
+import org.wordpress.android.BaseUnitTest
+import org.wordpress.android.ui.bloggingprompts.promptslist.model.BloggingPromptsListItemModel
+import org.wordpress.android.ui.bloggingprompts.promptslist.usecase.FetchBloggingPromptsListUseCase
+import org.wordpress.android.util.NetworkUtilsWrapper
+import java.util.Date
+
+@ExperimentalCoroutinesApi
+class BloggingPromptsListViewModelTest : BaseUnitTest() {
+    @Mock private lateinit var fetchBloggingPromptsListUseCase: FetchBloggingPromptsListUseCase
+    @Mock private lateinit var networkUtilsWrapper: NetworkUtilsWrapper
+    lateinit var viewModel: BloggingPromptsListViewModel
+
+    @Before
+    fun setUp() {
+        viewModel = BloggingPromptsListViewModel(
+                fetchBloggingPromptsListUseCase,
+                networkUtilsWrapper,
+                testDispatcher()
+        )
+    }
+
+    @Test
+    fun `given successful fetch, when fetchPrompts, then update uiState to Loading then Content`() = test {
+        val promptsList = listOf(BloggingPromptsListItemModel(0, "prompt", Date(), false, 0))
+        whenever(fetchBloggingPromptsListUseCase.execute()).doSuspendableAnswer {
+            delay(10)
+            promptsList
+        }
+        mockNetworkAvailability(true)
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.None)
+
+        viewModel.fetchPrompts()
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.Loading)
+
+        advanceUntilIdle()
+
+        val result = viewModel.uiStateFlow.value
+        assertThat(result).isInstanceOf(BloggingPromptsListViewModel.UiState.Content::class.java)
+        assertThat((result as BloggingPromptsListViewModel.UiState.Content).content).isEqualTo(promptsList)
+    }
+
+    @Test
+    fun `given unsuccessful fetch, when fetchPrompts, then update uiState to Loading then FetchError`() = test {
+        whenever(fetchBloggingPromptsListUseCase.execute()).doSuspendableAnswer {
+            delay(10)
+            throw Exception("test")
+        }
+        mockNetworkAvailability(true)
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.None)
+
+        viewModel.fetchPrompts()
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.Loading)
+
+        advanceUntilIdle()
+
+        val result = viewModel.uiStateFlow.value
+        assertThat(result).isInstanceOf(BloggingPromptsListViewModel.UiState.FetchError::class.java)
+    }
+
+    @Test
+    fun `given network unavailable, when fetchPrompts, then update uiState to Loading then FetchError`() = test {
+        mockNetworkAvailability(false)
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.None)
+
+        viewModel.fetchPrompts()
+
+        assertThat(viewModel.uiStateFlow.value).isEqualTo(BloggingPromptsListViewModel.UiState.NetworkError)
+    }
+
+
+    private fun mockNetworkAvailability(isNetworkAvailable: Boolean) {
+        whenever(networkUtilsWrapper.isNetworkAvailable()).thenReturn(isNetworkAvailable)
+    }
+}
