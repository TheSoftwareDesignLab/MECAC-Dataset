diff --git a/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewAbstract.java b/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewAbstract.java
index 7b94adfe3250..eddff2f717b9 100644
--- a/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewAbstract.java
+++ b/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewAbstract.java
@@ -28,6 +28,7 @@
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.URLDecoder;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -60,7 +61,8 @@ private void configureWebView() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 if (url != null && url.startsWith("callback") && mJsCallbackReceiver != null) {
-                    String[] split = url.split(":", 2);
+                    String data = URLDecoder.decode(url);
+                    String[] split = data.split(":", 2);
                     String callbackId = split[0];
                     String params = (split.length > 1 ? split[1] : "");
                     mJsCallbackReceiver.executeCallback(callbackId, params);
diff --git a/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewCompatibility.java b/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewCompatibility.java
index 714f87ac8763..4f72868b5937 100644
--- a/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewCompatibility.java
+++ b/WordPressEditor/src/main/java/org/wordpress/android/editor/EditorWebViewCompatibility.java
@@ -18,30 +18,52 @@
  * JavaScript, {@link #loadJavaScript(String)}, instead of {@link WebView#loadUrl(String)}. This is needed because
  * <code>WebView#loadUrl(String)</code> on API<19 eventually calls <code>WebViewClassic#hideSoftKeyboard()</code>,
  * hiding the keyboard whenever JavaScript is executed.</p>
- *
+ * <p/>
  * <p>This class uses reflection to access the normally inaccessible <code>WebViewCore#sendMessage(Message)</code>
  * and use it to execute JavaScript, sidestepping <code>WebView#loadUrl(String)</code> and the keyboard issue.</p>
  */
 @SuppressWarnings("TryWithIdenticalCatches")
 public class EditorWebViewCompatibility extends EditorWebViewAbstract {
+    public interface ReflectionFailureListener {
+        void onReflectionFailure(ReflectionException e);
+    }
+
+    public class ReflectionException extends Exception {
+        public ReflectionException(Throwable cause) {
+            super(cause);
+        }
+    }
+
     private static final int EXECUTE_JS = 194; // WebViewCore internal JS message code
 
     private Object mWebViewCore;
     private Method mSendMessageMethod;
 
+    // Dirty static listener, but it's impossible to set the listener during the construction if we want to keep
+    // the xml layout
+    private static ReflectionFailureListener mReflectionFailureListener;
+    private boolean mReflectionSucceed = true;
+
+    public static void setReflectionFailureListener(ReflectionFailureListener reflectionFailureListener) {
+        mReflectionFailureListener = reflectionFailureListener;
+    }
+
     public EditorWebViewCompatibility(Context context, AttributeSet attrs) {
         super(context, attrs);
         try {
             this.initReflection();
         } catch (ReflectionException e) {
             AppLog.e(T.EDITOR, e);
-            handleReflectionFailure();
+            handleReflectionFailure(e);
         }
     }
 
     private void initReflection() throws ReflectionException {
+        if (!mReflectionSucceed) {
+            // Reflection failed once already, it won't succeed on a second try
+            return;
+        }
         Object webViewProvider;
-
         try {
             if (Build.VERSION.SDK_INT >= 16) {
                 // On API >= 16, the WebViewCore instance is not defined inside WebView itself but inside a
@@ -58,7 +80,6 @@ private void initReflection() throws ReflectionException {
                 mWebViewCore = webViewCoreField.get(webViewProvider);
             } else {
                 // On API < 16, the WebViewCore is directly accessible from the WebView
-
                 // Access WebViewCore object
                 Field webViewCoreField = WebView.class.getDeclaredField("mWebViewCore");
                 webViewCoreField.setAccessible(true);
@@ -97,19 +118,22 @@ private void loadJavaScript(final String javaScript) throws ReflectionException
     public void execJavaScriptFromString(String javaScript) {
         try {
             loadJavaScript(javaScript);
-        } catch(ReflectionException e) {
+        } catch (ReflectionException e) {
             AppLog.e(T.EDITOR, e);
-            handleReflectionFailure();
+            handleReflectionFailure(e);
         }
     }
 
-    private void handleReflectionFailure() {
-        // TODO: Fallback to legacy editor and pass the error to analytics
+    private void handleReflectionFailure(ReflectionException e) {
+        if (mReflectionFailureListener != null) {
+            mReflectionFailureListener.onReflectionFailure(e);
+        }
+        mReflectionSucceed = false;
     }
 
-    public class ReflectionException extends Exception {
-        public ReflectionException(Throwable cause) {
-            super(cause);
-        }
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mReflectionFailureListener = null;
     }
-}
\ No newline at end of file
+}
diff --git a/WordPressEditor/src/main/java/org/wordpress/android/editor/LegacyEditorFragment.java b/WordPressEditor/src/main/java/org/wordpress/android/editor/LegacyEditorFragment.java
index e3d142e96b59..246082504cc7 100644
--- a/WordPressEditor/src/main/java/org/wordpress/android/editor/LegacyEditorFragment.java
+++ b/WordPressEditor/src/main/java/org/wordpress/android/editor/LegacyEditorFragment.java
@@ -9,9 +9,8 @@
 import android.graphics.BitmapFactory;
 import android.graphics.Typeface;
 import android.net.Uri;
+import android.os.AsyncTask;
 import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
 import android.os.Parcelable;
 import android.support.v7.app.ActionBar;
 import android.support.v7.app.AppCompatActivity;
@@ -1023,66 +1022,83 @@ public void onSaveInstanceState(Bundle outState) {
         outState.putString(KEY_CONTENT, mContentEditText.getText().toString());
     }
 
-    public void addMediaFile(final MediaFile mediaFile, final String imageUrl, final ImageLoader imageLoader, final int start, final int end) {
-        mediaFile.setFileURL(imageUrl);
-        mediaFile.setFilePath(imageUrl);
-        final WPEditImageSpan imageSpan = createWPEditImageSpan(getActivity(), mediaFile);
-        mEditorFragmentListener.saveMediaFile(mediaFile);
-        imageSpan.setMediaFile(mediaFile);
+    private class AddMediaFileTask extends AsyncTask<Void, Void, WPEditImageSpan> {
+        private MediaFile mMediaFile;
+        private String mImageUrl;
+        private ImageLoader mImageLoader;
+        private int mStart;
+        private int mEnd;
+
+        public AddMediaFileTask(MediaFile mediaFile, String imageUrl, ImageLoader imageLoader, int start, int end) {
+            mMediaFile = mediaFile;
+            mImageUrl = imageUrl;
+            mImageLoader = imageLoader;
+            mStart = start;
+            mEnd = end;
+        }
 
-        Handler handler = new Handler(Looper.getMainLooper());
-        final Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                // Insert the WPImageSpan in the content field
-                int selectionStart = start;
-                int selectionEnd = end;
-
-                if (selectionStart > selectionEnd) {
-                    int temp = selectionEnd;
-                    selectionEnd = selectionStart;
-                    selectionStart = temp;
-                }
+        protected WPEditImageSpan doInBackground(Void... voids) {
+            mMediaFile.setFileURL(mImageUrl);
+            mMediaFile.setFilePath(mImageUrl);
+            WPEditImageSpan imageSpan = createWPEditImageSpan(getActivity(), mMediaFile);
+            mEditorFragmentListener.saveMediaFile(mMediaFile);
+            return imageSpan;
+        }
 
-                imageSpan.setPosition(selectionStart, selectionEnd);
+        protected void onPostExecute(WPEditImageSpan imageSpan) {
+            // Insert the WPImageSpan in the content field
+            int selectionStart = mStart;
+            int selectionEnd = mEnd;
 
-                int line, column = 0;
-                if (mContentEditText.getLayout() != null) {
-                    line = mContentEditText.getLayout().getLineForOffset(selectionStart);
-                    column = selectionStart - mContentEditText.getLayout().getLineStart(line);
-                }
+            if (selectionStart > selectionEnd) {
+                int temp = selectionEnd;
+                selectionEnd = selectionStart;
+                selectionStart = temp;
+            }
 
-                Editable s = mContentEditText.getText();
-                if (s == null) {
-                    return;
-                }
+            imageSpan.setPosition(selectionStart, selectionEnd);
 
-                WPImageSpan[] imageSpans = s.getSpans(selectionStart, selectionEnd, WPImageSpan.class);
-                if (imageSpans.length != 0) {
-                    // insert a few line breaks if the cursor is already on an image
-                    s.insert(selectionEnd, "\n\n");
-                    selectionStart = selectionStart + 2;
-                    selectionEnd = selectionEnd + 2;
-                } else if (column != 0) {
-                    // insert one line break if the cursor is not at the first column
-                    s.insert(selectionEnd, "\n");
-                    selectionStart = selectionStart + 1;
-                    selectionEnd = selectionEnd + 1;
-                }
+            int line, column = 0;
+            if (mContentEditText.getLayout() != null) {
+                line = mContentEditText.getLayout().getLineForOffset(selectionStart);
+                column = selectionStart - mContentEditText.getLayout().getLineStart(line);
+            }
 
-                s.insert(selectionStart, " ");
-                s.setSpan(imageSpan, selectionStart, selectionEnd + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
-                AlignmentSpan.Standard as = new AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER);
-                s.setSpan(as, selectionStart, selectionEnd + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
-                s.insert(selectionEnd + 1, "\n\n");
+            Editable s = mContentEditText.getText();
+            if (s == null) {
+                return;
+            }
 
-                // Fetch and replace the WPImageSpan if it's a remote media
-                if (imageLoader != null && URLUtil.isNetworkUrl(imageUrl)) {
-                    loadWPImageSpanThumbnail(mediaFile, imageUrl, imageLoader);
-                }
+            WPImageSpan[] imageSpans = s.getSpans(selectionStart, selectionEnd, WPImageSpan.class);
+            if (imageSpans.length != 0) {
+                // insert a few line breaks if the cursor is already on an image
+                s.insert(selectionEnd, "\n\n");
+                selectionStart = selectionStart + 2;
+                selectionEnd = selectionEnd + 2;
+            } else if (column != 0) {
+                // insert one line break if the cursor is not at the first column
+                s.insert(selectionEnd, "\n");
+                selectionStart = selectionStart + 1;
+                selectionEnd = selectionEnd + 1;
             }
-        };
-        handler.postDelayed(r, 1);
+
+            s.insert(selectionStart, " ");
+            s.setSpan(imageSpan, selectionStart, selectionEnd + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+            AlignmentSpan.Standard as = new AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER);
+            s.setSpan(as, selectionStart, selectionEnd + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+            s.insert(selectionEnd + 1, "\n\n");
+
+            // Fetch and replace the WPImageSpan if it's a remote media
+            if (mImageLoader != null && URLUtil.isNetworkUrl(mImageUrl)) {
+                loadWPImageSpanThumbnail(mMediaFile, mImageUrl, mImageLoader);
+            }
+        }
+    }
+
+    public void addMediaFile(final MediaFile mediaFile, final String imageUrl, final ImageLoader imageLoader,
+                             final int start, final int end) {
+        AddMediaFileTask addMediaFileTask = new AddMediaFileTask(mediaFile, imageUrl, imageLoader, start, end);
+        addMediaFileTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     @Override
diff --git a/libs/editor-common/assets/ZSSRichTextEditor.js b/libs/editor-common/assets/ZSSRichTextEditor.js
index 6ee6c5ef4771..a6bd7bd2286b 100755
--- a/libs/editor-common/assets/ZSSRichTextEditor.js
+++ b/libs/editor-common/assets/ZSSRichTextEditor.js
@@ -387,13 +387,18 @@ ZSSEditor.restoreRange = function(){
 };
 
 ZSSEditor.resetSelectionOnField = function(fieldId, offset) {
-    offset = typeof offset !== 'undefined' ? offset : 0;
-
     var query = "div#" + fieldId;
     var field = document.querySelector(query);
+
+    this.giveFocusToElement(field, offset);
+};
+
+ZSSEditor.giveFocusToElement = function(element, offset) {
+    offset = typeof offset !== 'undefined' ? offset : 0;
+
     var range = document.createRange();
-    range.setStart(field, offset);
-    range.setEnd(field, offset);
+    range.setStart(element, offset);
+    range.setEnd(element, offset);
 
     var selection = document.getSelection();
     selection.removeAllRanges();
@@ -644,6 +649,13 @@ ZSSEditor.setBlockquote = function() {
     var range = selection.getRangeAt(0).cloneRange();
     var sendStyles = false;
 
+    // Make sure text being wrapped in blockquotes is inside paragraph tags
+    // (should be <blockquote><paragraph>contents</paragraph></blockquote>)
+    var currentHtml = ZSSEditor.focusedField.getWrappedDomNode().innerHTML;
+    if (currentHtml.search('<' + ZSSEditor.defaultParagraphSeparator) == -1) {
+        ZSSEditor.focusedField.setHTML(Util.wrapHTMLInTag(currentHtml, ZSSEditor.defaultParagraphSeparator));
+    }
+
     var ancestorElement = this.getAncestorElementForSettingBlockquote(range);
 
     if (ancestorElement) {
@@ -3024,6 +3036,9 @@ ZSSField.prototype.bindListeners = function() {
     this.wrappedObject.bind('input', function(e) { thisObj.handleInputEvent(e); });
     this.wrappedObject.bind('compositionstart', function(e) { thisObj.handleCompositionStartEvent(e); });
     this.wrappedObject.bind('compositionend', function(e) { thisObj.handleCompositionEndEvent(e); });
+
+    // Only supported on API19+
+    this.wrappedObject.on('paste', function(e) { thisObj.handlePasteEvent(e); });
 };
 
 // MARK: - Emptying the field when it should be, well... empty (HTML madness)
@@ -3071,6 +3086,9 @@ ZSSField.prototype.handleKeyDownEvent = function(e) {
 
     var wasEnterPressed = (e.keyCode == '13');
 
+    // Handle keyDownEvent actions that need to happen after the event has completed (and the field has been modified)
+    setTimeout(this.afterKeyDownEvent, 20, e.target.innerHTML, e);
+
     if (this.isComposing) {
         e.stopPropagation();
     } else if (wasEnterPressed && !this.isMultiline()) {
@@ -3086,13 +3104,25 @@ ZSSField.prototype.handleKeyDownEvent = function(e) {
             return;
         }
 
-        // This is intended to work around an API19-only bug where paragraph wrapping the first character in a post
-        // will display a zero-width space character (from ZSSField.wrapCaretInParagraphIfNecessary)
+        // The containsParagraphSeparators check is intended to work around three bugs:
+        // 1. On API19 only, paragraph wrapping the first character in a post will display a zero-width space character
+        // (from ZSSField.wrapCaretInParagraphIfNecessary)
         // We can drop the if statement wrapping wrapCaretInParagraphIfNecessary() if we find a way to stop using
         // zero-width space characters (e.g., autocorrect issues are fixed and we switch back to p tags)
+        //
+        // 2. On all APIs, software pasting (long press -> paste) doesn't automatically wrap the paste in paragraph
+        // tags in new posts. On API19+ this is corrected by ZSSField.handlePasteEvent(), but earlier APIs don't support
+        // it. So, instead, we allow the editor not to wrap the paste in paragraph tags and it's automatically corrected
+        // after adding a newline. But allowing wrapCaretInParagraphIfNecessary() to go through will wrap the paragraph
+        // incorrectly, so we skip it in this case.
+        //
+        // 3. On all APIs, hardware pasting (CTRL + V) doesn't automatically wrap the paste in paragraph tags in
+        // new posts. ZSSField.handlePasteEvent() does not address this problem. It's the same fix as #2 above, but we
+        // have to extend the `containsParagraphSeparators` check to all APIs, not just API19 and below, to fix
+        // hardware pasting.
         var containsParagraphSeparators = this.getWrappedDomNode().innerHTML.search(
                 '<' + ZSSEditor.defaultParagraphSeparator) > -1;
-        if (nativeState.androidApiLevel != 19 || containsParagraphSeparators) {
+        if (containsParagraphSeparators) {
             this.wrapCaretInParagraphIfNecessary();
         }
 
@@ -3252,6 +3282,50 @@ ZSSField.prototype.handleTapEvent = function(e) {
     }
 };
 
+ZSSField.prototype.handlePasteEvent = function(e) {
+    if (this.isMultiline() && this.getHTML().length == 0) {
+        ZSSEditor.insertHTML(Util.wrapHTMLInTag('&#x200b;', ZSSEditor.defaultParagraphSeparator));
+    }
+};
+
+/**
+ *  @brief      Fires after 'keydown' events, when the field contents have already been modified
+ */
+ZSSField.prototype.afterKeyDownEvent = function(beforeHTML, e) {
+    var htmlWasModified = (beforeHTML != e.target.innerHTML);
+
+    var selection = document.getSelection();
+    var range = selection.getRangeAt(0).cloneRange();
+    var focusedNode = range.startContainer;
+
+    var focusedNodeIsEmpty = (focusedNode.innerHTML != undefined
+        && (focusedNode.innerHTML.length == 0 || focusedNode.innerHTML == '<br>'));
+
+    // Blockquote handling
+    if (focusedNode.nodeName == NodeName.BLOCKQUOTE && focusedNodeIsEmpty) {
+        if (!htmlWasModified) {
+            // We only want to handle this if the last character inside a blockquote was just deleted - if the HTML
+            // is unchanged, it might be that afterKeyDownEvent was called too soon, and we should avoid doing anything
+            return;
+        }
+
+        // When using backspace to delete the contents of a blockquote, the div within the blockquote is deleted
+        // This makes the blockquote unable to be deleted using backspace, and also causes autocorrect issues on API19+
+        range.startContainer.innerHTML = Util.wrapHTMLInTag('<br>', ZSSEditor.defaultParagraphSeparator);
+
+        // Give focus to new div
+        var newFocusElement = focusedNode.firstChild;
+        ZSSEditor.giveFocusToElement(newFocusElement, 1);
+    } else if (focusedNode.nodeName == NodeName.DIV && focusedNode.parentNode.nodeName == NodeName.BLOCKQUOTE
+        && focusedNode.parentNode.previousSibling == null && focusedNode.parentNode.childNodes.length == 1
+        && focusedNodeIsEmpty) {
+        // When a post begins with a blockquote, and there's content after that blockquote, backspacing inside that
+        // blockquote will work until the blockquote is empty. After that, backspace will have no effect
+        // This fix identifies that situation and makes the call to setBlockquote() to toggle off the blockquote
+        ZSSEditor.setBlockquote();
+    }
+};
+
 ZSSField.prototype.sendImageTappedCallback = function(imageNode) {
     var meta = JSON.stringify(ZSSEditor.extractImageMeta(imageNode));
     var imageId = "", mediaType = "image";
@@ -3383,13 +3457,23 @@ ZSSField.prototype.wrapCaretInParagraphIfNecessary = function()
     var parentNodeShouldBeParagraph = (closerParentNode == this.getWrappedDomNode()
                                        || closerParentNode.nodeName == NodeName.BLOCKQUOTE);
 
-    if (parentNodeShouldBeParagraph) {
+    // When starting a post with a blockquote (before any text is entered), the paragraph tags inside the blockquote
+    // won't properly wrap the text once it's entered
+    // In that case, remove the paragraph tags and re-apply them, wrapping around the newly entered text
+    var fixNewPostBlockquoteBug = (closerParentNode.nodeName == NodeName.DIV
+                                       && closerParentNode.parentNode.nodeName == NodeName.BLOCKQUOTE
+                                       && closerParentNode.innerHTML.length == 0);
+
+    if (parentNodeShouldBeParagraph || fixNewPostBlockquoteBug) {
         var selection = window.getSelection();
 
         if (selection && selection.rangeCount > 0) {
             var range = selection.getRangeAt(0);
 
             if (range.startContainer == range.endContainer) {
+                if (fixNewPostBlockquoteBug) {
+                    closerParentNode.parentNode.removeChild(closerParentNode);
+                }
                 var paragraph = document.createElement("div");
                 var textNode = document.createTextNode("&#x200b;");
 
@@ -3431,7 +3515,7 @@ ZSSField.prototype.isEmpty = function() {
 ZSSField.prototype.getHTML = function() {
     var html = this.wrappedObject.html();
     if (ZSSEditor.defaultParagraphSeparator == 'div') {
-        html = html.replace(/(<div)/igm, '<p').replace(/<\/div>/igm, '</p>');
+        html = html.replace(/(<div(?=[>\s]))/igm, '<p').replace(/<\/div>/igm, '</p>');
     }
     html = wp.saveText(html);
     html = ZSSEditor.removeVisualFormatting( html );
@@ -3446,9 +3530,16 @@ ZSSField.prototype.getHTMLForCallback = function() {
     if (this.hasNoStyle) {
         contentsArgument = "contents=" + this.strippedHTML();
     } else {
-        contentsArgument = "contents=" + this.getHTML();
+        var html;
+        if (nativeState.androidApiLevel < 17) {
+            // URI Encode HTML on API < 17 because of the use of WebViewClient.shouldOverrideUrlLoading. Data must
+            // be decoded in shouldOverrideUrlLoading.
+            html = encodeURIComponent(this.getHTML());
+        } else {
+            html = this.getHTML();
+        }
+        contentsArgument = "contents=" + html;
     }
-
     var joinedArguments = functionArgument + defaultCallbackSeparator + idArgument + defaultCallbackSeparator +
         contentsArgument;
     ZSSEditor.callback('callback-response-string', joinedArguments);
@@ -3470,7 +3561,7 @@ ZSSField.prototype.setHTML = function(html) {
 
     if (ZSSEditor.defaultParagraphSeparator == 'div') {
         // Replace the paragraph tags we get from wpload with divs
-        mutatedHTML = mutatedHTML.replace(/(<p)/igm, '<div').replace(/<\/p>/igm, '</div>');
+        mutatedHTML = mutatedHTML.replace(/(<p(?=[>\s]))/igm, '<div').replace(/<\/p>/igm, '</div>');
     }
 
     this.wrappedObject.html(mutatedHTML);
