diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.java b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.java
deleted file mode 100644
index dae85464d1b8..000000000000
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.wordpress.android.ui.reader.utils;
-
-import java.util.HashMap;
-import java.util.regex.Pattern;
-
-public class ReaderEmbedScanner {
-    private final String mContent;
-
-    private final HashMap<Pattern, String> mKnownEmbeds = new HashMap<>();
-
-    public ReaderEmbedScanner(String contentOfPost) {
-        mContent = contentOfPost;
-        mKnownEmbeds.put(Pattern.compile("<blockquote[^<>]class=\"instagram-", Pattern.CASE_INSENSITIVE),
-                         "https://platform.instagram.com/en_US/embeds.js");
-        mKnownEmbeds.put(Pattern.compile("<fb:post", Pattern.CASE_INSENSITIVE),
-                         "https://connect.facebook.net/en_US/sdk.js#xfbml=1&amp;version=v2.8");
-    }
-
-    public void beginScan(ReaderHtmlUtils.HtmlScannerListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("HtmlScannerListener is required");
-        }
-
-        for (Pattern pattern : mKnownEmbeds.keySet()) {
-            if (pattern.matcher(mContent).find()) {
-                // Use the onTagFound callback to pass a URL. Not super clean, but avoid clutter with more kind
-                // of listeners.
-                listener.onTagFound("", mKnownEmbeds.get(pattern));
-            }
-        }
-    }
-}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.kt
new file mode 100644
index 000000000000..a56444ba515c
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderEmbedScanner.kt
@@ -0,0 +1,31 @@
+package org.wordpress.android.ui.reader.utils
+
+import org.wordpress.android.ui.reader.utils.ReaderHtmlUtils.HtmlScannerListener
+import java.util.regex.Pattern
+
+class ReaderEmbedScanner(private val content: String) {
+    private val knownEmbeds = HashMap<Pattern, String>()
+
+    init {
+        knownEmbeds[Pattern.compile(
+            "<blockquote[^<>]class=\"instagram-",
+            Pattern.CASE_INSENSITIVE
+        )] = "https://platform.instagram.com/en_US/embeds.js"
+        knownEmbeds[Pattern.compile(
+            "<fb:post",
+            Pattern.CASE_INSENSITIVE
+        )] = "https://connect.facebook.net/en_US/sdk.js#xfbml=1&amp;version=v2.8"
+    }
+
+    fun beginScan(listener: HtmlScannerListener) {
+        knownEmbeds.keys
+            .filter { it.matcher(content).find() }
+            .forEach {
+                // Use the onTagFound callback to pass a URL. Not super clean, but avoid clutter with more kind
+                // of listeners.
+                knownEmbeds[it]?.let { url ->
+                    listener.onTagFound("", url)
+                }
+            }
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.java b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.java
deleted file mode 100644
index 8e8c0c1c8e39..000000000000
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package org.wordpress.android.ui.reader.utils;
-
-import android.net.Uri;
-
-import androidx.annotation.Nullable;
-
-import org.wordpress.android.util.StringUtils;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class ReaderHtmlUtils {
-    public interface HtmlScannerListener {
-        void onTagFound(String tag, String src);
-    }
-
-    // regex for matching oriwidth attributes in tags
-    private static final Pattern ORIGINAL_WIDTH_ATTR_PATTERN = Pattern.compile(
-            "data-orig-size\\s*=\\s*['\"](.*?),.*?['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    private static final Pattern ORIGINAL_HEIGHT_ATTR_PATTERN = Pattern.compile(
-            "data-orig-size\\s*=\\s*['\"].*?,(.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    // regex for matching width attributes in tags
-    private static final Pattern WIDTH_ATTR_PATTERN = Pattern.compile(
-            "width\\s*=\\s*['\"](.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    // regex for matching height attributes in tags
-    private static final Pattern HEIGHT_ATTR_PATTERN = Pattern.compile(
-            "height\\s*=\\s*['\"](.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    // regex for matching class attributes in tags
-    private static final Pattern CLASS_ATTR_PATTERN = Pattern.compile(
-            "class\\s*=\\s*['\"](.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    public static final Pattern SRCSET_ATTR_PATTERN = Pattern.compile(
-            "srcset\\s*=\\s*['\"](.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    // Matches pairs of URLs and widths inside a srcset tag, e.g.:
-    // <URL1> 600w, <URL2> 800w -> (<URL1>, 600) and (<URL2>, 800)
-    public static final Pattern SRCSET_INNER_PATTERN = Pattern.compile(
-            "(\\S*?)\\s+(\\d*)w,?\\s*?",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    public static final Pattern DATA_LARGE_FILE_PATTERN = Pattern.compile(
-            "data-large-file\\s*=\\s*['\"](.*?)['\"]",
-            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-
-    /*
-    * returns the integer value from the data-orig-size attribute in the passed html tag
-    */
-    public static int getOriginalWidthAttrValue(final String tag) {
-        return StringUtils.stringToInt(matchTagAttrPattern(ORIGINAL_WIDTH_ATTR_PATTERN, tag), 0);
-    }
-
-    public static int getOriginalHeightAttrValue(final String tag) {
-        return StringUtils.stringToInt(matchTagAttrPattern(ORIGINAL_HEIGHT_ATTR_PATTERN, tag), 0);
-    }
-
-    /*
-    * returns the integer value from the width attribute in the passed html tag
-    */
-    public static int getWidthAttrValue(final String tag) {
-        return StringUtils.stringToInt(matchTagAttrPattern(WIDTH_ATTR_PATTERN, tag), 0);
-    }
-
-    public static int getHeightAttrValue(final String tag) {
-        return StringUtils.stringToInt(matchTagAttrPattern(HEIGHT_ATTR_PATTERN, tag), 0);
-    }
-
-    /*
-     * returns the value from class src attribute in the passed html tag
-     */
-    public static String getClassAttrValue(final String tag) {
-        return matchTagAttrPattern(CLASS_ATTR_PATTERN, tag);
-    }
-
-    /*
-     * returns the integer value of the passed query param in the passed url - returns zero
-     * if the url is invalid, or the param doesn't exist, or the param value could not be
-     * converted to an int
-     */
-    public static int getIntQueryParam(final String url,
-                                       @SuppressWarnings("SameParameterValue") final String param) {
-        if (url == null
-            || param == null
-            || !url.startsWith("http")
-            || !url.contains(param + "=")) {
-            return 0;
-        }
-        return StringUtils.stringToInt(Uri.parse(url).getQueryParameter(param));
-    }
-
-    /*
-     * Extracts the srcset attribute from the given [tag], and returns the largest image.
-     * Returns null if the srcset attribute is not present.
-     */
-    @Nullable public static SrcsetImage getLargestSrcsetImageForTag(final String tag) {
-        if (tag == null) {
-            return null;
-        }
-
-        Matcher matcher = SRCSET_ATTR_PATTERN.matcher(tag);
-        if (matcher.find()) {
-            String srcsetBody = matcher.group(1);
-            Matcher innerMatcher = SRCSET_INNER_PATTERN.matcher(srcsetBody);
-            int largestWidth = 0;
-            String largestImageUrl = null;
-            while (innerMatcher.find()) {
-                int currentWidth = StringUtils.stringToInt(innerMatcher.group(2));
-                if (currentWidth > largestWidth) {
-                    largestWidth = currentWidth;
-                    largestImageUrl = innerMatcher.group(1);
-                }
-            }
-            if (largestImageUrl != null) {
-                return new SrcsetImage(largestWidth, largestImageUrl);
-            }
-        }
-        return null;
-    }
-
-    /*
-     * Returns the value from the data-large-file attribute in the passed html tag,
-     * or null if the attribute is not present.
-     */
-    @Nullable public static String getLargeFileAttr(final String tag) {
-        return matchTagAttrPattern(DATA_LARGE_FILE_PATTERN, tag);
-    }
-
-    @Nullable private static String matchTagAttrPattern(Pattern pattern, String tag) {
-        if (tag == null) {
-            return null;
-        }
-
-        Matcher matcher = pattern.matcher(tag);
-        if (matcher.find()) {
-            return matcher.group(1);
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.kt
new file mode 100644
index 000000000000..16ce6fc1ba16
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderHtmlUtils.kt
@@ -0,0 +1,160 @@
+package org.wordpress.android.ui.reader.utils
+
+import org.wordpress.android.util.StringUtils
+import java.util.regex.Pattern
+import androidx.core.net.toUri
+
+object ReaderHtmlUtils {
+    // regex for matching oriwidth attributes in tags
+    private val ORIGINAL_WIDTH_ATTR_PATTERN: Pattern = Pattern.compile(
+        "data-orig-size\\s*=\\s*['\"](.*?),.*?['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    private val ORIGINAL_HEIGHT_ATTR_PATTERN: Pattern = Pattern.compile(
+        "data-orig-size\\s*=\\s*['\"].*?,(.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    // regex for matching width attributes in tags
+    private val WIDTH_ATTR_PATTERN: Pattern = Pattern.compile(
+        "width\\s*=\\s*['\"](.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    // regex for matching height attributes in tags
+    private val HEIGHT_ATTR_PATTERN: Pattern = Pattern.compile(
+        "height\\s*=\\s*['\"](.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    // regex for matching class attributes in tags
+    private val CLASS_ATTR_PATTERN: Pattern = Pattern.compile(
+        "class\\s*=\\s*['\"](.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    val SRCSET_ATTR_PATTERN: Pattern = Pattern.compile(
+        "srcset\\s*=\\s*['\"](.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    // Matches pairs of URLs and widths inside a srcset tag, e.g.:
+    // <URL1> 600w, <URL2> 800w -> (<URL1>, 600) and (<URL2>, 800)
+    val SRCSET_INNER_PATTERN: Pattern = Pattern.compile(
+        "(\\S*?)\\s+(\\d*)w,?\\s*?",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    private val DATA_LARGE_FILE_PATTERN: Pattern = Pattern.compile(
+        "data-large-file\\s*=\\s*['\"](.*?)['\"]",
+        Pattern.DOTALL or Pattern.CASE_INSENSITIVE
+    )
+
+    /*
+     * returns the integer value from the data-orig-size attribute in the passed html tag
+     */
+    fun getOriginalWidthAttrValue(tag: String): Int {
+        return StringUtils.stringToInt(
+            matchTagAttrPattern(
+                ORIGINAL_WIDTH_ATTR_PATTERN, tag
+            ), 0
+        )
+    }
+
+    fun getOriginalHeightAttrValue(tag: String): Int {
+        return StringUtils.stringToInt(
+            matchTagAttrPattern(
+                ORIGINAL_HEIGHT_ATTR_PATTERN, tag
+            ), 0
+        )
+    }
+
+    /*
+     * returns the integer value from the width attribute in the passed html tag
+     */
+    fun getWidthAttrValue(tag: String): Int {
+        return StringUtils.stringToInt(
+            matchTagAttrPattern(
+                WIDTH_ATTR_PATTERN, tag
+            ), 0
+        )
+    }
+
+    fun getHeightAttrValue(tag: String): Int {
+        return StringUtils.stringToInt(
+            matchTagAttrPattern(
+                HEIGHT_ATTR_PATTERN, tag
+            ), 0
+        )
+    }
+
+    /*
+     * returns the value from class src attribute in the passed html tag
+     */ fun getClassAttrValue(tag: String): String? {
+        return matchTagAttrPattern(CLASS_ATTR_PATTERN, tag)
+    }
+
+    /*
+     * returns the integer value of the passed query param in the passed url - returns zero
+     * if the url is invalid, or the param doesn't exist, or the param value could not be
+     * converted to an int
+     */
+    fun getIntQueryParam(
+        url: String,
+        param: String
+    ): Int {
+        if (!url.startsWith("http")
+            || !url.contains("$param=")
+        ) {
+            return 0
+        }
+        return StringUtils.stringToInt(url.toUri().getQueryParameter(param))
+    }
+
+    /*
+     * Extracts the srcset attribute from the given [tag], and returns the largest image.
+     * Returns null if the srcset attribute is not present.
+     */
+    fun getLargestSrcsetImageForTag(tag: String): SrcsetImage? {
+        val matcher = SRCSET_ATTR_PATTERN.matcher(tag)
+        if (matcher.find()) {
+            val srcsetBody = checkNotNull(matcher.group(1))
+            val innerMatcher = SRCSET_INNER_PATTERN.matcher(srcsetBody)
+            var largestWidth = 0
+            var largestImageUrl: String? = null
+            while (innerMatcher.find()) {
+                val currentWidth = StringUtils.stringToInt(innerMatcher.group(2))
+                if (currentWidth > largestWidth) {
+                    largestWidth = currentWidth
+                    largestImageUrl = innerMatcher.group(1)
+                }
+            }
+            if (largestImageUrl != null) {
+                return SrcsetImage(largestWidth, largestImageUrl)
+            }
+        }
+        return null
+    }
+
+    /*
+     * Returns the value from the data-large-file attribute in the passed html tag,
+     * or null if the attribute is not present.
+     */
+    fun getLargeFileAttr(tag: String): String? {
+        return matchTagAttrPattern(DATA_LARGE_FILE_PATTERN, tag)
+    }
+
+    private fun matchTagAttrPattern(pattern: Pattern, tag: String): String? {
+        val matcher = pattern.matcher(tag)
+        return if (matcher.find()) {
+            matcher.group(1)
+        } else {
+            null
+        }
+    }
+
+    fun interface HtmlScannerListener {
+        fun onTagFound(tag: String, src: String)
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.java b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.java
deleted file mode 100644
index 78c547799d12..000000000000
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.wordpress.android.ui.reader.utils;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class ReaderIframeScanner {
-    private final String mContent;
-
-    private static final Pattern IFRAME_TAG_PATTERN = Pattern.compile(
-            "<iframe[^>]* src=\\\'([^\\\']*)\\\'[^>]*>",
-            Pattern.CASE_INSENSITIVE);
-
-    public ReaderIframeScanner(String contentOfPost) {
-        mContent = contentOfPost;
-    }
-
-    public void beginScan(ReaderHtmlUtils.HtmlScannerListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("HtmlScannerListener is required");
-        }
-
-        Matcher matcher = IFRAME_TAG_PATTERN.matcher(mContent);
-        while (matcher.find()) {
-            String tag = matcher.group(0);
-            String src = matcher.group(1);
-            listener.onTagFound(tag, src);
-        }
-    }
-
-    /*
-     * scans the post for iframes containing usable videos, returns the first one found
-     */
-    public String getFirstUsableVideo() {
-        Matcher matcher = IFRAME_TAG_PATTERN.matcher(mContent);
-        while (matcher.find()) {
-            String src = matcher.group(1);
-            if (ReaderVideoUtils.canShowVideoThumbnail(src)) {
-                return src;
-            }
-        }
-        return null;
-    }
-}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.kt
new file mode 100644
index 000000000000..fb6a82a999a2
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderIframeScanner.kt
@@ -0,0 +1,37 @@
+package org.wordpress.android.ui.reader.utils
+
+import org.wordpress.android.ui.reader.utils.ReaderHtmlUtils.HtmlScannerListener
+import java.util.regex.Pattern
+
+class ReaderIframeScanner(private val content: String) {
+    fun beginScan(listener: HtmlScannerListener) {
+        val matcher = IFRAME_TAG_PATTERN.matcher(content)
+        while (matcher.find()) {
+            val tag = matcher.group(0).orEmpty()
+            val src = matcher.group(1).orEmpty()
+            listener.onTagFound(tag, src)
+        }
+    }
+
+    /*
+     * scans the post for iframes containing usable videos, returns the first one found
+     */
+    fun getFirstUsableVideo(): String? {
+        val matcher =
+            IFRAME_TAG_PATTERN.matcher(content)
+        while (matcher.find()) {
+            val src = matcher.group(1)
+            if (ReaderVideoUtils.canShowVideoThumbnail(src)) {
+                return src
+            }
+        }
+        return null
+    }
+
+    companion object {
+        private val IFRAME_TAG_PATTERN: Pattern = Pattern.compile(
+            "<iframe[^>]* src=\\\'([^\\\']*)\\\'[^>]*>",
+            Pattern.CASE_INSENSITIVE
+        )
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.java b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.java
deleted file mode 100644
index 8929570faf53..000000000000
--- a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.java
+++ /dev/null
@@ -1,155 +0,0 @@
-package org.wordpress.android.ui.reader.utils;
-
-import androidx.annotation.NonNull;
-
-import org.wordpress.android.ui.reader.models.ReaderImageList;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class ReaderImageScanner {
-    private final String mContent;
-    private final boolean mIsPrivate;
-    private final boolean mContentContainsImages;
-
-    private static final Pattern IMG_TAG_PATTERN = Pattern.compile(
-            "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>",
-            Pattern.CASE_INSENSITIVE);
-
-    public ReaderImageScanner(String contentOfPost, boolean isPrivate) {
-        mContent = contentOfPost;
-        mIsPrivate = isPrivate;
-        mContentContainsImages = mContent != null && mContent.contains("<img");
-    }
-
-    /*
-     * start scanning the content for images and notify the passed listener about each one
-     */
-    public void beginScan(ReaderHtmlUtils.HtmlScannerListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("HtmlScannerListener is required");
-        }
-
-        if (!mContentContainsImages) {
-            return;
-        }
-
-        Matcher imgMatcher = IMG_TAG_PATTERN.matcher(mContent);
-        while (imgMatcher.find()) {
-            String imageTag = imgMatcher.group(0);
-            String imageUrl = imgMatcher.group(1);
-            listener.onTagFound(imageTag, imageUrl);
-        }
-    }
-
-    /*
-     * returns a list of image URLs in the content up to the max above a certain width - pass zero
-     * to include all images regardless of size
-     */
-    public ReaderImageList getImageList(int maxImageCount, int minImageWidth) {
-        ReaderImageList imageList = new ReaderImageList(mIsPrivate);
-
-        if (!mContentContainsImages) {
-            return imageList;
-        }
-
-        Matcher imgMatcher = IMG_TAG_PATTERN.matcher(mContent);
-        while (imgMatcher.find()) {
-            String imageTag = imgMatcher.group(0);
-            String imageUrl = imgMatcher.group(1);
-
-            if (minImageWidth == 0) {
-                imageList.addImageUrl(imageUrl);
-            } else {
-                int width = Math.max(ReaderHtmlUtils.getWidthAttrValue(imageTag),
-                                     ReaderHtmlUtils.getIntQueryParam(imageUrl, "w"));
-                if (width >= minImageWidth) {
-                    imageList.addImageUrl(imageUrl);
-                    if (maxImageCount > 0 && imageList.size() >= maxImageCount) {
-                        break;
-                    }
-                }
-            }
-        }
-
-        return imageList;
-    }
-
-    /*
-     * returns true if there at least `minImageCount` images in the post content that are at
-     * least `minImageWidth` in size
-     */
-    public boolean hasUsableImageCount(int minImageCount, int minImageWidth) {
-        return getImageList(minImageCount, minImageWidth).size() == minImageCount;
-    }
-
-    /*
-     * used when a post doesn't have a featured image assigned, searches post's content
-     * for an image that may be large enough to be suitable as a featured image
-     */
-    public String getLargestImage(int minImageWidth) {
-        if (!mContentContainsImages) {
-            return null;
-        }
-
-        String currentImageUrl = null;
-        int currentMaxWidth = minImageWidth;
-
-        Matcher imgMatcher = IMG_TAG_PATTERN.matcher(mContent);
-        while (imgMatcher.find()) {
-            String imageTag = imgMatcher.group(0);
-            String imageUrl = imgMatcher.group(1);
-
-            // Primary source: check the width attribute.
-            int width = Math.max(ReaderHtmlUtils.getWidthAttrValue(imageTag),
-                                 ReaderHtmlUtils.getIntQueryParam(imageUrl, "w"));
-            if (width > currentMaxWidth) {
-                currentImageUrl = imageUrl;
-                currentMaxWidth = width;
-            }
-
-            // Look through the srcset attribute (if set) for the largest available size of this image.
-            SrcsetImage bestFromSrcset = ReaderHtmlUtils.getLargestSrcsetImageForTag(imageTag);
-            if (bestFromSrcset != null && bestFromSrcset.getWidth() > currentMaxWidth) {
-                currentMaxWidth = bestFromSrcset.getWidth();
-                currentImageUrl = bestFromSrcset.getUrl();
-            }
-
-            // Check if the image tag's class suggests it's a good enough size.
-            // Only do this if we don't already have a winner, since we can't be sure of the width
-            // and shouldn't replace an image we know for sure is larger than [minImageWidth].
-            if (currentImageUrl == null && hasSuitableClassForFeaturedImage(imageTag)) {
-                currentImageUrl = imageUrl;
-            }
-
-            // Look for a data-large-file attribute if set and use the associated url.
-            // Only do this if we don't already have a winner, since we can't be sure of the width
-            // and shouldn't replace an image we know for sure is larger than [minImageWidth].
-            if (currentImageUrl == null) {
-                currentImageUrl = ReaderHtmlUtils.getLargeFileAttr(imageTag);
-            }
-        }
-
-        return currentImageUrl;
-    }
-
-    /*
-     * returns true if the passed image tag has a "size-" class attribute which would make it
-     * suitable for use as a featured image
-     */
-    private boolean hasSuitableClassForFeaturedImage(@NonNull String imageTag) {
-        String tagClass = ReaderHtmlUtils.getClassAttrValue(imageTag);
-        return (tagClass != null
-                && (tagClass.contains("size-full")
-                    || tagClass.contains("size-large")
-                    || tagClass.contains("size-medium")));
-    }
-
-    /*
-     * same as above, but doesn't enforce the max width - will return the first image found if
-     * no images have their width set
-     */
-    public String getLargestImage() {
-        return getLargestImage(-1);
-    }
-}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.kt b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.kt
new file mode 100644
index 000000000000..9a3deb0d40a7
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/reader/utils/ReaderImageScanner.kt
@@ -0,0 +1,143 @@
+package org.wordpress.android.ui.reader.utils
+
+import org.wordpress.android.ui.reader.models.ReaderImageList
+import org.wordpress.android.ui.reader.utils.ReaderHtmlUtils.HtmlScannerListener
+import java.util.regex.Pattern
+import kotlin.math.max
+
+class ReaderImageScanner(private val content: String, private val isPrivate: Boolean) {
+    private val contentContainsImages =
+        content.contains("<img")
+
+    /*
+    * start scanning the content for images and notify the passed listener about each one
+    */
+    fun beginScan(listener: HtmlScannerListener) {
+        if (!contentContainsImages) {
+            return
+        }
+
+        val imgMatcher = IMG_TAG_PATTERN.matcher(content)
+        while (imgMatcher.find()) {
+            val imageTag = imgMatcher.group(0).orEmpty()
+            val imageUrl = imgMatcher.group(1).orEmpty()
+            listener.onTagFound(imageTag, imageUrl)
+        }
+    }
+
+    /*
+     * returns a list of image URLs in the content up to the max above a certain width.
+     * pass zero as the count to include all images regardless of size.
+     */
+    @Suppress("NestedBlockDepth")
+    fun getImageList(maxImageCount: Int, minImageWidth: Int): ReaderImageList {
+        val imageList = ReaderImageList(isPrivate)
+
+        if (!contentContainsImages) {
+            return imageList
+        }
+
+        val imgMatcher = IMG_TAG_PATTERN.matcher(content)
+        while (imgMatcher.find()) {
+            val imageTag = imgMatcher.group(0).orEmpty()
+            val imageUrl = imgMatcher.group(1).orEmpty()
+
+            if (minImageWidth == 0) {
+                imageList.addImageUrl(imageUrl)
+            } else {
+                val width = max(
+                    ReaderHtmlUtils.getWidthAttrValue(imageTag).toDouble(),
+                    ReaderHtmlUtils.getIntQueryParam(imageUrl, "w").toDouble()
+                ).toInt()
+                if (width >= minImageWidth) {
+                    imageList.addImageUrl(imageUrl)
+                    if (maxImageCount > 0 && imageList.size >= maxImageCount) {
+                        break
+                    }
+                }
+            }
+        }
+
+        return imageList
+    }
+
+    /*
+     * returns true if there at least `minImageCount` images in the post content that are at
+     * least `minImageWidth` in size
+     */
+    fun hasUsableImageCount(minImageCount: Int, minImageWidth: Int): Boolean {
+        return getImageList(minImageCount, minImageWidth).size == minImageCount
+    }
+
+    /*
+     * used when a post doesn't have a featured image assigned, searches post's content
+     * for an image that may be large enough to be suitable as a featured image
+     */
+    fun getLargestImage(minImageWidth: Int): String? {
+        if (!contentContainsImages) {
+            return null
+        }
+
+        var currentImageUrl: String? = null
+        var currentMaxWidth = minImageWidth
+
+        val imgMatcher = IMG_TAG_PATTERN.matcher(content)
+        while (imgMatcher.find()) {
+            val imageTag = imgMatcher.group(0).orEmpty()
+            val imageUrl = imgMatcher.group(1).orEmpty()
+
+            // Primary source: check the width attribute.
+            val width = max(
+                ReaderHtmlUtils.getWidthAttrValue(imageTag).toDouble(),
+                ReaderHtmlUtils.getIntQueryParam(imageUrl, "w").toDouble()
+            ).toInt()
+            if (width > currentMaxWidth) {
+                currentImageUrl = imageUrl
+                currentMaxWidth = width
+            }
+
+            // Look through the srcset attribute (if set) for the largest available size of this image.
+            ReaderHtmlUtils.getLargestSrcsetImageForTag(imageTag)?.let { bestFromSrcset ->
+                if (bestFromSrcset.width > currentMaxWidth) {
+                    currentMaxWidth = bestFromSrcset.width
+                    currentImageUrl = bestFromSrcset.url
+                }
+            }
+
+            // Check if the image tag's class suggests it's a good enough size.
+            // Only do this if we don't already have a winner, since we can't be sure of the width
+            // and shouldn't replace an image we know for sure is larger than [minImageWidth].
+            if (currentImageUrl == null && hasSuitableClassForFeaturedImage(imageTag!!)) {
+                currentImageUrl = imageUrl
+            }
+
+            // Look for a data-large-file attribute if set and use the associated url.
+            // Only do this if we don't already have a winner, since we can't be sure of the width
+            // and shouldn't replace an image we know for sure is larger than [minImageWidth].
+            if (currentImageUrl == null) {
+                currentImageUrl = ReaderHtmlUtils.getLargeFileAttr(imageTag)
+            }
+        }
+
+        return currentImageUrl
+    }
+
+    /*
+     * returns true if the passed image tag has a "size-" class attribute which would make it
+     * suitable for use as a featured image
+     */
+    private fun hasSuitableClassForFeaturedImage(imageTag: String): Boolean {
+        val tagClass = ReaderHtmlUtils.getClassAttrValue(imageTag)
+        return (tagClass != null
+                && (tagClass.contains("size-full")
+                || tagClass.contains("size-large")
+                || tagClass.contains("size-medium")))
+    }
+
+    companion object {
+        private val IMG_TAG_PATTERN: Pattern = Pattern.compile(
+            "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>",
+            Pattern.CASE_INSENSITIVE
+        )
+    }
+}
