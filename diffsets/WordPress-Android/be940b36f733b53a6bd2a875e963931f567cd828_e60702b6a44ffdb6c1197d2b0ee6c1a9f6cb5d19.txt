diff --git a/WordPress/src/main/java/org/wordpress/android/AppInitializer.kt b/WordPress/src/main/java/org/wordpress/android/AppInitializer.kt
index 6e2361fc19a8..f12b648d29e8 100644
--- a/WordPress/src/main/java/org/wordpress/android/AppInitializer.kt
+++ b/WordPress/src/main/java/org/wordpress/android/AppInitializer.kt
@@ -56,6 +56,7 @@ import org.wordpress.android.fluxc.generated.SiteActionBuilder
 import org.wordpress.android.fluxc.generated.ThemeActionBuilder
 import org.wordpress.android.fluxc.network.UserAgent
 import org.wordpress.android.fluxc.network.rest.wpcom.site.PrivateAtomicCookie
+import org.wordpress.android.auth.WordPressCookieAuthenticator
 import org.wordpress.android.fluxc.store.AccountStore
 import org.wordpress.android.fluxc.store.AccountStore.OnAccountChanged
 import org.wordpress.android.fluxc.store.AccountStore.OnAuthenticationChanged
@@ -165,6 +166,9 @@ class AppInitializer @Inject constructor(
     @Inject
     lateinit var privateAtomicCookie: PrivateAtomicCookie
 
+    @Inject
+    lateinit var wordPressCookieAuthenticator: WordPressCookieAuthenticator
+
     @Inject
     lateinit var imageEditorTracker: ImageEditorTracker
 
@@ -723,6 +727,9 @@ class AppInitializer @Inject constructor(
         // Remove private Atomic cookie
         privateAtomicCookie.clearCookie()
 
+        // Clear WordPress.com account cookie cache
+        wordPressCookieAuthenticator.clearAllCachedCookies()
+
         // Clear cached assignments if user has logged out. This can be removed once we start using an anonymous ID.
         exPlat.clear()
     }
diff --git a/WordPress/src/main/java/org/wordpress/android/auth/WordPressCookieAuthenticator.kt b/WordPress/src/main/java/org/wordpress/android/auth/WordPressCookieAuthenticator.kt
new file mode 100644
index 000000000000..501988e57756
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/auth/WordPressCookieAuthenticator.kt
@@ -0,0 +1,380 @@
+package org.wordpress.android.auth
+
+import com.google.gson.Gson
+import com.google.gson.GsonBuilder
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlinx.coroutines.withContext
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.FormBody
+import okhttp3.HttpUrl
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import org.wordpress.android.fluxc.utils.PreferenceUtils.PreferenceUtilsWrapper
+import org.wordpress.android.util.AppLog
+import java.io.IOException
+import javax.inject.Inject
+import javax.inject.Named
+import javax.inject.Singleton
+import kotlin.coroutines.resume
+import kotlin.coroutines.resumeWithException
+import androidx.core.content.edit
+
+/**
+ * Utility class for WordPress.com cookie authentication.
+ * Handles Bearer token authentication to retrieve session cookies.
+ * Uses WPAndroid's configured OkHttpClient with proper cookie handling.
+ * Implements automatic caching to avoid unnecessary network requests.
+ */
+@Singleton
+class WordPressCookieAuthenticator @Inject constructor(
+    @Named("regular") private val okHttpClient: OkHttpClient,
+    @Named("IO_THREAD") private val ioDispatcher: CoroutineDispatcher,
+    private val preferenceUtils: PreferenceUtilsWrapper
+) {
+    companion object {
+        private const val WP_LOGIN_URL = "https://wordpress.com/wp-login.php"
+        private const val CONTENT_TYPE_FORM = "application/x-www-form-urlencoded"
+        private const val WPCOM_COOKIE_CACHE_PREFIX = "WPCOM_COOKIE_CACHE_"
+        private const val COOKIE_CACHE_EXPIRATION_HOURS = 24 * 30 * 6 // 6 months (approximately)
+        private const val MILLIS_PER_SECOND = 1000L
+        private const val SECONDS_PER_HOUR = 3600L
+    }
+
+    private val gson: Gson by lazy {
+        GsonBuilder().create()
+    }
+
+    /**
+     * Data class for cached cookie information
+     */
+    private data class CachedCookieData(
+        val cookies: Map<String, String>,
+        val expirationTimestamp: Long
+    )
+
+    /**
+     * Data class for authentication parameters
+     */
+    data class AuthParams(
+        val username: String,
+        val bearerToken: String,
+        val userAgent: String
+    )
+
+    /**
+     * Data class for validated authentication parameters (internal use)
+     */
+    private data class ValidatedAuthParams(
+        val username: String,
+        val bearerToken: String,
+        val userAgent: String
+    )
+
+    /**
+     * Data class for authentication result
+     */
+    sealed class AuthResult {
+        data class Success(val cookies: Map<String, String>) : AuthResult()
+        data class Failure(val error: String) : AuthResult()
+    }
+
+    /**
+     * Authenticates with WordPress.com and retrieves session cookies using coroutines.
+     * This is the preferred method for Kotlin callers.
+     * Automatically handles caching to avoid unnecessary network requests.
+     *
+     * @param params Authentication parameters including username, Bearer token, and user agent
+     * @return AuthResult containing either success with cookies or failure with error message
+     */
+    suspend fun authenticateForCookies(params: AuthParams): AuthResult = withContext(ioDispatcher) {
+        // Validate parameters
+        if (params.username.isBlank()) {
+            return@withContext AuthResult.Failure("Username cannot be empty")
+        }
+
+        if (params.bearerToken.isBlank()) {
+            return@withContext AuthResult.Failure("Bearer token cannot be empty")
+        }
+
+        AppLog.d(
+            AppLog.T.API,
+            "Starting WordPress.com account cookie authentication for user: ${params.username}"
+        )
+
+        // Check cache first
+        val cachedCookies = getCachedCookies(params.username)
+        if (cachedCookies != null) {
+            AppLog.d(
+                AppLog.T.API,
+                "WordPress.com account cookie cache hit for user: ${params.username}"
+            )
+            return@withContext AuthResult.Success(cachedCookies)
+        }
+
+        AppLog.d(
+            AppLog.T.API,
+            "WordPress.com account cookie cache miss for user: ${params.username}, making network request"
+        )
+
+        // Create validated parameters after validation checks pass
+        val validatedParams = ValidatedAuthParams(
+            username = params.username,
+            bearerToken = params.bearerToken,
+            userAgent = params.userAgent
+        )
+
+        return@withContext performAuthenticationRequest(validatedParams)
+    }
+
+    /**
+     * Performs the actual authentication request and handles caching of successful results.
+     * Accepts only validated parameters, ensuring all validation has been completed.
+     */
+    private suspend fun performAuthenticationRequest(validatedParams: ValidatedAuthParams): AuthResult {
+        try {
+            // Build form body with authentication parameters
+            val formBody = FormBody.Builder()
+                .add("log", validatedParams.username)
+                .add("rememberme", "true")
+                .build()
+
+            // Build HTTP request matching curl command
+            val request = Request.Builder()
+                .url(WP_LOGIN_URL)
+                .post(formBody)
+                .addHeader("Content-Type", CONTENT_TYPE_FORM)
+                .addHeader("Authorization", "Bearer ${validatedParams.bearerToken}")
+                .addHeader("User-Agent", validatedParams.userAgent)
+                .build()
+
+            AppLog.d(
+                AppLog.T.API,
+                "Making POST account cookie authentication request to: $WP_LOGIN_URL"
+            )
+            AppLog.d(AppLog.T.API, "Request form body: log=${validatedParams.username}&rememberme=true")
+            AppLog.d(AppLog.T.API, "Request User-Agent: ${validatedParams.userAgent}")
+            AppLog.d(AppLog.T.API, "Request Content-Type: $CONTENT_TYPE_FORM")
+
+            // Execute request and wait for response
+            val response = executeRequest(request)
+            return response.use {
+                val result = handleAuthResponse(response)
+
+                // Cache successful results
+                if (result is AuthResult.Success) {
+                    cacheCookies(validatedParams.username, result.cookies)
+                    AppLog.d(
+                        AppLog.T.API,
+                        "WordPress.com account cookies cached for user: ${validatedParams.username}"
+                    )
+                }
+
+                result
+            }
+        } catch (e: IOException) {
+            AppLog.e(
+                AppLog.T.API,
+                "WordPress.com account cookie authentication error: ${e.message}"
+            )
+            return AuthResult.Failure("Authentication error: ${e.message}")
+        }
+    }
+
+    /**
+     * Executes HTTP request using coroutines with proper cancellation support
+     */
+    private suspend fun executeRequest(request: Request): Response =
+        suspendCancellableCoroutine { continuation ->
+            val call = okHttpClient.newCall(request)
+
+            call.enqueue(object : Callback {
+                override fun onFailure(call: Call, e: IOException) {
+                    if (continuation.isActive) {
+                        continuation.resumeWithException(e)
+                    }
+                }
+
+                override fun onResponse(call: Call, response: Response) {
+                    if (continuation.isActive) {
+                        continuation.resume(response)
+                    }
+                }
+            })
+
+            continuation.invokeOnCancellation {
+                call.cancel()
+            }
+        }
+
+    /**
+     * Handles the authentication response and extracts cookies
+     */
+    private fun handleAuthResponse(response: Response): AuthResult {
+        AppLog.d(AppLog.T.API, "Account cookie auth response code: ${response.code}")
+        AppLog.d(AppLog.T.API, "Account cookie auth response message: ${response.message}")
+        AppLog.d(AppLog.T.API, "Response headers: ${response.headers}")
+
+        if (!response.isSuccessful) {
+            AppLog.w(
+                AppLog.T.API,
+                "WordPress.com account cookie authentication unsuccessful: HTTP ${response.code}"
+            )
+            return AuthResult.Failure("HTTP error: ${response.code}")
+        }
+
+        // Log all Set-Cookie headers for debugging
+        val allCookieHeaders = response.headers("Set-Cookie")
+        AppLog.d(AppLog.T.API, "Total Set-Cookie headers: ${allCookieHeaders.size}")
+        for (cookieHeader in allCookieHeaders) {
+            AppLog.d(AppLog.T.API, "Raw cookie header: $cookieHeader")
+        }
+
+        // Extract authentication cookies from CookieJar instead of headers
+        val cookies = extractAuthenticationCookiesFromJar(response.request.url)
+
+        return if (cookies.isEmpty()) {
+            AppLog.w(AppLog.T.API, "No WordPress.com account cookies found in response")
+            AuthResult.Failure("No authentication cookies received")
+        } else {
+            AppLog.d(
+                AppLog.T.API,
+                "Successfully retrieved ${cookies.size} WordPress.com account cookies"
+            )
+            for (cookieName in cookies.keys) {
+                AppLog.d(AppLog.T.API, "Received WordPress.com account cookie: $cookieName")
+            }
+            AuthResult.Success(cookies)
+        }
+    }
+
+    /**
+     * Extracts WordPress authentication cookies from the CookieJar
+     */
+    private fun extractAuthenticationCookiesFromJar(url: HttpUrl): Map<String, String> {
+        val cookies = mutableMapOf<String, String>()
+
+        // Get all cookies from the CookieJar for the request URL
+        val jarCookies = okHttpClient.cookieJar.loadForRequest(url)
+        AppLog.d(AppLog.T.API, "Total cookies in jar for ${url.host}: ${jarCookies.size}")
+
+        for (cookie in jarCookies) {
+            cookies[cookie.name] = cookie.value
+            AppLog.d(
+                AppLog.T.API,
+                "Extracted WordPress.com account cookie from jar: ${cookie.name}"
+            )
+        }
+
+        return cookies
+    }
+
+    /**
+     * Gets cached cookies for a user if they exist and are not expired
+     */
+    private fun getCachedCookies(username: String): Map<String, String>? {
+        val cacheKey = getCacheKey(username)
+        val cachedDataJson = preferenceUtils.getFluxCPreferences().getString(cacheKey, null)
+
+        if (cachedDataJson == null) {
+            AppLog.d(
+                AppLog.T.API,
+                "No cached WordPress.com account cookie data found for user: $username"
+            )
+            return null
+        }
+
+        return try {
+            val cachedData = gson.fromJson(cachedDataJson, CachedCookieData::class.java)
+            val currentTime = System.currentTimeMillis() / MILLIS_PER_SECOND
+
+            if (currentTime >= cachedData.expirationTimestamp) {
+                AppLog.d(
+                    AppLog.T.API,
+                    "Cached WordPress.com account cookies expired for user: $username, clearing cache"
+                )
+                clearCachedCookies(username)
+                null
+            } else {
+                AppLog.d(
+                    AppLog.T.API,
+                    "Valid cached WordPress.com account cookies found for user: $username"
+                )
+                cachedData.cookies
+            }
+        } catch (e: com.google.gson.JsonSyntaxException) {
+            AppLog.w(
+                AppLog.T.API,
+                "Failed to parse cached WordPress.com account cookie data for " +
+                        "user: $username, clearing cache: ${e.message}"
+            )
+            clearCachedCookies(username)
+            null
+        }
+    }
+
+    /**
+     * Caches cookies for a user with expiration timestamp
+     */
+    private fun cacheCookies(username: String, cookies: Map<String, String>) {
+        val cacheKey = getCacheKey(username)
+        val currentTime = System.currentTimeMillis() / MILLIS_PER_SECOND
+        val expirationTime = currentTime + (COOKIE_CACHE_EXPIRATION_HOURS * SECONDS_PER_HOUR)
+
+        val cachedData = CachedCookieData(
+            cookies = cookies,
+            expirationTimestamp = expirationTime
+        )
+
+        val cachedDataJson = gson.toJson(cachedData)
+        preferenceUtils.getFluxCPreferences().edit {
+            putString(cacheKey, cachedDataJson)
+        }
+
+        AppLog.d(
+            AppLog.T.API,
+            "Cached ${cookies.size} WordPress.com account cookies for user: $username, expires at: $expirationTime"
+        )
+    }
+
+    /**
+     * Clears cached cookies for a specific user
+     */
+    fun clearCachedCookies(username: String) {
+        val cacheKey = getCacheKey(username)
+        preferenceUtils.getFluxCPreferences().edit {
+            remove(cacheKey)
+        }
+
+        AppLog.d(AppLog.T.API, "Cleared cached WordPress.com account cookies for user: $username")
+    }
+
+    /**
+     * Clears all cached cookies (useful for logout)
+     */
+    fun clearAllCachedCookies() {
+        val preferences = preferenceUtils.getFluxCPreferences()
+        val editor = preferences.edit()
+        val allKeys = preferences.all.keys
+
+        var clearedCount = 0
+        for (key in allKeys) {
+            if (key.startsWith(WPCOM_COOKIE_CACHE_PREFIX)) {
+                editor.remove(key)
+                clearedCount++
+            }
+        }
+
+        editor.apply()
+        AppLog.d(AppLog.T.API, "Cleared $clearedCount cached WordPress.com account cookie entries")
+    }
+
+    /**
+     * Generates cache key for a user
+     */
+    private fun getCacheKey(username: String): String {
+        return WPCOM_COOKIE_CACHE_PREFIX + username
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/modules/ViewModelModule.java b/WordPress/src/main/java/org/wordpress/android/modules/ViewModelModule.java
index ac7f28e0fc09..66dc66748712 100644
--- a/WordPress/src/main/java/org/wordpress/android/modules/ViewModelModule.java
+++ b/WordPress/src/main/java/org/wordpress/android/modules/ViewModelModule.java
@@ -31,6 +31,7 @@
 import org.wordpress.android.ui.photopicker.PhotoPickerViewModel;
 import org.wordpress.android.ui.plans.PlansViewModel;
 import org.wordpress.android.ui.posts.BasicDialogViewModel;
+import org.wordpress.android.ui.posts.EditPostAuthViewModel;
 import org.wordpress.android.ui.posts.EditPostPublishSettingsViewModel;
 import org.wordpress.android.ui.posts.EditorBloggingPromptsViewModel;
 import org.wordpress.android.ui.posts.EditorJetpackSocialViewModel;
@@ -286,6 +287,11 @@ abstract class ViewModelModule {
     @ViewModelKey(StorePostViewModel.class)
     abstract ViewModel storePostViewModel(StorePostViewModel viewModel);
 
+    @Binds
+    @IntoMap
+    @ViewModelKey(EditPostAuthViewModel.class)
+    abstract ViewModel editPostAuthViewModel(EditPostAuthViewModel viewModel);
+
     @Binds
     @IntoMap
     @ViewModelKey(EditPostPublishSettingsViewModel.class)
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.kt b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.kt
index ba9047311ca4..e6473e00ca3c 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostActivity.kt
@@ -431,6 +431,7 @@ class EditPostActivity : BaseAppCompatActivity(), EditorFragmentActivity, Editor
     @Inject lateinit var editorJetpackSocialViewModel: EditorJetpackSocialViewModel
     private lateinit var editPostNavigationViewModel: EditPostNavigationViewModel
     private lateinit var editPostSettingsViewModel: EditPostSettingsViewModel
+    @Inject lateinit var editPostAuthViewModel: EditPostAuthViewModel
 
     private lateinit var siteModel: SiteModel
 
@@ -604,16 +605,23 @@ class EditPostActivity : BaseAppCompatActivity(), EditorFragmentActivity, Editor
         }
         sectionsPagerAdapter = SectionsPagerAdapter(fragmentManager)
 
-        // we need to make sure AT cookie is available when trying to edit post on private AT site
-        if (siteModel.isPrivateWPComAtomic && privateAtomicCookie.isCookieRefreshRequired()) {
-            showIfNecessary(fragmentManager)
-            dispatcher.dispatch(
-                SiteActionBuilder.newFetchPrivateAtomicCookieAction(
-                    SiteStore.FetchPrivateAtomicCookiePayload(siteModel.siteId)
+        // Ensure cookies are available for private sites, so that protected media loads successfully
+        when {
+            siteModel.isPrivateWPComAtomic && privateAtomicCookie.isCookieRefreshRequired() -> {
+                showIfNecessary(fragmentManager)
+                dispatcher.dispatch(
+                    SiteActionBuilder.newFetchPrivateAtomicCookieAction(
+                        SiteStore.FetchPrivateAtomicCookiePayload(siteModel.siteId)
+                    )
                 )
-            )
-        } else {
-            setupViewPager()
+            }
+            siteModel.isWPCom && !siteModel.isWPComAtomic && siteModel.isPrivate -> {
+                showIfNecessary(fragmentManager)
+                editPostAuthViewModel.fetchWpComCookies()
+            }
+            else -> {
+                setupViewPager()
+            }
         }
         ActivityId.trackLastActivity(ActivityId.POST_EDITOR)
         setupPrepublishingBottomSheetRunnable()
@@ -979,6 +987,36 @@ class EditPostActivity : BaseAppCompatActivity(), EditorFragmentActivity, Editor
             AppLog.d(AppLog.T.POSTS, "EditPostActivity: Current destination changed to $destination")
             updateUIForDestination(destination)
         }
+
+        editPostAuthViewModel.wpComCookieAuthState.observe(this) { authState ->
+            when (authState) {
+                is EditPostAuthViewModel.WpComCookieAuthState.Loading -> {
+                    showIfNecessary(supportFragmentManager)
+                }
+                is EditPostAuthViewModel.WpComCookieAuthState.Success -> {
+                    if (isShowing(supportFragmentManager)) {
+                        setupViewPager()
+                        dismissIfNecessary(supportFragmentManager)
+                    } else {
+                        setupViewPager()
+                    }
+                }
+                is EditPostAuthViewModel.WpComCookieAuthState.Error -> {
+                    if (isShowing(supportFragmentManager)) {
+                        setupViewPager()
+                        dismissIfNecessary(supportFragmentManager)
+                    }
+                    make(
+                        findViewById(R.id.editor_activity),
+                        R.string.media_accessing_failed,
+                        Snackbar.LENGTH_LONG
+                    ).show()
+                }
+                is EditPostAuthViewModel.WpComCookieAuthState.Idle -> {
+                    // Do nothing - wait for actual authentication to be triggered
+                }
+            }
+        }
     }
 
     /**
@@ -2614,6 +2652,7 @@ class EditPostActivity : BaseAppCompatActivity(), EditorFragmentActivity, Editor
                 // Limited to Simple sites until application passwords are supported
                 "plugins" to (gutenbergKitPluginsFeature.isEnabled() && site.isWPCom),
                 "locale" to wpcomLocaleSlug,
+                "cookies" to editPostAuthViewModel.getCookiesForPrivateSites(site, privateAtomicCookie),
                 "webViewGlobals" to listOf(
                     WebViewGlobal(
                         "_currentSiteType",
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostAuthViewModel.kt b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostAuthViewModel.kt
new file mode 100644
index 000000000000..e82823bbbcc0
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/posts/EditPostAuthViewModel.kt
@@ -0,0 +1,97 @@
+package org.wordpress.android.ui.posts
+
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import kotlinx.coroutines.CoroutineDispatcher
+import org.wordpress.android.auth.WordPressCookieAuthenticator
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.fluxc.store.AccountStore
+import org.wordpress.android.modules.IO_THREAD
+import org.wordpress.android.fluxc.network.rest.wpcom.site.PrivateAtomicCookie
+import org.wordpress.android.util.AppLog
+import org.wordpress.android.fluxc.network.UserAgent
+import org.wordpress.android.viewmodel.ScopedViewModel
+import javax.inject.Inject
+import javax.inject.Named
+
+class EditPostAuthViewModel @Inject constructor(
+    @Named(IO_THREAD) private val ioDispatcher: CoroutineDispatcher,
+    private val wordPressCookieAuthenticator: WordPressCookieAuthenticator,
+    private val accountStore: AccountStore,
+    private val userAgent: UserAgent
+) : ScopedViewModel(ioDispatcher) {
+    sealed class WpComCookieAuthState {
+        data object Idle : WpComCookieAuthState()
+        data object Loading : WpComCookieAuthState()
+        data class Success(val cookies: Map<String, String>) : WpComCookieAuthState()
+        data class Error(val message: String) : WpComCookieAuthState()
+    }
+
+    private val _wpComCookieAuthState = MutableLiveData<WpComCookieAuthState>(WpComCookieAuthState.Idle)
+    val wpComCookieAuthState: LiveData<WpComCookieAuthState> = _wpComCookieAuthState
+
+    fun fetchWpComCookies() {
+        _wpComCookieAuthState.postValue(WpComCookieAuthState.Loading)
+
+        val authParams = WordPressCookieAuthenticator.AuthParams(
+            username = accountStore.account.userName ?: "",
+            bearerToken = accountStore.accessToken ?: "",
+            userAgent = userAgent.toString()
+        )
+
+        launch {
+            val result = wordPressCookieAuthenticator.authenticateForCookies(authParams)
+            when (result) {
+                is WordPressCookieAuthenticator.AuthResult.Success -> {
+                    _wpComCookieAuthState.postValue(WpComCookieAuthState.Success(result.cookies))
+                }
+
+                is WordPressCookieAuthenticator.AuthResult.Failure -> {
+                    AppLog.e(AppLog.T.EDITOR, "Failed to fetch cookies for Simple site: ${result.error}")
+                    _wpComCookieAuthState.postValue(WpComCookieAuthState.Error(result.error))
+                }
+            }
+        }
+    }
+
+    fun getCookiesForPrivateSites(siteModel: SiteModel, privateAtomicCookie: PrivateAtomicCookie): Map<String, String> {
+        val cookies = when {
+            !siteModel.isPrivate -> emptyMap()
+            siteModel.isWPComAtomic -> getAtomicSiteCookies(siteModel, privateAtomicCookie)
+            siteModel.isWPCom -> getWpComCookies(siteModel)
+            else -> emptyMap()
+        }
+        return cookies
+    }
+
+    private fun getAtomicSiteCookies(
+        siteModel: SiteModel,
+        privateAtomicCookie: PrivateAtomicCookie
+    ): Map<String, String> {
+        val cookies = mutableMapOf<String, String>()
+        if (privateAtomicCookie.exists() && !privateAtomicCookie.isExpired()) {
+            val cookieName = privateAtomicCookie.getName()
+            val cookieValue = privateAtomicCookie.getValue()
+            val cookieDomain = privateAtomicCookie.getDomain()
+            val value = "$cookieName=$cookieValue; domain=$cookieDomain; SameSite=None; Secure; HttpOnly"
+            cookies[siteModel.url] = value
+        }
+        return cookies
+    }
+
+    private fun getWpComCookies(siteModel: SiteModel): Map<String, String> {
+        return when (val currentState = _wpComCookieAuthState.value) {
+            is WpComCookieAuthState.Success -> {
+                currentState.cookies
+                    .entries
+                    .firstOrNull { (name, _) -> name.startsWith("wordpress_logged_in") }
+                    ?.let { (name, value) ->
+                        val cookieString = "$name=$value; domain=.wordpress.com; SameSite=None; Secure; HttpOnly"
+                        mapOf(siteModel.url to cookieString)
+                    }
+                    ?: emptyMap()
+            }
+            else -> emptyMap()
+        }
+    }
+}
diff --git a/WordPress/src/test/java/org/wordpress/android/auth/WordPressCookieAuthenticatorTest.kt b/WordPress/src/test/java/org/wordpress/android/auth/WordPressCookieAuthenticatorTest.kt
new file mode 100644
index 000000000000..2189a5e68c5e
--- /dev/null
+++ b/WordPress/src/test/java/org/wordpress/android/auth/WordPressCookieAuthenticatorTest.kt
@@ -0,0 +1,411 @@
+package org.wordpress.android.auth
+
+import android.content.SharedPreferences
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.runTest
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.CookieJar
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.toResponseBody
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mock
+import org.mockito.junit.MockitoJUnitRunner
+import org.mockito.kotlin.any
+import org.mockito.kotlin.eq
+import org.mockito.kotlin.never
+import org.mockito.kotlin.verify
+import org.mockito.kotlin.whenever
+import org.wordpress.android.fluxc.utils.PreferenceUtils.PreferenceUtilsWrapper
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
+
+@ExperimentalCoroutinesApi
+@RunWith(MockitoJUnitRunner::class)
+class WordPressCookieAuthenticatorTest {
+    @Mock
+    private lateinit var mockCookieJar: CookieJar
+
+    @Mock
+    private lateinit var mockPreferenceUtils: PreferenceUtilsWrapper
+
+    @Mock
+    private lateinit var mockSharedPreferences: SharedPreferences
+
+    @Mock
+    private lateinit var mockEditor: SharedPreferences.Editor
+
+    @Mock
+    private lateinit var mockOkHttpClient: OkHttpClient
+
+    @Mock
+    private lateinit var mockCall: Call
+    private lateinit var testDispatcher: CoroutineDispatcher
+    private lateinit var testScope: TestScope
+    private lateinit var authenticator: WordPressCookieAuthenticator
+
+    @Before
+    fun setUp() {
+        testScope = TestScope()
+        testDispatcher = StandardTestDispatcher(testScope.testScheduler)
+
+        // Mock SharedPreferences chain
+        whenever(mockPreferenceUtils.getFluxCPreferences()).thenReturn(mockSharedPreferences)
+        whenever(mockSharedPreferences.edit()).thenReturn(mockEditor)
+
+        // Mock OkHttpClient to return our mock call
+        whenever(mockOkHttpClient.newCall(any())).thenReturn(mockCall)
+        whenever(mockOkHttpClient.cookieJar).thenReturn(mockCookieJar)
+
+        authenticator = WordPressCookieAuthenticator(mockOkHttpClient, testDispatcher, mockPreferenceUtils)
+    }
+
+    @Test
+    fun `authenticateForCookies should return failure when username is blank`() = testScope.runTest {
+        // Given
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = "",
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("Username cannot be empty", result.error)
+    }
+
+    @Test
+    fun `authenticateForCookies should return failure when username is whitespace only`() = testScope.runTest {
+        // Given
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = "   ",
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("Username cannot be empty", result.error)
+    }
+
+    @Test
+    fun `authenticateForCookies should return failure when bearer token is blank`() = testScope.runTest {
+        // Given
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = "testuser",
+            bearerToken = "",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("Bearer token cannot be empty", result.error)
+    }
+
+    @Test
+    fun `authenticateForCookies should return failure when bearer token is whitespace only`() = testScope.runTest {
+        // Given
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = "testuser",
+            bearerToken = "   ",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("Bearer token cannot be empty", result.error)
+    }
+
+    @Test
+    fun `authenticateForCookies should return cached cookies when cache is valid`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+        val cachedCookies = mapOf("wordpress_logged_in_123" to "cookie_value")
+        val currentTime = System.currentTimeMillis() / 1000
+        val futureTime = currentTime + (3 * 60 * 60) // 3 hours in future
+        val cachedData =
+            "{\"cookies\":{\"wordpress_logged_in_123\":\"cookie_value\"},\"expirationTimestamp\":$futureTime}"
+
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(cachedData)
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Success)
+        assertEquals(cachedCookies, result.cookies)
+    }
+
+    @Test
+    fun `authenticateForCookies should clear expired cache`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+        val currentTime = System.currentTimeMillis() / 1000
+        val pastTime = currentTime - (1 * 60 * 60) // 1 hour in past (expired)
+        val expiredCachedData =
+            "{\"cookies\":{\"wordpress_logged_in_123\":\"expired_value\"},\"expirationTimestamp\":$pastTime}"
+
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(expiredCachedData)
+        whenever(mockEditor.remove(any())).thenReturn(mockEditor)
+
+        // Mock network request to simulate expired cache handling
+        val mockResponse = createMockResponse(200, "<html>Login page</html>")
+        setupMockHttpCall(mockResponse)
+        whenever(mockCookieJar.loadForRequest(any())).thenReturn(emptyList())
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        authenticator.authenticateForCookies(params)
+
+        // Then - Should clear expired cache
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_$username")
+        verify(mockEditor).apply()
+    }
+
+    @Test
+    fun `authenticateForCookies should handle corrupted cache gracefully`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+        val corruptedData = "invalid-json-data"
+
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(corruptedData)
+        whenever(mockEditor.remove(any())).thenReturn(mockEditor)
+
+        // Mock network request for corrupted cache scenario
+        val mockResponse = createMockResponse(200, "<html>Login page</html>")
+        setupMockHttpCall(mockResponse)
+        whenever(mockCookieJar.loadForRequest(any())).thenReturn(emptyList())
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then - Should clear corrupted cache
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_$username")
+        verify(mockEditor).apply()
+
+        // Should make network request after clearing cache
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+    }
+
+    @Test
+    fun `authenticateForCookies should return no cache initially`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+
+        // No cached data initially
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(null)
+
+        // Mock network request for no cache scenario
+        val mockResponse = createMockResponse(200, "<html>Login page</html>")
+        setupMockHttpCall(mockResponse)
+        whenever(mockCookieJar.loadForRequest(any())).thenReturn(emptyList())
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then - Should attempt network request since no cache
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("No authentication cookies received", result.error)
+    }
+
+    @Test
+    fun `clearAllCachedCookies should remove all cookie cache entries`() {
+        // Given
+        val allKeys = setOf(
+            "WPCOM_COOKIE_CACHE_user1",
+            "WPCOM_COOKIE_CACHE_user2",
+            "OTHER_PREF_KEY",
+            "WPCOM_COOKIE_CACHE_user3"
+        )
+        whenever(mockSharedPreferences.all).thenReturn(allKeys.associateWith { "value" })
+        whenever(mockEditor.remove(any())).thenReturn(mockEditor)
+
+        // When
+        authenticator.clearAllCachedCookies()
+
+        // Then - Should only remove WPCOM_COOKIE_CACHE_ prefixed keys
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_user1")
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_user2")
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_user3")
+        verify(mockEditor, never()).remove("OTHER_PREF_KEY")
+        verify(mockEditor).apply()
+    }
+
+    @Test
+    fun `clearCachedCookies should remove specific user cache`() {
+        // Given
+        val username = "testuser"
+        whenever(mockEditor.remove(any())).thenReturn(mockEditor)
+
+        // When
+        authenticator.clearCachedCookies(username)
+
+        // Then
+        verify(mockEditor).remove("WPCOM_COOKIE_CACHE_$username")
+        verify(mockEditor).apply()
+    }
+
+    private fun createMockResponse(code: Int, body: String): Response {
+        val request = Request.Builder()
+            .url("https://wordpress.com/wp-login.php")
+            .build()
+
+        return Response.Builder()
+            .request(request)
+            .protocol(okhttp3.Protocol.HTTP_1_1)
+            .code(code)
+            .message("OK")
+            .body(body.toResponseBody())
+            .build()
+    }
+
+    private fun setupMockHttpCall(mockResponse: Response) {
+        whenever(mockCall.enqueue(any())).thenAnswer { invocation ->
+            val callback = invocation.getArgument<Callback>(0)
+            callback.onResponse(mockCall, mockResponse)
+            null
+        }
+    }
+
+    @Test
+    fun `authenticateForCookies should successfully authenticate and cache cookies`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+        val expectedCookies = mapOf("wordpress_logged_in_123" to "auth_cookie_value")
+
+        // No cached data initially
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(null)
+        whenever(mockEditor.putString(any(), any())).thenReturn(mockEditor)
+
+        // Mock successful network response with cookies
+        val mockResponse = createMockResponse(200, "<html>Success</html>")
+        setupMockHttpCall(mockResponse)
+
+        // Mock cookie jar to return authentication cookies
+        val mockCookie = org.mockito.kotlin.mock<okhttp3.Cookie>()
+        whenever(mockCookie.name).thenReturn("wordpress_logged_in_123")
+        whenever(mockCookie.value).thenReturn("auth_cookie_value")
+        whenever(mockCookieJar.loadForRequest(any())).thenReturn(listOf(mockCookie))
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Success)
+        assertEquals(expectedCookies, result.cookies)
+
+        // Verify cookies were cached
+        verify(mockEditor).putString(eq("WPCOM_COOKIE_CACHE_$username"), any())
+        verify(mockEditor).apply()
+    }
+
+    @Test
+    fun `authenticateForCookies should handle HTTP error response`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+
+        // No cached data initially
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(null)
+
+        // Mock HTTP error response
+        val mockResponse = createMockResponse(401, "<html>Unauthorized</html>")
+        setupMockHttpCall(mockResponse)
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "invalid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("HTTP error: 401", result.error)
+    }
+
+    @Test
+    fun `authenticateForCookies should handle network failure`() = testScope.runTest {
+        // Given
+        val username = "testuser"
+
+        // No cached data initially
+        whenever(mockSharedPreferences.getString("WPCOM_COOKIE_CACHE_$username", null))
+            .thenReturn(null)
+
+        // Mock network failure
+        whenever(mockCall.enqueue(any())).thenAnswer { invocation ->
+            val callback = invocation.getArgument<Callback>(0)
+            callback.onFailure(mockCall, java.io.IOException("Network error"))
+            null
+        }
+
+        val params = WordPressCookieAuthenticator.AuthParams(
+            username = username,
+            bearerToken = "valid-token",
+            userAgent = "test-agent"
+        )
+
+        // When
+        val result = authenticator.authenticateForCookies(params)
+
+        // Then
+        assertTrue(result is WordPressCookieAuthenticator.AuthResult.Failure)
+        assertEquals("Authentication error: Network error", result.error)
+    }
+}
diff --git a/WordPress/src/test/java/org/wordpress/android/ui/posts/EditPostAuthViewModelTest.kt b/WordPress/src/test/java/org/wordpress/android/ui/posts/EditPostAuthViewModelTest.kt
new file mode 100644
index 000000000000..e58230463e84
--- /dev/null
+++ b/WordPress/src/test/java/org/wordpress/android/ui/posts/EditPostAuthViewModelTest.kt
@@ -0,0 +1,283 @@
+package org.wordpress.android.ui.posts
+
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import org.junit.Before
+import org.junit.Test
+import org.mockito.Mock
+import org.mockito.kotlin.whenever
+import org.wordpress.android.BaseUnitTest
+import org.wordpress.android.auth.WordPressCookieAuthenticator
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.fluxc.store.AccountStore
+import org.wordpress.android.fluxc.network.rest.wpcom.site.PrivateAtomicCookie
+import org.wordpress.android.fluxc.network.UserAgent
+import org.wordpress.android.fluxc.model.AccountModel
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
+
+@ExperimentalCoroutinesApi
+class EditPostAuthViewModelTest : BaseUnitTest() {
+    @Mock
+    private lateinit var wordPressCookieAuthenticator: WordPressCookieAuthenticator
+
+    @Mock
+    private lateinit var accountStore: AccountStore
+
+    @Mock
+    private lateinit var userAgent: UserAgent
+
+    @Mock
+    private lateinit var account: AccountModel
+
+    private lateinit var viewModel: EditPostAuthViewModel
+
+    private fun createMockPrivateAtomicCookie(
+        exists: Boolean = true,
+        isExpired: Boolean = false,
+        name: String = "atomic_cookie",
+        value: String = "cookie_value",
+        domain: String = ".example.wordpress.com"
+    ): PrivateAtomicCookie {
+        val mockCookie = org.mockito.kotlin.mock<PrivateAtomicCookie>()
+        whenever(mockCookie.exists()).thenReturn(exists)
+        if (exists && !isExpired) {
+            whenever(mockCookie.isExpired()).thenReturn(isExpired)
+            whenever(mockCookie.getName()).thenReturn(name)
+            whenever(mockCookie.getValue()).thenReturn(value)
+            whenever(mockCookie.getDomain()).thenReturn(domain)
+        }
+        return mockCookie
+    }
+
+    @Before
+    fun setUp() {
+        whenever(accountStore.account).thenReturn(account)
+        whenever(account.userName).thenReturn("testuser")
+        whenever(accountStore.accessToken).thenReturn("test-token")
+        whenever(userAgent.toString()).thenReturn("WordPress/Test")
+
+        viewModel = EditPostAuthViewModel(
+            testDispatcher(),
+            wordPressCookieAuthenticator,
+            accountStore,
+            userAgent
+        )
+    }
+
+    @Test
+    fun `fetchWpComCookies posts Loading then Success states`() = test {
+        // Given
+        val stateChanges = mutableListOf<EditPostAuthViewModel.WpComCookieAuthState>()
+        val expectedCookies = mapOf("wordpress_logged_in_123" to "cookie_value")
+
+        whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+            .thenReturn(WordPressCookieAuthenticator.AuthResult.Success(expectedCookies))
+
+        // Observe state changes
+        viewModel.wpComCookieAuthState.observeForever { state ->
+            stateChanges.add(state)
+        }
+
+        // When
+        viewModel.fetchWpComCookies()
+        advanceUntilIdle()
+
+        // Then - Should have seen Loading then Success states
+        assertTrue(stateChanges.size >= 2)
+        assertTrue(stateChanges[stateChanges.size - 2] is EditPostAuthViewModel.WpComCookieAuthState.Loading)
+        val finalState = stateChanges.last()
+        assertTrue(finalState is EditPostAuthViewModel.WpComCookieAuthState.Success)
+        assertEquals(expectedCookies, finalState.cookies)
+    }
+
+    @Test
+    fun `fetchWpComCookies transitions to Success on successful authentication`() = test {
+        // Given
+        val expectedCookies = mapOf("wordpress_logged_in_123" to "cookie_value")
+        whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+            .thenReturn(WordPressCookieAuthenticator.AuthResult.Success(expectedCookies))
+
+        // When
+        viewModel.fetchWpComCookies()
+        advanceUntilIdle()
+
+        // Then
+        val state = viewModel.wpComCookieAuthState.value
+        assertTrue(state is EditPostAuthViewModel.WpComCookieAuthState.Success)
+        assertEquals(expectedCookies, state.cookies)
+    }
+
+    @Test
+    fun `fetchWpComCookies transitions to Error on authentication failure`() = test {
+        // Given
+        val errorMessage = "Authentication failed"
+        whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+            .thenReturn(WordPressCookieAuthenticator.AuthResult.Failure(errorMessage))
+
+        // When
+        viewModel.fetchWpComCookies()
+        advanceUntilIdle()
+
+        // Then
+        val state = viewModel.wpComCookieAuthState.value
+        assertTrue(state is EditPostAuthViewModel.WpComCookieAuthState.Error)
+        assertEquals(errorMessage, state.message)
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns empty for non-private sites`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsPrivate(false)
+        }
+
+        // When
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+
+        // Then
+        assertTrue(cookies.isEmpty())
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns empty for non-WPCom sites`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(false)
+            setIsPrivate(true)
+        }
+
+        // When
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+
+        // Then
+        assertTrue(cookies.isEmpty())
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns atomic cookies for atomic sites`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsWPComAtomic(true)
+            setIsPrivate(true)
+            url = "https://example.wordpress.com"
+        }
+        val atomicCookie = createMockPrivateAtomicCookie()
+
+        // When
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, atomicCookie)
+
+        // Then
+        assertEquals(1, cookies.size)
+        assertTrue(cookies.containsKey(siteModel.url))
+        assertTrue(cookies[siteModel.url]?.contains("atomic_cookie=cookie_value") == true)
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns empty for atomic sites when cookie does not exist`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsWPComAtomic(true)
+            setIsPrivate(true)
+        }
+        val atomicCookie = createMockPrivateAtomicCookie(exists = false)
+
+        // When
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, atomicCookie)
+
+        // Then
+        assertTrue(cookies.isEmpty())
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns wpcom cookies for simple private sites after authentication`() =
+        test {
+            // Given
+            val siteModel = SiteModel().apply {
+                setIsWPCom(true)
+                setIsWPComAtomic(false)
+                setIsPrivate(true)
+                url = "https://example.wordpress.com"
+            }
+            val expectedCookies = mapOf("wordpress_logged_in_123" to "cookie_value")
+            whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+                .thenReturn(WordPressCookieAuthenticator.AuthResult.Success(expectedCookies))
+
+            // When - First authenticate
+            viewModel.fetchWpComCookies()
+            advanceUntilIdle()
+
+            // Then - Get cookies should return formatted cookies
+            val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+            assertEquals(1, cookies.size)
+            assertTrue(cookies.containsKey(siteModel.url))
+            assertTrue(cookies[siteModel.url]?.contains("wordpress_logged_in_123=cookie_value") == true)
+            assertTrue(cookies[siteModel.url]?.contains("domain=.wordpress.com") == true)
+        }
+
+    @Test
+    fun `getCookiesForPrivateSites returns empty for simple sites before authentication`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsWPComAtomic(false)
+            setIsPrivate(true)
+        }
+
+        // When - Get cookies without authentication
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+
+        // Then
+        assertTrue(cookies.isEmpty())
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites returns empty for simple sites after authentication failure`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsWPComAtomic(false)
+            setIsPrivate(true)
+        }
+        whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+            .thenReturn(WordPressCookieAuthenticator.AuthResult.Failure("Auth failed"))
+
+        // When
+        viewModel.fetchWpComCookies()
+        advanceUntilIdle()
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+
+        // Then
+        assertTrue(cookies.isEmpty())
+    }
+
+    @Test
+    fun `getCookiesForPrivateSites filters non-wordpress_logged_in cookies`() = test {
+        // Given
+        val siteModel = SiteModel().apply {
+            setIsWPCom(true)
+            setIsWPComAtomic(false)
+            setIsPrivate(true)
+            url = "https://example.wordpress.com"
+        }
+        val mixedCookies = mapOf(
+            "some_other_cookie" to "other_value",
+            "wordpress_logged_in_123" to "auth_value",
+            "another_cookie" to "another_value"
+        )
+        whenever(wordPressCookieAuthenticator.authenticateForCookies(org.mockito.kotlin.any()))
+            .thenReturn(WordPressCookieAuthenticator.AuthResult.Success(mixedCookies))
+
+        // When
+        viewModel.fetchWpComCookies()
+        advanceUntilIdle()
+        val cookies = viewModel.getCookiesForPrivateSites(siteModel, createMockPrivateAtomicCookie())
+
+        // Then - Only wordpress_logged_in cookie should be included
+        assertEquals(1, cookies.size)
+        assertTrue(cookies[siteModel.url]?.contains("wordpress_logged_in_123=auth_value") == true)
+        assertTrue(cookies[siteModel.url]?.contains("some_other_cookie") == false)
+    }
+}
diff --git a/libs/editor/src/main/java/org/wordpress/android/editor/gutenberg/GutenbergKitEditorFragment.java b/libs/editor/src/main/java/org/wordpress/android/editor/gutenberg/GutenbergKitEditorFragment.java
index 33c5350b1de6..86c118adfeb4 100644
--- a/libs/editor/src/main/java/org/wordpress/android/editor/gutenberg/GutenbergKitEditorFragment.java
+++ b/libs/editor/src/main/java/org/wordpress/android/editor/gutenberg/GutenbergKitEditorFragment.java
@@ -57,6 +57,7 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -578,6 +579,12 @@ public void startWithEditorSettings(@NonNull String editorSettings) {
         var firstNamespace = siteApiNamespace != null && siteApiNamespace.length > 0 ? siteApiNamespace[0] : "";
         var editorAssetsEndpoint = siteApiRoot + "wpcom/v2/" + firstNamespace + "editor-assets";
 
+        @SuppressWarnings("unchecked")
+        Map<String, String> cookies = (Map<String, String>) mSettings.get("cookies");
+        if (cookies == null) {
+            cookies = new HashMap<>();
+        }
+
         EditorConfiguration config = new EditorConfiguration.Builder()
                 .setTitle((String) mSettings.get("postTitle"))
                 .setContent((String) mSettings.get("postContent"))
@@ -595,6 +602,7 @@ public void startWithEditorSettings(@NonNull String editorSettings) {
                 .setEditorAssetsEndpoint(editorAssetsEndpoint)
                 .setCachedAssetHosts(Set.of("s0.wp.com", UrlUtils.getHost(siteURL)))
                 .setEnableAssetCaching(true)
+                .setCookies(cookies)
                 .build();
 
         mEditorStarted = true;
