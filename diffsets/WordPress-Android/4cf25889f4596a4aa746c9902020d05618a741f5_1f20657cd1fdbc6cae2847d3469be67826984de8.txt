diff --git a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionActivity.kt b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionActivity.kt
index bd52a9d35eaf..49b3c54a01fe 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionActivity.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionActivity.kt
@@ -138,20 +138,26 @@ class SuggestionActivity : LocaleAwareActivity() {
             showDropdownOnTouch()
         }
 
-        viewModel.suggestions.observe(this, Observer {
-            val isFirstUpdate = suggestionAdapter?.suggestionList == null
-            suggestionAdapter?.suggestionList = it
+        viewModel.suggestions.observe(this, Observer { suggestions ->
+            if (suggestions.isEmpty()) {
+                // Notify user that there are no suggestions and exit the suggestions activity because
+                // there is nothing the user can do here if there aren't any suggestions
+                val message = getString(string.suggestion_none, viewModel.suggestionTypeString)
+                ToastUtils.showToast(this@SuggestionActivity, message)
+                finish()
+            }
 
-            // Calling forceFiltering seemed to be the only way to force the suggestions list to
-            // immediately refresh with the new data
+            suggestionAdapter?.suggestionList = suggestions
+
+            // Calling forceFiltering is needed to force the suggestions list to always
+            // immediately refresh when there is new data
             autocompleteText.forceFiltering(autocompleteText.text)
 
             // Ensure that the suggestions list is displayed wth the new data. This is particularly needed when
-            // suggestion list was empty before the new data was received, otherwise the no-longer-empty suggestion
-            // list will not display when it is updated. We don't want to call showDropDown on the first update
-            // both because it is only needed when an empty list is updated, and because it avoids a crash when there
-            // is no internet connection.
-            if (!isFirstUpdate) {
+            // suggestion list was empty before the new data was received, otherwise the no-longer-empty
+            // suggestion list will not display when it is updated. Wrapping this in the isAttachedToWindow
+            // check avoids a crash if the suggestions are loaded when the view is not attached.
+            if (autocompleteText.isAttachedToWindow) {
                 autocompleteText.showDropDown()
             }
 
@@ -227,6 +233,9 @@ class SuggestionActivity : LocaleAwareActivity() {
     override fun onResume() {
         super.onResume()
         EventBus.getDefault().register(this)
+        if (autocompleteText.isAttachedToWindow) {
+            autocompleteText.showDropDown()
+        }
     }
 
     override fun onPause() {
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionSourceProvider.kt b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionSourceProvider.kt
new file mode 100644
index 000000000000..93cae9e1f0d7
--- /dev/null
+++ b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionSourceProvider.kt
@@ -0,0 +1,18 @@
+package org.wordpress.android.ui.suggestion
+
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.ui.suggestion.SuggestionType.Users
+import org.wordpress.android.ui.suggestion.SuggestionType.XPosts
+import javax.inject.Inject
+
+class SuggestionSourceProvider @Inject constructor(
+    private val suggestionSourceSubcomponentFactory: SuggestionSourceSubcomponent.Factory
+) {
+    fun get(type: SuggestionType, site: SiteModel): SuggestionSource {
+        val factory = suggestionSourceSubcomponentFactory.create(site)
+        return when (type) {
+            XPosts -> factory.xPostSuggestionSource()
+            Users -> factory.userSuggestionSource()
+        }
+    }
+}
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionViewModel.kt b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionViewModel.kt
index f517ee152afe..cff2bc81e283 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionViewModel.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/SuggestionViewModel.kt
@@ -18,7 +18,7 @@ import org.wordpress.android.viewmodel.ResourceProvider
 import javax.inject.Inject
 
 class SuggestionViewModel @Inject constructor(
-    private val suggestionSourceSubcomponentFactory: SuggestionSourceSubcomponent.Factory,
+    private val suggestionSourceProvider: SuggestionSourceProvider,
     private val resourceProvider: ResourceProvider,
     private val networkUtils: NetworkUtilsWrapper
 ) : ViewModel() {
@@ -34,7 +34,7 @@ class SuggestionViewModel @Inject constructor(
         }
     }
 
-    private val suggestionTypeString: String by lazy {
+    val suggestionTypeString: String by lazy {
         resourceProvider.getString(
                 when (type) {
                     XPosts -> R.string.suggestion_xpost
@@ -46,7 +46,7 @@ class SuggestionViewModel @Inject constructor(
     fun init(type: SuggestionType, site: SiteModel) =
             if (supportsSuggestions(site)) {
                 this.type = type
-                suggestionSource = getSuggestionSourceForType(type, site)
+                suggestionSource = suggestionSourceProvider.get(type, site)
                 true
             } else {
                 AppLog.e(T.EDITOR, "Attempting to initialize suggestions for an unsupported site")
@@ -55,20 +55,8 @@ class SuggestionViewModel @Inject constructor(
 
     private fun supportsSuggestions(site: SiteModel): Boolean = SiteUtils.isAccessedViaWPComRest(site)
 
-    private fun getSuggestionSourceForType(
-        type: SuggestionType,
-        site: SiteModel
-    ): SuggestionSource {
-        val suggestionSourceSubcomponent = suggestionSourceSubcomponentFactory.create(site)
-        return when (type) {
-            Users -> suggestionSourceSubcomponent.userSuggestionSource()
-            XPosts -> suggestionSourceSubcomponent.xPostSuggestionSource()
-        }
-    }
-
     fun onConnectionChanged(event: ConnectionChangeEvent) {
-        val hasNoSuggestions = suggestionSource.suggestions.value?.isEmpty() == true
-        if (event.isConnected && hasNoSuggestions) {
+        if (event.isConnected) {
             suggestionSource.refreshSuggestions()
         }
     }
@@ -121,6 +109,6 @@ class SuggestionViewModel @Inject constructor(
 data class EmptyViewState(val string: String, val visibility: Int)
 
 sealed class FinishAttempt {
-    class OnlyOneAvailable(val onlySelectedValue: String) : FinishAttempt()
-    class NotExactlyOneAvailable(val errorMessage: String) : FinishAttempt()
+    data class OnlyOneAvailable(val onlySelectedValue: String) : FinishAttempt()
+    data class NotExactlyOneAvailable(val errorMessage: String) : FinishAttempt()
 }
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/UserSuggestionSource.kt b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/UserSuggestionSource.kt
index 4e25a94a4f0a..76900a2dfccb 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/UserSuggestionSource.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/UserSuggestionSource.kt
@@ -31,17 +31,21 @@ class UserSuggestionSource @Inject constructor(
     override val suggestions: LiveData<List<Suggestion>> = _suggestions
 
     init {
-        postSavedSuggestions()
+        postSavedSuggestions(false)
         connectionManager.bindToService()
         eventBusWrapper.register(this)
     }
 
-    private fun postSavedSuggestions() {
+    private fun postSavedSuggestions(suggestionsWereJustUpdated: Boolean) {
         launch {
             val suggestions = Suggestion.fromUserSuggestions(
                     UserSuggestionTable.getSuggestionsForSite(site.siteId)
             )
-            _suggestions.postValue(suggestions)
+
+            // Only send empty suggestions if they are recent
+            if (suggestions.isNotEmpty() || suggestionsWereJustUpdated) {
+                _suggestions.postValue(suggestions)
+            }
         }
     }
 
@@ -55,7 +59,7 @@ class UserSuggestionSource @Inject constructor(
     @Subscribe
     fun onEventMainThread(event: SuggestionNameListUpdated) {
         if (event.mRemoteBlogId == site.siteId) {
-            postSavedSuggestions()
+            postSavedSuggestions(true)
         }
     }
 
diff --git a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/XPostsSuggestionSource.kt b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/XPostsSuggestionSource.kt
index eb588ff922c6..8b882293700b 100644
--- a/WordPress/src/main/java/org/wordpress/android/ui/suggestion/XPostsSuggestionSource.kt
+++ b/WordPress/src/main/java/org/wordpress/android/ui/suggestion/XPostsSuggestionSource.kt
@@ -7,6 +7,7 @@ import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.launch
 import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.fluxc.store.XPostsSource.REST_API
 import org.wordpress.android.fluxc.store.XPostsStore
 import org.wordpress.android.modules.BG_THREAD
 import javax.inject.Inject
@@ -29,19 +30,26 @@ class XPostsSuggestionSource @Inject constructor(
                     .getXPostsFromDb(site)
                     .map { Suggestion.fromXpost(it) }
                     .sortedBy { it.value }
-            _suggestions.postValue(suggestions)
+            if (suggestions.isNotEmpty()) {
+                _suggestions.postValue(suggestions)
+            }
         }
         refreshSuggestions()
     }
 
     override fun refreshSuggestions() {
         launch {
-            val suggestions = xPostsStore
-                    .fetchXPosts(site)
-                    .xPosts
-                    .map { Suggestion.fromXpost(it) }
-                    .sortedBy { it.value }
-            _suggestions.postValue(suggestions)
+            val result = xPostsStore.fetchXPosts(site)
+
+            // We already checked the DB when this class was initialized,
+            // so we only care if the suggestions have been updated
+            if (result.source == REST_API) {
+                val sortedSuggestions = result
+                        .xPosts
+                        .map { Suggestion.fromXpost(it) }
+                        .sortedBy { it.value }
+                _suggestions.postValue(sortedSuggestions)
+            }
         }
     }
 
diff --git a/WordPress/src/main/res/values/strings.xml b/WordPress/src/main/res/values/strings.xml
index 02960d5473e8..c110bc824536 100644
--- a/WordPress/src/main/res/values/strings.xml
+++ b/WordPress/src/main/res/values/strings.xml
@@ -2329,6 +2329,7 @@
     <string name="tap_to_try_again">Tap to try again!</string>
     <string name="add_media_progress">Adding media</string>
     <string name="suggestion_invalid">"%s is not a valid %s"</string>
+    <string name="suggestion_none">"No %s suggestions available."</string>
     <string name="suggestion_no_matching">"No matching %s."</string>
     <string name="suggestion_no_connection">"No internet connection.\nSuggestions are unavailable."</string>
     <string name="suggestion_user">user</string>
diff --git a/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionSourceProviderTest.kt b/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionSourceProviderTest.kt
new file mode 100644
index 000000000000..ac77f8544e60
--- /dev/null
+++ b/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionSourceProviderTest.kt
@@ -0,0 +1,47 @@
+package org.wordpress.android.ui.suggestion
+
+import com.nhaarman.mockitokotlin2.mock
+import com.nhaarman.mockitokotlin2.whenever
+import junit.framework.Assert.assertEquals
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.InjectMocks
+import org.mockito.Mock
+import org.mockito.junit.MockitoJUnitRunner
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.ui.suggestion.SuggestionType.Users
+import org.wordpress.android.ui.suggestion.SuggestionType.XPosts
+
+@RunWith(MockitoJUnitRunner::class)
+class SuggestionSourceProviderTest {
+    @Mock lateinit var mockSuggestionSourceSubcomponentFactory: SuggestionSourceSubcomponent.Factory
+    @Mock lateinit var mockSuggestionSourceSubcomponent: SuggestionSourceSubcomponent
+    @Mock lateinit var mockSite: SiteModel
+
+    @InjectMocks lateinit var provider: SuggestionSourceProvider
+
+    @Before
+    fun setUp() {
+        whenever(mockSuggestionSourceSubcomponentFactory.create(mockSite))
+                .thenReturn(mockSuggestionSourceSubcomponent)
+    }
+
+    @Test
+    fun `gets xpost source`() {
+        val expected = mock<XPostsSuggestionSource>()
+        whenever(mockSuggestionSourceSubcomponent.xPostSuggestionSource())
+                .thenReturn(expected)
+        val actual = provider.get(XPosts, mockSite)
+        assertEquals(expected, actual)
+    }
+
+    @Test
+    fun `gets user source`() {
+        val expected = mock<UserSuggestionSource>()
+        whenever(mockSuggestionSourceSubcomponent.userSuggestionSource())
+                .thenReturn(expected)
+        val actual = provider.get(Users, mockSite)
+        assertEquals(expected, actual)
+    }
+}
diff --git a/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionViewModelTest.kt b/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionViewModelTest.kt
new file mode 100644
index 000000000000..e110f0cd6894
--- /dev/null
+++ b/WordPress/src/test/java/org/wordpress/android/ui/suggestion/SuggestionViewModelTest.kt
@@ -0,0 +1,236 @@
+package org.wordpress.android.ui.suggestion
+
+import android.view.View
+import androidx.lifecycle.LiveData
+import com.nhaarman.mockitokotlin2.mock
+import com.nhaarman.mockitokotlin2.never
+import com.nhaarman.mockitokotlin2.verify
+import com.nhaarman.mockitokotlin2.whenever
+import junit.framework.Assert.assertEquals
+import junit.framework.Assert.assertFalse
+import junit.framework.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.InjectMocks
+import org.mockito.Mock
+import org.mockito.junit.MockitoJUnitRunner
+import org.wordpress.android.R
+import org.wordpress.android.fluxc.model.SiteModel
+import org.wordpress.android.networking.ConnectionChangeReceiver.ConnectionChangeEvent
+import org.wordpress.android.ui.suggestion.FinishAttempt.NotExactlyOneAvailable
+import org.wordpress.android.ui.suggestion.FinishAttempt.OnlyOneAvailable
+import org.wordpress.android.ui.suggestion.SuggestionType.Users
+import org.wordpress.android.ui.suggestion.SuggestionType.XPosts
+import org.wordpress.android.util.NetworkUtilsWrapper
+import org.wordpress.android.viewmodel.ResourceProvider
+
+@RunWith(MockitoJUnitRunner::class)
+class SuggestionViewModelTest {
+    @Mock lateinit var mockSuggestionSourceProvider: SuggestionSourceProvider
+    @Mock lateinit var mockResourceProvider: ResourceProvider
+    @Mock lateinit var mockNetworkUtils: NetworkUtilsWrapper
+    @Mock lateinit var mockSite: SiteModel
+    @Mock lateinit var mockLiveData: LiveData<List<Suggestion>>
+    @Mock lateinit var mockSuggestionSource: SuggestionSource
+
+    @InjectMocks lateinit var viewModel: SuggestionViewModel
+
+    private val xpostSuggestionTypeString = "xpost_suggestion_type_string"
+    private val userSuggestionTypeString = "user_suggestion_type_string"
+
+    @Before
+    fun setUp() {
+        setSuggestionsSupported(true)
+
+        whenever(mockResourceProvider.getString(R.string.suggestion_xpost)).thenReturn(xpostSuggestionTypeString)
+        whenever(mockResourceProvider.getString(R.string.suggestion_user)).thenReturn(userSuggestionTypeString)
+
+        whenever(mockSuggestionSource.suggestions).thenReturn(mockLiveData)
+    }
+
+    @Test
+    fun `init when suggestions not supported`() {
+        setSuggestionsSupported(false)
+        val anySuggestionType = XPosts
+        assertFalse(viewModel.init(anySuggestionType, mockSite))
+    }
+
+    @Test
+    fun `init with xpost suggestions`() {
+        assertTrue(initViewModel(XPosts))
+        verifyViewModelSuggestionType(XPosts)
+    }
+
+    @Test
+    fun `init with user suggestions`() {
+        assertTrue(initViewModel(Users))
+        verifyViewModelSuggestionType(Users)
+    }
+
+    @Test
+    fun `onConnectionChanged not connected`() {
+        initViewModel()
+        viewModel.onConnectionChanged(ConnectionChangeEvent(false))
+        verify(mockSuggestionSource, never()).refreshSuggestions()
+    }
+
+    @Test
+    fun `onConnectionChanged connected`() {
+        initViewModel()
+        viewModel.onConnectionChanged(ConnectionChangeEvent(true))
+        verify(mockSuggestionSource).refreshSuggestions()
+    }
+
+    @Test
+    fun `getEmptyViewState visibility gone`() {
+        initViewModel()
+        stubEmptyViewStateText()
+
+        val nonEmptyList = listOf(mock<Suggestion>())
+        val actual = viewModel.getEmptyViewState(nonEmptyList)
+        assertEquals(View.GONE, actual.visibility)
+    }
+
+    @Test
+    fun `getEmptyViewState visibility visible`() {
+        initViewModel()
+        whenever(mockLiveData.value).thenReturn(emptyList())
+        stubEmptyViewStateText()
+
+        val actual = viewModel.getEmptyViewState(emptyList())
+        assertEquals(View.VISIBLE, actual.visibility)
+    }
+
+    private fun stubEmptyViewStateText() {
+        whenever(mockNetworkUtils.isNetworkAvailable()).thenReturn(true)
+        whenever(mockResourceProvider.getString(R.string.loading)).thenReturn("")
+    }
+
+    @Test
+    fun `getEmptyViewState text no matching suggestions if suggestions available`() {
+        initViewModel()
+        val nonEmptyList = listOf(mock<Suggestion>())
+        whenever(mockLiveData.value).thenReturn(nonEmptyList)
+        val expectedText = "expected_text"
+        whenever(mockResourceProvider.getString(R.string.suggestion_no_matching, viewModel.suggestionTypeString))
+                .thenReturn(expectedText)
+
+        val actual = viewModel.getEmptyViewState(emptyList())
+        assertEquals(expectedText, actual.string)
+    }
+
+    @Test
+    fun `getEmptyViewState text loading if no suggestions available but network available`() {
+        initViewModel()
+        whenever(mockLiveData.value).thenReturn(emptyList())
+        whenever(mockNetworkUtils.isNetworkAvailable()).thenReturn(true)
+        val expectedText = "expected_text"
+        whenever(mockResourceProvider.getString(R.string.loading))
+                .thenReturn(expectedText)
+
+        val actual = viewModel.getEmptyViewState(emptyList())
+        assertEquals(expectedText, actual.string)
+    }
+
+    @Test
+    fun `getEmptyViewState text no internet if no suggestions available and network unavailable`() {
+        initViewModel()
+        whenever(mockLiveData.value).thenReturn(emptyList())
+        whenever(mockNetworkUtils.isNetworkAvailable()).thenReturn(false)
+        val expectedText = "expected_text"
+        whenever(mockResourceProvider.getString(R.string.suggestion_no_connection))
+                .thenReturn(expectedText)
+
+        val actual = viewModel.getEmptyViewState(emptyList())
+        assertEquals(expectedText, actual.string)
+    }
+
+    @Test
+    fun `onAttemptToFinish no displayed suggestions`() {
+        initViewModel()
+        val userInput = "user_input"
+        val expectedMesage = "expected_message"
+        whenever(
+                mockResourceProvider.getString(
+                        R.string.suggestion_invalid,
+                        userInput, viewModel.suggestionTypeString
+                )
+        )
+                .thenReturn(expectedMesage)
+
+        val actual = viewModel.onAttemptToFinish(emptyList(), userInput)
+
+        val expected = NotExactlyOneAvailable(expectedMesage)
+        assertEquals(expected, actual)
+    }
+
+    @Test
+    fun `onAttemptToFinish multiple displayed suggestions`() {
+        initViewModel()
+        val userInput = "user_input"
+        val expectedMesage = "expected_message"
+        whenever(
+                mockResourceProvider.getString(
+                        R.string.suggestion_invalid,
+                        userInput, viewModel.suggestionTypeString
+                )
+        )
+                .thenReturn(expectedMesage)
+
+        val listWithMoreThanOne = listOf<Suggestion>(mock(), mock())
+        val actual = viewModel.onAttemptToFinish(listWithMoreThanOne, userInput)
+
+        val expected = NotExactlyOneAvailable(expectedMesage)
+        assertEquals(expected, actual)
+    }
+
+    @Test
+    fun `onAttemptToFinish exactly 1 displayed suggestion`() {
+        initViewModel()
+
+        val mockSuggestion = Suggestion("", "expected_value", "")
+        val listWithExactlyOne = listOf<Suggestion>(mockSuggestion)
+        val actual = viewModel.onAttemptToFinish(listWithExactlyOne, "")
+
+        val expected = OnlyOneAvailable(mockSuggestion.value)
+        assertEquals(expected, actual)
+    }
+
+    private fun initViewModel(type: SuggestionType = XPosts): Boolean {
+        whenever(mockSuggestionSourceProvider.get(type, mockSite)).thenReturn(mockSuggestionSource)
+        return viewModel.init(type, mockSite)
+    }
+
+    private fun verifyViewModelSuggestionType(type: SuggestionType) {
+        verifySuggestionPrefix(type)
+        verifySuggestionTypeString(type)
+    }
+
+    private fun verifySuggestionPrefix(type: SuggestionType) {
+        val expectedPrefix = when (type) {
+            XPosts -> '+'
+            Users -> '@'
+        }
+        val actualPrefix = viewModel.suggestionPrefix
+        assertEquals(expectedPrefix, actualPrefix)
+    }
+
+    private fun verifySuggestionTypeString(type: SuggestionType) {
+        val expectedTypeString = when (type) {
+            XPosts -> xpostSuggestionTypeString
+            Users -> userSuggestionTypeString
+        }
+        val actualTypeString = viewModel.suggestionTypeString
+        assertEquals(expectedTypeString, actualTypeString)
+    }
+
+    private fun setSuggestionsSupported(areSupported: Boolean) {
+        val origin = if (areSupported) {
+            SiteModel.ORIGIN_WPCOM_REST
+        } else {
+            SiteModel.ORIGIN_UNKNOWN
+        }
+        whenever(mockSite.origin).thenReturn(origin)
+    }
+}
