diff --git a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/PagedListFactory.kt b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/PagedListFactory.kt
index 94eecdc9b8b4..9b4f102e7c6b 100644
--- a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/PagedListFactory.kt
+++ b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/PagedListFactory.kt
@@ -9,12 +9,12 @@ import org.wordpress.android.fluxc.model.list.datastore.InternalPagedListDataSto
  *
  * @param createDataStore A function that creates an instance of [InternalPagedListDataStore].
  */
-class PagedListFactory<LD : ListDescriptor, ID, T>(
-    private val createDataStore: () -> InternalPagedListDataStore<LD, ID, T>
-) : DataSource.Factory<Int, T>() {
-    private var currentSource: PagedListPositionalDataSource<LD, ID, T>? = null
+class PagedListFactory<LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM>(
+    private val createDataStore: () -> InternalPagedListDataStore<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>
+) : DataSource.Factory<Int, LIST_ITEM>() {
+    private var currentSource: PagedListPositionalDataSource<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>? = null
 
-    override fun create(): DataSource<Int, T> {
+    override fun create(): DataSource<Int, LIST_ITEM> {
         val source = PagedListPositionalDataSource(dataStore = createDataStore.invoke())
         currentSource = source
         return source
@@ -26,14 +26,14 @@ class PagedListFactory<LD : ListDescriptor, ID, T>(
 }
 
 /**
- * A positional data source for [T].
+ * A positional data source for [LIST_ITEM].
  *
- * @param dataStore Describes how to take certain actions such as fetching list for the item type [T].
+ * @param dataStore Describes how to take certain actions such as fetching list for the item type [LIST_ITEM].
  */
-private class PagedListPositionalDataSource<LD : ListDescriptor, ID, T>(
-    private val dataStore: InternalPagedListDataStore<LD, ID, T>
-) : PositionalDataSource<T>() {
-    override fun loadInitial(params: LoadInitialParams, callback: LoadInitialCallback<T>) {
+private class PagedListPositionalDataSource<LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM>(
+    private val dataStore: InternalPagedListDataStore<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>
+) : PositionalDataSource<LIST_ITEM>() {
+    override fun loadInitial(params: LoadInitialParams, callback: LoadInitialCallback<LIST_ITEM>) {
         val totalSize = dataStore.totalSize
         val startPosition = computeInitialLoadPosition(params, totalSize)
         val loadSize = computeInitialLoadSize(params, startPosition, totalSize)
@@ -45,12 +45,12 @@ private class PagedListPositionalDataSource<LD : ListDescriptor, ID, T>(
         }
     }
 
-    override fun loadRange(params: LoadRangeParams, callback: LoadRangeCallback<T>) {
+    override fun loadRange(params: LoadRangeParams, callback: LoadRangeCallback<LIST_ITEM>) {
         val items = loadRangeInternal(params.startPosition, params.loadSize)
         callback.onResult(items)
     }
 
-    private fun loadRangeInternal(startPosition: Int, loadSize: Int): List<T> {
+    private fun loadRangeInternal(startPosition: Int, loadSize: Int): List<LIST_ITEM> {
         val endPosition = startPosition + loadSize
         if (startPosition == endPosition) {
             return emptyList()
diff --git a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/InternalPagedListDataStore.kt b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/InternalPagedListDataStore.kt
index b1a81947807c..e9bb7e034c61 100644
--- a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/InternalPagedListDataStore.kt
+++ b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/InternalPagedListDataStore.kt
@@ -9,16 +9,12 @@ import org.wordpress.android.fluxc.model.list.ListDescriptor
  *
  * It takes a snapshot of the identifiers for the list when it's created and propagates the calls from the PagedList
  * data source to [ListItemDataStoreInterface] using these identifiers.
- *
- * [LD] represents the ListDescriptor
- * [ID] represents the identifier for the type [T]
- * [T] represents the end result type that'll be used by `PagedList`.
  */
-class InternalPagedListDataStore<LD : ListDescriptor, ID, T>(
-    private val listDescriptor: LD,
+class InternalPagedListDataStore<LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM>(
+    private val listDescriptor: LIST_DESCRIPTOR,
     remoteItemIds: List<RemoteId>,
     isListFullyFetched: Boolean,
-    private val itemDataStore: ListItemDataStoreInterface<LD, ID, T>
+    private val itemDataStore: ListItemDataStoreInterface<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>
 ) {
     /*
      * PagedList library needs a snapshot of the data. It does the heavy lifting by caching the items provided to it,
@@ -37,22 +33,22 @@ class InternalPagedListDataStore<LD : ListDescriptor, ID, T>(
         get() = itemIdentifiers.size
 
     /**
-     * Returns the list of items [T] by propagating the call to [ListItemDataStoreInterface]
+     * Returns the list of items [LIST_ITEM] by propagating the call to [ListItemDataStoreInterface]
      *
      * @param startPosition Start position that's inclusive
      * @param endPosition End position that's exclusive
      */
-    fun getItemsInRange(startPosition: Int, endPosition: Int): List<T> =
+    fun getItemsInRange(startPosition: Int, endPosition: Int): List<LIST_ITEM> =
             itemDataStore.getItemsAndFetchIfNecessary(listDescriptor, getItemIds(startPosition, endPosition))
 
     /**
-     * Helper function that returns the list of identifiers [ID] for the given start and end positions using the
+     * Helper function that returns the list [ITEM_IDENTIFIER]s for the given start and end positions using the
      * internal [itemIdentifiers].
      *
      * @param startPosition Start position that's inclusive
      * @param endPosition End position that's exclusive
      */
-    private fun getItemIds(startPosition: Int, endPosition: Int): List<ID> {
+    private fun getItemIds(startPosition: Int, endPosition: Int): List<ITEM_IDENTIFIER> {
         require(startPosition in 0..endPosition && endPosition <= totalSize) {
             "Illegal start($startPosition) or end($endPosition) position for totalSize($totalSize)"
         }
diff --git a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/ListItemDataStoreInterface.kt b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/ListItemDataStoreInterface.kt
index 728c89825e0a..4130864e7e9c 100644
--- a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/ListItemDataStoreInterface.kt
+++ b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/model/list/datastore/ListItemDataStoreInterface.kt
@@ -5,22 +5,23 @@ import org.wordpress.android.fluxc.model.list.ListDescriptor
 
 /**
  * An interface used to tell how to take certain actions to manage a `PagedList`.
- *
- * [LD] represents the ListDescriptor
- * [ID] represents the identifier for the type [T]
- * [T] represents the end result type that'll be used by `PagedList`.
  */
-interface ListItemDataStoreInterface<LD : ListDescriptor, ID, T> {
+interface ListItemDataStoreInterface<LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM> {
     /**
-     * Should return a list of items [T] for the given [ListDescriptor] and the list of identifiers [ID] that
-     * will be provided by [getItemIdentifiers]. It should also fetch the missing items if necessary.
+     * Should return a list [LIST_ITEM]s for the given [LIST_DESCRIPTOR] and the list [ITEM_IDENTIFIER]s that will be
+     * provided by [getItemIdentifiers].
+     *
+     * It should also fetch the missing items if necessary.
      */
-    fun getItemsAndFetchIfNecessary(listDescriptor: LD, itemIdentifiers: List<ID>): List<T>
+    fun getItemsAndFetchIfNecessary(
+        listDescriptor: LIST_DESCRIPTOR,
+        itemIdentifiers: List<ITEM_IDENTIFIER>
+    ): List<LIST_ITEM>
 
     /**
-     * Should transform a list of remote ids for the given [ListDescriptor] to a list of identifiers [ID] to be
-     * used by [getItemsAndFetchIfNecessary]. This method allows the implementation of this interface to make the
-     * modifications to the list as necessary. For example, a list could be transformed to:
+     * Should transform a list of remote ids for the given [LIST_DESCRIPTOR] to a list [ITEM_IDENTIFIER]s to be used by
+     * [getItemsAndFetchIfNecessary]. This method allows the implementation of this interface to make the modifications
+     * to the list as necessary. For example, a list could be transformed to:
      *
      * * Add a header
      * * Add an end list indicator
@@ -28,13 +29,13 @@ interface ListItemDataStoreInterface<LD : ListDescriptor, ID, T> {
      * * Add section headers
      */
     fun getItemIdentifiers(
-        listDescriptor: LD,
+        listDescriptor: LIST_DESCRIPTOR,
         remoteItemIds: List<RemoteId>,
         isListFullyFetched: Boolean
-    ): List<ID>
+    ): List<ITEM_IDENTIFIER>
 
     /**
-     * Should fetch the list for the given [ListDescriptor] and an offset.
+     * Should fetch the list for the given [LIST_DESCRIPTOR] and an offset.
      */
-    fun fetchList(listDescriptor: LD, offset: Long)
+    fun fetchList(listDescriptor: LIST_DESCRIPTOR, offset: Long)
 }
diff --git a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/store/ListStore.kt b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/store/ListStore.kt
index 48a40d2f0300..07f170042df7 100644
--- a/libs/fluxc/src/main/java/org/wordpress/android/fluxc/store/ListStore.kt
+++ b/libs/fluxc/src/main/java/org/wordpress/android/fluxc/store/ListStore.kt
@@ -72,18 +72,18 @@ class ListStore @Inject constructor(
      * This is the function that'll be used to consume lists.
      *
      * @param listDescriptor Describes which list will be consumed
-     * @param dataStore Describes how to take certain actions such as fetching a list for the item type [T].
+     * @param dataStore Describes how to take certain actions such as fetching a list for the item type [LIST_ITEM].
      * @param lifecycle The lifecycle of the client that'll be consuming this list. It's used to make sure everything
      * is cleaned up properly once the client is destroyed.
      *
      * @return A [PagedListWrapper] that provides all the necessary information to consume a list such as its data,
      * whether the first page is being fetched, whether there are any errors etc. in `LiveData` format.
      */
-    fun <LD : ListDescriptor, ID, T> getList(
-        listDescriptor: LD,
-        dataStore: ListItemDataStoreInterface<LD, ID, T>,
+    fun <LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM> getList(
+        listDescriptor: LIST_DESCRIPTOR,
+        dataStore: ListItemDataStoreInterface<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>,
         lifecycle: Lifecycle
-    ): PagedListWrapper<T> {
+    ): PagedListWrapper<LIST_ITEM> {
         val factory = createPagedListFactory(listDescriptor, dataStore)
         val pagedListData = createPagedListLiveData(
                 listDescriptor = listDescriptor,
@@ -108,21 +108,21 @@ class ListStore @Inject constructor(
     }
 
     /**
-     * A helper function that creates a [PagedList] [LiveData] for the given [listDescriptor], [dataStore] and the
+     * A helper function that creates a [PagedList] [LiveData] for the given [LIST_DESCRIPTOR], [dataStore] and the
      * [PagedListFactory].
      */
-    private fun <LD : ListDescriptor, ID, T> createPagedListLiveData(
-        listDescriptor: LD,
-        dataStore: ListItemDataStoreInterface<LD, ID, T>,
-        pagedListFactory: PagedListFactory<LD, ID, T>
-    ): LiveData<PagedList<T>> {
+    private fun <LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM> createPagedListLiveData(
+        listDescriptor: LIST_DESCRIPTOR,
+        dataStore: ListItemDataStoreInterface<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>,
+        pagedListFactory: PagedListFactory<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>
+    ): LiveData<PagedList<LIST_ITEM>> {
         val pagedListConfig = PagedList.Config.Builder()
                 .setEnablePlaceholders(true)
                 .setInitialLoadSizeHint(listDescriptor.config.initialLoadSize)
                 .setPageSize(listDescriptor.config.dbPageSize)
                 .build()
-        val boundaryCallback = object : BoundaryCallback<T>() {
-            override fun onItemAtEndLoaded(itemAtEnd: T) {
+        val boundaryCallback = object : BoundaryCallback<LIST_ITEM>() {
+            override fun onItemAtEndLoaded(itemAtEnd: LIST_ITEM) {
                 // Load more items if we are near the end of list
                 handleFetchList(listDescriptor, loadMore = true) { offset ->
                     dataStore.fetchList(listDescriptor, offset)
@@ -130,17 +130,17 @@ class ListStore @Inject constructor(
                 super.onItemAtEndLoaded(itemAtEnd)
             }
         }
-        return LivePagedListBuilder<Int, T>(pagedListFactory, pagedListConfig)
+        return LivePagedListBuilder<Int, LIST_ITEM>(pagedListFactory, pagedListConfig)
                 .setBoundaryCallback(boundaryCallback).build()
     }
 
     /**
-     * A helper function that creates a [PagedListFactory] for the given [listDescriptor] and [dataStore].
+     * A helper function that creates a [PagedListFactory] for the given [LIST_DESCRIPTOR] and [dataStore].
      */
-    private fun <LD : ListDescriptor, ID, T> createPagedListFactory(
-        listDescriptor: LD,
-        dataStore: ListItemDataStoreInterface<LD, ID, T>
-    ): PagedListFactory<LD, ID, T> {
+    private fun <LIST_DESCRIPTOR : ListDescriptor, ITEM_IDENTIFIER, LIST_ITEM> createPagedListFactory(
+        listDescriptor: LIST_DESCRIPTOR,
+        dataStore: ListItemDataStoreInterface<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM>
+    ): PagedListFactory<LIST_DESCRIPTOR, ITEM_IDENTIFIER, LIST_ITEM> {
         val getRemoteItemIds = { getListItems(listDescriptor).map { RemoteId(value = it) } }
         val getIsListFullyFetched = { getListState(listDescriptor) == FETCHED }
         return PagedListFactory(
