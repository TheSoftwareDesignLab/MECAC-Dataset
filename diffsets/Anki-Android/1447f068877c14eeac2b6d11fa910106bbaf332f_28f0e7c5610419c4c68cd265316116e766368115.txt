diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index a011fa7770dc..7091fb5b70fc 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -733,12 +733,21 @@ protected void onPause() {
         	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
     		adapter.removeButtonListener(this);
     		adapter = null;
-        }        
+        }
         
 		super.onPause();
 		waitForDeckLoaderThread();
 	}
 
+	@Override
+	protected void onStop() {
+		Log.i(AnkiDroidApp.TAG, "DeckPicker - onStop");
+		super.onStop();
+		if (!isFinishing() && mIsFinished) {
+			WidgetStatus.update(this);
+		}
+	}
+
 	@Override
 	protected void onDestroy() {
 		super.onDestroy();
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
index 7c9ff3c185b7..4120a0d5db80 100644
--- a/src/com/ichi2/anki/DeckTask.java
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -80,7 +80,6 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
 
     private int mType;
     private TaskListener mListener;
-    private boolean mIsCanceled;
     
     public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData... params) {
         sOldInstance = sInstance;
@@ -242,11 +241,6 @@ protected void onPostExecute(TaskData result) {
     }
 
 
-    public static void cancelTask() {
-    	sInstance.mIsCanceled = true;
-    }
-
-
     private TaskData doInBackgroundAddFact(TaskData[] params) {
         // Save the fact
         Deck deck = params[0].getDeck();
@@ -560,7 +554,7 @@ private TaskData doInBackgroundLoadCards(TaskData... params) {
         int chunk = params[0].getInt();
     	Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadCards");
     	String startId = "";
-    	while (!mIsCanceled) {
+    	while (!this.isCancelled()) {
     		ArrayList<HashMap<String, String>> cards = deck.getCards(chunk, startId);
     		if (cards.size() == 0) {
     			break;
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 1ade10eb0a34..5a45e9838263 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -957,7 +957,6 @@ protected void onPause() {
 	            DeckTask.waitToFinish();
 	            deck.commitToDB();
             }
-            WidgetStatus.update(getBaseContext());
         }
 
         if (mShakeEnabled) {
@@ -1001,6 +1000,7 @@ protected void onStop() {
       if (mShakeEnabled) {
           mSensorManager.unregisterListener(mSensorListener);    	  
       }
+      WidgetStatus.update(getBaseContext(), true);
       super.onStop();
     }
 
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 7104c0629cd4..15cf7bbacf6f 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -826,22 +826,32 @@ protected void onDestroy() {
     }
 
 
-     @Override
-     protected void onPause() {
-         if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
-         	Log.d("Zeemote","Removing listener in onPause");
-         	AnkiDroidApp.zeemoteController().removeButtonListener(this);
-         	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
-     		adapter.removeButtonListener(this);
-     		adapter = null;
-         }
-    	 
-         super.onPause();
-         // Update the widget when pausing this activity.
-         if (!mInDeckPicker && !mInReviewer) {
-             WidgetStatus.update(getBaseContext());
-         }
-     }
+    @Override
+    protected void onPause() {
+        if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
+        	Log.d("Zeemote","Removing listener in onPause");
+        	AnkiDroidApp.zeemoteController().removeButtonListener(this);
+        	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
+    		adapter.removeButtonListener(this);
+    		adapter = null;
+        }
+   	 
+        super.onPause();
+    }
+
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        // Update the widget when stopping this activity (all when closing, only current when pressing home).
+        if (!mInDeckPicker && !mInReviewer) {
+        	if (isFinishing()) {
+                WidgetStatus.update(getBaseContext());
+        	} else {
+                WidgetStatus.update(getBaseContext(), true);
+        	}
+        }
+    }
 
 
     @Override
diff --git a/src/com/ichi2/anki/WidgetStatus.java b/src/com/ichi2/anki/WidgetStatus.java
index 0b77eda72c34..95028e3bc616 100644
--- a/src/com/ichi2/anki/WidgetStatus.java
+++ b/src/com/ichi2/anki/WidgetStatus.java
@@ -39,6 +39,7 @@ public final class WidgetStatus {
 	private static boolean mediumWidget = false;
 	private static boolean smallWidget = false;
 	private static boolean notification = false;
+	private static boolean onlyCurrentDeck = false;
 	private static AsyncTask<Context,Void,Context> mUpdateDeckStatusAsyncTask;
 
     /** This class should not be instantiated. */
@@ -46,8 +47,11 @@ private WidgetStatus() {}
 
     /** Request the widget to update its status. */
     public static void update(Context context) {
-        // Only update the widget if it is enabled.
-        // TODO(flerda): Split widget from notifications.
+    	update(context, false);
+    }
+    /** Request the widget to update its status. */
+    public static void update(Context context, boolean onlyCurrent) {
+    	onlyCurrentDeck = onlyCurrent;
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
         if (preferences.getBoolean("widgetMediumEnabled", false)) {
             mediumWidget = true;
@@ -59,7 +63,7 @@ public static void update(Context context) {
         } else {
             smallWidget = false;
         }
-        if (Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25")) < 1000000) {
+        if (Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25")) < 1000000 && !onlyCurrentDeck) {
         	notification = true;
         } else {
         	notification = false;
@@ -116,74 +120,103 @@ protected Context doInBackground(Context... params) {
             	return context;
             }
 
-            SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-            String deckPath = preferences.getString("deckPath",
-                    AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
+            // For the deck information
+            ArrayList<DeckStatus> decks;
+
+            if (onlyCurrentDeck) {
+                decks = new ArrayList<DeckStatus>(mDecks.length);
+
+                Deck currentDeck = AnkiDroidApp.deck();
+                if (currentDeck != null) {
+                	String currentDeckPath = currentDeck.getDeckPath();
+                	try {
+                		for (DeckStatus m : mDecks) {
+                			if (m.mDeckPath.equals(currentDeckPath)) {
+                    			Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + currentDeckPath);
+                				decks.add(new DeckStatus(currentDeckPath, currentDeck.getDeckName(), currentDeck.getNewCountToday(), currentDeck.getRevCount(), currentDeck.getFailedSoonCount(), currentDeck.getETA(), currentDeck.getSessionFinishedCards()));
+                			} else {
+                    			Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
+                				decks.add(m);
+                			}
+                		}
+                    } catch (SQLException e) {
+                        Log.i(AnkiDroidApp.TAG, "Widget: Could not retrieve deck information");
+                        Log.e(AnkiDroidApp.TAG, e.toString());
+                        if (currentDeckPath != null) {
+                            BackupManager.restoreDeckIfMissing(currentDeckPath);                    	
+                        }
+                    }
+                }
 
-            File dir = new File(deckPath);
+            } else {
+                SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+                String deckPath = preferences.getString("deckPath",
+                        AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
 
-            File[] fileList = dir.listFiles(new AnkiFileFilter());
+                File dir = new File(deckPath);
 
-            if (fileList == null || fileList.length == 0) {
-                mDecks = EMPTY_DECK_STATUS;
-                return context;
-            }
+                File[] fileList = dir.listFiles(new AnkiFileFilter());
 
-            // For the deck information
-            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
-
-            for (File file : fileList) {
-            	String absPath = null;
-                try {
-                    // Run through the decks and get the information
-                    absPath = file.getAbsolutePath();
-                    String deckName = file.getName().replaceAll(".anki", "");
-
-                    Log.i(AnkiDroidApp.TAG, "Found deck: " + absPath);
-
-                    Deck deck;
-                    Deck currentDeck = AnkiDroidApp.deck();
-                    if (currentDeck != null && currentDeck.getDeckPath().equals(deckName)) {
-                    	deck = currentDeck;
-                    } else {
-                    	try {
-                        	deck = Deck.openDeck(absPath, false);                    		
-            			} catch (RuntimeException e) {
-            				Log.w(AnkiDroidApp.TAG, "Widget: Could not open database " + absPath + ": " + e);
-            				BackupManager.restoreDeckIfMissing(absPath);
-            				deck = null;
-            			}
-                    }
-                    if (deck == null) {
-                        Log.e(AnkiDroidApp.TAG, "Widget: Skipping null deck: " + absPath);
-                        // Use the data from the last time we updated the deck, if available.
-//                        for (DeckStatus deckStatus : mDecks) {
-//                            if (absPath.equals(deckStatus.mDeckPath)) {
-//                                Log.d(AnkiDroidApp.TAG, "Using previous value");
-//                                decks.add(deckStatus);
-//                                break;
-//                            }
-//                        }
-                        continue;
-                    }
-                    int dueCards = deck.getRevCount();
-                    int newCards = deck.getNewCountToday();
-                    int failedCards = deck.getFailedSoonCount();
-                    int eta = deck.getETA();
-                    int reps = deck.getSessionFinishedCards();
-                    // Close the database connection, but only if this is not the current database.
-                    // Probably we need to make this atomic to be sure it will not cause a failure.
-                    if (currentDeck != null && currentDeck.getDB() != deck.getDB()) {
-                        deck.closeDeck();
-                    }
+                if (fileList == null || fileList.length == 0) {
+                    mDecks = EMPTY_DECK_STATUS;
+                    return context;
+                }
 
-                    // Add the information about the deck
-                    decks.add(new DeckStatus(absPath, deckName, newCards, dueCards, failedCards, eta, reps));
-                } catch (SQLException e) {
-                    Log.i(AnkiDroidApp.TAG, "Widget: Could not open deck");
-                    Log.e(AnkiDroidApp.TAG, e.toString());
-                    if (absPath != null) {
-                        BackupManager.restoreDeckIfMissing(absPath);                    	
+                decks = new ArrayList<DeckStatus>(fileList.length);
+
+                for (File file : fileList) {
+                	String absPath = null;
+                    try {
+                        // Run through the decks and get the information
+                        absPath = file.getAbsolutePath();
+                        String deckName = file.getName().replaceAll(".anki", "");
+
+                        Log.i(AnkiDroidApp.TAG, "Found deck: " + absPath);
+
+                        Deck deck;
+                        Deck currentDeck = AnkiDroidApp.deck();
+                        if (currentDeck != null && currentDeck.getDeckPath().equals(deckName)) {
+                        	deck = currentDeck;
+                        } else {
+                        	try {
+                            	deck = Deck.openDeck(absPath, false);                    		
+                			} catch (RuntimeException e) {
+                				Log.w(AnkiDroidApp.TAG, "Widget: Could not open database " + absPath + ": " + e);
+                				BackupManager.restoreDeckIfMissing(absPath);
+                				deck = null;
+                			}
+                        }
+                        if (deck == null) {
+                            Log.e(AnkiDroidApp.TAG, "Widget: Skipping null deck: " + absPath);
+                            // Use the data from the last time we updated the deck, if available.
+//                            for (DeckStatus deckStatus : mDecks) {
+//                                if (absPath.equals(deckStatus.mDeckPath)) {
+//                                    Log.d(AnkiDroidApp.TAG, "Using previous value");
+//                                    decks.add(deckStatus);
+//                                    break;
+//                                }
+//                            }
+                            continue;
+                        }
+                        int dueCards = deck.getRevCount();
+                        int newCards = deck.getNewCountToday();
+                        int failedCards = deck.getFailedSoonCount();
+                        int eta = deck.getETA();
+                        int reps = deck.getSessionFinishedCards();
+                        // Close the database connection, but only if this is not the current database.
+                        // Probably we need to make this atomic to be sure it will not cause a failure.
+                        if (currentDeck != null && currentDeck.getDB() != deck.getDB()) {
+                            deck.closeDeck();
+                        }
+
+                        // Add the information about the deck
+                        decks.add(new DeckStatus(absPath, deckName, newCards, dueCards, failedCards, eta, reps));
+                    } catch (SQLException e) {
+                        Log.i(AnkiDroidApp.TAG, "Widget: Could not open deck");
+                        Log.e(AnkiDroidApp.TAG, e.toString());
+                        if (absPath != null) {
+                            BackupManager.restoreDeckIfMissing(absPath);                    	
+                        }
                     }
                 }
             }
