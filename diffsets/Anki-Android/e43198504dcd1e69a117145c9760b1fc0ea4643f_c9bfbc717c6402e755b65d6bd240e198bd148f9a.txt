diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
index 1fd2abac6681..b6f807e12390 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
@@ -21,7 +21,7 @@ import android.database.sqlite.SQLiteDatabaseCorruptException
 import androidx.sqlite.db.SupportSQLiteDatabase
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.CollectionHelper
-import com.ichi2.anki.backend.AnkiDroidDB
+import com.ichi2.anki.libanki.DB
 import com.ichi2.anki.tests.InstrumentedTest
 import com.ichi2.anki.testutil.GrantStoragePermission
 import net.ankiweb.rsdroid.database.AnkiSupportSQLiteDatabase
@@ -49,7 +49,7 @@ class DBTest : InstrumentedTest() {
         Assert.assertFalse("database exists already", illFatedDBFile.exists())
         val callback = TestCallback(1)
         val illFatedDB =
-            AnkiDroidDB(
+            DB(
                 AnkiSupportSQLiteDatabase.withFramework(
                     testContext,
                     illFatedDBFile.canonicalPath,
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/backend/AnkiDroidDB.kt b/AnkiDroid/src/main/java/com/ichi2/anki/backend/AnkiDroidDB.kt
deleted file mode 100644
index 2f745a7bda62..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/anki/backend/AnkiDroidDB.kt
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- *  Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>
- *  Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>
- *  Copyright (c) 2009 Andrew <andrewdubya@gmail.com>
- *  Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>
- *  Copyright (c) 2018 Mike Hardy <mike@mikehardy.net>
- *  Copyright (c) 2025 David Allison <davidallisongithub@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free Software
- *  Foundation; either version 3 of the License, or (at your option) any later
- *  version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
- *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.ichi2.anki.backend
-
-import android.content.ContentValues
-import android.database.Cursor
-import android.database.SQLException
-import android.database.sqlite.SQLiteDatabase
-import androidx.sqlite.db.SupportSQLiteDatabase
-import com.ichi2.anki.common.utils.annotation.KotlinCleanup
-import com.ichi2.anki.libanki.DB
-import timber.log.Timber
-
-/**
- * Database layer for AnkiDroid. Wraps a [SupportSQLiteDatabase], and provides some helpers on top.
- *
- * @param database the SQLite database containing the collection data.
- */
-class AnkiDroidDB(
-    val database: SupportSQLiteDatabase,
-) : DB {
-    var mod = false
-
-    override fun close() {
-        try {
-            database.close()
-            Timber.d("Database %s closed = %s", database.path, !database.isOpen)
-        } catch (e: Exception) {
-            // The pre-framework requery API ate this exception, but the framework API exposes it.
-            // We may want to propagate it in the future, but for now maintain the old API and log.
-            Timber.e(e, "Failed to close database %s", database.path)
-        }
-    }
-
-    // Allows to avoid using new Object[]
-    override fun query(
-        query: String,
-        vararg selectionArgs: Any,
-    ): Cursor = database.query(query, selectionArgs)
-
-    override fun queryScalar(
-        query: String,
-        vararg selectionArgs: Any,
-    ): Int {
-        val scalar: Int
-        database.query(query, selectionArgs).use { cursor ->
-            if (!cursor.moveToNext()) {
-                return 0
-            }
-            scalar = cursor.getInt(0)
-        }
-        return scalar
-    }
-
-    override fun queryString(
-        query: String,
-        vararg bindArgs: Any,
-    ): String {
-        database.query(query, bindArgs).use { cursor ->
-            if (!cursor.moveToNext()) {
-                throw SQLException("No result for query: $query")
-            }
-            return cursor.getString(0)
-        }
-    }
-
-    override fun queryLongScalar(
-        query: String,
-        vararg bindArgs: Any,
-    ): Long {
-        var scalar: Long
-        database.query(query, bindArgs).use { cursor ->
-            if (!cursor.moveToNext()) {
-                return 0
-            }
-            scalar = cursor.getLong(0)
-        }
-        return scalar
-    }
-
-    override fun queryLongList(
-        query: String,
-        vararg bindArgs: Any,
-    ): ArrayList<Long> {
-        val results = ArrayList<Long>()
-        database.query(query, bindArgs).use { cursor ->
-            while (cursor.moveToNext()) {
-                results.add(cursor.getLong(0))
-            }
-        }
-        return results
-    }
-
-    override fun queryStringList(
-        query: String,
-        vararg bindArgs: Any,
-    ): ArrayList<String> {
-        val results = ArrayList<String>()
-        database.query(query, bindArgs).use { cursor ->
-            while (cursor.moveToNext()) {
-                results.add(cursor.getString(0))
-            }
-        }
-        return results
-    }
-
-    override fun execute(
-        sql: String,
-        vararg `object`: Any?,
-    ) {
-        val s = sql.trim().lowercase()
-        // mark modified?
-        for (mo in MOD_SQL_STATEMENTS) {
-            if (s.startsWith(mo)) {
-                break
-            }
-        }
-        database.execSQL(sql, `object`)
-    }
-
-    @KotlinCleanup("""Use Kotlin string. Change split so that there is no empty string after last ";".""")
-    override fun executeScript(sql: String) {
-        val queries = java.lang.String(sql).split(";")
-        for (query in queries) {
-            database.execSQL(query)
-        }
-    }
-
-    override fun update(
-        table: String,
-        values: ContentValues,
-        whereClause: String?,
-        whereArgs: Array<String>?,
-    ): Int = database.update(table, SQLiteDatabase.CONFLICT_NONE, values, whereClause, whereArgs)
-
-    override fun insert(
-        table: String,
-        values: ContentValues,
-    ): Long = database.insert(table, SQLiteDatabase.CONFLICT_NONE, values)
-
-    override val path: String
-        get() = database.path ?: ":memory:"
-
-    companion object {
-        private val MOD_SQL_STATEMENTS = arrayOf("insert", "update", "delete")
-    }
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt b/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
index 3b3000f3d6f1..ed8d3befe2bd 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
@@ -22,6 +22,7 @@ import androidx.sqlite.db.SupportSQLiteDatabase
 import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.CrashReportService.sendExceptionReport
 import com.ichi2.anki.dialogs.DatabaseErrorDialog
+import com.ichi2.anki.libanki.DB
 import net.ankiweb.rsdroid.Backend
 import net.ankiweb.rsdroid.database.AnkiSupportSQLiteDatabase
 import timber.log.Timber
@@ -34,7 +35,7 @@ import java.io.File
 fun createDatabaseUsingAndroidFramework(
     context: Context,
     path: File,
-): AnkiDroidDB {
+): DB {
     val db =
         AnkiSupportSQLiteDatabase.withFramework(
             context,
@@ -43,7 +44,7 @@ fun createDatabaseUsingAndroidFramework(
         )
     db.disableWriteAheadLogging()
     db.query("PRAGMA synchronous = 2")
-    return AnkiDroidDB(db)
+    return DB(db)
 }
 
 /**
@@ -51,7 +52,7 @@ fun createDatabaseUsingAndroidFramework(
  * Caller is responsible for opening&closing the database.
  */
 @CheckResult
-fun createDatabaseUsingRustBackend(backend: Backend): AnkiDroidDB = AnkiDroidDB(AnkiSupportSQLiteDatabase.withRustBackend(backend))
+fun createDatabaseUsingRustBackend(backend: Backend): DB = DB(AnkiSupportSQLiteDatabase.withRustBackend(backend))
 
 /**
  * The default AnkiDroid SQLite database callback.
diff --git a/libanki/build.gradle.kts b/libanki/build.gradle.kts
index ae9ddcb8b24f..b5812e9a18d4 100644
--- a/libanki/build.gradle.kts
+++ b/libanki/build.gradle.kts
@@ -63,6 +63,7 @@ dependencies {
 
     // Android interface dependencies
     implementation(libs.androidx.annotation)
+    implementation(libs.androidx.sqlite.framework)
     testImplementation(libs.androidx.sqlite.framework)
 
     // test dependencies
diff --git a/libanki/src/main/java/com/ichi2/anki/libanki/DB.kt b/libanki/src/main/java/com/ichi2/anki/libanki/DB.kt
index 6d6e60229afd..0822024335e7 100644
--- a/libanki/src/main/java/com/ichi2/anki/libanki/DB.kt
+++ b/libanki/src/main/java/com/ichi2/anki/libanki/DB.kt
@@ -22,99 +22,142 @@ package com.ichi2.anki.libanki
 import android.content.ContentValues
 import android.database.Cursor
 import android.database.SQLException
-import androidx.annotation.WorkerThread
+import android.database.sqlite.SQLiteDatabase
+import androidx.sqlite.db.SupportSQLiteDatabase
 import com.ichi2.anki.common.utils.annotation.KotlinCleanup
+import timber.log.Timber
 
 /**
- * Database accessor for AnkiDroid, providing convenience methods (e.g. [queryStringList])
+ * Database layer for AnkiDroid. Wraps a [SupportSQLiteDatabase], and provides some helpers on top.
+ *
+ * @param database the SQLite database containing the collection data.
  */
-// TODO: see if we can turn query methods into extensions
-//  probably hard due to the casting of varargs Any to Array<out Any?>
-@KotlinCleanup("Improve documentation")
-@WorkerThread
-interface DB {
-    /**
-     * Closes a previously opened database connection.
-     */
-    fun close()
+class DB(
+    val database: SupportSQLiteDatabase,
+) {
+    var mod = false
 
+    fun close() {
+        try {
+            database.close()
+            Timber.d("Database %s closed = %s", database.path, !database.isOpen)
+        } catch (e: Exception) {
+            // The pre-framework requery API ate this exception, but the framework API exposes it.
+            // We may want to propagate it in the future, but for now maintain the old API and log.
+            Timber.e(e, "Failed to close database %s", database.path)
+        }
+    }
+
+    // Allows to avoid using new Object[]
     fun query(
         query: String,
         vararg selectionArgs: Any,
-    ): Cursor
-
-    fun execute(
-        sql: String,
-        vararg `object`: Any?,
-    )
-
-    /**
-     * WARNING: This is a convenience method that splits SQL scripts into separate queries with semicolons (;)
-     * as the delimiter. Only use this method on internal functions where we can guarantee that the script does
-     * not contain any non-statement-terminating semicolons.
-     */
-    fun executeScript(sql: String)
+    ): Cursor = database.query(query, selectionArgs)
 
-    /**
-     * Convenience method for querying the database for a single integer result.
-     *
-     * @param query The raw SQL query to use.
-     * @return The integer result of the query.
-     */
     fun queryScalar(
         query: String,
         vararg selectionArgs: Any,
-    ): Int
+    ): Int {
+        val scalar: Int
+        database.query(query, selectionArgs).use { cursor ->
+            if (!cursor.moveToNext()) {
+                return 0
+            }
+            scalar = cursor.getInt(0)
+        }
+        return scalar
+    }
 
-    @Throws(SQLException::class)
     fun queryString(
         query: String,
         vararg bindArgs: Any,
-    ): String
+    ): String {
+        database.query(query, bindArgs).use { cursor ->
+            if (!cursor.moveToNext()) {
+                throw SQLException("No result for query: $query")
+            }
+            return cursor.getString(0)
+        }
+    }
 
     fun queryLongScalar(
         query: String,
         vararg bindArgs: Any,
-    ): Long
+    ): Long {
+        var scalar: Long
+        database.query(query, bindArgs).use { cursor ->
+            if (!cursor.moveToNext()) {
+                return 0
+            }
+            scalar = cursor.getLong(0)
+        }
+        return scalar
+    }
 
-    /**
-     * Convenience method for querying the database for an entire column of long.
-     *
-     * @param query The SQL query statement.
-     * @return An ArrayList with the contents of the specified column.
-     */
     fun queryLongList(
         query: String,
         vararg bindArgs: Any,
-    ): ArrayList<Long>
+    ): ArrayList<Long> {
+        val results = ArrayList<Long>()
+        database.query(query, bindArgs).use { cursor ->
+            while (cursor.moveToNext()) {
+                results.add(cursor.getLong(0))
+            }
+        }
+        return results
+    }
 
-    /**
-     * Convenience method for querying the database for an entire column of String.
-     *
-     * @param query The SQL query statement.
-     * @return An ArrayList with the contents of the specified column.
-     */
     fun queryStringList(
         query: String,
         vararg bindArgs: Any,
-    ): ArrayList<String>
+    ): ArrayList<String> {
+        val results = ArrayList<String>()
+        database.query(query, bindArgs).use { cursor ->
+            while (cursor.moveToNext()) {
+                results.add(cursor.getString(0))
+            }
+        }
+        return results
+    }
+
+    fun execute(
+        sql: String,
+        vararg `object`: Any?,
+    ) {
+        val s = sql.trim().lowercase()
+        // mark modified?
+        for (mo in MOD_SQL_STATEMENTS) {
+            if (s.startsWith(mo)) {
+                break
+            }
+        }
+        database.execSQL(sql, `object`)
+    }
+
+    @KotlinCleanup("""Use Kotlin string. Change split so that there is no empty string after last ";".""")
+    fun executeScript(sql: String) {
+        val queries = java.lang.String(sql).split(";")
+        for (query in queries) {
+            database.execSQL(query)
+        }
+    }
 
-    /** update must always be called via DB in order to mark the db as changed  */
     fun update(
         table: String,
         values: ContentValues,
-        whereClause: String? = null,
-        whereArgs: Array<String>? = null,
-    ): Int
+        whereClause: String?,
+        whereArgs: Array<String>?,
+    ): Int = database.update(table, SQLiteDatabase.CONFLICT_NONE, values, whereClause, whereArgs)
 
-    /** insert must always be called via DB in order to mark the db as changed  */
     fun insert(
         table: String,
         values: ContentValues,
-    ): Long
+    ): Long = database.insert(table, SQLiteDatabase.CONFLICT_NONE, values)
 
-    /**
-     * @return The full path to this database file.
-     */
     val path: String
+        get() = database.path ?: ":memory:"
+
+    companion object {
+        private val MOD_SQL_STATEMENTS = arrayOf("insert", "update", "delete")
+    }
 }
