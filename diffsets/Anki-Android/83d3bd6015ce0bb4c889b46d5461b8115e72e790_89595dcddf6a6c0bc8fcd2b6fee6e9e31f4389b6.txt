diff --git a/src/com/ichi2/anki/DeckManager.java b/src/com/ichi2/anki/DeckManager.java
index d5dccf957f84..1eae09d874a0 100644
--- a/src/com/ichi2/anki/DeckManager.java
+++ b/src/com/ichi2/anki/DeckManager.java
@@ -4,7 +4,6 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.TreeSet;
-import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
 import com.ichi2.anki.DeckPicker.AnkiFilter;
@@ -80,16 +79,17 @@ public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck,
 				// do not open deck if already loaded
 			        DeckInformation deckInformation = sLoadedDecks.get(deckpath);
 		        	try {
-		                if ((deckInformation.mClosingAsyncTask != null) && (deckInformation.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED && !deckInformation.mClosingAsyncTask.isCancelled())) {
-					if (deckInformation.mWaitForDeckTaskToFinish) {
+		        		AsyncTask<CloseDeckInformation, Void, DeckInformation> closingTask = deckInformation.mClosingAsyncTask;
+		                if (closingTask != null && closingTask.getStatus() == AsyncTask.Status.RUNNING && !closingTask.isCancelled()) {
+		                	if (deckInformation.mWaitForDeckTaskToFinish) {
 			                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, cancelling this");
-						deckInformation.mClosingAsyncTask.cancel(true);
-						deckInformation.mOpenedBy = new ArrayList<Integer>();
-					} else {
+			                	closingTask.cancel(true);
+			                	deckInformation.mOpenedBy = new ArrayList<Integer>();
+		                	} else {
 			                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
-						deckInformation.mClosingAsyncTask.get();
+			                	closingTask.get();
 			                	return getDeck(deckpath, setAsMainDeck, doSafetyBackupIfNeeded, requestingActivity, rebuild);
-					}
+		                	}
 		                }
 		            } catch (Exception e) {
 		            	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
@@ -181,18 +181,6 @@ public static void unlockDeck(String path) {
 	}
 
 
-//	public static void waitForDeckOperation(String path) {
-//		if (sDeckLocks.containsKey(path)) {
-//			if (sDeckLocks.get(path).is)
-//			Log.i(AnkiDroidApp.TAG, "DeckManager: waitForDeckOperation");
-////			while (mClosingDeck != null && mClosingDeck.equals(deckpath)) {
-////				Log.e(AnkiDroidApp.TAG, "DeckManager: waitForDeckClosing (" + deckpath + ")");
-////					mCondFinished.await();
-////			}
-//		}
-//	}
-
-
     /** get main deck path */
 	public static String getMainDeckPath() {
 		return sMainDeckPath;
@@ -222,10 +210,16 @@ public static Deck getMainDeck(int requestingActivity) {
 	public static void waitForDeckClosingThread(String deckpath) {
 		DeckInformation deckInformation = sLoadedDecks.get(deckpath);
     	try {
-            if ((deckInformation.mClosingAsyncTask != null) && (deckInformation.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED && !deckInformation.mClosingAsyncTask.isCancelled())) {
-            	// wait for closing deck async task before resuming
-            	Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
-            	deckInformation.mClosingAsyncTask.get();
+            if ((deckInformation.mClosingAsyncTask != null) && deckInformation.mClosingAsyncTask.getStatus() == AsyncTask.Status.RUNNING && !deckInformation.mClosingAsyncTask.isCancelled()) {
+            	if (deckInformation.mWaitForDeckTaskToFinish) {
+                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, cancelling this");
+                	deckInformation.mClosingAsyncTask.cancel(true);
+                	deckInformation.mOpenedBy = new ArrayList<Integer>();
+            	} else {
+                	// wait for closing deck async task before resuming
+                	Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
+                	deckInformation.mClosingAsyncTask.get();
+            	}
             }
         } catch (Exception e) {
         	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
@@ -313,7 +307,7 @@ public static void closeDeck(String deckpath, int requestingActivity, boolean wa
 		try {
 			if (sLoadedDecks.containsKey(deckpath)) {
 				DeckInformation di = sLoadedDecks.get(deckpath);
-				if ((di.mClosingAsyncTask != null) && (di.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED && !di.mClosingAsyncTask.isCancelled())) {
+				if ((di.mClosingAsyncTask != null) && di.mClosingAsyncTask.getStatus() == AsyncTask.Status.RUNNING && !di.mClosingAsyncTask.isCancelled()) {
 					Log.i(AnkiDroidApp.TAG, "DeckManager: closeDeck - deck " + deckpath + " is already closing");
 	            	return;
 	            }
@@ -412,12 +406,12 @@ protected DeckInformation doInBackground(CloseDeckInformation... params) {
             
             if (di.mOpenedBy.contains(REQUESTING_ACTIVITY_STUDYOPTIONS) && requestingActivity != REQUESTING_ACTIVITY_STUDYOPTIONS) {
             	// wait for any decktask operation
-		di.mWaitForDeckTaskToFinish = true;
+            	di.mWaitForDeckTaskToFinish = true;
             	DeckTask.waitToFinish();
-		if (this.isCancelled()) {
-			return null;
-		}
-		di.mWaitForDeckTaskToFinish = false;
+            	di.mWaitForDeckTaskToFinish = false;
+            	if (this.isCancelled()) {
+            		return null;
+            	}
             }
 
             try {
@@ -432,9 +426,9 @@ protected DeckInformation doInBackground(CloseDeckInformation... params) {
         @Override
         protected void onPostExecute(DeckInformation deckInformation) {
             Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
-		if (this.isCancelled()) {
-			return;
-		}
+            if (this.isCancelled()) {
+            	return;
+            }
             sLoadedDecks.remove(deckInformation.mKey);
     		for (String dp : sLoadedDecks.keySet()) {
         		Log.i(AnkiDroidApp.TAG, "DeckManager: still loaded: " + dp + ": " + sLoadedDecks.get(dp).mOpenedBy.toString());
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
index 7030acc51c74..e9189c1a2161 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -17,6 +17,7 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.concurrent.ExecutionException;
 
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.BackupManager;
@@ -375,11 +376,13 @@ public void onStart(Intent intent, int startId) {
             if (intent != null && intent.getAction() != null) {
             	String action = intent.getAction();
             	if (ACTION_NOTHING.equals(action)) {
-			// do nothing
+            		// do nothing
             	} else if (ACTION_UPDATE.equals(action)) {
             		if (!sWaitForAsyncTask) {
                 		sShowProgressDialog = false;
                 		updateViews(intent.getIntExtra(EXTRA_VIEW, VIEW_NOT_SPECIFIED));            			
+            		} else if (sCurrentView == VIEW_SHOW_HELP) {
+            			showProgressDialog();
             		}
             	} else if (ACTION_OPENDECK.equals(action)) {
             		showProgressDialog();
@@ -426,7 +429,13 @@ public void onStart(Intent intent, int startId) {
                     editIntent.putExtra(CardEditor.DECKPATH, sLoadedDeck.getDeckPath());
                     this.startActivity(editIntent);
                 } else if (ACTION_HELP.equals(action)) {
-                	updateViews(VIEW_SHOW_HELP);
+                	if (sShowProgressDialog) {
+                		sShowProgressDialog = false;
+                    	updateViews(VIEW_SHOW_HELP);
+                    	sShowProgressDialog = true;
+                	} else {
+                    	updateViews(VIEW_SHOW_HELP);                		
+                	}
                 } else if (ACTION_LEARN_MORE.equals(action)) {
                 	if (sLoadedDeck != null) {
                 		sLoadedDeck.setupLearnMoreScheduler();
@@ -725,6 +734,7 @@ private void updateCounts(RemoteViews updateViews, int view) {
         	    		updateViews.setTextViewText(R.id.widget_big_decketa, "─────\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
 				} else if (sTomorrowDues == null) {
 						updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
+            			sShowProgressDialog = true;
             			updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
 
             			sWaitForAsyncTask = true;
@@ -897,6 +907,10 @@ protected DeckStatus[] doInBackground(String... params) {
                     		Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
                     	}
                     }
+                    if (this.isCancelled()) {
+                    	sTomorrowDues = null;
+                    	return null;
+                    }
                     Collections.sort(decks, new WidgetStatus.ByNameComparator());
                 }
                 return decks.toArray(new DeckStatus[0]);
@@ -907,13 +921,14 @@ protected void onPostExecute(DeckStatus[] status) {
                 Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
             	sLoadedDeck = null;
             	sCard = null;
-            	sShowProgressDialog = false;
             	sCurrentMessage = null;
             	sWaitForAsyncTask = false;
             	sTomorrowDues = status;
-            	if (sCurrentView != VIEW_SHOW_HELP) {
-                	updateWidget(VIEW_CONGRATS);            		
+            	if (sShowProgressDialog) {
+                	sShowProgressDialog = false;
+                	updateWidget(VIEW_CONGRATS);
             	}
+            	sShowProgressDialog = false;
             }
         }        
     }
