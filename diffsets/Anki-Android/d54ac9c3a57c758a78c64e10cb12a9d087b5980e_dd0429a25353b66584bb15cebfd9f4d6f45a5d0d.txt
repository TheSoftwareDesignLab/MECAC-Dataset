diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
index 8127d61d52cb..6f58c94aa2a3 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/libanki/DBTest.kt
@@ -23,7 +23,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.CollectionHelper
 import com.ichi2.anki.tests.InstrumentedTest
 import com.ichi2.anki.testutil.GrantStoragePermission
-import com.ichi2.libanki.DB
+import com.ichi2.libanki.AnkiDroidDB
 import net.ankiweb.rsdroid.database.AnkiSupportSQLiteDatabase
 import org.junit.Assert
 import org.junit.Rule
@@ -49,7 +49,7 @@ class DBTest : InstrumentedTest() {
         Assert.assertFalse("database exists already", illFatedDBFile.exists())
         val callback = TestCallback(1)
         val illFatedDB =
-            DB(
+            AnkiDroidDB(
                 AnkiSupportSQLiteDatabase.withFramework(
                     testContext,
                     illFatedDBFile.canonicalPath,
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt b/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
index 0f1acbad3488..dd88e0765bd0 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/backend/BackendDBUtils.kt
@@ -21,7 +21,7 @@ import androidx.sqlite.db.SupportSQLiteDatabase
 import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.CrashReportService.sendExceptionReport
 import com.ichi2.anki.dialogs.DatabaseErrorDialog
-import com.ichi2.libanki.DB
+import com.ichi2.libanki.AnkiDroidDB
 import net.ankiweb.rsdroid.database.AnkiSupportSQLiteDatabase
 import timber.log.Timber
 import java.io.File
@@ -33,7 +33,7 @@ object BackendDBUtils {
     fun withAndroidFramework(
         context: Context,
         path: File,
-    ): DB {
+    ): AnkiDroidDB {
         val db =
             AnkiSupportSQLiteDatabase.withFramework(
                 context,
@@ -42,7 +42,7 @@ object BackendDBUtils {
             )
         db.disableWriteAheadLogging()
         db.query("PRAGMA synchronous = 2")
-        return DB(db)
+        return AnkiDroidDB(db)
     }
 }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.kt b/AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.kt
index db84cbbbdec9..df7bdaae9b48 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.kt
@@ -234,7 +234,7 @@ class CardContentProvider : ContentProvider() {
                 if (noteIds.isNotEmpty()) {
                     val sel = "id in (${noteIds.joinToString(",")})"
                     val sql = SQLiteQueryBuilder.buildQueryString(false, "notes", proj, sel, null, null, order, null)
-                    col.db.database.query(sql)
+                    col.db.query(sql)
                 } else {
                     null
                 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/DB.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/DB.kt
index cb4d31312e8d..4de8b2b529be 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/DB.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/DB.kt
@@ -33,20 +33,113 @@ import timber.log.Timber
 /**
  * Database layer for AnkiDroid. Wraps an SupportSQLiteDatabase (provided by either the Rust backend
  * or the Android framework), and provides some helpers on top.
- *
- * @param database The collection, which is actually a SQLite database.
  */
+// TODO: see if we can turn query methods into extensions
+//  probably hard due to the casting of varargs Any to Array<out Any?>
 @KotlinCleanup("Improve documentation")
 @WorkerThread
-class DB(
+interface DB {
+    /**
+     * Closes a previously opened database connection.
+     */
+    fun close()
+
+    fun query(
+        query: String,
+        vararg selectionArgs: Any,
+    ): Cursor
+
+    fun execute(
+        sql: String,
+        vararg `object`: Any?,
+    )
+
+    /**
+     * WARNING: This is a convenience method that splits SQL scripts into separate queries with semicolons (;)
+     * as the delimiter. Only use this method on internal functions where we can guarantee that the script does
+     * not contain any non-statement-terminating semicolons.
+     */
+    fun executeScript(sql: String)
+
+    /**
+     * Convenience method for querying the database for a single integer result.
+     *
+     * @param query The raw SQL query to use.
+     * @return The integer result of the query.
+     */
+    fun queryScalar(
+        query: String,
+        vararg selectionArgs: Any,
+    ): Int
+
+    @Throws(SQLException::class)
+    fun queryString(
+        query: String,
+        vararg bindArgs: Any,
+    ): String
+
+    fun queryLongScalar(
+        query: String,
+        vararg bindArgs: Any,
+    ): Long
+
+    /**
+     * Convenience method for querying the database for an entire column of long.
+     *
+     * @param query The SQL query statement.
+     * @return An ArrayList with the contents of the specified column.
+     */
+    fun queryLongList(
+        query: String,
+        vararg bindArgs: Any,
+    ): ArrayList<Long>
+
+    /**
+     * Convenience method for querying the database for an entire column of String.
+     *
+     * @param query The SQL query statement.
+     * @return An ArrayList with the contents of the specified column.
+     */
+    fun queryStringList(
+        query: String,
+        vararg bindArgs: Any,
+    ): ArrayList<String>
+
+    /** update must always be called via DB in order to mark the db as changed  */
+    fun update(
+        table: String,
+        values: ContentValues,
+        whereClause: String? = null,
+        whereArgs: Array<String>? = null,
+    ): Int
+
+    /** insert must always be called via DB in order to mark the db as changed  */
+    fun insert(
+        table: String,
+        values: ContentValues,
+    ): Long
+
+    /**
+     * @return The full path to this database file.
+     */
+    val path: String
+}
+
+/**
+ * Database layer for AnkiDroid. Wraps an SupportSQLiteDatabase (provided by either the Rust backend
+ * or the Android framework), and provides some helpers on top.
+ *
+ * @param database The collection, which is actually a SQLite database.
+ */
+class AnkiDroidDB(
     val database: SupportSQLiteDatabase,
-) {
+) : DB {
     var mod = false
 
     /**
      * Closes a previously opened database connection.
      */
-    fun close() {
+    override fun close() {
         try {
             database.close()
             Timber.d("Database %s closed = %s", database.path, !database.isOpen)
@@ -58,7 +151,7 @@ class DB(
     }
 
     // Allows to avoid using new Object[]
-    fun query(
+    override fun query(
         query: String,
         vararg selectionArgs: Any,
     ): Cursor = database.query(query, selectionArgs)
@@ -69,7 +162,7 @@ class DB(
      * @param query The raw SQL query to use.
      * @return The integer result of the query.
      */
-    fun queryScalar(
+    override fun queryScalar(
         query: String,
         vararg selectionArgs: Any,
     ): Int {
@@ -84,7 +177,7 @@ class DB(
     }
 
     @Throws(SQLException::class)
-    fun queryString(
+    override fun queryString(
         query: String,
         vararg bindArgs: Any,
     ): String {
@@ -96,7 +189,7 @@ class DB(
         }
     }
 
-    fun queryLongScalar(
+    override fun queryLongScalar(
         query: String,
         vararg bindArgs: Any,
     ): Long {
@@ -116,7 +209,7 @@ class DB(
      * @param query The SQL query statement.
      * @return An ArrayList with the contents of the specified column.
      */
-    fun queryLongList(
+    override fun queryLongList(
         query: String,
         vararg bindArgs: Any,
     ): ArrayList<Long> {
@@ -135,7 +228,7 @@ class DB(
      * @param query The SQL query statement.
      * @return An ArrayList with the contents of the specified column.
      */
-    fun queryStringList(
+    override fun queryStringList(
         query: String,
         vararg bindArgs: Any,
     ): ArrayList<String> {
@@ -148,7 +241,7 @@ class DB(
         return results
     }
 
-    fun execute(
+    override fun execute(
         sql: String,
         vararg `object`: Any?,
     ) {
@@ -168,7 +261,7 @@ class DB(
      * not contain any non-statement-terminating semicolons.
      */
     @KotlinCleanup("""Use Kotlin string. Change split so that there is no empty string after last ";".""")
-    fun executeScript(sql: String) {
+    override fun executeScript(sql: String) {
         val queries = java.lang.String(sql).split(";")
         for (query in queries) {
             database.execSQL(query)
@@ -176,15 +269,15 @@ class DB(
     }
 
     /** update must always be called via DB in order to mark the db as changed  */
-    fun update(
+    override fun update(
         table: String,
         values: ContentValues,
-        whereClause: String? = null,
-        whereArgs: Array<String>? = null,
+        whereClause: String?,
+        whereArgs: Array<String>?,
     ): Int = database.update(table, SQLiteDatabase.CONFLICT_NONE, values, whereClause, whereArgs)
 
     /** insert must always be called via DB in order to mark the db as changed  */
-    fun insert(
+    override fun insert(
         table: String,
         values: ContentValues,
     ): Long = database.insert(table, SQLiteDatabase.CONFLICT_NONE, values)
@@ -192,7 +285,7 @@ class DB(
     /**
      * @return The full path to this database file.
      */
-    val path: String
+    override val path: String
         get() = database.path ?: ":memory:"
 
     companion object {
@@ -202,6 +295,6 @@ class DB(
          * Wrap a Rust backend connection (which provides an SQL interface).
          * Caller is responsible for opening&closing the database.
          */
-        fun withRustBackend(backend: Backend): DB = DB(AnkiSupportSQLiteDatabase.withRustBackend(backend))
+        fun withRustBackend(backend: Backend): AnkiDroidDB = AnkiDroidDB(AnkiSupportSQLiteDatabase.withRustBackend(backend))
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Storage.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/Storage.kt
index c7561b6448ab..48c034f0e044 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Storage.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Storage.kt
@@ -55,7 +55,7 @@ object Storage {
         } else {
             backend.openCollection(if (isInMemory) ":memory:" else path.absolutePath)
         }
-        val db = DB.withRustBackend(backend)
+        val db = AnkiDroidDB.withRustBackend(backend)
 
         // initialize
         if (create) {
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/SchedulerTest.kt b/AnkiDroid/src/test/java/com/ichi2/libanki/SchedulerTest.kt
index 373c9f8a1ea2..7f4e3a7ce3ab 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/SchedulerTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/SchedulerTest.kt
@@ -210,7 +210,7 @@ open class SchedulerTest : JvmTest() {
         )
         Assert.assertEquals(2, (c.left % 1000).toLong())
         // check log is accurate
-        val log = col.db.database.query("select * from revlog order by id desc")
+        val log = col.db.query("select * from revlog order by id desc")
         Assert.assertTrue(log.moveToFirst())
         Assert.assertEquals(3, log.getInt(3).toLong())
         Assert.assertEquals(-180, log.getInt(4).toLong())
