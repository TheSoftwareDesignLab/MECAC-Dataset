diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/BackendBackups.kt b/AnkiDroid/src/main/java/com/ichi2/anki/BackendBackups.kt
index 5f91e5142b60..b258159cbed0 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/BackendBackups.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/BackendBackups.kt
@@ -22,11 +22,9 @@ import com.ichi2.libanki.CollectionV16
 import com.ichi2.libanki.awaitBackupCompletion
 import com.ichi2.libanki.createBackup
 import kotlinx.coroutines.*
-import timber.log.Timber
 
 fun DeckPicker.performBackupInBackground() {
-    val col = CollectionHelper.getInstance().getCol(baseContext).newBackend
-    catchingLifecycleScope(this) {
+    launchCatchingCollectionTask { col ->
         // Wait a second to allow the deck list to finish loading first, or it
         // will hang until the first stage of the backup completes.
         delay(1000)
@@ -35,21 +33,21 @@ fun DeckPicker.performBackupInBackground() {
 }
 
 fun DeckPicker.importColpkg(colpkgPath: String) {
-    val deckPicker = this
-    catchingLifecycleScope(this) {
-        runInBackground {
-            val helper = CollectionHelper.getInstance()
-            val backend = helper.getOrCreateBackend(baseContext)
-            backend.withProgress({
-                if (it.hasImporting()) {
-                    // TODO: show progress in GUI
-                    Timber.i("%s", it.importing)
+    launchCatchingTask {
+        val helper = CollectionHelper.getInstance()
+        val backend = helper.getOrCreateBackend(baseContext)
+        runInBackgroundWithProgress(
+            backend,
+            extractProgress = {
+                if (progress.hasImporting()) {
+                    text = progress.importing
                 }
-            }) {
-                helper.importColpkg(baseContext, colpkgPath)
-            }
+            },
+        ) {
+            helper.importColpkg(baseContext, colpkgPath)
         }
-        deckPicker.updateDeckList()
+        invalidateOptionsMenu()
+        updateDeckList()
     }
 }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/BackendImporting.kt b/AnkiDroid/src/main/java/com/ichi2/anki/BackendImporting.kt
index a361e0cd880e..06d78fc0795a 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/BackendImporting.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/BackendImporting.kt
@@ -21,22 +21,26 @@ package com.ichi2.anki
 import anki.import_export.ImportResponse
 import com.ichi2.libanki.exportAnkiPackage
 import com.ichi2.libanki.importAnkiPackage
+import com.ichi2.libanki.undoableOp
 import net.ankiweb.rsdroid.Translations
-import timber.log.Timber
 
-fun DeckPicker.importApkg(apkgPath: String) {
-    val deckPicker = this
-    val col = CollectionHelper.getInstance().getCol(deckPicker.baseContext).newBackend
-    catchingLifecycleScope(this) {
-        val report = col.opWithProgress({
-            if (it.hasImporting()) {
-                // TODO: show progress in GUI
-                Timber.i("%s", it.importing)
+fun DeckPicker.importApkgs(apkgPaths: List<String>) {
+    launchCatchingCollectionTask { col ->
+        for (apkgPath in apkgPaths) {
+            val report = runInBackgroundWithProgress(
+                col.backend,
+                extractProgress = {
+                    if (progress.hasImporting()) {
+                        text = progress.importing
+                    }
+                },
+            ) {
+                undoableOp {
+                    col.importAnkiPackage(apkgPath)
+                }
             }
-        }) {
-            importAnkiPackage(apkgPath)
+            showSimpleMessageDialog(summarizeReport(col.tr, report))
         }
-        showSimpleMessageDialog(summarizeReport(col.tr, report))
     }
 }
 
@@ -65,15 +69,15 @@ fun DeckPicker.exportApkg(
     withMedia: Boolean,
     deckId: Long?
 ) {
-    val deckPicker = this
-    val col = CollectionHelper.getInstance().getCol(deckPicker.baseContext).newBackend
-    catchingLifecycleScope(this) {
-        runInBackgroundWithProgress(col, {
-            if (it.hasExporting()) {
-                // TODO: show progress in GUI
-                Timber.i("%s", it.exporting)
-            }
-        }) {
+    launchCatchingCollectionTask { col ->
+        runInBackgroundWithProgress(
+            col.backend,
+            extractProgress = {
+                if (progress.hasExporting()) {
+                    text = progress.exporting
+                }
+            },
+        ) {
             col.exportAnkiPackage(apkgPath, withScheduling, withMedia, deckId)
         }
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt b/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
index 3164137fc758..c9923f0b7fb4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
@@ -1,5 +1,5 @@
 /***************************************************************************************
- * Copyright (c) 2022 Ankitects Pty Ltd <http://apps.ankiweb.net>                       *
+ * Copyright (c) 2022 Ankitects Pty Ltd <https://apps.ankiweb.net>                       *
  *                                                                                      *
  * This program is free software; you can redistribute it and/or modify it under        *
  * the terms of the GNU General Public License as published by the Free Software        *
@@ -16,59 +16,78 @@
 
 package com.ichi2.anki
 
-import android.app.Activity
-import androidx.lifecycle.LifecycleOwner
+import android.content.Context
+import androidx.appcompat.app.AlertDialog
 import androidx.lifecycle.coroutineScope
 import anki.collection.Progress
 import com.ichi2.anki.UIUtils.showSimpleSnackbar
-import com.ichi2.libanki.ChangeManager
 import com.ichi2.libanki.CollectionV16
+import com.ichi2.themes.StyledProgressDialog
 import kotlinx.coroutines.*
 import net.ankiweb.rsdroid.Backend
 import net.ankiweb.rsdroid.BackendException
+import net.ankiweb.rsdroid.exceptions.BackendInterruptedException
+import timber.log.Timber
 
 /**
  * Launch a job that catches any uncaught errors and reports them to the user.
  * Errors from the backend contain localized text that is often suitable to show to the user as-is.
  * Other errors should ideally be handled in the block.
  */
-// TODO: require user confirmation before message disappears
-fun LifecycleOwner.catchingLifecycleScope(activity: Activity, block: suspend CoroutineScope.() -> Unit): Job {
+fun AnkiActivity.launchCatchingTask(
+    block: suspend CoroutineScope.() -> Unit
+): Job {
     return lifecycle.coroutineScope.launch {
         try {
             block()
+        } catch (exc: BackendInterruptedException) {
+            Timber.e("caught: %s", exc)
+            showSimpleSnackbar(this@launchCatchingTask, exc.localizedMessage, false)
         } catch (exc: BackendException) {
-            showSimpleSnackbar(activity, exc.localizedMessage, false)
+            Timber.e("caught: %s", exc)
+            showError(this@launchCatchingTask, exc.localizedMessage!!)
         } catch (exc: Exception) {
-            // TODO: localize
-            showSimpleSnackbar(activity, "An error occurred: {exc}", false)
+            Timber.e("caught: %s", exc)
+            showError(this@launchCatchingTask, exc.toString())
         }
     }
 }
 
-suspend fun <T> runInBackground(block: suspend CoroutineScope.() -> T): T {
-    return withContext(Dispatchers.IO) {
-        block()
+private fun showError(context: Context, msg: String) {
+    AlertDialog.Builder(context)
+        .setTitle(R.string.vague_error)
+        .setMessage(msg)
+        .setPositiveButton(R.string.dialog_ok) { _, _ -> }
+        .show()
+}
+
+/** Launch a catching task that requires a collection with the new schema enabled. */
+fun AnkiActivity.launchCatchingCollectionTask(block: suspend CoroutineScope.(col: CollectionV16) -> Unit): Job {
+    val col = CollectionHelper.getInstance().getCol(baseContext).newBackend
+    return launchCatchingTask {
+        block(col)
     }
 }
 
-/**
- * Run an operation and notify change subscribers.
- * * See the docs in ChangeManager.kt
- * */
-suspend fun <T> CollectionV16.op(handler: Any? = null, block: suspend CollectionV16.() -> T): T {
-    return runInBackground {
+/** Run a blocking call in a background thread pool. */
+suspend fun <T> runInBackground(block: suspend CoroutineScope.() -> T): T {
+    return withContext(Dispatchers.IO) {
         block()
-    }.also {
-        ChangeManager.notifySubscribers(it, handler)
     }
 }
 
-suspend fun <T> Backend.withProgress(onProgress: (Progress) -> Unit, block: suspend CoroutineScope.() -> T): T {
-    val backend = this
+/** In most cases, you'll want [AnkiActivity.runInBackgroundWithProgress]
+ * instead. This lower-level routine can be used to integrate your own
+ * progress UI.
+ */
+suspend fun <T> Backend.withProgress(
+    extractProgress: ProgressContext.() -> Unit,
+    updateUi: ProgressContext.() -> Unit,
+    block: suspend CoroutineScope.() -> T,
+): T {
     return coroutineScope {
         val monitor = launch {
-            monitorProgress(backend, onProgress)
+            monitorProgress(this@withProgress, extractProgress, updateUi)
         }
         try {
             block()
@@ -78,43 +97,93 @@ suspend fun <T> Backend.withProgress(onProgress: (Progress) -> Unit, block: susp
     }
 }
 
-suspend fun <T> runInBackgroundWithProgress(
-    col: CollectionV16,
-    onProgress: (Progress) -> Unit,
-    op: suspend (CollectionV16) -> T
-): T = coroutineScope {
-    col.backend.withProgress(onProgress) {
-        runInBackground { op(col) }
+/**
+ * Run the provided operation in the background, showing a progress
+ * window.
+ */
+suspend fun <T> AnkiActivity.runInBackgroundWithProgress(
+    backend: Backend,
+    extractProgress: ProgressContext.() -> Unit,
+    onCancel: ((Backend) -> Unit)? = { it.setWantsAbort() },
+    op: suspend () -> T
+): T = withProgressDialog(
+    context = this@runInBackgroundWithProgress,
+    onCancel = if (onCancel != null) {
+        fun() { onCancel(backend) }
+    } else {
+        null
+    }
+) { dialog ->
+    backend.withProgress(
+        extractProgress = extractProgress,
+        updateUi = { updateDialog(dialog) }
+    ) {
+        runInBackground { op() }
     }
 }
 
-/**
- * Run an operation and notify change subscribers, and capture backend progress.
- *
- * See the docs in ChangeManager.kt
- * */
-suspend fun <T> CollectionV16.opWithProgress(
-    onProgress: (Progress) -> Unit,
-    handler: Any? = null,
-    op: suspend CollectionV16.() -> T,
-): T = coroutineScope {
-    backend.withProgress(onProgress) {
-        this@opWithProgress.op(handler) {
-            op()
-        }
+private suspend fun <T> withProgressDialog(
+    context: AnkiActivity,
+    onCancel: (() -> Unit)?,
+    @Suppress("Deprecation") // ProgressDialog deprecation
+    op: suspend (android.app.ProgressDialog) -> T
+): T {
+    val dialog = StyledProgressDialog.show(
+        context, null,
+        null, onCancel != null
+    )
+    onCancel?.let {
+        dialog.setOnCancelListener { it() }
+    }
+    return try {
+        op(dialog)
+    } finally {
+        dialog.dismiss()
     }
 }
 
 /**
  * Poll the backend for progress info every 100ms until cancelled by caller.
+ * Calls extractProgress() to gather progress info and write it into
+ * [ProgressContext]. Calls updateUi() to update the UI with the extracted
+ * progress.
  */
-private suspend fun monitorProgress(backend: Backend, op: (Progress) -> Unit) {
+private suspend fun monitorProgress(
+    backend: Backend,
+    extractProgress: ProgressContext.() -> Unit,
+    updateUi: ProgressContext.() -> Unit,
+) {
+    var state = ProgressContext(Progress.getDefaultInstance())
     while (true) {
-        val progress = backend.latestProgress()
+        state.progress = backend.latestProgress()
+        state.extractProgress()
         // on main thread, so op can update UI
         withContext(Dispatchers.Main) {
-            op(progress)
+            state.updateUi()
         }
         delay(100)
     }
 }
+
+/** Holds the current backend progress, and text/amount properties
+ * that can be written to in order to update the UI.
+ */
+data class ProgressContext(
+    var progress: Progress,
+    var text: String = "",
+    /** If set, shows progress bar with a of b complete. */
+    var amount: Pair<Int, Int>? = null,
+)
+
+@Suppress("Deprecation") // ProgressDialog deprecation
+private fun ProgressContext.updateDialog(dialog: android.app.ProgressDialog) {
+    // ideally this would show a progress bar, but MaterialDialog does not support
+    // setting progress after starting with indeterminate progress, so we just use
+    // this for now
+    // this code has since been updated to ProgressDialog, and the above not rechecked
+    val progressText = amount?.let {
+        " ${it.first}/${it.second}"
+    } ?: ""
+    @Suppress("Deprecation") // ProgressDialog deprecation
+    dialog.setMessage(text + progressText)
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DatabaseCheck.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DatabaseCheck.kt
index b5b0ba31e022..440842f2e202 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DatabaseCheck.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DatabaseCheck.kt
@@ -16,24 +16,24 @@
 
 package com.ichi2.anki
 
-import timber.log.Timber
-
 fun DeckPicker.handleDatabaseCheck() {
-    val col = CollectionHelper.getInstance().getCol(baseContext).newBackend
-    val deckPicker = this
-    catchingLifecycleScope(this) {
-        val problems = runInBackgroundWithProgress(col, {
-            if (it.hasDatabaseCheck()) {
-                // TODO: show progress in GUI
-                it.databaseCheck.run {
-                    if (stageTotal > 0) {
-                        Timber.i("$stage: $stageCurrent/$stageTotal")
-                    } else {
-                        Timber.i("$stage")
+    launchCatchingCollectionTask { col ->
+        val problems = runInBackgroundWithProgress(
+            col.backend,
+            extractProgress = {
+                if (progress.hasDatabaseCheck()) {
+                    progress.databaseCheck.let {
+                        text = it.stage
+                        if (it.stageTotal > 0) {
+                            amount = Pair(it.stageCurrent, it.stageTotal)
+                        } else {
+                            amount = null
+                        }
                     }
                 }
-            }
-        }) {
+            },
+            onCancel = null,
+        ) {
             col.fixIntegrity()
         }
         val message = if (problems.isNotEmpty()) {
@@ -41,6 +41,6 @@ fun DeckPicker.handleDatabaseCheck() {
         } else {
             col.tr.databaseCheckRebuilt()
         }
-        deckPicker.showSimpleMessageDialog(message)
+        showSimpleMessageDialog(message)
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index e808ef56b91c..a24238e8113f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -1846,16 +1846,19 @@ open class DeckPicker :
         if (BackendFactory.defaultLegacySchema) {
             TaskManager.launchCollectionTask(ImportAdd(importPath), mImportAddListener)
         } else {
-            for (file in importPath) {
-                importApkg(file)
-            }
+            importApkgs(importPath)
         }
     }
 
     // Callback to import a file -- replacing the existing collection
     @NeedsTest("Test 2 successful files & test 1 failure & 1 successful file")
     override fun importReplace(importPath: List<String>) {
-        TaskManager.launchCollectionTask(ImportReplace(importPath), importReplaceListener())
+        if (BackendFactory.defaultLegacySchema) {
+            TaskManager.launchCollectionTask(ImportReplace(importPath), importReplaceListener())
+        } else {
+            // multiple colpkg files is nonsensical
+            importColpkg(importPath[0])
+        }
     }
 
     /**
@@ -2050,7 +2053,7 @@ open class DeckPicker :
             context.mDueTree = result.map { x -> x.unsafeCastToType(AbstractDeckTreeNode::class.java) }
             context.renderPage()
             // Update the mini statistics bar as well
-            deckPicker?.catchingLifecycleScope(deckPicker) {
+            deckPicker?.launchCatchingTask {
                 AnkiStatsTaskHandler.createReviewSummaryStatistics(context.col, context.mReviewSummaryTextView)
             }
             Timber.d("Startup - Deck List UI Completed")
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Sync.kt b/AnkiDroid/src/main/java/com/ichi2/anki/Sync.kt
index 1e8366c14454..6254682b95d4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Sync.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Sync.kt
@@ -25,9 +25,11 @@
 package com.ichi2.anki
 
 import android.content.Context
+import androidx.appcompat.app.AlertDialog
 import androidx.core.content.edit
 import anki.sync.SyncAuth
 import anki.sync.SyncCollectionResponse
+import anki.sync.syncAuth
 import com.ichi2.anim.ActivityTransitionAnimation
 import com.ichi2.anki.dialogs.SyncErrorDialog
 import com.ichi2.anki.web.HostNumFactory
@@ -35,6 +37,7 @@ import com.ichi2.async.Connection
 import com.ichi2.libanki.CollectionV16
 import com.ichi2.libanki.createBackup
 import com.ichi2.libanki.sync.*
+import net.ankiweb.rsdroid.Backend
 import net.ankiweb.rsdroid.exceptions.BackendSyncException
 import timber.log.Timber
 
@@ -43,35 +46,31 @@ fun DeckPicker.handleNewSync(
     hostNum: Int,
     conflict: Connection.ConflictResolution?
 ) {
-    val auth = SyncAuth.newBuilder().apply {
+    val auth = syncAuth {
         this.hkey = hkey
         this.hostNumber = hostNum
-    }.build()
-
-    val col = CollectionHelper.getInstance().getCol(baseContext).newBackend
+    }
     val deckPicker = this
-
-    catchingLifecycleScope(this) {
+    launchCatchingCollectionTask { col ->
         try {
             when (conflict) {
-                Connection.ConflictResolution.FULL_DOWNLOAD -> handleDownload(col, auth, deckPicker)
-                Connection.ConflictResolution.FULL_UPLOAD -> handleUpload(col, auth, deckPicker)
-                null -> handleNormalSync(baseContext, col, auth, deckPicker)
+                Connection.ConflictResolution.FULL_DOWNLOAD -> handleDownload(deckPicker, col, auth)
+                Connection.ConflictResolution.FULL_UPLOAD -> handleUpload(deckPicker, col, auth)
+                null -> handleNormalSync(deckPicker, col, auth)
             }
         } catch (exc: BackendSyncException.BackendSyncAuthFailedException) {
             // auth failed; log out
             updateLogin(baseContext, "", "")
             throw exc
         }
-        deckPicker.refreshState()
+        refreshState()
     }
 }
 
 fun MyAccount.handleNewLogin(username: String, password: String) {
-    val col = CollectionHelper.getInstance().getCol(baseContext).newBackend
-    catchingLifecycleScope(this) {
+    launchCatchingCollectionTask { col ->
         val auth = try {
-            runInBackgroundWithProgress(col, { }) {
+            runInBackgroundWithProgress(col.backend, {}, onCancel = ::cancelSync) {
                 col.syncLogin(username, password)
             }
         } catch (exc: BackendSyncException.BackendSyncAuthFailedException) {
@@ -92,22 +91,30 @@ private fun updateLogin(context: Context, username: String, hkey: String?) {
     }
 }
 
+private fun cancelSync(backend: Backend) {
+    backend.setWantsAbort()
+    backend.abortSync()
+}
+
 private suspend fun handleNormalSync(
-    context: Context,
+    deckPicker: DeckPicker,
     col: CollectionV16,
-    auth: SyncAuth,
-    deckPicker: DeckPicker
+    auth: SyncAuth
 ) {
-    val output = runInBackgroundWithProgress(col, {
-        if (it.hasNormalSync()) {
-            it.normalSync.run { updateProgress("$added $removed") }
-        }
-    }) {
+    val output = deckPicker.runInBackgroundWithProgress(
+        col.backend,
+        extractProgress = {
+            if (progress.hasNormalSync()) {
+                text = progress.normalSync.run { "$added\n$removed" }
+            }
+        },
+        onCancel = ::cancelSync
+    ) {
         col.syncCollection(auth)
     }
 
     // Save current host number
-    HostNumFactory.getInstance(context).setHostNum(output.hostNumber)
+    HostNumFactory.getInstance(deckPicker).setHostNum(output.hostNumber)
 
     when (output.required) {
         SyncCollectionResponse.ChangesRequired.NO_CHANGES -> {
@@ -115,17 +122,17 @@ private suspend fun handleNormalSync(
             deckPicker.showSyncLogMessage(R.string.sync_database_acknowledge, output.serverMessage)
             // kick off media sync - future implementations may want to run this in the
             // background instead
-            handleMediaSync(col, auth)
+            handleMediaSync(deckPicker, col, auth)
         }
 
         SyncCollectionResponse.ChangesRequired.FULL_DOWNLOAD -> {
-            handleDownload(col, auth, deckPicker)
-            handleMediaSync(col, auth)
+            handleDownload(deckPicker, col, auth)
+            handleMediaSync(deckPicker, col, auth)
         }
 
         SyncCollectionResponse.ChangesRequired.FULL_UPLOAD -> {
-            handleUpload(col, auth, deckPicker)
-            handleMediaSync(col, auth)
+            handleUpload(deckPicker, col, auth)
+            handleMediaSync(deckPicker, col, auth)
         }
 
         SyncCollectionResponse.ChangesRequired.FULL_SYNC -> {
@@ -140,16 +147,25 @@ private suspend fun handleNormalSync(
     }
 }
 
+private fun fullDownloadProgress(title: String): ProgressContext.() -> Unit {
+    return {
+        if (progress.hasFullSync()) {
+            text = title
+            amount = progress.fullSync.run { Pair(transferred, total) }
+        }
+    }
+}
+
 private suspend fun handleDownload(
+    deckPicker: DeckPicker,
     col: CollectionV16,
-    auth: SyncAuth,
-    deckPicker: DeckPicker
+    auth: SyncAuth
 ) {
-    runInBackgroundWithProgress(col, {
-        if (it.hasFullSync()) {
-            it.fullSync.run { updateProgress("downloaded $transferred/$total") }
-        }
-    }) {
+    deckPicker.runInBackgroundWithProgress(
+        col.backend,
+        extractProgress = fullDownloadProgress(col.tr.syncDownloadingFromAnkiweb()),
+        onCancel = ::cancelSync
+    ) {
         col.createBackup(
             BackupManager.getBackupDirectoryFromCollection(col.path),
             force = true,
@@ -168,15 +184,15 @@ private suspend fun handleDownload(
 }
 
 private suspend fun handleUpload(
+    deckPicker: DeckPicker,
     col: CollectionV16,
-    auth: SyncAuth,
-    deckPicker: DeckPicker
+    auth: SyncAuth
 ) {
-    runInBackgroundWithProgress(col, {
-        if (it.hasFullSync()) {
-            it.fullSync.run { updateProgress("uploaded $transferred/$total") }
-        }
-    }) {
+    deckPicker.runInBackgroundWithProgress(
+        col.backend,
+        extractProgress = fullDownloadProgress(col.tr.syncUploadingToAnkiweb()),
+        onCancel = ::cancelSync
+    ) {
         col.close(save = true, downgrade = false, forFullSync = true)
         try {
             col.fullUpload(auth)
@@ -184,26 +200,48 @@ private suspend fun handleUpload(
             col.reopen(afterFullSync = true)
         }
     }
-
     Timber.i("Full Upload Completed")
     deckPicker.showSyncLogMessage(R.string.sync_log_uploading_message, "")
 }
 
-@Suppress("UNUSED_PARAMETER", "UNREACHABLE_CODE")
+// TODO: this needs a dedicated UI for media syncing, and needs to expose
+// a way to interrupt the sync
+
+private fun cancelMediaSync(backend: Backend) {
+    backend.setWantsAbort()
+    backend.abortMediaSync()
+}
+
 private suspend fun handleMediaSync(
+    deckPicker: DeckPicker,
     col: CollectionV16,
     auth: SyncAuth
 ) {
-    runInBackgroundWithProgress(col, {
-        if (it.hasMediaSync()) {
-            it.mediaSync.run { updateProgress("media: $added $removed $checked") }
+    // TODO: show this in a way that is clear it can be continued in background,
+    // but also warn user that media files will not be available until it completes.
+    // TODO: provide a way for users to abort later, and see it's still going
+    val dialog = AlertDialog.Builder(deckPicker)
+        .setTitle(col.tr.syncMediaLogTitle())
+        .setMessage("")
+        .setPositiveButton("Background") { _, _ -> }
+        .show()
+    try {
+        col.backend.withProgress(
+            extractProgress = {
+                if (progress.hasMediaSync()) {
+                    text =
+                        progress.mediaSync.run { "\n$added\n$removed\n$checked" }
+                }
+            },
+            updateUi = {
+                dialog.setMessage(text)
+            },
+        ) {
+            runInBackground {
+                col.syncMedia(auth)
+            }
         }
-    }) {
-        col.syncMedia(auth)
+    } finally {
+        dialog.dismiss()
     }
 }
-
-// FIXME: display/update a popup progress window instead of logging
-private fun updateProgress(text: String) {
-    Timber.i("progress: $text")
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/ChangeManager.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/ChangeManager.kt
index 3998b9319edd..ac70013e400e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/ChangeManager.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/ChangeManager.kt
@@ -79,3 +79,11 @@ object ChangeManager {
         notifySubscribers(opChanges, initiator)
     }
 }
+
+/** Wrap a routine that returns OpChanges* or similar undo info with this
+ * to notify change subscribers of the changes. */
+fun<T> undoableOp(handler: Any? = null, block: () -> T): T {
+    return block().also {
+        ChangeManager.notifySubscribers(it, handler)
+    }
+}
