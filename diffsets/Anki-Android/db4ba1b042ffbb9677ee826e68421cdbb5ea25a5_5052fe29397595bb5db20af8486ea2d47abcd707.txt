diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java
index 75bcd7d030d7..61ca7f5efedd 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java
@@ -42,6 +42,7 @@
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Consts;
 import com.ichi2.libanki.Deck;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.libanki.Decks;
 import com.ichi2.libanki.Model;
 import com.ichi2.libanki.Note;
@@ -750,7 +751,7 @@ public void testUnsupportedOperations() {
     @Test
     public void testQueryAllDecks() {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
 
         Cursor decksCursor = getContentResolver()
                 .query(FlashCardsContract.Deck.CONTENT_ALL_URI, FlashCardsContract.Deck.DEFAULT_PROJECTION, null, null, null);
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/customstudy/CustomStudyDialog.java b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/customstudy/CustomStudyDialog.java
index dd22b173e965..a34bb7f245ed 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/customstudy/CustomStudyDialog.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/customstudy/CustomStudyDialog.java
@@ -55,7 +55,7 @@
 import com.ichi2.libanki.Consts;
 
 import com.ichi2.libanki.Deck;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.utils.JSONArray;
 import com.ichi2.utils.JSONObject;
 
@@ -473,7 +473,7 @@ private String getDefaultValue() {
     private void createCustomStudySession(JSONArray delays, Object[] terms, Boolean resched) {
         Deck dyn;
         long did = requireArguments().getLong("did");
-        Decks decks = mCollection.getDecks();
+        DeckManager decks = mCollection.getDecks();
         String deckToStudyName = decks.get(did).getString("name");
         String customStudyDeck = getResources().getString(R.string.custom_study_deck_name);
         Deck cur = decks.byName(customStudyDeck);
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
index 6f5eeba07b18..69563faadc3e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
@@ -105,7 +105,7 @@ public class Collection implements CollectionGetter {
     private boolean mServer;
     //private double mLastSave;
     private final Media mMedia;
-    private final Decks mDecks;
+    private final DeckManager mDecks;
     private ModelManager mModels;
     private final TagManager mTags;
 
@@ -2019,7 +2019,7 @@ public DB getDb() {
     }
 
 
-    public Decks getDecks() {
+    public DeckManager getDecks() {
         return mDecks;
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/DeckManager.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/DeckManager.kt
new file mode 100644
index 000000000000..96a7b1e22adc
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/DeckManager.kt
@@ -0,0 +1,228 @@
+/*
+ *  Copyright (c) 2021 David Allison <davidallisongithub@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free Software
+ *  Foundation; either version 3 of the License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.libanki
+
+import androidx.annotation.CheckResult
+import androidx.annotation.VisibleForTesting
+import com.ichi2.anki.exception.ConfirmModSchemaException
+import com.ichi2.anki.exception.DeckRenameException
+import com.ichi2.anki.exception.FilteredAncestor
+import com.ichi2.utils.JSONObject
+import net.ankiweb.rsdroid.RustCleanup
+import java.util.*
+
+abstract class DeckManager {
+
+    /*
+     * Registry save/load
+     * ***********************************************************
+     */
+
+    abstract fun load(decks: String, dconf: String)
+    fun save() = save(null)
+    /** Can be called with either a deck or a deck configuration. */
+    abstract fun save(g: JSONObject?)
+    abstract fun flush()
+
+    /*
+     * Deck save/load
+     * ***********************************************************
+     */
+
+    abstract fun id_for_name(name: String): Long?
+    @Throws(FilteredAncestor::class)
+    abstract fun id(name: String): Long
+    /** Same as id, but rename ancestors if filtered to avoid failure */
+    fun id_safe(name: String) = id_safe(name, Decks.DEFAULT_DECK)
+    /** Same as id, but rename ancestors if filtered to avoid failure */
+    abstract fun id_safe(name: String, type: String): Long
+
+    /** Remove the deck. delete any cards inside and child decks. */
+    fun rem(did: Long) = rem(did, true)
+    /** Remove the deck. Delete child decks. If cardsToo, delete any cards inside. */
+    fun rem(did: Long, cardsToo: Boolean = true) = rem(did, cardsToo, true)
+    /** Remove the deck. If cardsToo, delete any cards inside. */
+    abstract fun rem(did: Long, cardsToo: Boolean = true, childrenToo: Boolean = true)
+
+    /** An unsorted list of all deck names. */
+    fun allNames() = allNames(true)
+    /** An unsorted list of all deck names. */
+    abstract fun allNames(dyn: Boolean = true): List<String>
+    /** A list of all decks. */
+    abstract fun all(): List<Deck>
+    abstract fun allIds(): Set<Long>
+
+    abstract fun collapse(did: Long)
+
+    /** Return the number of decks. */
+    abstract fun count(): Int
+    @CheckResult
+    /** Obtains the deck from the DeckID, or default if the deck was not found */
+    fun get(did: Long): Deck = get(did, true)!!
+    /**
+     * Obtains the deck from the DeckID
+     * @param did The deck to obtain
+     * @param _default Whether to return the default deck, or null if did is not found
+     */
+    @CheckResult
+    abstract fun get(did: Long, _default: Boolean): Deck?
+
+    /** Get deck with NAME, ignoring case */
+    @CheckResult
+    abstract fun byName(name: String): Deck?
+
+    /** Add or update an existing deck. Used for syncing and merging. */
+    abstract fun update(g: Deck)
+
+    /** Rename deck prefix to NAME if not exists. Updates children. */
+    @Throws(DeckRenameException::class)
+    abstract fun rename(g: Deck, newName: String)
+
+    /*
+     * Deck configurations
+     ************************************************************
+     */
+
+    /** * A list of all deck config. */
+    abstract fun allConf(): ArrayList<DeckConfig>
+    abstract fun confForDid(did: Long): DeckConfig
+    abstract fun getConf(confId: Long): DeckConfig?
+    abstract fun updateConf(g: DeckConfig)
+
+    fun confId(name: String): Long = confId(name, Decks.DEFAULT_CONF)
+    /** Create a new configuration and return id */
+    abstract fun confId(name: String, cloneFrom: String): Long
+    /**
+     * Remove a configuration and update all decks using it.
+     * @throws ConfirmModSchemaException
+     */
+    @Throws(ConfirmModSchemaException::class)
+    abstract fun remConf(id: Long)
+    abstract fun setConf(grp: Deck, id: Long)
+
+    abstract fun didsForConf(conf: DeckConfig): List<Long>
+    abstract fun restoreToDefault(conf: DeckConfig)
+
+    /*
+     * Deck utils
+     * ***********************************************************
+     */
+
+    abstract fun name(did: Long): String
+    fun cids(did: Long): Array<Long> = cids(did, false)
+    abstract fun cids(did: Long, children: Boolean): Array<Long>
+    abstract fun checkIntegrity()
+
+    /*
+     * Deck selection
+     * ***********************************************************
+     */
+    /** The currently active dids. Make sure to copy before modifying. */
+    abstract fun active(): LinkedList<Long>
+    /** The currently selected did. */
+    abstract fun selected(): Long
+    abstract fun current(): Deck
+    /** Select a new branch. */
+    abstract fun select(did: Long)
+    /**
+     * All children of did as nodes of (key:name, value:id)
+     *
+     * TODO: There is likely no need for this collection to be a TreeMap. This method should not
+     * need to sort on behalf of select().
+     */
+    abstract fun children(did: Long): TreeMap<String, Long>
+    abstract fun childDids(did: Long, childMap: Decks.Node): List<Long>
+    abstract fun childMap(): Decks.Node
+    /** All parents of did. */
+    abstract fun parents(did: Long): List<Deck>
+
+    /*
+     * Sync handling
+     * ***********************************************************
+     */
+
+    abstract fun beforeUpload()
+
+    /*
+     * Dynamic decks
+     * ***********************************************************
+     */
+
+    /** Return a new dynamic deck and set it as the current deck. */
+    @Throws(FilteredAncestor::class)
+    abstract fun newDyn(name: String): Long
+    abstract fun isDyn(did: Long): Boolean
+
+    /*
+     * ***********************************************************
+     * The methods below are not in LibAnki.
+     * ***********************************************************
+     */
+
+    abstract fun getActualDescription(): String
+
+    /** @return the fully qualified name of the subdeck, or null if unavailable */
+    abstract fun getSubdeckName(did: Long, subdeckName: String?): String?
+
+    /* Methods only visible for testing */
+
+    @VisibleForTesting
+    abstract fun allSortedNames(): List<String>
+    /**
+     *
+     * @param name The name whose parents should exists
+     * @return The name, with potentially change in capitalization and unicode normalization, so that the parent's name corresponds to an existing deck.
+     * @throws FilteredAncestor if a parent is filtered
+     */
+    @VisibleForTesting
+    @Throws(FilteredAncestor::class)
+    protected abstract fun _ensureParents(name: String): String
+
+    /**
+     *
+     * Similar as ensure parent, to use when the method can't fail and it's better to allow more change to ancestor's names.
+     * @param name The name whose parents should exists
+     * @return The name similar to input, changed as required, and as little as required, so that no ancestor is filtered and the parent's name is an existing deck.
+     */
+    @VisibleForTesting
+    protected abstract fun _ensureParentsNotFiltered(name: String): String
+
+    /*
+     * Not in libAnki
+     */
+
+    /**
+     * Return the same deck list from all() but sorted using a comparator that ensures the same
+     * sorting order for decks as the desktop client.
+     *
+     * This method does not exist in the original python module but *must* be used for any user
+     * interface components that display a deck list to ensure the ordering is consistent.
+     */
+    abstract fun allSorted(): List<Deck>
+
+    @RustCleanup("potentially an extension function")
+    fun allDynamicDeckIds(): Array<Long> {
+        val ids = allIds()
+        val validValues = ArrayList<Long>(ids.size)
+        for (did in ids) {
+            if (isDyn(did)) {
+                validValues.add(did)
+            }
+        }
+        return validValues.toTypedArray()
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
index 0b6d95538001..f6dee33b00f9 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
@@ -64,7 +64,7 @@
 
 @SuppressWarnings({"PMD.AvoidThrowingRawExceptionTypes",
         "PMD.MethodNamingConventions","PMD.AvoidReassigningParameters","PMD.SimplifyBooleanReturns"})
-public class Decks {
+public class Decks extends DeckManager {
 
     // Invalid id, represents an id on an unfound deck
     public static final long NOT_FOUND_DECK_ID = -1L;
@@ -252,7 +252,8 @@ public Decks(Collection col) {
     }
 
 
-    public void load(String decks, String dconf) {
+    @Override
+    public void load(@NonNull String decks, @NonNull String dconf) {
         JSONObject decksarray = new JSONObject(decks);
         JSONArray ids = decksarray.names();
         mDecks = new HashMap<>(decksarray.length());
@@ -275,15 +276,8 @@ public void load(String decks, String dconf) {
         mChanged = false;
     }
 
-
-    public void save() {
-        save(null);
-    }
-
-
-    /**
-     * Can be called with either a deck or a deck configuration.
-     */
+    /** {@inheritDoc} */
+    @Override
     public void save(JSONObject g) {
         if (g != null) {
             g.put("mod", mCol.getTime().intTime());
@@ -293,6 +287,7 @@ public void save(JSONObject g) {
     }
 
 
+    @Override
     public void flush() {
         ContentValues values = new ContentValues();
         if (mChanged) {
@@ -318,7 +313,8 @@ public void flush() {
      */
 
     @Nullable
-    public Long id_for_name(String name) {
+    @Override
+    public Long id_for_name(@NonNull String name) {
         name = usable_name(name);
         Deck deck = byName(name);
         if (deck != null) {
@@ -327,15 +323,12 @@ public Long id_for_name(String name) {
         return null;
     }
 
-    public long id(String name) throws FilteredAncestor {
+    @Override
+    public long id(@NonNull String name) throws FilteredAncestor {
         return id(name, DEFAULT_DECK);
     }
 
-    public long id_safe(String name) {
-        return id_safe(name, DEFAULT_DECK);
-    }
-
-    private String usable_name(String name) {
+    private String usable_name(@NonNull String name) {
         name = strip(name);
         name = name.replace("\"", "");
         name = Normalizer.normalize(name, Normalizer.Form.NFC);
@@ -345,7 +338,7 @@ private String usable_name(String name) {
     /**
      * Add a deck with NAME. Reuse deck if already exists. Return id as int.
      */
-    public long id(String name, String type) throws FilteredAncestor {
+    public long id(@NonNull String name, @NonNull String type) throws FilteredAncestor {
         name = usable_name(name);
         Long id = id_for_name(name);
         if (id != null) {
@@ -364,7 +357,7 @@ public long id(String name, String type) throws FilteredAncestor {
      * @param type The json encoding of the deck, except for name and id
      * @return the deck's id
      */
-    private long id_create_name_valid(String name, String type) {
+    private long id_create_name_valid(@NonNull String name, @NonNull String type) {
         long id;
         Deck g = new Deck(type);
         g.put("name", name);
@@ -381,10 +374,9 @@ private long id_create_name_valid(String name, String type) {
     }
 
 
-    /**
-     * Same as id, but rename ancestors if filtered to avoid failure
-     */
-    public long id_safe(String name, String type)  {
+    /** {@inheritDoc} */
+    @Override
+    public long id_safe(@NonNull String name, @NonNull String type)  {
         name = usable_name(name);
         Long id = id_for_name(name);
         if (id != null) {
@@ -397,20 +389,8 @@ public long id_safe(String name, String type)  {
         return id_create_name_valid(name, type);
     }
 
-
-    public void rem(long did) {
-        rem(did, true);
-    }
-
-
-    public void rem(long did, boolean cardsToo) {
-        rem(did, cardsToo, true);
-    }
-
-
-    /**
-     * Remove the deck. If cardsToo, delete any cards inside.
-     */
+    /** {@inheritDoc} */
+    @Override
     public void rem(long did, boolean cardsToo, boolean childrenToo) {
         Deck deck = get(did, false);
         if (did == 1) {
@@ -462,15 +442,9 @@ public void rem(long did, boolean cardsToo, boolean childrenToo) {
         save();
     }
 
-
-    public List<String> allNames() {
-        return allNames(true);
-    }
-
-
-    /**
-     * An unsorted list of all deck names.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public List<String> allNames(boolean dyn) {
         List<String> list = new ArrayList<>(mDecks.size());
         if (dyn) {
@@ -488,27 +462,25 @@ public List<String> allNames(boolean dyn) {
     }
 
 
-    /**
-     * A list of all decks.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public List<Deck> all() {
         return new ArrayList<>(mDecks.values());
     }
 
 
-    /**
-     * Return the same deck list from all() but sorted using a comparator that ensures the same
-     * sorting order for decks as the desktop client.
-     *
-     * This method does not exist in the original python module but *must* be used for any user
-     * interface components that display a deck list to ensure the ordering is consistent.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public List<Deck> allSorted() {
         List<Deck> decks = all();
         Collections.sort(decks, DeckComparator.INSTANCE);
         return decks;
     }
 
+    @NonNull
+    @Override
     @VisibleForTesting
     public List<String> allSortedNames() {
         List<String> names = allNames();
@@ -517,11 +489,14 @@ public List<String> allSortedNames() {
     }
 
 
+    @NonNull
+    @Override
     public Set<Long> allIds() {
         return mDecks.keySet();
     }
 
 
+    @Override
     public void collapse(long did) {
         Deck deck = get(did);
         deck.put("collapsed", !deck.getBoolean("collapsed"));
@@ -537,20 +512,13 @@ public void collapseBrowser(long did) {
     }
 
 
-    /**
-     * Return the number of decks.
-     */
+    /** {@inheritDoc} */
+    @Override
     public int count() {
         return mDecks.size();
     }
 
-    /** Obtains the deck from the DeckID, or default if the deck was not found */
-    @CheckResult
-    public @NonNull Deck get(long did) {
-        return get(did, true);
-    }
-
-
+    @Override
     @CheckResult
     public Deck get(long did, boolean _default) {
         if (mDecks.containsKey(did)) {
@@ -563,19 +531,17 @@ public Deck get(long did, boolean _default) {
     }
 
 
-    /**
-     * Get deck with NAME, ignoring case.
-     */
+    /** {@inheritDoc} */
+    @Override
     @CheckResult
     public @Nullable Deck byName(String name) {
         return mNameMap.get(name);
     }
 
 
-    /**
-     * Add or update an existing deck. Used for syncing and merging.
-     */
-    public void update(Deck g) {
+    /** {@inheritDoc} */
+    @Override
+    public void update(@NonNull Deck g) {
         long id = g.getLong("id");
         JSONObject oldDeck = get(id, false);
         if (oldDeck != null) {
@@ -590,10 +556,9 @@ public void update(Deck g) {
         save();
     }
 
-    /**
-     * Rename deck prefix to NAME if not exists. Updates children.
-     */
-    public void rename(Deck g, String newName) throws DeckRenameException {
+    /** {@inheritDoc} */
+    @Override
+    public void rename(@NonNull Deck g, @NonNull String newName) throws DeckRenameException {
         newName = strip(newName);
         // make sure target node doesn't already exist
         Deck deckWithThisName = byName(newName);
@@ -715,14 +680,11 @@ public static String basename(String name) {
     }
 
 
-    /**
-     *
-     * @param name The name whose parents should exists
-     * @return The name, with potentially change in capitalization and unicode normalization, so that the parent's name corresponds to an existing deck.
-     * @throws FilteredAncestor if a parent is filtered
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     @VisibleForTesting
-    protected String _ensureParents(String name) throws FilteredAncestor {
+    protected String _ensureParents(@NonNull String name) throws FilteredAncestor {
         String s = "";
         String[] path = path(name);
         if (path.length < 2) {
@@ -749,11 +711,8 @@ protected String _ensureParents(String name) throws FilteredAncestor {
     }
 
 
-    /**
-     * Similar as ensure parent, to use when the method can't fail and it's better to allow more change to ancestor's names.
-     * @param name The name whose parents should exists
-     * @return The name similar to input, changed as required, and as little as required, so that no ancestor is filtered and the parent's name is an existing deck.
-     */
+    /** {@inheritDoc} */
+    @Override
     @VisibleForTesting
     protected  String _ensureParentsNotFiltered(String name) {
         String s = "";
@@ -792,14 +751,16 @@ protected  String _ensureParentsNotFiltered(String name) {
      */
 
 
-    /**
-     * A list of all deck config.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public ArrayList<DeckConfig> allConf() {
         return new ArrayList<>(mDconf.values());
     }
 
 
+    @NonNull
+    @Override
     public DeckConfig confForDid(long did) {
         Deck deck = get(did, false);
         assert deck != null;
@@ -817,26 +778,21 @@ public DeckConfig confForDid(long did) {
     }
 
 
+    @Override
     public DeckConfig getConf(long confId) {
         return mDconf.get(confId);
     }
 
 
-    public void updateConf(DeckConfig g) {
+    @Override
+    public void updateConf(@NonNull DeckConfig g) {
         mDconf.put(g.getLong("id"), g);
         save();
     }
 
-
-    public long confId(String name) {
-        return confId(name, DEFAULT_CONF);
-    }
-
-
-    /**
-     * Create a new configuration and return id.
-     */
-    public long confId(String name, String cloneFrom) {
+    /** {@inheritDoc} */
+    @Override
+    public long confId(@NonNull String name, @NonNull String cloneFrom) {
         long id;
         DeckConfig c = new DeckConfig(cloneFrom);
         do {
@@ -850,10 +806,8 @@ public long confId(String name, String cloneFrom) {
     }
 
 
-    /**
-     * Remove a configuration and update all decks using it.
-     * @throws ConfirmModSchemaException 
-     */
+    /** {@inheritDoc} */
+    @Override
     public void remConf(long id) throws ConfirmModSchemaException {
         assert id != 1;
         mCol.modSchema();
@@ -871,12 +825,15 @@ public void remConf(long id) throws ConfirmModSchemaException {
     }
 
 
-    public void setConf(Deck grp, long id) {
+    @Override
+    public void setConf(@NonNull Deck grp, long id) {
         grp.put("conf", id);
         save(grp);
     }
 
 
+    @NonNull
+    @Override
     public List<Long> didsForConf(DeckConfig conf) {
         List<Long> dids = new ArrayList<>();
         for(Deck deck : mDecks.values()) {
@@ -888,7 +845,8 @@ public List<Long> didsForConf(DeckConfig conf) {
     }
 
 
-    public void restoreToDefault(DeckConfig conf) {
+    @Override
+    public void restoreToDefault(@NonNull DeckConfig conf) {
         int oldOrder = conf.getJSONObject("new").getInt("order");
         DeckConfig _new = mCol.getBackend().new_deck_config_legacy();
         _new.put("id", conf.getLong("id"));
@@ -908,6 +866,8 @@ public void restoreToDefault(DeckConfig conf) {
      */
 
 
+    @NonNull
+    @Override
     public String name(long did) {
         return name(did, false);
     }
@@ -944,11 +904,8 @@ private void maybeAddToActive() {
     }
 
 
-    public Long[] cids(long did) {
-        return cids(did, false);
-    }
-
-
+    @NonNull
+    @Override
     public Long[] cids(long did, boolean children) {
         if (!children) {
             return Utils.list2ObjectArray(mCol.getDb().queryLongList("select id from cards where did=?", did));
@@ -963,7 +920,7 @@ public Long[] cids(long did, boolean children) {
 
     private static final Pattern spaceAroundSeparator = Pattern.compile("\\s*::\\s*");
     @VisibleForTesting
-    static String strip(String deckName) {
+    static String strip(@NonNull String deckName) {
         //Ends of components are either the ends of the deck name, or near the ::.
         //Deal with all spaces around ::
         deckName = spaceAroundSeparator.matcher(deckName).replaceAll("::");
@@ -1045,6 +1002,7 @@ private void _checkDeckTree() {
         }
     }
 
+    @Override
     public void checkIntegrity() {
         _recoverOrphans();
         _checkDeckTree();
@@ -1057,9 +1015,9 @@ public void checkIntegrity() {
      */
 
 
-    /**
-     * The currently active dids. Make sure to copy before modifying.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public LinkedList<Long> active() {
         JSONArray activeDecks = mCol.get_config_array("activeDecks");
         LinkedList<Long> result = new LinkedList<>();
@@ -1068,14 +1026,15 @@ public LinkedList<Long> active() {
     }
 
 
-    /**
-     * The currently selected did.
-     */
+    /** {@inheritDoc} */
+    @Override
     public long selected() {
         return mCol.get_config_long("curDeck");
     }
 
 
+    @NonNull
+    @Override
     public Deck current() {
         if (get(selected()) == null || !mDecks.containsKey(selected())) {
             select(Consts.DEFAULT_DECK_ID); // Select default deck if the selected deck is null
@@ -1084,9 +1043,8 @@ public Deck current() {
     }
 
 
-    /**
-     * Select a new branch.
-     */
+    /** {@inheritDoc} */
+    @Override
     public void select(long did) {
         String name = mDecks.get(did).getString("name");
 
@@ -1104,12 +1062,9 @@ public void select(long did) {
     }
 
 
-    /**
-     * All children of did as nodes of (key:name, value:id)
-     *
-     * TODO: There is likely no need for this collection to be a TreeMap. This method should not
-     * need to sort on behalf of select().
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public TreeMap<String, Long> children(long did) {
         String name = get(did).getString("name");
         TreeMap<String, Long> actv = new TreeMap<>();
@@ -1131,6 +1086,8 @@ private void gather(Node node, List<Long> arr) {
         }
     }
 
+    @NonNull
+    @Override
     public List<Long> childDids(long did, Node childMap) {
         List<Long> arr = new ArrayList<>();
         gather(childMap.get(did), arr);
@@ -1138,6 +1095,8 @@ public List<Long> childDids(long did, Node childMap) {
     }
 
 
+    @NonNull
+    @Override
     public Node childMap() {
 
         Node childMap = new Node();
@@ -1179,9 +1138,9 @@ private String[] parentsNames(String name) {
         return parentsNames;
     }
 
-    /**
-     * All parents of did.
-     */
+    /** {@inheritDoc} */
+    @NonNull
+    @Override
     public List<Deck> parents(long did) {
         // get parent and grandparent names
         String[] parents = parentsNames(get(did).getString("name"));
@@ -1202,6 +1161,7 @@ public List<Deck> parents(long did) {
      */
 
 
+    @Override
     public void beforeUpload() {
         boolean changed_decks = Utils.markAsUploaded(all());
         boolean changed_conf = Utils.markAsUploaded(allConf());
@@ -1219,9 +1179,8 @@ public void beforeUpload() {
      */
 
 
-    /**
-     * Return a new dynamic deck and set it as the current deck.
-     */
+    /** {@inheritDoc} */
+    @Override
     public long newDyn(String name) throws FilteredAncestor {
         long did = id(name, defaultDynamicDeck);
         select(did);
@@ -1229,6 +1188,7 @@ public long newDyn(String name) throws FilteredAncestor {
     }
 
 
+    @Override
     public boolean isDyn(long did) {
         return get(did).isDyn();
     }
@@ -1277,6 +1237,8 @@ public static String parent(String deckName) {
         return sParentCache.get(deckName);
     }
 
+    @NonNull
+    @Override
     public String getActualDescription() {
         return current().optString("desc","");
     }
@@ -1287,17 +1249,6 @@ public HashMap<Long, Deck> getDecks() {
         return mDecks;
     }
 
-    public Long[] allDynamicDeckIds() {
-        Set<Long> ids = allIds();
-        ArrayList<Long> validValues = new ArrayList<>(ids.size());
-        for (Long did : ids) {
-            if (isDyn(did)) {
-                validValues.add(did);
-            }
-        }
-        return validValues.toArray(new Long[0]);
-    }
-
     public static boolean isDynamic(Collection col, long deckId) {
         return Decks.isDynamic(col.getDecks().get(deckId));
     }
@@ -1306,7 +1257,8 @@ public static boolean isDynamic(Deck deck) {
         return deck.isDyn();
     }
 
-    /** Retruns the fully qualified name of the subdeck, or null if unavailable */
+    /** {@inheritDoc} */
+    @Override
     @Nullable
     public String getSubdeckName(long did, @Nullable String subdeckName) {
         if (TextUtils.isEmpty(subdeckName)) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/stats/AdvancedStatistics.java b/AnkiDroid/src/main/java/com/ichi2/libanki/stats/AdvancedStatistics.java
index f84888e837eb..6eceaa3d15f3 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/stats/AdvancedStatistics.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/stats/AdvancedStatistics.java
@@ -28,7 +28,7 @@
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Consts;
 import com.ichi2.libanki.DB;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.libanki.DeckConfig;
 import com.ichi2.libanki.utils.Time;
 
@@ -487,7 +487,7 @@ public void setLastReview(int lastReview) {
 
     private class DeckFactory {
 
-        public Deck createDeck(long did, Decks decks) {
+        public Deck createDeck(long did, DeckManager decks) {
 
             Timber.d("Trying to get deck settings for deck with id=" + did);
 
@@ -904,7 +904,7 @@ public ReviewSimulator(DB db, EaseClassifier classifier, int nTimeBins, int time
             this.mTMax = this.mNTimeBins * this.mTimeBinLength;
         }
 
-        public SimulationResult simNreviews(int today, Decks decks, String didsStr, TodayStats todayStats) {
+        public SimulationResult simNreviews(int today, DeckManager decks, String didsStr, TodayStats todayStats) {
 
             SimulationResult simulationResultAggregated = new SimulationResult(mNTimeBins, mTimeBinLength, SimulationResult.DOUBLE_TO_INT_MODE_ROUND);
 
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.java
index b9f21ff79772..a4ae71f3c522 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.java
@@ -13,7 +13,7 @@
 import com.ichi2.libanki.Card;
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Consts;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.libanki.Model;
 import com.ichi2.libanki.ModelManager;
 import com.ichi2.libanki.Note;
@@ -236,7 +236,7 @@ public void baseDeckName() {
         Collection col = getCol();
         ModelManager models = col.getModels();
 
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         Long didAb = addDeck("A::B");
         Model basic = models.byName(AnkiDroidApp.getAppResources().getString(R.string.basic_model_name));
         basic.put("did", didAb);
@@ -252,7 +252,7 @@ public void baseDeckName() {
     public void jsAnkiGetDeckName() {
         Collection col = getCol();
         ModelManager models = col.getModels();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
 
         Long didAb = addDeck("A::B");
         Model basic = models.byName(AnkiDroidApp.getAppResources().getString(R.string.basic_model_name));
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/dialogs/CreateDeckDialogTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/dialogs/CreateDeckDialogTest.java
index c865378596f3..c4e38ff9f023 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/dialogs/CreateDeckDialogTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/dialogs/CreateDeckDialogTest.java
@@ -19,7 +19,7 @@
 import com.ichi2.anki.R;
 import com.ichi2.anki.RobolectricTest;
 import com.ichi2.anki.exception.FilteredAncestor;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -56,7 +56,7 @@ public void testCreateFilteredDeckFunction() {
                 // a deck was created
                 try {
                     isCreated.set(true);
-                    final Decks decks = activity.getCol().getDecks();
+                    final DeckManager decks = activity.getCol().getDecks();
                     assertThat(id, is(decks.id(deckName)));
                 } catch (FilteredAncestor filteredAncestor) {
                     throw new RuntimeException(filteredAncestor);
@@ -81,7 +81,7 @@ public void testCreateSubDeckFunction() throws FilteredAncestor {
             createDeckDialog.setOnNewDeckCreated((id) -> {
                 try {
                     isCreated.set(true);
-                    final Decks decks = activity.getCol().getDecks();
+                    final DeckManager decks = activity.getCol().getDecks();
                     String deckNameWithParentName = decks.getSubdeckName(deckParentId, deckName);
                     assertThat(id, is(decks.id(deckNameWithParentName)));
                 } catch (FilteredAncestor filteredAncestor) {
@@ -105,7 +105,7 @@ public void testCreateDeckFunction() {
             createDeckDialog.setOnNewDeckCreated((id) -> {
                 // a deck was created
                 isCreated.set(true);
-                final Decks decks = activity.getCol().getDecks();
+                final DeckManager decks = activity.getCol().getDecks();
                 assertThat(id, is(decks.byName(deckName).getLong("id")));
             });
 
@@ -128,7 +128,7 @@ public void testRenameDeckFunction() {
             createDeckDialog.setOnNewDeckCreated((id) -> {
                 // a deck name was renamed
                 isCreated.set(true);
-                final Decks decks = activity.getCol().getDecks();
+                final DeckManager decks = activity.getCol().getDecks();
                 assertThat(deckNewName, is(decks.name(id)));
             });
 
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java b/AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java
index a50c4c2c8b4c..247c7ce00c43 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java
@@ -252,7 +252,7 @@ public void nextDueTest() throws FilteredAncestor {
         // Test runs as the 7th of august 2020, 9h00
         Note n = addNoteUsingBasicModel("Front", "Back");
         Card c = n.firstCard();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
 
         Calendar cal = Calendar.getInstance();
         cal.set(2021, 2, 19, 7, 42, 42);
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/DecksTest.java b/AnkiDroid/src/test/java/com/ichi2/libanki/DecksTest.java
index 0048ed31efd9..9f06fd0b46a9 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/DecksTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/DecksTest.java
@@ -36,7 +36,7 @@ public class DecksTest extends RobolectricTest {
 
     @Test
     public void duplicateName() {
-        Decks decks = getCol().getDecks();
+        DeckManager decks = getCol().getDecks();
         decks.load("{\"2\": {\"name\": \"A\", \"id\":2}, \"3\": {\"name\": \"A\", \"id\":3}, \"4\": {\"name\": \"A::B\", \"id\":4}}", "{}");
         decks.checkIntegrity();
         JSONObject deckA = decks.byName("A");
@@ -47,7 +47,7 @@ public void duplicateName() {
     }
     @Test
     public void ensureDeckList() {
-        Decks decks = getCol().getDecks();
+        DeckManager decks = getCol().getDecks();
         for (String deckName: TEST_DECKS) {
             addDeck(deckName);
         }
@@ -81,7 +81,7 @@ public void trim() {
     @Test
     public void test_basic() throws FilteredAncestor {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         // we start with a standard col
         assertEquals(1, decks.allSortedNames().size());
         // it should have an id of 1
@@ -150,7 +150,7 @@ public void test_rename() throws DeckRenameException, FilteredAncestor {
         long id = addDeck("hello::world");
         // should be able to rename into a completely different branch, creating
         // parents as necessary
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         decks.rename(decks.get(id), "foo::bar");
         List<String> names = decks.allSortedNames();
         assertTrue(names.contains("foo"));
@@ -237,7 +237,7 @@ public void test_rename() throws DeckRenameException, FilteredAncestor {
     public void curDeckIsLong() throws FilteredAncestor {
         // Regression for #8092
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         long id = addDeck("test");
         decks.select(id);
         assertDoesNotThrow("curDeck should be saved as a long. A deck id.", () -> col.get_config_long("curDeck"));
@@ -247,7 +247,7 @@ public void curDeckIsLong() throws FilteredAncestor {
     @Test
     public void isDynStd() {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         long filteredId = addDynamicDeck("filtered");
         Deck filtered = decks.get(filteredId);
         long deckId = addDeck("deck");
@@ -269,7 +269,7 @@ public void isDynStd() {
     @Test
     public void testEnsureParents() throws FilteredAncestor {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         addDeck("test");
         String subsubdeck_name = decks._ensureParents("  tESt :: sub :: subdeck");
         assertEquals("test::sub:: subdeck", subsubdeck_name);// Only parents are renamed, not the last deck.
@@ -285,7 +285,7 @@ public void testEnsureParents() throws FilteredAncestor {
     @Test
     public void descendantOfFiltered() throws FilteredAncestor {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         long filtered_id = decks.newDyn("filtered");
         assertThrows(FilteredAncestor.class,  () -> decks.id("filtered::subdeck::subsubdeck"));
 
@@ -297,7 +297,7 @@ public void descendantOfFiltered() throws FilteredAncestor {
     @Test
     public void testEnsureParentsNotFiltered() throws FilteredAncestor {
         Collection col = getCol();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         addDeck("test");
         String subsubdeck_name = decks._ensureParentsNotFiltered("  tESt :: sub :: subdeck");
         assertEquals("test::sub:: subdeck", subsubdeck_name);// Only parents are renamed, not the last deck.
@@ -318,7 +318,7 @@ public void testEnsureParentsNotFiltered() throws FilteredAncestor {
     @Test
     public void confForDidReturnsDefaultIfNotFound() {
         // https://github.com/ankitects/anki/commit/94d369db18c2a6ac3b0614498d8abcc7db538633
-        Decks decks = getCol().getDecks();
+        DeckManager decks = getCol().getDecks();
 
         Deck d = decks.all().get(0);
         d.put("conf", 12L);
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/AbstractSchedTest.java b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/AbstractSchedTest.java
index bc13eaac197b..4ce5efb606db 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/AbstractSchedTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/AbstractSchedTest.java
@@ -24,7 +24,7 @@
 import com.ichi2.libanki.Consts;
 import com.ichi2.libanki.Deck;
 import com.ichi2.libanki.DeckConfig;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.libanki.Model;
 import com.ichi2.libanki.ModelManager;
 import com.ichi2.libanki.Note;
@@ -211,7 +211,7 @@ public void deckDueTreeInconsistentDecksPasses() {
 
     private class IncreaseToday {
         private final long aId, bId, cId, dId;
-        private final Decks decks;
+        private final DeckManager decks;
         private final AbstractSched sched;
 
         public IncreaseToday() {
@@ -386,7 +386,7 @@ public void undoAndRedoNoPreload() {
     }
 
     private void addDeckWithExactName(String name) {
-        Decks decks = getCol().getDecks();
+        DeckManager decks = getCol().getDecks();
 
         long did = addDeck(name);
         Deck d = decks.get(did);
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java
index ddf73268eaa8..57b02549522d 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java
@@ -25,7 +25,7 @@
 import com.ichi2.libanki.Consts;
 import com.ichi2.libanki.Deck;
 import com.ichi2.libanki.DeckConfig;
-import com.ichi2.libanki.Decks;
+import com.ichi2.libanki.DeckManager;
 import com.ichi2.libanki.Model;
 import com.ichi2.libanki.ModelManager;
 import com.ichi2.libanki.Models;
@@ -1731,7 +1731,7 @@ public void test_initial_repeat() throws Exception {
     public void regression_test_preview() throws Exception {
         //"https://github.com/ankidroid/Anki-Android/issues/7285"
         Collection col = getColV2();
-        Decks decks = col.getDecks();
+        DeckManager decks = col.getDecks();
         AbstractSched sched = col.getSched();
         addNoteUsingBasicModel("foo", "bar");
         long did = addDynamicDeck("test");
