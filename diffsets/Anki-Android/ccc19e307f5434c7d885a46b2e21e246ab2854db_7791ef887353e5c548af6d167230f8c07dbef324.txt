diff --git a/assets/flashcard_css b/assets/flashcard_css
index 8b52d6452eac..797c52547195 100644
--- a/assets/flashcard_css
+++ b/assets/flashcard_css
@@ -14,4 +14,28 @@ body {
   width: 100%;
   text-align: center;
   font-size: 250%;
+}
+
+ruby
+{
+	display: inline-table;
+	text-align: center;
+	white-space: nowrap;
+	text-indent: 0;
+	margin: 0;
+	vertical-align: -20%;
+}
+
+rb
+{
+	display: table-row-group;
+	line-height: 150%;
+}
+
+rt
+{
+	display: table-header-group;
+	font-size: 60%;
+	line-height: 40%;
+	letter-spacing: 0;
 }
\ No newline at end of file
diff --git a/src/com/ichi2/anki/Ankidroid.java b/src/com/ichi2/anki/Ankidroid.java
index 074ac2e679e9..0327788267b9 100644
--- a/src/com/ichi2/anki/Ankidroid.java
+++ b/src/com/ichi2/anki/Ankidroid.java
@@ -60,6 +60,7 @@
 
 import com.ichi2.anki.DeckTask.TaskData;
 import com.ichi2.utils.DiffEngine;
+import com.ichi2.utils.RubyParser;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 /**
@@ -725,6 +726,8 @@ public void updateCard(String content)
 		//In order to display the bold style correctly, we have to change font-weight to 700
 		content = content.replaceAll("font-weight:600;", "font-weight:700;");
 
+		content = RubyParser.ankiRubyToMarkup(content);
+		
 		Log.i(TAG, "content card = \n" + content);
 		String card = cardTemplate.replace("::content::", content);
 		mCard.loadDataWithBaseURL("", card, "text/html", "utf-8", null);
diff --git a/src/com/ichi2/utils/RubyParser.java b/src/com/ichi2/utils/RubyParser.java
new file mode 100644
index 000000000000..03554967b0d8
--- /dev/null
+++ b/src/com/ichi2/utils/RubyParser.java
@@ -0,0 +1,116 @@
+/**
+ * 
+ */
+package com.ichi2.utils;
+
+/**
+ * Parses text input from Anki cards to display ruby text correctly in AnkiDroid.
+ * Anki's Japanese language support handles ruby text as:
+ * <code>basetext[rubytext]</code> 
+ * where the base text begins after the first spacer proceeding the ruby text, 
+ * or the beginning of the string of text if no spacers exist before the start of the base text.
+ * This is converted to basic ruby markup:
+ * <code><ruby><rb>baseText</rb><rt>rubyText</rt></ruby></code>
+ *   While webkit on android devices does not support ruby markup yet, 
+ *   the text can be adjusted adequately using css.
+ * @author brennan.daguilar@gmail.com (Brennan D'Aguilar)
+ *
+ */
+public class RubyParser {
+
+    private static final  char RUBY_SPACER_JAP_SPACE = ' ';
+    private static final char RUBY_SPACER_JAP_COMMA = '、';
+    private static final  char RUBY_TEXT_START = '[';
+    private static final  char RUBY_TEXT_END = ']';
+    private static final  char HTML_TAG_START = '<';
+    private static final  char HTML_TAG_END = '>';
+
+    /**
+     * Converts ruby text from the format used by Anki's Japanese support plugin
+     * to html ruby markup.
+     * @param sourceText the japanese text containing ruby text
+     * @return html ruby markup equivalent of the input text.
+     */
+    public static String ankiRubyToMarkup(String sourceText)
+    {
+        int cursorIndex = 0;
+
+        int nextRubyTextStart;     // The first '[' after the cursorIndex
+        int nextSpacer;                      // The first spacer (' ', or '、') after the cursorIndex
+        int nextRubyTextEnd;      // The first ']' after the cursorIndex
+        int nextHtmlTagStart;      // The first '<' after the cursorIndex
+
+        StringBuilder builder = new StringBuilder();
+
+        // Loop until the entire string is parsed
+        while (cursorIndex < sourceText.length() - 1)
+        {
+            //Find the location of the beginning of the next ruby text
+            nextRubyTextStart = sourceText.indexOf(RUBY_TEXT_START, cursorIndex);
+            
+            //Find the location of the next spacing character (only -1 if neither possible
+            // spacing character remains.
+            nextSpacer = sourceText.indexOf(RUBY_SPACER_JAP_SPACE, cursorIndex);
+            if (nextSpacer == -1)
+            {
+                nextSpacer =  Math.max(nextSpacer, sourceText.indexOf(RUBY_SPACER_JAP_COMMA, cursorIndex));
+            }
+            
+            
+            //Check for html tags that come before any ruby text.  If found, pass the full tag
+            // without parsing.
+            nextHtmlTagStart = sourceText.indexOf(HTML_TAG_START, cursorIndex);
+
+            if (nextHtmlTagStart != -1 &&
+                    (nextSpacer == -1 || nextHtmlTagStart < nextSpacer ) &&
+                    (nextRubyTextStart == -1 || nextHtmlTagStart < nextRubyTextStart))
+            {
+                int nextHtmlTagEnd = sourceText.indexOf(HTML_TAG_END, nextHtmlTagStart);
+                builder.append(sourceText.substring(cursorIndex, nextHtmlTagEnd + 1));
+                cursorIndex = nextHtmlTagEnd + 1;
+            }
+            else //If no html tag is passed through on this cycle, check for ruby text.
+            {
+                // If any unparsed ruby text remains
+                if  (nextRubyTextStart != -1) 
+                {
+                    //If there is any text before the next ruby tag that is part of the ruby base text,
+                    // pass it through unparsed.
+                    if (nextSpacer < nextRubyTextStart && nextSpacer != -1)
+                    {
+                        // Remove spaces from the text
+                        if (sourceText.charAt(nextSpacer) == RUBY_SPACER_JAP_SPACE)
+                        {
+                            builder.append(sourceText.substring(cursorIndex, nextSpacer));
+                        }
+                        else //If spacing character is not a space (eg. a comma), pass it through as well.
+                        {
+                            builder.append(sourceText.substring(cursorIndex, nextSpacer + 1));
+                        }
+                        cursorIndex = nextSpacer + 1;
+                    } 
+                    else 
+                    {
+                        // Find the end of the ruby text, and parse it into html tags.
+                        nextRubyTextEnd = sourceText.indexOf(RUBY_TEXT_END, cursorIndex);
+                        builder.append(newRubyPair(sourceText.substring(cursorIndex, nextRubyTextStart), sourceText.substring(nextRubyTextStart + 1, nextRubyTextEnd)));
+                        cursorIndex = nextRubyTextEnd + 1;
+                    }
+                }
+                else 
+                {
+                    // If no ruby text remains to be parsed, pass any remaining text through and finish.
+                    builder.append(sourceText.substring(cursorIndex));
+                    cursorIndex = sourceText.length();
+                }
+            }
+        }
+
+        return builder.toString();
+
+    }
+
+    private static String newRubyPair(String baseText, String rubyText) {
+        return "<ruby><rb>" + baseText + "</rb><rt>" + rubyText + "</rt></ruby>";
+    }
+}
