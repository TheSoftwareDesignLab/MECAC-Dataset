diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 14d5a4a226e0..01f4f30b01c8 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -21,7 +21,7 @@
       package="com.ichi2.anki"
       android:versionName="0.4" android:versionCode="10">
     <application android:label="@string/app_name" android:icon="@drawable/anki" android:name="AnkiDroidApp" android:debuggable="true">
-        <activity android:name="StudyOptions" android:label="@string/app_name">
+        <activity android:name="StudyOptions">
          <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
diff --git a/res/layout/shared_deck_item.xml b/res/layout/download_deck_item.xml
similarity index 50%
rename from res/layout/shared_deck_item.xml
rename to res/layout/download_deck_item.xml
index 162d7488abb9..c0794672fb35 100644
--- a/res/layout/shared_deck_item.xml
+++ b/res/layout/download_deck_item.xml
@@ -21,7 +21,48 @@
   android:layout_height="wrap_content"
   android:orientation="vertical">
 
-	<TextView android:id="@+id/SharedDeckTitle"
+	  
+	  <TextView android:id="@+id/header_title"
+	  	android:layout_width="fill_parent"
+	  	android:layout_height="wrap_content"
+	  	android:textColor="#000000"
+	  	android:textColorHighlight="#000000"
+	  	android:background="#dddddd"
+	  	android:textStyle="bold"
+	  	android:visibility="gone"/>
+	  	
+
+	<TextView android:id="@+id/download_title"
+		android:layout_width="fill_parent"
+		android:layout_height="wrap_content"
+		android:padding="10dip"
+		android:singleLine="true"
+		android:ellipsize="end"
+		android:textSize="24sp"
+		android:textColor="#ffffff"
+		android:visibility="gone"/>
+	
+	<ProgressBar android:id="@+id/progress_bar"
+  		android:layout_width="fill_parent"
+  		android:layout_height="wrap_content"
+  		android:padding="10dip"
+  		style="?android:attr/progressBarStyleHorizontal"
+  		android:indeterminate="true"
+  		android:indeterminateBehavior="cycle"
+  		android:progress="0"
+  		android:max="100"
+  		android:visibility="gone"/>
+  	
+  	<TextView android:id="@+id/progress_text"
+  		android:layout_width="wrap_content"
+  		android:layout_height="wrap_content"
+  		android:paddingLeft="10dip"
+  		android:paddingBottom="5dip"
+  		android:text="Downloading..."
+  		android:textColor="#ffffff"
+  		android:visibility="gone"/>
+  		
+	<TextView android:id="@+id/deck_title"
 		android:layout_width="fill_parent"
 		android:layout_height="wrap_content"
 		android:padding="10dip"
@@ -29,7 +70,7 @@
 		android:textSize="24sp"
 		android:textColor="#ffffff"/>
 		
-	<TextView android:id="@+id/SharedDeckFacts" 
+	<TextView android:id="@+id/deck_facts" 
 		android:layout_height="wrap_content" 
 		android:layout_width="fill_parent"
 		android:gravity="center_horizontal"
diff --git a/res/layout/download_deck_picker.xml b/res/layout/download_deck_picker.xml
new file mode 100644
index 000000000000..2efc24c678d9
--- /dev/null
+++ b/res/layout/download_deck_picker.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  	android:layout_width="fill_parent"
+  	android:layout_height="fill_parent"
+  	android:orientation="vertical">
+  	
+  <ListView android:id="@+id/list"
+  	android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:fastScrollEnabled="true"/>
+    
+</LinearLayout>
diff --git a/res/layout/list_header.xml b/res/layout/list_header.xml
new file mode 100644
index 000000000000..51120ad84112
--- /dev/null
+++ b/res/layout/list_header.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  android:layout_width="fill_parent"
+  android:layout_height="wrap_content"
+  android:paddingTop="2dp"
+  android:paddingBottom="2dp"
+  android:paddingLeft="5dp"
+  android:background="#ffffff">
+  
+  <TextView android:id="@+id/header_title"
+  	android:layout_width="fill_parent"
+  	android:layout_height="wrap_content"
+  	android:textColor="#000000"
+  	android:textStyle="bold"/>
+  	
+</LinearLayout>
diff --git a/res/layout/main.xml b/res/layout/main.xml
index 32e45559293c..4290aa01c646 100644
--- a/res/layout/main.xml
+++ b/res/layout/main.xml
@@ -19,4 +19,4 @@
     android:id="@+id/files"
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
-    />
\ No newline at end of file
+    android:fastScrollEnabled="true"/>
\ No newline at end of file
diff --git a/res/layout/personal_deck_item.xml b/res/layout/personal_deck_item.xml
deleted file mode 100644
index f60aad324b1b..000000000000
--- a/res/layout/personal_deck_item.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<!--
-~ Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>
-~
-~ This program is free software; you can redistribute it and/or modify it under
-~ the terms of the GNU General Public License as published by the Free Software
-~ Foundation; either version 3 of the License, or (at your option) any later
-~ version.
-~
-~ This program is distributed in the hope that it will be useful, but WITHOUT ANY
-~ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-~ PARTICULAR PURPOSE. See the GNU General Public License for more details.
-~
-~ You should have received a copy of the GNU General Public License along with
-~ this program.  If not, see <http://www.gnu.org/licenses/>.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-  android:layout_width="fill_parent"
-  android:layout_height="wrap_content"
-  android:orientation="vertical">
-
-	<TextView android:id="@+id/PersonalDeckTitle"
-		android:layout_width="fill_parent"
-		android:layout_height="wrap_content"
-		android:padding="10dip"
-		android:gravity="center_horizontal"
-		android:textSize="24sp"
-		android:textColor="#ffffff"/>
-		
-</LinearLayout>
diff --git a/res/layout/preferences.xml b/res/layout/preferences.xml
index 1d8ed7a04cfe..6199d8b3f322 100644
--- a/res/layout/preferences.xml
+++ b/res/layout/preferences.xml
@@ -25,7 +25,7 @@
 			android:key="generateSampleDeck" />
 		<EditTextPreference
 			android:title="@string/deck_path"
-			android:defaultValue="/sdcard"
+			android:defaultValue="/sdcard/Anki"
 			android:summary="@string/deck_path_summ"
 			android:key="deckPath" />
 	</PreferenceCategory>
@@ -86,7 +86,7 @@
 			android:key="corporalPunishments" />
 		<CheckBoxPreference
 			android:title="@string/notification_bar"
-			android:defaultValue="false"
+			android:defaultValue="true"
 			android:summary="@string/notification_bar_summ"
 			android:key="notificationBar" />
 	</PreferenceCategory>
diff --git a/src/com/ichi2/anki/About.java b/src/com/ichi2/anki/About.java
index e224eaa9dff4..9768795cba2c 100644
--- a/src/com/ichi2/anki/About.java
+++ b/src/com/ichi2/anki/About.java
@@ -16,14 +16,9 @@
 ****************************************************************************************/
 package com.ichi2.anki;
 
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
 import android.app.Activity;
-import android.content.SharedPreferences;
 import android.database.SQLException;
 import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
 import android.webkit.WebView;
 
 /**
@@ -32,30 +27,13 @@
 
 public class About extends Activity
 {
-	private boolean notificationBar;
-	
 	@Override
 	public void onCreate(Bundle savedInstanceState) throws SQLException
 	{
 		super.onCreate(savedInstanceState);
 				
-		restorePreferences();
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-
 		setContentView(R.layout.about);
 		WebView webview = (WebView) findViewById(R.id.about);
 		webview.loadDataWithBaseURL("", getResources().getString(R.string.about_content), "text/html", "utf-8", null);
 	}
-
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
-	}
-
 }
\ No newline at end of file
diff --git a/src/com/ichi2/anki/AnkiDroidApp.java b/src/com/ichi2/anki/AnkiDroidApp.java
index 5ea31618b20b..2c746314422b 100644
--- a/src/com/ichi2/anki/AnkiDroidApp.java
+++ b/src/com/ichi2/anki/AnkiDroidApp.java
@@ -74,6 +74,10 @@ public void onCreate() {
 		storageDirectory = Environment.getExternalStorageDirectory().getAbsolutePath();
 		res = getResources();
 		SharedPreferences prefs = PrefSettings.getSharedPrefs(this);
+		
+		// FIXME: Test
+		DownloadManager.getSharedInstance(getApplicationContext(), prefs.getString("username", "eduzasu"), prefs.getString("password", "asrso8D0f1i8f"), prefs.getString("deckPath", "/mnt/sdcard/Anki Decks"));
+		
 		// Assign some default settings if necessary
 		if (prefs.getString(PrefSettings.KEY_CHECK_URI, null) == null) {
 			Editor editor = prefs.edit();
diff --git a/src/com/ichi2/anki/AnkiDroidProxy.java b/src/com/ichi2/anki/AnkiDroidProxy.java
index 97e766745f3c..785c1e43336f 100644
--- a/src/com/ichi2/anki/AnkiDroidProxy.java
+++ b/src/com/ichi2/anki/AnkiDroidProxy.java
@@ -492,7 +492,7 @@ private static String handleFile(InputStream source, SharedDeck sharedDeck, Stri
 				
 				if("shared.anki".equalsIgnoreCase(zipEntry.getName()))
 				{
-					Utils.writeToFile(zipInputStream, deckFilename);
+					Utils.writeToFile(zipInputStream, deckFilename + ".tmp");
 				}
 				else if(zipEntry.getName().startsWith("shared.media/", 0))
 				{
@@ -502,6 +502,9 @@ else if(zipEntry.getName().startsWith("shared.media/", 0))
 				}
 			}
 			zipInputStream.close();
+			
+			// TODO: Finish he workflow of temporal files (when a temporal file is renamed, how...) and see that is consistent in any scenario
+			new File(deckFilename + ".tmp").renameTo(new File(deckFilename));
 		}
 		
 		return deckFilename;
diff --git a/src/com/ichi2/anki/Deck.java b/src/com/ichi2/anki/Deck.java
index 65fc7aa14de0..512d2b1fe876 100644
--- a/src/com/ichi2/anki/Deck.java
+++ b/src/com/ichi2/anki/Deck.java
@@ -24,9 +24,9 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.Stack;
-import java.util.Map.Entry;
 
 import android.content.ContentValues;
 import android.database.Cursor;
@@ -229,7 +229,7 @@ private void initVars()
 		reviewEarly = false;
 	}
 
-	public static Deck openDeck(String path) throws SQLException
+	public static synchronized Deck openDeck(String path) throws SQLException
 	{
 		Deck deck = null;
 		Cursor cursor = null;
@@ -336,7 +336,7 @@ public static Deck openDeck(String path) throws SQLException
 		return deck;
 	}
 
-	public void closeDeck()
+	public synchronized void closeDeck()
 	{
 		DeckTask.waitToFinish(); // Wait for any thread working on the deck to finish.
 		if (modifiedSinceSave())
@@ -721,7 +721,8 @@ public void updateAllCards()
 	{
         Cursor cursor = AnkiDb.database.rawQuery(
                 "SELECT id, factId " +
-                "FROM cards", 
+                "FROM cards " +
+                "ORDER BY id", 
                 null);
 
         while (cursor.moveToNext())
@@ -745,6 +746,7 @@ public void updateAllCards()
             
             card.toDB();
         }
+        cursor.close();
 	}
 	
 	/* Answering a card
diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index 09c8aea6a67d..330a406c89bb 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -44,8 +44,6 @@
 import android.preference.PreferenceManager;
 import android.util.Log;
 import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
 import android.widget.AdapterView;
 import android.widget.ListView;
 import android.widget.ProgressBar;
@@ -86,10 +84,6 @@ public class DeckPicker extends Activity implements Runnable
 
 	private BroadcastReceiver mUnmountReceiver = null;
 	
-	
-	private boolean notificationBar;
-	
-
 	AdapterView.OnItemClickListener mDeckSelHandler = new AdapterView.OnItemClickListener()
 	{
 		public void onItemClick(AdapterView<?> parent, View v, int p, long id)
@@ -105,13 +99,6 @@ public void onCreate(Bundle savedInstanceState) throws SQLException
 		Log.i(TAG, "DeckPicker - onCreate");
 		super.onCreate(savedInstanceState);
 
-		
-		restorePreferences();
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-		
 		registerExternalStorageListener();
 
 		mSelf = this;
@@ -257,7 +244,6 @@ public boolean accept(File pathname)
 				return true;
 			return false;
 		}
-
 	}
 
 	private static final class HashMapCompare implements Comparator<HashMap<String, String>>
@@ -447,15 +433,6 @@ public void onDestroy()
     	if(mUnmountReceiver != null)
     		unregisterReceiver(mUnmountReceiver);
     }
-
-	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
-	}
 	
 	/*private void logTree(TreeSet<HashMap<String, String>> tree)
 	{
diff --git a/src/com/ichi2/anki/DeckPreferences.java b/src/com/ichi2/anki/DeckPreferences.java
index a57d9d8ff041..cb64ac9a5da5 100644
--- a/src/com/ichi2/anki/DeckPreferences.java
+++ b/src/com/ichi2/anki/DeckPreferences.java
@@ -22,8 +22,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
 import android.content.ContentValues;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
@@ -32,8 +30,6 @@
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.util.Log;
-import android.view.Window;
-import android.view.WindowManager;
 
 /**
  * Preferences for the current deck.
@@ -43,10 +39,6 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
 
     static final String TAG = "AnkiDroid";
     
-	
-	private boolean notificationBar;
-	
-
     public class DeckPreferenceHack implements SharedPreferences
     {
 
@@ -244,13 +236,6 @@ public void onCreate( Bundle icicle )
         } 
         else
         {
-    		
-    		restorePreferences();
-    		// Remove the status bar and make title bar progress available
-    		if (notificationBar==false) {
-    		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-    		}
-    		
     		//requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
     		
             this.pref = new DeckPreferenceHack();
@@ -280,14 +265,4 @@ protected void updateSummaries()
             pref.setSummary( this.pref.getString( key, "" ) );
         }
     }
-    
-	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
-	}
-	
 }
diff --git a/src/com/ichi2/anki/DeckProperties.java b/src/com/ichi2/anki/DeckProperties.java
index f406eb118fbf..032f1b11281e 100644
--- a/src/com/ichi2/anki/DeckProperties.java
+++ b/src/com/ichi2/anki/DeckProperties.java
@@ -6,8 +6,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
 import android.content.BroadcastReceiver;
 import android.content.ContentValues;
 import android.content.Context;
@@ -20,16 +18,11 @@
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.util.Log;
-import android.view.WindowManager;
 
 public class DeckProperties extends PreferenceActivity implements OnSharedPreferenceChangeListener {
 
 	static final String TAG = "AnkiDroid";
 	
-	
-	private boolean notificationBar;
-	
-	
 	/**
 	 * Broadcast that informs us when the sd card is about to be unmounted
 	 */
@@ -222,13 +215,6 @@ public void onCreate( Bundle icicle )
 		}
 		else
 		{
-			
-			restorePreferences();
-			// Remove the status bar and make title bar progress available
-			if (notificationBar==false) {
-			getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-			}
-			
 			registerExternalStorageListener();
 			this.pref = new DeckPreferenceHack();
 			this.pref.registerOnSharedPreferenceChangeListener( this );
@@ -294,14 +280,5 @@ protected void updateSummaries()
 			pref.setSummary( this.pref.getString( key, "" ) );
 		}
 	}
-
-	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
-	}
 	
 }
diff --git a/src/com/ichi2/anki/Download.java b/src/com/ichi2/anki/Download.java
new file mode 100644
index 000000000000..8474e5231755
--- /dev/null
+++ b/src/com/ichi2/anki/Download.java
@@ -0,0 +1,165 @@
+package com.ichi2.anki;
+
+import java.net.URL;
+import java.text.DecimalFormat;
+import java.util.HashMap;
+
+public class Download extends HashMap<String,Object>{
+
+	public static final String TAG = "AnkiDroid";
+
+	// Status names
+    public static final String STATUSES[] = {"Downloading", "Paused", "Complete", "Cancelled", "Error"};
+    
+    // Status codes
+    public static final int START = -1;
+    public static final int DOWNLOADING = 0;
+    public static final int PAUSED = 1;
+    public static final int COMPLETE = 2;
+    public static final int CANCELLED = 3;
+    public static final int ERROR = 4;
+    
+    // Download URL
+	private URL url;
+	// Size of download in bytes
+    protected long size;
+    // Number of bytes downloaded
+    private long downloaded;
+    // Current status of download
+    private int status; 
+    private int progress;
+    // Download's title
+    protected String title;
+    
+    // Constructor for Download.
+    public Download(URL url) {
+    	this.url = url;
+    	put("filename", url.toString());
+        size = -1;
+        downloaded = 0;
+        status = START;
+    }
+    
+    public Download(String title)
+    {
+    	this.title = title;
+    	size = -1;
+    	downloaded = 0;
+    	status = START;
+    }
+    
+    public Download(String title, long downloaded)
+    {
+    	this.title = title;
+    	this.downloaded = downloaded;
+    	status = START;
+    }
+    
+    public URL getUrl() {
+		return url;
+	}
+
+	public void setUrl(URL url) {
+		this.url = url;
+		put("filename", url.toString());
+	}
+
+	public long getSize() {
+		return size;
+	}
+
+	public void setSize(long size) {
+		this.size = size;
+		float sizeToShow = size;
+		int divs = 0;
+		while(sizeToShow > 1000)
+		{
+			sizeToShow = sizeToShow / 1000;
+			divs++;
+		}
+		
+		DecimalFormat dec = new DecimalFormat("#.##");
+		switch(divs)
+		{
+			case 0:
+				put("size", dec.format(sizeToShow) + "B");
+				break;
+				
+			case 1:
+				put("size", dec.format(sizeToShow) + "KB");
+				break;
+				
+			case 2:
+				put("size", dec.format(sizeToShow) + "MB");
+				break;
+				
+			case 3:
+				put("size", dec.format(sizeToShow) + "GB");
+				break;
+		}
+		setProgress();
+	}
+
+	public long getDownloaded() {
+		return downloaded;
+	}
+
+	public void setDownloaded(long downloaded) {
+		this.downloaded = downloaded;
+		float downloadedToShow = downloaded;
+		int divs = 0;
+		while(downloadedToShow > 1000)
+		{
+			downloadedToShow = downloadedToShow / 1000;
+			divs++;
+		}
+		
+		DecimalFormat dec = new DecimalFormat("#.##");
+		switch(divs)
+		{
+			case 0:
+				put("downloaded", dec.format(downloadedToShow) + "B");
+				break;
+				
+			case 1:
+				put("downloaded", dec.format(downloadedToShow) + "KB");
+				break;
+				
+			case 2:
+				put("downloaded", dec.format(downloadedToShow) + "MB");
+				break;
+				
+			case 3:
+				put("downloaded", dec.format(downloadedToShow) + "GB");
+				break;
+		}
+		setProgress();
+	}
+
+	public int getProgress() 
+	{
+		return progress;
+	}
+	
+	private void setProgress() 
+	{
+		progress = (int) (((float)downloaded / size) * 100);
+		put("progress", progress + "%");
+	}
+	
+	public int getStatus() {
+		return status;
+	}
+
+	public void setStatus(int status) {
+		this.status = status;
+	}
+
+	public String getTitle() {
+		return title;
+	}
+
+	public void setTitle(String title) {
+		this.title = title;
+	}
+}
diff --git a/src/com/ichi2/anki/DownloadManager.java b/src/com/ichi2/anki/DownloadManager.java
new file mode 100644
index 000000000000..9273d48bb9b4
--- /dev/null
+++ b/src/com/ichi2/anki/DownloadManager.java
@@ -0,0 +1,736 @@
+package com.ichi2.anki;
+
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.RandomAccessFile;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.zip.InflaterInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.database.CursorIndexOutOfBoundsException;
+import android.database.SQLException;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.util.Log;
+
+import com.ichi2.async.Connection;
+import com.ichi2.async.Connection.Payload;
+
+public class DownloadManager {
+
+	private static final String TAG = "AnkiDroid";
+
+	public static final int ALL_DOWNLOADS = 0;
+	public static final int PERSONAL_DECK_DOWNLOAD = 1;
+	public static final int SHARED_DECK_DOWNLOAD = 2;
+	
+	private static final String ANKI_URL = "http://anki.ichi2.net";
+	private static final String SYNC_URL = ANKI_URL + "/sync/";
+	// Max size of download buffer.
+	private static final int MAX_BUFFER_SIZE = 1024;
+
+	static DownloadManager mSharedInstance;
+	
+	private Context mContext;
+	private static String mUsername;
+	private static String mPassword;
+	private static String mDestination;
+	
+	private ArrayList<Download> mPersonalDeckDownloads;
+	private ArrayList<DownloadsListener> mPersonalDeckListeners;
+	
+	private ArrayList<SharedDeckDownload> mSharedDeckDownloads;
+	private ArrayList<DownloadsListener> mSharedDeckListeners;
+	
+	private int mNotificationCounter = 0;
+	
+	public synchronized static DownloadManager getSharedInstance(Context context, String username, String password, String destination)
+	{
+		if (mSharedInstance == null || !username.equalsIgnoreCase(mUsername) || !password.equalsIgnoreCase(mPassword) || !destination.equalsIgnoreCase(destination))
+		{
+			mSharedInstance = new DownloadManager(context, username, password, destination);
+		}
+		return mSharedInstance;
+	}
+
+	public DownloadManager(Context context, String username, String password, String destination)
+	{
+		mContext = context;
+		mUsername = username;
+		mPassword = password;
+		mDestination = destination;
+		mPersonalDeckDownloads = new ArrayList<Download>();
+		mPersonalDeckListeners = new ArrayList<DownloadsListener>();
+		mSharedDeckDownloads = new ArrayList<SharedDeckDownload>();
+		mSharedDeckListeners = new ArrayList<DownloadsListener>();
+		
+		addIncompleteDownloads();
+		resumeDownloads();
+	}
+
+	private void addIncompleteDownloads() 
+	{
+		Log.i(TAG, "Adding incomplete downloads:");
+		File dir = new File(mDestination);
+		File[] fileList = dir.listFiles(new IncompleteDownloadsFilter());
+		
+		if(fileList != null)
+		{
+			for(int i = 0; i < fileList.length; i++)
+			{
+				File file = fileList[i];
+				
+				
+				String filename = file.getName();
+				// Personal decks
+				if(filename.endsWith(".anki.tmp"))
+				{
+					mPersonalDeckDownloads.add(new Download(filename.substring(0, filename.length() - ".anki.tmp".length()), file.length()));
+					Log.i(TAG, "Incomplete download of deck = " + mPersonalDeckDownloads.get(mPersonalDeckDownloads.size() - 1).getTitle() + ", downloaded = " +  mPersonalDeckDownloads.get(mPersonalDeckDownloads.size() - 1).getDownloaded() + "B");
+				}
+				// Shared decks
+				else if(filename.endsWith(".shared.zip.tmp"))
+				{
+					filename = filename.substring(0, filename.length() - ".shared.zip.tmp".length());
+					Log.i(TAG, "filename = " + filename);
+					int lastDotPosition = filename.lastIndexOf(".");
+					Log.i(TAG, "lastDotPosition = " + lastDotPosition);
+					String identifier = filename.substring(lastDotPosition + 1, filename.length());
+					Log.i(TAG, "identifier = " + identifier);
+					String title = filename.substring(0, lastDotPosition);
+					Log.i(TAG, "Title = " + title);
+					mSharedDeckDownloads.add(new SharedDeckDownload(Integer.parseInt(identifier), title, file.length()));
+					Log.i(TAG, "Incomplete download of deck = " + mSharedDeckDownloads.get(mSharedDeckDownloads.size() - 1).getTitle() + ", identifier = " + identifier + " downloaded = " +  mSharedDeckDownloads.get(mSharedDeckDownloads.size() - 1).getDownloaded() + "B");
+				}
+			}
+			notifyObservers();
+		}
+	}
+	
+	public void resumeDownloads()
+	{
+		int i = 0;
+		int j = 0;
+		
+		int personalDeckDownloadsSize = mPersonalDeckDownloads.size();
+		int sharedDeckDownloadsSize = mSharedDeckDownloads.size();
+		
+		// Resume both personal deck downloads and shared deck downloads
+		for(i = 0; i < personalDeckDownloadsSize &&  i < sharedDeckDownloadsSize; i++)
+		{
+			resumeDownload(mPersonalDeckDownloads.get(i));
+			resumeDownload(mSharedDeckDownloads.get(i));
+		}
+		
+		// Download remaining personal deck downloads
+		for(j = i; j < personalDeckDownloadsSize; j++)
+		{
+			resumeDownload(mPersonalDeckDownloads.get(j));
+		}
+		
+		// Download remaining shared deck downloads
+		for(j = i; j < sharedDeckDownloadsSize; j++)
+		{
+			resumeDownload(mSharedDeckDownloads.get(j));
+		}
+	}
+	
+	public List<Download> getDownloadsList(int downloadType)
+	{
+		ArrayList<Download> downloadsList = new ArrayList<Download>();
+		
+		switch(downloadType)
+		{
+			case PERSONAL_DECK_DOWNLOAD:
+				downloadsList.addAll(mPersonalDeckDownloads);
+				break;
+				
+			case SHARED_DECK_DOWNLOAD:
+				downloadsList.addAll(mSharedDeckDownloads);
+				break;
+				
+			case ALL_DOWNLOADS:
+				downloadsList.addAll(mPersonalDeckDownloads);
+				downloadsList.addAll(mSharedDeckDownloads);
+				break;
+		}
+		return downloadsList;
+	}
+	
+	public void downloadFile(Download download)
+	{
+		if(download instanceof SharedDeckDownload)
+		{
+			mSharedDeckDownloads.add((SharedDeckDownload)download);
+		}
+		else
+		{
+			mPersonalDeckDownloads.add(download);
+		}
+		resumeDownload(download);
+	}
+	
+	public void resumeDownload(Download download)
+	{
+		if(download instanceof SharedDeckDownload)
+		{
+			new DownloadSharedDeckTask().execute(download);
+		}
+		else
+		{
+			new DownloadPersonalDeckTask().execute(download);
+		}
+	}
+	
+	private class DownloadPersonalDeckTask extends AsyncTask<Download, Object, Download> {
+		
+		protected Download doInBackground(Download... downloads) 
+		{
+			Download download = downloads[0];
+			
+			URL url;
+			RandomAccessFile file = null;
+			InflaterInputStream iis = null;
+
+			try {
+				url = new URL(SYNC_URL + "fulldown");
+				HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+
+				connection.setDoInput(true);
+				connection.setDoOutput(true);
+				connection.setUseCaches(false);
+				connection.setRequestMethod("POST");
+				// FIXME: The connection always returns all bytes, regardless of what is indicated in range property, so resuming downloads of personal decks is not possible at the moment
+				//		  Fix this when the connection is fixed on AnkiOnline
+				//Log.i(TAG, "Range = " + download.getDownloaded());
+				//connection.setRequestProperty("Range","bytes=" + download.getDownloaded() + "-");
+				connection.setRequestProperty("Content-type", "application/x-www-form-urlencoded");
+
+				connection.connect();
+
+				long startTime = System.currentTimeMillis();
+				
+				DataOutputStream ds = new DataOutputStream(connection.getOutputStream());
+				String data = "p=" + URLEncoder.encode(mPassword,"UTF-8") + "&u=" + URLEncoder.encode(mUsername,"UTF-8") + "&d=" + URLEncoder.encode(download.getTitle(), "UTF-8");
+				ds.writeBytes(data);
+				Log.i(TAG, "Closing streams...");
+				ds.flush();
+				ds.close();
+
+				// Make sure response code is in the 200 range.
+				if (connection.getResponseCode() / 100 != 2) 
+				{
+					download.setStatus(Download.ERROR);
+					publishProgress();
+				}
+				else
+				{
+					download.setStatus(Download.DOWNLOADING);
+					publishProgress();
+				}
+
+				Log.i(TAG, "Response code = " + connection.getResponseCode());
+
+				// Check for valid content length.
+				Log.i(TAG, "Connection length = " + connection.getContentLength());
+				int contentLength = connection.getContentLength();
+				if (contentLength < 1) 
+				{
+					Log.i(TAG, "Content Length = -1");
+					//download.setStatus(Download.ERROR);
+				}
+
+				// Set the size for this download if it hasn't been already set
+				if (download.getSize() == -1 && contentLength != -1) 
+				{
+					download.setSize(contentLength);
+					Log.i(TAG, "File size = " + contentLength);
+					// TODO: NOTIFY???
+				}
+				
+				// Open file
+				file = new RandomAccessFile(mDestination + "/" + download.getTitle() + ".anki.tmp", "rw");
+				// FIXME:  Uncomment next line when the connection is fixed on AnkiOnline (= when the connection only returns the bytes specified on the range property)
+				//file.seek(download.getDownloaded());
+				
+				iis = new InflaterInputStream(connection.getInputStream());
+				
+				while (download.getStatus() == Download.DOWNLOADING) 
+				{
+					// Size buffer according to how much of the file is left to download
+					Log.i(TAG, "Downloading... " + download.getDownloaded());
+					byte buffer[];
+					//if (size - downloaded > MAX_BUFFER_SIZE) {
+					buffer = new byte[MAX_BUFFER_SIZE];
+					//} else {
+					//    buffer = new byte[size - downloaded];
+					//}
+					
+					// Read from server into buffer.
+					int read = iis.read(buffer);
+					if (read == -1)
+					{
+						break;
+					}
+					
+					// Write buffer to file.
+					file.write(buffer, 0, read);
+					download.setDownloaded(download.getDownloaded() + read);
+					//TODO: NOTIFY???
+				}
+				
+				// Change status to complete if this point was reached because downloading has finished
+				if (download.getStatus() == Download.DOWNLOADING) 
+				{
+					download.setStatus(Download.COMPLETE);
+					new File(mDestination + "/" + download.getTitle() + ".anki.tmp").renameTo(new File(mDestination + "/" + download.getTitle() + ".anki"));
+					publishProgress();
+				}
+				long finishTime = System.currentTimeMillis();
+				Log.i(TAG, "Finished in " + ((finishTime - startTime)/1000) + " seconds!");
+				Log.i(TAG, "Downloaded = " + download.getDownloaded());
+				connection.disconnect();
+			} catch (Exception e) {
+				e.printStackTrace();
+				Log.i(TAG, "Exception Error = " + e.getMessage());
+				download.setStatus(Download.ERROR);
+				publishProgress();
+			} finally {
+				// Close file.
+				if (file != null) {
+					try {
+						file.close();
+					} catch (Exception e) {}
+				}
+				
+				// Close connection to server.
+				if (iis != null) {
+					try {
+						iis.close();
+					} catch (Exception e) {}
+				}
+			}
+			
+			return download;
+		}
+
+		protected void onProgressUpdate(Object... values) 
+		{
+			notifyPersonalDeckObservers();
+		}
+
+		protected void onPostExecute(Download download) 
+		{
+			mPersonalDeckDownloads.remove(download);
+			notifyPersonalDeckObservers();
+			showNotification(download.getTitle());
+		}
+	}
+
+	private class DownloadSharedDeckTask extends AsyncTask<Download, Object, Download> {
+		
+		protected Download doInBackground(Download... downloads) 
+		{
+			SharedDeckDownload download = (SharedDeckDownload) downloads[0];
+			
+			URL url;
+			RandomAccessFile file = null;
+			InputStream is = null;
+
+			try {
+				url = new URL(ANKI_URL + "/file/get?id=" + download.getId());
+				HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+
+				connection.setDoInput(true);
+				connection.setDoOutput(true);
+				connection.setUseCaches(false);
+				connection.setRequestMethod("GET");
+				Log.i(TAG, "Range = " + download.getDownloaded());
+				// FIXME: Seems that Range property is also not working well here -> TEST IT!
+				//connection.setRequestProperty("Range","bytes=" + download.getDownloaded() + "-");
+				connection.setRequestProperty("Accept-Encoding", "identity");
+				connection.setRequestProperty("Host", "anki.ichi2.net");
+				connection.setRequestProperty("Connection", "close");
+
+				connection.connect();
+
+				long startTime = System.currentTimeMillis();
+				
+				// Make sure response code is in the 200 range.
+				if (connection.getResponseCode() / 100 != 2) 
+				{
+					download.setStatus(Download.ERROR);
+					publishProgress();
+				}
+				else
+				{
+					download.setStatus(Download.DOWNLOADING);
+					publishProgress();
+				}
+
+				Log.i(TAG, "Response code = " + connection.getResponseCode());
+
+				// Check for valid content length.
+				Log.i(TAG, "Connection length = " + connection.getContentLength());
+				int contentLength = connection.getContentLength();
+				if (contentLength < 1) 
+				{
+					Log.i(TAG, "Content Length = -1");
+					//download.setStatus(Download.ERROR);
+				}
+
+				// Set the size for this download if it hasn't been already set
+				if (download.getSize() == -1 && contentLength != -1) 
+				{
+					download.setSize(contentLength);
+					Log.i(TAG, "File size = " + contentLength);
+					// TODO: NOTIFY???
+				}
+				
+				// Open file
+				file = new RandomAccessFile(mDestination + "/" + download.getTitle() + "." + download.getId() +".shared.zip.tmp", "rw");
+				// FIXME:  Uncomment next line when the connection is fixed on AnkiOnline (= when the connection only returns the bytes specified on the range property)
+				//file.seek(download.getDownloaded());
+				
+				is = connection.getInputStream();
+				
+				//if(download.getFilename().endsWith(".zip"))
+				//{
+					
+					while(download.getStatus() == Download.DOWNLOADING)
+					{
+						Log.i(TAG, "Downloading... " + download.getDownloaded());
+						byte buffer[];
+						//if (size - downloaded > MAX_BUFFER_SIZE) {
+						buffer = new byte[MAX_BUFFER_SIZE];
+						//} else {
+						//    buffer = new byte[size - downloaded];
+						//}
+						
+						// Read from server into buffer.
+						int read = is.read(buffer);
+						if (read == -1)
+						{
+							break;
+						}
+						
+						// Write buffer to file.
+						file.write(buffer, 0, read);
+						download.setDownloaded(download.getDownloaded() + read);
+					}
+					
+				//Utils.writeToFile(is, mDestination + "/" + download.getTitle() + ".zip");
+				//}
+				
+				// Change status to complete if this point was reached because downloading has finished
+				if (download.getStatus() == Download.DOWNLOADING) 
+				{
+					download.setStatus(Download.COMPLETE);
+					new File(mDestination + "/" + download.getTitle() + "." + download.getId() +".shared.zip.tmp").renameTo(new File(mDestination + "/" + download.getTitle() + ".zip"));
+					//TODO: NOTIFY???
+					publishProgress();
+				}
+				
+				long finishTime = System.currentTimeMillis();
+				Log.i(TAG, "Finished in " + ((finishTime - startTime)/1000) + " seconds!");
+				Log.i(TAG, "Downloaded = " + download.getDownloaded());
+				connection.disconnect();
+			} catch (Exception e) {
+				e.printStackTrace();
+				Log.i(TAG, "Exception Error = " + e.getMessage());
+				download.setStatus(Download.ERROR);
+				publishProgress();
+			} finally {
+				// Close file.
+				if (file != null) {
+					try {
+						file.close();
+					} catch (Exception e) {}
+				}
+				// Close connection to server.
+				if (is != null) {
+					try {
+						is.close();
+					} catch (Exception e) {}
+				}
+			}
+			
+			return download;
+		}
+		
+		protected void onProgressUpdate(Object... values) 
+		{
+			notifySharedDeckObservers();
+		}
+
+		protected void onPostExecute(Download download) 
+		{
+			Log.i(TAG, "onPostExecute");
+			SharedDeckDownload sharedDownload = (SharedDeckDownload) download;
+			sharedDownload.setStatus(SharedDeckDownload.UPDATE);
+			notifySharedDeckObservers();
+			
+			
+			try {
+				// Unzip deck and media
+				String unzippedDeckName = unzipSharedDeckFile(mDestination + "/" + download.getTitle() + ".zip", sharedDownload.getTitle());
+				// Update all the cards in the deck
+				new UpdateDeckTask().execute(new Payload(new Object[] {unzippedDeckName, download}));
+			} catch (IOException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+			
+		}
+	}
+	
+	// It seemed to work better with DeckTask: TRY AGAIN and compare them!
+
+	private class UpdateDeckTask extends AsyncTask<Connection.Payload, Connection.Payload, Connection.Payload> {
+
+		@Override
+		protected void onPreExecute() {
+			super.onPreExecute();
+			// Pass
+		}
+
+		@Override
+		protected Payload doInBackground(Payload... args) {
+			Payload data = doInBackgroundLoadDeck(args);
+			if(data.returnType == AnkiDroid.DECK_LOADED)
+			{
+				HashMap<String,Object> results = (HashMap<String, Object>) data.result;
+				Deck deck = (Deck) results.get("deck");
+				deck.updateAllCards();
+				//results.put("card", deck.getCurrentCard());
+			}
+			else
+			{
+				data.success = false;
+			}
+			return data;
+		}
+		
+		private Payload doInBackgroundLoadDeck(Payload... params)
+		{
+			Payload data = params[0];
+			String deckName = (String) data.data[0];
+			String deckFilename = mDestination + "/" + deckName + ".anki";
+			Log.i(TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
+
+			Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
+			try
+			{
+				// Open the right deck.
+				Deck deck = Deck.openDeck(deckFilename);
+				// Start by getting the first card and displaying it.
+				Card card = deck.getCard();
+				Log.i(TAG, "Deck loaded!");
+
+				// Set the result
+				data.returnType = AnkiDroid.DECK_LOADED;
+				HashMap<String,Object> results = new HashMap<String,Object>();
+				results.put("deck", deck);
+				results.put("card", card);
+				data.result = results;
+				return data;
+			} catch (SQLException e)
+			{
+				Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
+				data.success = false;
+				data.returnType = AnkiDroid.DECK_NOT_LOADED;
+				data.exception = e;
+				return data;
+			} catch (CursorIndexOutOfBoundsException e)
+			{
+				Log.i(TAG, "The deck has no cards = " + e.getMessage());
+				data.success = false;
+				data.returnType = AnkiDroid.DECK_EMPTY;
+				data.exception = e;
+				return data;
+			}
+		}
+		
+		@Override
+		protected void onPostExecute(Payload result) {
+			super.onPostExecute(result);
+			if(result.success)
+			{
+				HashMap<String,Object> results = (HashMap<String, Object>) result.result;
+				Deck deck = (Deck) results.get("deck");
+				// Close the previously opened deck.
+				if (deck != null)
+				{
+					deck.closeDeck();
+				}
+				mSharedDeckDownloads.remove((Download)result.data[1]);
+				notifySharedDeckObservers();
+				showNotification((String)result.data[0]);
+			}
+		}
+	}
+	
+	private static final class IncompleteDownloadsFilter implements FileFilter
+	{
+		public boolean accept(File pathname)
+		{
+			if(pathname.isFile() && (pathname.getName().endsWith(".anki.tmp") || pathname.getName().endsWith(".shared.zip.tmp")))
+			{
+				return true;
+			}
+			return false;
+		}
+	}
+	
+	public static interface DownloadsListener {
+		
+		public void onStateChanged(List downloads);
+		
+	}
+	
+	private synchronized void notifyObservers()
+	{
+		notifyPersonalDeckObservers();
+		notifySharedDeckObservers();
+	}
+	
+	private synchronized void notifyPersonalDeckObservers()
+	{
+		for(int i = 0; i < mPersonalDeckListeners.size(); i++)
+		{
+			mPersonalDeckListeners.get(i).onStateChanged(mPersonalDeckDownloads);
+		}
+	}
+	
+	private synchronized void notifySharedDeckObservers()
+	{
+		for(int i = 0; i < mSharedDeckListeners.size(); i++)
+		{
+			mSharedDeckListeners.get(i).onStateChanged(mSharedDeckDownloads);
+		}
+	}
+	
+	public void registerListener(int downloadType, DownloadsListener listener)
+	{
+		switch(downloadType)
+		{
+			case PERSONAL_DECK_DOWNLOAD:
+				mPersonalDeckListeners.add(listener);
+				break;
+				
+			case SHARED_DECK_DOWNLOAD:
+				mSharedDeckListeners.add(listener);
+				break;
+				
+			case ALL_DOWNLOADS:
+				mPersonalDeckListeners.add(listener);
+				mSharedDeckListeners.add(listener);
+				break;
+		}
+	}
+	
+	public void unregisterListener(DownloadsListener listener)
+	{
+		mPersonalDeckListeners.remove(listener);
+		mSharedDeckListeners.remove(listener);
+	}
+	
+	private static String unzipSharedDeckFile(String zipFilename, String title) throws IOException
+	{
+		ZipInputStream zipInputStream = null;
+		Log.i(TAG, "unzipSharedDeckFile");
+		if(zipFilename.endsWith(".zip"))
+		{
+			Log.i(TAG, "zipFilename ends with .zip");
+			zipInputStream = new ZipInputStream(new FileInputStream(new File(zipFilename)));
+
+			title = title.replace("^", "");
+			title = title.substring(0, java.lang.Math.min(title.length(), 40));
+
+			if(new File(mDestination + "/" + title + ".anki").exists())
+				title += System.currentTimeMillis();
+
+			String partialDeckPath = mDestination + "/" + title;
+			String deckFilename = partialDeckPath + ".anki";
+
+			ZipEntry zipEntry = null;
+			while((zipEntry = zipInputStream.getNextEntry()) != null)
+			{
+				Log.i(TAG, "zipEntry = " + zipEntry.getName());
+
+				if("shared.anki".equalsIgnoreCase(zipEntry.getName()))
+				{
+					Utils.writeToFile(zipInputStream, deckFilename);
+				}
+				else if(zipEntry.getName().startsWith("shared.media/", 0))
+				{
+					Log.i(TAG, "Folder created = " + new File(AnkiDroidApp.getStorageDirectory() + title + ".media/").mkdir());
+					Log.i(TAG, "Destination = " + AnkiDroidApp.getStorageDirectory() + "/" + title + ".media/" + zipEntry.getName().replace("shared.media/", ""));
+					Utils.writeToFile(zipInputStream, partialDeckPath + ".media/" + zipEntry.getName().replace("shared.media/", ""));
+				}
+			}
+			zipInputStream.close();
+			
+			new File(zipFilename).delete();
+		}
+
+		return title;
+	}
+	
+	/**
+	 * Show a notification informing the user when a deck is ready to be used
+	 */
+	private void showNotification(String deckTitle) 
+	{
+		NotificationManager mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+
+		// In this sample, we'll use the same text for the ticker and the expanded notification
+		//CharSequence text = getText(R.string.remote_service_started);
+
+		// Set the icon, scrolling text and timestamp
+		Notification notification = new Notification(R.drawable.anki, "Download finished", System.currentTimeMillis());
+
+		Intent loadDeckIntent = new Intent(mContext, StudyOptions.class);
+		loadDeckIntent.putExtra(StudyOptions.OPT_DB, mDestination + "/" + deckTitle + ".anki");
+		loadDeckIntent.setData(Uri.parse(deckTitle));
+		
+		// The PendingIntent to launch our activity if the user selects this notification
+		PendingIntent contentIntent = PendingIntent.getActivity(mContext, 0, loadDeckIntent, 0);
+
+		// Set the info for the views that show in the notification panel.
+		notification.setLatestEventInfo(mContext, deckTitle, "Deck downloaded", contentIntent);
+
+		// Clear the notification when the user selects it
+		notification.flags |= Notification.FLAG_AUTO_CANCEL;
+		
+		// Vibrate
+		notification.defaults |= Notification.DEFAULT_VIBRATE;
+		
+		// Show a blue light
+		notification.ledARGB = 0xff0000ff;
+		notification.ledOnMS = 500;
+		notification.ledOffMS = 1000;
+		notification.flags |= Notification.FLAG_SHOW_LIGHTS;
+		
+		//notification.number = 1;
+		
+		// Send the notification.
+		mNotificationManager.notify(mNotificationCounter++, notification);
+	}
+
+}
diff --git a/src/com/ichi2/anki/MyAccount.java b/src/com/ichi2/anki/MyAccount.java
index 858070431825..8d1f6933c9f1 100644
--- a/src/com/ichi2/anki/MyAccount.java
+++ b/src/com/ichi2/anki/MyAccount.java
@@ -225,7 +225,7 @@ public void onPostExecute(Payload data) {
 			}
 			else
 			{
-				if(data.errorType == AnkiDroidProxy.LOGIN_INVALID_USER_PASS)
+				if(data.returnType == AnkiDroidProxy.LOGIN_INVALID_USER_PASS)
 				{
 					mInvalidUserPassAlert.show();
 				}
diff --git a/src/com/ichi2/anki/PersonalDeckPicker.java b/src/com/ichi2/anki/PersonalDeckPicker.java
index 628068c1cc47..ded30c05a4f7 100644
--- a/src/com/ichi2/anki/PersonalDeckPicker.java
+++ b/src/com/ichi2/anki/PersonalDeckPicker.java
@@ -15,12 +15,13 @@
 import android.os.Bundle;
 import android.util.Log;
 import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
+import android.view.ViewGroup;
 import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
 import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.TextView;
 
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
@@ -28,6 +29,8 @@
 
 public class PersonalDeckPicker extends Activity {
 
+	private DownloadManager mDownloadManager;
+	
 	/**
 	 * Broadcast that informs us when the sd card is about to be unmounted
 	 */
@@ -39,31 +42,23 @@ public class PersonalDeckPicker extends Activity {
 	
 	private AlertDialog connectionFailedAlert;
 	
+	private List<Download> mPersonalDecksDownloads;
 	private List<String> mPersonalDecks;
+	
+	private List<Object> mAllPersonalDecks;
 	private ListView mPersonalDecksListView;
-	private ArrayAdapter<String> mPersonalDecksAdapter;
+	//private ArrayAdapter<String> mPersonalDecksAdapter;
+	private PersonalDecksAdapter mPersonalDecksAdapter;
 	
 	private String username;
 	private String password;
 	private String deckName;
 	private String deckPath;
 	
-	
-	private boolean notificationBar;
-	
-	
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
 		
-		
-		restorePreferences();
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-		
-		
 		setContentView(R.layout.main);
 		registerExternalStorageListener();
 		
@@ -73,8 +68,12 @@ protected void onCreate(Bundle savedInstanceState) {
 		username = pref.getString("username", "");
 		password = pref.getString("password", "");
 		
+		mPersonalDecksDownloads = new ArrayList<Download>();
 		mPersonalDecks = new ArrayList<String>();
-		mPersonalDecksAdapter = new ArrayAdapter<String>(this, R.layout.personal_deck_item, R.id.PersonalDeckTitle, mPersonalDecks);
+		
+		mAllPersonalDecks = new ArrayList<Object>();
+		//mPersonalDecksAdapter = new ArrayAdapter<String>(this, R.layout.personal_deck_item, R.id.PersonalDeckTitle, mAllPersonalDecks);
+		mPersonalDecksAdapter = new PersonalDecksAdapter();
 		mPersonalDecksListView = (ListView)findViewById(R.id.files);
 		mPersonalDecksListView.setAdapter(mPersonalDecksAdapter);
 		mPersonalDecksListView.setOnItemClickListener(new OnItemClickListener() {
@@ -83,17 +82,39 @@ protected void onCreate(Bundle savedInstanceState) {
 			public void onItemClick(AdapterView<?> parent, View view, int position, long id) 
 			{
 				SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
-				deckName = mPersonalDecks.get(position);
+				deckName = (String) mAllPersonalDecks.get(position);
 				deckPath = pref.getString("deckPath", AnkiDroidApp.getStorageDirectory()) + "/" + deckName + ".anki";
 				
-				Connection.downloadPersonalDeck(downloadSharedDeckListener, new Connection.Payload(new Object[] {username, password, deckName, deckPath}));
+				Download personalDeckDownload = new Download(deckName);
+				mPersonalDecksDownloads.add(personalDeckDownload);
+				refreshPersonalDecksList();
+				//new Connection().downloadPersonalDeck(downloadSharedDeckListener, new Connection.Payload(new Object[] {username, password, deckName, deckPath}));
+				mDownloadManager.downloadFile(personalDeckDownload);
 			}
 			
 		});
 		
+		mDownloadManager = DownloadManager.getSharedInstance(getApplicationContext(), username, password, pref.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
 		Connection.getPersonalDecks(getPersonalDecksListener, new Connection.Payload(new Object[] {username, password}));
 	}
 
+	
+	@Override
+	protected void onResume() {
+		super.onResume();
+		mDownloadManager.registerListener(DownloadManager.PERSONAL_DECK_DOWNLOAD, downloadListener);
+		mPersonalDecksDownloads.clear();
+		mPersonalDecksDownloads.addAll(mDownloadManager.getDownloadsList(DownloadManager.PERSONAL_DECK_DOWNLOAD));
+		refreshPersonalDecksList();
+	}
+
+
+	@Override
+	protected void onPause() {
+		super.onPause();
+		mDownloadManager.unregisterListener(downloadListener);
+	}
+
 	@Override
     public void onDestroy()
     {
@@ -153,6 +174,14 @@ private void initAlertDialogs()
 	    connectionFailedAlert = builder.create();
 	}
 	
+	private void refreshPersonalDecksList() 
+	{
+		mAllPersonalDecks.clear();
+		mAllPersonalDecks.addAll(mPersonalDecksDownloads);
+		mAllPersonalDecks.addAll(mPersonalDecks);
+		mPersonalDecksAdapter.notifyDataSetChanged();
+	}
+	
 	/**
 	 * Listeners
 	 */
@@ -171,7 +200,8 @@ public void onPostExecute(Payload data) {
 			{
 				mPersonalDecks.clear();
 				mPersonalDecks.addAll((List<String>)data.result);
-				mPersonalDecksAdapter.notifyDataSetChanged();
+				
+				refreshPersonalDecksList();
 			}
 			else
 			{
@@ -203,15 +233,19 @@ public void onDisconnected() {
 
 		@Override
 		public void onPostExecute(Payload data) {
-			progressDialog.dismiss();
+			//progressDialog.dismiss();
 			if(data.success)
 			{
+				// TODO: Decide what to do when a download is finished
+				/*
 				Intent intent = PersonalDeckPicker.this.getIntent();
 				// Return the name of the downloaded deck
 				intent.putExtra(AnkiDroid.OPT_DB, deckPath);
 				setResult(RESULT_OK, intent);
 
 				finish();
+				*/
+				Log.i("AnkiDroid", "Deck downloaded = " + data.data[2]);
 			}
 			else
 			{
@@ -221,7 +255,7 @@ public void onPostExecute(Payload data) {
 
 		@Override
 		public void onPreExecute() {
-			progressDialog = ProgressDialog.show(PersonalDeckPicker.this, "", getResources().getString(R.string.downloading_shared_deck));
+			//progressDialog = ProgressDialog.show(PersonalDeckPicker.this, "", getResources().getString(R.string.downloading_shared_deck));
 		}
 
 		@Override
@@ -231,13 +265,204 @@ public void onProgressUpdate(Object... values) {
 		
 	};
 	
+	DownloadManager.DownloadsListener downloadListener = new DownloadManager.DownloadsListener() {
+		
+		@Override
+		public void onStateChanged(List downloads) {
+			mPersonalDecksDownloads.clear();
+			mPersonalDecksDownloads.addAll(downloads);
+			
+			refreshPersonalDecksList();
+		}
+		
+	};
 	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
+	/**
+	 * 
+	 * Adapter with Holder pattern
+	 */
+	class ViewWrapper {
+		
+		View base;
+		TextView headerTitle = null;
+		TextView downloadTitle = null;
+		ProgressBar progressBar = null;
+		TextView progressBarText = null;
+		TextView deckTitle = null;
+		TextView deckFacts = null;
+		
+		ViewWrapper(View base) {
+			this.base = base;
+		}
+		
+		TextView getHeaderTitle() 
+		{
+			if(headerTitle == null)
+			{
+				headerTitle = (TextView) base.findViewById(R.id.header_title);
+			}
+			return headerTitle;
+		}
+		
+		TextView getDownloadTitle() 
+		{
+			if(downloadTitle == null)
+			{
+				downloadTitle = (TextView) base.findViewById(R.id.download_title);
+			}
+			return downloadTitle;
+		}
+		
+		ProgressBar getProgressBar()
+		{
+			if(progressBar == null)
+			{
+				progressBar = (ProgressBar) base.findViewById(R.id.progress_bar);
+			}
+			return progressBar;
+		}
+		
+		TextView getProgressBarText()
+		{
+			if(progressBarText == null)
+			{
+				progressBarText = (TextView) base.findViewById(R.id.progress_text);
+			}
+			return progressBarText;
+		}
+
+		TextView getDeckTitle()
+		{
+			if(deckTitle == null)
+			{
+				deckTitle = (TextView) base.findViewById(R.id.deck_title);
+			}
+			return deckTitle;
+		}
+		
+		TextView getDeckFacts()
+		{
+			if(deckFacts == null)
+			{
+				deckFacts = (TextView) base.findViewById(R.id.deck_facts);
+			}
+			return deckFacts;
+		}
+	}
+	
+	public class PersonalDecksAdapter extends BaseAdapter {
+
+		@Override
+		public int getCount() {
+			return mAllPersonalDecks.size();
+		}
+
+		@Override
+		public Object getItem(int position) {
+			return mAllPersonalDecks.get(position);
+		}
+
+		@Override
+		public long getItemId(int position) {
+			return position;
+		}
+		
+		@Override
+		public boolean isEnabled(int position) {
+			return !(mAllPersonalDecks.get(position) instanceof Download);
+		}
+		
+		@Override
+		public View getView(int position, View convertView, ViewGroup parent) {
+			View row = convertView;
+			ViewWrapper wrapper = null;
+			
+			if(row == null)
+			{
+				row = getLayoutInflater().inflate(R.layout.download_deck_item, null);
+				wrapper = new ViewWrapper(row);
+				row.setTag(wrapper);
+			}
+			else
+			{
+				wrapper = (ViewWrapper)row.getTag();
+			}
+			
+			TextView headerTitle = wrapper.getHeaderTitle();
+			TextView downloadingSharedDeckTitle = wrapper.getDownloadTitle();
+			ProgressBar progressBar = wrapper.getProgressBar();
+			TextView progressText = wrapper.getProgressBarText();
+			TextView sharedDeckTitle = wrapper.getDeckTitle();
+			TextView sharedDeckFacts = wrapper.getDeckFacts();
+			
+			Object obj = (Object) mAllPersonalDecks.get(position);
+			if(obj instanceof Download)
+			{
+				Download download = (Download) obj;
+				
+				sharedDeckTitle.setVisibility(View.GONE);
+				sharedDeckFacts.setVisibility(View.GONE);
+				
+				if(position == 0)
+				{
+					headerTitle.setText("Currently downloading");
+					headerTitle.setVisibility(View.VISIBLE);
+				}
+				else
+				{
+					headerTitle.setVisibility(View.GONE);
+				}
+				downloadingSharedDeckTitle.setText(download.getTitle());
+				downloadingSharedDeckTitle.setVisibility(View.VISIBLE);
+				progressBar.setVisibility(View.VISIBLE);
+				switch(download.getStatus())
+				{
+					case Download.START:
+						progressText.setText("Starting download...");
+						break;
+						
+					case Download.DOWNLOADING:
+						progressText.setText("Downloading...");
+						break;
+						
+					case Download.PAUSED:
+						progressText.setText("Paused");
+						break;
+					
+					case Download.COMPLETE:
+						progressText.setText("Downloaded");
+						break;
+						
+					default:
+						progressText.setText("Error");
+						break;
+				}
+				progressText.setVisibility(View.VISIBLE);
+			}
+			else
+			{
+				String personalDeckTitle = (String) obj;
+				if(position > 0 && (mAllPersonalDecks.get(position - 1) instanceof Download))
+				{
+					headerTitle.setText("Shared Decks");
+					headerTitle.setVisibility(View.VISIBLE);
+				}
+				else
+				{
+					headerTitle.setVisibility(View.GONE);
+				}
+				downloadingSharedDeckTitle.setVisibility(View.GONE);
+				progressBar.setVisibility(View.GONE);
+				progressText.setVisibility(View.GONE);
+				
+				sharedDeckTitle.setText(personalDeckTitle);
+				sharedDeckTitle.setVisibility(View.VISIBLE);
+				sharedDeckFacts.setVisibility(View.GONE);
+			}
+			
+			return row;
+		}
 		
-		return preferences;
 	}
 	
 }
diff --git a/src/com/ichi2/anki/Preferences.java b/src/com/ichi2/anki/Preferences.java
index 559386563ea3..63ab77bd99f1 100644
--- a/src/com/ichi2/anki/Preferences.java
+++ b/src/com/ichi2/anki/Preferences.java
@@ -17,10 +17,8 @@
 package com.ichi2.anki;
 
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.os.Bundle;
 import android.preference.PreferenceActivity;
-import android.view.WindowManager;
 
 import com.tomgibara.android.veecheck.Veecheck;
 import com.tomgibara.android.veecheck.util.PrefSettings;
@@ -30,22 +28,11 @@
  */
 public class Preferences extends PreferenceActivity
 {
-	
-	private boolean notificationBar;
-	
-	
 	@Override
 	protected void onCreate(Bundle savedInstanceState)
 	{
 		super.onCreate(savedInstanceState);
 		
-		
-		restorePreferences();
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-		
 		getPreferenceManager().setSharedPreferencesName(PrefSettings.SHARED_PREFS_NAME);
 		addPreferencesFromResource(R.layout.preferences);
 	}
@@ -56,15 +43,4 @@ protected void onPause() {
     	// Reschedule the checking in case the user has changed anything
 		sendBroadcast(new Intent(Veecheck.getRescheduleAction(this)));
     }
-    
-	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
-	}
-	
-
 }
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index f9aefd2582b5..b32cb3e598a3 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -88,7 +88,6 @@ public class Reviewer extends Activity {
 	
 	private boolean notificationBar;
 	
-	
 	public String cardTemplate;
 	
 	/**
@@ -288,8 +287,9 @@ protected void onCreate(Bundle savedInstanceState) {
 			restorePreferences();
 			
 			// Remove the status bar and make title bar progress available
-			if (notificationBar==false) {
-			getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+			if(notificationBar == false) 
+			{
+				getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
 			}
 			
 			requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
diff --git a/src/com/ichi2/anki/SharedDeck.java b/src/com/ichi2/anki/SharedDeck.java
index e8cb7b41ac33..d3d1250a1702 100644
--- a/src/com/ichi2/anki/SharedDeck.java
+++ b/src/com/ichi2/anki/SharedDeck.java
@@ -7,17 +7,17 @@
 public class SharedDeck extends HashMap<String, Object>{
 
 	private static final String TAG = "AnkidroidSharedDecks";
-	private int id;
-	private String username;
-	private String title;
-	private String description;
-	private String tags;
-	private int version;
-	private int facts;
-	private int size;
-	private int count;
-	private double modified;
-	private String fileName;
+	protected int id;
+	protected String username;
+	protected String title;
+	protected String description;
+	protected String tags;
+	protected int version;
+	protected int facts;
+	protected int size;
+	protected int count;
+	protected double modified;
+	protected String fileName;
 
 	public int getId() {
 		return id;
diff --git a/src/com/ichi2/anki/SharedDeckDownload.java b/src/com/ichi2/anki/SharedDeckDownload.java
new file mode 100644
index 000000000000..e997421171bf
--- /dev/null
+++ b/src/com/ichi2/anki/SharedDeckDownload.java
@@ -0,0 +1,37 @@
+package com.ichi2.anki;
+
+public class SharedDeckDownload extends Download {
+
+	public static final int UPDATE = 5;
+	
+	private int id;
+	private String filename;
+	
+	public SharedDeckDownload(int id, String title, long downloaded) {
+		super(title, downloaded);
+		this.id = id;
+	}
+	
+	public SharedDeckDownload(int id, String title, String filename, long size) {
+		super(title);
+		setSize(size);
+		this.id = id;
+		this.filename = filename;
+	}
+	
+	public int getId() {
+		return id;
+	}
+
+	public void setId(int id) {
+		this.id = id;
+	}
+	
+	public String getFilename() {
+		return filename;
+	}
+
+	public void setFilename(String filename) {
+		this.filename = filename;
+	}
+}
diff --git a/src/com/ichi2/anki/SharedDeckPicker.java b/src/com/ichi2/anki/SharedDeckPicker.java
index 8221ec807e64..11e434edae4b 100644
--- a/src/com/ichi2/anki/SharedDeckPicker.java
+++ b/src/com/ichi2/anki/SharedDeckPicker.java
@@ -13,14 +13,14 @@
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
+import android.view.ViewGroup;
 import android.widget.AdapterView;
-import android.widget.ListView;
-import android.widget.SimpleAdapter;
 import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.TextView;
 
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
@@ -28,6 +28,9 @@
 
 public class SharedDeckPicker extends Activity {
 
+	private DownloadManager mDownloadManager;
+	//private SharedDownloadManager mDownloadManager;
+	
 	/**
 	 * Broadcast that informs us when the sd card is about to be unmounted
 	 */
@@ -39,59 +42,78 @@ public class SharedDeckPicker extends Activity {
 	
 	private AlertDialog connectionFailedAlert;
 	
-	
-	private boolean notificationBar;
-	
-	
+	List<Download> mSharedDeckDownloads;
 	List<SharedDeck> mSharedDecks;
+	
+	List<Object> mAllSharedDecks;
 	ListView mSharedDecksListView;
-	SimpleAdapter mSharedDecksAdapter;
+	//SimpleAdapter mSharedDecksAdapter;
+	SharedDecksAdapter mSharedDecksAdapter;
+	SharedDeck deckToDownload;
 	
-	SharedDeck downloadedDeck;
+	private String username;
+	private String password;
+	private String deckName;
+	private String deckPath;
 	
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
 		
-		
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-		
-		setContentView(R.layout.main);
+		setContentView(R.layout.download_deck_picker);
 		
 		registerExternalStorageListener();
 		initAlertDialogs();
 		
+		SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
+		username = pref.getString("username", "");
+		password = pref.getString("password", "");
+		
+		mSharedDeckDownloads = new ArrayList<Download>();
 		mSharedDecks = new ArrayList<SharedDeck>();
-		mSharedDecksAdapter = new SimpleAdapter(this, mSharedDecks, R.layout.shared_deck_item, new String[] {"title", "facts"}, new int[] {R.id.SharedDeckTitle, R.id.SharedDeckFacts});
-		mSharedDecksListView = (ListView)findViewById(R.id.files);
+		
+		mAllSharedDecks = new ArrayList<Object>();
+		//mSharedDecksAdapter = new SimpleAdapter(this, mAllSharedDecks, R.layout.shared_deck_item, new String[] {"title", "title", "facts"}, new int[] {R.id.download_shared_deck_title, R.id.shared_deck_title, R.id.shared_deck_facts});
+		mSharedDecksAdapter =new SharedDecksAdapter();
+		mSharedDecksListView = (ListView)findViewById(R.id.list);
 		mSharedDecksListView.setAdapter(mSharedDecksAdapter);
 		mSharedDecksListView.setOnItemClickListener(new OnItemClickListener() {
 
 			@Override
 			public void onItemClick(AdapterView<?> parent, View view, int position, long id) 
 			{
-				downloadedDeck = mSharedDecks.get(position);
+				deckToDownload = (SharedDeck) mAllSharedDecks.get(position);
+				
+				SharedDeckDownload sharedDeckDownload = new SharedDeckDownload(deckToDownload.getId(), deckToDownload.getTitle(), deckToDownload.getFileName(), deckToDownload.getSize());
+				mSharedDeckDownloads.add(sharedDeckDownload);
+				refreshSharedDecksList();
+				
 				SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
 				String deckPath = preferences.getString("deckPath", AnkiDroidApp.getStorageDirectory());
-				Connection.downloadSharedDeck(downloadSharedDeckListener, new Connection.Payload(new Object[] {downloadedDeck, deckPath}));
+				mDownloadManager.downloadFile(sharedDeckDownload);
+				//new Connection().downloadSharedDeck(downloadSharedDeckListener, new Connection.Payload(new Object[] {deckToDownload, deckPath}));
 			}
-			
 		});
+		mDownloadManager = DownloadManager.getSharedInstance(getApplicationContext(), username, password, pref.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
+		//mDownloadManager = SharedDownloadManager.getSharedInstance(getApplicationContext(), username, password, pref.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
 		Connection.getSharedDecks(getSharedDecksListener, new Connection.Payload(new Object[] {}));
 	}
 	
-	
-	private SharedPreferences restorePreferences()
-	{
-		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		return preferences;
+	@Override
+	protected void onResume() {
+		super.onResume();
+		mDownloadManager.registerListener(DownloadManager.SHARED_DECK_DOWNLOAD, downloadListener);
+		//mDownloadManager.registerListener(downloadListener);
+		mSharedDeckDownloads.clear();
+		mSharedDeckDownloads.addAll(mDownloadManager.getDownloadsList(DownloadManager.SHARED_DECK_DOWNLOAD));
+		//mSharedDeckDownloads.addAll(mDownloadManager.getDownloadsList());
+		refreshSharedDecksList();
 	}
 	
+	@Override
+	protected void onPause() {
+		super.onPause();
+	}
 
 	@Override
     public void onDestroy()
@@ -147,9 +169,43 @@ private void initAlertDialogs()
 	    connectionFailedAlert = builder.create();
 	}
 	
+	private void refreshSharedDecksList() 
+	{
+		mAllSharedDecks.clear();
+		mAllSharedDecks.addAll(mSharedDeckDownloads);
+		mAllSharedDecks.addAll(mSharedDecks);
+		mSharedDecksAdapter.notifyDataSetChanged();
+	}
+	
 	/**
 	 * Listeners
 	 */
+	DownloadManager.DownloadsListener downloadListener = new DownloadManager.DownloadsListener() {
+		
+		@Override
+		public void onStateChanged(List downloads) {
+			mSharedDeckDownloads.clear();
+			mSharedDeckDownloads.addAll(downloads);
+			
+			refreshSharedDecksList();
+		}
+		
+	};
+	
+	/*
+	SharedDownloadManager.DownloadsListener downloadListener = new SharedDownloadManager.DownloadsListener() {
+		
+		@Override
+		public void onStateChanged(List downloads) {
+			mSharedDeckDownloads.clear();
+			mSharedDeckDownloads.addAll(downloads);
+			
+			refreshSharedDecksList();
+		}
+		
+	};
+	*/
+	
 	Connection.TaskListener getSharedDecksListener = new Connection.TaskListener() {
 
 		@Override
@@ -165,6 +221,9 @@ public void onPostExecute(Payload data) {
 			{
 				mSharedDecks.clear();
 				mSharedDecks.addAll((List<SharedDeck>)data.result);
+				mAllSharedDecks.clear();
+				mAllSharedDecks.addAll(mSharedDeckDownloads);
+				mAllSharedDecks.addAll(mSharedDecks);
 				mSharedDecksAdapter.notifyDataSetChanged();
 			}
 			else
@@ -194,7 +253,7 @@ public void onDisconnected() {
 
 		@Override
 		public void onPostExecute(Payload data) {
-			progressDialog.dismiss();
+			//progressDialog.dismiss();
 			if(data.success)
 			{
 				Intent intent = SharedDeckPicker.this.getIntent();
@@ -212,7 +271,7 @@ public void onPostExecute(Payload data) {
 
 		@Override
 		public void onPreExecute() {
-			progressDialog = ProgressDialog.show(SharedDeckPicker.this, "", getResources().getString(R.string.downloading_shared_deck));
+			//progressDialog = ProgressDialog.show(SharedDeckPicker.this, "", getResources().getString(R.string.downloading_shared_deck));
 		}
 
 		@Override
@@ -221,4 +280,193 @@ public void onProgressUpdate(Object... values) {
 		}
 		
 	};
+	
+	class ViewWrapper {
+		
+		View base;
+		TextView headerTitle = null;
+		TextView downloadTitle = null;
+		ProgressBar progressBar = null;
+		TextView progressBarText = null;
+		TextView deckTitle = null;
+		TextView deckFacts = null;
+		
+		ViewWrapper(View base) {
+			this.base = base;
+		}
+		
+		TextView getHeaderTitle() 
+		{
+			if(headerTitle == null)
+			{
+				headerTitle = (TextView) base.findViewById(R.id.header_title);
+			}
+			return headerTitle;
+		}
+		
+		TextView getDownloadTitle() 
+		{
+			if(downloadTitle == null)
+			{
+				downloadTitle = (TextView) base.findViewById(R.id.download_title);
+			}
+			return downloadTitle;
+		}
+		
+		ProgressBar getProgressBar()
+		{
+			if(progressBar == null)
+			{
+				progressBar = (ProgressBar) base.findViewById(R.id.progress_bar);
+			}
+			return progressBar;
+		}
+		
+		TextView getProgressBarText()
+		{
+			if(progressBarText == null)
+			{
+				progressBarText = (TextView) base.findViewById(R.id.progress_text);
+			}
+			return progressBarText;
+		}
+
+		TextView getDeckTitle()
+		{
+			if(deckTitle == null)
+			{
+				deckTitle = (TextView) base.findViewById(R.id.deck_title);
+			}
+			return deckTitle;
+		}
+		
+		TextView getDeckFacts()
+		{
+			if(deckFacts == null)
+			{
+				deckFacts = (TextView) base.findViewById(R.id.deck_facts);
+			}
+			return deckFacts;
+		}
+	}
+	
+	public class SharedDecksAdapter extends BaseAdapter {
+
+		@Override
+		public int getCount() {
+			return mAllSharedDecks.size();
+		}
+
+		@Override
+		public Object getItem(int position) {
+			return mAllSharedDecks.get(position);
+		}
+
+		@Override
+		public long getItemId(int position) {
+			return position;
+		}
+		
+		@Override
+		public boolean isEnabled(int position) {
+			return !(mAllSharedDecks.get(position) instanceof Download);
+		}
+		
+		@Override
+		public View getView(int position, View convertView, ViewGroup parent) {
+			View row = convertView;
+			ViewWrapper wrapper = null;
+			
+			if(row == null)
+			{
+				row = getLayoutInflater().inflate(R.layout.download_deck_item, null);
+				wrapper = new ViewWrapper(row);
+				row.setTag(wrapper);
+			}
+			else
+			{
+				wrapper = (ViewWrapper)row.getTag();
+			}
+			
+			TextView headerTitle = wrapper.getHeaderTitle();
+			TextView downloadingSharedDeckTitle = wrapper.getDownloadTitle();
+			ProgressBar progressBar = wrapper.getProgressBar();
+			TextView progressText = wrapper.getProgressBarText();
+			TextView sharedDeckTitle = wrapper.getDeckTitle();
+			TextView sharedDeckFacts = wrapper.getDeckFacts();
+			
+			Object obj = (Object) mAllSharedDecks.get(position);
+			if(obj instanceof Download)
+			{
+				Download download = (Download) obj;
+				
+				sharedDeckTitle.setVisibility(View.GONE);
+				sharedDeckFacts.setVisibility(View.GONE);
+				
+				if(position == 0)
+				{
+					headerTitle.setText("Currently downloading");
+					headerTitle.setVisibility(View.VISIBLE);
+				}
+				else
+				{
+					headerTitle.setVisibility(View.GONE);
+				}
+				downloadingSharedDeckTitle.setText(download.getTitle());
+				downloadingSharedDeckTitle.setVisibility(View.VISIBLE);
+				progressBar.setVisibility(View.VISIBLE);
+				switch(download.getStatus())
+				{
+					case Download.START:
+						progressText.setText("Starting download...");
+						break;
+						
+					case Download.DOWNLOADING:
+						progressText.setText("Downloading...");
+						break;
+						
+					case Download.PAUSED:
+						progressText.setText("Paused");
+						break;
+					
+					case Download.COMPLETE:
+						progressText.setText("Downloaded");
+						break;
+					
+					case SharedDeckDownload.UPDATE:
+						progressText.setText("Updating...");
+						break;
+						
+					default:
+						progressText.setText("Error");
+						break;
+				}
+				progressText.setVisibility(View.VISIBLE);
+			}
+			else
+			{
+				SharedDeck sharedDeck = (SharedDeck) obj;
+				if(position > 0 && (mAllSharedDecks.get(position - 1) instanceof Download))
+				{
+					headerTitle.setText("Shared Decks");
+					headerTitle.setVisibility(View.VISIBLE);
+				}
+				else
+				{
+					headerTitle.setVisibility(View.GONE);
+				}
+				downloadingSharedDeckTitle.setVisibility(View.GONE);
+				progressBar.setVisibility(View.GONE);
+				progressText.setVisibility(View.GONE);
+				
+				sharedDeckTitle.setText(sharedDeck.getTitle());
+				sharedDeckTitle.setVisibility(View.VISIBLE);
+				sharedDeckFacts.setText(sharedDeck.getFacts() + " facts");
+				sharedDeckFacts.setVisibility(View.VISIBLE);
+			}
+			
+			return row;
+		}
+		
+	}
 }
diff --git a/src/com/ichi2/anki/SharedDownloadManager.java b/src/com/ichi2/anki/SharedDownloadManager.java
new file mode 100644
index 000000000000..dc93f590a3cb
--- /dev/null
+++ b/src/com/ichi2/anki/SharedDownloadManager.java
@@ -0,0 +1,482 @@
+package com.ichi2.anki;
+
+import java.io.File;
+import java.io.FileFilter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.RandomAccessFile;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.database.CursorIndexOutOfBoundsException;
+import android.database.SQLException;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.util.Log;
+
+import com.ichi2.async.Connection;
+import com.ichi2.async.Connection.Payload;
+
+public class SharedDownloadManager {
+
+	private static final String TAG = "AnkiDroid";
+	
+	private static final String ANKI_URL = "http://anki.ichi2.net";
+	private static final String SYNC_URL = ANKI_URL + "/sync/";
+	// Max size of download buffer.
+	private static final int MAX_BUFFER_SIZE = 1024;
+
+	static SharedDownloadManager mSharedInstance;
+	
+	private Context mContext;
+	private static String mUsername;
+	private static String mPassword;
+	private static String mDestination;
+	
+	private ArrayList<Download> mDownloads;
+	
+	private ArrayList<DownloadsListener> mListeners;
+	
+	private int mNotificationCounter = 0;
+	
+	public synchronized static SharedDownloadManager getSharedInstance(Context context, String username, String password, String destination)
+	{
+		if (mSharedInstance == null || !username.equalsIgnoreCase(mUsername) || !password.equalsIgnoreCase(mPassword) || !destination.equalsIgnoreCase(destination))
+		{
+			mSharedInstance = new SharedDownloadManager(context, username, password, destination);
+		}
+		return mSharedInstance;
+	}
+
+	public SharedDownloadManager(Context context, String username, String password, String destination)
+	{
+		mContext = context;
+		mUsername = username;
+		mPassword = password;
+		mDestination = destination;
+		mDownloads = new ArrayList<Download>();
+		mListeners = new ArrayList<DownloadsListener>();
+		
+		addIncompleteDownloads();
+		//resumeDownloads();
+	}
+
+	private void addIncompleteDownloads() 
+	{
+		Log.i(TAG, "Adding incomplete downloads:");
+		File[] fileList;
+		File dir = new File(mDestination);
+		fileList = dir.listFiles(new IncompleteDownloadsFilter());
+		
+		for(int i = 0; i < fileList.length; i++)
+		{
+			File file = fileList[i];
+			
+			//Personal decks
+			String filename = file.getName();
+			if(filename.endsWith(".shared.anki.tmp"))
+			{
+				// FIXME: Maybe the identifier does not have only one character... fix that!
+				String identifier = filename.substring(filename.length() - ".shared.anki.tmp".length() - 1, filename.length() - ".shared.anki.tmp".length());
+				mDownloads.add(new Download(filename.substring(0, filename.length() - ".shared.anki.tmp".length()), file.length()));
+				Log.i(TAG, "Incomplete download of deck = " + mDownloads.get(mDownloads.size() - 1).getTitle() + ", identifier = " + identifier + " downloaded = " +  mDownloads.get(mDownloads.size() - 1).getSize() + "B");
+			}
+		}
+		
+		notifyObservers();
+	}
+	
+	public void resumeDownloads()
+	{
+		for(int i = 0; i < mDownloads.size(); i++)
+		{
+			resumeDownload(mDownloads.get(i));
+		}
+	}
+	
+	public List<Download> getDownloadsList()
+	{
+		return mDownloads;
+	}
+	
+	
+	public void downloadFile(Download download)
+	{
+		mDownloads.add(download);
+		resumeDownload(download);
+	}
+	
+	public void resumeDownload(Download download)
+	{
+		new DownloadFilesTask().execute(download);
+	}
+	
+	private class DownloadFilesTask extends AsyncTask<Download, Object, Download> {
+		
+		protected Download doInBackground(Download... downloads) 
+		{
+			SharedDeckDownload download = (SharedDeckDownload) downloads[0];
+			
+			URL url;
+			RandomAccessFile file = null;
+			InputStream is = null;
+
+			try {
+				url = new URL(ANKI_URL + "/file/get?id=" + download.getId());
+				HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+
+				connection.setDoInput(true);
+				connection.setDoOutput(true);
+				connection.setUseCaches(false);
+				connection.setRequestMethod("GET");
+				connection.setRequestProperty("Range","bytes=" + download.getDownloaded() + "-");
+				connection.setRequestProperty("Accept-Encoding", "identity");
+				connection.setRequestProperty("Host", "anki.ichi2.net");
+				connection.setRequestProperty("Connection", "close");
+
+				connection.connect();
+
+				// Make sure response code is in the 200 range.
+				if (connection.getResponseCode() / 100 != 2) 
+				{
+					download.setStatus(Download.ERROR);
+					publishProgress();
+				}
+				else
+				{
+					download.setStatus(Download.DOWNLOADING);
+					publishProgress();
+				}
+
+				Log.i(TAG, "Response code = " + connection.getResponseCode());
+
+				// Check for valid content length.
+				Log.i(TAG, "Connection length = " + connection.getContentLength());
+				int contentLength = connection.getContentLength();
+				if (contentLength < 1) 
+				{
+					Log.i(TAG, "Content Length = -1");
+					//download.setStatus(Download.ERROR);
+				}
+
+				// Set the size for this download if it hasn't been already set
+				if (download.getSize() == -1 && contentLength != -1) 
+				{
+					download.setSize(contentLength);
+					Log.i(TAG, "File size = " + contentLength);
+					// TODO: NOTIFY???
+				}
+				
+				// Open file and seek to the end of it.
+				file = new RandomAccessFile(mDestination + "/" + download.getTitle() + "." + download.getId() +".shared.zip.tmp", "rw");
+				file.seek(download.getDownloaded());
+				
+				is = connection.getInputStream();
+				
+				if(download.getFilename().endsWith(".zip"))
+				{
+					while(download.getStatus() == Download.DOWNLOADING)
+					{
+						byte buffer[];
+						//if (size - downloaded > MAX_BUFFER_SIZE) {
+						buffer = new byte[MAX_BUFFER_SIZE];
+						//} else {
+						//    buffer = new byte[size - downloaded];
+						//}
+						
+						// Read from server into buffer.
+						int read = is.read(buffer);
+						if (read == -1)
+						{
+							break;
+						}
+						
+						// Write buffer to file.
+						file.write(buffer, 0, read);
+						download.setDownloaded(download.getDownloaded() + read);
+					}
+				}
+				
+				// Change status to complete if this point was reached because downloading has finished
+				
+				if (download.getStatus() == Download.DOWNLOADING) 
+				{
+					download.setStatus(Download.COMPLETE);
+					new File(mDestination + "/" + download.getTitle() + "." + download.getId() +".shared.zip.tmp").renameTo(new File(mDestination + "/" + download.getTitle() + ".zip"));
+					//TODO: NOTIFY???
+					publishProgress();
+				}
+				
+				
+				Log.i(TAG, "Finished!");
+				connection.disconnect();
+			} catch (Exception e) {
+				e.printStackTrace();
+				Log.i(TAG, "Exception Error = " + e.getMessage());
+				download.setStatus(Download.ERROR);
+				publishProgress();
+			} finally {
+				// Close file.
+				if (file != null) {
+					try {
+						file.close();
+					} catch (Exception e) {}
+				}
+				
+				// Close connection to server.
+				if (is != null) {
+					try {
+						is.close();
+					} catch (Exception e) {}
+				}
+			}
+			
+			return download;
+		}
+		
+		protected void onProgressUpdate(Object... values) 
+		{
+			notifyObservers();
+		}
+
+		protected void onPostExecute(Download download) 
+		{
+			Log.i(TAG, "onPostExecute");
+			SharedDeckDownload sharedDownload = (SharedDeckDownload) download;
+			sharedDownload.setStatus(SharedDeckDownload.UPDATE);
+			notifyObservers();
+			
+			try {
+				// Unzip deck and media
+				unzipSharedDeckFile(mDestination + "/" + download.getTitle() + ".zip", sharedDownload.getTitle());
+				// Update all the cards in the deck
+				new UpdateDeckTask().execute(new Payload(new Object[] {mDestination + "/" + download.getTitle() + ".anki", download}));
+			} catch (IOException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	// It seemed to work better with DeckTask: TRY AGAIN and compare them!
+
+	private class UpdateDeckTask extends AsyncTask<Connection.Payload, Connection.Payload, Connection.Payload> {
+
+		@Override
+		protected void onPreExecute() {
+			super.onPreExecute();
+			// Pass
+		}
+
+		@Override
+		protected Payload doInBackground(Payload... args) {
+			Payload data = doInBackgroundLoadDeck(args);
+			if(data.returnType == AnkiDroid.DECK_LOADED)
+			{
+				HashMap<String,Object> results = (HashMap<String, Object>) data.result;
+				Deck deck = (Deck) results.get("deck");
+				deck.updateAllCards();
+				//results.put("card", deck.getCurrentCard());
+			}
+			else
+			{
+				data.success = false;
+			}
+			return data;
+		}
+		
+		private Payload doInBackgroundLoadDeck(Payload... params)
+		{
+			Payload data = params[0];
+			String deckFilename = (String) data.data[0];
+			Log.i(TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
+
+			Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
+			try
+			{
+				// Open the right deck.
+				Deck deck = Deck.openDeck(deckFilename);
+				// Start by getting the first card and displaying it.
+				Card card = deck.getCard();
+				Log.i(TAG, "Deck loaded!");
+
+				// Set the result
+				data.returnType = AnkiDroid.DECK_LOADED;
+				HashMap<String,Object> results = new HashMap<String,Object>();
+				results.put("deck", deck);
+				results.put("card", card);
+				data.result = results;
+				return data;
+			} catch (SQLException e)
+			{
+				Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
+				data.returnType = AnkiDroid.DECK_NOT_LOADED;
+				return data;
+			} catch (CursorIndexOutOfBoundsException e)
+			{
+				Log.i(TAG, "The deck has no cards = " + e.getMessage());
+				data.returnType = AnkiDroid.DECK_EMPTY;
+				return data;
+			}
+		}
+		
+		@Override
+		protected void onPostExecute(Payload result) {
+			super.onPostExecute(result);
+			if(result.returnType == AnkiDroid.DECK_LOADED)
+			{
+				HashMap<String,Object> results = (HashMap<String, Object>) result.result;
+				Deck deck = (Deck) results.get("deck");
+				// Close the previously opened deck.
+				if (deck != null)
+				{
+					deck.closeDeck();
+				}
+				mDownloads.remove((Download)result.data[1]);
+				notifyObservers();
+				showNotification(deck.deckName);
+			}
+		}
+	}
+	
+	private static final class IncompleteDownloadsFilter implements FileFilter
+	{
+		public boolean accept(File pathname)
+		{
+			if(pathname.isFile() && pathname.getName().endsWith(".shared.anki.tmp"))
+			{
+				return true;
+			}
+			return false;
+		}
+	}
+	
+	
+	
+	private static String unzipSharedDeckFile(String zipFilename, String title) throws IOException
+	{
+		String deckFilename = "";
+		
+		Log.i(TAG, "Unzipping " + zipFilename + "...");
+		InputStream is = null;
+		if(zipFilename.endsWith(".zip"))
+		{
+			ZipFile zipFile = new ZipFile(zipFilename);
+
+			title = title.replace("^", "");
+			title = title.substring(0, java.lang.Math.min(title.length(), 40));
+			
+			if(new File(mDestination + "/" + title + ".anki").exists())
+				title += System.currentTimeMillis();
+			
+			String partialDeckPath = mDestination + "/" + title;
+			deckFilename = partialDeckPath + ".anki";
+			
+			ZipEntry zipEntry = null;
+			Enumeration zipEntries = zipFile.entries();
+			while(zipEntries.hasMoreElements())
+			{
+				zipEntry = (ZipEntry) zipEntries.nextElement();
+				is = zipFile.getInputStream(zipEntry);
+				//Log.i(TAG, "zipEntry = " + zipEntry.getName());
+				
+				if("shared.anki".equalsIgnoreCase(zipEntry.getName()))
+				{
+					Utils.writeToFile(is, deckFilename);
+				}
+				else if(zipEntry.getName().startsWith("shared.media/", 0))
+				{
+					//Log.i(TAG, "Folder created = " + new File(AnkiDroidApp.getStorageDirectory() + title + ".media/").mkdir());
+					//Log.i(TAG, "Destination = " + AnkiDroidApp.getStorageDirectory() + "/" + title + ".media/" + zipEntry.getName().replace("shared.media/", ""));
+					Utils.writeToFile(is, partialDeckPath + ".media/" + zipEntry.getName().replace("shared.media/", ""));
+				}
+			}
+			is.close();
+			
+			// TODO: Finish he workflow of temporal files (when a temporal file is renamed, how...) and see that is consistent in any scenario
+			new File(zipFilename).delete();
+		}
+		
+		Log.i(TAG, "Deck unzipped!");
+		return deckFilename;
+	}
+	
+	public static interface DownloadsListener {
+		
+		public void onStateChanged(List<Download> downloads);
+		
+	}
+	
+	private synchronized void notifyObservers()
+	{
+		Log.i(TAG, "Notifying observers...");
+		for(int i = 0; i < mListeners.size(); i++)
+		{
+			mListeners.get(i).onStateChanged(mDownloads);
+		}
+	}
+	
+	public void registerListener(DownloadsListener listener)
+	{
+		mListeners.add(listener);
+	}
+	
+	public void unregisterListener(DownloadsListener listener)
+	{
+		mListeners.remove(listener);
+	}
+	
+	
+	/**
+	 * Show a notification informing the user when a deck is downloaded
+	 */
+	private void showNotification(String deckTitle) 
+	{
+		NotificationManager mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+
+		// In this sample, we'll use the same text for the ticker and the expanded notification
+		//CharSequence text = getText(R.string.remote_service_started);
+
+		// Set the icon, scrolling text and timestamp
+		Notification notification = new Notification(R.drawable.anki, "Download finished", System.currentTimeMillis());
+
+		Intent loadDeckIntent = new Intent(mContext, StudyOptions.class);
+		loadDeckIntent.putExtra(StudyOptions.OPT_DB, mDestination + "/" + deckTitle + ".anki");
+		loadDeckIntent.setData(Uri.parse(deckTitle));
+		
+		// The PendingIntent to launch our activity if the user selects this notification
+		PendingIntent contentIntent = PendingIntent.getActivity(mContext, 0, loadDeckIntent, 0);
+
+		// Set the info for the views that show in the notification panel.
+		notification.setLatestEventInfo(mContext, deckTitle, "Deck downloaded", contentIntent);
+
+		// Clear the notification when the user selects it
+		notification.flags |= Notification.FLAG_AUTO_CANCEL;
+		
+		// Vibrate
+		notification.defaults |= Notification.DEFAULT_VIBRATE;
+		
+		// Show a blue light
+		notification.ledARGB = 0xff0000ff;
+		notification.ledOnMS = 500;
+		notification.ledOffMS = 1000;
+		notification.flags |= Notification.FLAG_SHOW_LIGHTS;
+		
+		//notification.number = 1;
+		
+		// Send the notification.
+		mNotificationManager.notify(mNotificationCounter++, notification);
+	}
+
+}
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 20dd59a11700..3dafedecb806 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -22,7 +22,6 @@
 import android.view.SubMenu;
 import android.view.View;
 import android.view.Window;
-import android.view.WindowManager;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.Spinner;
@@ -117,10 +116,6 @@ public class StudyOptions extends Activity
 	
 	//private boolean deckSelected;
 	
-	
-	private boolean notificationBar;
-	
-	
 	private boolean inDeckPicker;
 	
 	private String deckFilename;
@@ -285,18 +280,18 @@ protected void onCreate(Bundle savedInstanceState)
 		SharedPreferences preferences = restorePreferences();
 		registerExternalStorageListener();
 		
-		
-		// Remove the status bar and make title bar progress available
-		if (notificationBar==false) {
-		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-		}
-		
 		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
 		
 		initAllContentViews();
 		initAllAlertDialogs();
 		
-		if (savedInstanceState != null)
+		Bundle extras = getIntent().getExtras();
+		if (extras != null && extras.getString(OPT_DB) != null)
+		{
+			deckFilename = extras.getString(OPT_DB);
+			Log.i(TAG, "onCreate - deckFilename from extras: " + deckFilename);
+		}
+		else if(savedInstanceState != null)
 		{
 			// Use the same deck as last time Ankidroid was used.
 			deckFilename = savedInstanceState.getString("deckFilename");
@@ -432,11 +427,11 @@ private void initAllContentViews()
 		
 		
 		// First setup for ProgressDialog
-		progressDialog = new ProgressDialog(StudyOptions.this);
-		progressDialog.setCancelable(true);
-		progressDialog.setMax(100);
-		progressDialog.setProgress(0);
-		progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
+		//progressDialog = new ProgressDialog(StudyOptions.this);
+		//progressDialog.setCancelable(true);
+		//progressDialog.setMax(100);
+		//progressDialog.setProgress(0);
+		//progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
 		
 	}
 	
@@ -792,9 +787,6 @@ private SharedPreferences restorePreferences()
 		prefDeckPath = preferences.getString("deckPath", "/sdcard");
 		prefStudyOptions = preferences.getBoolean("study_options", true);
 		
-		notificationBar = preferences.getBoolean("notificationBar", false);
-		
-		
 		return preferences;
 	}
 	
@@ -937,11 +929,10 @@ public void onPostExecute(Payload data) {
 
 		@Override
 		public void onPreExecute() {
-			
-			// progressDialog = ProgressDialog.show(StudyOptions.this, "", getResources().getString(R.string.loading_shared_decks));
-			progressDialog.setTitle("Downloading shared deck");
-			progressDialog.setMessage("Starting");
-			progressDialog.show();
+			progressDialog = ProgressDialog.show(StudyOptions.this, "", getResources().getString(R.string.loading_shared_decks));
+			//progressDialog.setTitle("Downloading shared deck");
+			//progressDialog.setMessage("Starting");
+			//progressDialog.show();
 			
 		}
 
@@ -986,19 +977,18 @@ public void onPostExecute(Payload data) {
 
 		@Override
 		public void onPreExecute() {
-			
-			// progressDialog = ProgressDialog.show(StudyOptions.this, "", getResources().getString(R.string.loading_shared_decks));
-			progressDialog.setTitle("Synchronizing");
-			progressDialog.setMessage("Starting");
-			progressDialog.show();
+			progressDialog = ProgressDialog.show(StudyOptions.this, "", getResources().getString(R.string.loading_shared_decks));
+			//progressDialog.setTitle("Synchronizing");
+			//progressDialog.setMessage("Starting");
+			//progressDialog.show();
 			
 		}
 
 		@Override
 		public void onProgressUpdate(Object... values) {
-			
-			progressDialog.setProgress(((Integer) values[0]));
-			progressDialog.setMessage(((String) values[1]));
+			// Pass
+			//progressDialog.setProgress(((Integer) values[0]));
+			//progressDialog.setMessage(((String) values[1]));
 			
 		}
 		
diff --git a/src/com/ichi2/anki/Utils.java b/src/com/ichi2/anki/Utils.java
index 7ff594ee388d..282d4d93f33c 100644
--- a/src/com/ichi2/anki/Utils.java
+++ b/src/com/ichi2/anki/Utils.java
@@ -39,10 +39,10 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import com.mindprod.common11.BigDate;
-
 import android.util.Log;
 
+import com.mindprod.common11.BigDate;
+
 /**
  * TODO comments
  */
@@ -257,6 +257,7 @@ public static boolean writeToFile(InputStream source, String destination)
 	{
 		try
 		{
+			Log.i(TAG, "Creating new file... = " + destination);
 			new File(destination).createNewFile();
 	
 			OutputStream output = new FileOutputStream(destination);
@@ -268,8 +269,10 @@ public static boolean writeToFile(InputStream source, String destination)
 			while ((len = source.read(buf)) > 0)
 			{
 				output.write(buf, 0, len);
+				Log.i(TAG, "Write...");
 			}
 			
+			Log.i(TAG, "Finished writing!");
 			output.close();
 
 		} catch (Exception e) {
diff --git a/src/com/ichi2/anki/Whiteboard.java b/src/com/ichi2/anki/Whiteboard.java
index 44035e6e14b2..e18b02420ac3 100644
--- a/src/com/ichi2/anki/Whiteboard.java
+++ b/src/com/ichi2/anki/Whiteboard.java
@@ -17,20 +17,19 @@
 ****************************************************************************************/
 package com.ichi2.anki;
 
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.Path;
 import android.util.AttributeSet;
-import android.util.Log;
 import android.view.Display;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.WindowManager;
 
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
 /**
  * Whiteboard allowing the user to draw the card's answer on the touchscreen.
  * TODO Javadoc
diff --git a/src/com/ichi2/async/Connection.java b/src/com/ichi2/async/Connection.java
index c2b289b5fc39..694cae6d86ed 100644
--- a/src/com/ichi2/async/Connection.java
+++ b/src/com/ichi2/async/Connection.java
@@ -83,7 +83,10 @@ private static Connection launchConnectionTask(TaskListener listener, Payload da
      */
     protected void onPreExecute() 
     {
-    	listener.onPreExecute();
+    	if(listener != null)
+    	{
+    		listener.onPreExecute();
+    	}
     }
 
     /*
@@ -91,7 +94,10 @@ protected void onPreExecute()
      */
     public void onPostExecute(Payload data)
     {
-    	listener.onPostExecute(data);
+    	if(listener != null)
+    	{
+    		listener.onPostExecute(data);
+    	}
     }
 
     /*
@@ -99,7 +105,10 @@ public void onPostExecute(Payload data)
      */
     public void onProgressUpdate(Object... values)
     {
-    	listener.onProgressUpdate(values);
+    	if(listener != null)
+    	{
+    		listener.onProgressUpdate(values);
+    	}
     }
     
     public static Connection login(TaskListener listener, Payload data)
@@ -126,11 +135,20 @@ public static Connection getPersonalDecks(TaskListener listener, Payload data)
 		return launchConnectionTask(listener, data);
 	}
 	
+	/*
 	public static Connection downloadPersonalDeck(TaskListener listener, Payload data)
 	{
 		data.taskType = TASK_TYPE_DOWNLOAD_PERSONAL_DECK;
 		return launchConnectionTask(listener, data);
 	}
+	*/
+	
+	public void downloadPersonalDeck(TaskListener listener, Payload data)
+	{
+		data.taskType = TASK_TYPE_DOWNLOAD_PERSONAL_DECK;
+		this.listener = listener;
+		execute(data);
+	}
 	
 	public static Connection syncDeck(TaskListener listener, Payload data)
 	{
@@ -190,7 +208,7 @@ private Payload doInBackgroundLogin(Payload data)
 			if(status != AnkiDroidProxy.LOGIN_OK)
 			{
 				data.success = false;
-				data.errorType = status;
+				data.returnType = status;
 			}
 		} catch (Exception e) {
 			data.success = false;
@@ -449,7 +467,7 @@ public static class Payload
         public Object[] data;
         public Object result;
         public boolean success;
-        public int errorType;
+        public int returnType;
         public Exception exception;
 
         public Payload(Object[] data) {
diff --git a/src/com/mindprod/common11/StringTools.java b/src/com/mindprod/common11/StringTools.java
index c932dc2ede5d..ce31b6776ca1 100644
--- a/src/com/mindprod/common11/StringTools.java
+++ b/src/com/mindprod/common11/StringTools.java
@@ -33,6 +33,8 @@
 import java.util.BitSet;
 import java.util.Vector;
 
+import android.graphics.Color;
+
 /**
  * Miscellaneous static methods for dealing with Strings in JDK 1.1+.
  * <p/>
diff --git a/src/com/tomgibara/android/veecheck/util/DefaultNotifier.java b/src/com/tomgibara/android/veecheck/util/DefaultNotifier.java
index 1b7a1496996c..38612d7a5eb0 100644
--- a/src/com/tomgibara/android/veecheck/util/DefaultNotifier.java
+++ b/src/com/tomgibara/android/veecheck/util/DefaultNotifier.java
@@ -19,9 +19,6 @@
 
 import java.util.Map;
 
-import com.tomgibara.android.veecheck.VeecheckActivity;
-import com.tomgibara.android.veecheck.VeecheckNotifier;
-
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.content.Context;
@@ -29,6 +26,9 @@
 import android.content.IntentFilter;
 import android.net.Uri;
 
+import com.tomgibara.android.veecheck.VeecheckActivity;
+import com.tomgibara.android.veecheck.VeecheckNotifier;
+
 /**
  * An implementation of {@link VeecheckNotifier} that directs a user to a
  * {@link VeecheckActivity}.
