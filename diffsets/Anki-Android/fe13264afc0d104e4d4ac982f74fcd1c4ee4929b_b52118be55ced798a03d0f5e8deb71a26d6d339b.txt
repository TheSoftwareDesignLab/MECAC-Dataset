diff --git a/src/com/ichi2/anki/MetaDB.java b/src/com/ichi2/anki/MetaDB.java
index fb6235299e4b..3d517eb4d66b 100644
--- a/src/com/ichi2/anki/MetaDB.java
+++ b/src/com/ichi2/anki/MetaDB.java
@@ -31,7 +31,7 @@ public class MetaDB {
     private static final String DATABASE_NAME = "ankidroid.db";
 
     /** The Database Version, increase if you want updates to happen on next upgrade. */
-    private static final int DATABASE_VERSION = 1;
+    private static final int DATABASE_VERSION = 2;
 
     // Possible values for the qa column of the languages table.
     /** The language refers to the question. */
@@ -85,6 +85,8 @@ private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVers
                 + "deckpath TEXT NOT NULL, " + "dictionary INTEGER)");
         mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS intentInformation (" + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                 + "source TEXT NOT NULL, " + "target INTEGER NOT NULL)");
+        mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS smallWidgetStatus (" + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
+                + "progress INTEGER NOT NULL, left INTEGER NOT NULL, eta INTEGER NOT NULL)");
         // Use pragma to get info about widgetStatus.
         Cursor c = mMetaDb.rawQuery("PRAGMA table_info(widgetStatus)", null);
         int columnNumber = c.getCount();
@@ -135,6 +137,8 @@ public static boolean resetDB(Context context) {
             Log.i(AnkiDroidApp.TAG, "Resetting custom Dictionary");
             mMetaDb.execSQL("DROP TABLE IF EXISTS widgetStatus;");
             Log.i(AnkiDroidApp.TAG, "Resetting widget status");
+            mMetaDb.execSQL("DROP TABLE IF EXISTS smallWidgetStatus;");
+            Log.i(AnkiDroidApp.TAG, "Resetting small widget status");
             mMetaDb.execSQL("DROP TABLE IF EXISTS intentInformation;");
             Log.i(AnkiDroidApp.TAG, "Resetting intentInformation");
             upgradeDB(mMetaDb, DATABASE_VERSION);
@@ -171,10 +175,11 @@ public static boolean resetWidget(Context context) {
         try {
             Log.i(AnkiDroidApp.TAG, "Resetting widget status");
             mMetaDb.execSQL("DROP TABLE IF EXISTS widgetStatus;");
+            mMetaDb.execSQL("DROP TABLE IF EXISTS smallWidgetStatus;");
             openDB(context);
             return true;
         } catch (Exception e) {
-            Log.e("Error", "Error resetting widgetStatus ", e);
+            Log.e("Error", "Error resetting widgetStatus and smallWidgetStatus", e);
         }
         return false;
     }
@@ -438,20 +443,10 @@ public static DeckStatus[] getWidgetStatus(Context context) {
     public static int[] getWidgetSmallStatus(Context context) {
         openDBIfClosed(context);
         Cursor cursor = null;
-        int due = 0;
-        int progress = 0;
-        int eta = 0;
-        boolean noDeck = true;
         try {
-            cursor = mMetaDb.query("widgetStatus", new String[] { "deckName", "newCards", "lrnCards", "dueCards",
-                    "progress", "eta" }, null, null, null, null, null);
+            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "progress", "left", "eta" }, null, null, null, null, null);
             while (cursor.moveToNext()) {
-                noDeck = false;
-                if (cursor.getString(0).split("::").length == 1) {
-                    due += cursor.getInt(1) + cursor.getInt(2) + cursor.getInt(3);
-                    progress = cursor.getInt(4);
-                    eta = cursor.getInt(5);
-                }
+            	return (new int[]{ cursor.getInt(0), cursor.getInt(1), cursor.getInt(2)});
             }
         } catch (SQLiteException e) {
             Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
@@ -460,7 +455,7 @@ public static int[] getWidgetSmallStatus(Context context) {
                 cursor.close();
             }
         }
-        return new int[] { noDeck ? -1 : due, progress, eta };
+        return null;
     }
 
 
@@ -485,6 +480,28 @@ public static int getNotificationStatus(Context context) {
     }
 
 
+    public static void storeSmallWidgetStatus(Context context, float[] progress) {
+        openDBIfClosed(context);
+        try {
+            mMetaDb.beginTransaction();
+            try {
+                // First clear all the existing content.
+                mMetaDb.execSQL("DELETE FROM smallWidgetStatus");
+                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(progress, left, eta) VALUES (?, ?, ?)", new Object[] {(int)(progress[1] * 1000), (int)progress[2], (int)progress[3]});
+                mMetaDb.setTransactionSuccessful();
+            } finally {
+                mMetaDb.endTransaction();
+            }
+        } catch (IllegalStateException e) {
+            Log.e(AnkiDroidApp.TAG, "MetaDB.storeSmallWidgetStatus: failed", e);
+        } catch (SQLiteException e) {
+            Log.e(AnkiDroidApp.TAG, "MetaDB.storeSmallWidgetStatus: failed", e);
+            closeDB();
+            Log.i(AnkiDroidApp.TAG, "Trying to reset Widget: " + resetWidget(context));
+        }
+    }
+
+
     /**
      * Stores the current state of the widget.
      * <p>
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 610cabe3916e..ad89ecbede8a 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -93,6 +93,7 @@
 import com.ichi2.themes.Themes;
 import com.ichi2.utils.DiffEngine;
 import com.ichi2.utils.RubyParser;
+import com.ichi2.widget.DeckStatus;
 import com.ichi2.widget.WidgetStatus;
 
 import org.amr.arabic.ArabicUtilities;
@@ -1138,10 +1139,9 @@ protected void onStop() {
         // }
 
         if (!isFinishing()) {
-            int[] counts = mSched.counts(mCurrentCard);
             // try {
-            WidgetStatus.update(this);// , new DeckStatus(mSched.getCol().getDecks().current().getLong("id"), -1, "",
-                                      // counts[0], counts[1], counts[2], -1, -1));
+            WidgetStatus.update(this, mSched.progressToday(null, mCurrentCard, true));
+            
             // } catch (JSONException e) {
             // throw new RuntimeException(e);
             // }
@@ -2364,10 +2364,11 @@ private void updateStatisticBars() {
             mStatisticBarsMax = view.getWidth();
             mStatisticBarsHeight = view.getHeight();
         }
+        float[] progress = mSched.progressToday(null, mCurrentCard, false);
         Utils.updateProgressBars(mSessionProgressBar,
-                (int) (mStatisticBarsMax * mSched.todaysProgress(mCurrentCard, false, false)), mStatisticBarsHeight);
+                (int) (mStatisticBarsMax * progress[0]), mStatisticBarsHeight);
         Utils.updateProgressBars(mSessionProgressTotalBar,
-                (int) (mStatisticBarsMax * mSched.todaysProgress(mCurrentCard, true, false)), mStatisticBarsHeight);
+                (int) (mStatisticBarsMax * progress[1]), mStatisticBarsHeight);
     }
 
     /*
diff --git a/src/com/ichi2/anki/StudyOptionsFragment.java b/src/com/ichi2/anki/StudyOptionsFragment.java
index 89c82af04db3..b4a1957c5bd5 100644
--- a/src/com/ichi2/anki/StudyOptionsFragment.java
+++ b/src/com/ichi2/anki/StudyOptionsFragment.java
@@ -975,6 +975,9 @@ private SharedPreferences restorePreferences() {
     DeckTask.TaskListener mUpdateValuesFromDeckListener = new DeckTask.TaskListener() {
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
+        	if (result == null) {
+        		return;
+        	}
             Object[] obj = result.getObjArray();
             int newCards = (Integer) obj[0];
             int lrnCards = (Integer) obj[1];
diff --git a/src/com/ichi2/async/DeckTask.java b/src/com/ichi2/async/DeckTask.java
index a55b0aae06b1..2f6eaabfb825 100644
--- a/src/com/ichi2/async/DeckTask.java
+++ b/src/com/ichi2/async/DeckTask.java
@@ -721,21 +721,26 @@ private TaskData doInBackgroundCloseCollection(TaskData... params) {
 
 	private TaskData doInBackgroundUpdateValuesFromDeck(TaskData... params) {
 		Log.i(AnkiDroidApp.TAG, "doInBackgroundUpdateValuesFromDeck");
-		boolean reset = params[0].getBoolean();
-		Sched sched = params[0].getSched();
-		if (reset) {
-			sched.reset();
+		try {
+			boolean reset = params[0].getBoolean();
+			Sched sched = params[0].getSched();
+			if (reset) {
+				sched.reset();
+			}
+			int[] counts = sched.counts();
+			int totalNewCount = sched.newCount();
+			int totalCount = sched.cardCount();
+			double progressMature = ((double) sched.matureCount())
+					/ ((double) totalCount);
+			double progressAll = 1 - (((double) (totalNewCount + counts[1])) / ((double) totalCount));
+			double[][] serieslist = Stats.getSmallDueStats(sched.getCol());
+			return new TaskData(new Object[] { counts[0], counts[1], counts[2],
+					totalNewCount, totalCount, progressMature, progressAll,
+					sched.eta(counts), serieslist });			
+		} catch (RuntimeException e) {
+			Log.e(AnkiDroidApp.TAG, "doInBackgroundUpdateValuesFromDeck - an error occurred: " + e);
+			return null;
 		}
-		int[] counts = sched.counts();
-		int totalNewCount = sched.newCount();
-		int totalCount = sched.cardCount();
-		double progressMature = ((double) sched.matureCount())
-				/ ((double) totalCount);
-		double progressAll = 1 - (((double) (totalNewCount + counts[1])) / ((double) totalCount));
-		double[][] serieslist = Stats.getSmallDueStats(sched.getCol());
-		return new TaskData(new Object[] { counts[0], counts[1], counts[2],
-				totalNewCount, totalCount, progressMature, progressAll,
-				sched.eta(counts), serieslist });
 	}
 
 	private TaskData doInBackgroundRestoreIfMissing(TaskData... params) {
diff --git a/src/com/ichi2/libanki/Decks.java b/src/com/ichi2/libanki/Decks.java
index 5dee627f39ff..b1f76af62f9c 100644
--- a/src/com/ichi2/libanki/Decks.java
+++ b/src/com/ichi2/libanki/Decks.java
@@ -669,9 +669,6 @@ public void select(long did) {
             }
             mCol.getConf().put("activeDecks", ja);
             mChanged = true;
-
-            // reset total progress count (not in libanki)
-            mCol.getSched().resetTotalProgress();
         } catch (JSONException e) {
             throw new RuntimeException(e);
         }
diff --git a/src/com/ichi2/libanki/Sched.java b/src/com/ichi2/libanki/Sched.java
index 1bc0534ba10d..1ab6599f8f68 100644
--- a/src/com/ichi2/libanki/Sched.java
+++ b/src/com/ichi2/libanki/Sched.java
@@ -129,9 +129,8 @@ public class Sched {
     private TreeMap<Integer, Integer> mGroupConfs;
     private TreeMap<Integer, JSONObject> mConfCache;
 
-    /** all due cards which are not in the current deck selection */
-    private int mNonselectedDues;
-
+    private HashMap<Long, Pair<Integer, int[]>> mNonSelectedDecksProgress;
+    private boolean mNonSelectedDecksCleared = false;
 
     /**
      * queue types: 0=new/cram, 1=lrn, 2=rev, 3=day lrn, -1=suspended, -2=buried revlog types: 0=lrn, 1=rev, 2=relrn,
@@ -380,67 +379,6 @@ private void extendLimits(int newc, int rev) {
     }
 
 
-    /** LIBANKI: not in libanki */
-    public int eta(int[] counts) {
-        return eta(counts, true);
-    }
-
-
-    public int eta(int[] counts, boolean reload) {
-        double revYesRate;
-        double revTime;
-        double lrnYesRate;
-        double lrnTime;
-        if (reload || mEtaCache[0] == -1) {
-            Cursor cur = null;
-            try {
-                cur = mCol
-                        .getDb()
-                        .getDatabase()
-                        .rawQuery(
-                                "SELECT avg(CASE WHEN ease > 1 THEN 1 ELSE 0 END), avg(time) FROM revlog WHERE type = 1 AND id > "
-                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
-                if (!cur.moveToFirst()) {
-                    return -1;
-                }
-                revYesRate = cur.getDouble(0);
-                revTime = cur.getDouble(1);
-                cur = mCol
-                        .getDb()
-                        .getDatabase()
-                        .rawQuery(
-                                "SELECT avg(CASE WHEN ease = 3 THEN 1 ELSE 0 END), avg(time) FROM revlog WHERE type != 1 AND id > "
-                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
-                if (!cur.moveToFirst()) {
-                    return -1;
-                }
-                lrnYesRate = cur.getDouble(0);
-                lrnTime = cur.getDouble(1);
-            } finally {
-                if (cur != null && !cur.isClosed()) {
-                    cur.close();
-                }
-            }
-            mEtaCache[0] = revYesRate;
-            mEtaCache[1] = revTime;
-            mEtaCache[2] = lrnYesRate;
-            mEtaCache[3] = lrnTime;
-        } else {
-            revYesRate = mEtaCache[0];
-            revTime = mEtaCache[1];
-            lrnYesRate = mEtaCache[2];
-            lrnTime = mEtaCache[3];
-        }
-        // rev cards
-        double eta = revTime * counts[2];
-        // lrn cards
-        double factor = Math.min(1 / (1 - lrnYesRate), 10);
-        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
-        eta += lrnAnswers * lrnTime;
-        return (int) (eta / 60000);
-    }
-
-
     private int _walkingCount() {
         return _walkingCount(null, null, null);
     }
@@ -516,10 +454,6 @@ private int _walkingCount(LinkedList<Long> dids, Method limFn, Method cntFn) {
 
     /** LIBANKI: not in libanki */
     public Object[] deckCounts() {
-        // check if new day has rolled over and reset counts if yes
-        // if (Utils.now() > mDayCutoff) {
-        // _updateCutoff();
-        // }
         TreeSet<Object[]> decks = deckDueTree(0);
         int[] counts = new int[] { 0, 0, 0 };
         for (Object[] deck : decks) {
@@ -2320,72 +2254,167 @@ public int matureCount(String dids) {
     }
 
 
-    /** NOT IN LIBANKI */
-    public float todaysProgress(Card card, boolean allDecks, boolean reloadNonselected) {
-        int counts = mNewCount + mLrnCount + mRevCount;
-        if (card != null) {
-            int idx = countIdx(card);
-            if (idx == 1) {
-                counts += card.getLeft();
-            } else {
-                counts += 1;
-            }
-        }
-        try {
-            float done = 0;
-            if (allDecks) {
-                if (reloadNonselected) {
-                    mNonselectedDues = 0;
-                    for (JSONObject g : mCol.getDecks().all()) {
-                        try {
-                            if (!g.getString("name").matches(".*::.*")) {
-                                long did = g.getLong("id");
-                                LinkedList<Long> ldid = new LinkedList<Long>();
-                                ldid.add(did);
-                                for (Long c : mCol.getDecks().children(did).values()) {
-                                    ldid.add(c);
-                                }
-                                String didLimit = Utils.ids2str(ldid);
-                                mNonselectedDues += _walkingCount(ldid,
-                                        Sched.class.getDeclaredMethod("_deckNewLimitSingle", JSONObject.class),
-                                        Sched.class.getDeclaredMethod("_cntFnNew", long.class, int.class));
-                                mNonselectedDues += _cntFnLrn(didLimit);
-                                mNonselectedDues += _walkingCount(ldid,
-                                        Sched.class.getDeclaredMethod("_deckRevLimitSingle", JSONObject.class),
-                                        Sched.class.getDeclaredMethod("_cntFnRev", long.class, int.class));
-                            }
-                        } catch (JSONException e) {
-                            throw new RuntimeException(e);
-                        } catch (NoSuchMethodException e) {
-                            throw new RuntimeException(e);
-                        }
-                    }
-                    mNonselectedDues -= mNewCount + mLrnCount + mRevCount;
-                }
-                counts += mNonselectedDues;
-                for (JSONObject d : mCol.getDecks().all()) {
-                    if (!d.getString("name").matches(".*::.*")) {
-                        done += d.getJSONArray("newToday").getInt(1) + d.getJSONArray("lrnToday").getInt(1)
-                                + d.getJSONArray("revToday").getInt(1);
-                    }
-                }
-            } else {
-                JSONObject c = mCol.getDecks().current();
-                done = c.getJSONArray("newToday").getInt(1) + c.getJSONArray("lrnToday").getInt(1)
-                        + c.getJSONArray("revToday").getInt(1);
-            }
-            return done / (done + counts);
-        } catch (JSONException e) {
-            throw new RuntimeException(e);
-        }
+    /** returns today's progress 
+     * 
+     * @param counts (if empty, cached version will be used if any)
+     * @param card
+     * @return [progressCurrentDeck, progressAllDecks, leftCards, eta]
+     */
+    public float[] progressToday(TreeSet<Object[]> counts, Card card, boolean eta) {
+    	try {
+        	int doneCurrent = 0;
+        	int[] leftCurrent = new int[]{0, 0, 0};
+        	String[] cs = new String[]{"new", "lrn", "rev"};
+        	long currentDid = 0;
+        	long currentParentDid = 0;
+
+        	// refresh deck progresses with fresh counts if necessary
+        	if (counts != null || mNonSelectedDecksProgress == null) {
+        		if (mNonSelectedDecksProgress == null) {
+            		mNonSelectedDecksProgress = new HashMap<Long, Pair<Integer, int[]>>();
+        		}
+        		mNonSelectedDecksProgress.clear();
+        		if (counts == null) {
+        			// reload counts
+        			counts = (TreeSet<Object[]>)deckCounts()[0];
+        		}
+        		int done = 0;
+            	for (Object[] d : counts) {
+            		if (((String[])d[0]).length == 1) {
+            			// top deck
+            			JSONObject deck = mCol.getDecks().get((Long) d[1]);
+                		for (String s : cs) {
+                			done += deck.getJSONArray(s + "Today").getInt(1);
+                		}
+                		mNonSelectedDecksProgress.put((Long)d[1], new Pair<Integer, int[]>(done, new int[]{(Integer)d[2], (Integer)d[3], (Integer)d[4]}));
+            		}
+            	}
+            	mNonSelectedDecksCleared = false;
+        	}
+
+        	// current selected deck
+        	if (card != null) {
+        		JSONObject deck = mCol.getDecks().current();
+        		currentDid = deck.getLong("id");
+        		String[] name = deck.getString("name").split(" ");
+        		if (name.length > 1) {
+        			// is a subdeck, note parent's did
+        			currentParentDid = mCol.getDecks().id(name[0], false);
+        		}
+        		for (String s : cs) {
+        			doneCurrent += deck.getJSONArray(s + "Today").getInt(1);
+        		}
+        		int idx = countIdx(card);
+        		leftCurrent = new int[]{ mNewCount + (idx == 1 ? 0 : 1), mLrnCount + (idx == 1 ? card.getLeft() / 1000 : 0), mRevCount + (idx == 1 ? 0 : 1)};
+        	}
+
+    		// remove current deck from cache if still present
+        	if (!mNonSelectedDecksCleared) {
+        		if (mNonSelectedDecksProgress.containsKey(currentDid)) {
+        			mNonSelectedDecksProgress.remove(currentDid);
+            		mNonSelectedDecksCleared = true;
+        		} else if (mNonSelectedDecksProgress.containsKey(currentParentDid)) {
+        			Pair<Integer, int[]> c = mNonSelectedDecksProgress.get(currentParentDid);
+        			int[] left = c.second;
+        			left[0] -= leftCurrent[0];
+        			left[1] -= leftCurrent[1];
+        			left[2] -= leftCurrent[2];
+        			mNonSelectedDecksProgress.put(currentParentDid, new Pair<Integer, int[]>(c.first - doneCurrent, left));
+            		mNonSelectedDecksCleared = true;
+        		}
+        	}
+
+        	int doneAll = 0;
+        	int[] leftAll = new int[]{0, 0, 0};
+        	for (Pair<Integer, int[]> d : mNonSelectedDecksProgress.values()) {
+        		doneAll += d.first;
+        		leftAll[0] += d.second[0];
+        		leftAll[1] += d.second[1];
+        		leftAll[2] += d.second[2];
+        	}
+        	doneAll += doneCurrent;
+        	leftAll[0] += leftCurrent[0];
+        	leftAll[1] += leftCurrent[1];
+        	leftAll[2] += leftCurrent[2];
+        	int totalAll = doneAll + leftAll[0] + leftAll[1] + leftAll[2];
+        	int totalCurrent = doneCurrent + leftCurrent[0] + leftCurrent[1] + leftCurrent[2];
+
+        	float progressCurrent = -1;
+        	if (totalCurrent != 0) {
+        		progressCurrent = (float) doneCurrent / (float) totalCurrent;
+        	}
+        	float progressTotal = -1;
+        	if (totalAll != 0) {
+        		progressTotal = (float) doneAll / (float) totalAll;
+        	}
+        	return new float[]{ progressCurrent, progressTotal, totalAll - doneAll, eta ? eta(leftAll, false) : -1};
+    	} catch (JSONException e) {
+    		throw new RuntimeException(e);
+    	}
     }
 
 
-    public void resetTotalProgress() {
-        mNonselectedDues = 0;
+    /** LIBANKI: not in libanki */
+    public int eta(int[] counts) {
+        return eta(counts, true);
     }
 
 
+    /** estimates remaining time for learning (based on last seven days) */
+    public int eta(int[] counts, boolean reload) {
+        double revYesRate;
+        double revTime;
+        double lrnYesRate;
+        double lrnTime;
+        if (reload || mEtaCache[0] == -1) {
+            Cursor cur = null;
+            try {
+                cur = mCol
+                        .getDb()
+                        .getDatabase()
+                        .rawQuery(
+                                "SELECT avg(CASE WHEN ease > 1 THEN 1 ELSE 0 END), avg(time) FROM revlog WHERE type = 1 AND id > "
+                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
+                if (!cur.moveToFirst()) {
+                    return -1;
+                }
+                revYesRate = cur.getDouble(0);
+                revTime = cur.getDouble(1);
+                cur = mCol
+                        .getDb()
+                        .getDatabase()
+                        .rawQuery(
+                                "SELECT avg(CASE WHEN ease = 3 THEN 1 ELSE 0 END), avg(time) FROM revlog WHERE type != 1 AND id > "
+                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
+                if (!cur.moveToFirst()) {
+                    return -1;
+                }
+                lrnYesRate = cur.getDouble(0);
+                lrnTime = cur.getDouble(1);
+            } finally {
+                if (cur != null && !cur.isClosed()) {
+                    cur.close();
+                }
+            }
+            mEtaCache[0] = revYesRate;
+            mEtaCache[1] = revTime;
+            mEtaCache[2] = lrnYesRate;
+            mEtaCache[3] = lrnTime;
+        } else {
+            revYesRate = mEtaCache[0];
+            revTime = mEtaCache[1];
+            lrnYesRate = mEtaCache[2];
+            lrnTime = mEtaCache[3];
+        }
+        // rev cards
+        double eta = revTime * counts[2];
+        // lrn cards
+        double factor = Math.min(1 / (1 - lrnYesRate), 10);
+        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
+        eta += lrnAnswers * lrnTime;
+        return (int) (eta / 60000);
+    }
+
     //
     // /**
     // * Time spent learning today, in seconds.
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
index 6b7b0f858907..4c8fdc755ff5 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -1,1136 +1,1136 @@
-/***************************************************************************************
- * This program is free software; you can redistribute it and/or modify it under        *
- * the terms of the GNU General Public License as published by the Free Software        *
- * Foundation; either version 3 of the License, or (at your option) any later           *
- * version.                                                                             *
- *                                                                                      *
- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
- *                                                                                      *
- * You should have received a copy of the GNU General Public License along with         *
- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
- ****************************************************************************************/
-
-package com.ichi2.widget;
-
-import org.json.JSONException;
-
-import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.anki.DeckPicker;
-import com.ichi2.anki2.R;
-import com.ichi2.async.DeckTask;
-import com.ichi2.libanki.Card;
-import com.ichi2.libanki.Utils;
-
-import android.app.PendingIntent;
-import android.app.Service;
-import android.appwidget.AppWidgetManager;
-import android.appwidget.AppWidgetProvider;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.content.SharedPreferences;
-import android.content.res.Resources;
-import android.graphics.Color;
-import android.os.AsyncTask;
-import android.os.IBinder;
-import android.text.Html;
-import android.text.SpannableString;
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.text.style.ForegroundColorSpan;
-import android.text.style.UnderlineSpan;
-import android.util.Log;
-import android.view.View;
-import android.widget.RemoteViews;
-
-public class AnkiDroidWidgetBig extends AppWidgetProvider {
-
-    private static Context sContext;
-
-    private static WidgetContentService contentService = null;
-    private static WidgetContentService.WidgetContentBinder contentServiceBinder;
-    private static Intent tempIntent;
-
-    private static ServiceConnection localServiceConnection = new ServiceConnection() {
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder binder) {
-            Log.i(AnkiDroidApp.TAG, "binding content service - success");
-            contentServiceBinder = (WidgetContentService.WidgetContentBinder) binder;
-            contentService = contentServiceBinder.getService();
-            // check, if card is still the same after reloading the deck. If not, show question instead of answering
-            if (tempIntent.getAction().startsWith(UpdateService.ACTION_ANSWER)
-                    && contentService.mCurrentCard != null
-                    && AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getLong(
-                            "lastWidgetCard", 0) != contentService.mCurrentCard.getId()) {
-                tempIntent.setAction(UpdateService.ACTION_UPDATE);
-                tempIntent.putExtra(UpdateService.EXTRA_VIEW, UpdateService.VIEW_SHOW_QUESTION);
-            }
-            sContext.startService(tempIntent);
-            tempIntent = null;
-        }
-
-
-        @Override
-        public void onServiceDisconnected(ComponentName arg0) {
-            contentService = null;
-        }
-    };
-
-
-    @Override
-    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        Log.i(AnkiDroidApp.TAG, "BigWidget: onUpdate");
-        WidgetStatus.update(context);
-    }
-
-
-    @Override
-    public void onEnabled(Context context) {
-        super.onEnabled(context);
-        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget enabled");
-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-        if (!preferences.getBoolean("widgetBigEnabled", false)) {
-            // show info dialog
-            Intent intent;
-            intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-            intent.setAction(UpdateService.ACTION_SHOW_RESTRICTIONS_DIALOG);
-            context.startService(intent);
-        }
-        preferences.edit().putBoolean("widgetBigEnabled", true).commit();
-        if (contentService != null) {
-            contentService.mBigCurrentView = UpdateService.VIEW_NOT_SPECIFIED;
-            contentService.mCol = null;
-            AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-                    .putString("lastWidgetDeck", "").commit();
-            contentService.setCard(null);
-            contentService.mBigCurrentMessage = null;
-            contentService.mBigShowProgressDialog = false;
-            contentService.mTomorrowDues = null;
-            contentService.mWaitForAsyncTask = false;
-        }
-    }
-
-
-    @Override
-    public void onDisabled(Context context) {
-        super.onDisabled(context);
-        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget disabled");
-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-        preferences.edit().putBoolean("widgetBigEnabled", false).commit();
-    }
-
-
-    // public static void setDeck(Decks deck) {
-    // if (contentService != null) {
-    // contentService.mCol = deck;
-    // }
-    // updateWidget(UpdateService.VIEW_NOT_SPECIFIED);
-    // }
-
-    public static void setCard(Card card) {
-        if (contentService != null && contentService.mCol != null) {
-            contentService.setCard(card);
-        }
-    }
-
-
-    public static Card getCard() {
-        if (contentService != null) {
-            return contentService.mCurrentCard;
-        } else {
-            return null;
-        }
-    }
-
-
-    public static void updateWidget(int view) {
-        updateWidget(view, false);
-    }
-
-
-    public static void updateWidget(int view, boolean showProgressDialog) {
-        AnkiDroidApp
-                .getInstance()
-                .getApplicationContext()
-                .startService(
-                        getUpdateIntent(AnkiDroidApp.getInstance().getApplicationContext(), view, showProgressDialog));
-    }
-
-
-    public static Intent getUpdateIntent(Context context, int view, boolean showProgressDialog) {
-        Intent intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-        intent.putExtra(UpdateService.EXTRA_VIEW, view);
-        intent.putExtra(UpdateService.EXTRA_PROGRESSDIALOG, showProgressDialog);
-        return intent.setAction(UpdateService.ACTION_UPDATE);
-    }
-
-    public static class UpdateService extends Service {
-        public static final String ACTION_NOTHING = "org.ichi2.anki.AnkiDroidWidgetBig.NOTHING";
-        public static final String ACTION_OPENDECK = "org.ichi2.anki.AnkiDroidWidgetBig.OPENDECK";
-        public static final String ACTION_OPENCOLLECTION = "org.ichi2.anki.AnkiDroidWidgetBig.OPENCOLLECTION";
-        public static final String ACTION_CLOSEDECK = "org.ichi2.anki.AnkiDroidWidgetBig.CLOSEDECK";
-        public static final String ACTION_ANSWER = "org.ichi2.anki.AnkiDroidWidgetBig.ANSWER";
-        public static final String ACTION_OPEN = "org.ichi2.anki.AnkiDroidWidgetBig.OPEN";
-        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidgetBig.UPDATE";
-        public static final String ACTION_BURY_CARD = "org.ichi2.anki.AnkiDroidWidgetBig.BURYCARD";
-        public static final String ACTION_UNDO = "org.ichi2.anki.AnkiDroidWidgetBig.UNDO";
-        public static final String ACTION_CARDEDITOR = "org.ichi2.anki.AnkiDroidWidgetBig.CARDEDITOR";
-        public static final String ACTION_FACTADDER = "org.ichi2.anki.AnkiDroidWidgetBig.FACTADDER";
-        public static final String ACTION_HELP = "org.ichi2.anki.AnkiDroidWidgetBig.HELP";
-        public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
-        public static final String ACTION_LEARN_MORE = "org.ichi2.anki.AnkiDroidWidgetBig.LEARNMORE";
-        public static final String ACTION_REVIEW_EARLY = "org.ichi2.anki.AnkiDroidWidgetBig.REVIEWEARLY";
-        public static final String ACTION_SHOW_TOMORROW_DUES = "org.ichi2.anki.AnkiDroidWidgetBig.TOMORROWDUES";
-
-        public static final String EXTRA_EASE = "ease";
-        public static final String EXTRA_VIEW = "view";
-        public static final String EXTRA_PROGRESSDIALOG = "progressDialog";
-
-        public static final int VIEW_ACTION_DEFAULT = 0;
-        public static final int VIEW_ACTION_SHOW_PROGRESS_DIALOG = 1;
-        public static final int VIEW_ACTION_HIDE_BUTTONS = 2;
-
-        public static final int VIEW_NOT_SPECIFIED = 0;
-        public static final int VIEW_DECKS = 1;
-        public static final int VIEW_CONGRATS = 2;
-        public static final int VIEW_SHOW_QUESTION = 3;
-        public static final int VIEW_SHOW_ANSWER = 4;
-        public static final int VIEW_NOTHING_DUE = 5;
-        public static final int VIEW_SHOW_HELP = 6;
-
-        private static final int sColorBlue = Color.parseColor("#000099");
-        private static final int sColorRed = Color.parseColor("#990000");
-        private static final int sColorGreen = Color.parseColor("#007700");
-
-
-        private CharSequence getDeckStatusString(Card card) {
-            int[] counts = contentService.mCol.getSched().counts(card);
-            return getDeckStatusString(counts[0], counts[1], counts[2], card);
-        }
-
-
-        private CharSequence getDeckStatusString(int newCount, int lrnCount, int dueCount, Card card) {
-            SpannableStringBuilder sb = new SpannableStringBuilder();
-
-            SpannableString red = new SpannableString(Integer.toString(newCount));
-            red.setSpan(new ForegroundColorSpan(sColorBlue), 0, red.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            if (card != null && card.getType() == Card.TYPE_NEW) {
-                red.setSpan(new UnderlineSpan(), 0, red.length(), 0);
-            }
-
-            SpannableString black = new SpannableString(Integer.toString(lrnCount));
-            black.setSpan(new ForegroundColorSpan(sColorRed), 0, black.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            if (card != null && card.getType() == Card.TYPE_LRN) {
-                black.setSpan(new UnderlineSpan(), 0, black.length(), 0);
-            }
-
-            SpannableString blue = new SpannableString(Integer.toString(dueCount));
-            blue.setSpan(new ForegroundColorSpan(sColorGreen), 0, blue.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            if (card != null && card.getType() == Card.TYPE_REV) {
-                blue.setSpan(new UnderlineSpan(), 0, blue.length(), 0);
-            }
-
-            sb.append(red);
-            sb.append(" ");
-            sb.append(black);
-            sb.append(" ");
-            sb.append(blue);
-
-            return sb;
-        }
-
-
-        private CharSequence getNextTimeString(Card card) {
-            SpannableStringBuilder sb = new SpannableStringBuilder();
-
-            SpannableString again = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 1));
-            SpannableString hard = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 2));
-            SpannableString easy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 3));
-            SpannableString veryEasy = null;
-
-            again.setSpan(new ForegroundColorSpan(sColorRed), 0, again.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-
-            if (contentService.mCol.getSched().answerButtons(card) == 3) {
-                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
-                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            } else {
-                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
-                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-
-                veryEasy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 4));
-                veryEasy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-                        veryEasy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            }
-
-            sb.append(again);
-            sb.append(" \u2027 ");
-            sb.append(hard);
-            sb.append(" \u2027 ");
-            sb.append(easy);
-            if (contentService.mCol.getSched().answerButtons(card) == 4) {
-                sb.append(" \u2027 ");
-                sb.append(veryEasy);
-            }
-
-            return sb;
-        }
-
-        private DeckTask.TaskListener mOpenCollectionHandler = new DeckTask.TaskListener() {
-            @Override
-            public void onPreExecute() {
-                showProgressDialog();
-            }
-
-
-            @Override
-            public void onProgressUpdate(DeckTask.TaskData... values) {
-                String message = values[0].getString();
-                if (message != null) {
-                    contentService.mBigCurrentMessage = message;
-                }
-                updateViews();
-            }
-
-
-            @Override
-            public void onPostExecute(DeckTask.TaskData result) {
-                contentService.mCol = result.getCollection();
-                if (contentService.mCol != null) {
-                    showDeckSelectionDialog();
-                } else {
-                    handleError();
-                }
-            }
-        };
-
-        private DeckTask.TaskListener mOpenDeckHandler = new DeckTask.TaskListener() {
-            @Override
-            public void onPreExecute() {
-                showProgressDialog();
-            }
-
-
-            @Override
-            public void onProgressUpdate(DeckTask.TaskData... values) {
-            }
-
-
-            @Override
-            public void onPostExecute(DeckTask.TaskData result) {
-                contentService.setCard();
-                contentService.mBigShowProgressDialog = false;
-                contentService.mBigCurrentMessage = null;
-                updateViews(VIEW_SHOW_QUESTION);
-            }
-        };
-
-        private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
-            @Override
-            public void onPreExecute() {
-                showProgressDialog();
-            }
-
-
-            @Override
-            public void onProgressUpdate(DeckTask.TaskData... values) {
-                contentService.setCard(values[0].getCard());
-                int leech = values[0].getInt();
-                if (leech > 0) {
-                    String leechMessage;
-                    if (leech == 2) {
-                        contentService.mBigCurrentMessage = getResources().getString(
-                                R.string.leech_suspend_notification);
-                    } else {
-                        contentService.mBigCurrentMessage = getResources().getString(R.string.leech_notification);
-                    }
-                } else {
-                    contentService.mBigCurrentMessage = null;
-                }
-                contentService.mBigShowProgressDialog = false;
-                updateViews(VIEW_SHOW_QUESTION);
-                // TODO: do not reload all counts
-                WidgetStatus.update(UpdateService.this);
-            }
-
-
-            @Override
-            public void onPostExecute(DeckTask.TaskData result) {
-                if (!result.getBoolean()) {
-                    handleError();
-                }
-            }
-        };
-
-        private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
-            @Override
-            public void onPreExecute() {
-                showProgressDialog();
-            }
-
-
-            @Override
-            public void onProgressUpdate(DeckTask.TaskData... values) {
-                contentService.setCard(values[0].getCard());
-                contentService.mBigShowProgressDialog = false;
-                contentService.mBigCurrentMessage = null;
-                updateViews(VIEW_SHOW_QUESTION);
-            }
-
-
-            @Override
-            public void onPostExecute(DeckTask.TaskData result) {
-                if (!result.getBoolean()) {
-                    handleError();
-                    return;
-                }
-                String str = result.getString();
-                if (str != null) {
-                    // if (str.equals(Decks.UNDO_TYPE_SUSPEND_CARD)) {
-                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_unsuspended);
-                    // } else if (str.equals("redo suspend")) {
-                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_suspended);
-                    // }
-                }
-                updateViews();
-                // WidgetStatus.update(UpdateService.this, WidgetStatus.getDeckStatus(contentService.mCol), false);
-            }
-        };
-
-        private DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
-            @Override
-            public void onPreExecute() {
-                showProgressDialog();
-            }
-
-
-            @Override
-            public void onProgressUpdate(DeckTask.TaskData... values) {
-            }
-
-
-            @Override
-            public void onPostExecute(DeckTask.TaskData result) {
-                contentService.mCol = null;
-                AnkiDroidApp.getSharedPrefs(UpdateService.this.getBaseContext()).edit().putString("lastWidgetDeck", "")
-                        .commit();
-                contentService.setCard(null);
-                contentService.mBigShowProgressDialog = false;
-                contentService.mBigCurrentMessage = null;
-                updateViews(VIEW_DECKS);
-            }
-        };
-
-
-        @Override
-        public void onStart(Intent intent, int startId) {
-            Log.i(AnkiDroidApp.TAG, "BigWidget: OnStart");
-
-            if (intent == null) {
-                // do nothing
-            } else if (contentService == null) {
-                Log.i(AnkiDroidApp.TAG, "binding content service");
-                updateViews();
-                tempIntent = intent;
-                sContext = this;
-                Intent contentIntent = new Intent(this, WidgetContentService.class);
-                this.bindService(contentIntent, localServiceConnection, Context.BIND_AUTO_CREATE);
-            } else if (intent.getAction() != null) {
-                String action = intent.getAction();
-                if (ACTION_NOTHING.equals(action)) {
-                    // do nothing
-                } else if (ACTION_UPDATE.equals(action)) {
-                    if (!contentService.mWaitForAsyncTask) {
-                        if (!intent.getBooleanExtra(EXTRA_PROGRESSDIALOG, false)) {
-                            contentService.mBigShowProgressDialog = false;
-                            updateViews(intent.getIntExtra(EXTRA_VIEW, VIEW_NOT_SPECIFIED));
-                        } else if (!contentService.mBigShowProgressDialog) {
-                            showProgressDialog();
-                        }
-                    }
-                } else if (ACTION_OPENCOLLECTION.equals(action)) {
-                    showProgressDialog();
-                    if (contentService.mCol == null) {
-                        contentService.mBigCurrentMessage = getResources().getString(R.string.open_collection);
-                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler,
-                                new DeckTask.TaskData(AnkiDroidApp.getCollectionPath()));
-                        updateViews();
-                    } else {
-                        showDeckSelectionDialog();
-                    }
-                } else if (ACTION_OPENDECK.equals(action)) {
-                    showProgressDialog();
-                    if (contentService != null) {
-                        contentService.mCol.getDecks().select(intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1));
-                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_VALUES_FROM_DECK, mOpenDeckHandler,
-                                new DeckTask.TaskData(contentService.mCol.getSched(), true));
-                    }
-                } else if (ACTION_CLOSEDECK.equals(action)) {
-                    // if (contentService.mCol != null) {
-                    // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new
-                    // DeckTask.TaskData(contentService.mCol.getDeckPath()));
-                    // } else {
-                    updateViews(VIEW_DECKS);
-                    // }
-                } else if (ACTION_UNDO.equals(action)) {
-                    if (contentService.mCol != null) {
-                        if (contentService.mCol.undoAvailable()) {
-                            // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new
-                            // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard != null ?
-                            // contentService.mCurrentCard.getId() : 0, true));
-                        }
-                    } else {
-                        updateViews(VIEW_DECKS);
-                    }
-                } else if (ACTION_BURY_CARD.equals(action)) {
-                    if (contentService.mCol != null) {
-                        // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new
-                        // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard));
-                    } else {
-                        updateViews(VIEW_DECKS);
-                    }
-                } else if (action.startsWith(ACTION_ANSWER)) {
-                    int ease = intent.getIntExtra(EXTRA_EASE, 0);
-                    if (ease == 0) {
-                        updateViews(VIEW_SHOW_ANSWER);
-                    } else {
-                        if (contentService.mCol != null) {
-                            if (contentService.mCurrentCard.timeTaken() > 12) {
-                                // assume, user was not learning
-                                contentService.mCurrentCard.setTimer(Utils.now() - 6);
-                            }
-                            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,
-                                    new DeckTask.TaskData(contentService.mCol.getSched(), contentService.mCurrentCard,
-                                            ease));
-                        } else {
-                            updateViews(VIEW_DECKS);
-                        }
-                    }
-                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
-                    Intent dialogIntent = new Intent(this, WidgetDialog.class);
-                    dialogIntent.setAction(WidgetDialog.ACTION_SHOW_RESTRICTIONS_DIALOG);
-                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    this.startActivity(dialogIntent);
-                } else if (ACTION_OPEN.equals(action)) {
-                    // String deckpath = intent.getStringExtra(EXTRA_DECK_PATH);
-                    // Intent newIntent = StudyOptions.getLoadDeckIntent(this, deckpath);
-                    // if (deckpath != null) {
-                    // DeckManager.getDeck(deckpath, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
-                    // if (contentService.mBigCurrentView != VIEW_NOTHING_DUE) {
-                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_REVIEWER);
-                    // startActivity(newIntent);
-                    // showProgressDialog();
-                    // } else {
-                    // startActivity(newIntent);
-                    // }
-                    // } else {
-                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_DECKPICKER);
-                    // startActivity(newIntent);
-                    // }
-                } else if (ACTION_CARDEDITOR.equals(action)) {
-                    // Intent editIntent = new Intent(this, CardEditor.class);
-                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_EDIT);
-                    // // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
-                    // this.startActivity(editIntent);
-                } else if (ACTION_FACTADDER.equals(action)) {
-                    // Intent editIntent = new Intent(this, CardEditor.class);
-                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_ADD);
-                    // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
-                    // this.startActivity(editIntent);
-                } else if (ACTION_HELP.equals(action)) {
-                    if (contentService.mBigShowProgressDialog) {
-                        contentService.mBigShowProgressDialog = false;
-                        updateViews(VIEW_SHOW_HELP);
-                        contentService.mBigShowProgressDialog = true;
-                    } else {
-                        updateViews(VIEW_SHOW_HELP);
-                    }
-                } else if (ACTION_LEARN_MORE.equals(action)) {
-                    // if (contentService.mCol != null) {
-                    // contentService.mCol.setupLearnMoreScheduler();
-                    // contentService.mCol.reset();
-                    // contentService.setCard();
-                    // contentService.mBigShowProgressDialog = false;
-                    // contentService.mBigCurrentMessage = null;
-                    // updateViews(VIEW_SHOW_QUESTION);
-                    // } else {
-                    // updateViews(VIEW_DECKS);
-                    // }
-                } else if (ACTION_REVIEW_EARLY.equals(action)) {
-                    // if (contentService.mCol != null) {
-                    // contentService.mCol.setupReviewEarlyScheduler();
-                    // contentService.mCol.reset();
-                    // contentService.setCard();
-                    // contentService.mBigShowProgressDialog = false;
-                    // contentService.mBigCurrentMessage = null;
-                    // updateViews(VIEW_SHOW_QUESTION);
-                    // } else {
-                    // updateViews(VIEW_DECKS);
-                    // }
-                } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
-                    if (contentService.mTomorrowDues == null) {
-                        showProgressDialog();
-                        contentService.mWaitForAsyncTask = true;
-                        AsyncTask<String, Void, DeckStatus[]> getTomorrowDuesAsyncTask = new GetTomorrowDueAsyncTask();
-                        getTomorrowDuesAsyncTask.execute(AnkiDroidApp.getSharedPrefs(
-                                AnkiDroidWidgetBig.UpdateService.this).getString("deckPath",
-                                AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
-                    } else {
-                        updateViews(VIEW_CONGRATS);
-                    }
-                }
-            }
-        }
-
-
-        private void handleError() {
-            // TODO
-            // Intent newIntent = DeckPicker.getLoadDeckIntent(AnkiDroidWidgetBig.UpdateService.this, 0);
-            // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_DB_ERROR);
-            // startActivity(newIntent);
-            // contentService.mBigCurrentMessage = null;
-            // DeckManager.closeDeck(deckPath);
-            // contentService.mCol = null;
-            // contentService.setCard(null);
-            // contentService.mBigShowProgressDialog = false;
-            // updateViews(VIEW_DECKS);
-        }
-
-
-        private void showProgressDialog() {
-            Log.i(AnkiDroidApp.TAG, "BigWidget: show progress dialog");
-            contentService.mBigShowProgressDialog = true;
-            updateViews();
-        }
-
-
-        private void updateViews(int view) {
-            if (view != VIEW_NOT_SPECIFIED) {
-                contentService.mBigCurrentView = view;
-            }
-            updateViews();
-        }
-
-
-        private void updateViews() {
-            RemoteViews updateViews = buildUpdate(this);
-
-            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetBig.class);
-            AppWidgetManager manager = AppWidgetManager.getInstance(this);
-            manager.updateAppWidget(thisWidget, updateViews);
-        }
-
-
-        private synchronized RemoteViews buildUpdate(Context context) {
-            Resources res = getResources();
-            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
-
-            if (contentService == null) {
-                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
-                return updateViews;
-            }
-
-            if (contentService.mBigCurrentView == VIEW_NOT_SPECIFIED) {
-                contentService.mBigCurrentView = VIEW_DECKS;
-            }
-
-            Log.i(AnkiDroidApp.TAG, "BigWidget: buildUpdate (" + contentService.mBigCurrentView + ")");
-
-            if (contentService.mBigCurrentView == VIEW_DECKS || contentService.mBigCurrentView == VIEW_SHOW_HELP
-                    || contentService.mBigCurrentView == VIEW_CONGRATS) {
-            } else if (contentService.mCol == null) {
-                contentService.mBigCurrentView = VIEW_DECKS;
-            } else if (contentService.mCurrentCard == null) {
-                contentService.mBigCurrentView = VIEW_NOTHING_DUE;
-            }
-
-            if (contentService.mBigCurrentMessage != null) {
-                updateViews.setTextViewText(R.id.widget_big_message, contentService.mBigCurrentMessage);
-            } else {
-                updateViews.setTextViewText(R.id.widget_big_message, "");
-            }
-
-            if (contentService.mBigShowProgressDialog) {
-                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
-                return updateViews;
-            } else {
-                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);
-                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
-            }
-
-            switch (contentService.mBigCurrentView) {
-                case VIEW_CONGRATS:
-                case VIEW_DECKS:
-                    updateViews.setTextViewText(R.id.widget_big_deckname, "");
-                    updateCounts(updateViews, contentService.mBigCurrentView);
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_deckfield,
-                            contentService.mBigCurrentView == VIEW_DECKS ? getTomorrowDuePendingIntent(context)
-                                    : getUpdatePendingIntent(context, VIEW_DECKS));
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose,
-                            getShowDeckSelectionPendingIntent(context));
-                    updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
-
-                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getHelpPendingIntent(this));
-
-                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
-                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
-                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.INVISIBLE);
-                    emptyCardAreaTexts(updateViews);
-                    removeAreaListeners(this, true);
-
-                    updateViews.setViewVisibility(R.id.widget_big_add, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_star, View.VISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getOpenPendingIntent(this, 0));
-                    break;
-
-                case VIEW_SHOW_HELP:
-                    updateViews
-                            .setOnClickPendingIntent(R.id.widget_big_empty, getUpdatePendingIntent(this, VIEW_DECKS));
-
-                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-
-                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-                    String[] values = res.getStringArray(R.array.gestures_labels);
-                    updateViews.setTextViewText(R.id.widget_big_topleft, res.getString(R.string.open_in_reviewer));
-                    updateViews.setTextViewText(R.id.widget_big_middleleft, values[12]);
-                    updateViews.setTextViewText(R.id.widget_big_bottomleft, values[1]);
-                    updateViews.setTextViewText(R.id.widget_big_topright, values[9]);
-                    updateViews.setTextViewText(R.id.widget_big_middleright, values[7]);
-                    updateViews.setTextViewText(R.id.widget_big_bottomright, values[5]);
-                    break;
-
-                case VIEW_SHOW_QUESTION:
-                    try {
-                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
-                                .getString("name"));
-                    } catch (JSONException e1) {
-                        throw new RuntimeException(e1);
-                    }
-                    updateCounts(updateViews, contentService.mBigCurrentView);
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
-                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
-
-                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.VISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getAnswerPendingIntent(context, 0));
-
-                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
-                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(this));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 0));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(this));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 0));
-                    emptyCardAreaTexts(updateViews);
-
-                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
-
-                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
-                            Html.fromHtml(contentService.mCurrentCard.getQuestion(true)));
-
-                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
-                            getFactAdderPendingIntent(context));
-                    break;
-
-                case VIEW_SHOW_ANSWER:
-                    updateViews.setViewVisibility(R.id.widget_big_empty, View.INVISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, getAnswerPendingIntent(context, 1));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, getAnswerPendingIntent(context, 2));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, getAnswerPendingIntent(context, 3));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease4, getAnswerPendingIntent(context, 4));
-
-                    updateViews
-                            .setTextViewText(R.id.widget_big_message, getNextTimeString(contentService.mCurrentCard));
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 1));
-
-                    if (contentService.mCol.getSched().answerButtons(contentService.mCurrentCard) == 4) {
-                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.INVISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.VISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.INVISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.VISIBLE);
-                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
-                                getAnswerPendingIntent(this, 3));
-                    } else {
-                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.VISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.INVISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.VISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.INVISIBLE);
-                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
-                                getAnswerPendingIntent(this, 2));
-                    }
-
-                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
-                            Html.fromHtml(contentService.mCurrentCard.getAnswer(true)));
-                    break;
-
-                case VIEW_NOTHING_DUE:
-                    try {
-                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
-                                .getString("name"));
-                    } catch (JSONException e) {
-                        throw new RuntimeException(e);
-                    }
-                    updateCounts(updateViews, contentService.mBigCurrentView);
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
-                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
-
-                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
-                    getHelpPendingIntent(this).cancel();
-                    getUpdatePendingIntent(this, VIEW_DECKS).cancel();
-
-                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
-                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
-                    removeAreaListeners(this, false);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
-                    emptyCardAreaTexts(updateViews);
-
-                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
-                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
-                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-
-                    // TODO
-                    // int failedCards = contentService.mCol.getFailedDelayedCount();
-                    // int revCards = contentService.mCol.getNextDueCards(1);
-                    // int newCards = contentService.mCol.getNextNewCards();
-                    // int eta = contentService.mCol.getETA(failedCards, revCards, newCards, true);
-                    // updateViews.setTextViewText(R.id.widget_big_congrats, StudyOptions.getCongratsMessage(this,
-                    // failedCards, revCards, newCards, eta));
-
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_review_early,
-                            getReviewEarlyPendingIntent(context));
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_learn_more, getLearnMorePendingIntent(context));
-
-                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
-                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
-                            getFactAdderPendingIntent(context));
-                    break;
-            }
-            return updateViews;
-
-            // WebView webView = new WebView(this);
-            // webView.setDrawingCacheEnabled(true);
-            // webView.layout(0, 0, 500, 500);
-            // webView.loadDataWithBaseURL("", "asdf", "text/html", "utf-8", null);
-            // webView.buildDrawingCache(true);
-            // Bitmap b = Bitmap.createBitmap(webView.getDrawingCache());
-            // webView.setDrawingCacheEnabled(false); // clear drawing cache
-            //
-            // FileOutputStream out;
-            // try {
-            // out = new FileOutputStream("/emmc/test.png");
-            // b.compress(Bitmap.CompressFormat.PNG, 90, out);
-            // File f = new File("/emmc/test.png");
-            // Uri uri = Uri.fromFile(f);
-            // updateViews.setImageViewUri(R.id.widget_big_cardcontent, uri);
-            // } catch (FileNotFoundException e) {
-            // // TODO Auto-generated catch block
-            // e.printStackTrace();
-            // }
-        }
-
-
-        private void updateCounts(RemoteViews updateViews, int view) {
-            int[] counts = WidgetStatus.fetchSmall(this);
-            int progressTotal = counts[1];
-            int eta = counts[2];
-            updateViews.setProgressBar(R.id.widget_big_progress_total, 100, progressTotal, false);
-            if (eta == 0) {
-                updateViews.setViewVisibility(R.id.widget_big_eta, View.INVISIBLE);
-            } else {
-                updateViews.setViewVisibility(R.id.widget_big_eta, View.VISIBLE);
-                updateViews.setTextViewText(R.id.widget_big_eta,
-                        eta > 99 ? "\u2027\u2027\u2027" : Integer.toString(eta));
-            }
-
-            switch (view) {
-                case VIEW_SHOW_QUESTION:
-                case VIEW_NOTHING_DUE:
-                    updateViews.setTextViewText(R.id.widget_big_counts,
-                            getDeckStatusString(contentService.mCurrentCard));
-                    double sessionProgress = contentService.mCol.getSched().todaysProgress(contentService.mCurrentCard,
-                            false, false);
-                    if (sessionProgress == -1) {
-                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
-                    } else {
-                        updateViews.setProgressBar(R.id.widget_big_progress_deck, 100, (int) (sessionProgress * 100),
-                                false);
-                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.VISIBLE);
-                    }
-                    contentService.mTomorrowDues = null;
-                    break;
-
-                case VIEW_CONGRATS:
-                    if (contentService.mTomorrowDues != null && contentService.mTomorrowDues.length > 0) {
-                        updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.VISIBLE);
-                        setDeckCounts(updateViews, contentService.mTomorrowDues);
-                    }
-                    break;
-
-                case VIEW_DECKS:
-                    updateViews.setTextViewText(R.id.widget_big_counts, "");
-                    updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
-
-                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.VISIBLE);
-                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-
-                    setDeckCounts(updateViews, WidgetStatus.fetch(this));
-
-                    updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
-                    updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
-                    updateViews.setTextViewText(R.id.widget_big_decketa,
-                            "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
-                    break;
-            }
-        }
-
-
-        private void emptyCardAreaTexts(RemoteViews updateViews) {
-            updateViews.setTextViewText(R.id.widget_big_topleft, "");
-            updateViews.setTextViewText(R.id.widget_big_middleleft, "");
-            updateViews.setTextViewText(R.id.widget_big_bottomleft, "");
-            updateViews.setTextViewText(R.id.widget_big_topright, "");
-            updateViews.setTextViewText(R.id.widget_big_middleright, "");
-            updateViews.setTextViewText(R.id.widget_big_bottomright, "");
-        }
-
-
-        private void removeAreaListeners(Context context, boolean all) {
-            getBuryCardPendingIntent(context).cancel();
-            getAnswerPendingIntent(context, 0).cancel();
-            getAnswerPendingIntent(context, 1).cancel();
-            getAnswerPendingIntent(context, 2).cancel();
-            getAnswerPendingIntent(context, 3).cancel();
-            getCardEditorPendingIntent(context).cancel();
-            if (all) {
-                getOpenPendingIntent(context, 0).cancel();
-                getUndoPendingIntent(context).cancel();
-            }
-        }
-
-
-        private void setDeckCounts(RemoteViews updateViews, DeckStatus[] decks) {
-            StringBuilder namesSb = new StringBuilder();
-            SpannableStringBuilder duesSb = new SpannableStringBuilder();
-            int eta = 0;
-            for (DeckStatus d : decks) {
-                namesSb.append(d.mDeckName).append("  \n");
-                duesSb.append(getDeckStatusString(d.mNewCards, d.mLrnCards, d.mDueCards, null)).append("\n");
-                eta += d.mEta;
-            }
-            int pos = namesSb.length() - 1;
-            if (pos != -1) {
-                namesSb.delete(pos, pos + 1);
-            }
-            pos = duesSb.length() - 1;
-            if (pos != -1) {
-                duesSb.delete(pos, pos + 1);
-            }
-            if (namesSb.length() == 0 || duesSb.length() == 0) {
-                updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-                // if (!sUpdateStarted) {
-                // sUpdateStarted = true;
-                // WidgetStatus.update(sContext);
-                // }
-            } else {
-                // sUpdateStarted = false;
-            }
-            updateViews.setTextViewText(R.id.widget_big_decknames, namesSb);
-            updateViews.setTextViewText(R.id.widget_big_deckdues, duesSb);
-            updateViews.setTextViewText(R.id.widget_big_decketa,
-                    "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
-        }
-
-
-        private PendingIntent getAnswerPendingIntent(Context context, int ease) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_ANSWER + Integer.toString(ease));
-            ankiDroidIntent.putExtra(EXTRA_EASE, ease);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getShowDeckSelectionPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_OPENCOLLECTION);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getCloseDeckPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_CLOSEDECK);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getUndoPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_UNDO);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getBuryCardPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_BURY_CARD);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getOpenPendingIntent(Context context, long deckId) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_OPEN);
-            ankiDroidIntent.putExtra(DeckPicker.EXTRA_DECK_ID, deckId);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
-        }
-
-
-        private PendingIntent getLearnMorePendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_LEARN_MORE);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getReviewEarlyPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_REVIEW_EARLY);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getCardEditorPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_CARDEDITOR);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getFactAdderPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_FACTADDER);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getHelpPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_HELP);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getTomorrowDuePendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_SHOW_TOMORROW_DUES);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        private PendingIntent getUpdatePendingIntent(Context context, int view) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_UPDATE);
-            ankiDroidIntent.putExtra(EXTRA_VIEW, view);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
-        }
-
-
-        private void showDeckSelectionDialog() {
-            Intent ankiDroidIntent = new Intent(UpdateService.this, WidgetDialog.class);
-            ankiDroidIntent.setAction(WidgetDialog.ACTION_SHOW_DECK_SELECTION_DIALOG);
-            ankiDroidIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | Intent.FLAG_ACTIVITY_NEW_TASK);
-            startActivity(ankiDroidIntent);
-        }
-
-
-        @Override
-        public IBinder onBind(Intent arg0) {
-            Log.i(AnkiDroidApp.TAG, "onBind");
-            return null;
-        }
-
-        private static class GetTomorrowDueAsyncTask extends AsyncTask<String, Void, DeckStatus[]> {
-
-            @Override
-            protected DeckStatus[] doInBackground(String... params) {
-                Log.i(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue");
-                //
-                // File dir = new File(params[0]);
-                // File[] fileList = dir.listFiles(new WidgetStatus.AnkiFileFilter());
-                //
-                // DeckStatus[] todayDues = WidgetStatus.fetch(sContext);
-                //
-                // ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
-                //
-                // for (DeckStatus s : todayDues) {
-                // try {
-                // Decks deck = DeckManager.getDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
-                // if (deck != null) {
-                // int failedCards = deck.getFailedDelayedCount() + s.mFailedCards;
-                // int dueCards = deck.getNextDueCards(1) + s.mDueCards;
-                // int newCards = deck.getNextNewCards() + s.mNewCards;
-                // decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards,
-                // deck.getETA(failedCards, dueCards, newCards, true), 0));
-                // }
-                // DeckManager.closeDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-                // } catch (RuntimeException e) {
-                // Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
-                // }
-                // }
-                // return decks.toArray(new DeckStatus[0]);
-                return null;
-            }
-
-
-            @Override
-            protected void onPostExecute(DeckStatus[] status) {
-                Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
-                contentService.mCol = null;
-                contentService.mCurrentCard = null;
-                contentService.mBigCurrentMessage = null;
-                contentService.mWaitForAsyncTask = false;
-                contentService.mTomorrowDues = status;
-                if (contentService.mBigShowProgressDialog) {
-                    contentService.mBigShowProgressDialog = false;
-                    updateWidget(VIEW_CONGRATS);
-                }
-                contentService.mBigShowProgressDialog = false;
-            }
-        }
-    }
-}
+///***************************************************************************************
+// * This program is free software; you can redistribute it and/or modify it under        *
+// * the terms of the GNU General Public License as published by the Free Software        *
+// * Foundation; either version 3 of the License, or (at your option) any later           *
+// * version.                                                                             *
+// *                                                                                      *
+// * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+// * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+// * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+// *                                                                                      *
+// * You should have received a copy of the GNU General Public License along with         *
+// * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+// ****************************************************************************************/
+//
+//package com.ichi2.widget;
+//
+//import org.json.JSONException;
+//
+//import com.ichi2.anki.AnkiDroidApp;
+//import com.ichi2.anki.DeckPicker;
+//import com.ichi2.anki2.R;
+//import com.ichi2.async.DeckTask;
+//import com.ichi2.libanki.Card;
+//import com.ichi2.libanki.Utils;
+//
+//import android.app.PendingIntent;
+//import android.app.Service;
+//import android.appwidget.AppWidgetManager;
+//import android.appwidget.AppWidgetProvider;
+//import android.content.ComponentName;
+//import android.content.Context;
+//import android.content.Intent;
+//import android.content.ServiceConnection;
+//import android.content.SharedPreferences;
+//import android.content.res.Resources;
+//import android.graphics.Color;
+//import android.os.AsyncTask;
+//import android.os.IBinder;
+//import android.text.Html;
+//import android.text.SpannableString;
+//import android.text.SpannableStringBuilder;
+//import android.text.Spanned;
+//import android.text.style.ForegroundColorSpan;
+//import android.text.style.UnderlineSpan;
+//import android.util.Log;
+//import android.view.View;
+//import android.widget.RemoteViews;
+//
+//public class AnkiDroidWidgetBig extends AppWidgetProvider {
+//
+//    private static Context sContext;
+//
+//    private static WidgetContentService contentService = null;
+//    private static WidgetContentService.WidgetContentBinder contentServiceBinder;
+//    private static Intent tempIntent;
+//
+//    private static ServiceConnection localServiceConnection = new ServiceConnection() {
+//
+//        @Override
+//        public void onServiceConnected(ComponentName className, IBinder binder) {
+//            Log.i(AnkiDroidApp.TAG, "binding content service - success");
+//            contentServiceBinder = (WidgetContentService.WidgetContentBinder) binder;
+//            contentService = contentServiceBinder.getService();
+//            // check, if card is still the same after reloading the deck. If not, show question instead of answering
+//            if (tempIntent.getAction().startsWith(UpdateService.ACTION_ANSWER)
+//                    && contentService.mCurrentCard != null
+//                    && AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getLong(
+//                            "lastWidgetCard", 0) != contentService.mCurrentCard.getId()) {
+//                tempIntent.setAction(UpdateService.ACTION_UPDATE);
+//                tempIntent.putExtra(UpdateService.EXTRA_VIEW, UpdateService.VIEW_SHOW_QUESTION);
+//            }
+//            sContext.startService(tempIntent);
+//            tempIntent = null;
+//        }
+//
+//
+//        @Override
+//        public void onServiceDisconnected(ComponentName arg0) {
+//            contentService = null;
+//        }
+//    };
+//
+//
+//    @Override
+//    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
+//        Log.i(AnkiDroidApp.TAG, "BigWidget: onUpdate");
+//        WidgetStatus.update(context);
+//    }
+//
+//
+//    @Override
+//    public void onEnabled(Context context) {
+//        super.onEnabled(context);
+//        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget enabled");
+//        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
+//        if (!preferences.getBoolean("widgetBigEnabled", false)) {
+//            // show info dialog
+//            Intent intent;
+//            intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
+//            intent.setAction(UpdateService.ACTION_SHOW_RESTRICTIONS_DIALOG);
+//            context.startService(intent);
+//        }
+//        preferences.edit().putBoolean("widgetBigEnabled", true).commit();
+//        if (contentService != null) {
+//            contentService.mBigCurrentView = UpdateService.VIEW_NOT_SPECIFIED;
+//            contentService.mCol = null;
+//            AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+//                    .putString("lastWidgetDeck", "").commit();
+//            contentService.setCard(null);
+//            contentService.mBigCurrentMessage = null;
+//            contentService.mBigShowProgressDialog = false;
+//            contentService.mTomorrowDues = null;
+//            contentService.mWaitForAsyncTask = false;
+//        }
+//    }
+//
+//
+//    @Override
+//    public void onDisabled(Context context) {
+//        super.onDisabled(context);
+//        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget disabled");
+//        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
+//        preferences.edit().putBoolean("widgetBigEnabled", false).commit();
+//    }
+//
+//
+//    // public static void setDeck(Decks deck) {
+//    // if (contentService != null) {
+//    // contentService.mCol = deck;
+//    // }
+//    // updateWidget(UpdateService.VIEW_NOT_SPECIFIED);
+//    // }
+//
+//    public static void setCard(Card card) {
+//        if (contentService != null && contentService.mCol != null) {
+//            contentService.setCard(card);
+//        }
+//    }
+//
+//
+//    public static Card getCard() {
+//        if (contentService != null) {
+//            return contentService.mCurrentCard;
+//        } else {
+//            return null;
+//        }
+//    }
+//
+//
+//    public static void updateWidget(int view) {
+//        updateWidget(view, false);
+//    }
+//
+//
+//    public static void updateWidget(int view, boolean showProgressDialog) {
+//        AnkiDroidApp
+//                .getInstance()
+//                .getApplicationContext()
+//                .startService(
+//                        getUpdateIntent(AnkiDroidApp.getInstance().getApplicationContext(), view, showProgressDialog));
+//    }
+//
+//
+//    public static Intent getUpdateIntent(Context context, int view, boolean showProgressDialog) {
+//        Intent intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
+//        intent.putExtra(UpdateService.EXTRA_VIEW, view);
+//        intent.putExtra(UpdateService.EXTRA_PROGRESSDIALOG, showProgressDialog);
+//        return intent.setAction(UpdateService.ACTION_UPDATE);
+//    }
+//
+//    public static class UpdateService extends Service {
+//        public static final String ACTION_NOTHING = "org.ichi2.anki.AnkiDroidWidgetBig.NOTHING";
+//        public static final String ACTION_OPENDECK = "org.ichi2.anki.AnkiDroidWidgetBig.OPENDECK";
+//        public static final String ACTION_OPENCOLLECTION = "org.ichi2.anki.AnkiDroidWidgetBig.OPENCOLLECTION";
+//        public static final String ACTION_CLOSEDECK = "org.ichi2.anki.AnkiDroidWidgetBig.CLOSEDECK";
+//        public static final String ACTION_ANSWER = "org.ichi2.anki.AnkiDroidWidgetBig.ANSWER";
+//        public static final String ACTION_OPEN = "org.ichi2.anki.AnkiDroidWidgetBig.OPEN";
+//        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidgetBig.UPDATE";
+//        public static final String ACTION_BURY_CARD = "org.ichi2.anki.AnkiDroidWidgetBig.BURYCARD";
+//        public static final String ACTION_UNDO = "org.ichi2.anki.AnkiDroidWidgetBig.UNDO";
+//        public static final String ACTION_CARDEDITOR = "org.ichi2.anki.AnkiDroidWidgetBig.CARDEDITOR";
+//        public static final String ACTION_FACTADDER = "org.ichi2.anki.AnkiDroidWidgetBig.FACTADDER";
+//        public static final String ACTION_HELP = "org.ichi2.anki.AnkiDroidWidgetBig.HELP";
+//        public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
+//        public static final String ACTION_LEARN_MORE = "org.ichi2.anki.AnkiDroidWidgetBig.LEARNMORE";
+//        public static final String ACTION_REVIEW_EARLY = "org.ichi2.anki.AnkiDroidWidgetBig.REVIEWEARLY";
+//        public static final String ACTION_SHOW_TOMORROW_DUES = "org.ichi2.anki.AnkiDroidWidgetBig.TOMORROWDUES";
+//
+//        public static final String EXTRA_EASE = "ease";
+//        public static final String EXTRA_VIEW = "view";
+//        public static final String EXTRA_PROGRESSDIALOG = "progressDialog";
+//
+//        public static final int VIEW_ACTION_DEFAULT = 0;
+//        public static final int VIEW_ACTION_SHOW_PROGRESS_DIALOG = 1;
+//        public static final int VIEW_ACTION_HIDE_BUTTONS = 2;
+//
+//        public static final int VIEW_NOT_SPECIFIED = 0;
+//        public static final int VIEW_DECKS = 1;
+//        public static final int VIEW_CONGRATS = 2;
+//        public static final int VIEW_SHOW_QUESTION = 3;
+//        public static final int VIEW_SHOW_ANSWER = 4;
+//        public static final int VIEW_NOTHING_DUE = 5;
+//        public static final int VIEW_SHOW_HELP = 6;
+//
+//        private static final int sColorBlue = Color.parseColor("#000099");
+//        private static final int sColorRed = Color.parseColor("#990000");
+//        private static final int sColorGreen = Color.parseColor("#007700");
+//
+//
+//        private CharSequence getDeckStatusString(Card card) {
+//            int[] counts = contentService.mCol.getSched().counts(card);
+//            return getDeckStatusString(counts[0], counts[1], counts[2], card);
+//        }
+//
+//
+//        private CharSequence getDeckStatusString(int newCount, int lrnCount, int dueCount, Card card) {
+//            SpannableStringBuilder sb = new SpannableStringBuilder();
+//
+//            SpannableString red = new SpannableString(Integer.toString(newCount));
+//            red.setSpan(new ForegroundColorSpan(sColorBlue), 0, red.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//            if (card != null && card.getType() == Card.TYPE_NEW) {
+//                red.setSpan(new UnderlineSpan(), 0, red.length(), 0);
+//            }
+//
+//            SpannableString black = new SpannableString(Integer.toString(lrnCount));
+//            black.setSpan(new ForegroundColorSpan(sColorRed), 0, black.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//            if (card != null && card.getType() == Card.TYPE_LRN) {
+//                black.setSpan(new UnderlineSpan(), 0, black.length(), 0);
+//            }
+//
+//            SpannableString blue = new SpannableString(Integer.toString(dueCount));
+//            blue.setSpan(new ForegroundColorSpan(sColorGreen), 0, blue.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//            if (card != null && card.getType() == Card.TYPE_REV) {
+//                blue.setSpan(new UnderlineSpan(), 0, blue.length(), 0);
+//            }
+//
+//            sb.append(red);
+//            sb.append(" ");
+//            sb.append(black);
+//            sb.append(" ");
+//            sb.append(blue);
+//
+//            return sb;
+//        }
+//
+//
+//        private CharSequence getNextTimeString(Card card) {
+//            SpannableStringBuilder sb = new SpannableStringBuilder();
+//
+//            SpannableString again = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 1));
+//            SpannableString hard = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 2));
+//            SpannableString easy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 3));
+//            SpannableString veryEasy = null;
+//
+//            again.setSpan(new ForegroundColorSpan(sColorRed), 0, again.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//
+//            if (contentService.mCol.getSched().answerButtons(card) == 3) {
+//                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
+//                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
+//                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//            } else {
+//                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
+//                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
+//                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//
+//                veryEasy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 4));
+//                veryEasy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
+//                        veryEasy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+//            }
+//
+//            sb.append(again);
+//            sb.append(" \u2027 ");
+//            sb.append(hard);
+//            sb.append(" \u2027 ");
+//            sb.append(easy);
+//            if (contentService.mCol.getSched().answerButtons(card) == 4) {
+//                sb.append(" \u2027 ");
+//                sb.append(veryEasy);
+//            }
+//
+//            return sb;
+//        }
+//
+//        private DeckTask.TaskListener mOpenCollectionHandler = new DeckTask.TaskListener() {
+//            @Override
+//            public void onPreExecute() {
+//                showProgressDialog();
+//            }
+//
+//
+//            @Override
+//            public void onProgressUpdate(DeckTask.TaskData... values) {
+//                String message = values[0].getString();
+//                if (message != null) {
+//                    contentService.mBigCurrentMessage = message;
+//                }
+//                updateViews();
+//            }
+//
+//
+//            @Override
+//            public void onPostExecute(DeckTask.TaskData result) {
+//                contentService.mCol = result.getCollection();
+//                if (contentService.mCol != null) {
+//                    showDeckSelectionDialog();
+//                } else {
+//                    handleError();
+//                }
+//            }
+//        };
+//
+//        private DeckTask.TaskListener mOpenDeckHandler = new DeckTask.TaskListener() {
+//            @Override
+//            public void onPreExecute() {
+//                showProgressDialog();
+//            }
+//
+//
+//            @Override
+//            public void onProgressUpdate(DeckTask.TaskData... values) {
+//            }
+//
+//
+//            @Override
+//            public void onPostExecute(DeckTask.TaskData result) {
+//                contentService.setCard();
+//                contentService.mBigShowProgressDialog = false;
+//                contentService.mBigCurrentMessage = null;
+//                updateViews(VIEW_SHOW_QUESTION);
+//            }
+//        };
+//
+//        private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
+//            @Override
+//            public void onPreExecute() {
+//                showProgressDialog();
+//            }
+//
+//
+//            @Override
+//            public void onProgressUpdate(DeckTask.TaskData... values) {
+//                contentService.setCard(values[0].getCard());
+//                int leech = values[0].getInt();
+//                if (leech > 0) {
+//                    String leechMessage;
+//                    if (leech == 2) {
+//                        contentService.mBigCurrentMessage = getResources().getString(
+//                                R.string.leech_suspend_notification);
+//                    } else {
+//                        contentService.mBigCurrentMessage = getResources().getString(R.string.leech_notification);
+//                    }
+//                } else {
+//                    contentService.mBigCurrentMessage = null;
+//                }
+//                contentService.mBigShowProgressDialog = false;
+//                updateViews(VIEW_SHOW_QUESTION);
+//                // TODO: do not reload all counts
+//                WidgetStatus.update(UpdateService.this);
+//            }
+//
+//
+//            @Override
+//            public void onPostExecute(DeckTask.TaskData result) {
+//                if (!result.getBoolean()) {
+//                    handleError();
+//                }
+//            }
+//        };
+//
+//        private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
+//            @Override
+//            public void onPreExecute() {
+//                showProgressDialog();
+//            }
+//
+//
+//            @Override
+//            public void onProgressUpdate(DeckTask.TaskData... values) {
+//                contentService.setCard(values[0].getCard());
+//                contentService.mBigShowProgressDialog = false;
+//                contentService.mBigCurrentMessage = null;
+//                updateViews(VIEW_SHOW_QUESTION);
+//            }
+//
+//
+//            @Override
+//            public void onPostExecute(DeckTask.TaskData result) {
+//                if (!result.getBoolean()) {
+//                    handleError();
+//                    return;
+//                }
+//                String str = result.getString();
+//                if (str != null) {
+//                    // if (str.equals(Decks.UNDO_TYPE_SUSPEND_CARD)) {
+//                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_unsuspended);
+//                    // } else if (str.equals("redo suspend")) {
+//                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_suspended);
+//                    // }
+//                }
+//                updateViews();
+//                // WidgetStatus.update(UpdateService.this, WidgetStatus.getDeckStatus(contentService.mCol), false);
+//            }
+//        };
+//
+//        private DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
+//            @Override
+//            public void onPreExecute() {
+//                showProgressDialog();
+//            }
+//
+//
+//            @Override
+//            public void onProgressUpdate(DeckTask.TaskData... values) {
+//            }
+//
+//
+//            @Override
+//            public void onPostExecute(DeckTask.TaskData result) {
+//                contentService.mCol = null;
+//                AnkiDroidApp.getSharedPrefs(UpdateService.this.getBaseContext()).edit().putString("lastWidgetDeck", "")
+//                        .commit();
+//                contentService.setCard(null);
+//                contentService.mBigShowProgressDialog = false;
+//                contentService.mBigCurrentMessage = null;
+//                updateViews(VIEW_DECKS);
+//            }
+//        };
+//
+//
+//        @Override
+//        public void onStart(Intent intent, int startId) {
+//            Log.i(AnkiDroidApp.TAG, "BigWidget: OnStart");
+//
+//            if (intent == null) {
+//                // do nothing
+//            } else if (contentService == null) {
+//                Log.i(AnkiDroidApp.TAG, "binding content service");
+//                updateViews();
+//                tempIntent = intent;
+//                sContext = this;
+//                Intent contentIntent = new Intent(this, WidgetContentService.class);
+//                this.bindService(contentIntent, localServiceConnection, Context.BIND_AUTO_CREATE);
+//            } else if (intent.getAction() != null) {
+//                String action = intent.getAction();
+//                if (ACTION_NOTHING.equals(action)) {
+//                    // do nothing
+//                } else if (ACTION_UPDATE.equals(action)) {
+//                    if (!contentService.mWaitForAsyncTask) {
+//                        if (!intent.getBooleanExtra(EXTRA_PROGRESSDIALOG, false)) {
+//                            contentService.mBigShowProgressDialog = false;
+//                            updateViews(intent.getIntExtra(EXTRA_VIEW, VIEW_NOT_SPECIFIED));
+//                        } else if (!contentService.mBigShowProgressDialog) {
+//                            showProgressDialog();
+//                        }
+//                    }
+//                } else if (ACTION_OPENCOLLECTION.equals(action)) {
+//                    showProgressDialog();
+//                    if (contentService.mCol == null) {
+//                        contentService.mBigCurrentMessage = getResources().getString(R.string.open_collection);
+//                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler,
+//                                new DeckTask.TaskData(AnkiDroidApp.getCollectionPath()));
+//                        updateViews();
+//                    } else {
+//                        showDeckSelectionDialog();
+//                    }
+//                } else if (ACTION_OPENDECK.equals(action)) {
+//                    showProgressDialog();
+//                    if (contentService != null) {
+//                        contentService.mCol.getDecks().select(intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1));
+//                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_VALUES_FROM_DECK, mOpenDeckHandler,
+//                                new DeckTask.TaskData(contentService.mCol.getSched(), true));
+//                    }
+//                } else if (ACTION_CLOSEDECK.equals(action)) {
+//                    // if (contentService.mCol != null) {
+//                    // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new
+//                    // DeckTask.TaskData(contentService.mCol.getDeckPath()));
+//                    // } else {
+//                    updateViews(VIEW_DECKS);
+//                    // }
+//                } else if (ACTION_UNDO.equals(action)) {
+//                    if (contentService.mCol != null) {
+//                        if (contentService.mCol.undoAvailable()) {
+//                            // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new
+//                            // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard != null ?
+//                            // contentService.mCurrentCard.getId() : 0, true));
+//                        }
+//                    } else {
+//                        updateViews(VIEW_DECKS);
+//                    }
+//                } else if (ACTION_BURY_CARD.equals(action)) {
+//                    if (contentService.mCol != null) {
+//                        // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new
+//                        // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard));
+//                    } else {
+//                        updateViews(VIEW_DECKS);
+//                    }
+//                } else if (action.startsWith(ACTION_ANSWER)) {
+//                    int ease = intent.getIntExtra(EXTRA_EASE, 0);
+//                    if (ease == 0) {
+//                        updateViews(VIEW_SHOW_ANSWER);
+//                    } else {
+//                        if (contentService.mCol != null) {
+//                            if (contentService.mCurrentCard.timeTaken() > 12) {
+//                                // assume, user was not learning
+//                                contentService.mCurrentCard.setTimer(Utils.now() - 6);
+//                            }
+//                            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,
+//                                    new DeckTask.TaskData(contentService.mCol.getSched(), contentService.mCurrentCard,
+//                                            ease));
+//                        } else {
+//                            updateViews(VIEW_DECKS);
+//                        }
+//                    }
+//                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
+//                    Intent dialogIntent = new Intent(this, WidgetDialog.class);
+//                    dialogIntent.setAction(WidgetDialog.ACTION_SHOW_RESTRICTIONS_DIALOG);
+//                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+//                    this.startActivity(dialogIntent);
+//                } else if (ACTION_OPEN.equals(action)) {
+//                    // String deckpath = intent.getStringExtra(EXTRA_DECK_PATH);
+//                    // Intent newIntent = StudyOptions.getLoadDeckIntent(this, deckpath);
+//                    // if (deckpath != null) {
+//                    // DeckManager.getDeck(deckpath, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+//                    // if (contentService.mBigCurrentView != VIEW_NOTHING_DUE) {
+//                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_REVIEWER);
+//                    // startActivity(newIntent);
+//                    // showProgressDialog();
+//                    // } else {
+//                    // startActivity(newIntent);
+//                    // }
+//                    // } else {
+//                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_DECKPICKER);
+//                    // startActivity(newIntent);
+//                    // }
+//                } else if (ACTION_CARDEDITOR.equals(action)) {
+//                    // Intent editIntent = new Intent(this, CardEditor.class);
+//                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+//                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_EDIT);
+//                    // // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
+//                    // this.startActivity(editIntent);
+//                } else if (ACTION_FACTADDER.equals(action)) {
+//                    // Intent editIntent = new Intent(this, CardEditor.class);
+//                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+//                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_ADD);
+//                    // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
+//                    // this.startActivity(editIntent);
+//                } else if (ACTION_HELP.equals(action)) {
+//                    if (contentService.mBigShowProgressDialog) {
+//                        contentService.mBigShowProgressDialog = false;
+//                        updateViews(VIEW_SHOW_HELP);
+//                        contentService.mBigShowProgressDialog = true;
+//                    } else {
+//                        updateViews(VIEW_SHOW_HELP);
+//                    }
+//                } else if (ACTION_LEARN_MORE.equals(action)) {
+//                    // if (contentService.mCol != null) {
+//                    // contentService.mCol.setupLearnMoreScheduler();
+//                    // contentService.mCol.reset();
+//                    // contentService.setCard();
+//                    // contentService.mBigShowProgressDialog = false;
+//                    // contentService.mBigCurrentMessage = null;
+//                    // updateViews(VIEW_SHOW_QUESTION);
+//                    // } else {
+//                    // updateViews(VIEW_DECKS);
+//                    // }
+//                } else if (ACTION_REVIEW_EARLY.equals(action)) {
+//                    // if (contentService.mCol != null) {
+//                    // contentService.mCol.setupReviewEarlyScheduler();
+//                    // contentService.mCol.reset();
+//                    // contentService.setCard();
+//                    // contentService.mBigShowProgressDialog = false;
+//                    // contentService.mBigCurrentMessage = null;
+//                    // updateViews(VIEW_SHOW_QUESTION);
+//                    // } else {
+//                    // updateViews(VIEW_DECKS);
+//                    // }
+//                } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
+//                    if (contentService.mTomorrowDues == null) {
+//                        showProgressDialog();
+//                        contentService.mWaitForAsyncTask = true;
+//                        AsyncTask<String, Void, DeckStatus[]> getTomorrowDuesAsyncTask = new GetTomorrowDueAsyncTask();
+//                        getTomorrowDuesAsyncTask.execute(AnkiDroidApp.getSharedPrefs(
+//                                AnkiDroidWidgetBig.UpdateService.this).getString("deckPath",
+//                                AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
+//                    } else {
+//                        updateViews(VIEW_CONGRATS);
+//                    }
+//                }
+//            }
+//        }
+//
+//
+//        private void handleError() {
+//            // TODO
+//            // Intent newIntent = DeckPicker.getLoadDeckIntent(AnkiDroidWidgetBig.UpdateService.this, 0);
+//            // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_DB_ERROR);
+//            // startActivity(newIntent);
+//            // contentService.mBigCurrentMessage = null;
+//            // DeckManager.closeDeck(deckPath);
+//            // contentService.mCol = null;
+//            // contentService.setCard(null);
+//            // contentService.mBigShowProgressDialog = false;
+//            // updateViews(VIEW_DECKS);
+//        }
+//
+//
+//        private void showProgressDialog() {
+//            Log.i(AnkiDroidApp.TAG, "BigWidget: show progress dialog");
+//            contentService.mBigShowProgressDialog = true;
+//            updateViews();
+//        }
+//
+//
+//        private void updateViews(int view) {
+//            if (view != VIEW_NOT_SPECIFIED) {
+//                contentService.mBigCurrentView = view;
+//            }
+//            updateViews();
+//        }
+//
+//
+//        private void updateViews() {
+//            RemoteViews updateViews = buildUpdate(this);
+//
+//            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetBig.class);
+//            AppWidgetManager manager = AppWidgetManager.getInstance(this);
+//            manager.updateAppWidget(thisWidget, updateViews);
+//        }
+//
+//
+//        private synchronized RemoteViews buildUpdate(Context context) {
+//            Resources res = getResources();
+//            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
+//
+//            if (contentService == null) {
+//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
+//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
+//                return updateViews;
+//            }
+//
+//            if (contentService.mBigCurrentView == VIEW_NOT_SPECIFIED) {
+//                contentService.mBigCurrentView = VIEW_DECKS;
+//            }
+//
+//            Log.i(AnkiDroidApp.TAG, "BigWidget: buildUpdate (" + contentService.mBigCurrentView + ")");
+//
+//            if (contentService.mBigCurrentView == VIEW_DECKS || contentService.mBigCurrentView == VIEW_SHOW_HELP
+//                    || contentService.mBigCurrentView == VIEW_CONGRATS) {
+//            } else if (contentService.mCol == null) {
+//                contentService.mBigCurrentView = VIEW_DECKS;
+//            } else if (contentService.mCurrentCard == null) {
+//                contentService.mBigCurrentView = VIEW_NOTHING_DUE;
+//            }
+//
+//            if (contentService.mBigCurrentMessage != null) {
+//                updateViews.setTextViewText(R.id.widget_big_message, contentService.mBigCurrentMessage);
+//            } else {
+//                updateViews.setTextViewText(R.id.widget_big_message, "");
+//            }
+//
+//            if (contentService.mBigShowProgressDialog) {
+//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
+//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
+//                return updateViews;
+//            } else {
+//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);
+//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
+//            }
+//
+//            switch (contentService.mBigCurrentView) {
+//                case VIEW_CONGRATS:
+//                case VIEW_DECKS:
+//                    updateViews.setTextViewText(R.id.widget_big_deckname, "");
+//                    updateCounts(updateViews, contentService.mBigCurrentView);
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_deckfield,
+//                            contentService.mBigCurrentView == VIEW_DECKS ? getTomorrowDuePendingIntent(context)
+//                                    : getUpdatePendingIntent(context, VIEW_DECKS));
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose,
+//                            getShowDeckSelectionPendingIntent(context));
+//                    updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getHelpPendingIntent(this));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
+//                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
+//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.INVISIBLE);
+//                    emptyCardAreaTexts(updateViews);
+//                    removeAreaListeners(this, true);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_add, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_star, View.VISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getOpenPendingIntent(this, 0));
+//                    break;
+//
+//                case VIEW_SHOW_HELP:
+//                    updateViews
+//                            .setOnClickPendingIntent(R.id.widget_big_empty, getUpdatePendingIntent(this, VIEW_DECKS));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+//                    String[] values = res.getStringArray(R.array.gestures_labels);
+//                    updateViews.setTextViewText(R.id.widget_big_topleft, res.getString(R.string.open_in_reviewer));
+//                    updateViews.setTextViewText(R.id.widget_big_middleleft, values[12]);
+//                    updateViews.setTextViewText(R.id.widget_big_bottomleft, values[1]);
+//                    updateViews.setTextViewText(R.id.widget_big_topright, values[9]);
+//                    updateViews.setTextViewText(R.id.widget_big_middleright, values[7]);
+//                    updateViews.setTextViewText(R.id.widget_big_bottomright, values[5]);
+//                    break;
+//
+//                case VIEW_SHOW_QUESTION:
+//                    try {
+//                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
+//                                .getString("name"));
+//                    } catch (JSONException e1) {
+//                        throw new RuntimeException(e1);
+//                    }
+//                    updateCounts(updateViews, contentService.mBigCurrentView);
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
+//                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.VISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getAnswerPendingIntent(context, 0));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
+//                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(this));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 0));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(this));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 0));
+//                    emptyCardAreaTexts(updateViews);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
+//
+//                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
+//                            Html.fromHtml(contentService.mCurrentCard.getQuestion(true)));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
+//                            getFactAdderPendingIntent(context));
+//                    break;
+//
+//                case VIEW_SHOW_ANSWER:
+//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.INVISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, getAnswerPendingIntent(context, 1));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, getAnswerPendingIntent(context, 2));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, getAnswerPendingIntent(context, 3));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease4, getAnswerPendingIntent(context, 4));
+//
+//                    updateViews
+//                            .setTextViewText(R.id.widget_big_message, getNextTimeString(contentService.mCurrentCard));
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 1));
+//
+//                    if (contentService.mCol.getSched().answerButtons(contentService.mCurrentCard) == 4) {
+//                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.INVISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.VISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.INVISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.VISIBLE);
+//                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
+//                                getAnswerPendingIntent(this, 3));
+//                    } else {
+//                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.VISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.INVISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.VISIBLE);
+//                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.INVISIBLE);
+//                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
+//                                getAnswerPendingIntent(this, 2));
+//                    }
+//
+//                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
+//                            Html.fromHtml(contentService.mCurrentCard.getAnswer(true)));
+//                    break;
+//
+//                case VIEW_NOTHING_DUE:
+//                    try {
+//                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
+//                                .getString("name"));
+//                    } catch (JSONException e) {
+//                        throw new RuntimeException(e);
+//                    }
+//                    updateCounts(updateViews, contentService.mBigCurrentView);
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
+//                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
+//                    getHelpPendingIntent(this).cancel();
+//                    getUpdatePendingIntent(this, VIEW_DECKS).cancel();
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
+//                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
+//                    removeAreaListeners(this, false);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
+//                    emptyCardAreaTexts(updateViews);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
+//                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
+//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+//
+//                    // TODO
+//                    // int failedCards = contentService.mCol.getFailedDelayedCount();
+//                    // int revCards = contentService.mCol.getNextDueCards(1);
+//                    // int newCards = contentService.mCol.getNextNewCards();
+//                    // int eta = contentService.mCol.getETA(failedCards, revCards, newCards, true);
+//                    // updateViews.setTextViewText(R.id.widget_big_congrats, StudyOptions.getCongratsMessage(this,
+//                    // failedCards, revCards, newCards, eta));
+//
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_review_early,
+//                            getReviewEarlyPendingIntent(context));
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_learn_more, getLearnMorePendingIntent(context));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
+//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
+//                            getFactAdderPendingIntent(context));
+//                    break;
+//            }
+//            return updateViews;
+//
+//            // WebView webView = new WebView(this);
+//            // webView.setDrawingCacheEnabled(true);
+//            // webView.layout(0, 0, 500, 500);
+//            // webView.loadDataWithBaseURL("", "asdf", "text/html", "utf-8", null);
+//            // webView.buildDrawingCache(true);
+//            // Bitmap b = Bitmap.createBitmap(webView.getDrawingCache());
+//            // webView.setDrawingCacheEnabled(false); // clear drawing cache
+//            //
+//            // FileOutputStream out;
+//            // try {
+//            // out = new FileOutputStream("/emmc/test.png");
+//            // b.compress(Bitmap.CompressFormat.PNG, 90, out);
+//            // File f = new File("/emmc/test.png");
+//            // Uri uri = Uri.fromFile(f);
+//            // updateViews.setImageViewUri(R.id.widget_big_cardcontent, uri);
+//            // } catch (FileNotFoundException e) {
+//            // // TODO Auto-generated catch block
+//            // e.printStackTrace();
+//            // }
+//        }
+//
+//
+//        private void updateCounts(RemoteViews updateViews, int view) {
+//            int[] counts = WidgetStatus.fetchSmall(this);
+//            int progressTotal = counts[1];
+//            int eta = counts[2];
+//            updateViews.setProgressBar(R.id.widget_big_progress_total, 100, progressTotal, false);
+//            if (eta == 0) {
+//                updateViews.setViewVisibility(R.id.widget_big_eta, View.INVISIBLE);
+//            } else {
+//                updateViews.setViewVisibility(R.id.widget_big_eta, View.VISIBLE);
+//                updateViews.setTextViewText(R.id.widget_big_eta,
+//                        eta > 99 ? "\u2027\u2027\u2027" : Integer.toString(eta));
+//            }
+//
+//            switch (view) {
+//                case VIEW_SHOW_QUESTION:
+//                case VIEW_NOTHING_DUE:
+//                    updateViews.setTextViewText(R.id.widget_big_counts,
+//                            getDeckStatusString(contentService.mCurrentCard));
+//                    double sessionProgress = contentService.mCol.getSched().todaysProgress(contentService.mCurrentCard,
+//                            false, false);
+//                    if (sessionProgress == -1) {
+//                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
+//                    } else {
+//                        updateViews.setProgressBar(R.id.widget_big_progress_deck, 100, (int) (sessionProgress * 100),
+//                                false);
+//                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.VISIBLE);
+//                    }
+//                    contentService.mTomorrowDues = null;
+//                    break;
+//
+//                case VIEW_CONGRATS:
+//                    if (contentService.mTomorrowDues != null && contentService.mTomorrowDues.length > 0) {
+//                        updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.VISIBLE);
+//                        setDeckCounts(updateViews, contentService.mTomorrowDues);
+//                    }
+//                    break;
+//
+//                case VIEW_DECKS:
+//                    updateViews.setTextViewText(R.id.widget_big_counts, "");
+//                    updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.VISIBLE);
+//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+//
+//                    setDeckCounts(updateViews, WidgetStatus.fetch(this));
+//
+//                    updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
+//                    updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
+//                    updateViews.setTextViewText(R.id.widget_big_decketa,
+//                            "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
+//                    break;
+//            }
+//        }
+//
+//
+//        private void emptyCardAreaTexts(RemoteViews updateViews) {
+//            updateViews.setTextViewText(R.id.widget_big_topleft, "");
+//            updateViews.setTextViewText(R.id.widget_big_middleleft, "");
+//            updateViews.setTextViewText(R.id.widget_big_bottomleft, "");
+//            updateViews.setTextViewText(R.id.widget_big_topright, "");
+//            updateViews.setTextViewText(R.id.widget_big_middleright, "");
+//            updateViews.setTextViewText(R.id.widget_big_bottomright, "");
+//        }
+//
+//
+//        private void removeAreaListeners(Context context, boolean all) {
+//            getBuryCardPendingIntent(context).cancel();
+//            getAnswerPendingIntent(context, 0).cancel();
+//            getAnswerPendingIntent(context, 1).cancel();
+//            getAnswerPendingIntent(context, 2).cancel();
+//            getAnswerPendingIntent(context, 3).cancel();
+//            getCardEditorPendingIntent(context).cancel();
+//            if (all) {
+//                getOpenPendingIntent(context, 0).cancel();
+//                getUndoPendingIntent(context).cancel();
+//            }
+//        }
+//
+//
+//        private void setDeckCounts(RemoteViews updateViews, DeckStatus[] decks) {
+//            StringBuilder namesSb = new StringBuilder();
+//            SpannableStringBuilder duesSb = new SpannableStringBuilder();
+//            int eta = 0;
+//            for (DeckStatus d : decks) {
+//                namesSb.append(d.mDeckName).append("  \n");
+//                duesSb.append(getDeckStatusString(d.mNewCards, d.mLrnCards, d.mDueCards, null)).append("\n");
+//                eta += d.mEta;
+//            }
+//            int pos = namesSb.length() - 1;
+//            if (pos != -1) {
+//                namesSb.delete(pos, pos + 1);
+//            }
+//            pos = duesSb.length() - 1;
+//            if (pos != -1) {
+//                duesSb.delete(pos, pos + 1);
+//            }
+//            if (namesSb.length() == 0 || duesSb.length() == 0) {
+//                updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+//                // if (!sUpdateStarted) {
+//                // sUpdateStarted = true;
+//                // WidgetStatus.update(sContext);
+//                // }
+//            } else {
+//                // sUpdateStarted = false;
+//            }
+//            updateViews.setTextViewText(R.id.widget_big_decknames, namesSb);
+//            updateViews.setTextViewText(R.id.widget_big_deckdues, duesSb);
+//            updateViews.setTextViewText(R.id.widget_big_decketa,
+//                    "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
+//        }
+//
+//
+//        private PendingIntent getAnswerPendingIntent(Context context, int ease) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_ANSWER + Integer.toString(ease));
+//            ankiDroidIntent.putExtra(EXTRA_EASE, ease);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getShowDeckSelectionPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_OPENCOLLECTION);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getCloseDeckPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_CLOSEDECK);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getUndoPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_UNDO);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getBuryCardPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_BURY_CARD);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getOpenPendingIntent(Context context, long deckId) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_OPEN);
+//            ankiDroidIntent.putExtra(DeckPicker.EXTRA_DECK_ID, deckId);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
+//        }
+//
+//
+//        private PendingIntent getLearnMorePendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_LEARN_MORE);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getReviewEarlyPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_REVIEW_EARLY);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getCardEditorPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_CARDEDITOR);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getFactAdderPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_FACTADDER);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getHelpPendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_HELP);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getTomorrowDuePendingIntent(Context context) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_SHOW_TOMORROW_DUES);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+//        }
+//
+//
+//        private PendingIntent getUpdatePendingIntent(Context context, int view) {
+//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+//            ankiDroidIntent.setAction(ACTION_UPDATE);
+//            ankiDroidIntent.putExtra(EXTRA_VIEW, view);
+//            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
+//        }
+//
+//
+//        private void showDeckSelectionDialog() {
+//            Intent ankiDroidIntent = new Intent(UpdateService.this, WidgetDialog.class);
+//            ankiDroidIntent.setAction(WidgetDialog.ACTION_SHOW_DECK_SELECTION_DIALOG);
+//            ankiDroidIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | Intent.FLAG_ACTIVITY_NEW_TASK);
+//            startActivity(ankiDroidIntent);
+//        }
+//
+//
+//        @Override
+//        public IBinder onBind(Intent arg0) {
+//            Log.i(AnkiDroidApp.TAG, "onBind");
+//            return null;
+//        }
+//
+//        private static class GetTomorrowDueAsyncTask extends AsyncTask<String, Void, DeckStatus[]> {
+//
+//            @Override
+//            protected DeckStatus[] doInBackground(String... params) {
+//                Log.i(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue");
+//                //
+//                // File dir = new File(params[0]);
+//                // File[] fileList = dir.listFiles(new WidgetStatus.AnkiFileFilter());
+//                //
+//                // DeckStatus[] todayDues = WidgetStatus.fetch(sContext);
+//                //
+//                // ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
+//                //
+//                // for (DeckStatus s : todayDues) {
+//                // try {
+//                // Decks deck = DeckManager.getDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
+//                // if (deck != null) {
+//                // int failedCards = deck.getFailedDelayedCount() + s.mFailedCards;
+//                // int dueCards = deck.getNextDueCards(1) + s.mDueCards;
+//                // int newCards = deck.getNextNewCards() + s.mNewCards;
+//                // decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards,
+//                // deck.getETA(failedCards, dueCards, newCards, true), 0));
+//                // }
+//                // DeckManager.closeDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+//                // } catch (RuntimeException e) {
+//                // Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
+//                // }
+//                // }
+//                // return decks.toArray(new DeckStatus[0]);
+//                return null;
+//            }
+//
+//
+//            @Override
+//            protected void onPostExecute(DeckStatus[] status) {
+//                Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
+//                contentService.mCol = null;
+//                contentService.mCurrentCard = null;
+//                contentService.mBigCurrentMessage = null;
+//                contentService.mWaitForAsyncTask = false;
+//                contentService.mTomorrowDues = status;
+//                if (contentService.mBigShowProgressDialog) {
+//                    contentService.mBigShowProgressDialog = false;
+//                    updateWidget(VIEW_CONGRATS);
+//                }
+//                contentService.mBigShowProgressDialog = false;
+//            }
+//        }
+//    }
+//}
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetSmall.java b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
index 5e81bcd18971..c35a5f6d91dd 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
@@ -131,8 +131,8 @@ public void onReceive(Context context, Intent intent) {
                     // Also compute the total number of cards due.
                     int[] counts = WidgetStatus.fetchSmall(context);
 
-                    dueCardsCount = counts[0];
-                    progress = counts[1];
+                    progress = counts[0];
+                    dueCardsCount = counts[1];
                     eta = counts[2];
                     if (dueCardsCount <= 0) {
                         if (dueCardsCount == 0) {
@@ -147,7 +147,7 @@ public void onReceive(Context context, Intent intent) {
                         updateViews.setViewVisibility(R.id.widget_due, View.VISIBLE);
                         updateViews.setViewVisibility(R.id.widget_progress_frame, View.VISIBLE);
                         updateViews.setTextViewText(R.id.widget_due, Integer.toString(dueCardsCount));
-                        updateViews.setProgressBar(R.id.widget_progress, 100, progress, false);
+                        updateViews.setProgressBar(R.id.widget_progress, 1000, progress, false);
                     }
                     if (eta <= 0 || dueCardsCount <= 0) {
                         updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);
diff --git a/src/com/ichi2/widget/WidgetContentService.java b/src/com/ichi2/widget/WidgetContentService.java
index db776597bb05..f9cf85174759 100644
--- a/src/com/ichi2/widget/WidgetContentService.java
+++ b/src/com/ichi2/widget/WidgetContentService.java
@@ -1,91 +1,91 @@
-
-package com.ichi2.widget;
-
-import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.libanki.Card;
-import com.ichi2.libanki.Collection;
-
-import android.app.Service;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Binder;
-import android.os.IBinder;
-import android.util.Log;
-
-public class WidgetContentService extends Service {
-    private final IBinder widgetContentBinder = new WidgetContentBinder();
-
-    public Collection mCol;
-    public Card mCurrentCard;
-    public boolean mBigShowProgressDialog = false;
-    public int mBigCurrentView = AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED;
-    public String mBigCurrentMessage;
-    public DeckStatus[] mTomorrowDues;
-    public boolean mWaitForAsyncTask = false;
-    public boolean mUpdateStarted = false;
-
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
-        String path = prefs.getString("lastWidgetDeck", "");
-        if (path != null && path.length() > 0 && AnkiDroidApp.isSdCardMounted()) {
-            Log.i(AnkiDroidApp.TAG, "BigWidget: reloading deck " + path);
-            mCol = Collection.currentCollection();
-            if (mCol != null) {
-                mCurrentCard = mCol.getSched().getCard();
-            }
-        }
-    }
-
-
-    @Override
-    public void onDestroy() {
-        // // TODO: this does not seem to be reliably called
-        // String path = "";
-        long cardId = 0l;
-        if (mCol != null) {
-            // path = mLoadedDeck.getDeckPath();
-            // DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-            if (mCurrentCard != null) {
-                cardId = mCurrentCard.getId();
-            }
-        }
-        // PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putString("lastWidgetDeck",
-        // path).commit();
-        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-                .putLong("lastWidgetCard", cardId).commit();
-    }
-
-
-    public void setCard() {
-        if (mCol != null) {
-            setCard(mCol.getSched().getCard());
-        }
-    }
-
-
-    public void setCard(Card card) {
-        mCurrentCard = card;
-        Long cardId = 0l;
-        if (card != null) {
-            cardId = card.getId();
-        }
-        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-                .putLong("lastWidgetCard", cardId).commit();
-    }
-
-
-    @Override
-    public IBinder onBind(Intent arg0) {
-        return widgetContentBinder;
-    }
-
-    public class WidgetContentBinder extends Binder {
-
-        WidgetContentService getService() {
-            return WidgetContentService.this;
-        }
-    }
-}
+//
+//package com.ichi2.widget;
+//
+//import com.ichi2.anki.AnkiDroidApp;
+//import com.ichi2.libanki.Card;
+//import com.ichi2.libanki.Collection;
+//
+//import android.app.Service;
+//import android.content.Intent;
+//import android.content.SharedPreferences;
+//import android.os.Binder;
+//import android.os.IBinder;
+//import android.util.Log;
+//
+//public class WidgetContentService extends Service {
+//    private final IBinder widgetContentBinder = new WidgetContentBinder();
+//
+//    public Collection mCol;
+//    public Card mCurrentCard;
+//    public boolean mBigShowProgressDialog = false;
+//    public int mBigCurrentView = AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED;
+//    public String mBigCurrentMessage;
+//    public DeckStatus[] mTomorrowDues;
+//    public boolean mWaitForAsyncTask = false;
+//    public boolean mUpdateStarted = false;
+//
+//
+//    @Override
+//    public void onCreate() {
+//        super.onCreate();
+//        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
+//        String path = prefs.getString("lastWidgetDeck", "");
+//        if (path != null && path.length() > 0 && AnkiDroidApp.isSdCardMounted()) {
+//            Log.i(AnkiDroidApp.TAG, "BigWidget: reloading deck " + path);
+//            mCol = Collection.currentCollection();
+//            if (mCol != null) {
+//                mCurrentCard = mCol.getSched().getCard();
+//            }
+//        }
+//    }
+//
+//
+//    @Override
+//    public void onDestroy() {
+//        // // TODO: this does not seem to be reliably called
+//        // String path = "";
+//        long cardId = 0l;
+//        if (mCol != null) {
+//            // path = mLoadedDeck.getDeckPath();
+//            // DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+//            if (mCurrentCard != null) {
+//                cardId = mCurrentCard.getId();
+//            }
+//        }
+//        // PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putString("lastWidgetDeck",
+//        // path).commit();
+//        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+//                .putLong("lastWidgetCard", cardId).commit();
+//    }
+//
+//
+//    public void setCard() {
+//        if (mCol != null) {
+//            setCard(mCol.getSched().getCard());
+//        }
+//    }
+//
+//
+//    public void setCard(Card card) {
+//        mCurrentCard = card;
+//        Long cardId = 0l;
+//        if (card != null) {
+//            cardId = card.getId();
+//        }
+//        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+//                .putLong("lastWidgetCard", cardId).commit();
+//    }
+//
+//
+//    @Override
+//    public IBinder onBind(Intent arg0) {
+//        return widgetContentBinder;
+//    }
+//
+//    public class WidgetContentBinder extends Binder {
+//
+//        WidgetContentService getService() {
+//            return WidgetContentService.this;
+//        }
+//    }
+//}
diff --git a/src/com/ichi2/widget/WidgetDialog.java b/src/com/ichi2/widget/WidgetDialog.java
index 774b3bc24ed3..ad2a48e73978 100644
--- a/src/com/ichi2/widget/WidgetDialog.java
+++ b/src/com/ichi2/widget/WidgetDialog.java
@@ -1,143 +1,143 @@
-/***************************************************************************************
- * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
- *                                                                                      *
- * This program is free software; you can redistribute it and/or modify it under        *
- * the terms of the GNU General Public License as published by the Free Software        *
- * Foundation; either version 3 of the License, or (at your option) any later           *
- * version.                                                                             *
- *                                                                                      *
- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
- *                                                                                      *
- * You should have received a copy of the GNU General Public License along with         *
- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
- ****************************************************************************************/
-
-package com.ichi2.widget;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import com.ichi2.anki.AnkiActivity;
-import com.ichi2.anki.DeckPicker;
-import com.ichi2.anki.CardEditor.JSONNameComparator;
-import com.ichi2.anki2.R;
-import com.ichi2.libanki.Collection;
-import com.ichi2.themes.StyledDialog;
-import com.ichi2.themes.Themes;
-
-import android.app.Activity;
-import android.content.DialogInterface;
-import android.content.DialogInterface.OnClickListener;
-import android.content.DialogInterface.OnDismissListener;
-import android.content.res.Resources;
-import android.content.Intent;
-import android.os.Bundle;
-
-public class WidgetDialog extends AnkiActivity {
-
-    public static final String ACTION_SHOW_DECK_SELECTION_DIALOG = "org.ichi2.WidgetDialog.SHOWDECKSELECTIONDIALOG";
-    public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.WidgetDialog.SHOWRESTRICTIONSDIALOG";
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        Themes.applyTheme(this, Themes.THEME_NO_THEME);
-        super.onCreate(savedInstanceState);
-        Intent intent = getIntent();
-        if (intent != null) {
-            String action = intent.getAction();
-            if (action != null) {
-                if (ACTION_SHOW_DECK_SELECTION_DIALOG.equals(action)) {
-                    Collection col = Collection.currentCollection();
-                    if (col == null) {
-                        return;
-                    }
-                    ArrayList<CharSequence> dialogDeckItems = new ArrayList<CharSequence>();
-                    // Use this array to know which ID is associated with each
-                    // Item(name)
-                    final ArrayList<Long> dialogDeckIds = new ArrayList<Long>();
-
-                    ArrayList<JSONObject> decks = col.getDecks().all();
-                    Collections.sort(decks, new JSONNameComparator());
-                    StyledDialog.Builder builder = new StyledDialog.Builder(this);
-                    builder.setTitle(R.string.deck);
-                    for (JSONObject d : decks) {
-                        try {
-                            dialogDeckItems.add(DeckPicker.readableDeckName(d.getString("name").split("::")));
-                            dialogDeckIds.add(d.getLong("id"));
-                        } catch (JSONException e) {
-                            throw new RuntimeException(e);
-                        }
-                    }
-                    // Convert to Array
-                    String[] items = new String[dialogDeckItems.size()];
-                    dialogDeckItems.toArray(items);
-
-                    builder.setItems(items, new DialogInterface.OnClickListener() {
-                        public void onClick(DialogInterface dialog, int item) {
-                            Intent newIntent = new Intent(WidgetDialog.this, AnkiDroidWidgetBig.UpdateService.class);
-                            newIntent.putExtra(DeckPicker.EXTRA_DECK_ID, dialogDeckIds.get(item));
-                            newIntent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_OPENDECK);
-                            startService(newIntent);
-                        }
-                    });
-                    builder.setOnDismissListener(new OnDismissListener() {
-
-                        @Override
-                        public void onDismiss(DialogInterface arg0) {
-                            WidgetDialog.this.finishWithoutAnimation();
-                        }
-
-                    });
-                    builder.show();
-                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
-                    Resources res = getResources();
-                    StyledDialog.Builder builder = new StyledDialog.Builder(this);
-                    builder.setTitle(res.getString(R.string.widget_big))
-                            .setMessage(R.string.widget_big_restrictions_dialog)
-                            .setOnDismissListener(new OnDismissListener() {
-
-                                @Override
-                                public void onDismiss(DialogInterface arg0) {
-                                    WidgetDialog.this.finishWithoutAnimation();
-                                }
-                            }).setPositiveButton(res.getString(R.string.ok), null);
-                    builder.show();
-                }
-            }
-        }
-    }
-
-    public class JSONNameComparator implements Comparator<JSONObject> {
-        @Override
-        public int compare(JSONObject lhs, JSONObject rhs) {
-            String[] o1;
-            String[] o2;
-            try {
-                o1 = lhs.getString("name").split("::");
-                o2 = rhs.getString("name").split("::");
-            } catch (JSONException e) {
-                throw new RuntimeException(e);
-            }
-            for (int i = 0; i < Math.min(o1.length, o2.length); i++) {
-                int result = o1[i].compareToIgnoreCase(o2[i]);
-                if (result != 0) {
-                    return result;
-                }
-            }
-            if (o1.length < o2.length) {
-                return -1;
-            } else if (o1.length > o2.length) {
-                return 1;
-            } else {
-                return 0;
-            }
-        }
-    }
-}
+///***************************************************************************************
+// * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
+// *                                                                                      *
+// * This program is free software; you can redistribute it and/or modify it under        *
+// * the terms of the GNU General Public License as published by the Free Software        *
+// * Foundation; either version 3 of the License, or (at your option) any later           *
+// * version.                                                                             *
+// *                                                                                      *
+// * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+// * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+// * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+// *                                                                                      *
+// * You should have received a copy of the GNU General Public License along with         *
+// * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+// ****************************************************************************************/
+//
+//package com.ichi2.widget;
+//
+//import java.util.ArrayList;
+//import java.util.Collections;
+//import java.util.Comparator;
+//
+//import org.json.JSONException;
+//import org.json.JSONObject;
+//
+//import com.ichi2.anki.AnkiActivity;
+//import com.ichi2.anki.DeckPicker;
+//import com.ichi2.anki.CardEditor.JSONNameComparator;
+//import com.ichi2.anki2.R;
+//import com.ichi2.libanki.Collection;
+//import com.ichi2.themes.StyledDialog;
+//import com.ichi2.themes.Themes;
+//
+//import android.app.Activity;
+//import android.content.DialogInterface;
+//import android.content.DialogInterface.OnClickListener;
+//import android.content.DialogInterface.OnDismissListener;
+//import android.content.res.Resources;
+//import android.content.Intent;
+//import android.os.Bundle;
+//
+//public class WidgetDialog extends AnkiActivity {
+//
+//    public static final String ACTION_SHOW_DECK_SELECTION_DIALOG = "org.ichi2.WidgetDialog.SHOWDECKSELECTIONDIALOG";
+//    public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.WidgetDialog.SHOWRESTRICTIONSDIALOG";
+//
+//
+//    @Override
+//    protected void onCreate(Bundle savedInstanceState) {
+//        Themes.applyTheme(this, Themes.THEME_NO_THEME);
+//        super.onCreate(savedInstanceState);
+//        Intent intent = getIntent();
+//        if (intent != null) {
+//            String action = intent.getAction();
+//            if (action != null) {
+//                if (ACTION_SHOW_DECK_SELECTION_DIALOG.equals(action)) {
+//                    Collection col = Collection.currentCollection();
+//                    if (col == null) {
+//                        return;
+//                    }
+//                    ArrayList<CharSequence> dialogDeckItems = new ArrayList<CharSequence>();
+//                    // Use this array to know which ID is associated with each
+//                    // Item(name)
+//                    final ArrayList<Long> dialogDeckIds = new ArrayList<Long>();
+//
+//                    ArrayList<JSONObject> decks = col.getDecks().all();
+//                    Collections.sort(decks, new JSONNameComparator());
+//                    StyledDialog.Builder builder = new StyledDialog.Builder(this);
+//                    builder.setTitle(R.string.deck);
+//                    for (JSONObject d : decks) {
+//                        try {
+//                            dialogDeckItems.add(DeckPicker.readableDeckName(d.getString("name").split("::")));
+//                            dialogDeckIds.add(d.getLong("id"));
+//                        } catch (JSONException e) {
+//                            throw new RuntimeException(e);
+//                        }
+//                    }
+//                    // Convert to Array
+//                    String[] items = new String[dialogDeckItems.size()];
+//                    dialogDeckItems.toArray(items);
+//
+//                    builder.setItems(items, new DialogInterface.OnClickListener() {
+//                        public void onClick(DialogInterface dialog, int item) {
+//                            Intent newIntent = new Intent(WidgetDialog.this, AnkiDroidWidgetBig.UpdateService.class);
+//                            newIntent.putExtra(DeckPicker.EXTRA_DECK_ID, dialogDeckIds.get(item));
+//                            newIntent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_OPENDECK);
+//                            startService(newIntent);
+//                        }
+//                    });
+//                    builder.setOnDismissListener(new OnDismissListener() {
+//
+//                        @Override
+//                        public void onDismiss(DialogInterface arg0) {
+//                            WidgetDialog.this.finishWithoutAnimation();
+//                        }
+//
+//                    });
+//                    builder.show();
+//                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
+//                    Resources res = getResources();
+//                    StyledDialog.Builder builder = new StyledDialog.Builder(this);
+//                    builder.setTitle(res.getString(R.string.widget_big))
+//                            .setMessage(R.string.widget_big_restrictions_dialog)
+//                            .setOnDismissListener(new OnDismissListener() {
+//
+//                                @Override
+//                                public void onDismiss(DialogInterface arg0) {
+//                                    WidgetDialog.this.finishWithoutAnimation();
+//                                }
+//                            }).setPositiveButton(res.getString(R.string.ok), null);
+//                    builder.show();
+//                }
+//            }
+//        }
+//    }
+//
+//    public class JSONNameComparator implements Comparator<JSONObject> {
+//        @Override
+//        public int compare(JSONObject lhs, JSONObject rhs) {
+//            String[] o1;
+//            String[] o2;
+//            try {
+//                o1 = lhs.getString("name").split("::");
+//                o2 = rhs.getString("name").split("::");
+//            } catch (JSONException e) {
+//                throw new RuntimeException(e);
+//            }
+//            for (int i = 0; i < Math.min(o1.length, o2.length); i++) {
+//                int result = o1[i].compareToIgnoreCase(o2[i]);
+//                if (result != 0) {
+//                    return result;
+//                }
+//            }
+//            if (o1.length < o2.length) {
+//                return -1;
+//            } else if (o1.length > o2.length) {
+//                return 1;
+//            } else {
+//                return 0;
+//            }
+//        }
+//    }
+//}
diff --git a/src/com/ichi2/widget/WidgetStatus.java b/src/com/ichi2/widget/WidgetStatus.java
index e759305f3a2a..7017feb1663b 100644
--- a/src/com/ichi2/widget/WidgetStatus.java
+++ b/src/com/ichi2/widget/WidgetStatus.java
@@ -50,6 +50,7 @@ public final class WidgetStatus {
     private static boolean notification = false;
 
     private static DeckStatus sDeckStatus;
+    private static float[] sSmallWidgetStatus;
     private static AsyncTask<Context, Void, Context> sUpdateDeckStatusAsyncTask;
 
 
@@ -60,18 +61,24 @@ private WidgetStatus() {
 
     /** Request the widget to update its status. */
     public static void update(Context context) {
-        update(context, null);
+        update(context, true);
     }
 
 
     /** Request the widget to update its status. */
     public static void update(Context context, DeckStatus deckStatus) {
-        update(context, deckStatus, true);
+        sDeckStatus = deckStatus;
+        update(context);
     }
 
 
-    public static void update(Context context, DeckStatus deckStatus, boolean updateBigWidget) {
-        sDeckStatus = deckStatus;
+    public static void update(Context context, float[] smallWidgetStatus) {
+    	sSmallWidgetStatus = smallWidgetStatus;
+        update(context);
+    }
+
+
+    public static void update(Context context, boolean updateBigWidget) {
         SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
         if (preferences.getBoolean("widgetMediumEnabled", false)) {
             mediumWidget = true;
@@ -160,6 +167,7 @@ private static class UpdateDeckStatusAsyncTask extends AsyncTask<Context, Void,
         private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];
 
         private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;
+        private static float[] mSmallWidgetStatus = new float[]{0, 0, 0, 0};
 
 
         @Override
@@ -172,7 +180,7 @@ protected Context doInBackground(Context... params) {
             }
 
             // For the deck information
-            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
+//            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
 
             // if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
             // decks = new ArrayList<DeckStatus>(mDecks.length);
@@ -190,35 +198,47 @@ protected Context doInBackground(Context... params) {
             // }
             // } else {
             try {
-                Collection col = Collection.currentCollection();
-                Object[] di;
-                float progress;
-                if (col == null) {
-                    col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
-                    di = col.getSched().deckCounts();
-                    progress = col.getSched().todaysProgress(null, true, true);
-                    col.close(false);
-                } else {
-                    di = col.getSched().deckCounts();
-                    progress = col.getSched().todaysProgress(null, true, true);
-                }
-                int eta = (Integer) di[1];
-                for (Object[] d : (TreeSet<Object[]>) di[0]) {
-                    String[] sname = (String[]) d[0];
-                    StringBuilder name = new StringBuilder();
-                    name.append(sname[0]);
-                    for (int i = 1; i < sname.length; i++) {
-                        name.append("::").append(sname[i]);
+            	if (sSmallWidgetStatus == null) {
+                    Collection col = Collection.currentCollection();
+                    if (col == null) {
+                        col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
+                        mSmallWidgetStatus = col.getSched().progressToday(null, null, true);
+                        col.close(false);
+                    } else {
+                        mSmallWidgetStatus = col.getSched().progressToday(null, null, true);                    	
                     }
-                    decks.add(new DeckStatus((Long) d[1], name.toString(), (Integer) d[2], (Integer) d[3],
-                            (Integer) d[4], (int) (progress * 100), eta));
-                }
+            	} else {
+            		mSmallWidgetStatus = sSmallWidgetStatus;
+            	}
+//                Collection col = Collection.currentCollection();              
+//                Object[] di;
+//                float progress;
+//                if (col == null) {
+//                    col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
+//                    di = col.getSched().deckCounts();
+//                    progress = col.getSched().todaysProgress(null, true, true);
+//                    col.close(false);
+//                } else {
+//                    di = col.getSched().deckCounts();
+//                    progress = col.getSched().progressTodayAll(di);
+//                }
+//                int eta = (Integer) di[1];
+//                for (Object[] d : (TreeSet<Object[]>) di[0]) {
+//                    String[] sname = (String[]) d[0];
+//                    StringBuilder name = new StringBuilder();
+//                    name.append(sname[0]);
+//                    for (int i = 1; i < sname.length; i++) {
+//                        name.append("::").append(sname[i]);
+//                    }
+//                    decks.add(new DeckStatus((Long) d[1], name.toString(), (Integer) d[2], (Integer) d[3],
+//                            (Integer) d[4], (int) (progress * 100), eta));
+//                }
             } catch (SQLException e) {
                 Log.i(AnkiDroidApp.TAG, "Widget: Problems on retrieving deck information");
             }
-            // }
-
-            mDecks = decks.toArray(EMPTY_DECK_STATUS);
+//             }
+//
+//            mDecks = decks.toArray(EMPTY_DECK_STATUS);
             return context;
         }
 
@@ -226,24 +246,25 @@ protected Context doInBackground(Context... params) {
         @Override
         protected void onPostExecute(Context context) {
             Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()");
-            MetaDB.storeWidgetStatus(context, mDecks);
-            if (mediumWidget) {
-                Intent intent;
-                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
-                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
-                context.startService(intent);
-            }
+            MetaDB.storeSmallWidgetStatus(context, mSmallWidgetStatus);
+//            MetaDB.storeWidgetStatus(context, mDecks);
+//            if (mediumWidget) {
+//                Intent intent;
+//                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
+//                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
+//                context.startService(intent);
+//            }
             if (smallWidget) {
                 Intent intent;
                 intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);
                 context.startService(intent);
             }
-            if (bigWidget) {
-                Intent intent;
-                intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-                intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
-                context.startService(intent);
-            }
+//            if (bigWidget) {
+//                Intent intent;
+//                intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
+//                intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
+//                context.startService(intent);
+//            }
             if (notification) {
                 Intent intent;
                 intent = new Intent(context, NotificationService.class);
