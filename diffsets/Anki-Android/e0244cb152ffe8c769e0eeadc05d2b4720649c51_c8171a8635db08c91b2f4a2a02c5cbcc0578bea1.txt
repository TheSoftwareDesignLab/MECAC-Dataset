diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index 42e1072f8960..dcf8f63d5289 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -758,7 +758,7 @@ private void closeDeckPicker(boolean backPressed) {
 
 	private void enableButtons(boolean enabled) {
 		if (enabled) {
-			if (!PrefSettings.getSharedPrefs(getBaseContext()).getInt("walWarning", AnkiDb.NO_WAL_WARNING) == AnkiDb.NO_WAL_WARNING)) {
+			if (!(PrefSettings.getSharedPrefs(getBaseContext()).getInt("walWarning", AnkiDb.NO_WAL_WARNING) == AnkiDb.NO_WAL_WARNING)) {
 				mSyncAllButton.setVisibility(View.GONE);
 			}
 			mDeckpickerButtons.setVisibility(View.VISIBLE);
diff --git a/src/com/ichi2/anki/FactAdder.java b/src/com/ichi2/anki/FactAdder.java
index 11d8357784c8..f1e2f1acef92 100644
--- a/src/com/ichi2/anki/FactAdder.java
+++ b/src/com/ichi2/anki/FactAdder.java
@@ -453,6 +453,7 @@ private void loadDeck(int item) {
 		if (mDeck == null) {
 			Themes.showThemedToast(FactAdder.this, getResources().getString(R.string.fact_adder_deck_not_loaded), true);
 		} else {
+			setTitle(mDeckNames[item]);
 			loadContents();
 		}
     }
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index e59872eca94b..4897ff936d35 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -933,6 +933,7 @@ public void onConfigurationChanged(Configuration newConfig) {
 
         long savedTimer = mCardTimer.getBase();
         CharSequence savedAnswerField = mAnswerField.getText();
+        boolean cardVisible = mCardContainer.getVisibility() == View.VISIBLE;
 
         // Reload layout
         initLayout(R.layout.flashcard);
@@ -963,15 +964,23 @@ public void onConfigurationChanged(Configuration newConfig) {
         // Also skipping the counts (because we don't know which one to underline)
         // They will be updated when the card loads anyway
         if (mCurrentCard != null) {
-            fillFlashcard(false);
+        	if (cardVisible) {
+                fillFlashcard(false);
+                if (mPrefTimer) {
+                    mCardTimer.setBase(savedTimer);
+                    mCardTimer.start();
+                }        		
+        		if (sDisplayAnswer) {
+        			updateForNewCard();
+            	}
+        	} else {
+        		mCardContainer.setVisibility(View.INVISIBLE);
+        		switchVisibility(mProgressBars, View.INVISIBLE);
+        		switchVisibility(mCardTimer, View.INVISIBLE);
+        	}
     		if (sDisplayAnswer) {
-    			updateForNewCard();
         		showEaseButtons();
         	}
-            if (mPrefTimer) {
-                mCardTimer.setBase(savedTimer);
-                mCardTimer.start();
-            }
         }
 
         mConfigurationChanged = false;
@@ -1105,11 +1114,13 @@ public boolean onOptionsItemSelected(MenuItem item) {
             	return editCard();
 
             case MENU_REMOVE_BURY:
+            	setNextCardAnimation(false);
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                         AnkiDroidApp.deck(), mCurrentCard));
                 return true;
 
             case MENU_REMOVE_SUSPEND:
+            	setNextCardAnimation(false);
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                         AnkiDroidApp.deck(), mCurrentCard));
                 return true;
@@ -1319,6 +1330,7 @@ private void showDeleteCardDialog() {
                 new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
+                    	setNextCardAnimation(false);
                         DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mDismissCardHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), mCurrentCard));
                     }
                 });
@@ -2043,7 +2055,7 @@ public void fillFlashcard(boolean flip) {
     		boolean directionToLeft = true;
     		switch (mNextAnimation) {
     		case ANIMATION_TURN:
-    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 5, Animation3D.ANIMATION_TURN, true, true, this);
+    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 9, Animation3D.ANIMATION_TURN, true, true, this);
     			rotation.setDuration(mAnimationDurationTurn);
     			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
     			break;
@@ -2628,10 +2640,12 @@ private void executeCommand(int which) {
     		lookUp();
     		break;
     	case GESTURE_BURY:
+        	setNextCardAnimation(false);
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                     AnkiDroidApp.deck(), mCurrentCard));
     		break;
     	case GESTURE_SUSPEND:
+        	setNextCardAnimation(false);
     		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                     AnkiDroidApp.deck(), mCurrentCard));
     		break;
