diff --git a/src/com/ichi2/anki/AnkiDb.java b/src/com/ichi2/anki/AnkiDb.java
index 7e5468d07c67..8ef0f1acdb15 100644
--- a/src/com/ichi2/anki/AnkiDb.java
+++ b/src/com/ichi2/anki/AnkiDb.java
@@ -48,6 +48,7 @@ static public void closeDatabase()
 		if (database != null)
 		{
 			database.close();
+			database = null;
 		}
 	}
 
diff --git a/src/com/ichi2/anki/Ankidroid.java b/src/com/ichi2/anki/Ankidroid.java
index 7a5c995f3d94..3f40a8868728 100644
--- a/src/com/ichi2/anki/Ankidroid.java
+++ b/src/com/ichi2/anki/Ankidroid.java
@@ -16,12 +16,9 @@
 import android.content.SharedPreferences.Editor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
-import android.database.CursorIndexOutOfBoundsException;
 import android.database.SQLException;
 import android.os.Bundle;
 import android.os.Environment;
-import android.os.Handler;
-import android.os.Message;
 import android.os.SystemClock;
 import android.os.Vibrator;
 import android.preference.PreferenceManager;
@@ -44,7 +41,7 @@
  * @author Andrew Dubya, Nicolas Raoul, Edu Zamora
  * 
  */
-public class Ankidroid extends Activity implements Runnable
+public class Ankidroid extends Activity// implements Runnable
 {
 
 	/**
@@ -188,27 +185,41 @@ public void onCheckedChanged(CompoundButton btn, boolean state)
 	{
 		public void onClick(View view)
 		{
+			int ease;
 			switch (view.getId())
 			{
 			case R.id.ease1:
+				ease = 1;
 				if (corporalPunishments)
 				{
 					Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
 					v.vibrate(500);
 				}
-				deck.answerCard(currentCard, 1);
 				break;
 			case R.id.ease2:
-				deck.answerCard(currentCard, 2);
+				ease = 2;
 				break;
 			case R.id.ease3:
-				deck.answerCard(currentCard, 3);
+				ease = 3;
 				break;
 			case R.id.ease4:
-				deck.answerCard(currentCard, 4);
+				ease = 4;
 				break;
+			default:
+				ease = 0;
+				return;
 			}
-			nextCard();
+//			long start = System.currentTimeMillis();
+//			deck.answerCard(currentCard, ease);
+//			long stop = System.currentTimeMillis();
+//			Log.v(TAG, "mSelectEaseHandler.onClick - Answered card in " + (stop - start) + " ms.");
+			
+			//nextCard(ease);
+			
+			DeckTask.launchDeckTask(
+					DeckTask.TASK_TYPE_ANSWER_CARD,
+					mAnswerCardHandler,
+					new DeckTask.TaskData(ease, deck, currentCard));
 		}
 	};
 	
@@ -464,9 +475,13 @@ private void displayProgressDialogAndLoadDeck()
 			if (deckFilename != null && new File(deckFilename).exists())
 			{
 				showControls(false);
-				dialog = ProgressDialog.show(this, "", "Loading deck. Please wait...", true);
-				Thread thread = new Thread(this);
-				thread.start();
+//				dialog = ProgressDialog.show(this, "", "Loading deck. Please wait...", true);
+//				Thread thread = new Thread(this);
+//				thread.start();
+				DeckTask.launchDeckTask(
+						DeckTask.TASK_TYPE_LOAD_DECK,
+						mLoadDeckHandler,
+						new DeckTask.TaskData(deckFilename));
 			}
 			else
 			{
@@ -487,75 +502,76 @@ private void displayProgressDialogAndLoadDeck()
 
 	}
 
-	public void run()
-	{
-		Log.i(TAG, "Ankidroid loader thread - run");
-		handler.sendEmptyMessage(loadDeck(deckFilename));
-	}
+//	public void run()
+//	{
+//		Log.i(TAG, "Ankidroid loader thread - run");
+//		handler.sendEmptyMessage(loadDeck(deckFilename));
+//	}
 
-	public int loadDeck(String deckFilename)
-	{
-		Log.i(TAG, "loadDeck - deckFilename = " + deckFilename);
-		this.deckFilename = deckFilename;
-		
-		Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
-		try
-		{
-			// Open the right deck.
-			//AnkiDb.openDatabase(deckFilename);
-			deck = Deck.openDeck(deckFilename);
-			// Start by getting the first card and displaying it.
-			nextCard();
-			Log.i(TAG, "Deck loaded!");
-			return DECK_LOADED;
-		} catch (SQLException e)
-		{
-			Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
-			return DECK_NOT_LOADED;
-		} catch (CursorIndexOutOfBoundsException e)
-		{
-			Log.i(TAG, "The deck has no cards = " + e.getMessage());;
-			return DECK_EMPTY;
-		}
-	}
+//	public int loadDeck(String deckFilename)
+//	{
+//		Log.i(TAG, "loadDeck - deckFilename = " + deckFilename);
+//		this.deckFilename = deckFilename;
+//		
+//		Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
+//		try
+//		{
+//			// Open the right deck.
+//			//AnkiDb.openDatabase(deckFilename);
+//			deck = Deck.openDeck(deckFilename);
+//			// Start by getting the first card and displaying it.
+//			//nextCard(0);
+//			Log.i(TAG, "Deck loaded!");
+//			return DECK_LOADED;
+//		} catch (SQLException e)
+//		{
+//			Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
+//			return DECK_NOT_LOADED;
+//		} catch (CursorIndexOutOfBoundsException e)
+//		{
+//			Log.i(TAG, "The deck has no cards = " + e.getMessage());;
+//			return DECK_EMPTY;
+//		}
+//	}
 
 
-	private Handler handler = new Handler()
-	{
-		public void handleMessage(Message msg)
-		{	
-			//This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
-			if(dialog.isShowing()) 
-			{
-				try
-				{
-					dialog.dismiss();
-				} catch(Exception e)
-				{
-					Log.e(TAG, "handleMessage - Dialog dismiss Exception = " + e.getMessage());
-				}
-				
-			}
-			
-			switch(msg.what)
-			{
-
-				case DECK_LOADED:
-					showControls(true);
-					deckLoaded = true;
-					displayCardQuestion();
-					break;
-					
-				case DECK_NOT_LOADED:
-					displayDeckNotLoaded();
-					break;
-				
-				case DECK_EMPTY:
-					displayNoCardsInDeck();
-					break;
-			}
-		}
-	};
+//	private Handler handler = new Handler()
+//	{
+//		public void handleMessage(Message msg)
+//		{	
+//			//This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
+//			if(dialog.isShowing()) 
+//			{
+//				try
+//				{
+//					dialog.dismiss();
+//				} catch(Exception e)
+//				{
+//					Log.e(TAG, "handleMessage - Dialog dismiss Exception = " + e.getMessage());
+//				}
+//				
+//			}
+//			nextCard(0);
+//			
+//			switch(msg.what)
+//			{
+//
+//				case DECK_LOADED:
+//					showControls(true);
+//					deckLoaded = true;
+//					displayCardQuestion();
+//					break;
+//					
+//				case DECK_NOT_LOADED:
+//					displayDeckNotLoaded();
+//					break;
+//				
+//				case DECK_EMPTY:
+//					displayNoCardsInDeck();
+//					break;
+//			}
+//		}
+//	};
 	
 	@Override
 	protected void onActivityResult(int requestCode, int resultCode, Intent intent)
@@ -682,33 +698,63 @@ public void setOverlayState(boolean enabled)
 	}
 
 	// Get the next card.
-	public void nextCard()
-	{
-		Log.i(TAG, "nextCard");
+//	public void nextCard(int ease)
+//	{
+//		Log.i(TAG, "nextCard");
+//		long start, stop;
 //		if (spacedRepetition)
 //			currentCard = AnkiDb.Card.smallestIntervalCard();
 //		else
 //			currentCard = AnkiDb.Card.randomCard();
 
-		currentCard = deck.getCard();
-		
-		// Set the correct value for the flip card button - That triggers the
-		// listener which displays the question of the card
-		mFlipCard.setChecked(false);
-		mWhiteboard.clear();
-		mTimer.setBase(SystemClock.elapsedRealtime());
-		mTimer.start();
-	}
+		// Store away the current card to answer after the new card has been loaded.
+		// In order for it to not appear again as the new card, we temporarily set its
+		// priority to 0.
+//		Card oldCard = currentCard;
+//		if (oldCard != null)
+//		{
+//			start = System.currentTimeMillis();
+//			oldCard.temporarilySetLowestPriority();
+//			stop = System.currentTimeMillis();
+//			Log.v(TAG, "nextCard - Set old card 0 priority in " + (stop - start) + " ms.");
+//		}
+//		
+//		start = System.currentTimeMillis();
+//		currentCard = deck.getCard();
+//		stop = System.currentTimeMillis();
+//		
+//		Log.v(TAG, "nextCard - Loaded new card in " + (stop - start) + " ms.");
+//		
+//		// Set the correct value for the flip card button - That triggers the
+//		// listener which displays the question of the card
+//		mFlipCard.setChecked(false);
+//		mWhiteboard.clear();
+//		mTimer.setBase(SystemClock.elapsedRealtime());
+//		mTimer.start();
+//		
+//		if (ease != 0 && oldCard != null)
+//		{
+//			start = System.currentTimeMillis();
+//			deck.answerCard(oldCard, ease);
+//			stop = System.currentTimeMillis();
+//			Log.v(TAG, "nextCard - Answered old card in " + (stop - start) + " ms.");
+//		}
+//		task = launchDeckTask(
+//				deck,
+//				DeckTask.TASK_TYPE_ANSWER_CARD,
+//				new TaskData(ease));
+//		
+//	}
 
 	// Set up the display for the current card.
 	public void displayCardQuestion()
 	{
 		Log.i(TAG, "displayCardQuestion");
 
-		if (currentCard == null)
-		{
-			nextCard();
-		}
+//		if (currentCard == null)
+//		{
+//			nextCard();
+//		}
 
 		if (currentCard == null)
 		{
@@ -934,4 +980,377 @@ private void displayNoCardsInDeck()
 	{
 		showDialog(DIALOG_UPDATE);
 	}*/
+	
+//	private DeckTask launchDeckTask(Deck deck, Card cardToAnswer, int type, DeckTask.TaskData... params)
+//	{
+//		try
+//		{
+//		if ((task != null) && (task.getStatus() != AsyncTask.Status.FINISHED))
+//			task.get();
+//		} catch (Exception e)
+//		{
+//			e.printStackTrace();
+//		}
+//		
+//		switch (type)
+//		{
+//		case DeckTask.TASK_TYPE_LOAD_DECK:
+//			return (DeckTask) new DeckTask(null, null, type, mLoadDeckHandler).execute(params);
+//		case DeckTask.TASK_TYPE_ANSWER_CARD:
+//			return (DeckTask) new DeckTask(deck, cardToAnswer, type, mAnswerCardHandler).execute(params);
+//		default:
+//			return null;
+//		}
+//	}
+	
+	DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener()
+	{
+		
+		@Override
+		public void onPreExecute() {
+			dialog = ProgressDialog.show(Ankidroid.this, "", "Loading new card...", true);
+		}
+		
+		@Override
+		public void onPostExecute(DeckTask.TaskData result) {
+			// Pass
+		}
+		
+		@Override
+		public void onProgressUpdate(DeckTask.TaskData... values) {
+			Card newCard = values[0].getCard();
+			
+			currentCard = newCard;
+			
+			// Set the correct value for the flip card button - That triggers the
+			// listener which displays the question of the card
+			mFlipCard.setChecked(false);
+			mWhiteboard.clear();
+			mTimer.setBase(SystemClock.elapsedRealtime());
+			mTimer.start();
+			
+			dialog.dismiss();
+		}
+		
+	};
+	
+	DeckTask.TaskListener mLoadDeckHandler = new DeckTask.TaskListener() 
+	{
+		
+		@Override
+		public void onPreExecute() {
+			dialog = ProgressDialog.show(Ankidroid.this, "", "Loading deck. Please wait...", true);
+		}
+		
+		@Override
+		public void onPostExecute(DeckTask.TaskData result) {
+			// This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
+			if(dialog.isShowing()) 
+			{
+				try
+				{
+					dialog.dismiss();
+				} catch(Exception e)
+				{
+					Log.e(TAG, "handleMessage - Dialog dismiss Exception = " + e.getMessage());
+				}
+			}
+			
+			switch(result.getInt())
+			{
+				case DECK_LOADED:
+					deck = result.getDeck();
+					currentCard = result.getCard();
+					showControls(true);
+					deckLoaded = true;
+					displayCardQuestion();
+					break;
+					
+				case DECK_NOT_LOADED:
+					displayDeckNotLoaded();
+					break;
+				
+				case DECK_EMPTY:
+					displayNoCardsInDeck();
+					break;
+			}
+		}
+		
+		@Override
+		public void onProgressUpdate(DeckTask.TaskData... values) {
+			// Pass
+		}
+		
+	};
+	
+//	public static class DeckTask extends AsyncTask<TaskData, TaskData, TaskData>
+//	{
+//		public static final int TASK_TYPE_LOAD_DECK = 0;
+//		public static final int TASK_TYPE_ANSWER_CARD = 1;
+//		int type;
+//		Deck deck;
+//		Card oldCard;
+//		TaskListener listener;
+//		
+//		public DeckTask(Deck deck, int type, TaskListener listener)
+//		{
+//			this.deck = deck;
+//			this.type = type;
+//			this.listener = listener;
+//		}
+//		
+//		public DeckTask(Deck deck, Card cardToAnswer, int type, TaskListener listener)
+//		{
+//			this(deck, type, listener);
+//			this.oldCard = cardToAnswer;
+//		}
+//
+//		@Override
+//		protected TaskData doInBackground(TaskData... params)
+//		{
+//			switch (type)
+//			{
+//			case TASK_TYPE_LOAD_DECK:
+//				return doInBackgroundLoadDeck(params);
+//			case TASK_TYPE_ANSWER_CARD:
+//				return doInBackgroundAnswerCard(params);
+//			default:
+//				return null;
+//			}
+//		}
+//		
+//		@Override
+//		protected void onPreExecute()
+//		{
+//			listener.onPreExecute();
+////			switch (type)
+////			{
+////			case TASK_TYPE_LOAD_DECK:
+////				onPreExecuteLoadDeck();
+////			case TASK_TYPE_ANSWER_CARD:
+////				onPreExecuteAnswerCard();
+////				break;
+////			default:
+////				break;
+////			}
+//		}
+//		
+//		@Override
+//		protected void onProgressUpdate(TaskData... values)
+//		{
+//			listener.onProgressUpdate(values);
+////			switch (type)
+////			{
+////			case TASK_TYPE_ANSWER_CARD:
+////				onProgressUpdateAnswerCard(values);
+////				break;
+////			default:
+////				break;
+////			}
+//		}
+//		
+//		@Override
+//		protected void onPostExecute(TaskData result)
+//		{
+//			listener.onPostExecute(result);
+////			switch (type)
+////			{
+////			case TASK_TYPE_LOAD_DECK:
+////				onPostExecuteLoadDeck(result);
+////				break;
+////			default:
+////				break;
+////			}
+//		}
+//		
+////		private void onPreExecuteAnswerCard()
+////		{
+////			oldCard = Ankidroid.this.currentCard;
+////			dialog = ProgressDialog.show(Ankidroid.this, "", "Loading new card...", true);
+////		}
+//		
+//		private TaskData doInBackgroundAnswerCard(TaskData... params)
+//		{
+//			long start, stop;
+//			Card newCard;
+//			int ease = params[0].getInt();
+//			
+//			if (oldCard != null)
+//			{
+//				start = System.currentTimeMillis();
+//				oldCard.temporarilySetLowestPriority();
+//				stop = System.currentTimeMillis();
+//				Log.v(TAG, "doInBackground - Set old card 0 priority in " + (stop - start) + " ms.");
+//			}
+//			
+//			start = System.currentTimeMillis();
+//			newCard = this.deck.getCard();
+//			stop = System.currentTimeMillis();
+//			Log.v(TAG, "doInBackground - Loaded new card in " + (stop - start) + " ms.");
+//			publishProgress(new TaskData(newCard));
+//			
+//			if (ease != 0 && oldCard != null)
+//			{
+//				start = System.currentTimeMillis();
+//				this.deck.answerCard(oldCard, ease);
+//				stop = System.currentTimeMillis();
+//				Log.v(TAG, "doInBackground - Answered old card in " + (stop - start) + " ms.");
+//			}
+//			
+//			return null;
+//		}
+//		
+////		private void onProgressUpdateAnswerCard(TaskData... values)
+////		{
+////			Card newCard = values[0].getCard();
+////			
+////			Ankidroid.this.currentCard = newCard;
+////			
+////			// Set the correct value for the flip card button - That triggers the
+////			// listener which displays the question of the card
+////			Ankidroid.this.mFlipCard.setChecked(false);
+////			Ankidroid.this.mWhiteboard.clear();
+////			Ankidroid.this.mTimer.setBase(SystemClock.elapsedRealtime());
+////			Ankidroid.this.mTimer.start();
+////			
+////			dialog.dismiss();
+////		}
+//		
+////		private void onPreExecuteLoadDeck()
+////		{
+////			dialog = ProgressDialog.show(Ankidroid.this, "", "Loading deck. Please wait...", true);
+////		}
+//		
+//		private TaskData doInBackgroundLoadDeck(TaskData... params)
+//		{
+//			String deckFilename = params[0].getString();
+//			Log.i(TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
+//			
+//			Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
+//			try
+//			{
+//				// Open the right deck.
+//				//AnkiDb.openDatabase(deckFilename);
+//				Deck deck = Deck.openDeck(deckFilename);
+//				// Start by getting the first card and displaying it.
+//				//nextCard(0);
+//				Card card = deck.getCard();
+//				Log.i(TAG, "Deck loaded!");
+//				
+//				return new TaskData(Ankidroid.DECK_LOADED, deck, card);
+//			} catch (SQLException e)
+//			{
+//				Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
+//				return new TaskData(Ankidroid.DECK_NOT_LOADED);
+//			} catch (CursorIndexOutOfBoundsException e)
+//			{
+//				Log.i(TAG, "The deck has no cards = " + e.getMessage());;
+//				return new TaskData(Ankidroid.DECK_EMPTY);
+//			}
+//		}
+//		
+////		private void onPostExecuteLoadDeck(TaskData result)
+////		{
+////			// This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
+////			if(dialog.isShowing()) 
+////			{
+////				try
+////				{
+////					dialog.dismiss();
+////				} catch(Exception e)
+////				{
+////					Log.e(TAG, "handleMessage - Dialog dismiss Exception = " + e.getMessage());
+////				}
+////			}
+////			
+////			switch(result.getInt())
+////			{
+////				case DECK_LOADED:
+////					showControls(true);
+////					deckLoaded = true;
+////					displayCardQuestion();
+////					break;
+////					
+////				case DECK_NOT_LOADED:
+////					displayDeckNotLoaded();
+////					break;
+////				
+////				case DECK_EMPTY:
+////					displayNoCardsInDeck();
+////					break;
+////			}
+////		}
+//		
+//		public static interface TaskListener
+//		{
+//			public void onPreExecute();
+//			
+//			public void onPostExecute(TaskData result);
+//			
+//			public void onProgressUpdate(TaskData... values);
+//		}
+//		
+//		public static class TaskData
+//		{
+//			private Deck deck;
+//			private Card card;
+//			private int integer;
+//			private String msg;
+//			
+//			public TaskData(int value, Deck deck, Card card)
+//			{
+//				this(value);
+//				this.deck = deck;
+//				this.card = card;
+//			}
+//			
+//			public TaskData(Card card)
+//			{
+//				this.card = card;
+//			}
+//			
+//			public TaskData(int value)
+//			{
+//				this.integer = value;
+//			}
+//			
+//			public TaskData(String msg)
+//			{
+//				this.msg = msg;
+//			}
+//			
+////			public void putCard(Card card)
+////			{
+////				this.card = card;
+////			}
+////			
+////			public void putInt(int value)
+////			{
+////				this.integer = value;
+////			}
+//			
+//			public Deck getDeck()
+//			{
+//				return deck;
+//			}
+//			
+//			public Card getCard()
+//			{
+//				return card;
+//			}
+//			
+//			public int getInt()
+//			{
+//				return integer;
+//			}
+//			
+//			public String getString()
+//			{
+//				return msg;
+//			}
+//			
+//		}
+//		
+//	}
+	
 }
\ No newline at end of file
diff --git a/src/com/ichi2/anki/Card.java b/src/com/ichi2/anki/Card.java
index c38a195807a0..a1f0739d319b 100644
--- a/src/com/ichi2/anki/Card.java
+++ b/src/com/ichi2/anki/Card.java
@@ -4,10 +4,10 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Random;
-import java.util.TreeSet;
 
 import android.content.ContentValues;
 import android.database.Cursor;
+import android.database.sqlite.SQLiteStatement;
 import android.util.Log;
 
 public class Card {
@@ -18,8 +18,8 @@ public class Card {
 	long id; // Primary key
 	long factId; // Foreign key facts.id
 	long cardModelId; // Foreign key cardModels.id
-	float created = System.currentTimeMillis() / 1000f;
-	float modified = System.currentTimeMillis() / 1000f;
+	double created = System.currentTimeMillis() / 1000.0;
+	double modified = System.currentTimeMillis() / 1000.0;
 	String tags = "";
 	int ordinal;
 	// Cached - changed on fact update
@@ -28,18 +28,18 @@ public class Card {
 	// Default to 'normal' priority
 	// This is indexed in deck.java as we need to create a reverse index
 	int priority = 2;
-	float interval = 0;
-	float lastInterval = 0;
-	float due = System.currentTimeMillis() / 1000f;
-	float lastDue = 0;
-	float factor = 2.5f;
-	float lastFactor = 2.5f;
-	float firstAnswered = 0;
+	double interval = 0;
+	double lastInterval = 0;
+	double due = System.currentTimeMillis() / 1000.0;
+	double lastDue = 0;
+	double factor = 2.5;
+	double lastFactor = 2.5;
+	double firstAnswered = 0;
 	// Stats
 	int reps = 0;
 	int successive = 0;
-	float averageTime = 0;
-	float reviewTime = 0;
+	double averageTime = 0;
+	double reviewTime = 0;
 	int youngEase0 = 0;
 	int youngEase1 = 0;
 	int youngEase2 = 0;
@@ -54,11 +54,11 @@ public class Card {
 	// data to the above
 	int yesCount = 0;
 	int noCount = 0;
-	float spaceUntil = 0;
-	float relativeDelay = 0;
+	double spaceUntil = 0;
+	double relativeDelay = 0;
 	int isDue = 0;
 	int type = 2;
-	float combinedDue = 0;
+	double combinedDue = 0;
 	// END SQL table entries
 	
 	// BEGIN JOINed variables
@@ -66,20 +66,22 @@ public class Card {
 	Fact fact;
 	// END JOINed variables
 	
-	float timerStarted;
-	float timerStopped;
-	float fuzz;
+	double timerStarted;
+	double timerStopped;
+	double fuzz;
 	
-	public Card(Fact fact, CardModel cardModel, float created) {
+	static SQLiteStatement updateStmt;
+	
+	public Card(Fact fact, CardModel cardModel, double created) {
 		tags = "";
 		id = Util.genID();
 		// New cards start as new & due
 		type = 2;
 		isDue = 1;
-		timerStarted = Float.NaN;
-		timerStopped = Float.NaN;
-		modified = System.currentTimeMillis() / 1000f;
-		if (created != Float.NaN) {
+		timerStarted = Double.NaN;
+		timerStopped = Double.NaN;
+		modified = System.currentTimeMillis() / 1000.0;
+		if (created != Double.NaN) {
 			this.created = created;
 			this.due = created;
 		}
@@ -103,38 +105,82 @@ public Card(Fact fact, CardModel cardModel, float created) {
 			question = qa.get("question");
 			answer = qa.get("answer");
 		}
+		
+		if (updateStmt == null)
+		{
+			updateStmt = AnkiDb.database.compileStatement(
+					"UPDATE cards " +
+					"SET factId = ?, " +
+					"cardModelId = ?, " +
+					"created = ?, " +
+					"modified = ?, " +
+					"tags = ?, " +
+					"ordinal = ?, " +
+					"question = ?, " +
+					"answer = ?, " +
+					"priority = ?, " +
+					"interval = ?, " +
+					"lastInterval = ?, " +
+					"due = ?, " +
+					"lastDue = ?, " +
+					"factor = ?, " +
+					"lastFactor = ?, " +
+					"firstAnswered = ?, " +
+					"reps = ?, " +
+					"successive = ?, " +
+					"averageTime = ?, " +
+					"reviewTime = ?, " +
+					"youngEase0 = ?, " +
+					"youngEase1 = ?, " +
+					"youngEase2 = ?, " +
+					"youngEase3 = ?, " +
+					"youngEase4 = ?, " +
+					"matureEase0 = ?, " +
+					"matureEase1 = ?, " +
+					"matureEase2 = ?, " +
+					"matureEase3 = ?, " +
+					"matureEase4 = ?, " +
+					"yesCount = ?, " +
+					"noCount = ?, " +
+					"spaceUntil = ?, " +
+					"relativeDelay = 0, " +
+					"isDue = ?, " +
+					"type = ?, " +
+					"combinedDue = ? " +
+					"WHERE id = ?");
+		}
 	}
 	
 	public Card(){
-		this(null, null, Float.NaN);
+		this(null, null, Double.NaN);
 	}
 	
 	public void setModified() {
-		modified = System.currentTimeMillis() / 1000f;
+		modified = System.currentTimeMillis() / 1000.0;
 	}
 	
 	public void startTimer() {
-		timerStarted = System.currentTimeMillis() / 1000f;
+		timerStarted = System.currentTimeMillis() / 1000.0;
 	}
 	
 	public void stopTimer() {
-		timerStopped = System.currentTimeMillis() / 1000f;
+		timerStopped = System.currentTimeMillis() / 1000.0;
 	}
 	
-	public float thinkingTime() {
+	public double thinkingTime() {
 		if (timerStopped == Float.NaN)
-			return (System.currentTimeMillis() / 1000f) - timerStarted;
+			return (System.currentTimeMillis() / 1000.0) - timerStarted;
 		else
 			return timerStopped - timerStarted;
 	}
 	
-	public float totalTime() {
-		return (System.currentTimeMillis() / 1000f) - timerStarted;
+	public double totalTime() {
+		return (System.currentTimeMillis() / 1000.0) - timerStarted;
 	}
 	
 	public void genFuzz() {
 		Random rand = new Random();
-		fuzz = 0.95f + (0.1f * rand.nextFloat());
+		fuzz = 0.95 + (0.1 * rand.nextDouble());
 	}
 	
 	public String htmlQuestion(String type, boolean align) {
@@ -152,12 +198,12 @@ public void updateStats(int ease, String state) {
 		else
 			successive = 0;
 		
-		float delay = totalTime();
+		double delay = totalTime();
 		// Ignore any times over 60 seconds
 		if (delay < 60) {
 			reviewTime += delay;
 			if (averageTime != 0)
-				averageTime = (averageTime + delay) / 2f;
+				averageTime = (averageTime + delay) / 2.0;
 			else
 				averageTime = delay;
 		}
@@ -178,7 +224,7 @@ public void updateStats(int ease, String state) {
 		else
 			yesCount += 1;
 		if (firstAnswered == 0)
-			firstAnswered = System.currentTimeMillis() / 1000f;
+			firstAnswered = System.currentTimeMillis() / 1000.0;
 		setModified();
 	}
 	
@@ -215,24 +261,24 @@ public boolean fromDB(long id) {
 		this.id = cursor.getLong(0);
 		this.factId = cursor.getLong(1);
 		this.cardModelId = cursor.getLong(2);
-		this.created = cursor.getFloat(3);
-		this.modified = cursor.getFloat(4);
+		this.created = cursor.getDouble(3);
+		this.modified = cursor.getDouble(4);
 		this.tags = cursor.getString(5);
 		this.ordinal = cursor.getInt(6);
 		this.question = cursor.getString(7);
 		this.answer = cursor.getString(8);
 		this.priority = cursor.getInt(9);
-		this.interval = cursor.getFloat(10);
-		this.lastInterval = cursor.getFloat(11);
-		this.due = cursor.getFloat(12);
-		this.lastDue = cursor.getFloat(13);
-		this.factor = cursor.getFloat(14);
-		this.lastFactor = cursor.getFloat(15);
-		this.firstAnswered = cursor.getFloat(16);
+		this.interval = cursor.getDouble(10);
+		this.lastInterval = cursor.getDouble(11);
+		this.due = cursor.getDouble(12);
+		this.lastDue = cursor.getDouble(13);
+		this.factor = cursor.getDouble(14);
+		this.lastFactor = cursor.getDouble(15);
+		this.firstAnswered = cursor.getDouble(16);
 		this.reps = cursor.getInt(17);
 		this.successive = cursor.getInt(18);
-		this.averageTime = cursor.getFloat(19);
-		this.reviewTime = cursor.getFloat(20);
+		this.averageTime = cursor.getDouble(19);
+		this.reviewTime = cursor.getDouble(20);
 		this.youngEase0 = cursor.getInt(21);
 		this.youngEase1 = cursor.getInt(22);
 		this.youngEase2 = cursor.getInt(23);
@@ -245,10 +291,10 @@ public boolean fromDB(long id) {
 		this.matureEase4 = cursor.getInt(30);
 		this.yesCount = cursor.getInt(31);
 		this.noCount = cursor.getInt(32);
-		this.spaceUntil = cursor.getFloat(33);
+		this.spaceUntil = cursor.getDouble(33);
 		this.isDue = cursor.getInt(34);
 		this.type = cursor.getInt(35);
-		this.combinedDue = cursor.getFloat(36);
+		this.combinedDue = cursor.getDouble(36);
 		
 		cursor.close();
 		
@@ -257,6 +303,58 @@ public boolean fromDB(long id) {
 	}
 	
 	public void toDB() {
+		if (reps == 0)
+			type = 2;
+		else if (successive != 0)
+			type = 1;
+		else
+			type = 0;
+		
+		ContentValues values = new ContentValues();
+		values.put("factId", factId);
+		values.put("cardModelId", cardModelId);
+		values.put("created", created);
+		values.put("modified", modified);
+		values.put("tags", tags);
+		values.put("ordinal", ordinal);
+		values.put("question", question);
+		values.put("answer", answer);
+		values.put("priority", priority);
+		values.put("interval", interval);
+		values.put("lastInterval", lastInterval);
+		values.put("due", due);
+		values.put("lastDue", lastDue);
+		values.put("factor", factor);
+		values.put("lastFactor", lastFactor);
+		values.put("firstAnswered", firstAnswered);
+		values.put("reps", reps);
+		values.put("successive", successive);
+		values.put("averageTime", averageTime);
+		values.put("reviewTime", reviewTime);
+		values.put("youngEase0", youngEase0);
+		values.put("youngEase1", youngEase1);
+		values.put("youngEase2", youngEase2);
+		values.put("youngEase3", youngEase3);
+		values.put("youngEase4", youngEase4);
+		values.put("matureEase0", matureEase0);
+		values.put("matureEase1", matureEase1);
+		values.put("matureEase2", matureEase2);
+		values.put("matureEase3", matureEase3);
+		values.put("matureEase4", matureEase4);
+		values.put("yesCount", yesCount);
+		values.put("noCount", noCount);
+		values.put("spaceUntil", spaceUntil);
+		values.put("isDue", isDue);
+		values.put("type", type);
+		values.put("combinedDue", Math.max(spaceUntil, due));
+		values.put("relativeDelay", 0.0);
+		AnkiDb.database.update("cards", values, "id = " + id, null);
+		
+		// TODO: Should also write JOINED entries: CardModel and Fact.
+	}
+	
+	public void toDB2()
+	{
 		if (this.reps == 0)
 			this.type = 2;
 		else if (this.successive != 0)
@@ -264,47 +362,102 @@ else if (this.successive != 0)
 		else
 			this.type = 0;
 		
-		ContentValues values = new ContentValues();
-		values.put("factId", this.factId);
-		values.put("cardModelId", this.cardModelId);
-		values.put("created", this.created);
-		values.put("modified", this.modified);
-		values.put("tags", this.tags);
-		values.put("ordinal", this.ordinal);
-		values.put("question", this.question);
-		values.put("answer", this.answer);
-		values.put("priority", this.priority);
-		values.put("interval", this.interval);
-		values.put("lastInterval", this.lastInterval);
-		values.put("due", this.due);
-		values.put("lastDue", this.lastDue);
-		values.put("factor", this.factor);
-		values.put("lastFactor", this.lastFactor);
-		values.put("firstAnswered", this.firstAnswered);
-		values.put("reps", this.reps);
-		values.put("successive", this.successive);
-		values.put("averageTime", this.averageTime);
-		values.put("reviewTime", this.reviewTime);
-		values.put("youngEase0", this.youngEase0);
-		values.put("youngEase1", this.youngEase1);
-		values.put("youngEase2", this.youngEase2);
-		values.put("youngEase3", this.youngEase3);
-		values.put("youngEase4", this.youngEase4);
-		values.put("matureEase0", this.matureEase0);
-		values.put("matureEase1", this.matureEase1);
-		values.put("matureEase2", this.matureEase2);
-		values.put("matureEase3", this.matureEase3);
-		values.put("matureEase4", this.matureEase4);
-		values.put("yesCount", this.yesCount);
-		values.put("noCount", this.noCount);
-		values.put("spaceUntil", this.spaceUntil);
-		values.put("isDue", this.isDue);
-		values.put("type", this.type);
-		values.put("combinedDue", Math.max(this.spaceUntil, this.due));
-		values.put("relativeDelay", 0f);
-		AnkiDb.database.update("cards", values, "id = " + this.id, null);
+		AnkiDb.database.execSQL(
+				"UPDATE cards SET " +
+				"factId = " + factId + ", " +
+				"cardModelId = " + cardModelId + ", " +
+				"created = " + String.format("%f", created) + ", " +
+				"modified = " + String.format("%f", modified) + ", " +
+				"tags = '" + tags + "', " +
+				"ordinal = " + ordinal + ", " +
+				"question = '" + question + "', " +
+				"answer = '" + answer + "', " +
+				"priority = " + priority + ", " +
+				"interval = " + String.format("%f", interval) + ", " +
+				"lastInterval = " + String.format("%f", lastInterval) + ", " +
+				"due = " + String.format("%f", due) + ", " +
+				"lastDue = " + String.format("%f", lastDue) + ", " +
+				"factor = " + String.format("%f", factor) + ", " +
+				"lastFactor = " + String.format("%f", lastFactor) + ", " +
+				"firstAnswered = " + String.format("%f", firstAnswered) + ", " +
+				"reps = " + reps + ", " +
+				"successive = " + successive + ", " +
+				"averageTime = " + String.format("%f", averageTime) + ", " +
+				"reviewTime = " + String.format("%f", reviewTime) + ", " +
+				"youngEase0 = " + youngEase0 + ", " +
+				"youngEase1 = " + youngEase1 + ", " +
+				"youngEase2 = " + youngEase2 + ", " +
+				"youngEase3 = " + youngEase3 + ", " +
+				"youngEase4 = " + youngEase4 + ", " +
+				"matureEase0 = " + matureEase0 + ", " +
+				"matureEase1 = " + matureEase1 + ", " +
+				"matureEase2 = " + matureEase2 + ", " +
+				"matureEase3 = " + matureEase3 + ", " +
+				"matureEase4 = " + matureEase4 + ", " +
+				"yesCount = " + yesCount + ", " +
+				"noCount = " + noCount + ", " +
+				"spaceUntil = " + String.format("%f", spaceUntil) + ", " +
+				"relativeDelay = 0, " +
+				"isDue = " + isDue + ", " +
+				"type = " + type + ", " +
+				"combinedDue = " + String.format("%f", Math.max(spaceUntil, due)) + " " +
+				"WHERE id = " + id);
+	}
+	
+	public void toDB3()
+	{
+		if (this.reps == 0)
+			this.type = 2;
+		else if (this.successive != 0)
+			this.type = 1;
+		else
+			this.type = 0;
 		
-		// TODO: Should also write JOINED entries: CardModel and Fact.
+		updateStmt.clearBindings();
+		updateStmt.bindLong(1, factId);
+		updateStmt.bindLong(2, cardModelId);
+		updateStmt.bindDouble(3, created);
+		updateStmt.bindDouble(4, modified);
+		updateStmt.bindString(5, tags);
+		updateStmt.bindLong(6, ordinal);
+		updateStmt.bindString(7, question);
+		updateStmt.bindString(8, answer);
+		updateStmt.bindLong(9, priority);
+		updateStmt.bindDouble(10, interval);
+		updateStmt.bindDouble(11, lastInterval);
+		updateStmt.bindDouble(12, due);
+		updateStmt.bindDouble(13, lastDue);
+		updateStmt.bindDouble(14, factor);
+		updateStmt.bindDouble(15, lastFactor);
+		updateStmt.bindDouble(16, firstAnswered);
+		updateStmt.bindLong(17, reps);
+		updateStmt.bindLong(18, successive);
+		updateStmt.bindDouble(19, averageTime);
+		updateStmt.bindDouble(20, reviewTime);
+		updateStmt.bindLong(21, youngEase0);
+		updateStmt.bindLong(22, youngEase1);
+		updateStmt.bindLong(23, youngEase2);
+		updateStmt.bindLong(24, youngEase3);
+		updateStmt.bindLong(25, youngEase4);
+		updateStmt.bindLong(26, matureEase0);
+		updateStmt.bindLong(27, matureEase1);
+		updateStmt.bindLong(28, matureEase2);
+		updateStmt.bindLong(29, matureEase3);
+		updateStmt.bindLong(30, matureEase4);
+		updateStmt.bindLong(31, yesCount);
+		updateStmt.bindLong(32, noCount);
+		updateStmt.bindDouble(33, spaceUntil);
+		updateStmt.bindLong(34, isDue);
+		updateStmt.bindLong(35, type);
+		updateStmt.bindDouble(36, Math.max(spaceUntil, due));
+		updateStmt.bindLong(37, id);
+		
+		updateStmt.execute();
+	}
+	
+	public void temporarilySetLowestPriority()
+	{
+		AnkiDb.database.execSQL("UPDATE cards SET priority = 0, isDue = 0 WHERE id = " + id);
 	}
 	
 }
diff --git a/src/com/ichi2/anki/CardHistoryEntry.java b/src/com/ichi2/anki/CardHistoryEntry.java
index 3a7ea0055b0b..03f7363a2a7c 100644
--- a/src/com/ichi2/anki/CardHistoryEntry.java
+++ b/src/com/ichi2/anki/CardHistoryEntry.java
@@ -6,35 +6,35 @@ public class CardHistoryEntry {
 	
 	// BEGIN: SQL table columns
 	long cardId;
-	float time = System.currentTimeMillis() / 1000f;
-	float lastInterval;
-	float nextInterval;
+	double time;
+	double lastInterval;
+	double nextInterval;
 	int ease;
-	float delay;
-	float lastFactor;
-	float nextFactor;
+	double delay;
+	double lastFactor;
+	double nextFactor;
 	float reps;
-	float thinkingTime;
+	double thinkingTime;
 	float yesCount;
 	float noCount;
 	// END: SQL table columns
 	
-	public CardHistoryEntry(Card card, int ease, float delay)
+	public CardHistoryEntry(Card card, int ease, double delay)
 	{
 		if (card == null)
 			return;
 		
-		this.cardId = card.id;
-		this.lastInterval = card.lastInterval;
-		this.nextInterval = card.interval;
-		this.lastFactor = card.lastFactor;
-		this.nextFactor = card.factor;
-		this.reps = card.reps;
-		this.yesCount = card.yesCount;
-		this.noCount = card.noCount;
+		cardId = card.id;
+		lastInterval = card.lastInterval;
+		nextInterval = card.interval;
+		lastFactor = card.lastFactor;
+		nextFactor = card.factor;
+		reps = card.reps;
+		yesCount = card.yesCount;
+		noCount = card.noCount;
 		this.ease = ease;
 		this.delay = delay;
-		this.thinkingTime = card.thinkingTime();
+		thinkingTime = card.thinkingTime();
 	}
 	
 	public void writeSQL()
@@ -51,7 +51,7 @@ public void writeSQL()
 	values.put("thinkingTime", thinkingTime);
 	values.put("yesCount", yesCount);
 	values.put("noCount", noCount);
-	values.put("time", System.currentTimeMillis() / 1000f);
+	values.put("time", System.currentTimeMillis() / 1000.0);
 	
 	AnkiDb.database.insert("reviewHistory", null, values);
 	}
diff --git a/src/com/ichi2/anki/Deck.java b/src/com/ichi2/anki/Deck.java
index cebf42227c6e..ee3dd11ebc3a 100644
--- a/src/com/ichi2/anki/Deck.java
+++ b/src/com/ichi2/anki/Deck.java
@@ -70,16 +70,16 @@ public class Deck
 
 	private static final int DECK_VERSION = 43;
 	
-	private static final float factorFour = 1.3f;
-	private static final float initialFactor = 2.5f;
-	private static final float maxScheduleTime = 36500f;
+	private static final double factorFour = 1.3;
+	private static final double initialFactor = 2.5;
+	private static final double maxScheduleTime = 36500.0;
 	
 	// BEGIN: SQL table columns
 	long id;
 
-	float created;
+	double created;
 
-	float modified;
+	double modified;
 
 	String description;
 
@@ -89,21 +89,21 @@ public class Deck
 	
 	String syncName;
 
-	float lastSync;
+	double lastSync;
 
 	// Scheduling
 	// Initial intervals
-	float hardIntervalMin;
+	double hardIntervalMin;
 
-	float hardIntervalMax;
+	double hardIntervalMax;
 
-	float midIntervalMin;
+	double midIntervalMin;
 
-	float midIntervalMax;
+	double midIntervalMax;
 
-	float easyIntervalMin;
+	double easyIntervalMin;
 
-	float easyIntervalMax;
+	double easyIntervalMax;
 
 	// Delays on failure
 	int delay0;
@@ -113,7 +113,7 @@ public class Deck
 	int delay2;
 
 	// Collapsing future cards
-	float collapseTime;
+	double collapseTime;
 
 	// Priorities and postponing
 	String highPriority;
@@ -142,7 +142,7 @@ public class Deck
 	int sessionTimeLimit;
 
 	// Stats offset
-	float utcOffset;
+	double utcOffset;
 
 	// Count cache
 	int cardCount;
@@ -167,13 +167,13 @@ public class Deck
 	//ArrayList<Model> models; // Deck.id = Model.deckId
 	// END JOINed variables
 	
-	float averageFactor;
+	double averageFactor;
 
 	int newCardModulus;
 
 	int newCountToday;
 
-	float lastLoaded;
+	double lastLoaded;
 	
 	boolean newEarly;
 
@@ -188,7 +188,7 @@ private void initVars()
 		// tmpMediaDir = null;
 		// forceMediaDir = null;
 		// lastTags = "";
-		lastLoaded = (float) System.currentTimeMillis() / 1000;
+		lastLoaded = (double) System.currentTimeMillis() / 1000.0;
 //		undoEnabled = false;
 //		sessionStartReps = 0;
 //		sessionStartTime = 0;
@@ -202,7 +202,7 @@ public static Deck openDeck(String path) throws SQLException
 		Deck deck = new Deck();
 		Log.i(TAG, "openDeck - Opening database " + path);
 		AnkiDb.openDatabase(path);
-
+		
 		// Read in deck table columns
 		Cursor cursor = AnkiDb.database.rawQuery("SELECT *" + " FROM decks" + " LIMIT 1", null);
 
@@ -211,23 +211,23 @@ public static Deck openDeck(String path) throws SQLException
 		cursor.moveToFirst();
 		
 		deck.id 			 = cursor.getLong(0);
-		deck.created		 = cursor.getFloat(1);
-		deck.modified 		 = cursor.getFloat(2);
+		deck.created		 = cursor.getDouble(1);
+		deck.modified 		 = cursor.getDouble(2);
 		deck.description	 = cursor.getString(3);
 		deck.version		 = cursor.getInt(4);
 		deck.currentModelId	 = cursor.getLong(5);
 		deck.syncName		 = cursor.getString(6);
-		deck.lastSync		 = cursor.getFloat(7);
-		deck.hardIntervalMin = cursor.getFloat(8);
-		deck.hardIntervalMax = cursor.getFloat(9);
-		deck.midIntervalMin  = cursor.getFloat(10);
-		deck.midIntervalMax  = cursor.getFloat(11);
-		deck.easyIntervalMin = cursor.getFloat(12);
-		deck.easyIntervalMax = cursor.getFloat(13);
+		deck.lastSync		 = cursor.getDouble(7);
+		deck.hardIntervalMin = cursor.getDouble(8);
+		deck.hardIntervalMax = cursor.getDouble(9);
+		deck.midIntervalMin  = cursor.getDouble(10);
+		deck.midIntervalMax  = cursor.getDouble(11);
+		deck.easyIntervalMin = cursor.getDouble(12);
+		deck.easyIntervalMax = cursor.getDouble(13);
 		deck.delay0 		 = cursor.getInt(14);
 		deck.delay1 		 = cursor.getInt(15);
 		deck.delay2 		 = cursor.getInt(16);
-		deck.collapseTime 	 = cursor.getFloat(17);
+		deck.collapseTime 	 = cursor.getDouble(17);
 		deck.highPriority 	 = cursor.getString(18);
 		deck.medPriority 	 = cursor.getString(19);
 		deck.lowPriority 	 = cursor.getString(20);
@@ -238,7 +238,7 @@ public static Deck openDeck(String path) throws SQLException
 		deck.newCardsPerDay  = cursor.getInt(25);
 		deck.sessionRepLimit = cursor.getInt(26);
 		deck.sessionTimeLimit= cursor.getInt(27);
-		deck.utcOffset		 = cursor.getFloat(28);
+		deck.utcOffset		 = cursor.getDouble(28);
 		deck.cardCount 		 = cursor.getInt(29);
 		deck.factCount 		 = cursor.getInt(30);
 		deck.failedNowCount  = cursor.getInt(31);
@@ -249,9 +249,10 @@ public static Deck openDeck(String path) throws SQLException
 
 		Log.i(TAG, "openDeck - Read " + cursor.getColumnCount() + " columns from decks table.");
 		cursor.close();
+		Log.i(TAG, String.format("openDeck - modified: %f currentTime: %f", deck.modified, System.currentTimeMillis()/1000.0));
 
 		deck.initVars();
-
+		
 		// Ensure necessary indices are available
 		deck.updateDynamicIndices();
 		// Save counts to determine if we should save deck after check
@@ -259,8 +260,13 @@ public static Deck openDeck(String path) throws SQLException
 		// Update counts
 		deck.rebuildQueue();
 		// Unsuspend reviewed early & buried
-		cursor = AnkiDb.database.rawQuery("SELECT id " + "FROM cards " + "WHERE type in (0,1,2) and "
-		        + "isDue = 0 and " + "priority in (-1,-2)", null);
+		cursor = AnkiDb.database.rawQuery(
+				"SELECT id " + 
+				"FROM cards " + 
+				"WHERE type in (0,1,2) and " + 
+				"isDue = 0 and " + 
+				"priority in (-1,-2)",
+				null);
 
 		if (cursor.isClosed())
 			throw new SQLException();
@@ -282,6 +288,8 @@ public static Deck openDeck(String path) throws SQLException
 		if ((oldCount != (deck.failedSoonCount + deck.revCount + deck.newCount)) || deck.modifiedSinceSave())
 			deck.commitToDB();
 
+		Card.updateStmt = null;
+		
 		return deck;
 	}
 
@@ -294,11 +302,11 @@ public void closeDeck()
 
 	private boolean modifiedSinceSave()
 	{
-		return this.modified > this.lastLoaded;
+		return modified > lastLoaded;
 	}
 	
 	private void setModified() {
-		modified = System.currentTimeMillis() / 1000f;
+		modified = System.currentTimeMillis() / 1000.0;
 	}
 	
 	private void flushMod() {
@@ -309,7 +317,6 @@ private void flushMod() {
 	private void commitToDB() {
 		Log.i(TAG, "commitToDB - Saving deck to DB...");
 		ContentValues values = new ContentValues();
-		values.put("id", id);
 		values.put("created", created);
 		values.put("modified", modified);
 		values.put("description", description);
@@ -347,12 +354,11 @@ private void commitToDB() {
 		values.put("revCardOrder", revCardOrder);
 
 		AnkiDb.database.update("decks", values, "id = " + this.id, null);
-		lastLoaded = System.currentTimeMillis() / 1000f;
 	}
 
-	public static float getLastModified(String deckPath)
+	public static double getLastModified(String deckPath)
 	{
-		float value;
+		double value;
 		//Log.i(TAG, "Deck - getLastModified from deck = " + deckPath);
 		AnkiDb.openDatabase(deckPath);
 		Cursor cursor = AnkiDb.database.rawQuery("SELECT modified" + " FROM decks" + " LIMIT 1", null);
@@ -360,7 +366,7 @@ public static float getLastModified(String deckPath)
 		if (!cursor.moveToFirst())
 			value = -1;
 		else
-			value = cursor.getFloat(0);
+			value = cursor.getDouble(0);
 		cursor.close();
 		AnkiDb.closeDatabase();
 		return value;
@@ -414,7 +420,7 @@ private long getCardId() {
 		// Display failed cards early/last
 		if (showFailedLast()) {
 			try {
-			id = AnkiDb.queryScalar("SELECT id FROM failedCards limit 1");
+			id = AnkiDb.queryScalar("SELECT id FROM failedCards LIMIT 1");
 			} catch (Exception e) {
 				return 0;
 			}
@@ -511,14 +517,19 @@ private long getRevCard() {
 	}
 	
 	private boolean showFailedLast() {
-		return (collapseTime != 0f) || (delay0 == 0);
+		return (collapseTime != 0) || (delay0 == 0);
 	}
 	
 	private Card cardFromId(long id) {
 		if (id == 0)
 			return null;
 		Card card = new Card();
-		if (!card.fromDB(id))
+		long start = System.currentTimeMillis();
+		boolean result = card.fromDB(id);
+		long stop = System.currentTimeMillis();
+        Log.v(TAG, "cardFromId - card.fromDB in " + (stop - start) + " ms.");
+        
+		if (!result)
 			return null;
 		card.genFuzz();
 		card.startTimer();
@@ -530,16 +541,16 @@ private Card cardFromId(long id) {
 	
 	public void answerCard(Card card, int ease)
 	{
-		float now = System.currentTimeMillis() / 1000f;
+		double now = System.currentTimeMillis() / 1000.0;
 		
 		// Old state
 		String oldState = cardState(card);
-		float lastDelaySecs = System.currentTimeMillis() / 1000f - card.combinedDue;
-        float lastDelay = lastDelaySecs / 86400f;
+		double lastDelaySecs = System.currentTimeMillis() / 1000.0 - card.combinedDue;
+        double lastDelay = lastDelaySecs / 86400.0;
         int oldSuc = card.successive;
         
         // update card details
-        float last = card.interval;
+        double last = card.interval;
         card.interval = nextInterval(card, ease);
         if (lastDelay >= 0)
             card.lastInterval = last; // keep last interval if reviewing early
@@ -552,7 +563,8 @@ public void answerCard(Card card, int ease)
             updateFactor(card, ease); // don't update factor if learning ahead
         
         // spacing
-        float space, spaceFactor, minSpacing, minOfOtherCards;
+        long start = System.currentTimeMillis();
+        double space, spaceFactor, minSpacing, minOfOtherCards;
         Cursor cursor = AnkiDb.database.rawQuery(
         		"SELECT models.initialSpacing, models.spacing " +
         		"FROM facts, models " +
@@ -567,11 +579,14 @@ public void answerCard(Card card, int ease)
         }
         else
         {
-	        minSpacing = cursor.getFloat(0);
-	        spaceFactor = cursor.getFloat(1);
+	        minSpacing = cursor.getDouble(0);
+	        spaceFactor = cursor.getDouble(1);
         }
         cursor.close();
+        long stop = System.currentTimeMillis();
+        Log.v(TAG, "answerCard - spacing in " + (stop - start) + " ms.");
         
+        start = System.currentTimeMillis();
         cursor = AnkiDb.database.rawQuery(
         		"SELECT min(interval) " +
         		"FROM cards " +
@@ -583,15 +598,17 @@ public void answerCard(Card card, int ease)
 		if (!cursor.moveToFirst())
 			minOfOtherCards = 0;
 		else
-			minOfOtherCards = cursor.getFloat(0);
+			minOfOtherCards = cursor.getDouble(0);
 		cursor.close();
+		stop = System.currentTimeMillis();
+	    Log.v(TAG, "answerCard - minOfOtherCards in " + (stop - start) + " ms.");
         if (minOfOtherCards != 0)
             space = Math.min(minOfOtherCards, card.interval);
         else
             space = 0;
         space = space * spaceFactor * 86400f;
         space = Math.max(minSpacing, space);
-        space += System.currentTimeMillis() / 1000f;
+        space += System.currentTimeMillis() / 1000.0;
         
         // check what other cards we've spaced
         String extra;
@@ -602,7 +619,9 @@ public void answerCard(Card card, int ease)
             // if not reviewing early, make sure the current card is counted
             // even if it was not due yet (it's a failed card)
             extra = "or id = " + card.id;
-        }   
+        }
+        
+        start = System.currentTimeMillis();
         cursor = AnkiDb.database.rawQuery(
         		"SELECT type, count(type) " +
         		"FROM cards " +
@@ -610,21 +629,21 @@ public void answerCard(Card card, int ease)
         		card.factId + " and " +
         		"(isDue = 1 " + extra + ") " +
         		"GROUP BY type", null);
-        if (cursor.moveToFirst())
-        {
-        	while (cursor.moveToNext())
-        	{
-        		if (cursor.getInt(0) == 0)
-        			failedSoonCount -= cursor.getInt(1);
-        		else if (cursor.getInt(0) == 1)
-        			revCount -= cursor.getInt(1);
-        		else
-        			newCount -= cursor.getInt(1);
-        	}
-        }
+    	while (cursor.moveToNext())
+    	{
+    		if (cursor.getInt(0) == 0)
+    			failedSoonCount -= cursor.getInt(1);
+    		else if (cursor.getInt(0) == 1)
+    			revCount -= cursor.getInt(1);
+    		else
+    			newCount -= cursor.getInt(1);
+    	}
         cursor.close();
-            
-        // space other cards        
+        stop = System.currentTimeMillis();
+	    Log.v(TAG, "answerCard - other cards for same fact in " + (stop - start) + " ms.");
+	    
+        // space other cards
+	    start = System.currentTimeMillis();
         AnkiDb.database.execSQL(String.format(
         		"UPDATE cards " +
         		"SET spaceUntil = %f, " +
@@ -633,21 +652,37 @@ else if (cursor.getInt(0) == 1)
         		"isDue = 0 " +
         		"WHERE id != %d and factId = %d",
         		space, space, now, card.id, card.factId));
+        stop = System.currentTimeMillis();
+	    Log.v(TAG, "answerCard - space other cards for same fact in " + (stop - start) + " ms.");
         card.spaceUntil = 0;
         
         // temp suspend if learning ahead
-        if (this.reviewEarly && lastDelay < 0)
-            if (oldSuc != 0 || lastDelaySecs > this.delay0 || !this.showFailedLast())
+        if (reviewEarly && lastDelay < 0)
+            if (oldSuc != 0 || lastDelaySecs > delay0 || !showFailedLast())
                 card.priority = -1;
         // card stats
+        start = System.currentTimeMillis();
         card.updateStats(ease, oldState);
+        stop = System.currentTimeMillis();
+        Log.v(TAG, "answerCard - card.updateStats in " + (stop - start) + " ms.");
+        
+        start = System.currentTimeMillis();
         card.toDB();
+        stop = System.currentTimeMillis();
+        Log.v(TAG, "answerCard - card.toDB in " + (stop - start) + " ms.");
+        
         // global/daily stats
+        start = System.currentTimeMillis();
         Stats.updateAllStats(this.globalStats, this.dailyStats, card, ease, oldState);
+        stop = System.currentTimeMillis();
+        Log.v(TAG, "answerCard - Stats.updateAllStats in " + (stop - start) + " ms.");
         // review history
+        start = System.currentTimeMillis();
         CardHistoryEntry entry = new CardHistoryEntry(card, ease, lastDelay);
         entry.writeSQL();
-        this.modified = now;
+        stop = System.currentTimeMillis();
+        Log.v(TAG, "answerCard - CardHistoryEntry in " + (stop - start) + " ms.");
+        modified = now;
 //        // TODO: Fix leech handling
 //        if (isLeech(card)) 
 //            card = handleLeech(card);
@@ -688,22 +723,22 @@ else if (cursor.getInt(0) == 1)
 	/* Interval management
 	 ***********************************************************/
 	
-	private float nextInterval(Card card, int ease)
+	private double nextInterval(Card card, int ease)
 	{
-		float delay = adjustedDelay(card, ease);
+		double delay = adjustedDelay(card, ease);
 		return nextInterval(card, delay, ease);
 	}
 	
-	private float nextInterval(Card card, float delay, int ease)
+	private double nextInterval(Card card, double delay, int ease)
 	{
-		float interval = card.interval;
-        float factor = card.factor;
+		double interval = card.interval;
+        double factor = card.factor;
         
         // if shown early and not failed
         if ((delay < 0) && (card.successive != 0))
         {
             interval = Math.max(card.lastInterval, card.interval + delay);
-            if (interval < this.midIntervalMin)
+            if (interval < midIntervalMin)
                 interval = 0;
             delay = 0;
         }
@@ -711,26 +746,26 @@ private float nextInterval(Card card, float delay, int ease)
         // if interval is less than mid interval, use presets
         if (ease == 1)
         {
-            interval *= this.delay2;
-            if (interval < this.hardIntervalMin)
+            interval *= delay2;
+            if (interval < hardIntervalMin)
                 interval = 0;
         }
         else if (interval == 0)
         {
             if (ease == 2)
-            	interval = this.hardIntervalMin + ((float) Math.random())*(hardIntervalMax - hardIntervalMin);
+            	interval = hardIntervalMin + ((float) Math.random())*(hardIntervalMax - hardIntervalMin);
             else if (ease == 3)
-            	interval = this.midIntervalMin + ((float) Math.random())*(midIntervalMax - midIntervalMin);
+            	interval = midIntervalMin + ((float) Math.random())*(midIntervalMax - midIntervalMin);
             else if (ease == 4)
-            	interval = this.easyIntervalMin + ((float) Math.random())*(easyIntervalMax - easyIntervalMin);
+            	interval = easyIntervalMin + ((float) Math.random())*(easyIntervalMax - easyIntervalMin);
         }
         else
         {
             // if not cramming, boost initial 2
-            if ((interval < this.hardIntervalMax) && (interval > 0.166))
+            if ((interval < hardIntervalMax) && (interval > 0.166))
             {
-                float mid = (this.midIntervalMin + this.midIntervalMax) / 2f;
-                interval *= (mid / interval / factor);
+                double mid = (midIntervalMin + midIntervalMax) / 2.0;
+                interval = mid / factor;
             }
             // multiply last interval by factor
             if (ease == 2)
@@ -747,41 +782,41 @@ else if (ease == 4)
         return interval;
 	}
 	
-	private float nextDue(Card card, int ease, String oldState)
+	private double nextDue(Card card, int ease, String oldState)
 	{
-		float due;
+		double due;
 		if (ease == 1)
 			if (oldState.equals("mature"))
-				due = this.delay1;
+				due = delay1;
 			else
-				due = this.delay0;
+				due = delay0;
 		else
-			due = card.interval * 86400f;
-		return due + (System.currentTimeMillis()/1000f);
+			due = card.interval * 86400.0;
+		return due + (System.currentTimeMillis() / 1000.0);
 	}
 	
 	private void updateFactor(Card card, int ease)
 	{
 		card.lastFactor = card.factor;
 		if (card.reps == 0)
-			card.factor = this.averageFactor; // card is new, inherit beginning factor
+			card.factor = averageFactor; // card is new, inherit beginning factor
 		if (cardIsBeingLearnt(card) && (ease == 0 || ease == 1 || ease == 2))
 		{
 			if (card.successive != 0 && ease != 2)
-				card.factor -= 0.20f; // only penalize failures after success when starting
+				card.factor -= 0.20; // only penalize failures after success when starting
 		}
 		else if (ease == 0 || ease == 1)
-			card.factor -= 0.20f;
+			card.factor -= 0.20;
 		else if (ease == 2)
-			card.factor -= 0.15f;
+			card.factor -= 0.15;
 		else if (ease == 4)
-			card.factor += 0.10f;
-		card.factor = Math.max(1.3f, card.factor);
+			card.factor += 0.10;
+		card.factor = Math.max(1.3, card.factor);
 	}
 	
-	private float adjustedDelay(Card card, int ease)
+	private double adjustedDelay(Card card, int ease)
 	{
-		float now = System.currentTimeMillis();
+		double now = System.currentTimeMillis();
 		if (cardIsNew(card))
 			return 0;
 		if (card.combinedDue <= now)
@@ -811,7 +846,7 @@ private void rebuildCounts(boolean full) {
 				"WHERE type = 0 and " +
 				"isDue = 1 and " +
 				"combinedDue <= " +
-				String.format("%f", (float) (System.currentTimeMillis() / 1000f)));
+				String.format("%f", (double) (System.currentTimeMillis() / 1000.0)));
 		revCount = (int) AnkiDb.queryScalar(
 				"SELECT count(id) " +
 				"FROM cards " +
@@ -844,8 +879,8 @@ private void checkDue()
 				"type = 0 and " +
 				"isDue = 0 and " +
 				"priority in (1,2,3,4) and " +
-				String.format("combinedDue <= %f", (float)
-						((System.currentTimeMillis() / 1000f) + delay0)),
+				String.format("combinedDue <= %f", 
+						(double) ((System.currentTimeMillis() / 1000.0) + delay0)),
 				null);
 		
 		failedNowCount = (int) AnkiDb.queryScalar(
@@ -853,22 +888,22 @@ private void checkDue()
 				"FROM cards " +
 				"WHERE type = 0 and " +
 				"isDue = 1 and " +
-				String.format("combinedDue <= %f", (float)
-						(System.currentTimeMillis() / 1000f)));
+				String.format("combinedDue <= %f", 
+						(double) (System.currentTimeMillis() / 1000.0)));
 		
 		// Review
 		val.clear();
 		val.put("isDue", 1);
 		revCount += AnkiDb.database.update("cards", val, "type = 1 and " + "isDue = 0 and "
 		        + "priority in (1,2,3,4) and "
-		        + String.format("combinedDue <= %f", (float) (System.currentTimeMillis() / 1000f)), null);
+		        + String.format("combinedDue <= %f", (double) (System.currentTimeMillis() / 1000.0)), null);
 
 		// New
 		val.clear();
 		val.put("isDue", 1);
 		newCount += AnkiDb.database.update("cards", val, "type = 2 and " + "isDue = 0 and "
 		        + "priority in (1,2,3,4) and "
-		        + String.format("combinedDue <= %f", (float) (System.currentTimeMillis() / 1000f)), null);
+		        + String.format("combinedDue <= %f", (double) (System.currentTimeMillis() / 1000.0)), null);
 
 		newCountToday = Math.max(Math.min(newCount, newCardsPerDay - newCardsToday()), 0);
 	}
@@ -911,7 +946,7 @@ private void rebuildQueue()
 		if (!cursor.moveToFirst())
 			averageFactor = Deck.initialFactor;
 		else
-			averageFactor = cursor.getFloat(0);
+			averageFactor = cursor.getDouble(0);
 		cursor.close();
 
 		// Recache CSS
@@ -995,7 +1030,7 @@ private void updatePriorities(long[] cardIds, String[] suspend, boolean dirty) {
 
 		String extra = "";
 		if (dirty)
-			extra = ", modified = " + String.format("%f", (float) (System.currentTimeMillis() / 1000f));
+			extra = ", modified = " + String.format("%f", (double) (System.currentTimeMillis() / 1000.0));
 		for (int pri = 0; pri < 5; pri++)
 		{
 			int count = 0;
@@ -1066,7 +1101,7 @@ private boolean cardIsNew(Card card)
 	 */
 	private boolean cardIsBeingLearnt(Card card)
 	{
-		return card.interval < this.easyIntervalMin;
+		return card.interval < easyIntervalMin;
 	}
 	
 	/* Dynamic indices
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
new file mode 100644
index 000000000000..b0a76210170c
--- /dev/null
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -0,0 +1,305 @@
+package com.ichi2.anki;
+
+import android.database.CursorIndexOutOfBoundsException;
+import android.database.SQLException;
+import android.os.AsyncTask;
+import android.util.Log;
+
+public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, DeckTask.TaskData>
+{
+	
+	/**
+	 * Tag for logging messages
+	 */
+	private static final String TAG = "Ankidroid";
+	
+	public static final int TASK_TYPE_LOAD_DECK = 0;
+	public static final int TASK_TYPE_ANSWER_CARD = 1;
+	
+	private static DeckTask instance;
+	
+	int type;
+//	Deck deck;
+//	Card oldCard;
+	TaskListener listener;
+	
+//	public DeckTask(Deck deck, int type, TaskListener listener)
+//	{
+//		this.deck = deck;
+//		this.type = type;
+//		this.listener = listener;
+//	}
+//	
+//	public DeckTask(Deck deck, Card cardToAnswer, int type, TaskListener listener)
+//	{
+//		this(deck, type, listener);
+//		this.oldCard = cardToAnswer;
+//	}
+	
+	public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData... params)
+	{
+		try
+		{
+			if ((instance != null) && (instance.getStatus() != AsyncTask.Status.FINISHED))
+				instance.get();
+		} catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		
+		instance = new DeckTask();
+		instance.listener = listener;
+		instance.type = type;
+		
+		return (DeckTask) instance.execute(params);
+	}
+
+	@Override
+	protected TaskData doInBackground(TaskData... params)
+	{
+		switch (type)
+		{
+		case TASK_TYPE_LOAD_DECK:
+			return doInBackgroundLoadDeck(params);
+		case TASK_TYPE_ANSWER_CARD:
+			return doInBackgroundAnswerCard(params);
+		default:
+			return null;
+		}
+	}
+	
+	@Override
+	protected void onPreExecute()
+	{
+		listener.onPreExecute();
+//		switch (type)
+//		{
+//		case TASK_TYPE_LOAD_DECK:
+//			onPreExecuteLoadDeck();
+//		case TASK_TYPE_ANSWER_CARD:
+//			onPreExecuteAnswerCard();
+//			break;
+//		default:
+//			break;
+//		}
+	}
+	
+	@Override
+	protected void onProgressUpdate(TaskData... values)
+	{
+		listener.onProgressUpdate(values);
+//		switch (type)
+//		{
+//		case TASK_TYPE_ANSWER_CARD:
+//			onProgressUpdateAnswerCard(values);
+//			break;
+//		default:
+//			break;
+//		}
+	}
+	
+	@Override
+	protected void onPostExecute(TaskData result)
+	{
+		listener.onPostExecute(result);
+//		switch (type)
+//		{
+//		case TASK_TYPE_LOAD_DECK:
+//			onPostExecuteLoadDeck(result);
+//			break;
+//		default:
+//			break;
+//		}
+	}
+	
+//	private void onPreExecuteAnswerCard()
+//	{
+//		oldCard = Ankidroid.this.currentCard;
+//		dialog = ProgressDialog.show(Ankidroid.this, "", "Loading new card...", true);
+//	}
+	
+	private TaskData doInBackgroundAnswerCard(TaskData... params)
+	{
+		long start, stop;
+		Deck deck = params[0].getDeck();
+		Card oldCard = params[0].getCard();
+		int ease = params[0].getInt();
+		Card newCard;
+		
+		if (oldCard != null)
+		{
+			start = System.currentTimeMillis();
+			oldCard.temporarilySetLowestPriority();
+			stop = System.currentTimeMillis();
+			Log.v(TAG, "doInBackground - Set old card 0 priority in " + (stop - start) + " ms.");
+		}
+		
+		start = System.currentTimeMillis();
+		newCard = deck.getCard();
+		stop = System.currentTimeMillis();
+		Log.v(TAG, "doInBackground - Loaded new card in " + (stop - start) + " ms.");
+		publishProgress(new TaskData(newCard));
+		
+		if (ease != 0 && oldCard != null)
+		{
+			start = System.currentTimeMillis();
+			deck.answerCard(oldCard, ease);
+			stop = System.currentTimeMillis();
+			Log.v(TAG, "doInBackground - Answered old card in " + (stop - start) + " ms.");
+		}
+		
+		return null;
+	}
+	
+//	private void onProgressUpdateAnswerCard(TaskData... values)
+//	{
+//		Card newCard = values[0].getCard();
+//		
+//		Ankidroid.this.currentCard = newCard;
+//		
+//		// Set the correct value for the flip card button - That triggers the
+//		// listener which displays the question of the card
+//		Ankidroid.this.mFlipCard.setChecked(false);
+//		Ankidroid.this.mWhiteboard.clear();
+//		Ankidroid.this.mTimer.setBase(SystemClock.elapsedRealtime());
+//		Ankidroid.this.mTimer.start();
+//		
+//		dialog.dismiss();
+//	}
+	
+//	private void onPreExecuteLoadDeck()
+//	{
+//		dialog = ProgressDialog.show(Ankidroid.this, "", "Loading deck. Please wait...", true);
+//	}
+	
+	private TaskData doInBackgroundLoadDeck(TaskData... params)
+	{
+		String deckFilename = params[0].getString();
+		Log.i(TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
+		
+		Log.i(TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
+		try
+		{
+			// Open the right deck.
+			//AnkiDb.openDatabase(deckFilename);
+			Deck deck = Deck.openDeck(deckFilename);
+			// Start by getting the first card and displaying it.
+			//nextCard(0);
+			Card card = deck.getCard();
+			Log.i(TAG, "Deck loaded!");
+			
+			return new TaskData(Ankidroid.DECK_LOADED, deck, card);
+		} catch (SQLException e)
+		{
+			Log.i(TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
+			return new TaskData(Ankidroid.DECK_NOT_LOADED);
+		} catch (CursorIndexOutOfBoundsException e)
+		{
+			Log.i(TAG, "The deck has no cards = " + e.getMessage());;
+			return new TaskData(Ankidroid.DECK_EMPTY);
+		}
+	}
+	
+//	private void onPostExecuteLoadDeck(TaskData result)
+//	{
+//		// This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
+//		if(dialog.isShowing()) 
+//		{
+//			try
+//			{
+//				dialog.dismiss();
+//			} catch(Exception e)
+//			{
+//				Log.e(TAG, "handleMessage - Dialog dismiss Exception = " + e.getMessage());
+//			}
+//		}
+//		
+//		switch(result.getInt())
+//		{
+//			case DECK_LOADED:
+//				showControls(true);
+//				deckLoaded = true;
+//				displayCardQuestion();
+//				break;
+//				
+//			case DECK_NOT_LOADED:
+//				displayDeckNotLoaded();
+//				break;
+//			
+//			case DECK_EMPTY:
+//				displayNoCardsInDeck();
+//				break;
+//		}
+//	}
+	
+	public static interface TaskListener
+	{
+		public void onPreExecute();
+		
+		public void onPostExecute(TaskData result);
+		
+		public void onProgressUpdate(TaskData... values);
+	}
+	
+	public static class TaskData
+	{
+		private Deck deck;
+		private Card card;
+		private int integer;
+		private String msg;
+		
+		public TaskData(int value, Deck deck, Card card)
+		{
+			this(value);
+			this.deck = deck;
+			this.card = card;
+		}
+		
+		public TaskData(Card card)
+		{
+			this.card = card;
+		}
+		
+		public TaskData(int value)
+		{
+			this.integer = value;
+		}
+		
+		public TaskData(String msg)
+		{
+			this.msg = msg;
+		}
+		
+//		public void putCard(Card card)
+//		{
+//			this.card = card;
+//		}
+//		
+//		public void putInt(int value)
+//		{
+//			this.integer = value;
+//		}
+		
+		public Deck getDeck()
+		{
+			return deck;
+		}
+		
+		public Card getCard()
+		{
+			return card;
+		}
+		
+		public int getInt()
+		{
+			return integer;
+		}
+		
+		public String getString()
+		{
+			return msg;
+		}
+		
+	}
+	
+}
diff --git a/src/com/ichi2/anki/Model.java b/src/com/ichi2/anki/Model.java
index 94b58a0dde11..2d2f81db5243 100644
--- a/src/com/ichi2/anki/Model.java
+++ b/src/com/ichi2/anki/Model.java
@@ -11,14 +11,14 @@ public class Model {
 	// BEGIN SQL table entries
 	long id; // Primary key
 	long deckId; // Foreign key
-	float created = System.currentTimeMillis() / 1000f;
-	float modified = System.currentTimeMillis() / 1000f;
+	double created = System.currentTimeMillis() / 1000.0;
+	double modified = System.currentTimeMillis() / 1000.0;
 	String tags = "";
 	String name;
 	String description = "";
 	String features = ""; // obsolete
-	float spacing = 0.1f;
-	float initialSpacing = 60;
+	double spacing = 0.1;
+	double initialSpacing = 60;
 	int source = 0;
 	// BEGIN SQL table entries
 
@@ -39,7 +39,7 @@ public Model() {
 	}
 	
 	public void setModified() {
-		this.modified = System.currentTimeMillis() / 1000f;
+		this.modified = System.currentTimeMillis() / 1000.0;
 	}
 	
 	public void addFieldModel(FieldModel field) {
diff --git a/src/com/ichi2/anki/Stats.java b/src/com/ichi2/anki/Stats.java
index 481a2ae2c00f..86489a163a30 100644
--- a/src/com/ichi2/anki/Stats.java
+++ b/src/com/ichi2/anki/Stats.java
@@ -29,12 +29,12 @@ public class Stats
 
 	int reps;
 
-	float averageTime;
+	double averageTime;
 
-	float reviewTime;
+	double reviewTime;
 
 	// Next two columns no longer used
-	float distractedTime;
+	double distractedTime;
 
 	int distractedReps;
 
@@ -110,9 +110,9 @@ private void fromDB(long id) {
 		type = cursor.getInt(1);
 		day = Date.valueOf(cursor.getString(2));
 		reps = cursor.getInt(3);
-		averageTime = cursor.getFloat(4);
-		reviewTime = cursor.getFloat(5);
-		distractedTime = cursor.getFloat(6);
+		averageTime = cursor.getDouble(4);
+		reviewTime = cursor.getDouble(5);
+		distractedTime = cursor.getDouble(6);
 		distractedReps = cursor.getInt(7);
 		newEase0 = cursor.getInt(8);
 		newEase1 = cursor.getInt(9);
@@ -162,7 +162,7 @@ private void create(int type, Date day)
 		values.put("matureEase2", 0);
 		values.put("matureEase3", 0);
 		values.put("matureEase4", 0);
-		this.id = AnkiDb.database.insert("stats", null, values);
+		id = AnkiDb.database.insert("stats", null, values);
 	}
 	
 	public void toDB()
@@ -189,7 +189,7 @@ public void toDB()
 		values.put("matureEase3", matureEase3);
 		values.put("matureEase4", matureEase4);
 		
-		AnkiDb.database.update("stats", values, "id = " + this.id, null);
+		AnkiDb.database.update("stats", values, "id = " + id, null);
 	}
 
 	public static Date genToday(Deck deck)
@@ -206,13 +206,13 @@ public static void updateAllStats(Stats global, Stats daily, Card card, int ease
 	public static void updateStats(Stats stats, Card card, int ease, String oldState)
 	{
 		stats.reps += 1;
-	    float delay = card.totalTime();
+	    double delay = card.totalTime();
 	    if (delay >= 60)
 	        stats.reviewTime += 60;
 	    else
 	    {
 	        stats.reviewTime += delay;
-	        stats.averageTime = (stats.reviewTime / (float) stats.reps);
+	        stats.averageTime = (stats.reviewTime / (double) stats.reps);
 	    }
 	    // update eases
 	    String attr = oldState + String.format("Ease%d", ease);
