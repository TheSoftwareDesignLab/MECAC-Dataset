diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/EraserButton.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/EraserButton.kt
new file mode 100644
index 000000000000..3daf472b3aa6
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/EraserButton.kt
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+import android.content.Context
+import android.util.AttributeSet
+import com.google.android.material.button.MaterialButton
+import com.ichi2.anki.R
+import kotlin.math.roundToInt
+
+/**
+ * A custom button for the eraser tool that manages its own UI state.
+ * It updates its icon and text based on the current eraser mode and stroke width.
+ */
+class EraserButton : MaterialButton {
+    constructor(context: Context) : this(context, null)
+    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, com.google.android.material.R.attr.materialButtonStyle)
+    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {
+        isCheckable = true
+    }
+
+    /**
+     * Updates the button's visual state based on the eraser's properties.
+     *
+     * @param isChecked Whether the eraser tool is currently active.
+     * @param mode The current eraser mode (PIXEL or PATH).
+     * @param strokeWidth The current eraser stroke width to display.
+     */
+    fun updateState(
+        isChecked: Boolean,
+        mode: EraserMode,
+        strokeWidth: Float,
+    ) {
+        this.isChecked = isChecked
+        text = strokeWidth.roundToInt().toString()
+        when (mode) {
+            EraserMode.STROKE -> setIconResource(R.drawable.ic_edit_off)
+            EraserMode.INK -> setIconResource(R.drawable.eraser)
+        }
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardFragment.kt
new file mode 100644
index 000000000000..0464c74bdc8e
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardFragment.kt
@@ -0,0 +1,528 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+
+import android.content.res.ColorStateList
+import android.graphics.drawable.GradientDrawable
+import android.graphics.drawable.LayerDrawable
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.MenuItem
+import android.view.View
+import android.view.ViewGroup
+import android.widget.HorizontalScrollView
+import android.widget.ImageButton
+import android.widget.LinearLayout
+import android.widget.PopupWindow
+import android.widget.ScrollView
+import android.widget.TextView
+import androidx.appcompat.app.AlertDialog
+import androidx.appcompat.view.menu.MenuBuilder
+import androidx.appcompat.widget.PopupMenu
+import androidx.appcompat.widget.ThemeUtils
+import androidx.constraintlayout.widget.ConstraintLayout
+import androidx.constraintlayout.widget.ConstraintSet
+import androidx.core.view.children
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.viewModels
+import androidx.lifecycle.lifecycleScope
+import com.google.android.material.button.MaterialButton
+import com.google.android.material.button.MaterialButtonToggleGroup
+import com.google.android.material.slider.Slider
+import com.ichi2.anki.R
+import com.ichi2.anki.snackbar.showSnackbar
+import com.ichi2.compat.setTooltipTextCompat
+import com.ichi2.themes.Themes
+import com.ichi2.utils.dp
+import com.ichi2.utils.increaseHorizontalPaddingOfMenuIcons
+import com.mrudultora.colorpicker.ColorPickerPopUp
+import kotlinx.coroutines.flow.combine
+import kotlinx.coroutines.flow.launchIn
+import kotlinx.coroutines.flow.onEach
+import timber.log.Timber
+import kotlin.math.roundToInt
+
+/**
+ * Fragment that displays a whiteboard and its controls.
+ */
+class WhiteboardFragment :
+    Fragment(R.layout.fragment_whiteboard),
+    PopupMenu.OnMenuItemClickListener {
+    private val viewModel: WhiteboardViewModel by viewModels {
+        WhiteboardViewModel.factory(sharedPrefs())
+    }
+    private lateinit var brushToolbarContainerHorizontal: LinearLayout
+    private lateinit var brushToolbarContainerVertical: LinearLayout
+    private var eraserPopup: PopupWindow? = null
+    private var strokeWidthPopup: PopupWindow? = null
+
+    /**
+     * Sets up the view, observers, and event listeners.
+     */
+    override fun onViewCreated(
+        view: View,
+        savedInstanceState: Bundle?,
+    ) {
+        super.onViewCreated(view, savedInstanceState)
+        val whiteboardView = view.findViewById<WhiteboardView>(R.id.whiteboard_view)
+        brushToolbarContainerHorizontal = view.findViewById(R.id.brush_toolbar_container_horizontal)
+        brushToolbarContainerVertical = view.findViewById(R.id.brush_toolbar_container_vertical)
+
+        val isNightMode = Themes.systemIsInNightMode(requireContext())
+        viewModel.loadState(isNightMode)
+
+        setupUI(view)
+        observeViewModel(whiteboardView)
+
+        whiteboardView.onNewPath = viewModel::addPath
+        whiteboardView.onEraseGestureStart = viewModel::startPathEraseGesture
+        whiteboardView.onEraseGestureMove = viewModel::erasePathsAtPoint
+        whiteboardView.onEraseGestureEnd = viewModel::endPathEraseGesture
+    }
+
+    private fun setupUI(view: View) {
+        val undoButton = view.findViewById<ImageButton>(R.id.undo_button)
+        val redoButton = view.findViewById<ImageButton>(R.id.redo_button)
+        val eraserButton = view.findViewById<EraserButton>(R.id.eraser_button)
+
+        val overflowMenuButton = view.findViewById<ImageButton>(R.id.overflow_menu_button)
+        overflowMenuButton.setOnClickListener {
+            val popupMenu = PopupMenu(requireContext(), overflowMenuButton)
+            requireActivity().menuInflater.inflate(R.menu.whiteboard, popupMenu.menu)
+            with(popupMenu.menu) {
+                findItem(R.id.action_toggle_stylus).isChecked = viewModel.isStylusOnlyMode.value
+                (this as? MenuBuilder)?.setOptionalIconsVisible(true)
+                context?.increaseHorizontalPaddingOfMenuIcons(this)
+
+                val alignmentMenuItemId =
+                    when (viewModel.toolbarAlignment.value) {
+                        ToolbarAlignment.LEFT -> R.id.action_align_left
+                        ToolbarAlignment.RIGHT -> R.id.action_align_right
+                        ToolbarAlignment.BOTTOM -> R.id.action_align_bottom
+                    }
+                findItem(alignmentMenuItemId).isEnabled = false
+            }
+            popupMenu.setOnMenuItemClickListener(this)
+            popupMenu.show()
+        }
+
+        undoButton.setOnClickListener { viewModel.undo() }
+        redoButton.setOnClickListener { viewModel.redo() }
+        eraserButton.setOnClickListener {
+            if (viewModel.isEraserActive.value) {
+                eraserButton.isChecked = true
+                if (eraserPopup?.isShowing == true) {
+                    eraserPopup?.dismiss()
+                } else {
+                    showEraserOptionsPopup(it)
+                }
+            } else {
+                viewModel.enableEraser()
+            }
+        }
+
+        viewModel.canUndo.onEach { undoButton.isEnabled = it }.launchIn(lifecycleScope)
+        viewModel.canRedo.onEach { redoButton.isEnabled = it }.launchIn(lifecycleScope)
+    }
+
+    /**
+     * Sets up observers for the ViewModel's state flows.
+     */
+    private fun observeViewModel(whiteboardView: WhiteboardView) {
+        val eraserButton = view?.findViewById<EraserButton>(R.id.eraser_button)
+
+        viewModel.paths.onEach(whiteboardView::setHistory).launchIn(lifecycleScope)
+
+        combine(
+            viewModel.brushColor,
+            viewModel.activeStrokeWidth,
+        ) { color, width ->
+            whiteboardView.setCurrentBrush(color, width)
+        }.launchIn(lifecycleScope)
+
+        combine(
+            viewModel.isEraserActive,
+            viewModel.eraserMode,
+            viewModel.eraserDisplayWidth,
+        ) { isActive, mode, width ->
+            whiteboardView.isEraserActive = isActive
+            eraserButton?.updateState(isActive, mode, width)
+            whiteboardView.eraserMode = mode
+            if (!isActive) {
+                eraserPopup?.dismiss()
+            }
+        }.launchIn(lifecycleScope)
+
+        viewModel.brushes
+            .onEach { brushesInfo ->
+                updateBrushToolbar(brushesInfo)
+                updateToolbarSelection()
+            }.launchIn(lifecycleScope)
+
+        viewModel.activeBrushIndex.onEach { updateToolbarSelection() }.launchIn(lifecycleScope)
+        viewModel.isEraserActive
+            .onEach {
+                updateToolbarSelection()
+            }.launchIn(lifecycleScope)
+
+        viewModel.isStylusOnlyMode
+            .onEach { isEnabled ->
+                whiteboardView.isStylusOnlyMode = isEnabled
+            }.launchIn(lifecycleScope)
+
+        viewModel.toolbarAlignment
+            .onEach { alignment ->
+                updateLayoutForAlignment(alignment)
+            }.launchIn(lifecycleScope)
+    }
+
+    private fun updateBrushToolbar(brushesInfo: List<BrushInfo>) {
+        brushToolbarContainerHorizontal.removeAllViews()
+        brushToolbarContainerVertical.removeAllViews()
+        brushesInfo.forEachIndexed { index, brush ->
+            val inflater = LayoutInflater.from(requireContext())
+            val buttonHorizontal = inflater.inflate(R.layout.button_color_brush, brushToolbarContainerHorizontal, false) as MaterialButton
+            configureBrushButton(buttonHorizontal, brush, index)
+            brushToolbarContainerHorizontal.addView(buttonHorizontal)
+
+            val buttonVertical = inflater.inflate(R.layout.button_color_brush, brushToolbarContainerVertical, false) as MaterialButton
+            configureBrushButton(buttonVertical, brush, index)
+            brushToolbarContainerVertical.addView(buttonVertical)
+        }
+
+        fun addBrushButton() =
+            MaterialButton(requireContext(), null, com.google.android.material.R.attr.materialIconButtonStyle).apply {
+                setIconResource(R.drawable.ic_add)
+                setTooltipTextCompat(getString(R.string.add_brush))
+                val color = ThemeUtils.getThemeAttrColor(requireContext(), androidx.appcompat.R.attr.colorControlNormal)
+                iconTint = ColorStateList.valueOf(color)
+                setOnClickListener { showAddColorDialog() }
+            }
+        brushToolbarContainerHorizontal.addView(addBrushButton())
+        brushToolbarContainerVertical.addView(addBrushButton())
+    }
+
+    /**
+     * Configures a brush button's properties and listeners.
+     */
+    private fun configureBrushButton(
+        button: MaterialButton,
+        brush: BrushInfo,
+        index: Int,
+    ) {
+        button.isCheckable = true
+        button.text = brush.width.roundToInt().toString()
+        button.tag = index
+        button.iconTint = null
+
+        (button.icon?.mutate() as? LayerDrawable)?.let { layerDrawable ->
+            (layerDrawable.findDrawableByLayerId(R.id.brush_preview_fill) as? GradientDrawable)?.setColor(brush.color)
+        }
+
+        button.setOnClickListener {
+            if (viewModel.activeBrushIndex.value == index && !viewModel.isEraserActive.value) {
+                button.isChecked = true
+                showStrokeWidthPopup(it, index)
+            } else {
+                viewModel.setActiveBrush(index)
+            }
+        }
+
+        button.setOnLongClickListener {
+            if (viewModel.brushes.value.size > 1) {
+                showRemoveColorDialog(index)
+            } else {
+                Timber.i("Tried to remove the last brush of the whiteboard")
+                showSnackbar(R.string.cannot_remove_last_brush_message)
+            }
+            true
+        }
+    }
+
+    /**
+     * Updates the selection state of the eraser and brush buttons.
+     */
+    private fun updateToolbarSelection() {
+        val activeIndex = viewModel.activeBrushIndex.value
+        val isEraserActive = viewModel.isEraserActive.value
+
+        val configureSelection: (View) -> Unit = { view ->
+            val button = view as MaterialButton
+            val buttonIndex = button.tag as? Int
+            button.isChecked = (buttonIndex == activeIndex && !isEraserActive)
+        }
+
+        brushToolbarContainerHorizontal.children.forEach(configureSelection)
+        brushToolbarContainerVertical.children.forEach(configureSelection)
+    }
+
+    /**
+     * Shows a popup for adding a new brush color.
+     */
+    private fun showAddColorDialog() {
+        ColorPickerPopUp(context).run {
+            setShowAlpha(true)
+            setDefaultColor(viewModel.brushColor.value)
+            setOnPickColorListener(
+                object : ColorPickerPopUp.OnPickColorListener {
+                    override fun onColorPicked(color: Int) {
+                        Timber.i("Added brush with color %d", color)
+                        viewModel.addBrush(color)
+                    }
+
+                    override fun onCancel() {}
+                },
+            )
+            show()
+        }
+    }
+
+    /**
+     * Shows a confirmation dialog for removing a brush.
+     */
+    private fun showRemoveColorDialog(index: Int) {
+        AlertDialog
+            .Builder(requireContext())
+            .setMessage(R.string.whiteboard_remove_brush_message)
+            .setPositiveButton(R.string.dialog_remove) { dialog, _ ->
+                Timber.i("Removed brush of index %d", index)
+                viewModel.removeBrush(index)
+            }.setNegativeButton(R.string.dialog_cancel, null)
+            .show()
+    }
+
+    /**
+     * Shows a popup for adjusting the stroke width of a specific brush.
+     */
+    private fun showStrokeWidthPopup(
+        anchorView: View,
+        brushIndex: Int,
+    ) {
+        Timber.i("Showing brush %d popup", brushIndex)
+        val inflater = LayoutInflater.from(requireContext())
+        val popupView = inflater.inflate(R.layout.popup_brush_options, null)
+        val strokeSlider = popupView.findViewById<Slider>(R.id.stroke_width_slider)
+        val colorButton = popupView.findViewById<MaterialButton>(R.id.color_picker_button)
+        val valueIndicator = popupView.findViewById<TextView>(R.id.stroke_width_value_indicator)
+
+        val currentBrush = viewModel.brushes.value.getOrNull(brushIndex) ?: return
+
+        val previewDrawable = (colorButton.icon as? LayerDrawable)
+        val fillDrawable = previewDrawable?.findDrawableByLayerId(R.id.brush_preview_fill) as? GradientDrawable
+        fillDrawable?.setColor(currentBrush.color)
+        colorButton.icon = previewDrawable
+
+        colorButton.setOnClickListener {
+            showChangeColorDialog()
+        }
+
+        strokeSlider.value = currentBrush.width
+        valueIndicator.text = currentBrush.width.roundToInt().toString()
+        colorButton.iconSize = currentBrush.width.roundToInt()
+
+        // Set slider colors
+        val color = currentBrush.color
+        val colorStateList = ColorStateList.valueOf(color)
+        strokeSlider.trackActiveTintList = colorStateList
+        strokeSlider.thumbTintList = colorStateList
+        strokeSlider.haloTintList = colorStateList
+
+        strokeSlider.addOnChangeListener { _, value, fromUser ->
+            // Dynamically change the size of the brush preview icon
+            colorButton.iconSize = value.roundToInt()
+            valueIndicator.text = value.roundToInt().toString()
+
+            if (fromUser) viewModel.setActiveStrokeWidth(value)
+        }
+        strokeSlider.setLabelFormatter { value: Float -> value.roundToInt().toString() }
+
+        strokeWidthPopup = PopupWindow(popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true)
+        strokeWidthPopup?.elevation = resources.getDimension(R.dimen.study_screen_elevation)
+        strokeWidthPopup?.setOnDismissListener {
+            updateToolbarSelection()
+            strokeWidthPopup = null
+        }
+
+        popupView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED)
+        val yOffset = -(anchorView.height + popupView.measuredHeight)
+        val xOffset = (anchorView.width - popupView.measuredWidth) / 2
+        strokeWidthPopup?.showAsDropDown(anchorView, xOffset, yOffset)
+    }
+
+    /**
+     * Shows a color picker popup to change the active brush's color.
+     */
+    private fun showChangeColorDialog() {
+        ColorPickerPopUp(requireContext())
+            .setShowAlpha(true)
+            .setDefaultColor(viewModel.brushColor.value)
+            .setOnPickColorListener(
+                object : ColorPickerPopUp.OnPickColorListener {
+                    override fun onColorPicked(color: Int) {
+                        viewModel.updateBrushColor(color)
+                        strokeWidthPopup?.dismiss()
+                    }
+
+                    override fun onCancel() {}
+                },
+            ).show()
+    }
+
+    /**
+     * Shows a popup with eraser options (mode, width, clear).
+     */
+    private fun showEraserOptionsPopup(anchorView: View) {
+        val inflater = LayoutInflater.from(requireContext())
+        val popupView = inflater.inflate(R.layout.popup_eraser_options, null)
+        val slider = popupView.findViewById<Slider>(R.id.eraser_width_slider)
+        val toggleGroup = popupView.findViewById<MaterialButtonToggleGroup>(R.id.eraser_mode_toggle_group)
+        val clearButton = popupView.findViewById<MaterialButton>(R.id.clear_button_popup)
+
+        slider.value = viewModel.eraserDisplayWidth.value
+        slider.addOnChangeListener { _, value, fromUser ->
+            if (fromUser) viewModel.setActiveStrokeWidth(value)
+        }
+        slider.setLabelFormatter { value: Float -> value.roundToInt().toString() }
+
+        toggleGroup.clearOnButtonCheckedListeners()
+        when (viewModel.eraserMode.value) {
+            EraserMode.STROKE -> toggleGroup.check(R.id.eraser_mode_stroke)
+            EraserMode.INK -> toggleGroup.check(R.id.eraser_mode_ink)
+        }
+        toggleGroup.addOnButtonCheckedListener { _, checkedId, isChecked ->
+            if (isChecked) {
+                when (checkedId) {
+                    R.id.eraser_mode_stroke -> {
+                        viewModel.setEraserMode(EraserMode.STROKE)
+                        slider.value = viewModel.strokeEraserStrokeWidth.value
+                    }
+                    R.id.eraser_mode_ink -> {
+                        viewModel.setEraserMode(EraserMode.INK)
+                        slider.value = viewModel.inkEraserStrokeWidth.value
+                    }
+                }
+            }
+        }
+
+        clearButton.setOnClickListener {
+            viewModel.clearCanvas()
+            eraserPopup?.dismiss()
+        }
+
+        eraserPopup = PopupWindow(popupView, 360.dp.toPx(requireContext()), ViewGroup.LayoutParams.WRAP_CONTENT, true)
+        eraserPopup?.elevation = 8f
+        eraserPopup?.setOnDismissListener {
+            updateToolbarSelection()
+            eraserPopup = null
+        }
+
+        popupView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED)
+        val yOffset = -(anchorView.height + popupView.measuredHeight)
+        val xOffset = (anchorView.width - popupView.measuredWidth) / 2
+        eraserPopup?.showAsDropDown(anchorView, xOffset, yOffset)
+    }
+
+    /**
+     * Updates the toolbar's constraints and orientation.
+     */
+    private fun updateLayoutForAlignment(alignment: ToolbarAlignment) {
+        val controlsContainer = view?.findViewById<View>(R.id.controls_container) ?: return
+        val innerLayout = view?.findViewById<LinearLayout>(R.id.inner_controls_layout) ?: return
+        val divider = view?.findViewById<View>(R.id.controls_divider) ?: return
+        val rootLayout = view as? ConstraintLayout ?: return
+        val brushScrollViewHorizontal = view?.findViewById<HorizontalScrollView>(R.id.brush_scroll_view_horizontal) ?: return
+        val brushScrollViewVertical = view?.findViewById<ScrollView>(R.id.brush_scroll_view_vertical) ?: return
+
+        val isVertical = alignment == ToolbarAlignment.LEFT || alignment == ToolbarAlignment.RIGHT
+        innerLayout.orientation = if (isVertical) LinearLayout.VERTICAL else LinearLayout.HORIZONTAL
+
+        if (isVertical) {
+            brushScrollViewHorizontal.visibility = View.GONE
+            brushScrollViewVertical.visibility = View.VISIBLE
+        } else {
+            brushScrollViewHorizontal.visibility = View.VISIBLE
+            brushScrollViewVertical.visibility = View.GONE
+        }
+
+        val dp = 1.dp.toPx(requireContext())
+        val dividerParams = divider.layoutParams as LinearLayout.LayoutParams
+        val dividerMargin = 4 * dp
+        if (isVertical) {
+            dividerParams.width = LinearLayout.LayoutParams.MATCH_PARENT
+            dividerParams.height = 1 * dp
+            dividerParams.setMargins(0, dividerMargin, 0, dividerMargin)
+        } else {
+            dividerParams.width = 1 * dp
+            dividerParams.height = LinearLayout.LayoutParams.MATCH_PARENT
+            dividerParams.setMargins(dividerMargin, 0, dividerMargin, 0)
+        }
+        divider.layoutParams = dividerParams
+
+        val constraintSet = ConstraintSet()
+        constraintSet.clone(rootLayout)
+        val containerId = controlsContainer.id
+        constraintSet.clear(containerId)
+
+        when (alignment) {
+            ToolbarAlignment.BOTTOM -> {
+                constraintSet.connect(containerId, ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM)
+                constraintSet.connect(containerId, ConstraintSet.START, ConstraintSet.PARENT_ID, ConstraintSet.START)
+                constraintSet.connect(containerId, ConstraintSet.END, ConstraintSet.PARENT_ID, ConstraintSet.END)
+                constraintSet.constrainWidth(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.constrainHeight(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.constrainedWidth(containerId, true)
+                constraintSet.setMargin(containerId, ConstraintSet.START, 24 * dp)
+                constraintSet.setMargin(containerId, ConstraintSet.END, 24 * dp)
+                constraintSet.setMargin(containerId, ConstraintSet.BOTTOM, 8 * dp)
+            }
+            ToolbarAlignment.RIGHT -> {
+                constraintSet.connect(containerId, ConstraintSet.END, ConstraintSet.PARENT_ID, ConstraintSet.END)
+                constraintSet.connect(containerId, ConstraintSet.TOP, ConstraintSet.PARENT_ID, ConstraintSet.TOP)
+                constraintSet.connect(containerId, ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM)
+                constraintSet.constrainWidth(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.constrainHeight(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.setMargin(containerId, ConstraintSet.END, 8 * dp)
+            }
+            ToolbarAlignment.LEFT -> {
+                constraintSet.connect(containerId, ConstraintSet.START, ConstraintSet.PARENT_ID, ConstraintSet.START)
+                constraintSet.connect(containerId, ConstraintSet.TOP, ConstraintSet.PARENT_ID, ConstraintSet.TOP)
+                constraintSet.connect(containerId, ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM)
+                constraintSet.constrainWidth(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.constrainHeight(containerId, ConstraintSet.WRAP_CONTENT)
+                constraintSet.setMargin(containerId, ConstraintSet.START, 8 * dp)
+            }
+        }
+
+        constraintSet.applyTo(rootLayout)
+    }
+
+    override fun onMenuItemClick(item: MenuItem): Boolean {
+        Timber.i("WhiteboardFragment::onMenuItemClick %s", item.title)
+        when (item.itemId) {
+            R.id.action_toggle_stylus -> {
+                item.isChecked = !item.isChecked
+                viewModel.toggleStylusOnlyMode()
+            }
+            R.id.action_align_left -> viewModel.setToolbarAlignment(ToolbarAlignment.LEFT)
+            R.id.action_align_bottom -> viewModel.setToolbarAlignment(ToolbarAlignment.BOTTOM)
+            R.id.action_align_right -> viewModel.setToolbarAlignment(ToolbarAlignment.RIGHT)
+            else -> return false
+        }
+        return true
+    }
+
+    fun resetCanvas() = viewModel.reset()
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepository.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepository.kt
new file mode 100644
index 000000000000..509546020916
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepository.kt
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+
+import android.content.SharedPreferences
+import android.graphics.Color
+import androidx.core.content.edit
+
+/**
+ * Holds the configuration for a single brush.
+ */
+data class BrushInfo(
+    val color: Int,
+    val width: Float,
+)
+
+/**
+ * Repository for handling data operations, specifically for saving and loading
+ * whiteboard settings from SharedPreferences.
+ */
+class WhiteboardRepository(
+    private val sharedPreferences: SharedPreferences,
+) {
+    fun saveBrushes(
+        brushes: List<BrushInfo>,
+        isDarkMode: Boolean,
+    ) {
+        val key = if (isDarkMode) KEY_BRUSHES_DARK else KEY_BRUSHES_LIGHT
+        sharedPreferences.edit { putString(key, brushes.toPreferenceString()) }
+    }
+
+    fun loadBrushes(isDarkMode: Boolean): List<BrushInfo> {
+        val key = if (isDarkMode) KEY_BRUSHES_DARK else KEY_BRUSHES_LIGHT
+        val saved = sharedPreferences.getString(key, null)
+        return if (saved.isNullOrEmpty()) {
+            getDefaultBrushes(isDarkMode)
+        } else {
+            saved.fromPreferenceString()
+        }
+    }
+
+    fun saveLastActiveBrushIndex(
+        index: Int,
+        isDarkMode: Boolean,
+    ) {
+        val key = if (isDarkMode) KEY_LAST_ACTIVE_BRUSH_INDEX_DARK else KEY_LAST_ACTIVE_BRUSH_INDEX_LIGHT
+        sharedPreferences.edit { putInt(key, index) }
+    }
+
+    fun loadLastActiveBrushIndex(isDarkMode: Boolean): Int {
+        val key = if (isDarkMode) KEY_LAST_ACTIVE_BRUSH_INDEX_DARK else KEY_LAST_ACTIVE_BRUSH_INDEX_LIGHT
+        return sharedPreferences.getInt(key, 0)
+    }
+
+    var inkEraserWidth: Float
+        get() = sharedPreferences.getFloat(KEY_INK_ERASER_WIDTH, DEFAULT_ERASER_WIDTH)
+        set(value) = sharedPreferences.edit { putFloat(KEY_INK_ERASER_WIDTH, value) }
+
+    var strokeEraserWidth: Float
+        get() = sharedPreferences.getFloat(KEY_STROKE_ERASER_WIDTH, DEFAULT_ERASER_WIDTH)
+        set(value) = sharedPreferences.edit { putFloat(KEY_STROKE_ERASER_WIDTH, value) }
+
+    var eraserMode: EraserMode
+        get() {
+            val value = sharedPreferences.getString(KEY_ERASER_MODE, EraserMode.INK.name) ?: EraserMode.INK.name
+            return EraserMode.entries.firstOrNull { it.name == value } ?: EraserMode.INK
+        }
+        set(value) = sharedPreferences.edit { putString(KEY_ERASER_MODE, value.name) }
+
+    var stylusOnlyMode: Boolean
+        get() = sharedPreferences.getBoolean(KEY_STYLUS_ONLY_MODE, false)
+        set(value) = sharedPreferences.edit { putBoolean(KEY_STYLUS_ONLY_MODE, value) }
+
+    var toolbarAlignment: ToolbarAlignment
+        get() {
+            val value = sharedPreferences.getString(KEY_TOOLBAR_ALIGNMENT, ToolbarAlignment.BOTTOM.name) ?: ToolbarAlignment.BOTTOM.name
+            return ToolbarAlignment.entries.firstOrNull { it.name == value } ?: ToolbarAlignment.BOTTOM
+        }
+        set(value) = sharedPreferences.edit { putString(KEY_TOOLBAR_ALIGNMENT, value.name) }
+
+    private fun List<BrushInfo>.toPreferenceString(): String = this.joinToString(",") { "${it.color}|${it.width}" }
+
+    private fun String.fromPreferenceString(): List<BrushInfo> =
+        this.split(',').mapNotNull {
+            val parts = it.split('|')
+            if (parts.size == 2) {
+                try {
+                    BrushInfo(color = parts[0].toInt(), width = parts[1].toFloat())
+                } catch (_: NumberFormatException) {
+                    null
+                }
+            } else {
+                null
+            }
+        }
+
+    companion object {
+        private const val KEY_BRUSHES_LIGHT = "brushes_light"
+        private const val KEY_LAST_ACTIVE_BRUSH_INDEX_LIGHT = "last_active_brush_index_light"
+        private const val KEY_BRUSHES_DARK = "brushes_dark"
+        private const val KEY_LAST_ACTIVE_BRUSH_INDEX_DARK = "last_active_brush_index_dark"
+        private const val KEY_INK_ERASER_WIDTH = "ink_eraser_width"
+        private const val KEY_STROKE_ERASER_WIDTH = "stroke_eraser_width"
+        private const val KEY_ERASER_MODE = "eraser_mode"
+        private const val KEY_STYLUS_ONLY_MODE = "stylus_only_mode"
+        private const val KEY_TOOLBAR_ALIGNMENT = "toolbar_alignment"
+        const val DEFAULT_STROKE_WIDTH = 10f
+        const val DEFAULT_ERASER_WIDTH = 30f
+
+        fun getDefaultBrushes(isDarkMode: Boolean): List<BrushInfo> =
+            if (isDarkMode) {
+                listOf(
+                    BrushInfo(color = Color.WHITE, width = DEFAULT_STROKE_WIDTH),
+                )
+            } else {
+                listOf(
+                    BrushInfo(color = Color.BLACK, width = DEFAULT_STROKE_WIDTH),
+                )
+            }
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardView.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardView.kt
new file mode 100644
index 000000000000..9956fe5ae5c3
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardView.kt
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.graphics.Path
+import android.graphics.PorterDuff
+import android.graphics.PorterDuffXfermode
+import android.util.AttributeSet
+import android.view.MotionEvent
+import android.view.View
+import androidx.core.graphics.createBitmap
+import com.ichi2.anki.R
+
+/**
+ * A custom view for the whiteboard that handles drawing and touch events.
+ */
+class WhiteboardView : View {
+    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)
+    constructor(context: Context) : this(context, null)
+
+    // Callbacks for user actions
+    var onNewPath: ((Path) -> Unit)? = null
+    var onEraseGestureStart: (() -> Unit)? = null
+    var onEraseGestureMove: ((Float, Float) -> Unit)? = null
+    var onEraseGestureEnd: (() -> Unit)? = null
+
+    // Public properties for tool state
+    var isEraserActive: Boolean = false
+    var eraserMode: EraserMode = EraserMode.INK
+    var isStylusOnlyMode: Boolean = false
+
+    // Internal drawing state
+    private val currentPath = Path()
+    private val currentPaint =
+        Paint().apply {
+            isAntiAlias = true
+            isDither = true
+            style = Paint.Style.STROKE
+            strokeJoin = Paint.Join.ROUND
+            strokeCap = Paint.Cap.ROUND
+        }
+    private val eraserPreviewPaint =
+        Paint(currentPaint).apply {
+            color = context.getColor(R.color.whiteboard_eraser)
+        }
+    private var history: List<DrawingAction> = emptyList()
+    private lateinit var bufferCanvas: Canvas
+    private lateinit var bufferBitmap: Bitmap
+    private val canvasPaint = Paint(Paint.DITHER_FLAG)
+
+    private var hasMoved = false
+
+    /**
+     * Recreates the drawing buffer when the view size changes.
+     */
+    override fun onSizeChanged(
+        w: Int,
+        h: Int,
+        oldw: Int,
+        oldh: Int,
+    ) {
+        super.onSizeChanged(w, h, oldw, oldh)
+        if (::bufferBitmap.isInitialized) bufferBitmap.recycle()
+        bufferBitmap = createBitmap(w, h)
+        bufferCanvas = Canvas(bufferBitmap)
+        redrawHistory()
+    }
+
+    /**
+     * Draws the whiteboard content.
+     * This includes the historical drawing buffer and the current live path.
+     */
+    override fun onDraw(canvas: Canvas) {
+        super.onDraw(canvas)
+        // Draw the committed history
+        canvas.drawBitmap(bufferBitmap, 0f, 0f, canvasPaint)
+
+        // Draw the live preview path for the current gesture
+        if (isEraserActive) {
+            canvas.drawPath(currentPath, eraserPreviewPaint)
+        } else {
+            // Draw the normal brush or pixel eraser preview
+            canvas.drawPath(currentPath, currentPaint)
+        }
+    }
+
+    /**
+     * Handles user touch input for drawing and erasing.
+     * Ignores finger input if stylus-only mode is enabled.
+     */
+    override fun onTouchEvent(event: MotionEvent): Boolean {
+        if (isStylusOnlyMode && event.getToolType(0) != MotionEvent.TOOL_TYPE_STYLUS) {
+            return false
+        }
+
+        val touchX = event.x
+        val touchY = event.y
+        val isPathEraser = isEraserActive && eraserMode == EraserMode.STROKE
+
+        when (event.action) {
+            MotionEvent.ACTION_DOWN -> {
+                hasMoved = false
+                currentPath.moveTo(touchX, touchY)
+                if (isPathEraser) {
+                    onEraseGestureStart?.invoke()
+                    onEraseGestureMove?.invoke(touchX, touchY)
+                }
+                invalidate()
+            }
+            MotionEvent.ACTION_MOVE -> {
+                hasMoved = true
+                currentPath.lineTo(touchX, touchY)
+                if (isPathEraser) {
+                    onEraseGestureMove?.invoke(touchX, touchY)
+                }
+                invalidate()
+            }
+            MotionEvent.ACTION_UP -> {
+                if (isPathEraser) {
+                    onEraseGestureEnd?.invoke()
+                } else {
+                    if (!hasMoved) {
+                        // A single tap. Add a tiny line segment to ensure it has a non-zero length,
+                        // which makes it more robust for path operations.
+                        currentPath.lineTo(touchX + 0.2f, touchY + 0.2f)
+                    }
+                    onNewPath?.invoke(Path(currentPath))
+                }
+                // Reset the path for the next gesture
+                currentPath.reset()
+                invalidate()
+            }
+            else -> return false
+        }
+        return true
+    }
+
+    /**
+     * Replaces the current drawing history with a new set of actions and redraws the buffer.
+     */
+    fun setHistory(actions: List<DrawingAction>) {
+        history = actions
+        redrawHistory()
+    }
+
+    /**
+     * Configures the paint for the live drawing preview based on the current tool.
+     */
+    fun setCurrentBrush(
+        color: Int,
+        strokeWidth: Float,
+    ) {
+        currentPaint.strokeWidth = strokeWidth
+        currentPaint.xfermode = null
+        currentPaint.color = color
+
+        // Configure the stroke eraser's preview paint separately
+        eraserPreviewPaint.strokeWidth = strokeWidth
+    }
+
+    /**
+     * Redraws all historical paths onto the offscreen buffer.
+     */
+    private fun redrawHistory() {
+        if (!::bufferCanvas.isInitialized) return
+        bufferCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR)
+        val tempPaint =
+            Paint().apply {
+                isAntiAlias = true
+                isDither = true
+                style = Paint.Style.STROKE
+                strokeJoin = Paint.Join.ROUND
+                strokeCap = Paint.Cap.ROUND
+            }
+        for (action in history) {
+            tempPaint.strokeWidth = action.strokeWidth
+            if (action.isEraser) {
+                tempPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.CLEAR)
+            } else {
+                tempPaint.xfermode = null
+                tempPaint.color = action.color
+            }
+            bufferCanvas.drawPath(action.path, tempPaint)
+        }
+        invalidate()
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardViewModel.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardViewModel.kt
new file mode 100644
index 000000000000..967811e47e29
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardViewModel.kt
@@ -0,0 +1,454 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+import android.content.SharedPreferences
+import android.graphics.Color
+import android.graphics.Path
+import android.graphics.PathMeasure
+import androidx.annotation.CheckResult
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.viewModelScope
+import androidx.lifecycle.viewmodel.initializer
+import androidx.lifecycle.viewmodel.viewModelFactory
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.SharingStarted
+import kotlinx.coroutines.flow.combine
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.flow.stateIn
+import kotlinx.coroutines.flow.update
+import timber.log.Timber
+
+/**
+ * Represents a single drawing action on the whiteboard, such as a brush stroke or an eraser mark.
+ */
+data class DrawingAction(
+    val path: Path,
+    val color: Int,
+    val strokeWidth: Float,
+    val isEraser: Boolean = false,
+)
+
+/**
+ * Defines the available eraser modes: erasing by pixel or by entire path.
+ */
+enum class EraserMode { INK, STROKE }
+
+/**
+ * Defines the available toolbar alignment options.
+ */
+enum class ToolbarAlignment { LEFT, RIGHT, BOTTOM }
+
+/**
+ * Represents a command that can be undone and redone.
+ */
+sealed class UndoableAction
+
+data class AddAction(
+    val added: DrawingAction,
+) : UndoableAction()
+
+data class RemoveAction(
+    val removed: List<Pair<Int, DrawingAction>>,
+) : UndoableAction()
+
+data class ClearAction(
+    val cleared: List<DrawingAction>,
+) : UndoableAction()
+
+/**
+ * Manages the state and business logic for the whiteboard.
+ * This includes handling drawing paths, undo/redo stacks, brush/eraser settings,
+ * and persisting user preferences via the WhiteboardRepository.
+ */
+class WhiteboardViewModel(
+    private val repository: WhiteboardRepository,
+) : ViewModel() {
+    // State for drawing history and undo/redo
+    val paths = MutableStateFlow<List<DrawingAction>>(emptyList())
+    private val undoStack = MutableStateFlow<List<UndoableAction>>(emptyList())
+    private val redoStack = MutableStateFlow<List<UndoableAction>>(emptyList())
+    val canUndo = undoStack.map { it.isNotEmpty() }.stateIn(viewModelScope, SharingStarted.Eagerly, false)
+    val canRedo = redoStack.map { it.isNotEmpty() }.stateIn(viewModelScope, SharingStarted.Eagerly, false)
+
+    // State for brushes
+    val brushes = MutableStateFlow<List<BrushInfo>>(emptyList())
+    val activeBrushIndex = MutableStateFlow(0)
+
+    // State for the currently active tool's properties
+    val inkEraserStrokeWidth = MutableStateFlow(WhiteboardRepository.DEFAULT_ERASER_WIDTH)
+    val strokeEraserStrokeWidth = MutableStateFlow(WhiteboardRepository.DEFAULT_ERASER_WIDTH)
+
+    val brushColor = MutableStateFlow(Color.BLACK)
+    val activeStrokeWidth = MutableStateFlow(WhiteboardRepository.DEFAULT_STROKE_WIDTH)
+    val isEraserActive = MutableStateFlow(false)
+    val eraserMode = MutableStateFlow(EraserMode.INK)
+    val isStylusOnlyMode = MutableStateFlow(false)
+    val toolbarAlignment = MutableStateFlow(ToolbarAlignment.BOTTOM)
+
+    val eraserDisplayWidth =
+        combine(eraserMode, inkEraserStrokeWidth, strokeEraserStrokeWidth) { mode, inkWidth, strokeWidth ->
+            if (mode == EraserMode.INK) inkWidth else strokeWidth
+        }.stateIn(viewModelScope, SharingStarted.Eagerly, WhiteboardRepository.DEFAULT_ERASER_WIDTH)
+
+    private val pathsErasedInCurrentGesture = mutableListOf<DrawingAction>()
+    private var pathsBeforeGesture: List<DrawingAction> = emptyList()
+    private var isDarkMode = false
+
+    /**
+     * Loads saved preferences for brushes and eraser settings from the repository.
+     */
+    fun loadState(isDarkMode: Boolean) {
+        this.isDarkMode = isDarkMode
+        brushes.value = repository.loadBrushes(isDarkMode)
+        inkEraserStrokeWidth.value = repository.inkEraserWidth
+        strokeEraserStrokeWidth.value = repository.strokeEraserWidth
+        eraserMode.value = repository.eraserMode
+        isStylusOnlyMode.value = repository.stylusOnlyMode
+        toolbarAlignment.value = repository.toolbarAlignment
+
+        val lastActiveIndex = repository.loadLastActiveBrushIndex(isDarkMode)
+
+        if (!isEraserActive.value) {
+            setActiveBrush(lastActiveIndex)
+        }
+    }
+
+    /**
+     * Adds a new completed path to the drawing history.
+     */
+    fun addPath(path: Path) {
+        val isPixelEraser = isEraserActive.value && eraserMode.value == EraserMode.INK
+        val newAction =
+            DrawingAction(
+                path,
+                brushColor.value,
+                activeStrokeWidth.value,
+                isPixelEraser,
+            )
+        paths.update { it + newAction }
+        undoStack.update { it + AddAction(newAction) }
+        redoStack.value = emptyList()
+    }
+
+    /**
+     * Clears the list of paths erased in the current gesture.
+     */
+    fun startPathEraseGesture() {
+        pathsBeforeGesture = paths.value
+        pathsErasedInCurrentGesture.clear()
+    }
+
+    /**
+     * Finds and removes paths that intersect with the given point.
+     */
+    fun erasePathsAtPoint(
+        x: Float,
+        y: Float,
+    ) {
+        if (paths.value.isEmpty()) return
+
+        val remainingPaths = paths.value.toMutableList()
+        var pathWasErased = false
+
+        val pathsToEvaluate = remainingPaths.filter { it !in pathsErasedInCurrentGesture && !it.isEraser }
+
+        for (action in pathsToEvaluate) {
+            if (isPathIntersectingWithCircle(action, x, y, activeStrokeWidth.value / 2)) {
+                remainingPaths.remove(action)
+                pathsErasedInCurrentGesture.add(action)
+                pathWasErased = true
+            }
+        }
+
+        if (pathWasErased) {
+            paths.value = remainingPaths
+        }
+    }
+
+    /**
+     * Checks if a path intersects with a circular area.
+     */
+    private fun isPathIntersectingWithCircle(
+        action: DrawingAction,
+        cx: Float,
+        cy: Float,
+        eraserRadius: Float,
+    ): Boolean {
+        val path = action.path
+        val pathStrokeWidth = action.strokeWidth
+
+        val pathMeasure = PathMeasure(path, false)
+        val length = pathMeasure.length
+        val pos = FloatArray(2)
+
+        val pathRadius = pathStrokeWidth / 2
+        val totalRadius = eraserRadius + pathRadius
+        val totalRadiusSquared = totalRadius * totalRadius
+
+        if (length == 0f) {
+            pathMeasure.getPosTan(0f, pos, null)
+            val dx = pos[0] - cx
+            val dy = pos[1] - cy
+            return dx * dx + dy * dy <= totalRadiusSquared
+        }
+
+        var distance = 0f
+        while (distance < length) {
+            pathMeasure.getPosTan(distance, pos, null)
+            val dx = pos[0] - cx
+            val dy = pos[1] - cy
+            if (dx * dx + dy * dy <= totalRadiusSquared) {
+                return true
+            }
+            distance += 1f
+        }
+        return false
+    }
+
+    /**
+     * Finalizes a path erase gesture, adding the erased paths to the undo stack.
+     */
+    fun endPathEraseGesture() {
+        if (pathsErasedInCurrentGesture.isNotEmpty()) {
+            val removedWithIndices =
+                pathsErasedInCurrentGesture.mapNotNull { removedAction ->
+                    val index = pathsBeforeGesture.indexOf(removedAction)
+                    if (index != -1) {
+                        Pair(index, removedAction)
+                    } else {
+                        null
+                    }
+                }
+            val action = RemoveAction(removedWithIndices)
+            undoStack.update { it + action }
+            redoStack.value = emptyList()
+            pathsErasedInCurrentGesture.clear()
+        }
+    }
+
+    /**
+     * Reverts the last drawing action.
+     */
+    fun undo() {
+        val lastAction = undoStack.value.lastOrNull() ?: return
+
+        undoStack.update { it.dropLast(1) }
+        redoStack.update { it + lastAction }
+
+        when (lastAction) {
+            is AddAction -> {
+                paths.update { list -> list.filterNot { it === lastAction.added } }
+            }
+            is RemoveAction -> {
+                paths.update { currentPaths ->
+                    val mutablePaths = currentPaths.toMutableList()
+                    lastAction.removed.sortedBy { it.first }.forEach { (index, action) ->
+                        mutablePaths.add(index.coerceAtMost(mutablePaths.size), action)
+                    }
+                    mutablePaths
+                }
+            }
+            is ClearAction -> {
+                paths.update { it + lastAction.cleared }
+            }
+        }
+    }
+
+    /**
+     * Restores the last undone drawing action.
+     */
+    fun redo() {
+        val actionToRedo = redoStack.value.lastOrNull() ?: return
+
+        redoStack.update { it.dropLast(1) }
+        undoStack.update { it + actionToRedo }
+
+        when (actionToRedo) {
+            is AddAction -> {
+                paths.update { it + actionToRedo.added }
+            }
+            is RemoveAction -> {
+                val actionsToRemove = actionToRedo.removed.map { it.second }
+                paths.update { list -> list.filterNot { it in actionsToRemove } }
+            }
+            is ClearAction -> {
+                paths.value = emptyList()
+            }
+        }
+    }
+
+    /**
+     * Clears all paths from the canvas.
+     */
+    fun clearCanvas() {
+        if (paths.value.isNotEmpty()) {
+            val action = ClearAction(paths.value)
+            undoStack.update { it + action }
+            redoStack.value = emptyList()
+            paths.value = emptyList()
+        }
+    }
+
+    /**
+     * Sets the active brush by its index and deactivates the eraser if it was active.
+     */
+    fun setActiveBrush(index: Int) {
+        val brush = brushes.value.getOrNull(index) ?: return
+
+        isEraserActive.value = false
+        activeBrushIndex.value = index
+        repository.saveLastActiveBrushIndex(index, isDarkMode)
+
+        brushColor.value = brush.color
+        activeStrokeWidth.value = brush.width
+    }
+
+    /**
+     * Toggles the eraser tool on or off.
+     */
+    fun enableEraser() {
+        isEraserActive.value = true
+        activeStrokeWidth.value = eraserDisplayWidth.value
+    }
+
+    /**
+     * Sets the eraser mode (pixel or path).
+     */
+    fun setEraserMode(mode: EraserMode) {
+        eraserMode.value = mode
+        repository.eraserMode = mode
+        if (isEraserActive.value) {
+            activeStrokeWidth.value =
+                if (mode == EraserMode.INK) {
+                    inkEraserStrokeWidth.value
+                } else {
+                    strokeEraserStrokeWidth.value
+                }
+        }
+    }
+
+    /**
+     * Sets the stroke width for the currently active tool (brush or eraser).
+     */
+    fun setActiveStrokeWidth(newWidth: Float) {
+        if (isEraserActive.value) {
+            if (eraserMode.value == EraserMode.INK) {
+                inkEraserStrokeWidth.value = newWidth
+                repository.inkEraserWidth = newWidth
+            } else {
+                strokeEraserStrokeWidth.value = newWidth
+                repository.strokeEraserWidth = newWidth
+            }
+        } else {
+            // Update the width of the active brush
+            val activeIndex = activeBrushIndex.value
+            val updatedBrushes = brushes.value.replaceAt(activeIndex) { it.copy(width = newWidth) }
+            brushes.value = updatedBrushes
+            repository.saveBrushes(updatedBrushes, isDarkMode)
+        }
+        activeStrokeWidth.value = newWidth
+    }
+
+    @CheckResult
+    fun <T> List<T>.replaceAt(
+        index: Int,
+        replace: (T) -> T,
+    ): List<T> = this.mapIndexed { i, value -> if (i == index) replace(value) else value }
+
+    /**
+     * Replaces the active brush's color with a new one.
+     */
+    fun updateBrushColor(newColor: Int) {
+        Timber.i("Updating brush color to %d", newColor)
+        val activeIndex = activeBrushIndex.value
+        val updatedBrushes = brushes.value.replaceAt(activeIndex) { it.copy(color = newColor) }
+
+        brushes.value = updatedBrushes
+        repository.saveBrushes(brushes.value, isDarkMode)
+        brushColor.value = newColor
+    }
+
+    /**
+     * Adds a new brush color to the user's palette.
+     */
+    fun addBrush(color: Int) {
+        val newBrush = BrushInfo(color = color, width = WhiteboardRepository.DEFAULT_STROKE_WIDTH)
+        val updatedBrushes = brushes.value + newBrush
+        brushes.value = updatedBrushes
+        repository.saveBrushes(brushes.value, isDarkMode)
+        setActiveBrush(updatedBrushes.lastIndex)
+    }
+
+    /**
+     * Removes a brush from the user's palette by its index.
+     */
+    fun removeBrush(indexToRemove: Int) {
+        if (brushes.value.size <= 1) return
+
+        val oldActiveIndex = activeBrushIndex.value
+        val updatedBrushes = brushes.value.filterIndexed { i, _ -> i != indexToRemove }
+        brushes.value = updatedBrushes
+        repository.saveBrushes(brushes.value, isDarkMode)
+
+        when {
+            oldActiveIndex == indexToRemove -> {
+                val newIndex = (oldActiveIndex - 1).coerceAtLeast(0)
+                setActiveBrush(newIndex)
+            }
+            oldActiveIndex > indexToRemove -> {
+                setActiveBrush(oldActiveIndex - 1)
+            }
+        }
+    }
+
+    /**
+     * Toggles the stylus-only drawing mode.
+     */
+    fun toggleStylusOnlyMode() {
+        val newMode = !isStylusOnlyMode.value
+        isStylusOnlyMode.value = newMode
+        repository.stylusOnlyMode = newMode
+    }
+
+    /**
+     * Sets the toolbar alignment.
+     */
+    fun setToolbarAlignment(alignment: ToolbarAlignment) {
+        if (toolbarAlignment.value != alignment) {
+            toolbarAlignment.value = alignment
+            repository.toolbarAlignment = alignment
+        }
+    }
+
+    /**
+     * Clear the canvas and the undo/redo states
+     */
+    fun reset() {
+        clearCanvas()
+        undoStack.value = emptyList()
+        redoStack.value = emptyList()
+    }
+
+    companion object {
+        fun factory(sharedPreferences: SharedPreferences): ViewModelProvider.Factory =
+            viewModelFactory {
+                initializer {
+                    WhiteboardViewModel(WhiteboardRepository(sharedPreferences))
+                }
+            }
+    }
+}
diff --git a/AnkiDroid/src/main/res/color/selector_tool_background.xml b/AnkiDroid/src/main/res/color/selector_tool_background.xml
new file mode 100644
index 000000000000..16de7be110a1
--- /dev/null
+++ b/AnkiDroid/src/main/res/color/selector_tool_background.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:color="#33AAAAAA" android:state_checked="true"/>
+    <item android:color="@android:color/transparent"/>
+</selector>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/drawable/brush_preview_background.xml b/AnkiDroid/src/main/res/drawable/brush_preview_background.xml
new file mode 100644
index 000000000000..61b431905952
--- /dev/null
+++ b/AnkiDroid/src/main/res/drawable/brush_preview_background.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
+    <!-- Fill  -->
+    <item android:id="@+id/brush_preview_fill">
+        <shape android:shape="oval">
+            <solid android:color="@android:color/white"/>
+        </shape>
+    </item>
+    <!-- Border -->
+    <item>
+        <shape android:shape="oval">
+            <solid android:color="@android:color/transparent"/>
+            <stroke
+                android:width="1dp"
+                android:color="#808080"/>
+        </shape>
+    </item>
+</layer-list>
diff --git a/AnkiDroid/src/main/res/layout/button_color_brush.xml b/AnkiDroid/src/main/res/layout/button_color_brush.xml
new file mode 100644
index 000000000000..0cfaec977de7
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/button_color_brush.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.android.material.button.MaterialButton
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:minWidth="?minTouchTargetSize"
+    style="@style/Widget.Material3.Button.TextButton"
+    app:icon="@drawable/brush_preview_background"
+    app:iconGravity="top"
+    android:textColor="?attr/colorControlNormal"
+    app:backgroundTint="@color/selector_tool_background"
+    android:textSize="12sp"
+    tools:text="12" />
diff --git a/AnkiDroid/src/main/res/layout/fragment_whiteboard.xml b/AnkiDroid/src/main/res/layout/fragment_whiteboard.xml
new file mode 100644
index 000000000000..2599fc174b2e
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/fragment_whiteboard.xml
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <com.ichi2.anki.ui.windows.reviewer.whiteboard.WhiteboardView
+        android:id="@+id/whiteboard_view"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent"/>
+
+    <androidx.cardview.widget.CardView
+        android:id="@+id/controls_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginHorizontal="24dp"
+        android:layout_marginVertical="24dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constrainedWidth="true"
+        app:cardElevation="@dimen/study_screen_elevation"
+        app:cardCornerRadius="16dp"
+        android:clickable="true"
+        android:focusable="true"
+        app:rippleColor="@android:color/transparent">
+
+        <LinearLayout
+            android:id="@+id/inner_controls_layout"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal"
+            android:gravity="center_vertical">
+
+            <ImageButton
+                android:id="@+id/undo_button"
+                style="@android:style/Widget.ActionButton"
+                android:layout_width="?minTouchTargetSize"
+                android:layout_height="match_parent"
+                android:src="@drawable/ic_undo_white"
+                android:contentDescription="@string/undo"
+                android:tooltipText="@string/undo"/>
+
+            <ImageButton
+                android:id="@+id/redo_button"
+                style="@android:style/Widget.ActionButton"
+                android:layout_width="?minTouchTargetSize"
+                android:layout_height="match_parent"
+                android:src="@drawable/ic_redo"
+                android:contentDescription="@string/redo"
+                android:tooltipText="@string/redo"/>
+
+            <com.ichi2.anki.ui.windows.reviewer.whiteboard.EraserButton
+                android:id="@+id/eraser_button"
+                style="@style/Widget.Material3.Button.TextButton"
+                android:layout_width="?minTouchTargetSize"
+                android:layout_height="wrap_content"
+                android:minWidth="0dp"
+                android:contentDescription="@string/eraser"
+                android:textColor="?attr/colorControlNormal"
+                android:textSize="12sp"
+                android:tooltipText="@string/eraser"
+                app:icon="@drawable/eraser"
+                app:backgroundTint="@color/selector_tool_background"
+                app:iconGravity="top"
+                tools:text="30" />
+
+            <ImageButton
+                android:id="@+id/overflow_menu_button"
+                style="@android:style/Widget.ActionButton"
+                android:layout_width="?minTouchTargetSize"
+                android:layout_height="match_parent"
+                android:contentDescription="@string/whiteboard_more_options"
+                android:src="@drawable/ic_more_vertical"
+                android:tooltipText="@string/whiteboard_more_options" />
+
+            <View
+                android:id="@+id/controls_divider"
+                android:layout_width="1dp"
+                android:layout_height="match_parent"
+                android:background="?android:attr/listDivider"
+                android:layout_marginHorizontal="4dp"/>
+
+            <FrameLayout
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content">
+
+                <HorizontalScrollView
+                    android:id="@+id/brush_scroll_view_horizontal"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:scrollbars="none">
+
+                    <LinearLayout
+                        android:id="@+id/brush_toolbar_container_horizontal"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:gravity="center_vertical"
+                        android:orientation="horizontal"/>
+
+                </HorizontalScrollView>
+
+                <ScrollView
+                    android:id="@+id/brush_scroll_view_vertical"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:visibility="gone"
+                    android:scrollbars="none">
+
+                    <LinearLayout
+                        android:id="@+id/brush_toolbar_container_vertical"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:gravity="center_horizontal"
+                        android:orientation="vertical"/>
+                </ScrollView>
+            </FrameLayout>
+        </LinearLayout>
+
+    </androidx.cardview.widget.CardView>
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/AnkiDroid/src/main/res/layout/popup_brush_options.xml b/AnkiDroid/src/main/res/layout/popup_brush_options.xml
new file mode 100644
index 000000000000..1ea35cd983fd
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/popup_brush_options.xml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    app:cardCornerRadius="8dp"
+    app:cardElevation="@dimen/study_screen_elevation">
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content">
+
+        <TextView
+            android:id="@+id/stroke_width_value_indicator"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="8dp"
+            android:textAppearance="?attr/textAppearanceBody2"
+            android:textColor="?attr/colorOnSurface"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            tools:text="28" />
+
+        <com.google.android.material.slider.Slider
+            android:id="@+id/stroke_width_slider"
+            android:layout_width="220dp"
+            android:layout_height="wrap_content"
+            android:stepSize="1.0"
+            android:valueFrom="1.0"
+            android:valueTo="60.0"
+            app:labelBehavior="gone"
+            app:thumbHeight="24dp"
+            app:tickVisible="false"
+            app:layout_constraintTop_toTopOf="@id/color_picker_button"
+            app:layout_constraintBottom_toBottomOf="parent"
+            />
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/color_picker_button"
+            style="?attr/materialIconButtonStyle"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:minWidth="56dp"
+            android:minHeight="56dp"
+            app:layout_constraintStart_toEndOf="@id/stroke_width_slider"
+            app:layout_constraintTop_toBottomOf="@id/stroke_width_value_indicator"
+            app:iconGravity="textStart"
+            app:iconPadding="0dp"
+            app:icon="@drawable/brush_preview_background"
+            app:iconTint="@null" />
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</androidx.cardview.widget.CardView>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/layout/popup_eraser_options.xml b/AnkiDroid/src/main/res/layout/popup_eraser_options.xml
new file mode 100644
index 000000000000..47499858e375
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/popup_eraser_options.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="360dp"
+    android:layout_height="wrap_content"
+    app:cardCornerRadius="8dp"
+    app:cardElevation="@dimen/study_screen_elevation">
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="8dp">
+
+        <com.google.android.material.button.MaterialButtonToggleGroup
+            android:id="@+id/eraser_mode_toggle_group"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginEnd="8dp"
+            app:layout_constraintEnd_toStartOf="@id/clear_button_popup"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent"
+            app:selectionRequired="true"
+            app:singleSelection="true"
+            tools:checkedButton="@id/eraser_mode_ink">
+
+            <com.google.android.material.button.MaterialButton
+                android:id="@+id/eraser_mode_ink"
+                style="?attr/materialButtonOutlinedStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:backgroundTint="@color/selector_tool_background"
+                android:text="@string/whiteboard_ink_eraser"
+                app:icon="@drawable/eraser"
+                app:iconGravity="textStart" />
+
+            <com.google.android.material.button.MaterialButton
+                android:id="@+id/eraser_mode_stroke"
+                style="?attr/materialButtonOutlinedStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:backgroundTint="@color/selector_tool_background"
+                android:text="@string/whiteboard_stroke_eraser"
+                app:icon="@drawable/ic_edit_off"
+                app:iconGravity="textStart" />
+        </com.google.android.material.button.MaterialButtonToggleGroup>
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/clear_button_popup"
+            style="?attr/materialButtonOutlinedStyle"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/whiteboard_clear"
+            android:textColor="?android:textColor"
+            app:icon="@drawable/ic_clear_white"
+            app:iconGravity="textStart"
+            app:iconTint="?attr/colorControlNormal"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+
+        <com.google.android.material.slider.Slider
+            android:id="@+id/eraser_width_slider"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:stepSize="5.0"
+            android:valueFrom="5.0"
+            android:valueTo="200.0"
+            app:layout_constraintTop_toBottomOf="@id/eraser_mode_toggle_group"
+            app:thumbHeight="24dp"
+            app:tickVisible="false" />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</androidx.cardview.widget.CardView>
+
diff --git a/AnkiDroid/src/main/res/menu/whiteboard.xml b/AnkiDroid/src/main/res/menu/whiteboard.xml
new file mode 100644
index 000000000000..bfe8b67efd59
--- /dev/null
+++ b/AnkiDroid/src/main/res/menu/whiteboard.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+    <item
+        android:id="@+id/action_toggle_stylus"
+        android:title="@string/stylus_mode"
+        android:checkable="true"
+        android:icon="@drawable/ic_mode_edit_white"
+        app:showAsAction="never"
+        />
+    <item
+        android:id="@+id/action_align"
+        android:title="@string/toolbar_position"
+        android:icon="@drawable/ic_align"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/action_align_left"
+                android:icon="@drawable/ic_align_left"
+                android:title="@string/whiteboard_align_left"/>
+            <item
+                android:id="@+id/action_align_bottom"
+                android:icon="@drawable/ic_align_bottom"
+                android:title="@string/whiteboard_align_bottom"/>
+            <item
+                android:id="@+id/action_align_right"
+                android:icon="@drawable/ic_align_right"
+                android:title="@string/whiteboard_align_right"/>
+        </menu>
+    </item>
+</menu>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/values/02-strings.xml b/AnkiDroid/src/main/res/values/02-strings.xml
index eb0528cf2466..345acaa297b5 100644
--- a/AnkiDroid/src/main/res/values/02-strings.xml
+++ b/AnkiDroid/src/main/res/values/02-strings.xml
@@ -42,6 +42,25 @@
     <string name="save_whiteboard" maxLength="28">Save whiteboard</string>
     <string name="enable_stylus" maxLength="28">Enable stylus writing</string>
     <string name="disable_stylus">Disable stylus writing</string>
+    <string name="eraser" maxLength="28">Eraser</string>
+    <string name="add_brush" maxLength="28">Add brush</string>
+    <string name="whiteboard_align_left" comment="Option to align the whiteboard toolbar on the left" maxLength="28"
+        >Left</string>
+    <string name="whiteboard_align_bottom" comment="Option to align the whiteboard toolbar on the bottom" maxLength="28"
+        >Bottom</string>
+    <string name="whiteboard_align_right" comment="Option to align the whiteboard toolbar on the right" maxLength="28"
+        >Right</string>
+    <string name="whiteboard_clear" comment="Button text to clear the whiteboard" maxLength="28">Clear</string>
+    <string name="whiteboard_more_options" comment="Tooltip of the whiteboard 'More' button" maxLength="28"
+        >More options</string>
+    <string name="whiteboard_remove_brush_message">Are you sure you want to remove this brush from your palette?</string>
+    <string name="whiteboard_ink_eraser" comment="Title of the whiteboard Ink eraser"
+        >Ink</string>
+    <string name="whiteboard_stroke_eraser" comment="Title of the whiteboard Stroke eraser"
+        >Stroke</string>
+    <string name="stylus_mode" comment="Title of the menu item that toggles the whiteboard stylus mode" maxLength="28"
+        >Stylus mode</string>
+    <string name="cannot_remove_last_brush_message">The last brush may not be removed</string>
     <string name="enable_whiteboard" maxLength="28">Enable whiteboard</string>
     <string name="disable_whiteboard">Disable whiteboard</string>
     <string name="show_whiteboard">Show whiteboard</string>
diff --git a/AnkiDroid/src/main/res/values/10-preferences.xml b/AnkiDroid/src/main/res/values/10-preferences.xml
index c53327309fd2..1d8761e4a4be 100644
--- a/AnkiDroid/src/main/res/values/10-preferences.xml
+++ b/AnkiDroid/src/main/res/values/10-preferences.xml
@@ -461,7 +461,7 @@ this formatter is used if the bind only applies to the answer">A: %s</string>
         >None</string>
     <string name="toolbar" maxLength="41">Toolbar</string>
     <string name="toolbar_actions" maxLength="41">Toolbar actions</string>
-    <string name="toolbar_position" maxLength="41">Toolbar position</string>
+    <string name="toolbar_position" maxLength="28">Toolbar position</string>
     <string name="new_study_screen" maxLength="41">New study screen</string>
     <string name="new_study_screen_summ"
         ><![CDATA[Improved study screen that will succeed the current one. Some features of the old screen have been changed or removed. Please report any <a href="%1$s">feedback</a> or <a href="%2$s">bugs</a>.]]></string>
diff --git a/AnkiDroid/src/main/res/values/colors.xml b/AnkiDroid/src/main/res/values/colors.xml
index b246266680ca..b814630c0be3 100644
--- a/AnkiDroid/src/main/res/values/colors.xml
+++ b/AnkiDroid/src/main/res/values/colors.xml
@@ -22,6 +22,7 @@
     <color name="semi_transparent_black">#80000000</color>
 
     <color name="answer_buttons_highlight_color">#66FFFFFF</color>
+    <color name="whiteboard_eraser">#80808080</color>
 
 
     <!-- Material Design: http://www.google.com/design/spec/style/color.html#color-color-palette -->
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepositoryTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepositoryTest.kt
new file mode 100644
index 000000000000..53424a99d904
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/whiteboard/WhiteboardRepositoryTest.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer.whiteboard
+
+import org.junit.Test
+import kotlin.test.assertEquals
+
+class WhiteboardRepositoryTest {
+    @Test
+    fun `toolbar alignment enum values`() {
+        // changing a value require a preference upgrade or using constants in the enum
+        val values =
+            listOf(
+                "LEFT",
+                "RIGHT",
+                "BOTTOM",
+            )
+        val enumNames = ToolbarAlignment.entries.map { it.name }
+        assertEquals(values, enumNames)
+    }
+
+    @Test
+    fun `eraser enum values`() {
+        // changing a value require a preference upgrade or using constants in the enum
+        val values =
+            listOf(
+                "INK",
+                "STROKE",
+            )
+        val enumNames = EraserMode.entries.map { it.name }
+        assertEquals(values, enumNames)
+    }
+}
