diff --git a/AnkiDroid/src/main/assets/scripts/ankidroid.js b/AnkiDroid/src/main/assets/scripts/ankidroid.js
index c81903da0763..abdebeba608d 100644
--- a/AnkiDroid/src/main/assets/scripts/ankidroid.js
+++ b/AnkiDroid/src/main/assets/scripts/ankidroid.js
@@ -21,3 +21,94 @@ globalThis.ankidroid.showHint = function () {
 globalThis.ankidroid.showAllHints = function () {
     document.querySelectorAll("a.hint").forEach(el => el.click());
 };
+
+(() => {
+    const DOUBLE_TAP_TIMEOUT = 250; // Max ms between taps for a double tap.
+    const SCHEME = "gesture";
+
+    let startX = 0,
+        startY = 0,
+        tapTimer = null,
+        isSingleTouch = false;
+
+    document.addEventListener(
+        "touchstart",
+        event => {
+            // Ignore multi-touch gestures (like two-finger taps)
+            if (event.touches.length > 1) {
+                isSingleTouch = false;
+                return;
+            }
+            isSingleTouch = true;
+            startX = event.touches[0].clientX;
+            startY = event.touches[0].clientY;
+        },
+        { passive: true },
+    );
+
+    document.addEventListener(
+        "touchend",
+        event => {
+            if (!isSingleTouch || isTextSelected() || isInteractable(event)) return;
+            event.preventDefault();
+
+            if (tapTimer != null) {
+                clearTimeout(tapTimer);
+                tapTimer = null;
+                window.location.href = `${SCHEME}://doubleTap`;
+                return;
+            }
+
+            const endX = event.changedTouches[0].clientX;
+            const endY = event.changedTouches[0].clientY;
+            const params = new URLSearchParams({
+                x: Math.round(endX),
+                y: Math.round(endY),
+                deltaX: Math.round(endX - startX),
+                deltaY: Math.round(endY - startY),
+            });
+            const requestUrl = `${SCHEME}://tapOrSwipe/?${params.toString()}`;
+
+            tapTimer = setTimeout(() => {
+                window.location.href = requestUrl;
+                tapTimer = null;
+            }, DOUBLE_TAP_TIMEOUT);
+        },
+        { passive: false },
+    );
+
+    /**
+     * Checks if the target element or its parents are interactive.
+     * @param {HTMLElement} target
+     * @returns {boolean}
+     */
+    function isInteractable(e) {
+        let node = e.target;
+        while (node && node !== document) {
+            const res =
+                node.nodeName === "A" ||
+                node.onclick ||
+                node.nodeName === "BUTTON" ||
+                node.nodeName === "VIDEO" ||
+                node.nodeName === "SUMMARY" ||
+                node.nodeName === "INPUT" ||
+                node.getAttribute("contentEditable");
+            if (res) {
+                return true;
+            }
+            if (node.classList && node.classList.contains("tappable")) {
+                return true;
+            }
+            node = node.parentNode;
+        }
+        return false;
+    }
+
+    /**
+     * Checks if the user is selecting text.
+     * @returns {boolean}
+     */
+    function isTextSelected() {
+        return !document.getSelection().isCollapsed;
+    }
+})();
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/previewer/CardViewerFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/previewer/CardViewerFragment.kt
index fc022cc41fe9..ca439dd98654 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/previewer/CardViewerFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/previewer/CardViewerFragment.kt
@@ -159,7 +159,7 @@ abstract class CardViewerFragment(
             return handleUrl(url.toUri())
         }
 
-        private fun handleUrl(url: Uri): Boolean {
+        protected open fun handleUrl(url: Uri): Boolean {
             when (url.scheme) {
                 "playsound" -> viewModel.playSoundFromUrl(url.toString())
                 "videoended" -> viewModel.onVideoFinished()
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/BindingMap.kt b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/BindingMap.kt
index c2d167748fb3..72d5d45f262b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/BindingMap.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/BindingMap.kt
@@ -19,6 +19,7 @@ package com.ichi2.anki.reviewer
 import android.content.SharedPreferences
 import android.view.KeyEvent
 import android.view.MotionEvent
+import com.ichi2.anki.cardviewer.Gesture
 import com.ichi2.anki.reviewer.Binding.Companion.possibleKeyBindings
 
 /**
@@ -37,6 +38,7 @@ class BindingMap<B : MappableBinding, A : MappableAction<B>>(
 ) {
     private val keyMap = HashMap<Binding, List<Pair<A, B>>>()
     private val axisDetectors: List<SingleAxisDetector<B, A>>
+    private val gestureMap = HashMap<Gesture, List<Pair<A, B>>>()
 
     init {
         val axisList = mutableListOf<SingleAxisDetector<B, A>>()
@@ -54,6 +56,13 @@ class BindingMap<B : MappableBinding, A : MappableAction<B>>(
                     is Binding.AxisButtonBinding -> {
                         axisList.add(SingleAxisDetector(action, mappableBinding))
                     }
+                    is Binding.GestureInput -> {
+                        if (binding.gesture in gestureMap) {
+                            (gestureMap[binding.gesture] as MutableList).add(action to mappableBinding)
+                        } else {
+                            gestureMap[binding.gesture] = mutableListOf(action to mappableBinding)
+                        }
+                    }
                     else -> {}
                 }
             }
@@ -94,4 +103,12 @@ class BindingMap<B : MappableBinding, A : MappableAction<B>>(
         }
         return processed
     }
+
+    fun onGesture(gesture: Gesture): Boolean {
+        val mappableBindings = gestureMap[gesture] ?: return false
+        for ((action, mappableBinding) in mappableBindings) {
+            if (processor?.processAction(action, mappableBinding) == true) return true
+        }
+        return false
+    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
index f54e095b90a5..c650642be9c3 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
@@ -17,6 +17,7 @@ package com.ichi2.anki.ui.windows.reviewer
 
 import android.content.Context
 import android.content.Intent
+import android.net.Uri
 import android.os.Bundle
 import android.text.SpannableString
 import android.text.style.UnderlineSpan
@@ -28,6 +29,7 @@ import android.view.ViewGroup.MarginLayoutParams
 import android.view.inputmethod.EditorInfo
 import android.view.inputmethod.InputMethodManager
 import android.webkit.WebView
+import android.webkit.WebViewClient
 import android.widget.FrameLayout
 import android.widget.LinearLayout
 import androidx.annotation.StringRes
@@ -56,6 +58,8 @@ import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.DispatchKeyEventListener
 import com.ichi2.anki.R
 import com.ichi2.anki.cardviewer.CardMediaPlayer
+import com.ichi2.anki.cardviewer.Gesture
+import com.ichi2.anki.common.utils.android.isRobolectric
 import com.ichi2.anki.dialogs.tags.TagsDialog
 import com.ichi2.anki.dialogs.tags.TagsDialogFactory
 import com.ichi2.anki.dialogs.tags.TagsDialogListener
@@ -93,6 +97,10 @@ import com.ichi2.anki.utils.ext.window
 import com.ichi2.anki.utils.isWindowCompact
 import com.ichi2.libanki.sched.Counts
 import com.ichi2.utils.dp
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
+import kotlin.math.abs
 
 class ReviewerFragment :
     CardViewerFragment(R.layout.reviewer2),
@@ -542,7 +550,91 @@ class ReviewerFragment :
         stateFilter: CardStateFilter,
     ) = viewModel.onEditedTags(selectedTags)
 
+    override fun onCreateWebViewClient(savedInstanceState: Bundle?): WebViewClient = ReviewerWebViewClient(savedInstanceState)
+
+    private inner class ReviewerWebViewClient(
+        savedInstanceState: Bundle?,
+    ) : CardViewerWebViewClient(savedInstanceState) {
+        @Suppress("DEPRECATION") // the deprecation suggests using `onScaleChanged` to avoid
+        // race conditions when the scale is being changed. The method is already being used below
+        // for that matter. For only getting the initial scale, it's safe to use the property.
+        // Robolectric crashes with 'java.lang.Integer cannot be cast to class java.lang.Float'
+        private var scale: Float = if (!isRobolectric) webView.scale else 1F
+        private var isScrolling: Boolean = false
+        private var isScrollingJob: Job? = null
+
+        init {
+            webView.setOnScrollChangeListener { _, _, _, _, _ ->
+                isScrolling = true
+                isScrollingJob?.cancel()
+                isScrollingJob =
+                    lifecycleScope.launch {
+                        delay(300)
+                        isScrolling = false
+                    }
+            }
+        }
+
+        override fun handleUrl(url: Uri): Boolean {
+            return when (url.scheme) {
+                "gesture" -> {
+                    if (isScrolling) return true
+                    if (url.host == "doubleTap") {
+                        viewModel.onGesture(Gesture.DOUBLE_TAP)
+                        return true
+                    }
+
+                    fun Uri.getIntQuery(key: String) = getQueryParameter(key)?.toIntOrNull()
+                    val tapX = url.getIntQuery("x") ?: return false
+                    val tapY = url.getIntQuery("y") ?: return false
+                    val deltaX = url.getIntQuery("deltaX") ?: return false
+                    val deltaY = url.getIntQuery("deltaY") ?: return false
+                    val absDeltaX = abs(deltaX)
+                    val absDeltaY = abs(deltaY)
+
+                    // Constant that when divided by the scale allows minimum movement while tapping
+                    val swipeThreshold = 18 / scale
+                    if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) return true
+
+                    /** Gets the corresponding index of a dimension (X or Y) in the [gestureGrid] */
+                    fun getGridIndex(
+                        tapPosition: Int,
+                        scrolledDistance: Int,
+                        dimensionSize: Int,
+                    ): Int {
+                        val scaledTap = tapPosition * scale
+                        val adjustedTapPosition = scaledTap - scrolledDistance
+                        return (adjustedTapPosition / (dimensionSize / 3)).toInt()
+                    }
+
+                    val row = getGridIndex(tapY, webView.scrollY, webView.measuredHeight)
+                    val column = getGridIndex(tapX, webView.scrollX, webView.measuredWidth)
+                    val gesture = gestureGrid[row][column]
+                    viewModel.onGesture(gesture)
+                    true
+                }
+                else -> super.handleUrl(url)
+            }
+        }
+
+        override fun onScaleChanged(
+            view: WebView?,
+            oldScale: Float,
+            newScale: Float,
+        ) {
+            super.onScaleChanged(view, oldScale, newScale)
+            scale = newScale
+        }
+    }
+
     companion object {
         fun getIntent(context: Context): Intent = CardViewerActivity.getIntent(context, ReviewerFragment::class)
+
+        private val gestureGrid =
+            listOf(
+                listOf(Gesture.TAP_TOP_LEFT, Gesture.TAP_TOP, Gesture.TAP_TOP_RIGHT),
+                listOf(Gesture.TAP_LEFT, Gesture.TAP_CENTER, Gesture.TAP_RIGHT),
+                listOf(Gesture.TAP_BOTTOM_LEFT, Gesture.TAP_BOTTOM, Gesture.TAP_BOTTOM_RIGHT),
+            )
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerViewModel.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerViewModel.kt
index b3e613fb97b3..4e1fb584876d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerViewModel.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerViewModel.kt
@@ -36,6 +36,7 @@ import com.ichi2.anki.Flag
 import com.ichi2.anki.Reviewer
 import com.ichi2.anki.asyncIO
 import com.ichi2.anki.cardviewer.CardMediaPlayer
+import com.ichi2.anki.cardviewer.Gesture
 import com.ichi2.anki.common.time.TimeManager
 import com.ichi2.anki.launchCatchingIO
 import com.ichi2.anki.noteeditor.NoteEditorLauncher
@@ -202,6 +203,11 @@ class ReviewerViewModel(
 
     fun onGenericMotionEvent(event: MotionEvent?): Boolean = bindingMap.onGenericMotionEvent(event)
 
+    fun onGesture(gesture: Gesture) {
+        Timber.v("ReviewerViewModel::onGesture %s", gesture)
+        bindingMap.onGesture(gesture)
+    }
+
     private suspend fun toggleMark() {
         Timber.v("ReviewerViewModel::toggleMark")
         val card = currentCard.await()
