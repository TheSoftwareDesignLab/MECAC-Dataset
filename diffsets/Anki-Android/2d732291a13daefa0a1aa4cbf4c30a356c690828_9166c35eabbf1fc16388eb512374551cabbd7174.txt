diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
index bc6d76f3b322..25bb3f460749 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
@@ -387,6 +387,9 @@ internal constructor(
         fun spaceRequired(sourceDirectory: String): NumberOfBytes {
             return getEssentialFiles(sourceDirectory).sumOf { it.length() }
         }
+
+        /** The list of filenames we would move (if they exist) */
+        abstract val potentialFileNames: List<String>
     }
 
     /**
@@ -405,6 +408,8 @@ internal constructor(
 
         // guaranteed to be + "-journal": https://www.sqlite.org/tempfiles.html
         private val journalName = "$fileName-journal"
+
+        override val potentialFileNames get() = listOf(fileName, journalName)
     }
 
     /**
@@ -422,6 +427,8 @@ internal constructor(
                 listOf(file)
             }
         }
+
+        override val potentialFileNames get() = listOf(fileName)
     }
 
     /**
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateUserData.kt b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateUserData.kt
index 6286b9f7bd44..19f786c3c12e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateUserData.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateUserData.kt
@@ -17,11 +17,18 @@
 package com.ichi2.anki.servicelayer.scopedstorage
 
 import android.content.SharedPreferences
+import androidx.annotation.VisibleForTesting
 import com.ichi2.anki.model.Directory
 import com.ichi2.anki.model.DiskFile
+import com.ichi2.anki.model.RelativeFilePath
 import com.ichi2.anki.servicelayer.ScopedStorageService.UserDataMigrationPreferences
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateUserData.Operation
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateUserData.SingleRetryDecorator
+import com.ichi2.async.ProgressSenderAndCancelListener
+import com.ichi2.async.TaskDelegate
+import com.ichi2.compat.CompatHelper
+import com.ichi2.exceptions.AggregateException
+import com.ichi2.libanki.Collection
 import timber.log.Timber
 import java.io.File
 
@@ -29,7 +36,10 @@ typealias NumberOfBytes = Long
 
 /**
  * Migrating user data (images, backups etc..) to scoped storage
- * This needs to be performed in the background to allow users to use AnkiDroid
+ * This needs to be performed in the background to allow users to use AnkiDroid.
+ *
+ * A file is not user data if it is moved by [MigrateEssentialFiles]:
+ * * (collection and media SQL-related files, and .nomedia/collection logs)
  *
  * If this were performed in the foreground, users would be encouraged to uninstall the app
  * which means the app permanently loses access to the AnkiDroid directory.
@@ -37,7 +47,7 @@ typealias NumberOfBytes = Long
  * This also handles preemption, allowing media files to skip the queue
  * (if they're required for review)
  */
-class MigrateUserData private constructor(val source: Directory, val destination: Directory) {
+open class MigrateUserData protected constructor(val source: Directory, val destination: Directory) : TaskDelegate<NumberOfBytes, Boolean>() {
     companion object {
         /**
          * Creates an instance of [MigrateUserData] if valid, returns null if a migration is not in progress, or throws if data is invalid
@@ -257,7 +267,7 @@ class MigrateUserData private constructor(val source: Directory, val destination
      * Ignores [retryOperations] defined in [standardOperation]
      */
     class SingleRetryDecorator(
-        private val standardOperation: Operation,
+        internal val standardOperation: Operation,
         private val retryOperation: Operation
     ) : Operation() {
         override fun execute(context: MigrationContext) = standardOperation.execute(context)
@@ -270,7 +280,7 @@ class MigrateUserData private constructor(val source: Directory, val destination
      * should take priority over a background migration
      * of a random file)
      */
-    class Executor(private val operations: ArrayDeque<Operation>) {
+    open class Executor(private val operations: ArrayDeque<Operation>) {
         /** Whether [terminate] was called. Once this is called, a new instance should be used */
         private var terminated: Boolean = false
         /**
@@ -296,12 +306,18 @@ class MigrateUserData private constructor(val source: Directory, val destination
                 val operation = operations.removeFirstOrNull() ?: return
 
                 context.execSafe(operation) {
-                    val replacements = it.execute(context)
+                    val replacements = executeOperationInternal(it, context)
                     operations.addAll(0, replacements)
                 }
             }
         }
 
+        @VisibleForTesting
+        internal open fun executeOperationInternal(
+            it: Operation,
+            context: MigrationContext
+        ) = it.execute(context)
+
         /**
          * Executes all items in the preempted queue
          *
@@ -343,6 +359,205 @@ class MigrateUserData private constructor(val source: Directory, val destination
             this.terminated = true
         }
     }
+
+    /**
+     * Abstracts the decision of what to do when an exception occurs when migrating a file.
+     * Provides progress notifications
+     */
+    open class UserDataMigrationContext(private val executor: Executor, val source: Directory, val progressReportParam: ((NumberOfBytes) -> Unit)) : MigrationContext() {
+        val successfullyCompleted: Boolean get() = loggedExceptions.isEmpty()
+
+        /**
+         * The reason that the the execution of the whole migration was terminated early
+         *
+         * @see failOperationWith
+         */
+        var terminatedWith: Exception? = null
+            private set
+
+        val retriedDirectories = hashSetOf<File>()
+
+        val loggedExceptions = mutableListOf<Exception>()
+        var consecutiveExceptionsWithoutProgress = 0
+        override fun reportError(throwingOperation: Operation, ex: Exception) {
+            when (ex) {
+                is FileConflictException -> { moveToConflictedFolder(ex.source) }
+                is FileDirectoryConflictException -> { moveToConflictedFolder(ex.source) }
+                is DirectoryNotEmptyException -> {
+                    // If a directory isn't empty, some more files may have been added. Retry (after all others are completed)
+                    if (throwingOperation.retryOperations.any() && retriedDirectories.add(ex.directory.directory)) {
+                        executor.appendAll(throwingOperation.retryOperations)
+                    } else {
+                        logExceptionAndContinue(ex)
+                    }
+                }
+                is MissingDirectoryException -> failOperationWith(ex)
+                // logical error: we tried to migrate to the same path
+                is EquivalentFileException -> failOperationWith(ex)
+                // if we couldn't move a file to /conflict/, log and continue.
+                // we do not expect this exception to occur
+                is FileConflictResolutionFailedException -> logExceptionAndContinue(ex)
+                else -> logExceptionAndContinue(ex)
+            }
+        }
+
+        /**
+         * Keeps a circular buffer of the last 10 exceptions.
+         * the oldest exception is evicted if more than 10 are added
+         */
+        private fun logExceptionAndContinue(ex: Exception) {
+            if (loggedExceptions.size >= 10) {
+                loggedExceptions.removeFirst()
+            }
+            loggedExceptions.add(ex)
+            consecutiveExceptionsWithoutProgress++
+            if (consecutiveExceptionsWithoutProgress >= 10) {
+                val exception = AggregateException.raise("10 consecutive exceptions without progress", loggedExceptions)
+                failOperationWith(exception)
+            }
+        }
+
+        /**
+         * On a conflicted file, move it from `<path>` to `/conflict/<path>`.
+         * Files in this folder will not be moved again
+         *
+         * We perform this action immediately
+         *
+         * @see MoveConflictedFile
+         */
+        private fun moveToConflictedFolder(conflictedFile: DiskFile) {
+            val relativePath = RelativeFilePath.fromPaths(source, conflictedFile)!!
+            val operation: MoveConflictedFile = MoveConflictedFile.createInstance(conflictedFile, source, relativePath)
+            executor.prepend(operation)
+        }
+
+        override fun reportProgress(transferred: NumberOfBytes) {
+            consecutiveExceptionsWithoutProgress = 0
+            this.progressReportParam(transferred)
+        }
+
+        /** A fatal exception has occurred which should stop all file processing */
+        private fun failOperationWith(ex: Exception) {
+            executor.terminate()
+            terminatedWith = ex
+        }
+
+        fun reset() {
+            loggedExceptions.clear()
+            consecutiveExceptionsWithoutProgress = 0
+        }
+    }
+
+    @VisibleForTesting
+    var executor = Executor(ArrayDeque())
+
+    @VisibleForTesting
+    var externalRetries = 0
+        private set
+
+    /**
+     * Migrates all files and folders to [destination], aside from [getEssentialFiles]
+     *
+     * @throws MissingDirectoryException
+     * @throws EquivalentFileException
+     * @throws AggregateException If multiple exceptions were thrown when executing
+     * @throws RuntimeException Various other failings if only a single exception was thrown
+     */
+    override fun task(col: Collection, collectionTask: ProgressSenderAndCancelListener<NumberOfBytes>): Boolean {
+
+        val context = initializeContext(collectionTask)
+
+        // define the function here, so we can execute it on retry
+        fun moveRemainingFiles() {
+            executor.appendAll(getMigrateUserDataOperations())
+            executor.execute(context)
+        }
+
+        moveRemainingFiles()
+
+        // try 2 times, then stop temporarily
+        while (!context.successfullyCompleted && externalRetries < 2) {
+            context.reset()
+            externalRetries++
+            moveRemainingFiles()
+        }
+
+        // if the operation was terminated (typically due to too many consecutive exceptions), throw that
+        // otherwise, there were a few exceptions which didn't stop execution, throw these.
+        if (!context.successfullyCompleted) {
+            context.terminatedWith?.let { throw it }
+            throw AggregateException.raise("", context.loggedExceptions) // TODO
+        }
+
+        // we are successfully migrated here
+        // TODO: fix "conflicts" - check to see if conflicts are due to partially copied files in the destination
+
+        return true
+    }
+
+    @VisibleForTesting
+    internal open fun initializeContext(collectionTask: ProgressSenderAndCancelListener<NumberOfBytes>) =
+        UserDataMigrationContext(executor, source, collectionTask::doProgress)
+
+    /**
+     * Returns migration operations for the top level items in /AnkiDroid/
+     */
+    @VisibleForTesting
+    internal open fun getMigrateUserDataOperations(): List<Operation> =
+        getUserDataFiles()
+            .map { fileOrDir ->
+                MoveFileOrDirectory(
+                    sourceFile = File(source.directory, fileOrDir.name),
+                    destination = File(destination.directory, fileOrDir.name)
+                )
+            }.sortedWith(
+                compareBy {
+                    // Have user-generated files take priority over the media.
+                    // the 'fonts' folder will impact UX
+                    // 'card.html' is often regenerated and is likely to cause a conflict
+                    // We want all the backups to be restorable ASAP)
+                    when (it.sourceFile.name) {
+                        "card.html" -> -3
+                        "fonts" -> -2
+                        "backups" -> -1
+                        else -> 0
+                    }
+                }
+            )
+            .toList()
+
+    /** Gets a sequence of content in [source] */
+    private fun getDirectoryContent() = sequence {
+        CompatHelper.compat.contentOfDirectory(source.directory).use {
+            while (it.hasNext()) {
+                yield(it.next())
+            }
+        }
+    }
+
+    /** Returns a sequence of the Files or Directories in [source] which are to be migrated */
+    private fun getUserDataFiles() = getDirectoryContent().filter { isUserData(it) }
+
+    /** Returns a sequence of the Files or Directories in [source] which were already migrated */
+    private fun getEssentialFiles() = getDirectoryContent().filter { !isUserData(it) }
+
+    fun isEssentialFileName(name: String): Boolean {
+        return MigrateEssentialFiles.PRIORITY_FILES.flatMap { it.potentialFileNames }.contains(name)
+    }
+
+    /** Returns whether a file is "user data" and should be moved */
+    private fun isUserData(file: File): Boolean {
+        if (file.isFile && isEssentialFileName(file.name)) {
+            return false
+        }
+
+        // don't move the "conflict" directory
+        if (file.name == MoveConflictedFile.CONFLICT_DIRECTORY) {
+            return false
+        }
+
+        return true
+    }
 }
 
 /**
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
new file mode 100644
index 000000000000..cec65275165f
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
@@ -0,0 +1,305 @@
+/*
+ *  Copyright (c) 2022 David Allison <davidallisongithub@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free Software
+ *  Foundation; either version 3 of the License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.anki.servicelayer.scopedstorage
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.ichi2.anki.RobolectricTest
+import com.ichi2.anki.model.Directory
+import com.ichi2.anki.servicelayer.scopedstorage.MigrateUserData.*
+import com.ichi2.async.ProgressSenderAndCancelListener
+import com.ichi2.exceptions.AggregateException
+import com.ichi2.testutils.*
+import org.hamcrest.MatcherAssert.assertThat
+import org.hamcrest.Matchers.*
+import org.hamcrest.io.FileMatchers.anExistingDirectory
+import org.junit.After
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.kotlin.mock
+import timber.log.Timber
+import java.io.File
+import kotlin.io.path.Path
+import kotlin.io.path.pathString
+import kotlin.test.fail
+
+// PERF: Some of these do not need a collection
+/** Test for [MigrateUserData.execTask] */
+@RunWith(AndroidJUnit4::class)
+class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
+
+    private lateinit var underTest: MigrateUserDataTester
+    private val validDestination = File(Path(targetContext.getExternalFilesDir(null)!!.canonicalPath, "AnkiDroid-1").pathString)
+
+    override fun useInMemoryDatabase() = false
+
+    @After
+    override fun tearDown() {
+        try {
+            super.tearDown()
+        } finally {
+            ShadowStatFs.reset()
+        }
+    }
+
+    @Test
+    fun `Valid migration`() {
+        underTest = MigrateUserDataTester.create()
+        // use all the real components on a real collection.
+        val inputDirectory = File(col.path).parentFile!!
+        File(inputDirectory, "collection.media").addTempFile("image.jpg", "foo")
+
+        ShadowStatFs.markAsNonEmpty(validDestination)
+        ShadowStatFs.markAsNonEmpty(inputDirectory)
+
+        // migrate the essential files
+        MigrateEssentialFiles.migrateEssentialFiles(targetContext, validDestination)
+
+        underTest = MigrateUserDataTester.create(inputDirectory, validDestination)
+        val result = underTest.execTask()
+
+        assertThat("execution of user data should succeed", result, equalTo(true))
+
+        // 5 files remain: [collection.log, collection.media.ad.db2, collection.anki2-journal, collection.anki2, .nomedia]
+        underTest.integrationAssertOnlyIntendedFilesRemain()
+        assertThat(underTest.migratedFilesCount, equalTo(underTest.filesToMigrateCount))
+
+        assertThat(
+            "a number of files should remain to allow the user to restore their collection",
+            fileCount(inputDirectory), equalTo(MigrateUserDataTester.INTEGRATION_INTENDED_REMAINING_FILE_COUNT)
+        )
+    }
+
+    @Test
+    fun `Migration without space fails`() {
+        // use all the real components on a real collection.
+        val inputDirectory = File(col.path).parentFile!!
+        File(inputDirectory, "collection.media").addTempFile("image.jpg", "foo")
+        File(inputDirectory, "collection.media").addTempFile("image2.jpg", "bar")
+
+        ShadowStatFs.markAsNonEmpty(validDestination)
+        ShadowStatFs.markAsNonEmpty(inputDirectory)
+
+        // migrate the essential files
+        MigrateEssentialFiles.migrateEssentialFiles(targetContext, validDestination)
+
+        underTest = MigrateUserDataTester.create(inputDirectory, validDestination)
+        underTest.executor = object : Executor(ArrayDeque()) {
+            override fun executeOperationInternal(it: Operation, context: MigrationContext): List<Operation> {
+                if (it is MoveFile) {
+                    context.reportError(it, TestException("no space left on disk"))
+                    return emptyList()
+                }
+                return super.executeOperationInternal(it, context)
+            }
+        }
+
+        val aggregatedException = assertThrowsSubclass<AggregateException> { underTest.execTask() }
+
+        val testExceptions = aggregatedException.exceptions.filter { it !is DirectoryNotEmptyException }
+
+        assertThat("two failed files means two exceptions", testExceptions.size, equalTo(2))
+
+        assertThat(testExceptions[0], instanceOf(TestException::class.java))
+        assertThat(testExceptions[1], instanceOf(TestException::class.java))
+    }
+
+    @Test
+    fun `Empty migration passes`() {
+        underTest = MigrateUserDataTester.create(createTransientDirectory(), createTransientDirectory())
+
+        val result = underTest.execTask()
+
+        assertThat("migrating empty folder should succeed", result, equalTo(true))
+    }
+
+    /**
+     * Introduce a conflicted file
+     * * it's moved to /conflict/
+     * * the process succeeds
+     */
+    @Test
+    fun `Migration with conflict is moved`() {
+        underTest = MigrateUserDataTester.create()
+        underTest.destination.directory.addTempFile("maybeConflicted.log", "bar")
+
+        val result = underTest.execTask()
+
+        assertThat("all files should be in the destination", underTest.migratedFilesCount, equalTo(underTest.filesToMigrateCount))
+        assertThat("one file is conflicted", underTest.conflictedFilesCount, equalTo(1))
+        assertThat("expect to have conflict/maybeConflicted.log in source (file & folder)", underTest.sourceFilesCount, equalTo(2))
+        assertThat(underTest.conflictedFilePaths.single(), anyOf(endsWith("/conflict/maybeConflicted.log"), endsWith("\\conflict\\maybeConflicted.log")))
+
+        assertThat("even with a conflict, the operation should succeed", result, equalTo(true))
+    }
+
+    @Test
+    fun `Migration with file added is internally retried`() {
+        underTest = MigrateUserDataTester.create()
+        val executorWithNonEmpty = object : Executor(ArrayDeque()) {
+            var called = false
+            override fun executeOperationInternal(it: Operation, context: MigrationContext): List<Operation> {
+                Timber.i("%s", it::class.java.name)
+                val inner = innerOperation(it)
+                if (!called && inner is DeleteEmptyDirectory && inner.directory.directory.name == "collection.media") {
+                    called = true
+                    context.reportError(
+                        it,
+                        DirectoryNotEmptyException(inner.directory)
+                    )
+                    return emptyList()
+                }
+                return super.executeOperationInternal(it, context)
+            }
+
+            fun innerOperation(op: Operation): Operation = (op as? SingleRetryDecorator)?.standardOperation ?: op
+        }
+        underTest.executor = executorWithNonEmpty
+
+        underTest.execTask()
+
+        assertThat("test exception should be raised", executorWithNonEmpty.called, equalTo(true))
+
+        assertThat(
+            "collection media should be deleted on retry if empty",
+            File(underTest.source.directory, "collection.media"), not(anExistingDirectory())
+        )
+
+        assertThat("no external retries should be made", underTest.externalRetries, equalTo(0))
+    }
+
+    @Test
+    fun `Migration with temporary problem is externally retried`() {
+        underTest = MigrateUserDataTester.create()
+        // Define an 'out of space' error, and the 'retry' will solve this
+        val executorWithNonEmpty = object : Executor(ArrayDeque()) {
+            val shouldFail get() = underTest.externalRetries == 0
+            override fun executeOperationInternal(it: Operation, context: MigrationContext): List<Operation> {
+                if (shouldFail) {
+                    context.reportError(it, TestException("testing"))
+                    return emptyList()
+                }
+                return super.executeOperationInternal(it, context)
+            }
+        }
+        underTest.executor = executorWithNonEmpty
+
+        val result = underTest.execTask()
+
+        assertThat("operation should succeed", result, equalTo(true))
+        assertThat("an external retry occurred", underTest.externalRetries, equalTo(1))
+    }
+
+    private fun MigrateUserDataTester.execTask(): Boolean {
+        return this.execTask(mock(), mock())
+    }
+}
+
+/**
+ * @param filesToMigrateCount The number of files which should be migrated
+ */
+private class MigrateUserDataTester
+private constructor(source: Directory, destination: Directory, val filesToMigrateCount: Int) :
+    MigrateUserData(source, destination) {
+
+    override fun initializeContext(collectionTask: ProgressSenderAndCancelListener<NumberOfBytes>): UserDataMigrationContext {
+        return super.initializeContext(collectionTask).apply {
+            attemptRename = false
+        }
+    }
+
+    /** Asserts [source] is empty */
+    fun integrationAssertOnlyIntendedFilesRemain() {
+        if (sourceFilesCount == INTEGRATION_INTENDED_REMAINING_FILE_COUNT) {
+            return
+        }
+        fail("expected directory with 5 files, got: " + source.directory.listFiles()!!.map { it.name })
+    }
+
+    private val conflictDirectory = File(source.directory, "conflict")
+
+    /** The number of files in [destination] */
+    val migratedFilesCount: Int get() = fileCount(destination.directory)
+    /** The number of files in [source] */
+    val sourceFilesCount: Int get() = fileCount(source.directory)
+    /** The number of files in the "conflict" directory */
+    val conflictedFilesCount: Int get() {
+        if (!conflictDirectory.exists()) {
+            return 0
+        }
+        return fileCount(conflictDirectory)
+    }
+
+    /**
+     * Lists the files in the TOP LEVEL directory of /conflict/
+     * Throws if [conflictDirectory] does not exist
+     */
+    val conflictedFilePaths: List<String> get() {
+        check(conflictDirectory.exists()) { "$conflictDirectory should exist" }
+        return conflictDirectory.listFiles()!!.map { it.path }
+    }
+
+    companion object {
+        const val INTEGRATION_INTENDED_REMAINING_FILE_COUNT: Int = 5
+
+        /**
+         * A MigrateUserDataTest from inputSource to inputDestination (or transient directories if not provided)
+         *
+         * If [inputSource] is null, it is created and with the following contents:
+         * * ./foo.txt`, `./bar.txt`
+         * * `maybeConflicted.log`
+         * *`./collection.media/`
+         * * `.collection.media/image.jpg`
+         *
+         * i.e. 5 files files or directories that are not part of AnkiDroid's essential files.
+         */
+        fun create(inputSource: File? = null, inputDestination: File? = null): MigrateUserDataTester {
+            val destination = inputDestination ?: createTransientDirectory("destination")
+
+            val source = inputSource ?: createTransientDirectory("source").apply {
+                addTempFile("foo.txt", "foo")
+                addTempFile("bar.txt", "bar")
+                addTempFile("maybeConflicted.log", "maybeConflicted")
+                val media = addTempDirectory("collection.media")
+                media.directory.addTempFile("image.jpg", "image")
+            }
+
+            return MigrateUserDataTester(
+                source = Directory.createInstance(source)!!,
+                destination = Directory.createInstance(destination)!!,
+                filesToMigrateCount = fileCount(source)
+            ).also {
+                assertThat("Conflict directory should not exist before the migration starts", it.conflictedFilesCount, equalTo(0))
+            }
+        }
+    }
+}
+
+/**
+ * Return the number of files and directories in [directory] or in one of its subdirectories; not counting [directory] itself.
+ *
+ * Assumes no symbolic links.
+ */
+private fun fileCount(directory: File): Int {
+    check(directory.exists()) { "$directory must exist" }
+    check(directory.isDirectory) { "$directory must be a directory" }
+
+    val files = directory.listFiles()
+    return files!!.sumOf {
+        if (it.isFile) return@sumOf 1
+        else return@sumOf fileCount(it) + 1
+    }
+}
diff --git a/AnkiDroid/src/test/java/com/ichi2/testutils/FileUtil.kt b/AnkiDroid/src/test/java/com/ichi2/testutils/FileUtil.kt
index 48f73d6ee277..1e5202a3ca89 100644
--- a/AnkiDroid/src/test/java/com/ichi2/testutils/FileUtil.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/testutils/FileUtil.kt
@@ -71,6 +71,15 @@ fun File.addTempFile(fileName: String, content: String = "default content"): Fil
     }
 }
 
+/** Adds a directory to the directory with the provided name and content. Return the new directory. */
+fun File.addTempDirectory(directoryName: String): Directory {
+    val dir = File(this, directoryName).also {
+        it.mkdir()
+        it.deleteOnExit()
+    }
+    return Directory.createInstance(dir)!!
+}
+
 /** Adds a file to the directory with the provided name and content */
 fun Directory.withTempFile(fileName: String, content: String = "default content"): Directory {
     this.directory.withTempFile(fileName, content)
