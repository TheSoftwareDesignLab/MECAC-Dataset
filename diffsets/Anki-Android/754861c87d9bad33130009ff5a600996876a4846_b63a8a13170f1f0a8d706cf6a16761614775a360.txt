diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java
index bdfda55121d8..48e67441d619 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java
@@ -515,7 +515,7 @@ private boolean deletionWouldOrphanNote(Collection col, TemporaryModel tempModel
             // If we were deleting a template we just added, we don't care. If not, then for every
             // template delete queued up, we check the database to see if this delete in combo with any other
             // pending deletes could orphan cards
-            if (!tempModel.isTemplatePendingAdd(position)) {
+            if (!TemporaryModel.isOrdinalPendingAdd(tempModel, position)) {
                 int[] currentDeletes = tempModel.getDeleteDbOrds(position);
                 // TODO - this is a SQL query on GUI thread - should see a DeckTask conversion ideally
                 if (col.getModels().getCardIdsForModel(tempModel.getModelId(), currentDeletes) == null) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplatePreviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplatePreviewer.java
index 006566b9dd10..397c18472be3 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplatePreviewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardTemplatePreviewer.java
@@ -25,6 +25,7 @@
 import com.ichi2.libanki.Note;
 import com.ichi2.utils.JSONObject;
 
+import java.io.IOException;
 import java.util.ArrayList;
 
 import androidx.annotation.Nullable;
@@ -56,7 +57,11 @@ protected void onCreate(Bundle savedInstanceState) {
 
         if (mEditedModelFileName != null) {
             Timber.d("onCreate() loading edited model from %s", mEditedModelFileName);
-            mEditedModel = TemporaryModel.getTempModel(mEditedModelFileName);
+            try {
+                mEditedModel = TemporaryModel.getTempModel(mEditedModelFileName);
+            } catch (IOException e) {
+                Timber.w(e, "Unable to load temp model from file %s", mEditedModelFileName);
+            }
         }
 
         if (mEditedModel != null && mIndex != -1) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/TemporaryModel.java b/AnkiDroid/src/main/java/com/ichi2/anki/TemporaryModel.java
index 17f8bd803479..441c59e24b89 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/TemporaryModel.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/TemporaryModel.java
@@ -36,7 +36,6 @@
 import com.ichi2.utils.JSONObject;
 
 
-@SuppressWarnings({"PMD.AvoidThrowingRawExceptionTypes"})
 public class TemporaryModel {
 
     public enum ChangeType { ADD, DELETE }
@@ -46,23 +45,36 @@ public enum ChangeType { ADD, DELETE }
     private final @NonNull JSONObject mEditedModel;
 
 
-    public TemporaryModel(JSONObject model) {
+    public TemporaryModel(@NonNull JSONObject model) {
         Timber.d("Constructor called with model");
         mEditedModel = model;
     }
 
 
+    /**
+     * Load the TemporaryModel from the filename included in a Bundle
+     *
+     * @param bundle a Bundle that should contain persisted JSON under INTENT_MODEL_FILENAME key
+     * @return re-hydrated TemporaryModel or null if there was a problem, null means should reload from database
+     */
     public static TemporaryModel fromBundle(Bundle bundle) {
         String mEditedModelFileName = bundle.getString(INTENT_MODEL_FILENAME);
         // Bundle.getString is @Nullable, so we have to check.
-        // If we return null then onCollectionLoaded() just will load original from database
         if (mEditedModelFileName == null) {
             Timber.d("fromBundle() - model file name under key %s", INTENT_MODEL_FILENAME);
             return null;
         }
 
         Timber.d("onCreate() loading saved model file %s", mEditedModelFileName);
-        TemporaryModel model = new TemporaryModel((getTempModel(mEditedModelFileName)));
+        JSONObject tempModelJSON;
+        try {
+            tempModelJSON = getTempModel((mEditedModelFileName));
+        } catch (IOException e) {
+            Timber.w(e, "Unable to load saved model file");
+            return null;
+        }
+
+        TemporaryModel model = new TemporaryModel(tempModelJSON);
         model.loadTemplateChanges(bundle);
         return model;
     }
@@ -132,8 +144,9 @@ public void removeTemplate(int ord) {
 
     public void saveToDatabase(CollectionTask.TaskListener listener) {
         Timber.d("saveToDatabase() called");
+        dumpChanges();
         TemporaryModel.clearTempModelFiles();
-        CollectionTask.TaskData args = new CollectionTask.TaskData(new Object[] {mEditedModel, getTemplateChanges()});
+        CollectionTask.TaskData args = new CollectionTask.TaskData(new Object[] {mEditedModel, getAdjustedTemplateChanges()});
         CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_SAVE_MODEL, listener, args);
 
     }
@@ -177,14 +190,14 @@ String saveTempModel(@NonNull Context context, @NonNull JSONObject tempModel) {
      * Get the model temporarily saved into the file represented by the given path
      * @return JSONObject holding the model, or null if there was a problem
      */
-    public static @Nullable JSONObject getTempModel(@NonNull String tempModelFileName) {
+    public static JSONObject getTempModel(@NonNull String tempModelFileName) throws IOException {
         Timber.d("getTempModel() fetching tempModel %s", tempModelFileName);
         try (ByteArrayOutputStream target = new ByteArrayOutputStream()) {
             CompatHelper.getCompat().copyFile(tempModelFileName, target);
             return new JSONObject(target.toString());
-        } catch (Exception e) {
+        } catch (IOException e) {
             Timber.e(e, "Unable to read+parse tempModel from file %s", tempModelFileName);
-            return null;
+            throw e;
         }
     }
 
@@ -248,38 +261,68 @@ public void addTemplateChange(ChangeType type, int ordinal) {
 
         Timber.d("addTemplateChange() added ord/type: %s/%s", change[0], change[1]);
         mTemplateChanges.add(change);
+        dumpChanges();
     }
 
+    /**
+     * Check if the given ordinal from the current UI state (which includes all pending changes) is a pending add
+     *
+     * @param ord int representing an ordinal in the model, that might be an unsaved addition
+     * @return boolean true if it is a pending addition from this editing session
+     */
+    public static boolean isOrdinalPendingAdd(TemporaryModel model, int ord) {
+        for (int i = 0; i < model.getTemplateChanges().size(); i++) {
+            Object[] change = model.getTemplateChanges().get(i);
+            int adjustedOrdinal = isChangePendingAdd(model, i);
+            if (adjustedOrdinal == ord) {
+                Timber.d("isOrdinalPendingAdd() found ord %s was pending add (would adjust to %s)", ord, adjustedOrdinal);
+                return true;
+            }
+        }
+
+        Timber.d("isOrdinalPendingAdd() ord %s is not a pending add", ord);
+        return false;
+    }
 
     /**
-     * Check if the given ordinal is an addition from this editing session (and thus is not in the database)
-     * @param ord the ordinal to check
-     * @return boolean true if the given ordinal was added this session (and is not in the database yet)
+     * Check if the change at the given index in the changes array is an addition from this editing session
+     * (and thus is not in the database yet, and possibly needing ordinal adjustment from subsequent deletes)
+     * @param changesIndex the index of the template in the changes array
+     * @return either ordinal adjusted by any pending deletes if it is a pending add, or -1 if the ordinal is not an add
      */
-    public boolean isTemplatePendingAdd(int ord) {
+    public static int isChangePendingAdd(TemporaryModel model, int changesIndex) {
+        if (changesIndex >= model.getTemplateChanges().size()) {
+            return -1;
+        }
         int ordinalAdjustment = 0;
-        for (int i = mTemplateChanges.size() - 1; i >= 0; i--) {
-            Object[] oldChange = mTemplateChanges.get(i);
+        Object[] change = model.getTemplateChanges().get(changesIndex);
+        int changeOrdinal =  (Integer) change[0];
+
+        for (int i = model.getTemplateChanges().size() - 1; i >= changesIndex; i--) {
+            Object[] oldChange = model.getTemplateChanges().get(i);
             switch ((ChangeType) oldChange[1]) {
                 case DELETE: {
                     // Deleting an ordinal at or below us? Adjust our comparison basis...
-                    if ((Integer) oldChange[0] - ordinalAdjustment <= ord) {
+                    if ((Integer) oldChange[0] - ordinalAdjustment <= changeOrdinal) {
                         ordinalAdjustment++;
                         continue;
                     }
+                    Timber.d("isChangePendingAdd() contemplating delete at index %s, current ord adj %s", i, ordinalAdjustment);
                     break;
                 }
                 case ADD:
-                    if (ord == (Integer) oldChange[0] - ordinalAdjustment) {
-                        // something we added this session?
-                        return true;
+                    if (changesIndex == i) {
+                        // something we added this session
+                        Timber.d("isChangePendingAdd() pending add found at at index %s, old ord/adjusted ord %s/%s", i, oldChange[0], ((Integer)oldChange[0] - ordinalAdjustment));
+                        return ((Integer) oldChange[0] - ordinalAdjustment);
                     }
                     break;
                 default:
                     break;
             }
         }
-        return false;
+        Timber.d("isChangePendingAdd() determined changesIndex %s was not a pending add", changesIndex);
+        return -1;
     }
 
 
@@ -287,6 +330,7 @@ public boolean isTemplatePendingAdd(int ord) {
      * Return an int[] containing the collection-relative ordinals of all the currently pending deletes,
      * including the ordinal passed in, as opposed to the changelist-relative ordinals
      *
+     * @param ord int UI-relative ordinal to check database for delete safety along with existing deletes
      * @return int[] of all ordinals currently in the database, pending delete
      */
     public int[] getDeleteDbOrds(int ord) {
@@ -337,9 +381,12 @@ public int[] getDeleteDbOrds(int ord) {
 
 
     private void dumpChanges() {
+        ArrayList<Object[]> adjustedChanges = getAdjustedTemplateChanges();
         for (int i = 0; i < mTemplateChanges.size(); i++) {
             Object[] change = mTemplateChanges.get(i);
-            Timber.d("dumpChanges() Change %s is type/ord %s/%s", i, change[0], change[1]);
+            Object[] adjustedChange = adjustedChanges.get(i);
+            Timber.d("dumpChanges() Change %s is ord/type %s/%s", i, change[0], change[1]);
+            Timber.d("dumpChanges() During save change %s will be ord/type %s/%s", i, adjustedChange[0], adjustedChange[1]);
         }
     }
 
@@ -352,6 +399,38 @@ private void dumpChanges() {
     }
 
 
+    /**
+     * Adjust the ordinals in our accrued change list so that any pending adds have the correct
+     * ordinal after taking into account any pending deletes
+     *
+     * @return ArrayList<Object[2]> of [ordinal][ChangeType] entries
+     */
+    public @NonNull ArrayList<Object[]> getAdjustedTemplateChanges() {
+        ArrayList<Object[]> changes = getTemplateChanges();
+        ArrayList<Object[]> adjustedChanges = new ArrayList<>();
+
+        // In order to save the changes into the database, the ordinals in the changelist must correspond to the
+        // ordinals in the database (for deletes) or the correct index in the changes array (for adds)
+        // It is not possible to know what those will be until the user requests a save, so they are stored in the
+        // change list as-is until the save time comes, then the adjustment is made all at once
+        for (int i = 0; i < changes.size(); i++) {
+            Object[] change = changes.get(i);
+            Object[] adjustedChange = {change[0], change[1]};
+            switch ((ChangeType)adjustedChange[1]) {
+                case ADD:
+                    adjustedChange[0] = TemporaryModel.isChangePendingAdd(this, i);
+                    Timber.d("getAdjustedTemplateChanges() change %s ordinal adjusted from %s to %s", i, change[0], adjustedChange[0]);
+                    break;
+                case DELETE:
+                default:
+                    // no adjustment necessary for deletes - ephemeral deletes are already compacted out
+            }
+            adjustedChanges.add(adjustedChange);
+        }
+        return adjustedChanges;
+    }
+
+
     /**
      * Scan the sequence of template add/deletes, looking for the given ordinal.
      * When found, purge that ordinal and shift future changes down if they had ordinals higher than the one purged
diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java
index e6934abb71f6..3bf87018e7b4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java
+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java
@@ -125,7 +125,7 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle
 
 
     /**
-     * Starts a new {@link CollectionTask}.
+     * Starts a new {@link CollectionTask}, with no listener
      * <p>
      * Tasks will be executed serially, in the order in which they are started.
      * <p>
@@ -139,6 +139,18 @@ public static CollectionTask launchCollectionTask(int type, TaskData... params)
         return launchCollectionTask(type, null, params);
     }
 
+    /**
+     * Starts a new {@link CollectionTask}, with a listener provided for callbacks during execution
+     * <p>
+     * Tasks will be executed serially, in the order in which they are started.
+     * <p>
+     * This method must be called on the main thread.
+     *
+     * @param type of the task to start
+     * @param listener to the status and result of the task, may be null
+     * @param params to pass to the task
+     * @return the newly created task
+     */
     public static CollectionTask launchCollectionTask(int type, @Nullable Listener listener, TaskData... params) {
         // Start new task
         CollectionTask newTask = new CollectionTask(type, listener, sLatestInstance);
@@ -1412,7 +1424,7 @@ private TaskData doInBackgroundSaveModel(TaskData... params) {
         Object [] args = params[0].getObjArray();
         JSONObject model = (JSONObject) args[0];
         ArrayList<Object[]> templateChanges = (ArrayList<Object[]>)args[1];
-        JSONObject  oldModel = col.getModels().get(model.getLong("id"));
+        JSONObject oldModel = col.getModels().get(model.getLong("id"));
 
         // TODO need to save all the cards that will go away, for undo
         //  (do I need to remove them from graves during undo also?)
@@ -1423,8 +1435,6 @@ private TaskData doInBackgroundSaveModel(TaskData... params) {
         col.getDb().getDatabase().beginTransaction();
 
         try {
-            // Template add/deletes always arrive all deletes first, to be processed in order
-            // After that since templates can't be repositioned, any "extra" templates in newTemplates must be adds
             for (Object[] change : templateChanges) {
                 switch ((TemporaryModel.ChangeType) change[1]) {
                     case ADD:
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/CardTemplateEditorTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/CardTemplateEditorTest.java
index 24c08520f2ae..3c376b10e5b9 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/CardTemplateEditorTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/CardTemplateEditorTest.java
@@ -36,8 +36,6 @@
 import com.ichi2.libanki.Note;
 import com.ichi2.utils.JSONObject;
 
-import java.util.ArrayList;
-
 import timber.log.Timber;
 
 import static org.robolectric.Shadows.shadowOf;
@@ -58,7 +56,6 @@ public void testEditTemplateContents() throws Exception {
         intent.putExtra("modelId", collectionBasicModelOriginal.getLong("id"));
         ActivityController templateEditorController = Robolectric.buildActivity(CardTemplateEditor.class, intent).create().start().resume().visible();
         CardTemplateEditor testEditor = (CardTemplateEditor)templateEditorController.get();
-        ShadowActivity shadowTestEditor = shadowOf(testEditor);
         Assert.assertFalse("Model should not have changed yet", testEditor.modelHasChanged());
 
         // Change the model and make sure it registers as changed, but the database is unchanged
@@ -75,7 +72,7 @@ public void testEditTemplateContents() throws Exception {
         templateEditorController.pause().stop().destroy();
         templateEditorController = Robolectric.buildActivity(CardTemplateEditor.class).create(outBundle).start().resume().visible();
         testEditor = (CardTemplateEditor)templateEditorController.get();
-        shadowTestEditor = shadowOf(testEditor);
+        ShadowActivity shadowTestEditor = shadowOf(testEditor);
         Assert.assertTrue("model change not preserved across activity lifecycle?", testEditor.modelHasChanged());
         Assert.assertEquals("Change already in database?", collectionBasicModelOriginal.toString().trim(), getCurrentDatabaseModelCopy(modelName).toString().trim());
 
@@ -127,7 +124,7 @@ public void testEditTemplateContents() throws Exception {
 
 
     @Test
-    public void testDeleteTemplate() throws Exception {
+    public void testDeleteTemplate() {
 
         String modelName = "Basic (and reversed card)";
 
@@ -191,15 +188,19 @@ public void testTemplateAdd() throws Exception {
         NonPagingCardTemplateEditor.pagerCount = 1;
         ActivityController templateEditorController = Robolectric.buildActivity(NonPagingCardTemplateEditor.class, intent).create().start().resume().visible();
         CardTemplateEditor testEditor = (CardTemplateEditor)templateEditorController.get();
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
 
         // Try to add a template - click add, click confirm for card add, click confirm again for full sync
         ShadowActivity shadowTestEditor = shadowOf(testEditor);
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_add));
         advanceRobolectricLooper();
-        // TODO never existed in AnkiDroid but to match AnkiDesktop we should pop a dialog to confirm card create
+        // if AnkiDroid moves to match AnkiDesktop it will pop a dialog to confirm card create
         //Assert.assertEquals("Wrong dialog shown?", "This will create NN cards. Proceed?", getDialogText());
         //clickDialogButton(DialogAction.POSITIVE);
         Assert.assertTrue("Model should have changed", testEditor.modelHasChanged());
+        Assert.assertEquals("Change not pending add?", 1, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertTrue("Ordinal not pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
         Assert.assertEquals("Model should have 2 templates now", 2, testEditor.getTempModel().getTemplateCount());
 
         // Make sure we pass the new template to the Previewer
@@ -252,6 +253,8 @@ public void testDeleteTemplateWithSelectivelyGeneratedCards() {
         CardTemplateEditor testEditor = (CardTemplateEditor)templateEditorController.get();
         Assert.assertFalse("Model should not have changed yet", testEditor.modelHasChanged());
         Assert.assertEquals("Model should have 2 templates now", 2, testEditor.getTempModel().getTemplateCount());
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
 
         // Try to delete Card 1 template - click delete, check confirm for card delete popup indicating it was possible, then dismiss it
         ShadowActivity shadowTestEditor = shadowOf(testEditor);
@@ -262,8 +265,7 @@ public void testDeleteTemplateWithSelectivelyGeneratedCards() {
         advanceRobolectricLooper();
         Assert.assertFalse("Model should not have changed", testEditor.modelHasChanged());
 
-
-        // Create note with forward and back info, Add Reverse set to 'n'
+        // Create note with forward and back info, Add Reverse is empty, so should only be one card
         Note selectiveGeneratedNote = getCol().newNote(collectionBasicModelOriginal);
         selectiveGeneratedNote.setField(0, "TestFront");
         selectiveGeneratedNote.setField(1, "TestBack");
@@ -272,14 +274,7 @@ public void testDeleteTemplateWithSelectivelyGeneratedCards() {
             Timber.d("Got a field: %s", field);
         }
         getCol().addNote(selectiveGeneratedNote);
-
-        // - assert one card
-        ArrayList<Long> noteIds = getCol().getModels().nids(collectionBasicModelOriginal);
-        int cardCount = 0;
-        for (Long noteId : noteIds) {
-            cardCount += getCol().getNote(noteId).cards().size();
-        }
-        Assert.assertEquals("selective generation should result in one card", 1, cardCount);
+        Assert.assertEquals("selective generation should result in one card", 1, getModelCardCount(collectionBasicModelOriginal));
 
         // Try to delete the template again, but there's selective generation means it would orphan the note
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_delete));
@@ -291,21 +286,18 @@ public void testDeleteTemplateWithSelectivelyGeneratedCards() {
         advanceRobolectricLooper();
         Assert.assertNull("Can delete used template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0}));
         Assert.assertEquals("Change already in database?", collectionBasicModelOriginal.toString().trim(), getCurrentDatabaseModelCopy(modelName).toString().trim());
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertEquals("Change incorrectly added to list?", 0, testEditor.getTempModel().getTemplateChanges().size());
 
         // Assert can delete 'Card 2'
         Assert.assertNotNull("Cannot delete unused template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {1}));
 
-        // Edit note to have Add Reverse set to 'y'
+        // Edit note to have Add Reverse set to 'y' so we get a second card
         selectiveGeneratedNote.setField(2, "y");
         selectiveGeneratedNote.flush();
 
         // - assert two cards
-        noteIds = getCol().getModels().nids(collectionBasicModelOriginal);
-        cardCount = 0;
-        for (Long noteId : noteIds) {
-            cardCount += getCol().getNote(noteId).cards().size();
-        }
-        Assert.assertEquals("should be two cards now", 2, cardCount);
+        Assert.assertEquals("should be two cards now", 2, getModelCardCount(collectionBasicModelOriginal));
 
         // - assert can delete either Card template but not both
         Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0}));
@@ -329,10 +321,11 @@ public void testDeleteTemplateWithSelectivelyGeneratedCards() {
     /**
      * Normal template deletion - with no selective generation should of course work
      */
+    @SuppressWarnings("PMD.ExcessiveMethodLength")
     @Test
     public void testDeleteTemplateWithGeneratedCards() {
 
-        String modelName = "Basic";
+        String modelName = "Basic (and reversed card)";
         JSONObject collectionBasicModelOriginal = getCurrentDatabaseModelCopy(modelName);
 
         // Start the CardTemplateEditor with a specific model, and make sure the model starts unchanged
@@ -342,35 +335,44 @@ public void testDeleteTemplateWithGeneratedCards() {
         ActivityController templateEditorController = Robolectric.buildActivity(NonPagingCardTemplateEditor.class, intent).create().start().resume().visible();
         CardTemplateEditor testEditor = (CardTemplateEditor)templateEditorController.get();
         Assert.assertFalse("Model should not have changed yet", testEditor.modelHasChanged());
-        Assert.assertEquals("Model should have 1 template now", 1, testEditor.getTempModel().getTemplateCount());
+        Assert.assertEquals("Model should have 2 templates now", 2, testEditor.getTempModel().getTemplateCount());
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
 
         // Create note with forward and back info
         Note selectiveGeneratedNote = getCol().newNote(collectionBasicModelOriginal);
         selectiveGeneratedNote.setField(0, "TestFront");
         selectiveGeneratedNote.setField(1, "TestBack");
         getCol().addNote(selectiveGeneratedNote);
-        Assert.assertEquals("card generation should result in one card", 1, getModelCardCount(collectionBasicModelOriginal));
+        Assert.assertEquals("card generation should result in two cards", 2, getModelCardCount(collectionBasicModelOriginal));
 
-        // Try to delete the template, but there's only one
+        // Test if we can delete the template - should be possible - but cancel the delete
         ShadowActivity shadowTestEditor = shadowOf(testEditor);
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_delete));
         advanceRobolectricLooper();
-        Assert.assertEquals("Did not show dialog about deleting only card?",
-                getResourceString(R.string.card_template_editor_cant_delete),
+        Assert.assertEquals("Did not show dialog about deleting template and it's card?",
+                getQuantityString(R.plurals.card_template_editor_confirm_delete, 1, 1, "Card 1"),
                 getDialogText(true));
-        clickDialogButton(DialogAction.POSITIVE, true);
+        clickDialogButton(DialogAction.NEGATIVE, true);
         advanceRobolectricLooper();
+        Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0}));
+        Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {1}));
+        Assert.assertNull("Can delete both templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0, 1}));
         Assert.assertEquals("Change in database despite no change?", collectionBasicModelOriginal.toString().trim(), getCurrentDatabaseModelCopy(modelName).toString().trim());
-        Assert.assertEquals("Model should have 1 template still", 1, testEditor.getTempModel().getTemplateCount());
+        Assert.assertEquals("Model should have 2 templates still", 2, testEditor.getTempModel().getTemplateCount());
 
-        // Try to add a template - click add, click confirm for card add, click confirm again for full sync
+        // Add a template - click add, click confirm for card add, click confirm again for full sync
         shadowTestEditor.clickMenuItem(R.id.action_add);
         advanceRobolectricLooper();
         Assert.assertTrue("Model should have changed", testEditor.modelHasChanged());
+        Assert.assertEquals("Change added but not adjusted correctly?", 2, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
+        Assert.assertTrue("Ordinal not pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 2));
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_confirm));
         advanceRobolectricLooper();
         Assert.assertFalse("Model should now be unchanged", testEditor.modelHasChanged());
-        Assert.assertEquals("card generation should result in two cards", 2, getModelCardCount(collectionBasicModelOriginal));
+        Assert.assertEquals("card generation should result in three cards", 3, getModelCardCount(collectionBasicModelOriginal));
         collectionBasicModelOriginal = getCurrentDatabaseModelCopy(modelName); // reload the model for future comparison after saving the edit
 
         // Start the CardTemplateEditor back up after saving (which closes the thing...)
@@ -381,9 +383,24 @@ public void testDeleteTemplateWithGeneratedCards() {
         testEditor = (CardTemplateEditor)templateEditorController.get();
         shadowTestEditor = shadowOf(testEditor);
         Assert.assertFalse("Model should not have changed yet", testEditor.modelHasChanged());
-        Assert.assertEquals("Model should have 2 templates now", 2, testEditor.getTempModel().getTemplateCount());
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 2));
+        Assert.assertEquals("Model should have 3 templates now", 3, testEditor.getTempModel().getTemplateCount());
 
-        // Try to delete the template again, should work fine
+        // Add another template - but we work in memory for a while before saving
+        shadowTestEditor.clickMenuItem(R.id.action_add);
+        advanceRobolectricLooper();
+        Assert.assertEquals("Change added but not adjusted correctly?", 3, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertTrue("Model should have changed", testEditor.modelHasChanged());
+        Assert.assertEquals("Model should have 4 templates now", 4, testEditor.getTempModel().getTemplateCount());
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 1));
+        Assert.assertFalse("Ordinal pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 2));
+        Assert.assertTrue("Ordinal not pending add?", TemporaryModel.isOrdinalPendingAdd(testEditor.getTempModel(), 3));
+        Assert.assertEquals("Change added but not adjusted correctly?", 3, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 0));
+
+        // Delete a template now for real now - but still without saving it out, should work fine
         advanceRobolectricLooper();
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_delete));
         advanceRobolectricLooper();
@@ -393,20 +410,27 @@ public void testDeleteTemplateWithGeneratedCards() {
         clickDialogButton(DialogAction.POSITIVE, true);
         advanceRobolectricLooper();
 
-        // - assert can delete either Card template but not both
+        // - assert can delete any 1 or 2 Card templates but not all
         Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0}));
         Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {1}));
-        Assert.assertNull("Can delete both templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0, 1}));
+        Assert.assertNotNull("Cannot delete template?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {2}));
+        Assert.assertNotNull("Cannot delete two templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0, 1}));
+        Assert.assertNotNull("Cannot delete two templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0, 2}));
+        Assert.assertNotNull("Cannot delete two templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {1, 2}));
+        Assert.assertNull("Can delete all templates?", getCol().getModels().getCardIdsForModel(collectionBasicModelOriginal.getLong("id"), new int[] {0, 1, 2}));
         Assert.assertEquals("Change already in database?", collectionBasicModelOriginal.toString().trim(), getCurrentDatabaseModelCopy(modelName).toString().trim());
 
-        // Now do the delete and flush it
+        Assert.assertEquals("Change added but not adjusted correctly?", 2, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 0));
+        Assert.assertEquals("Change incorrectly pending add?", -1, TemporaryModel.isChangePendingAdd(testEditor.getTempModel(), 1));
+
+        // Now confirm everything to persist it to the database
         Assert.assertTrue("Unable to click?", shadowTestEditor.clickMenuItem(R.id.action_confirm));
         advanceRobolectricLooper();
         advanceRobolectricLooper();
         advanceRobolectricLooper();
         Assert.assertNotEquals("Change not in database?", collectionBasicModelOriginal.toString().trim(), getCurrentDatabaseModelCopy(modelName).toString().trim());
-        Assert.assertEquals("Model should have 1 template now", 1, getCurrentDatabaseModelCopy(modelName).getJSONArray("tmpls").length());
-        Assert.assertEquals("should be one card", 1, getModelCardCount(collectionBasicModelOriginal));
+        Assert.assertEquals("Model should have 3 templates now", 3, getCurrentDatabaseModelCopy(modelName).getJSONArray("tmpls").length());
+        Assert.assertEquals("should be three cards", 3, getModelCardCount(collectionBasicModelOriginal));
     }
 
     private int getModelCardCount(JSONObject model) {
@@ -416,4 +440,4 @@ private int getModelCardCount(JSONObject model) {
         }
         return cardCount;
     }
-}
\ No newline at end of file
+}
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/TemporaryModelTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/TemporaryModelTest.java
index 958e9c278270..3d5529dd3b6d 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/TemporaryModelTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/TemporaryModelTest.java
@@ -25,6 +25,7 @@
 
 import com.ichi2.utils.JSONObject;
 
+import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
 
@@ -52,12 +53,17 @@ public void testTempModelStorage() throws Exception {
         // Make sure clearing works
         Assert.assertEquals(1, TemporaryModel.clearTempModelFiles());
         Timber.i("The following logged NoSuchFileException is an expected part of verifying a file delete.");
-        Assert.assertNull("tempModel not correctly deleted", TemporaryModel.getTempModel(tempModelPath));
+        try {
+            TemporaryModel.getTempModel(tempModelPath);
+            Assert.fail("Should have caught an exception here because the file is missing");
+        } catch (IOException e) {
+            // this is expected
+        }
     }
 
 
     @Test
-    public void testAddDeleteTracking() throws Exception {
+    public void testAddDeleteTracking() {
 
         // Assume you start with a 2 template model (like "Basic (and reversed)")
         // Add a 3rd new template, remove the 2nd, remove the 1st, add a new now-2nd, remove 1st again
@@ -66,31 +72,73 @@ public void testAddDeleteTracking() throws Exception {
 
         tempModel.addTemplateChange(ADD, 3);
         Object[][] expected1 = {{3, ADD}};
+        // 3 templates and one change now
         assertTemplateChangesEqual(expected1, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(expected1, tempModel.getAdjustedTemplateChanges());
+        Assert.assertArrayEquals(new int[]{3}, tempModel.getDeleteDbOrds(3));
+
         tempModel.addTemplateChange(DELETE, 2);
-        tempModel.addTemplateChange(DELETE, 1);
-        Object[][] expected2 = {{3, ADD}, {2, DELETE}, {1, DELETE}};
+        // 2 templates and two changes now
+        Object[][] expected2 = {{3, ADD}, {2, DELETE}};
+        Object[][] adjExpected2 = {{2, ADD}, {2, DELETE}};
         assertTemplateChangesEqual(expected2, tempModel.getTemplateChanges());
-        tempModel.addTemplateChange(ADD, 2);
-        Object[][] expected3 = {{3, ADD}, {2, DELETE}, {1, DELETE}, {2, ADD}};
+        assertTemplateChangesEqual(adjExpected2, tempModel.getAdjustedTemplateChanges());
+        Assert.assertArrayEquals(new int[]{2, 4}, tempModel.getDeleteDbOrds(3));
+
+        tempModel.addTemplateChange(DELETE, 1);
+        // 1 template and three changes now
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected3 = {{3, ADD}, {2, DELETE}, {1, DELETE}};
+        Object[][] adjExpected3 = {{1, ADD}, {2, DELETE}, {1, DELETE}};
         assertTemplateChangesEqual(expected3, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(adjExpected3, tempModel.getAdjustedTemplateChanges());
+
+        tempModel.addTemplateChange(ADD, 2);
+        // 2 templates and 4 changes now
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected4 = {{3, ADD}, {2, DELETE}, {1, DELETE}, {2, ADD}};
+        Object[][] adjExpected4 = {{1, ADD}, {2, DELETE}, {1, DELETE}, {2, ADD}};
+        assertTemplateChangesEqual(expected4, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(adjExpected4, tempModel.getAdjustedTemplateChanges());
 
         // Make sure we can resurrect these changes across lifecycle
         Bundle outBundle = tempModel.toBundle();
-        assertTemplateChangesEqual(expected3, outBundle.getSerializable("mTemplateChanges"));
+        assertTemplateChangesEqual(expected4, outBundle.getSerializable("mTemplateChanges"));
 
         // This is the hard part. We will delete a template we added so everything shifts.
         // The template currently at ordinal 1 was added as template 3 at the start before it slid down on the deletes
         // So the first template add should be negated by this delete, and the second template add should slide down to 1
         tempModel.addTemplateChange(DELETE, 1);
-        Object[][] expected4 = {{2, DELETE}, {1, DELETE}, {1, ADD}};
-        assertTemplateChangesEqual(expected4, tempModel.getTemplateChanges());
-        tempModel.addTemplateChange(ADD, 2);
-        Object[][] expected5 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}};
+        // 1 template and 3 changes now (the delete just cancelled out one of the adds)
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected5 = {{2, DELETE}, {1, DELETE}, {1, ADD}};
+        Object[][] adjExpected5 = {{2, DELETE}, {1, DELETE}, {1, ADD}};
         assertTemplateChangesEqual(expected5, tempModel.getTemplateChanges());
-        tempModel.addTemplateChange(DELETE, 2);
-        Object[][] expected6 = {{2, DELETE}, {1, DELETE}, {1, ADD}};
+        assertTemplateChangesEqual(adjExpected5, tempModel.getAdjustedTemplateChanges());
+
+        tempModel.addTemplateChange(ADD, 2);
+        // 2 template and 4 changes now (the delete just cancelled out one of the adds)
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected6 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}};
+        Object[][] adjExpected6 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}};
         assertTemplateChangesEqual(expected6, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(adjExpected6, tempModel.getAdjustedTemplateChanges());
+
+        tempModel.addTemplateChange(ADD, 3);
+        // 2 template and 4 changes now (the delete just cancelled out one of the adds)
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected7 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}, {3, ADD}};
+        Object[][] adjExpected7 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}, {3, ADD}};
+        assertTemplateChangesEqual(expected7, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(adjExpected7, tempModel.getAdjustedTemplateChanges());
+
+        tempModel.addTemplateChange(DELETE, 3);
+        // 1 template and 3 changes now (two deletes cancelled out adds)
+        Assert.assertArrayEquals(new int[]{2, 1, 5}, tempModel.getDeleteDbOrds(3));
+        Object[][] expected8 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}};
+        Object[][] adjExpected8 = {{2, DELETE}, {1, DELETE}, {1, ADD}, {2, ADD}};
+        assertTemplateChangesEqual(expected8, tempModel.getTemplateChanges());
+        assertTemplateChangesEqual(adjExpected8, tempModel.getAdjustedTemplateChanges());
     }
 
 
