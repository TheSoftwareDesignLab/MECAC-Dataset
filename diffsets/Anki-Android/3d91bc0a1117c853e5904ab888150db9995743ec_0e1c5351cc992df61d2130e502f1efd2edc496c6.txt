diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ReadText.java b/AnkiDroid/src/main/java/com/ichi2/anki/ReadText.java
index 2cde3b363927..575b63d466cb 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ReadText.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ReadText.java
@@ -26,10 +26,11 @@
 import android.widget.Toast;
 
 import com.afollestad.materialdialogs.MaterialDialog;
+import com.ichi2.compat.Compat;
+import com.ichi2.compat.CompatHelper;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.Locale;
 
 import timber.log.Timber;
@@ -44,16 +45,15 @@ public class ReadText {
     private static int mQuestionAnswer;
     public static final String NO_TTS = "0";
     public static ArrayList<String[]> sTextQueue = new ArrayList<>();
-    public static HashMap<String, String> mTtsParams;
+    private static Compat compat = CompatHelper.getCompat();
+    private static Object mTtsParams = compat.initTtsParams();
 
 
-    // private boolean mTtsReady = false;
-    @SuppressWarnings("deprecation") // Movement to new API tracked in github as #5021
     public static void speak(String text, String loc, int queueMode) {
         int result = mTts.setLanguage(localeFromStringIgnoringScriptAndExtensions(loc));
         if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
             Toast.makeText(mReviewer.get(), mReviewer.get().getString(R.string.no_tts_available_message)
-                    +" ("+loc+")", Toast.LENGTH_LONG).show();
+                    + " (" + loc + ")", Toast.LENGTH_LONG).show();
             Timber.e("Error loading locale " + loc);
         } else {
             if (mTts.isSpeaking() && queueMode == TextToSpeech.QUEUE_FLUSH) {
@@ -61,12 +61,12 @@ public static void speak(String text, String loc, int queueMode) {
                 stopTts();
                 //sTextQueue.add(new String[] { text, loc });
             }
-            Timber.d("tts text '%s' to be played for locale (%s)",text, loc);
-            mTts.speak(mTextToSpeak, queueMode, mTtsParams);
+            Timber.d("tts text '%s' to be played for locale (%s)", text, loc);
+            compat.speak(mTts, mTextToSpeak, queueMode, mTtsParams, "stringId");
         }
     }
 
-
+    
     public static String getLanguage(long did, int ord, int qa) {
         return MetaDB.getLanguage(mReviewer.get(), did, ord, qa);
     }
@@ -169,14 +169,14 @@ public static void readCardSide(int cardSide, String cardSideContents, long did,
      * The voice is chosen as follows:
      * <p>
      * 1. If localeCode is a non-empty string representing a locale in the format returned
-     *    by Locale.toString(), and a voice matching the language of this locale (and ideally,
-     *    but not necessarily, also the country and variant of the locale) is available, then this
-     *    voice is used.
+     * by Locale.toString(), and a voice matching the language of this locale (and ideally,
+     * but not necessarily, also the country and variant of the locale) is available, then this
+     * voice is used.
      * 2. Otherwise, if the database contains a saved language for the given 'did', 'ord' and 'qa'
-     *    arguments, and a TTS voice matching that language is available, then this voice is used
-     *    (unless the saved language is NO_TTS, in which case the text is not read at all).
+     * arguments, and a TTS voice matching that language is available, then this voice is used
+     * (unless the saved language is NO_TTS, in which case the text is not read at all).
      * 3. Otherwise, the user is asked to select a language from among those for which a voice is
-     *    available.
+     * available.
      *
      * @param queueMode TextToSpeech.QUEUE_ADD or TextToSpeech.QUEUE_FLUSH.
      */
@@ -307,8 +307,6 @@ public void onStart(String arg0) {
                 }
             }
         });
-        mTtsParams = new HashMap<>();
-        mTtsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "stringId");
         // Show toast that it's getting initialized, as it can take a while before the sound plays the first time
         Toast.makeText(context, context.getString(R.string.initializing_tts), Toast.LENGTH_LONG).show();
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/compat/Compat.java b/AnkiDroid/src/main/java/com/ichi2/compat/Compat.java
index 37da91ad7492..311328a56a73 100644
--- a/AnkiDroid/src/main/java/com/ichi2/compat/Compat.java
+++ b/AnkiDroid/src/main/java/com/ichi2/compat/Compat.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.StatFs;
+import android.speech.tts.TextToSpeech;
 import android.text.Spanned;
 import android.view.View;
 import android.view.Window;
@@ -88,5 +89,9 @@ public interface Compat {
     void vibrate(Context context, long durationMillis);
     long copyFile(String source, OutputStream target) throws IOException;
     long copyFile(InputStream source, String target) throws IOException;
+
+    /** TextToSpeech API. {@link Compat#initTtsParams} should be called before calling {@link Compat#speak*/
+    Object initTtsParams();
+    int speak(TextToSpeech tts, String text, int queueMode, Object ttsParams, String utteranceId);
 }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/compat/CompatV15.java b/AnkiDroid/src/main/java/com/ichi2/compat/CompatV15.java
index b96c7fb6bdb5..4748daf0aa95 100644
--- a/AnkiDroid/src/main/java/com/ichi2/compat/CompatV15.java
+++ b/AnkiDroid/src/main/java/com/ichi2/compat/CompatV15.java
@@ -27,6 +27,7 @@
 
 import android.os.StatFs;
 import android.os.Vibrator;
+import android.speech.tts.TextToSpeech;
 import android.text.Html;
 import android.text.Spanned;
 import android.view.View;
@@ -49,6 +50,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Map;
 
 import androidx.sqlite.db.SupportSQLiteDatabase;
 import timber.log.Timber;
@@ -232,4 +235,17 @@ private long copyFile(@NonNull InputStream source, @NonNull OutputStream target)
         target.flush();
         return count;
     }
+
+    @Override
+    public Object initTtsParams() {
+        return new HashMap<String, String>();
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public int speak(TextToSpeech tts, String text, int queueMode, Object ttsParams, String utteranceId) {
+        HashMap<String, String> params = (HashMap) ttsParams;
+        params.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId);
+        return tts.speak(text, queueMode, params);
+    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/compat/CompatV21.java b/AnkiDroid/src/main/java/com/ichi2/compat/CompatV21.java
index 1c62f17f14a0..b193cca6a7e8 100644
--- a/AnkiDroid/src/main/java/com/ichi2/compat/CompatV21.java
+++ b/AnkiDroid/src/main/java/com/ichi2/compat/CompatV21.java
@@ -6,12 +6,16 @@
 import android.content.res.TypedArray;
 import android.hardware.camera2.CameraAccessException;
 import android.hardware.camera2.CameraManager;
+import android.os.Bundle;
+import android.speech.tts.TextToSpeech;
 import android.view.View;
 import android.view.Window;
 import android.webkit.CookieManager;
 
 import com.ichi2.anki.AnkiDroidApp;
 
+import java.util.HashMap;
+
 import timber.log.Timber;
 
 /** Implementation of {@link Compat} for SDK level 21 */
@@ -56,4 +60,14 @@ public int getCameraCount() {
         }
         return 0;
     }
+
+    @Override
+    public Object initTtsParams() {
+        return new Bundle();
+    }
+
+    @Override
+    public int speak(TextToSpeech tts, String text, int queueMode, Object ttsParams, String utteranceId) {
+        return tts.speak(text, queueMode, (Bundle) ttsParams, utteranceId);
+    }
 }
\ No newline at end of file
