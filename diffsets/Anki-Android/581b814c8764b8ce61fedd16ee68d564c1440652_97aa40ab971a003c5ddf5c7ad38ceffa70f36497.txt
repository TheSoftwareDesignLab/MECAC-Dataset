diff --git a/AnkiDroid/src/main/assets/scripts/ankidroid.js b/AnkiDroid/src/main/assets/scripts/ankidroid.js
index e3eddba7f9c4..0308ce87c657 100644
--- a/AnkiDroid/src/main/assets/scripts/ankidroid.js
+++ b/AnkiDroid/src/main/assets/scripts/ankidroid.js
@@ -47,8 +47,7 @@ globalThis.ankidroid.doubleTapTimeout = 200;
     let startX = 0,
         startY = 0,
         touchCount = 0,
-        touchStartTime = 0,
-        tapTimer = null;
+        touchStartTime = 0;
 
     document.addEventListener(
         "touchstart",
@@ -76,24 +75,16 @@ globalThis.ankidroid.doubleTapTimeout = 200;
             )
                 return;
 
-            // Multi-finger detection. Takes priority over double taps
+            // Multi-finger detection
             if (touchCount > 1) {
-                if ((Date.now() - touchStartTime) > MULTI_TOUCH_TIMEOUT) {
+                if (Date.now() - touchStartTime > MULTI_TOUCH_TIMEOUT) {
                     return;
                 }
                 window.location.href = `${SCHEME}://multiFingerTap/?touchCount=${touchCount}`;
                 return;
             }
 
-            // Double tap detection
-            if (tapTimer != null) {
-                clearTimeout(tapTimer);
-                tapTimer = null;
-                window.location.href = `${SCHEME}://doubleTap`;
-                return;
-            }
-
-            // Swipes and single tap detection
+            // Swipes and tap detection
             const endX = event.changedTouches[0].pageX;
             const endY = event.changedTouches[0].pageY;
             const scrollDirection = getScrollDirection(event.target);
@@ -102,15 +93,12 @@ globalThis.ankidroid.doubleTapTimeout = 200;
                 y: Math.round(endY),
                 deltaX: Math.round(endX - startX),
                 deltaY: Math.round(endY - startY),
+                time: Date.now(),
             });
             if (scrollDirection !== null) {
                 params.append("scrollDirection", scrollDirection);
             }
-            const requestUrl = `${SCHEME}://tapOrSwipe/?${params.toString()}`;
-            tapTimer = setTimeout(() => {
-                window.location.href = requestUrl;
-                tapTimer = null;
-            }, ankidroid.doubleTapTimeout);
+            window.location.href = `${SCHEME}://tapOrSwipe/?${params.toString()}`;
         },
         { passive: true },
     );
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt
index c7e5a3df2afe..67dedd228d2f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt
@@ -22,6 +22,10 @@ import com.ichi2.anki.cardviewer.Gesture
 import com.ichi2.anki.cardviewer.TapGestureMode
 import com.ichi2.anki.settings.Prefs
 import com.ichi2.anki.utils.ext.clamp
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
 import timber.log.Timber
 import kotlin.math.abs
 
@@ -31,31 +35,36 @@ import kotlin.math.abs
  * @see parse
  */
 class GestureParser(
+    private val scope: CoroutineScope,
+    private val isDoubleTapEnabled: Boolean,
     private val gestureMode: TapGestureMode = Prefs.tapGestureMode,
+    private val doubleTapTimeout: Long = Prefs.doubleTapInterval.toLong(),
     swipeSensitivity: Float = Prefs.swipeSensitivity,
 ) {
     private val swipeThresholdBase = 100 / swipeSensitivity
+    private var lastTapTime = 0L
+    private var singleTapJob: Job? = null
 
-    /**
-     * Analyzes the given [Uri] and returns the corresponding [Gesture]
-     */
     @VisibleForTesting
     fun parseInternal(
         uri: Uri,
         webViewState: WebViewState,
-    ): Gesture? {
-        when (uri.host) {
-            DOUBLE_TAP_HOST -> return Gesture.DOUBLE_TAP
-            MULTI_FINGER_HOST -> return getMultiTouchGesture(uri)
-        }
-        val data = GestureData.fromUri(uri) ?: return null
-
-        val swipeThreshold = swipeThresholdBase / webViewState.scale
-        if (abs(data.deltaX) > swipeThreshold || abs(data.deltaY) > swipeThreshold) {
-            return determineSwipeGesture(data)
-        }
-
-        return getTap(data, webViewState)
+        block: (Gesture?) -> Unit,
+    ) {
+        val gesture =
+            if (uri.host == MULTI_FINGER_HOST) {
+                getMultiTouchGesture(uri)
+            } else {
+                val data = GestureData.fromUri(uri) ?: return
+                val swipeThreshold = swipeThresholdBase / webViewState.scale
+                if (abs(data.deltaX) > swipeThreshold || abs(data.deltaY) > swipeThreshold) {
+                    determineSwipeGesture(data)
+                } else {
+                    handleTap(data, webViewState, block)
+                    return
+                }
+            }
+        block(gesture)
     }
 
     /**
@@ -70,7 +79,8 @@ class GestureParser(
         uri: Uri,
         scale: Float,
         webView: WebView,
-    ): Gesture? {
+        block: (Gesture?) -> Unit,
+    ) {
         val webViewState =
             WebViewState(
                 scale = scale,
@@ -79,7 +89,36 @@ class GestureParser(
                 width = webView.measuredWidth,
                 height = webView.measuredHeight,
             )
-        return parseInternal(uri, webViewState)
+        parseInternal(uri, webViewState, block)
+    }
+
+    private fun handleTap(
+        data: GestureData,
+        webViewState: WebViewState,
+        block: (Gesture?) -> Unit,
+    ) {
+        val isPotentialDoubleTap = data.time - lastTapTime < doubleTapTimeout
+        lastTapTime = data.time
+        if (isDoubleTapEnabled) {
+            if (isPotentialDoubleTap) {
+                // Confirmed double tap. Cancel any pending single tap and fire double tap.
+                singleTapJob?.cancel()
+                singleTapJob = null
+                lastTapTime = 0 // avoid retriggering double tap if a new quick tap comes
+                block(Gesture.DOUBLE_TAP)
+            } else {
+                // Potential single tap. Schedule it to run after a delay.
+                singleTapJob =
+                    scope.launch {
+                        delay(doubleTapTimeout)
+                        block(getTap(data, webViewState))
+                    }
+            }
+        } else {
+            if (!isPotentialDoubleTap) {
+                block(getTap(data, webViewState))
+            } // Otherwise, ignore the double tap.
+        }
     }
 
     /**
@@ -191,6 +230,7 @@ class GestureParser(
         val y: Int,
         val deltaX: Int,
         val deltaY: Int,
+        val time: Long,
         val scrollDirection: String?,
     ) {
         companion object {
@@ -201,6 +241,7 @@ class GestureParser(
                         y = uri.getIntQuery(PARAM_Y) ?: return@run null,
                         deltaX = uri.getIntQuery(PARAM_DELTA_X) ?: return@run null,
                         deltaY = uri.getIntQuery(PARAM_DELTA_Y) ?: return@run null,
+                        time = uri.getQueryParameter(PARAM_TIME)?.toLongOrNull() ?: return@run null,
                         scrollDirection = uri.getQueryParameter(PARAM_SCROLL_DIRECTION),
                     )
                 }
@@ -271,13 +312,13 @@ class GestureParser(
         const val PARAM_DELTA_Y = "deltaY"
 
         @VisibleForTesting
-        const val PARAM_SCROLL_DIRECTION = "scrollDirection"
+        const val PARAM_TIME = "time"
 
         @VisibleForTesting
-        const val PARAM_TOUCH_COUNT = "touchCount"
+        const val PARAM_SCROLL_DIRECTION = "scrollDirection"
 
         @VisibleForTesting
-        const val DOUBLE_TAP_HOST = "doubleTap"
+        const val PARAM_TOUCH_COUNT = "touchCount"
 
         @VisibleForTesting
         const val MULTI_FINGER_HOST = "multiFingerTap"
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
index 96d72f94ffd1..af687afad09b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
@@ -612,7 +612,12 @@ class ReviewerFragment :
         private var scale: Float = if (!isRobolectric) webView.scale else 1F
         private var isScrolling: Boolean = false
         private var isScrollingJob: Job? = null
-        private val gestureParser = GestureParser()
+        private val gestureParser by lazy {
+            GestureParser(
+                scope = lifecycleScope,
+                isDoubleTapEnabled = bindingMap.isBound(Gesture.DOUBLE_TAP),
+            )
+        }
 
         init {
             webView.setOnScrollChangeListener { _, _, _, _, _ ->
@@ -630,9 +635,11 @@ class ReviewerFragment :
             return when (url.scheme) {
                 "gesture" -> {
                     if (isScrolling) return true
-                    val gesture = gestureParser.parse(url, scale, webView) ?: return true
-                    Timber.v("ReviewerFragment::onGesture %s", gesture)
-                    bindingMap.onGesture(gesture)
+                    gestureParser.parse(url, scale, webView) { gesture ->
+                        if (gesture == null) return@parse
+                        Timber.v("ReviewerFragment::onGesture %s", gesture)
+                        bindingMap.onGesture(gesture)
+                    }
                     true
                 }
                 "ankidroid" -> {
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt
index 08291922c9a5..70ba6b5cd4ba 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt
@@ -20,6 +20,7 @@ import com.ichi2.anki.cardviewer.Gesture
 import com.ichi2.anki.cardviewer.TapGestureMode
 import io.mockk.every
 import io.mockk.mockk
+import kotlinx.coroutines.test.TestScope
 import org.junit.Test
 import kotlin.test.assertEquals
 import kotlin.test.assertNull
@@ -33,6 +34,7 @@ class GestureParserTest {
         y: Int? = 100,
         deltaX: Int? = 0,
         deltaY: Int? = 0,
+        time: Int? = 10000,
         touchCount: Int? = 1,
         scrollDirection: String? = null,
     ): Uri =
@@ -42,6 +44,7 @@ class GestureParserTest {
             every { getQueryParameter(GestureParser.PARAM_Y) } returns y?.toString()
             every { getQueryParameter(GestureParser.PARAM_DELTA_X) } returns deltaX?.toString()
             every { getQueryParameter(GestureParser.PARAM_DELTA_Y) } returns deltaY?.toString()
+            every { getQueryParameter(GestureParser.PARAM_TIME) } returns time?.toString()
             every { getQueryParameter(GestureParser.PARAM_TOUCH_COUNT) } returns touchCount?.toString()
             every { getQueryParameter(GestureParser.PARAM_SCROLL_DIRECTION) } returns scrollDirection
         }
@@ -58,21 +61,21 @@ class GestureParserTest {
     ): Gesture? {
         val gestureParser =
             GestureParser(
+                scope = TestScope(),
                 swipeSensitivity = swipeSensitivity,
                 gestureMode = gestureMode,
+                doubleTapTimeout = 200,
+                isDoubleTapEnabled = false,
             )
         val webViewState = GestureParser.WebViewState(scale, scrollX, scrollY, measuredWidth, measuredHeight)
-        return gestureParser.parseInternal(
+        var gesture: Gesture? = null
+        gestureParser.parseInternal(
             uri = uri,
             webViewState = webViewState,
-        )
-    }
-
-    @Test
-    fun `parse returns DOUBLE_TAP for doubleTap host`() {
-        val uri = createMockUri(host = GestureParser.DOUBLE_TAP_HOST)
-        val gesture = parseGesture(uri = uri)
-        assertEquals(Gesture.DOUBLE_TAP, gesture)
+        ) {
+            gesture = it
+        }
+        return gesture
     }
 
     @Test
