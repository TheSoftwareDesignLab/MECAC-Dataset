diff --git a/AnkiDroid/src/main/AndroidManifest.xml b/AnkiDroid/src/main/AndroidManifest.xml
index 758e8e90cb7f..986ff98ab702 100644
--- a/AnkiDroid/src/main/AndroidManifest.xml
+++ b/AnkiDroid/src/main/AndroidManifest.xml
@@ -270,36 +270,6 @@
         <!-- Service to perform web API queries -->
         <service android:name="com.ichi2.widget.AnkiDroidWidgetSmall$UpdateService" />
 
-        <!--
-        medium widget
-		<receiver android:name="com.ichi2.widget.AnkiDroidWidgetMedium" android:label="@string/widget_medium">
-			<intent-filter>
-			<action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
-			</intent-filter>
-			<meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider" />
-		</receiver>
-        -->
-        <!--
-        Service to perform web API queries
-		<service android:name="com.ichi2.widget.AnkiDroidWidgetMedium$UpdateService" />
-        -->
-
-
-        <!--
-        big widget
-		<uses-library android:name="android.test.runner"></uses-library>
-		<receiver android:name="com.ichi2.widget.AnkiDroidWidgetBig" android:label="@string/widget_big">
-			<intent-filter>
-			<action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
-			</intent-filter>
-			<meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_big" />
-		</receiver>
-        -->
-        <!--
-        Service to perform web API queries
-		<service android:name="com.ichi2.widget.AnkiDroidWidgetBig$UpdateService" />
-        -->
-
         <receiver
             android:name="com.ichi2.anki.receiver.SdCardReceiver"
             android:enabled="true"
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
index 371efc00dacd..bb21b5de323e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
@@ -2569,8 +2569,6 @@ protected void closeReviewer(int result, boolean saveDeck) {
 
         AbstractFlashcardViewer.this.setResult(result);
 
-        // updateBigWidget(!mCardFrame.isEnabled());
-
         if (saveDeck) {
             UIUtils.saveCollectionInBackground(this);
         }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
index 386add4a1526..571b6123a1bf 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
@@ -1767,9 +1767,6 @@ public void onPostExecute(TaskData result) {
                     scrollDecklistToDeck(current);
                     mFocusedDeck = current;
                 }
-
-                // update widget
-                WidgetStatus.update(DeckPicker.this, nodes);
                 // update options menu and clear welcome screen
                 supportInvalidateOptionsMenu();
                 // Update the mini statistics bar as well
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/MetaDB.java b/AnkiDroid/src/main/java/com/ichi2/anki/MetaDB.java
index 9adc0c2ca6a0..4f31b2d0b4cc 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/MetaDB.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/MetaDB.java
@@ -5,6 +5,7 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
+import android.util.Pair;
 
 
 import com.ichi2.libanki.Utils;
@@ -91,7 +92,7 @@ private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVers
         mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS customDictionary (" + "_id INTEGER PRIMARY KEY AUTOINCREMENT, "
                 + "did INTEGER NOT NULL, " + "dictionary INTEGER)");
         mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS smallWidgetStatus (" + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
-                + "progress INTEGER NOT NULL, left INTEGER NOT NULL, eta INTEGER NOT NULL)");
+                + "due INTEGER NOT NULL, eta INTEGER NOT NULL)");
         // Use pragma to get info about widgetStatus.
         Cursor c = mMetaDb.rawQuery("PRAGMA table_info(widgetStatus)", null);
         int columnNumber = c.getCount();
@@ -370,52 +371,16 @@ public static void storeLookupDictionary(Context context, long did, int dictiona
     /**
      * Return the current status of the widget.
      * 
-     * @return an array of {@link DeckStatus} objects, each representing the status of one of the known decks
-     */
-    public static DeckStatus[] getWidgetStatus(Context context) {
-        openDBIfClosed(context);
-        Cursor cursor = null;
-        try {
-            cursor = mMetaDb.query("widgetStatus", new String[] { "deckId", "deckName", "newCards", "lrnCards",
-                    "dueCards", "progress", "eta" }, null, null, null, null, "deckName");
-            int count = cursor.getCount();
-            DeckStatus[] decks = new DeckStatus[count];
-            for (int index = 0; index < count; ++index) {
-                if (!cursor.moveToNext()) {
-                    throw new SQLiteException("cursor count was incorrect");
-                }
-                decks[index] = new DeckStatus(cursor.getLong(cursor.getColumnIndexOrThrow("deckId")),
-                        cursor.getString(cursor.getColumnIndexOrThrow("deckName")), cursor.getInt(cursor
-                                .getColumnIndexOrThrow("newCards")), cursor.getInt(cursor
-                                .getColumnIndexOrThrow("lrnCards")), cursor.getInt(cursor
-                                .getColumnIndexOrThrow("dueCards")), cursor.getInt(cursor
-                                .getColumnIndexOrThrow("progress")), cursor.getInt(cursor.getColumnIndexOrThrow("eta")));
-            }
-            return decks;
-        } catch (SQLiteException e) {
-            Timber.e(e, "Error while querying widgetStatus");
-        } finally {
-            if (cursor != null && !cursor.isClosed()) {
-                cursor.close();
-            }
-        }
-        return new DeckStatus[0];
-    }
-
-
-    /**
-     * Return the current status of the widget.
-     * 
-     * @return an int array, containing due, progress, eta
+     * @return [due, eta]
      */
     public static int[] getWidgetSmallStatus(Context context) {
         openDBIfClosed(context);
         Cursor cursor = null;
         try {
-            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "progress", "left", "eta" }, null, null, null,
-                    null, null);
+            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "due", "eta" },
+                    null, null, null, null, null);
             while (cursor.moveToNext()) {
-                return (new int[] { cursor.getInt(0), cursor.getInt(1), cursor.getInt(2) });
+                return new int[]{cursor.getInt(0), cursor.getInt(1)};
             }
         } catch (SQLiteException e) {
             Timber.e(e, "Error while querying widgetStatus");
@@ -424,7 +389,7 @@ public static int[] getWidgetSmallStatus(Context context) {
                 cursor.close();
             }
         }
-        return null;
+        return new int[]{0, 0};
     }
 
 
@@ -433,13 +398,10 @@ public static int getNotificationStatus(Context context) {
         Cursor cursor = null;
         int due = 0;
         try {
-            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "left" }, null, null, null, null, null);
+            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "due" }, null, null, null, null, null);
             if (cursor.moveToFirst()) {
                 return cursor.getInt(0);
             }
-            // while (cursor.moveToNext()) {
-            // due += cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
-            // }
         } catch (SQLiteException e) {
             Timber.e(e, "Error while querying widgetStatus");
         } finally {
@@ -451,15 +413,15 @@ public static int getNotificationStatus(Context context) {
     }
 
 
-    public static void storeSmallWidgetStatus(Context context, float[] progress) {
+    public static void storeSmallWidgetStatus(Context context, Pair<Integer, Integer> status) {
         openDBIfClosed(context);
         try {
             mMetaDb.beginTransaction();
             try {
                 // First clear all the existing content.
                 mMetaDb.execSQL("DELETE FROM smallWidgetStatus");
-                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(progress, left, eta) VALUES (?, ?, ?)", new Object[] {
-                        (int) (progress[1] * 1000), (int) progress[2], (int) progress[3] });
+                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(due, eta) VALUES (?, ?)",
+                        new Object[]{status.first, status.second});
                 mMetaDb.setTransactionSuccessful();
             } finally {
                 mMetaDb.endTransaction();
@@ -472,38 +434,4 @@ public static void storeSmallWidgetStatus(Context context, float[] progress) {
             Timber.i("MetaDB:: Trying to reset Widget: " + resetWidget(context));
         }
     }
-
-
-    /**
-     * Stores the current state of the widget.
-     * <p>
-     * It replaces any stored state for the widget.
-     * 
-     * @param decks an array of {@link DeckStatus} objects, one for each of the know decks.
-     */
-    public static void storeWidgetStatus(Context context, DeckStatus[] decks) {
-        openDBIfClosed(context);
-        try {
-            mMetaDb.beginTransaction();
-            try {
-                // First clear all the existing content.
-                mMetaDb.execSQL("DELETE FROM widgetStatus");
-                for (DeckStatus deck : decks) {
-                    mMetaDb.execSQL(
-                            "INSERT INTO widgetStatus(deckId, deckName, newCards, lrnCards, dueCards, progress, eta) "
-                                    + "VALUES (?, ?, ?, ?, ?, ?, ?)", new Object[] { deck.mDeckId, deck.mDeckName,
-                                    deck.mNewCards, deck.mLrnCards, deck.mDueCards, deck.mProgress, deck.mEta });
-                }
-                mMetaDb.setTransactionSuccessful();
-            } finally {
-                mMetaDb.endTransaction();
-            }
-        } catch (IllegalStateException e) {
-            Timber.e(e, "MetaDB.storeWidgetStatus: failed");
-        } catch (SQLiteException e) {
-            Timber.e(e, "MetaDB.storeWidgetStatus: failed");
-            closeDB();
-            Timber.i("MetaDB:: Trying to reset Widget: " + resetWidget(context));
-        }
-    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
index 036b21fa3665..ef1018e6ddc0 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
@@ -73,7 +73,7 @@
 import com.ichi2.libanki.Utils;
 import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
-import com.ichi2.widget.PopupMenuWithIcons;
+import com.ichi2.anki.widgets.PopupMenuWithIcons;
 import com.ichi2.widget.WidgetStatus;
 
 import org.json.JSONArray;
@@ -120,9 +120,6 @@ public class NoteEditor extends AnkiActivity {
     public static final int CALLER_STUDYOPTIONS = 2;
     public static final int CALLER_DECKPICKER = 3;
 
-    public static final int CALLER_BIGWIDGET_EDIT = 4;
-    public static final int CALLER_BIGWIDGET_ADD = 5;
-
     public static final int CALLER_CARDBROWSER_EDIT = 6;
     public static final int CALLER_CARDBROWSER_ADD = 7;
 
@@ -199,11 +196,7 @@ public void onPreExecute() {
         @Override
         public void onProgressUpdate(DeckTask.TaskData... values) {
             int count = values[0].getInt();
-            if (mCaller == CALLER_BIGWIDGET_EDIT) {
-                // AnkiDroidWidgetBig.setCard(values[0].getCard());
-                // AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED);
-                mChanged = true;
-            } else if (count > 0) {
+            if (count > 0) {
                 mChanged = true;
                 mSourceText = null;
                 Note oldNote = mEditorNote.clone();
@@ -227,7 +220,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
             } else {
                 Themes.showThemedToast(NoteEditor.this, getResources().getString(R.string.factadder_saving_error), true);
             }
-            if (!mAddNote || mCaller == CALLER_CARDEDITOR || mCaller == CALLER_BIGWIDGET_EDIT || mAedictIntent) {
+            if (!mAddNote || mCaller == CALLER_CARDEDITOR || mAedictIntent) {
                 mChanged = true;
                 mCloseAfter = true;
             } else if (mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
@@ -389,20 +382,6 @@ public void onClick(View v) {
                 mAddNote = true;
                 break;
 
-            case CALLER_BIGWIDGET_EDIT:
-                // Card widgetCard = AnkiDroidWidgetBig.getCard();
-                // if (widgetCard == null) {
-                // finish();
-                // return;
-                // }
-                // mEditorNote = widgetCard.getFact();
-                // mAddNote = false;
-                break;
-
-            case CALLER_BIGWIDGET_ADD:
-                mAddNote = true;
-                break;
-
             case CALLER_CARDBROWSER_EDIT:
                 mCurrentEditedCard = CardBrowser.sCardBrowserCard;
                 if (mCurrentEditedCard == null) {
@@ -989,8 +968,7 @@ private void closeNoteEditor(int result, Intent intent) {
             setResult(result);
         }
 
-        if (mCaller == CALLER_CARDEDITOR_INTENT_ADD || mCaller == CALLER_BIGWIDGET_EDIT
-                || mCaller == CALLER_BIGWIDGET_ADD) {
+        if (mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
             finishWithAnimation(ActivityTransitionAnimation.FADE);
         } else if (mCaller == CALLER_INDICLASH) {
             finishWithAnimation(ActivityTransitionAnimation.NONE);
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
index b28fa603356b..e147f26235b3 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
@@ -341,7 +341,7 @@ protected void onStop() {
 
         if (!isFinishing()) {
             if (colIsOpen() && mSched != null) {
-                WidgetStatus.update(this, mSched.progressToday(null, mCurrentCard, true));
+                WidgetStatus.update(this);
             }
         }
         UIUtils.saveCollectionInBackground(this);
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/PopupMenuWithIcons.java b/AnkiDroid/src/main/java/com/ichi2/anki/widgets/PopupMenuWithIcons.java
similarity index 97%
rename from AnkiDroid/src/main/java/com/ichi2/widget/PopupMenuWithIcons.java
rename to AnkiDroid/src/main/java/com/ichi2/anki/widgets/PopupMenuWithIcons.java
index b4557739d494..5521aa506700 100644
--- a/AnkiDroid/src/main/java/com/ichi2/widget/PopupMenuWithIcons.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/widgets/PopupMenuWithIcons.java
@@ -1,4 +1,4 @@
-package com.ichi2.widget;
+package com.ichi2.anki.widgets;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Sched.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Sched.java
index 3a76e9974bf3..3c30a232a4ff 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Sched.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Sched.java
@@ -27,7 +27,6 @@
 import android.text.SpannableStringBuilder;
 import android.text.TextUtils;
 import android.text.style.StyleSpan;
-import android.util.Pair;
 
 import com.ichi2.anki.R;
 import com.ichi2.libanki.hooks.Hooks;
@@ -49,7 +48,6 @@
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Locale;
-import java.util.Map;
 import java.util.Random;
 
 import timber.log.Timber;
@@ -93,7 +91,6 @@ public class Sched {
     private LinkedList<Long> mRevDids;
 
     // Not in libanki
-    private HashMap<Long, Pair<String[], long[]>> mCachedDeckCounts;
     private WeakReference<Activity> mContextReference;
 
     /**
@@ -1852,7 +1849,7 @@ private boolean _resched(Card card) {
      * This function uses GregorianCalendar so as to be sensitive to leap years, daylight savings, etc.
      */
 
-    public void _updateCutoff() {
+    private void _updateCutoff() {
         int oldToday = mToday;
         // days since col created
         mToday = (int) ((Utils.now() - mCol.getCrt()) / 86400);
@@ -2392,102 +2389,6 @@ public int matureCount() {
     }
 
 
-    /** returns today's progress
-     *
-     * @param counts (if empty, cached version will be used if any)
-     * @param card
-     * @return [progressCurrentDeck, progressAllDecks, leftCards, eta]
-     */
-    public float[] progressToday(List<DeckDueTreeNode> counts, Card card, boolean eta) {
-        try {
-            int doneCurrent = 0;
-            int[] leftCurrent = new int[]{0, 0, 0};
-            String[] cs = new String[]{"new", "lrn", "rev"};
-            long currentDid = 0;
-
-            // current selected deck
-            if (counts == null) {
-                JSONObject deck = mCol.getDecks().current();
-                currentDid = deck.getLong("id");
-                for (String s : cs) {
-                    doneCurrent += deck.getJSONArray(s + "Today").getInt(1);
-                }
-                if (card != null) {
-                    int idx = countIdx(card);
-                    leftCurrent[idx] += idx == 1 ? card.getLeft() / 1000 : 1;
-                } else {
-                    reset();
-                }
-                leftCurrent[0] += mNewCount;
-                leftCurrent[1] += mLrnCount;
-                leftCurrent[2] += mRevCount;
-            }
-
-            // refresh deck progresses with fresh counts if necessary
-            if (counts != null || mCachedDeckCounts == null) {
-                if (mCachedDeckCounts == null) {
-                    mCachedDeckCounts = new HashMap<Long, Pair<String[], long[]>>();
-                }
-                mCachedDeckCounts.clear();
-                if (counts == null) {
-                    // reload counts
-                    counts = deckDueList();
-                }
-                for (DeckDueTreeNode d : counts) {
-                    int done = 0;
-                    JSONObject deck = mCol.getDecks().get(d.did);
-                    for (String s : cs) {
-                        done += deck.getJSONArray(s + "Today").getInt(1);
-                    }
-                    mCachedDeckCounts.put(d.did, new Pair<String[], long[]> (d.names, new long[]{done, d.newCount, d.lrnCount, d.revCount}));
-                }
-            }
-
-            int doneAll = 0;
-            int[] leftAll = new int[]{0, 0, 0};
-            for (Map.Entry<Long, Pair<String[], long[]>> d : mCachedDeckCounts.entrySet()) {
-                boolean exclude = d.getKey() == currentDid; // || mCol.getDecks().isDyn(d.getKey());
-                if (d.getValue().first.length == 1) {
-                    if (exclude) {
-                        // don't count cached version of current deck
-                        continue;
-                    }
-                    long[] c = d.getValue().second;
-                    doneAll += c[0];
-                    leftAll[0] += c[1];
-                    leftAll[1] += c[2];
-                    leftAll[2] += c[3];
-                } else if (exclude) {
-                    // exclude cached values for current deck in order to avoid double count
-                    long[] c = d.getValue().second;
-                    doneAll -= c[0];
-                    leftAll[0] -= c[1];
-                    leftAll[1] -= c[2];
-                    leftAll[2] -= c[3];
-                }
-            }
-            doneAll += doneCurrent;
-            leftAll[0] += leftCurrent[0];
-            leftAll[1] += leftCurrent[1];
-            leftAll[2] += leftCurrent[2];
-            int totalAll = doneAll + leftAll[0] + leftAll[1] + leftAll[2];
-            int totalCurrent = doneCurrent + leftCurrent[0] + leftCurrent[1] + leftCurrent[2];
-
-            float progressCurrent = -1;
-            if (totalCurrent != 0) {
-                progressCurrent = (float) doneCurrent / (float) totalCurrent;
-            }
-            float progressTotal = -1;
-            if (totalAll != 0) {
-                progressTotal = (float) doneAll / (float) totalAll;
-            }
-            return new float[]{ progressCurrent, progressTotal, totalAll - doneAll, eta ? eta(leftAll, false) : -1};
-        } catch (JSONException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-
     public int eta(int[] counts) {
         return eta(counts, true);
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetBig.java b/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetBig.java
deleted file mode 100644
index cfe348836f9b..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ /dev/null
@@ -1,1136 +0,0 @@
-///***************************************************************************************
-// * This program is free software; you can redistribute it and/or modify it under        *
-// * the terms of the GNU General Public License as published by the Free Software        *
-// * Foundation; either version 3 of the License, or (at your option) any later           *
-// * version.                                                                             *
-// *                                                                                      *
-// * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
-// * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
-// * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
-// *                                                                                      *
-// * You should have received a copy of the GNU General Public License along with         *
-// * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
-// ****************************************************************************************/
-//
-//package com.ichi2.widget;
-//
-//import org.json.JSONException;
-//
-//import com.ichi2.anki.AnkiDroidApp;
-//import com.ichi2.anki.DeckPicker;
-//import com.ichi2.anki2.R;
-//import com.ichi2.async.DeckTask;
-//import com.ichi2.libanki.Card;
-//import com.ichi2.libanki.Utils;
-//
-//import android.app.PendingIntent;
-//import android.app.Service;
-//import android.appwidget.AppWidgetManager;
-//import android.appwidget.AppWidgetProvider;
-//import android.content.ComponentName;
-//import android.content.Context;
-//import android.content.Intent;
-//import android.content.ServiceConnection;
-//import android.content.SharedPreferences;
-//import android.content.res.Resources;
-//import android.graphics.Color;
-//import android.os.AsyncTask;
-//import android.os.IBinder;
-//import android.text.Html;
-//import android.text.SpannableString;
-//import android.text.SpannableStringBuilder;
-//import android.text.Spanned;
-//import android.text.style.ForegroundColorSpan;
-//import android.text.style.UnderlineSpan;
-//
-//import android.view.View;
-//import android.widget.RemoteViews;
-//
-//public class AnkiDroidWidgetBig extends AppWidgetProvider {
-//
-//    private static Context sContext;
-//
-//    private static WidgetContentService contentService = null;
-//    private static WidgetContentService.WidgetContentBinder contentServiceBinder;
-//    private static Intent tempIntent;
-//
-//    private static ServiceConnection localServiceConnection = new ServiceConnection() {
-//
-//        @Override
-//        public void onServiceConnected(ComponentName className, IBinder binder) {
-//            Timber.i("binding content service - success");
-//            contentServiceBinder = (WidgetContentService.WidgetContentBinder) binder;
-//            contentService = contentServiceBinder.getService();
-//            // check, if card is still the same after reloading the deck. If not, show question instead of answering
-//            if (tempIntent.getAction().startsWith(UpdateService.ACTION_ANSWER)
-//                    && contentService.mCurrentCard != null
-//                    && AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getLong(
-//                            "lastWidgetCard", 0) != contentService.mCurrentCard.getId()) {
-//                tempIntent.setAction(UpdateService.ACTION_UPDATE);
-//                tempIntent.putExtra(UpdateService.EXTRA_VIEW, UpdateService.VIEW_SHOW_QUESTION);
-//            }
-//            sContext.startService(tempIntent);
-//            tempIntent = null;
-//        }
-//
-//
-//        @Override
-//        public void onServiceDisconnected(ComponentName arg0) {
-//            contentService = null;
-//        }
-//    };
-//
-//
-//    @Override
-//    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-//        Timber.i("BigWidget: onUpdate");
-//        WidgetStatus.update(context);
-//    }
-//
-//
-//    @Override
-//    public void onEnabled(Context context) {
-//        super.onEnabled(context);
-//        Timber.i("BigWidget: Widget enabled");
-//        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-//        if (!preferences.getBoolean("widgetBigEnabled", false)) {
-//            // show info dialog
-//            Intent intent;
-//            intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-//            intent.setAction(UpdateService.ACTION_SHOW_RESTRICTIONS_DIALOG);
-//            context.startService(intent);
-//        }
-//        preferences.edit().putBoolean("widgetBigEnabled", true).commit();
-//        if (contentService != null) {
-//            contentService.mBigCurrentView = UpdateService.VIEW_NOT_SPECIFIED;
-//            contentService.mCol = null;
-//            AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-//                    .putString("lastWidgetDeck", "").commit();
-//            contentService.setCard(null);
-//            contentService.mBigCurrentMessage = null;
-//            contentService.mBigShowProgressDialog = false;
-//            contentService.mTomorrowDues = null;
-//            contentService.mWaitForAsyncTask = false;
-//        }
-//    }
-//
-//
-//    @Override
-//    public void onDisabled(Context context) {
-//        super.onDisabled(context);
-//        Timber.i("BigWidget: Widget disabled");
-//        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-//        preferences.edit().putBoolean("widgetBigEnabled", false).commit();
-//    }
-//
-//
-//    // public static void setDeck(Decks deck) {
-//    // if (contentService != null) {
-//    // contentService.mCol = deck;
-//    // }
-//    // updateWidget(UpdateService.VIEW_NOT_SPECIFIED);
-//    // }
-//
-//    public static void setCard(Card card) {
-//        if (contentService != null && contentService.mCol != null) {
-//            contentService.setCard(card);
-//        }
-//    }
-//
-//
-//    public static Card getCard() {
-//        if (contentService != null) {
-//            return contentService.mCurrentCard;
-//        } else {
-//            return null;
-//        }
-//    }
-//
-//
-//    public static void updateWidget(int view) {
-//        updateWidget(view, false);
-//    }
-//
-//
-//    public static void updateWidget(int view, boolean showProgressDialog) {
-//        AnkiDroidApp
-//                .getInstance()
-//                .getApplicationContext()
-//                .startService(
-//                        getUpdateIntent(AnkiDroidApp.getInstance().getApplicationContext(), view, showProgressDialog));
-//    }
-//
-//
-//    public static Intent getUpdateIntent(Context context, int view, boolean showProgressDialog) {
-//        Intent intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-//        intent.putExtra(UpdateService.EXTRA_VIEW, view);
-//        intent.putExtra(UpdateService.EXTRA_PROGRESSDIALOG, showProgressDialog);
-//        return intent.setAction(UpdateService.ACTION_UPDATE);
-//    }
-//
-//    public static class UpdateService extends Service {
-//        public static final String ACTION_NOTHING = "org.ichi2.anki.AnkiDroidWidgetBig.NOTHING";
-//        public static final String ACTION_OPENDECK = "org.ichi2.anki.AnkiDroidWidgetBig.OPENDECK";
-//        public static final String ACTION_OPENCOLLECTION = "org.ichi2.anki.AnkiDroidWidgetBig.OPENCOLLECTION";
-//        public static final String ACTION_CLOSEDECK = "org.ichi2.anki.AnkiDroidWidgetBig.CLOSEDECK";
-//        public static final String ACTION_ANSWER = "org.ichi2.anki.AnkiDroidWidgetBig.ANSWER";
-//        public static final String ACTION_OPEN = "org.ichi2.anki.AnkiDroidWidgetBig.OPEN";
-//        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidgetBig.UPDATE";
-//        public static final String ACTION_BURY_CARD = "org.ichi2.anki.AnkiDroidWidgetBig.BURYCARD";
-//        public static final String ACTION_UNDO = "org.ichi2.anki.AnkiDroidWidgetBig.UNDO";
-//        public static final String ACTION_CARDEDITOR = "org.ichi2.anki.AnkiDroidWidgetBig.CARDEDITOR";
-//        public static final String ACTION_FACTADDER = "org.ichi2.anki.AnkiDroidWidgetBig.FACTADDER";
-//        public static final String ACTION_HELP = "org.ichi2.anki.AnkiDroidWidgetBig.HELP";
-//        public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
-//        public static final String ACTION_LEARN_MORE = "org.ichi2.anki.AnkiDroidWidgetBig.LEARNMORE";
-//        public static final String ACTION_REVIEW_EARLY = "org.ichi2.anki.AnkiDroidWidgetBig.REVIEWEARLY";
-//        public static final String ACTION_SHOW_TOMORROW_DUES = "org.ichi2.anki.AnkiDroidWidgetBig.TOMORROWDUES";
-//
-//        public static final String EXTRA_EASE = "ease";
-//        public static final String EXTRA_VIEW = "view";
-//        public static final String EXTRA_PROGRESSDIALOG = "progressDialog";
-//
-//        public static final int VIEW_ACTION_DEFAULT = 0;
-//        public static final int VIEW_ACTION_SHOW_PROGRESS_DIALOG = 1;
-//        public static final int VIEW_ACTION_HIDE_BUTTONS = 2;
-//
-//        public static final int VIEW_NOT_SPECIFIED = 0;
-//        public static final int VIEW_DECKS = 1;
-//        public static final int VIEW_CONGRATS = 2;
-//        public static final int VIEW_SHOW_QUESTION = 3;
-//        public static final int VIEW_SHOW_ANSWER = 4;
-//        public static final int VIEW_NOTHING_DUE = 5;
-//        public static final int VIEW_SHOW_HELP = 6;
-//
-//        private static final int sColorBlue = Color.parseColor("#000099");
-//        private static final int sColorRed = Color.parseColor("#990000");
-//        private static final int sColorGreen = Color.parseColor("#007700");
-//
-//
-//        private CharSequence getDeckStatusString(Card card) {
-//            int[] counts = contentService.mCol.getSched().counts(card);
-//            return getDeckStatusString(counts[0], counts[1], counts[2], card);
-//        }
-//
-//
-//        private CharSequence getDeckStatusString(int newCount, int lrnCount, int dueCount, Card card) {
-//            SpannableStringBuilder sb = new SpannableStringBuilder();
-//
-//            SpannableString red = new SpannableString(Integer.toString(newCount));
-//            red.setSpan(new ForegroundColorSpan(sColorBlue), 0, red.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//            if (card != null && card.getType() == Card.TYPE_NEW) {
-//                red.setSpan(new UnderlineSpan(), 0, red.length(), 0);
-//            }
-//
-//            SpannableString black = new SpannableString(Integer.toString(lrnCount));
-//            black.setSpan(new ForegroundColorSpan(sColorRed), 0, black.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//            if (card != null && card.getType() == Card.TYPE_LRN) {
-//                black.setSpan(new UnderlineSpan(), 0, black.length(), 0);
-//            }
-//
-//            SpannableString blue = new SpannableString(Integer.toString(dueCount));
-//            blue.setSpan(new ForegroundColorSpan(sColorGreen), 0, blue.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//            if (card != null && card.getType() == Card.TYPE_REV) {
-//                blue.setSpan(new UnderlineSpan(), 0, blue.length(), 0);
-//            }
-//
-//            sb.append(red);
-//            sb.append(" ");
-//            sb.append(black);
-//            sb.append(" ");
-//            sb.append(blue);
-//
-//            return sb;
-//        }
-//
-//
-//        private CharSequence getNextTimeString(Card card) {
-//            SpannableStringBuilder sb = new SpannableStringBuilder();
-//
-//            SpannableString again = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 1));
-//            SpannableString hard = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 2));
-//            SpannableString easy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 3));
-//            SpannableString veryEasy = null;
-//
-//            again.setSpan(new ForegroundColorSpan(sColorRed), 0, again.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//
-//            if (contentService.mCol.getSched().answerButtons(card) == 3) {
-//                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
-//                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-//                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//            } else {
-//                hard.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-//                        hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//                easy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_green)), 0,
-//                        easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//
-//                veryEasy = new SpannableString(contentService.mCol.getSched().nextIvlStr(card, 4));
-//                veryEasy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0,
-//                        veryEasy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-//            }
-//
-//            sb.append(again);
-//            sb.append(" \u2027 ");
-//            sb.append(hard);
-//            sb.append(" \u2027 ");
-//            sb.append(easy);
-//            if (contentService.mCol.getSched().answerButtons(card) == 4) {
-//                sb.append(" \u2027 ");
-//                sb.append(veryEasy);
-//            }
-//
-//            return sb;
-//        }
-//
-//        private DeckTask.TaskListener mOpenCollectionHandler = new DeckTask.TaskListener() {
-//            @Override
-//            public void onPreExecute() {
-//                showProgressDialog();
-//            }
-//
-//
-//            @Override
-//            public void onProgressUpdate(DeckTask.TaskData... values) {
-//                String message = values[0].getString();
-//                if (message != null) {
-//                    contentService.mBigCurrentMessage = message;
-//                }
-//                updateViews();
-//            }
-//
-//
-//            @Override
-//            public void onPostExecute(DeckTask.TaskData result) {
-//                contentService.mCol = result.getCol();
-//                if (contentService.mCol != null) {
-//                    showDeckSelectionDialog();
-//                } else {
-//                    handleError();
-//                }
-//            }
-//        };
-//
-//        private DeckTask.TaskListener mOpenDeckHandler = new DeckTask.TaskListener() {
-//            @Override
-//            public void onPreExecute() {
-//                showProgressDialog();
-//            }
-//
-//
-//            @Override
-//            public void onProgressUpdate(DeckTask.TaskData... values) {
-//            }
-//
-//
-//            @Override
-//            public void onPostExecute(DeckTask.TaskData result) {
-//                contentService.setCard();
-//                contentService.mBigShowProgressDialog = false;
-//                contentService.mBigCurrentMessage = null;
-//                updateViews(VIEW_SHOW_QUESTION);
-//            }
-//        };
-//
-//        private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
-//            @Override
-//            public void onPreExecute() {
-//                showProgressDialog();
-//            }
-//
-//
-//            @Override
-//            public void onProgressUpdate(DeckTask.TaskData... values) {
-//                contentService.setCard(values[0].getCard());
-//                int leech = values[0].getInt();
-//                if (leech > 0) {
-//                    String leechMessage;
-//                    if (leech == 2) {
-//                        contentService.mBigCurrentMessage = getResources().getString(
-//                                R.string.leech_suspend_notification);
-//                    } else {
-//                        contentService.mBigCurrentMessage = getResources().getString(R.string.leech_notification);
-//                    }
-//                } else {
-//                    contentService.mBigCurrentMessage = null;
-//                }
-//                contentService.mBigShowProgressDialog = false;
-//                updateViews(VIEW_SHOW_QUESTION);
-//                // TODO: do not reload all counts
-//                WidgetStatus.update(UpdateService.this);
-//            }
-//
-//
-//            @Override
-//            public void onPostExecute(DeckTask.TaskData result) {
-//                if (!result.getBoolean()) {
-//                    handleError();
-//                }
-//            }
-//        };
-//
-//        private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
-//            @Override
-//            public void onPreExecute() {
-//                showProgressDialog();
-//            }
-//
-//
-//            @Override
-//            public void onProgressUpdate(DeckTask.TaskData... values) {
-//                contentService.setCard(values[0].getCard());
-//                contentService.mBigShowProgressDialog = false;
-//                contentService.mBigCurrentMessage = null;
-//                updateViews(VIEW_SHOW_QUESTION);
-//            }
-//
-//
-//            @Override
-//            public void onPostExecute(DeckTask.TaskData result) {
-//                if (!result.getBoolean()) {
-//                    handleError();
-//                    return;
-//                }
-//                String str = result.getString();
-//                if (str != null) {
-//                    // if (str.equals(Decks.UNDO_TYPE_SUSPEND_CARD)) {
-//                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_unsuspended);
-//                    // } else if (str.equals("redo suspend")) {
-//                    // contentService.mBigCurrentMessage = getResources().getString(R.string.card_suspended);
-//                    // }
-//                }
-//                updateViews();
-//                // WidgetStatus.update(UpdateService.this, WidgetStatus.getDeckStatus(contentService.mCol), false);
-//            }
-//        };
-//
-//        private DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
-//            @Override
-//            public void onPreExecute() {
-//                showProgressDialog();
-//            }
-//
-//
-//            @Override
-//            public void onProgressUpdate(DeckTask.TaskData... values) {
-//            }
-//
-//
-//            @Override
-//            public void onPostExecute(DeckTask.TaskData result) {
-//                contentService.mCol = null;
-//                AnkiDroidApp.getSharedPrefs(UpdateService.this.getBaseContext()).edit().putString("lastWidgetDeck", "")
-//                        .commit();
-//                contentService.setCard(null);
-//                contentService.mBigShowProgressDialog = false;
-//                contentService.mBigCurrentMessage = null;
-//                updateViews(VIEW_DECKS);
-//            }
-//        };
-//
-//
-//        @Override
-//        public void onStart(Intent intent, int startId) {
-//            Timber.i("BigWidget: OnStart");
-//
-//            if (intent == null) {
-//                // do nothing
-//            } else if (contentService == null) {
-//                Timber.i("binding content service");
-//                updateViews();
-//                tempIntent = intent;
-//                sContext = this;
-//                Intent contentIntent = new Intent(this, WidgetContentService.class);
-//                this.bindService(contentIntent, localServiceConnection, Context.BIND_AUTO_CREATE);
-//            } else if (intent.getAction() != null) {
-//                String action = intent.getAction();
-//                if (ACTION_NOTHING.equals(action)) {
-//                    // do nothing
-//                } else if (ACTION_UPDATE.equals(action)) {
-//                    if (!contentService.mWaitForAsyncTask) {
-//                        if (!intent.getBooleanExtra(EXTRA_PROGRESSDIALOG, false)) {
-//                            contentService.mBigShowProgressDialog = false;
-//                            updateViews(intent.getIntExtra(EXTRA_VIEW, VIEW_NOT_SPECIFIED));
-//                        } else if (!contentService.mBigShowProgressDialog) {
-//                            showProgressDialog();
-//                        }
-//                    }
-//                } else if (ACTION_OPENCOLLECTION.equals(action)) {
-//                    showProgressDialog();
-//                    if (contentService.mCol == null) {
-//                        contentService.mBigCurrentMessage = getResources().getString(R.string.open_collection);
-//                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler,
-//                                new DeckTask.TaskData(AnkiDroidApp.getCollectionPath()));
-//                        updateViews();
-//                    } else {
-//                        showDeckSelectionDialog();
-//                    }
-//                } else if (ACTION_OPENDECK.equals(action)) {
-//                    showProgressDialog();
-//                    if (contentService != null) {
-//                        contentService.mCol.getDecks().select(intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1));
-//                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_VALUES_FROM_DECK, mOpenDeckHandler,
-//                                new DeckTask.TaskData(contentService.mCol.getSched(), true));
-//                    }
-//                } else if (ACTION_CLOSEDECK.equals(action)) {
-//                    // if (contentService.mCol != null) {
-//                    // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new
-//                    // DeckTask.TaskData(contentService.mCol.getDeckPath()));
-//                    // } else {
-//                    updateViews(VIEW_DECKS);
-//                    // }
-//                } else if (ACTION_UNDO.equals(action)) {
-//                    if (contentService.mCol != null) {
-//                        if (contentService.mCol.undoAvailable()) {
-//                            // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new
-//                            // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard != null ?
-//                            // contentService.mCurrentCard.getId() : 0, true));
-//                        }
-//                    } else {
-//                        updateViews(VIEW_DECKS);
-//                    }
-//                } else if (ACTION_BURY_CARD.equals(action)) {
-//                    if (contentService.mCol != null) {
-//                        // DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new
-//                        // DeckTask.TaskData(0, contentService.mCol, contentService.mCurrentCard));
-//                    } else {
-//                        updateViews(VIEW_DECKS);
-//                    }
-//                } else if (action.startsWith(ACTION_ANSWER)) {
-//                    int ease = intent.getIntExtra(EXTRA_EASE, 0);
-//                    if (ease == 0) {
-//                        updateViews(VIEW_SHOW_ANSWER);
-//                    } else {
-//                        if (contentService.mCol != null) {
-//                            if (contentService.mCurrentCard.timeTaken() > 12) {
-//                                // assume, user was not learning
-//                                contentService.mCurrentCard.setTimer(Utils.now() - 6);
-//                            }
-//                            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,
-//                                    new DeckTask.TaskData(contentService.mCol.getSched(), contentService.mCurrentCard,
-//                                            ease));
-//                        } else {
-//                            updateViews(VIEW_DECKS);
-//                        }
-//                    }
-//                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
-//                    Intent dialogIntent = new Intent(this, WidgetDialog.class);
-//                    dialogIntent.setAction(WidgetDialog.ACTION_SHOW_RESTRICTIONS_DIALOG);
-//                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-//                    this.startActivity(dialogIntent);
-//                } else if (ACTION_OPEN.equals(action)) {
-//                    // String deckpath = intent.getStringExtra(EXTRA_DECK_PATH);
-//                    // Intent newIntent = StudyOptions.getLoadDeckIntent(this, deckpath);
-//                    // if (deckpath != null) {
-//                    // DeckManager.getDeck(deckpath, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
-//                    // if (contentService.mBigCurrentView != VIEW_NOTHING_DUE) {
-//                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_REVIEWER);
-//                    // startActivity(newIntent);
-//                    // showProgressDialog();
-//                    // } else {
-//                    // startActivity(newIntent);
-//                    // }
-//                    // } else {
-//                    // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_DECKPICKER);
-//                    // startActivity(newIntent);
-//                    // }
-//                } else if (ACTION_CARDEDITOR.equals(action)) {
-//                    // Intent editIntent = new Intent(this, CardEditor.class);
-//                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-//                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_EDIT);
-//                    // // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
-//                    // this.startActivity(editIntent);
-//                } else if (ACTION_FACTADDER.equals(action)) {
-//                    // Intent editIntent = new Intent(this, CardEditor.class);
-//                    // editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-//                    // editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_ADD);
-//                    // editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mCol.getDeckPath());
-//                    // this.startActivity(editIntent);
-//                } else if (ACTION_HELP.equals(action)) {
-//                    if (contentService.mBigShowProgressDialog) {
-//                        contentService.mBigShowProgressDialog = false;
-//                        updateViews(VIEW_SHOW_HELP);
-//                        contentService.mBigShowProgressDialog = true;
-//                    } else {
-//                        updateViews(VIEW_SHOW_HELP);
-//                    }
-//                } else if (ACTION_LEARN_MORE.equals(action)) {
-//                    // if (contentService.mCol != null) {
-//                    // contentService.mCol.setupLearnMoreScheduler();
-//                    // contentService.mCol.reset();
-//                    // contentService.setCard();
-//                    // contentService.mBigShowProgressDialog = false;
-//                    // contentService.mBigCurrentMessage = null;
-//                    // updateViews(VIEW_SHOW_QUESTION);
-//                    // } else {
-//                    // updateViews(VIEW_DECKS);
-//                    // }
-//                } else if (ACTION_REVIEW_EARLY.equals(action)) {
-//                    // if (contentService.mCol != null) {
-//                    // contentService.mCol.setupReviewEarlyScheduler();
-//                    // contentService.mCol.reset();
-//                    // contentService.setCard();
-//                    // contentService.mBigShowProgressDialog = false;
-//                    // contentService.mBigCurrentMessage = null;
-//                    // updateViews(VIEW_SHOW_QUESTION);
-//                    // } else {
-//                    // updateViews(VIEW_DECKS);
-//                    // }
-//                } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
-//                    if (contentService.mTomorrowDues == null) {
-//                        showProgressDialog();
-//                        contentService.mWaitForAsyncTask = true;
-//                        AsyncTask<String, Void, DeckStatus[]> getTomorrowDuesAsyncTask = new GetTomorrowDueAsyncTask();
-//                        getTomorrowDuesAsyncTask.execute(AnkiDroidApp.getSharedPrefs(
-//                                AnkiDroidWidgetBig.UpdateService.this).getString("deckPath",
-//                                AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
-//                    } else {
-//                        updateViews(VIEW_CONGRATS);
-//                    }
-//                }
-//            }
-//        }
-//
-//
-//        private void handleError() {
-//            // TODO
-//            // Intent newIntent = DeckPicker.getLoadDeckIntent(AnkiDroidWidgetBig.UpdateService.this, 0);
-//            // newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_DB_ERROR);
-//            // startActivity(newIntent);
-//            // contentService.mBigCurrentMessage = null;
-//            // DeckManager.closeDeck(deckPath);
-//            // contentService.mCol = null;
-//            // contentService.setCard(null);
-//            // contentService.mBigShowProgressDialog = false;
-//            // updateViews(VIEW_DECKS);
-//        }
-//
-//
-//        private void showProgressDialog() {
-//            Timber.i("BigWidget: show progress dialog");
-//            contentService.mBigShowProgressDialog = true;
-//            updateViews();
-//        }
-//
-//
-//        private void updateViews(int view) {
-//            if (view != VIEW_NOT_SPECIFIED) {
-//                contentService.mBigCurrentView = view;
-//            }
-//            updateViews();
-//        }
-//
-//
-//        private void updateViews() {
-//            RemoteViews updateViews = buildUpdate(this);
-//
-//            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetBig.class);
-//            AppWidgetManager manager = AppWidgetManager.getInstance(this);
-//            manager.updateAppWidget(thisWidget, updateViews);
-//        }
-//
-//
-//        private synchronized RemoteViews buildUpdate(Context context) {
-//            Resources res = getResources();
-//            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
-//
-//            if (contentService == null) {
-//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
-//                return updateViews;
-//            }
-//
-//            if (contentService.mBigCurrentView == VIEW_NOT_SPECIFIED) {
-//                contentService.mBigCurrentView = VIEW_DECKS;
-//            }
-//
-//            Timber.i("BigWidget: buildUpdate (" + contentService.mBigCurrentView + ")");
-//
-//            if (contentService.mBigCurrentView == VIEW_DECKS || contentService.mBigCurrentView == VIEW_SHOW_HELP
-//                    || contentService.mBigCurrentView == VIEW_CONGRATS) {
-//            } else if (contentService.mCol == null) {
-//                contentService.mBigCurrentView = VIEW_DECKS;
-//            } else if (contentService.mCurrentCard == null) {
-//                contentService.mBigCurrentView = VIEW_NOTHING_DUE;
-//            }
-//
-//            if (contentService.mBigCurrentMessage != null) {
-//                updateViews.setTextViewText(R.id.widget_big_message, contentService.mBigCurrentMessage);
-//            } else {
-//                updateViews.setTextViewText(R.id.widget_big_message, "");
-//            }
-//
-//            if (contentService.mBigShowProgressDialog) {
-//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
-//                return updateViews;
-//            } else {
-//                updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);
-//                updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
-//            }
-//
-//            switch (contentService.mBigCurrentView) {
-//                case VIEW_CONGRATS:
-//                case VIEW_DECKS:
-//                    updateViews.setTextViewText(R.id.widget_big_deckname, "");
-//                    updateCounts(updateViews, contentService.mBigCurrentView);
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_deckfield,
-//                            contentService.mBigCurrentView == VIEW_DECKS ? getTomorrowDuePendingIntent(context)
-//                                    : getUpdatePendingIntent(context, VIEW_DECKS));
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose,
-//                            getShowDeckSelectionPendingIntent(context));
-//                    updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getHelpPendingIntent(this));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
-//                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
-//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.INVISIBLE);
-//                    emptyCardAreaTexts(updateViews);
-//                    removeAreaListeners(this, true);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_add, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_star, View.VISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getOpenPendingIntent(this, 0));
-//                    break;
-//
-//                case VIEW_SHOW_HELP:
-//                    updateViews
-//                            .setOnClickPendingIntent(R.id.widget_big_empty, getUpdatePendingIntent(this, VIEW_DECKS));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-//                    String[] values = res.getStringArray(R.array.gestures_labels);
-//                    updateViews.setTextViewText(R.id.widget_big_topleft, res.getString(R.string.open_in_reviewer));
-//                    updateViews.setTextViewText(R.id.widget_big_middleleft, values[12]);
-//                    updateViews.setTextViewText(R.id.widget_big_bottomleft, values[1]);
-//                    updateViews.setTextViewText(R.id.widget_big_topright, values[9]);
-//                    updateViews.setTextViewText(R.id.widget_big_middleright, values[7]);
-//                    updateViews.setTextViewText(R.id.widget_big_bottomright, values[5]);
-//                    break;
-//
-//                case VIEW_SHOW_QUESTION:
-//                    try {
-//                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
-//                                .getString("name"));
-//                    } catch (JSONException e1) {
-//                        throw new RuntimeException(e1);
-//                    }
-//                    updateCounts(updateViews, contentService.mBigCurrentView);
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
-//                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.VISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getAnswerPendingIntent(context, 0));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
-//                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(this));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 0));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(this));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 0));
-//                    emptyCardAreaTexts(updateViews);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
-//
-//                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
-//                            Html.fromHtml(contentService.mCurrentCard.getQuestion(true)));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
-//                            getFactAdderPendingIntent(context));
-//                    break;
-//
-//                case VIEW_SHOW_ANSWER:
-//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.INVISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, getAnswerPendingIntent(context, 1));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, getAnswerPendingIntent(context, 2));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, getAnswerPendingIntent(context, 3));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_ease4, getAnswerPendingIntent(context, 4));
-//
-//                    updateViews
-//                            .setTextViewText(R.id.widget_big_message, getNextTimeString(contentService.mCurrentCard));
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 1));
-//
-//                    if (contentService.mCol.getSched().answerButtons(contentService.mCurrentCard) == 4) {
-//                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.INVISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.VISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.INVISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.VISIBLE);
-//                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
-//                                getAnswerPendingIntent(this, 3));
-//                    } else {
-//                        updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.VISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.INVISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.VISIBLE);
-//                        updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.INVISIBLE);
-//                        updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright,
-//                                getAnswerPendingIntent(this, 2));
-//                    }
-//
-//                    updateViews.setTextViewText(R.id.widget_big_cardcontent,
-//                            Html.fromHtml(contentService.mCurrentCard.getAnswer(true)));
-//                    break;
-//
-//                case VIEW_NOTHING_DUE:
-//                    try {
-//                        updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mCol.getDecks().current()
-//                                .getString("name"));
-//                    } catch (JSONException e) {
-//                        throw new RuntimeException(e);
-//                    }
-//                    updateCounts(updateViews, contentService.mBigCurrentView);
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
-//                    updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
-//                    getHelpPendingIntent(this).cancel();
-//                    getUpdatePendingIntent(this, VIEW_DECKS).cancel();
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_topleft,
-//                            getOpenPendingIntent(this, contentService.mCol.getDecks().selected()));
-//                    removeAreaListeners(this, false);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
-//                    emptyCardAreaTexts(updateViews);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
-//                    updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
-//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-//
-//                    // TODO
-//                    // int failedCards = contentService.mCol.getFailedDelayedCount();
-//                    // int revCards = contentService.mCol.getNextDueCards(1);
-//                    // int newCards = contentService.mCol.getNextNewCards();
-//                    // int eta = contentService.mCol.getETA(failedCards, revCards, newCards, true);
-//                    // updateViews.setTextViewText(R.id.widget_big_congrats, StudyOptions.getCongratsMessage(this,
-//                    // failedCards, revCards, newCards, eta));
-//
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_review_early,
-//                            getReviewEarlyPendingIntent(context));
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_learn_more, getLearnMorePendingIntent(context));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
-//                    updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right,
-//                            getFactAdderPendingIntent(context));
-//                    break;
-//            }
-//            return updateViews;
-//
-//            // WebView webView = new WebView(this);
-//            // webView.setDrawingCacheEnabled(true);
-//            // webView.layout(0, 0, 500, 500);
-//            // webView.loadDataWithBaseURL("", "asdf", "text/html", "utf-8", null);
-//            // webView.buildDrawingCache(true);
-//            // Bitmap b = Bitmap.createBitmap(webView.getDrawingCache());
-//            // webView.setDrawingCacheEnabled(false); // clear drawing cache
-//            //
-//            // FileOutputStream out;
-//            // try {
-//            // out = new FileOutputStream("/emmc/test.png");
-//            // b.compress(Bitmap.CompressFormat.PNG, 90, out);
-//            // File f = new File("/emmc/test.png");
-//            // Uri uri = Uri.fromFile(f);
-//            // updateViews.setImageViewUri(R.id.widget_big_cardcontent, uri);
-//            // } catch (FileNotFoundException e) {
-//            // // TODO Auto-generated catch block
-//            // e.printStackTrace();
-//            // }
-//        }
-//
-//
-//        private void updateCounts(RemoteViews updateViews, int view) {
-//            int[] counts = WidgetStatus.fetchSmall(this);
-//            int progressTotal = counts[1];
-//            int eta = counts[2];
-//            updateViews.setProgressBar(R.id.widget_big_progress_total, 100, progressTotal, false);
-//            if (eta == 0) {
-//                updateViews.setViewVisibility(R.id.widget_big_eta, View.INVISIBLE);
-//            } else {
-//                updateViews.setViewVisibility(R.id.widget_big_eta, View.VISIBLE);
-//                updateViews.setTextViewText(R.id.widget_big_eta,
-//                        eta > 99 ? "\u2027\u2027\u2027" : Integer.toString(eta));
-//            }
-//
-//            switch (view) {
-//                case VIEW_SHOW_QUESTION:
-//                case VIEW_NOTHING_DUE:
-//                    updateViews.setTextViewText(R.id.widget_big_counts,
-//                            getDeckStatusString(contentService.mCurrentCard));
-//                    double sessionProgress = contentService.mCol.getSched().todaysProgress(contentService.mCurrentCard,
-//                            false, false);
-//                    if (sessionProgress == -1) {
-//                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
-//                    } else {
-//                        updateViews.setProgressBar(R.id.widget_big_progress_deck, 100, (int) (sessionProgress * 100),
-//                                false);
-//                        updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.VISIBLE);
-//                    }
-//                    contentService.mTomorrowDues = null;
-//                    break;
-//
-//                case VIEW_CONGRATS:
-//                    if (contentService.mTomorrowDues != null && contentService.mTomorrowDues.length > 0) {
-//                        updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.VISIBLE);
-//                        setDeckCounts(updateViews, contentService.mTomorrowDues);
-//                    }
-//                    break;
-//
-//                case VIEW_DECKS:
-//                    updateViews.setTextViewText(R.id.widget_big_counts, "");
-//                    updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_deckfield, View.VISIBLE);
-//                    updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
-//
-//                    setDeckCounts(updateViews, WidgetStatus.fetch(this));
-//
-//                    updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
-//                    updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
-//                    updateViews.setTextViewText(R.id.widget_big_decketa,
-//                            "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
-//                    break;
-//            }
-//        }
-//
-//
-//        private void emptyCardAreaTexts(RemoteViews updateViews) {
-//            updateViews.setTextViewText(R.id.widget_big_topleft, "");
-//            updateViews.setTextViewText(R.id.widget_big_middleleft, "");
-//            updateViews.setTextViewText(R.id.widget_big_bottomleft, "");
-//            updateViews.setTextViewText(R.id.widget_big_topright, "");
-//            updateViews.setTextViewText(R.id.widget_big_middleright, "");
-//            updateViews.setTextViewText(R.id.widget_big_bottomright, "");
-//        }
-//
-//
-//        private void removeAreaListeners(Context context, boolean all) {
-//            getBuryCardPendingIntent(context).cancel();
-//            getAnswerPendingIntent(context, 0).cancel();
-//            getAnswerPendingIntent(context, 1).cancel();
-//            getAnswerPendingIntent(context, 2).cancel();
-//            getAnswerPendingIntent(context, 3).cancel();
-//            getCardEditorPendingIntent(context).cancel();
-//            if (all) {
-//                getOpenPendingIntent(context, 0).cancel();
-//                getUndoPendingIntent(context).cancel();
-//            }
-//        }
-//
-//
-//        private void setDeckCounts(RemoteViews updateViews, DeckStatus[] decks) {
-//            StringBuilder namesSb = new StringBuilder();
-//            SpannableStringBuilder duesSb = new SpannableStringBuilder();
-//            int eta = 0;
-//            for (DeckStatus d : decks) {
-//                namesSb.append(d.mDeckName).append("  \n");
-//                duesSb.append(getDeckStatusString(d.mNewCards, d.mLrnCards, d.mDueCards, null)).append("\n");
-//                eta += d.mEta;
-//            }
-//            int pos = namesSb.length() - 1;
-//            if (pos != -1) {
-//                namesSb.delete(pos, pos + 1);
-//            }
-//            pos = duesSb.length() - 1;
-//            if (pos != -1) {
-//                duesSb.delete(pos, pos + 1);
-//            }
-//            if (namesSb.length() == 0 || duesSb.length() == 0) {
-//                updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
-//                // if (!sUpdateStarted) {
-//                // sUpdateStarted = true;
-//                // WidgetStatus.update(sContext);
-//                // }
-//            } else {
-//                // sUpdateStarted = false;
-//            }
-//            updateViews.setTextViewText(R.id.widget_big_decknames, namesSb);
-//            updateViews.setTextViewText(R.id.widget_big_deckdues, duesSb);
-//            updateViews.setTextViewText(R.id.widget_big_decketa,
-//                    "\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
-//        }
-//
-//
-//        private PendingIntent getAnswerPendingIntent(Context context, int ease) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_ANSWER + Integer.toString(ease));
-//            ankiDroidIntent.putExtra(EXTRA_EASE, ease);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getShowDeckSelectionPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_OPENCOLLECTION);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getCloseDeckPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_CLOSEDECK);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getUndoPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_UNDO);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getBuryCardPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_BURY_CARD);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getOpenPendingIntent(Context context, long deckId) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_OPEN);
-//            ankiDroidIntent.putExtra(DeckPicker.EXTRA_DECK_ID, deckId);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
-//        }
-//
-//
-//        private PendingIntent getLearnMorePendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_LEARN_MORE);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getReviewEarlyPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_REVIEW_EARLY);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getCardEditorPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_CARDEDITOR);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getFactAdderPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_FACTADDER);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getHelpPendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_HELP);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getTomorrowDuePendingIntent(Context context) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_SHOW_TOMORROW_DUES);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-//        }
-//
-//
-//        private PendingIntent getUpdatePendingIntent(Context context, int view) {
-//            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-//            ankiDroidIntent.setAction(ACTION_UPDATE);
-//            ankiDroidIntent.putExtra(EXTRA_VIEW, view);
-//            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
-//        }
-//
-//
-//        private void showDeckSelectionDialog() {
-//            Intent ankiDroidIntent = new Intent(UpdateService.this, WidgetDialog.class);
-//            ankiDroidIntent.setAction(WidgetDialog.ACTION_SHOW_DECK_SELECTION_DIALOG);
-//            ankiDroidIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | Intent.FLAG_ACTIVITY_NEW_TASK);
-//            startActivity(ankiDroidIntent);
-//        }
-//
-//
-//        @Override
-//        public IBinder onBind(Intent arg0) {
-//            Timber.i("onBind");
-//            return null;
-//        }
-//
-//        private static class GetTomorrowDueAsyncTask extends AsyncTask<String, Void, DeckStatus[]> {
-//
-//            @Override
-//            protected DeckStatus[] doInBackground(String... params) {
-//                Timber.i("doInBackgroundGetTomorrowDue");
-//                //
-//                // File dir = new File(params[0]);
-//                // File[] fileList = dir.listFiles(new WidgetStatus.AnkiFileFilter());
-//                //
-//                // DeckStatus[] todayDues = WidgetStatus.fetch(sContext);
-//                //
-//                // ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
-//                //
-//                // for (DeckStatus s : todayDues) {
-//                // try {
-//                // Decks deck = DeckManager.getDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
-//                // if (deck != null) {
-//                // int failedCards = deck.getFailedDelayedCount() + s.mFailedCards;
-//                // int dueCards = deck.getNextDueCards(1) + s.mDueCards;
-//                // int newCards = deck.getNextNewCards() + s.mNewCards;
-//                // decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards,
-//                // deck.getETA(failedCards, dueCards, newCards, true), 0));
-//                // }
-//                // DeckManager.closeDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-//                // } catch (RuntimeException e) {
-//                // Timber.e(e, "doInBackgroundGetTomorrowDue: an error occurred");
-//                // }
-//                // }
-//                // return decks.toArray(new DeckStatus[0]);
-//                return null;
-//            }
-//
-//
-//            @Override
-//            protected void onPostExecute(DeckStatus[] status) {
-//                Timber.d("DeckManager.CloseDeckAsyncTask.onPostExecute()");
-//                contentService.mCol = null;
-//                contentService.mCurrentCard = null;
-//                contentService.mBigCurrentMessage = null;
-//                contentService.mWaitForAsyncTask = false;
-//                contentService.mTomorrowDues = status;
-//                if (contentService.mBigShowProgressDialog) {
-//                    contentService.mBigShowProgressDialog = false;
-//                    updateWidget(VIEW_CONGRATS);
-//                }
-//                contentService.mBigShowProgressDialog = false;
-//            }
-//        }
-//    }
-// }
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetMedium.java b/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetMedium.java
deleted file mode 100644
index ecf289397f64..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetMedium.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/***************************************************************************************
- * This program is free software; you can redistribute it and/or modify it under        *
- * the terms of the GNU General Public License as published by the Free Software        *
- * Foundation; either version 3 of the License, or (at your option) any later           *
- * version.                                                                             *
- *                                                                                      *
- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
- *                                                                                      *
- * You should have received a copy of the GNU General Public License along with         *
- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
- ****************************************************************************************/
-
-package com.ichi2.widget;
-
-import android.app.PendingIntent;
-import android.app.Service;
-import android.appwidget.AppWidgetManager;
-import android.appwidget.AppWidgetProvider;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.content.res.Resources;
-import android.graphics.Color;
-import android.os.IBinder;
-import android.text.SpannableString;
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.text.style.ForegroundColorSpan;
-
-import android.view.View;
-import android.widget.RemoteViews;
-
-import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.anki.DeckPicker;
-import com.ichi2.anki.R;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import timber.log.Timber;
-
-public class AnkiDroidWidgetMedium extends AppWidgetProvider {
-
-    private static BroadcastReceiver mMountReceiver = null;
-    private static boolean remounted = false;
-
-
-    @Override
-    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        Timber.d("MediumWidget: onUpdate");
-        WidgetStatus.update(context);
-    }
-
-
-    @Override
-    public void onEnabled(Context context) {
-        super.onEnabled(context);
-        Timber.d("MediumWidget: Widget enabled");
-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-        preferences.edit().putBoolean("widgetMediumEnabled", true).commit();
-    }
-
-
-    @Override
-    public void onDisabled(Context context) {
-        super.onDisabled(context);
-        Timber.d("MediumWidget: Widget disabled");
-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-        preferences.edit().putBoolean("widgetMediumEnabled", false).commit();
-    }
-
-    public static class UpdateService extends Service {
-        /** If this action is used when starting the service, it will move to the next due deck. */
-        private static final String ACTION_NEXT = "org.ichi2.anki.AnkiDroidWidget.NEXT";
-
-        /**
-         * If this action is used when starting the service, it will move to the previous due deck.
-         */
-        private static final String ACTION_PREV = "org.ichi2.anki.AnkiDroidWidget.PREV";
-
-        /**
-         * When received, this action is ignored by the service.
-         * <p>
-         * It is used to associate with elements that at some point need to have a pending intent associated with them,
-         * but want to clear it off afterwards.
-         */
-        private static final String ACTION_IGNORE = "org.ichi2.anki.AnkiDroidWidget.IGNORE";
-
-        /**
-         * If this action is used when starting the service, it will open the current due deck.
-         */
-        private static final String ACTION_OPEN = "org.ichi2.anki.AnkiDroidWidget.OPEN";
-
-        /**
-         * Update the state of the widget.
-         */
-        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidget.UPDATE";
-
-        /**
-         * The current due deck that is shown in the widget.
-         * <p>
-         * This value is kept around until as long as the service is running and it is shared by all instances of the
-         * widget.
-         */
-        private int currentDueDeck = 0;
-
-        /** The cached information about the decks with due cards. */
-        private List<DeckStatus> dueDecks;
-        /** The cached number of total due cards. */
-        private int dueCardsCount;
-
-
-        private CharSequence getDeckStatusString(DeckStatus deck) {
-            SpannableStringBuilder sb = new SpannableStringBuilder();
-
-            SpannableString red = new SpannableString(Integer.toString(deck.mLrnCards));
-            red.setSpan(new ForegroundColorSpan(Color.RED), 0, red.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-
-            SpannableString black = new SpannableString(Integer.toString(deck.mDueCards));
-            black.setSpan(new ForegroundColorSpan(Color.BLACK), 0, black.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-
-            SpannableString blue = new SpannableString(Integer.toString(deck.mNewCards));
-            blue.setSpan(new ForegroundColorSpan(Color.BLUE), 0, blue.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-
-            sb.append(red);
-            sb.append(" ");
-            sb.append(black);
-            sb.append(" ");
-            sb.append(blue);
-
-            return sb;
-        }
-
-
-        @Override
-        public void onStart(Intent intent, int startId) {
-            Timber.i("MediumWidget: OnStart");
-
-            boolean updateDueDecksNow = true;
-            if (intent != null) {
-                // Bound checks will be done when updating the widget below.
-                if (ACTION_NEXT.equals(intent.getAction())) {
-                    currentDueDeck++;
-                    // Do not update the due decks on next action.
-                    // This causes latency.
-                    updateDueDecksNow = false;
-                } else if (ACTION_PREV.equals(intent.getAction())) {
-                    currentDueDeck--;
-                    // Do not update the due decks on prev action.
-                    // This causes latency.
-                    updateDueDecksNow = false;
-                } else if (ACTION_IGNORE.equals(intent.getAction())) {
-                    updateDueDecksNow = false;
-                } else if (ACTION_OPEN.equals(intent.getAction())) {
-                    startActivity(DeckPicker.getLoadDeckIntent(this, intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1)));
-                    updateDueDecksNow = false;
-                } else if (ACTION_UPDATE.equals(intent.getAction())) {
-                    // Updating the widget is done below for all actions.
-                    Timber.d("AnkiDroidWidget.UpdateService: UPDATE");
-                }
-            }
-            RemoteViews updateViews = buildUpdate(this, updateDueDecksNow);
-
-            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetMedium.class);
-            AppWidgetManager manager = AppWidgetManager.getInstance(this);
-            manager.updateAppWidget(thisWidget, updateViews);
-        }
-
-
-        private RemoteViews buildUpdate(Context context, boolean updateDueDecksNow) {
-            Timber.d("MediumWidget: buildUpdate");
-
-            // Resources res = context.getResources();
-            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget);
-
-            // Add a click listener to open Anki from the icon.
-            // This should be always there, whether there are due cards or not.
-            Intent ankiDroidIntent = new Intent(context, DeckPicker.class);
-            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
-            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
-            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, 0);
-            updateViews.setOnClickPendingIntent(R.id.anki_droid_logo, pendingAnkiDroidIntent);
-
-            if (!AnkiDroidApp.isSdCardMounted()) {
-                updateViews.setTextViewText(R.id.anki_droid_title, context.getText(R.string.sdcard_missing_message));
-                updateViews.setTextViewText(R.id.anki_droid_name, "");
-                updateViews.setTextViewText(R.id.anki_droid_status, "");
-                if (mMountReceiver == null) {
-                    mMountReceiver = new BroadcastReceiver() {
-                        @Override
-                        public void onReceive(Context context, Intent intent) {
-                            String action = intent.getAction();
-                            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
-                                Timber.d("mMountReceiver - Action = Media Mounted");
-                                if (remounted) {
-                                    WidgetStatus.update(getBaseContext());
-                                    remounted = false;
-                                    if (mMountReceiver != null) {
-                                        unregisterReceiver(mMountReceiver);
-                                    }
-                                } else {
-                                    remounted = true;
-                                }
-                            }
-                        }
-                    };
-                    IntentFilter iFilter = new IntentFilter();
-                    iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
-                    iFilter.addDataScheme("file");
-                    registerReceiver(mMountReceiver, iFilter);
-                }
-                return updateViews;
-            }
-
-            // If we do not have a cached version, always update.
-            if (dueDecks == null || updateDueDecksNow) {
-                // Build a list of decks with due cards.
-                // Also compute the total number of cards due.
-                updateDueDecks();
-            }
-
-            if (dueCardsCount > 0) {
-                Resources resources = getResources();
-                String decksText = resources
-                        .getQuantityString(R.plurals.widget_decks, dueDecks.size(), dueDecks.size());
-                String text = resources.getQuantityString(R.plurals.widget_cards_in_decks_due, dueCardsCount,
-                        dueCardsCount, decksText);
-                updateViews.setTextViewText(R.id.anki_droid_title, text);
-                // If the current due deck is out of bound, go back to the first one.
-                if (currentDueDeck < 0 || currentDueDeck > dueDecks.size() - 1) {
-                    currentDueDeck = 0;
-                }
-                // Show the name and info from the current due deck.
-                DeckStatus deckStatus = dueDecks.get(currentDueDeck);
-                updateViews.setTextViewText(R.id.anki_droid_name, deckStatus.mDeckName);
-                updateViews.setTextViewText(R.id.anki_droid_status, getDeckStatusString(deckStatus));
-                PendingIntent openPendingIntent = getOpenPendingIntent(context, deckStatus.mDeckId);
-                updateViews.setOnClickPendingIntent(R.id.anki_droid_name, openPendingIntent);
-                updateViews.setOnClickPendingIntent(R.id.anki_droid_status, openPendingIntent);
-                // Enable or disable the prev and next buttons.
-                if (currentDueDeck > 0) {
-                    updateViews.setImageViewResource(R.id.anki_droid_prev, R.drawable.widget_left_arrow);
-                    updateViews.setOnClickPendingIntent(R.id.anki_droid_prev, getPrevPendingIntent(context));
-                } else {
-                    updateViews.setImageViewResource(R.id.anki_droid_prev, R.drawable.widget_left_arrow_disabled);
-                    updateViews.setOnClickPendingIntent(R.id.anki_droid_prev, getIgnoredPendingIntent(context));
-                }
-                if (currentDueDeck < dueDecks.size() - 1) {
-                    updateViews.setImageViewResource(R.id.anki_droid_next, R.drawable.widget_right_arrow);
-                    updateViews.setOnClickPendingIntent(R.id.anki_droid_next, getNextPendingIntent(context));
-                } else {
-                    updateViews.setImageViewResource(R.id.anki_droid_next, R.drawable.widget_right_arrow_disabled);
-                    updateViews.setOnClickPendingIntent(R.id.anki_droid_next, getIgnoredPendingIntent(context));
-                }
-                updateViews.setViewVisibility(R.id.anki_droid_name, View.VISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_status, View.VISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_next, View.VISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_prev, View.VISIBLE);
-            } else {
-                // No card is currently due.
-                updateViews.setTextViewText(R.id.anki_droid_title, context.getString(R.string.widget_no_cards_due));
-                updateViews.setTextViewText(R.id.anki_droid_name, "");
-                updateViews.setTextViewText(R.id.anki_droid_status, "");
-                updateViews.setViewVisibility(R.id.anki_droid_name, View.INVISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_status, View.INVISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_next, View.INVISIBLE);
-                updateViews.setViewVisibility(R.id.anki_droid_prev, View.INVISIBLE);
-            }
-
-            return updateViews;
-        }
-
-
-        private void updateDueDecks() {
-            // Fetch the deck information, sorted by due cards
-            DeckStatus[] decks = WidgetStatus.fetch(getBaseContext());
-
-            if (dueDecks == null) {
-                dueDecks = new ArrayList<DeckStatus>();
-            } else {
-                dueDecks.clear();
-            }
-            dueCardsCount = 0;
-            for (DeckStatus deck : decks) {
-                if (deck.mDueCards + deck.mLrnCards + deck.mNewCards > 0) {
-                    dueCardsCount += deck.mDueCards + deck.mLrnCards + deck.mNewCards;
-                    dueDecks.add(deck);
-                }
-            }
-        }
-
-
-        /**
-         * Returns a pending intent that updates the widget to show the next deck.
-         */
-        private PendingIntent getNextPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_NEXT);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        /**
-         * Returns a pending intent that updates the widget to show the previous deck.
-         */
-        private PendingIntent getPrevPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_PREV);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        /**
-         * Returns a pending intent that is ignored by the service.
-         */
-        private PendingIntent getIgnoredPendingIntent(Context context) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_IGNORE);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
-        }
-
-
-        /**
-         * Returns a pending intent that opens the current deck.
-         */
-        private PendingIntent getOpenPendingIntent(Context context, long deckId) {
-            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_OPEN);
-            ankiDroidIntent.putExtra(DeckPicker.EXTRA_DECK_ID, deckId);
-            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
-        }
-
-
-        @Override
-        public IBinder onBind(Intent arg0) {
-            Timber.d("onBind");
-            return null;
-        }
-    }
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetSmall.java b/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetSmall.java
index e858641ba035..378a3480060b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetSmall.java
+++ b/AnkiDroid/src/main/java/com/ichi2/widget/AnkiDroidWidgetSmall.java
@@ -18,17 +18,13 @@
 import android.app.Service;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetProvider;
-import android.appwidget.AppWidgetProviderInfo;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
-import android.content.res.Configuration;
-import android.os.Bundle;
 import android.os.IBinder;
-
 import android.view.View;
 import android.widget.RemoteViews;
 
@@ -83,8 +79,6 @@ public static class UpdateService extends Service {
         /** The cached number of total due cards. */
         private int dueCardsCount;
 
-        /** Today's total progress */
-        private int progress;
 
         /** The cached estimated reviewing time. */
         private int eta;
@@ -111,7 +105,6 @@ private RemoteViews buildUpdate(Context context, boolean updateDueDecksNow) {
             if (!mounted) {
                 updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
                 updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);
-                updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
                 updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.GONE);
 
                 if (mMountReceiver == null) {
@@ -141,13 +134,10 @@ public void onReceive(Context context, Intent intent) {
             } else {
                 // If we do not have a cached version, always update.
                 if (dueCardsCount == 0 || updateDueDecksNow) {
-                    // Build a list of decks with due cards.
-                    // Also compute the total number of cards due.
+                    // Compute the total number of cards due.
                     int[] counts = WidgetStatus.fetchSmall(context);
-
-                    progress = counts[0];
-                    dueCardsCount = counts[1];
-                    eta = counts[2];
+                    dueCardsCount = counts[0];
+                    eta = counts[1];
                     if (dueCardsCount <= 0) {
                         if (dueCardsCount == 0) {
                             updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.VISIBLE);
@@ -155,13 +145,10 @@ public void onReceive(Context context, Intent intent) {
                             updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);
                         }
                         updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
                     } else {
                         updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);
                         updateViews.setViewVisibility(R.id.widget_due, View.VISIBLE);
-                        updateViews.setViewVisibility(R.id.widget_progress_frame, View.VISIBLE);
                         updateViews.setTextViewText(R.id.widget_due, Integer.toString(dueCardsCount));
-                        updateViews.setProgressBar(R.id.widget_progress, 1000, progress, false);
                     }
                     if (eta <= 0 || dueCardsCount <= 0) {
                         updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/WidgetContentService.java b/AnkiDroid/src/main/java/com/ichi2/widget/WidgetContentService.java
deleted file mode 100644
index 7f5c8c6e6988..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/widget/WidgetContentService.java
+++ /dev/null
@@ -1,91 +0,0 @@
-//
-//package com.ichi2.widget;
-//
-//import com.ichi2.anki.AnkiDroidApp;
-//import com.ichi2.libanki.Card;
-//import com.ichi2.libanki.Collection;
-//
-//import android.app.Service;
-//import android.content.Intent;
-//import android.content.SharedPreferences;
-//import android.os.Binder;
-//import android.os.IBinder;
-//
-//
-//public class WidgetContentService extends Service {
-//    private final IBinder widgetContentBinder = new WidgetContentBinder();
-//
-//    public Collection mCol;
-//    public Card mCurrentCard;
-//    public boolean mBigShowProgressDialog = false;
-//    public int mBigCurrentView = AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED;
-//    public String mBigCurrentMessage;
-//    public DeckStatus[] mTomorrowDues;
-//    public boolean mWaitForAsyncTask = false;
-//    public boolean mUpdateStarted = false;
-//
-//
-//    @Override
-//    public void onCreate() {
-//        super.onCreate();
-//        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
-//        String path = prefs.getString("lastWidgetDeck", "");
-//        if (path != null && path.length() > 0 && AnkiDroidApp.isSdCardMounted()) {
-//            Timber.i("BigWidget: reloading deck " + path);
-//            mCol = Collection.currentCollection();
-//            if (mCol != null) {
-//                mCurrentCard = mCol.getSched().getCard();
-//            }
-//        }
-//    }
-//
-//
-//    @Override
-//    public void onDestroy() {
-//        // // TODO: this does not seem to be reliably called
-//        // String path = "";
-//        long cardId = 0l;
-//        if (mCol != null) {
-//            // path = mLoadedDeck.getDeckPath();
-//            // DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-//            if (mCurrentCard != null) {
-//                cardId = mCurrentCard.getId();
-//            }
-//        }
-//        // PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putString("lastWidgetDeck",
-//        // path).commit();
-//        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-//                .putLong("lastWidgetCard", cardId).commit();
-//    }
-//
-//
-//    public void setCard() {
-//        if (mCol != null) {
-//            setCard(mCol.getSched().getCard());
-//        }
-//    }
-//
-//
-//    public void setCard(Card card) {
-//        mCurrentCard = card;
-//        Long cardId = 0l;
-//        if (card != null) {
-//            cardId = card.getId();
-//        }
-//        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-//                .putLong("lastWidgetCard", cardId).commit();
-//    }
-//
-//
-//    @Override
-//    public IBinder onBind(Intent arg0) {
-//        return widgetContentBinder;
-//    }
-//
-//    public class WidgetContentBinder extends Binder {
-//
-//        WidgetContentService getService() {
-//            return WidgetContentService.this;
-//        }
-//    }
-// }
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/WidgetStatus.java b/AnkiDroid/src/main/java/com/ichi2/widget/WidgetStatus.java
index 5d1f88f4dbc9..311d59867194 100644
--- a/AnkiDroid/src/main/java/com/ichi2/widget/WidgetStatus.java
+++ b/AnkiDroid/src/main/java/com/ichi2/widget/WidgetStatus.java
@@ -17,8 +17,8 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.database.SQLException;
 import android.os.AsyncTask;
+import android.util.Pair;
 
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.CollectionHelper;
@@ -26,7 +26,6 @@
 import com.ichi2.anki.services.NotificationService;
 import com.ichi2.async.BaseAsyncTask;
 import com.ichi2.libanki.Collection;
-import com.ichi2.libanki.Decks;
 import com.ichi2.libanki.Sched;
 
 import java.util.List;
@@ -35,20 +34,11 @@
 
 /**
  * The status of the widget.
- * <p>
- * It contains the status of each of the decks.
  */
 public final class WidgetStatus {
 
-    private static boolean mediumWidget = false;
-    private static boolean smallWidget = false;
-    private static boolean bigWidget = false;
-    private static boolean notification = false;
-
-    private static DeckStatus sDeckStatus;
-    private static float[] sSmallWidgetStatus;
-    private static List<Sched.DeckDueTreeNode> sDeckCounts;
-
+    private static boolean sSmallWidgetEnabled = false;
+    private static boolean sNotificationEnabled = false;
     private static AsyncTask<Context, Void, Context> sUpdateDeckStatusAsyncTask;
 
 
@@ -57,41 +47,14 @@ private WidgetStatus() {
     }
 
 
-    /** Request the widget to update its status. */
+    /**
+     * Request the widget to update its status.
+     */
     public static void update(Context context) {
-        update(context, true, null, null, null);
-    }
-
-
-    /** Request the widget to update its status. */
-    public static void update(Context context, DeckStatus deckStatus) {
-        update(context, true, deckStatus, null, null);
-    }
-
-
-    public static void update(Context context, List<Sched.DeckDueTreeNode> deckCounts) {
-        update(context, true, null, null, deckCounts);
-    }
-
-
-    public static void update(Context context, float[] smallWidgetStatus) {
-        update(context, true, null, smallWidgetStatus, null);
-    }
-
-
-    public static void update(Context context, boolean updateBigWidget, DeckStatus deckStatus,
-            float[] smallWidgetStatus, List<Sched.DeckDueTreeNode> deckCounts) {
-        sDeckStatus = deckStatus;
-        sSmallWidgetStatus = smallWidgetStatus;
-        sDeckCounts = deckCounts;
-
         SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
-        mediumWidget = preferences.getBoolean("widgetMediumEnabled", false);
-        smallWidget = preferences.getBoolean("widgetSmallEnabled", false);
-        bigWidget = updateBigWidget && preferences.getBoolean("widgetBigEnabled", false);
-        notification = Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "1000001")) < 1000000
-                && sDeckStatus == null;
-        if ((mediumWidget || smallWidget || bigWidget || notification)
+        sSmallWidgetEnabled = preferences.getBoolean("widgetSmallEnabled", false);
+        sNotificationEnabled = Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "1000001")) < 1000000;
+        if ((sSmallWidgetEnabled || sNotificationEnabled)
                 && ((sUpdateDeckStatusAsyncTask == null) || (sUpdateDeckStatusAsyncTask.getStatus() == AsyncTask.Status.FINISHED))) {
             Timber.d("WidgetStatus.update(): updating");
             sUpdateDeckStatusAsyncTask = new UpdateDeckStatusAsyncTask();
@@ -102,25 +65,6 @@ public static void update(Context context, boolean updateBigWidget, DeckStatus d
     }
 
 
-    public static void waitToFinish() {
-        try {
-            if ((sUpdateDeckStatusAsyncTask != null)
-                    && (sUpdateDeckStatusAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
-                Timber.i("WidgetStatus: wait to finish");
-                sUpdateDeckStatusAsyncTask.get();
-            }
-        } catch (Exception e) {
-            return;
-        }
-    }
-
-
-    /** Returns the status of each of the decks. */
-    public static DeckStatus[] fetch(Context context) {
-        return MetaDB.getWidgetStatus(context);
-    }
-
-
     /** Returns the status of each of the decks. */
     public static int[] fetchSmall(Context context) {
         return MetaDB.getWidgetSmallStatus(context);
@@ -132,98 +76,20 @@ public static int fetchDue(Context context) {
     }
 
 
-    public static DeckStatus getDeckStatus(Decks deck) {
-        if (deck == null) {
-            return null;
-        }
-        int dueCards = 0;
-        int newCards = 0;
-        // int failedCards = deck.getFailedSoonCount();
-        // int eta = 0;
-        // int reps = deck.getSessionFinishedCards();
-        //
-        //
-        // if(!deck.hasFinishScheduler()) {
-        // dueCards = deck.getRevCount();
-        // newCards = deck.getNewCountToday();
-        // eta = deck.getETA();
-        // }
-        // return new DeckStatus(deck.getDeckPath(), deck.getDeckName(), newCards, dueCards, failedCards, eta, reps);
-        // return new DeckStatus("aaa", "aaa", 1, 1, 1, 1, 1);
-        return null;
-    }
-
     private static class UpdateDeckStatusAsyncTask extends BaseAsyncTask<Context, Void, Context> {
-        private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];
-
-        private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;
-        private static float[] mSmallWidgetStatus = new float[] { 0, 0, 0, 0 };
 
+        // due, eta
+        private static Pair<Integer, Integer> mSmallWidgetStatus;
 
         @Override
         protected Context doInBackground(Context... params) {
             super.doInBackground(params);
             Timber.d("WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()");
             Context context = params[0];
-
             if (!AnkiDroidApp.isSdCardMounted()) {
                 return context;
             }
-
-            // For the deck information
-            // ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
-
-            // if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
-            // decks = new ArrayList<DeckStatus>(mDecks.length);
-            // int dues = 0;
-            // for (DeckStatus m : mDecks) {
-            // if (m.mDeckId == sDeckStatus.mDeckId) {
-            // Timber.i("UpdateWidget - update information for deck " + sDeckStatus.mDeckName);
-            // sDeckStatus.mDeckName = m.mDeckName;
-            // sDeckStatus.mDepth = m.mDepth;
-            // decks.add(sDeckStatus);
-            // } else {
-            // Timber.i("UpdateWidget - copy information for deck " + m.mDeckName);
-            // decks.add(m);
-            // }
-            // }
-            // } else {
-            try {
-                if (sSmallWidgetStatus == null) {
-                    Collection col = CollectionHelper.getInstance().getCol(context);
-                    mSmallWidgetStatus = col.getSched().progressToday(sDeckCounts, null, true);
-                } else {
-                    mSmallWidgetStatus = sSmallWidgetStatus;
-                }
-                // Collection col = Collection.currentCollection();
-                // Object[] di;
-                // float progress;
-                // if (col == null) {
-                // col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
-                // di = col.getSched().deckCounts();
-                // progress = col.getSched().todaysProgress(null, true, true);
-                // col.close(false);
-                // } else {
-                // di = col.getSched().deckCounts();
-                // progress = col.getSched().progressTodayAll(di);
-                // }
-                // int eta = (Integer) di[1];
-                // for (Object[] d : (TreeSet<Object[]>) di[0]) {
-                // String[] sname = (String[]) d[0];
-                // StringBuilder name = new StringBuilder();
-                // name.append(sname[0]);
-                // for (int i = 1; i < sname.length; i++) {
-                // name.append("::").append(sname[i]);
-                // }
-                // decks.add(new DeckStatus((Long) d[1], name.toString(), (Integer) d[2], (Integer) d[3],
-                // (Integer) d[4], (int) (progress * 100), eta));
-                // }
-            } catch (SQLException e) {
-                Timber.w("Widget: Problems on retrieving deck information");
-            }
-            // }
-            //
-            // mDecks = decks.toArray(EMPTY_DECK_STATUS);
+            mSmallWidgetStatus = getCounts(context);
             return context;
         }
 
@@ -233,25 +99,12 @@ protected void onPostExecute(Context context) {
             super.onPostExecute(context);
             Timber.d("WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()");
             MetaDB.storeSmallWidgetStatus(context, mSmallWidgetStatus);
-            // MetaDB.storeWidgetStatus(context, mDecks);
-            // if (mediumWidget) {
-            // Intent intent;
-            // intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
-            // intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
-            // context.startService(intent);
-            // }
-            if (smallWidget) {
+            if (sSmallWidgetEnabled) {
                 Intent intent;
                 intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);
                 context.startService(intent);
             }
-            // if (bigWidget) {
-            // Intent intent;
-            // intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-            // intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
-            // context.startService(intent);
-            // }
-            if (notification) {
+            if (sNotificationEnabled) {
                 Intent intent;
                 intent = new Intent(context, NotificationService.class);
                 context.startService(intent);
@@ -259,29 +112,22 @@ protected void onPostExecute(Context context) {
         }
     }
 
-    // /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
-    // public static class ByDueComparator implements java.util.Comparator<DeckStatus> {
-    // @Override
-    // public int compare(DeckStatus deck1, DeckStatus deck2) {
-    // // Reverse due cards number order
-    // return deck2.mDueCards - deck1.mDueCards;
-    // }
-    // }
-    //
-    //
-    // /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
-    // public static class ByNameComparator implements java.util.Comparator<DeckStatus> {
-    // @Override
-    // public int compare(DeckStatus deck1, DeckStatus deck2) {
-    // return - deck2.mDeckName.compareTo(deck1.mDeckName);
-    // }
-    // }
-    //
-    // /** Filter for Anki files. */
-    // public static final class AnkiFileFilter implements FileFilter {
-    // @Override
-    // public boolean accept(File pathname) {
-    // return pathname.isFile() && pathname.getName().endsWith(".anki");
-    // }
-    // }
+
+    private static Pair<Integer, Integer> getCounts(Context context) {
+        int[] total = {0, 0, 0};
+        Collection col = CollectionHelper.getInstance().getCol(context);
+        // Ensure queues are reset if we cross over to the next day.
+        col.getSched()._checkDay();
+
+        // Only count the top-level decks in the total
+        List<Sched.DeckDueTreeNode> nodes = col.getSched().deckDueTree();
+        for (Sched.DeckDueTreeNode node : nodes) {
+            total[0] += node.newCount;
+            total[1] += node.lrnCount;
+            total[2] += node.revCount;
+        }
+        int due = total[0] + total[1] + total[2];
+        int eta = col.getSched().eta(total, false);
+        return new Pair<>(due, eta);
+    }
 }
diff --git a/AnkiDroid/src/main/res/layout/widget.xml b/AnkiDroid/src/main/res/layout/widget.xml
deleted file mode 100644
index 4240b04c7906..000000000000
--- a/AnkiDroid/src/main/res/layout/widget.xml
+++ /dev/null
@@ -1,110 +0,0 @@
-<RelativeLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-
-    android:id="@+id/ankidroid_widget_layout"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@drawable/widget_bg_normal"
-    android:focusable="false"
-    android:orientation="horizontal" >
-
-    <TextView
-        android:id="@+id/anki_droid_logo"
-        android:layout_width="80dip"
-        android:layout_height="fill_parent"
-        android:layout_alignParentLeft="true"
-        android:background="@drawable/widget_bg_medium"
-        android:focusable="true" />
-
-    <LinearLayout
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
-        android:layout_toRightOf="@+id/anki_droid_logo"
-        android:focusable="false"
-        android:gravity="center"
-        android:orientation="vertical"
-        android:paddingBottom="10dip"
-        android:paddingLeft="0dip"
-        android:paddingRight="11dip"
-        android:paddingTop="10dip" >
-
-        <LinearLayout
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:orientation="vertical" >
-
-            <TextView
-                android:id="@+id/anki_droid_title"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:layout_marginBottom="2dip"
-                android:layout_marginLeft="0dip"
-                android:gravity="center"
-                android:includeFontPadding="false"
-                android:singleLine="true"
-                android:text="@string/widget_loading"
-                android:textColor="#000000"
-                android:textSize="18sp"
-                android:textStyle="bold" />
-
-            <LinearLayout
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:layout_marginLeft="0dip"
-                android:layout_marginRight="2dip"
-                android:focusable="false"
-                android:orientation="horizontal" >
-
-                <ImageView
-                    android:id="@+id/anki_droid_prev"
-                    android:layout_width="wrap_content"
-                    android:layout_height="fill_parent"
-                    android:layout_weight="0"
-                    tools:ignore="ContentDescription" />
-
-                <LinearLayout
-                    android:layout_width="wrap_content"
-                    android:layout_height="fill_parent"
-                    android:layout_weight="1"
-                    android:focusable="false"
-                    android:gravity="center"
-                    android:orientation="vertical" >
-
-                    <TextView
-                        android:id="@+id/anki_droid_name"
-                        android:layout_width="wrap_content"
-                        android:layout_height="wrap_content"
-                        android:layout_marginBottom="1dip"
-                        android:layout_marginTop="1dip"
-                        android:ellipsize="middle"
-                        android:includeFontPadding="false"
-                        android:singleLine="true"
-                        android:text=""
-                        android:textColor="#000000"
-                        android:textSize="18sp" />
-
-                    <TextView
-                        android:id="@+id/anki_droid_status"
-                        android:layout_width="wrap_content"
-                        android:layout_height="wrap_content"
-                        android:layout_marginBottom="1dip"
-                        android:layout_marginTop="1dip"
-                        android:includeFontPadding="false"
-                        android:singleLine="true"
-                        android:text=""
-                        android:textColor="#777777"
-                        android:textSize="14sp" />
-                </LinearLayout>
-
-                <ImageView
-                    android:id="@+id/anki_droid_next"
-                    android:layout_width="wrap_content"
-                    android:layout_height="fill_parent"
-                    android:layout_weight="0"
-                    tools:ignore="ContentDescription" />
-            </LinearLayout>
-        </LinearLayout>
-    </LinearLayout>
-
-</RelativeLayout>
diff --git a/AnkiDroid/src/main/res/layout/widget_small.xml b/AnkiDroid/src/main/res/layout/widget_small.xml
index 925b1945f33e..2c8c2a625970 100644
--- a/AnkiDroid/src/main/res/layout/widget_small.xml
+++ b/AnkiDroid/src/main/res/layout/widget_small.xml
@@ -37,31 +37,6 @@
             android:textSize="18sp"
             android:visibility="invisible" />
 
-        <FrameLayout
-            android:id="@+id/widget_progress_frame"
-            android:layout_width="fill_parent"
-            android:layout_height="5dip"
-            android:layout_alignRight="@+id/widget_due"
-            android:layout_below="@+id/widget_due"
-            android:layout_marginTop="2dip"
-            android:background="#ffffff"
-            android:padding="1dip"
-            android:visibility="invisible" >
-
-            <ProgressBar
-                android:id="@+id/widget_progress"
-                style="@style/Widget.ProgressBar.Horizontal"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent" />
-            <!--
-            <FrameLayout android:id="@+id/widget_progress"
-				android:layout_width="fill_parent"
-				android:layout_alignParentBottom="true"
-				android:layout_height="10dp"
-				android:background="#ff595a"/>
-            -->
-        </FrameLayout>
-
         <TextView
             android:id="@+id/widget_eta"
             android:layout_width="wrap_content"
diff --git a/AnkiDroid/src/main/res/values/styles.xml b/AnkiDroid/src/main/res/values/styles.xml
index 184db2164eaf..aad1942f30bd 100644
--- a/AnkiDroid/src/main/res/values/styles.xml
+++ b/AnkiDroid/src/main/res/values/styles.xml
@@ -7,17 +7,6 @@
     <!-- Theme for crash report dialog -->
     <style name="Theme.CrashReportDialog" parent="@android:style/Theme.Dialog" />
 
-    <!-- Widget elements -->
-    <style name="Widget.ProgressBar.Horizontal" parent="@android:style/Widget.ProgressBar.Horizontal">
-        <item name="android:progressDrawable">@drawable/progress_horizontal</item>
-        <item name="android:orientation">vertical</item>
-    </style>
-
-    <style name="Widget.ProgressBar.BigWidget.Horizontal" parent="@android:style/Widget.ProgressBar.Horizontal">
-        <item name="android:progressDrawable">@drawable/progress_widgetbig_horizontal</item>
-        <item name="android:orientation">vertical</item>
-    </style>
-
     <style name="Animation.Translucent" parent="@android:style/Animation.Translucent">
         <item name="android:windowEnterAnimation">@null</item>
         <item name="android:windowExitAnimation">@anim/translucent_exit</item>
