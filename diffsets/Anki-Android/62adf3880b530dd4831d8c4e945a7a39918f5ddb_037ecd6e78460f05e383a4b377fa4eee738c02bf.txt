diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index 9a0f238beb09..a27bed2079a5 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -822,6 +822,9 @@ open class DeckPicker :
             if (!importResult.isSuccess) {
                 ImportUtils.showImportUnsuccessfulDialog(this, importResult.humanReadableMessage, false)
             }
+        } else if (requestCode == PICK_CSV_FILE && resultCode == RESULT_OK) {
+            ImportUtils.getFileCachedCopy(this, data!!) ?: return
+            showThemedToast(this, "CSV importer is not implemented yet", true)
         }
     }
 
@@ -2691,6 +2694,7 @@ open class DeckPicker :
         const val SHOW_STUDYOPTIONS = 11
         private const val ADD_NOTE = 12
         const val PICK_APKG_FILE = 13
+        const val PICK_CSV_FILE = 14
 
         // For automatic syncing
         // 10 minutes in milliseconds.
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/analytics/UsageAnalytics.kt b/AnkiDroid/src/main/java/com/ichi2/anki/analytics/UsageAnalytics.kt
index fa3ec6415234..d5132cc4a76a 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/analytics/UsageAnalytics.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/analytics/UsageAnalytics.kt
@@ -453,5 +453,8 @@ object UsageAnalytics {
 
         @AnalyticsConstant
         val IMPORT_COLPKG_FILE = "Import COLPKG"
+
+        @AnalyticsConstant
+        val IMPORT_CSV_FILE = "Import CSV"
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/DatabaseErrorDialog.kt b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/DatabaseErrorDialog.kt
index 7e6fc1b8723a..9680133a0eaa 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/DatabaseErrorDialog.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/DatabaseErrorDialog.kt
@@ -219,7 +219,7 @@ class DatabaseErrorDialog : AsyncDialogFragment() {
                     }
                     dialog.title(R.string.backup_restore_select_title)
                         .positiveButton(R.string.restore_backup_choose_another) {
-                            ImportFileSelectionFragment.openImportFilePicker(activity as AnkiActivity)
+                            ImportFileSelectionFragment.openImportFilePicker(activity as AnkiActivity, DeckPicker.PICK_APKG_FILE)
                         }
                         .negativeButton(R.string.dialog_cancel)
                         .listItemsSingleChoice(items = dates.toTypedArray().toList(), waitForPositiveButton = false) { _: MaterialDialog, index: Int, _: CharSequence ->
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/ImportFileSelectionFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/ImportFileSelectionFragment.kt
index 2f4d3f165d5c..83a7e9ed6186 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/ImportFileSelectionFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/ImportFileSelectionFragment.kt
@@ -24,6 +24,7 @@ import com.ichi2.anki.analytics.UsageAnalytics
 import com.ichi2.anki.dialogs.HelpDialog.FunctionItem
 import com.ichi2.annotations.NeedsTest
 import com.ichi2.utils.KotlinCleanup
+import net.ankiweb.rsdroid.BackendFactory
 import timber.log.Timber
 
 @NeedsTest("Selecting APKG allows multiple files")
@@ -37,9 +38,9 @@ class ImportFileSelectionFragment {
             // this needs a deckPicker for now. See use of PICK_APKG_FILE
 
             // This is required for serialization of the lambda
-            class OpenFilePicker(var multiple: Boolean = false) : FunctionItem.ActivityConsumer {
+            class OpenFilePicker(val requestCode: Int, var multiple: Boolean = false, val mimeType: String = "*/*") : FunctionItem.ActivityConsumer {
                 override fun consume(activity: AnkiActivity) {
-                    openImportFilePicker(activity, multiple)
+                    openImportFilePicker(activity, requestCode, multiple, mimeType)
                 }
             }
 
@@ -48,30 +49,40 @@ class ImportFileSelectionFragment {
                     R.string.import_deck_package,
                     R.drawable.ic_manual_black_24dp,
                     UsageAnalytics.Actions.IMPORT_APKG_FILE,
-                    OpenFilePicker(true)
+                    OpenFilePicker(DeckPicker.PICK_APKG_FILE, true)
                 ),
                 FunctionItem(
                     R.string.import_collection_package,
                     R.drawable.ic_manual_black_24dp,
                     UsageAnalytics.Actions.IMPORT_COLPKG_FILE,
-                    OpenFilePicker()
+                    OpenFilePicker(DeckPicker.PICK_APKG_FILE)
                 ),
             )
+            if (!BackendFactory.defaultLegacySchema) {
+                importItems.add(
+                    FunctionItem(
+                        R.string.import_csv,
+                        R.drawable.ic_baseline_description_24,
+                        UsageAnalytics.Actions.IMPORT_CSV_FILE,
+                        OpenFilePicker(DeckPicker.PICK_CSV_FILE, multiple = false, mimeType = "text/plain")
+                    )
+                )
+            }
             return RecursivePictureMenu.createInstance(ArrayList(importItems), R.string.menu_import)
         }
 
         // needs to be static for serialization
         @JvmStatic
-        fun openImportFilePicker(activity: AnkiActivity, multiple: Boolean = false) {
+        fun openImportFilePicker(activity: AnkiActivity, requestCode: Int, multiple: Boolean = false, mimeType: String = "*/*") {
             Timber.d("openImportFilePicker() delegating to file picker intent")
             val intent = Intent(Intent.ACTION_OPEN_DOCUMENT)
             intent.addCategory(Intent.CATEGORY_OPENABLE)
-            intent.type = "*/*"
+            intent.type = mimeType
             intent.putExtra("android.content.extra.SHOW_ADVANCED", true)
             intent.putExtra("android.content.extra.FANCY", true)
             intent.putExtra("android.content.extra.SHOW_FILESIZE", true)
             intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, multiple)
-            activity.startActivityForResultWithoutAnimation(intent, DeckPicker.PICK_APKG_FILE)
+            activity.startActivityForResultWithoutAnimation(intent, requestCode)
         }
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/utils/ImportUtils.kt b/AnkiDroid/src/main/java/com/ichi2/utils/ImportUtils.kt
index ba42144073aa..638c3edd17d5 100644
--- a/AnkiDroid/src/main/java/com/ichi2/utils/ImportUtils.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/utils/ImportUtils.kt
@@ -46,6 +46,7 @@ import java.net.URLEncoder
 import java.util.*
 import java.util.zip.ZipException
 import java.util.zip.ZipInputStream
+import kotlin.collections.ArrayList
 
 object ImportUtils {
     /* A filename should be shortened if over this threshold */
@@ -63,6 +64,13 @@ object ImportUtils {
         return FileImporter().handleFileImport(context, intent)
     }
 
+    /**
+     * Makes a cached copy of the file selected on [intent] and returns its path
+     */
+    fun getFileCachedCopy(context: Context, intent: Intent): String? {
+        return FileImporter().getFileCachedCopy(context, intent)
+    }
+
     @JvmStatic
     fun showImportUnsuccessfulDialog(activity: Activity, errorMessage: String?, exitActivity: Boolean) {
         FileImporter().showImportUnsuccessfulDialog(activity, errorMessage, exitActivity)
@@ -112,35 +120,30 @@ object ImportUtils {
             } catch (e: Exception) {
                 CrashReportService.sendExceptionReport(e, "handleFileImport")
                 Timber.e(e, "failed to handle import intent")
-                ImportResult.fromErrorString(context.getString(R.string.import_error_exception, e.localizedMessage))
+                ImportResult.fromErrorString(context.getString(R.string.import_error_handle_exception, e.localizedMessage))
             }
         }
 
         private fun handleFileImportInternal(context: Context, intent: Intent): ImportResult {
-            if (intent.data == null) {
-                Timber.i("No intent data. Attempting to read clip data.")
-                if (intent.clipData == null ||
-                    intent.clipData!!.itemCount == 0
-                ) {
-                    return ImportResult.fromErrorString(context.getString(R.string.import_error_unhandled_request))
-                }
-                val clipUriList: ArrayList<Uri> = ArrayList()
-                // Iterate over clipUri & create clipUriList
-                // Pass clipUri list.
-                for (i in 0 until intent.clipData!!.itemCount) {
-                    intent.clipData?.getItemAt(i)?.let { clipUriList.add(it.uri) }
-                }
-                return handleContentProviderFile(context, intent, clipUriList)
+            val dataList = getUris(intent)
+            return if (dataList != null) {
+                handleContentProviderFile(context, intent, dataList)
+            } else {
+                ImportResult.fromErrorString(context.getString(R.string.import_error_handle_exception))
             }
+        }
 
-            // If Uri is of scheme which is supported by ContentResolver, read the contents
-            val intentUriScheme = intent.data!!.scheme
-            return if (intentUriScheme == ContentResolver.SCHEME_CONTENT || intentUriScheme == ContentResolver.SCHEME_FILE || intentUriScheme == ContentResolver.SCHEME_ANDROID_RESOURCE) {
-                Timber.i("Attempting to read content from intent.")
-                val intentDataList: ArrayList<Uri> = arrayListOf(intent.data!!)
-                handleContentProviderFile(context, intent, intentDataList)
+        /**
+         * Makes a cached copy of the file selected on [intent] and returns its path
+         */
+        fun getFileCachedCopy(context: Context, intent: Intent): String? {
+            val uri = getUris(intent)?.get(0) ?: return null
+            val filename = ensureValidLength(getFileNameFromContentProvider(context, uri) ?: return null)
+            val tempPath = Uri.fromFile(File(context.cacheDir, filename)).encodedPath!!
+            return if (copyFileToCache(context, uri, tempPath)) {
+                tempPath
             } else {
-                ImportResult.fromErrorString(context.resources.getString(R.string.import_error_unhandled_scheme, intent.data))
+                null
             }
         }
 
@@ -280,9 +283,9 @@ object ImportUtils {
             return MimeTypeMap.getFileExtensionFromUrl(file.toString())
         }
 
-        protected open fun getFileNameFromContentProvider(context: Context, data: Uri?): String? {
+        protected open fun getFileNameFromContentProvider(context: Context, data: Uri): String? {
             var filename: String? = null
-            context.contentResolver.query(data!!, arrayOf(OpenableColumns.DISPLAY_NAME), null, null, null).use { cursor ->
+            context.contentResolver.query(data, arrayOf(OpenableColumns.DISPLAY_NAME), null, null, null).use { cursor ->
                 if (cursor != null && cursor.moveToFirst()) {
                     filename = cursor.getString(0)
                     Timber.d("handleFileImport() Importing from content provider: %s", filename)
@@ -340,6 +343,31 @@ object ImportUtils {
         }
 
         companion object {
+            fun getUris(intent: Intent): ArrayList<Uri>? {
+                if (intent.data == null) {
+                    Timber.i("No intent data. Attempting to read clip data.")
+                    if (intent.clipData == null || intent.clipData!!.itemCount == 0) {
+                        return null
+                    }
+                    val clipUriList: ArrayList<Uri> = ArrayList()
+                    // Iterate over clipUri & create clipUriList
+                    // Pass clipUri list.
+                    for (i in 0 until intent.clipData!!.itemCount) {
+                        intent.clipData?.getItemAt(i)?.let { clipUriList.add(it.uri) }
+                    }
+                    return clipUriList
+                }
+
+                // If Uri is of scheme which is supported by ContentResolver, read the contents
+                val intentUriScheme = intent.data!!.scheme
+                return if (intentUriScheme == ContentResolver.SCHEME_CONTENT || intentUriScheme == ContentResolver.SCHEME_FILE || intentUriScheme == ContentResolver.SCHEME_ANDROID_RESOURCE) {
+                    Timber.i("Attempting to read content from intent.")
+                    arrayListOf(intent.data!!)
+                } else {
+                    null
+                }
+            }
+
             /**
              * Send a Message to AnkiDroidApp so that the DialogMessageHandler shows the Import apkg dialog.
              * @param pathList list of path(s) to apkg file which will be imported
diff --git a/AnkiDroid/src/main/res/values/02-strings.xml b/AnkiDroid/src/main/res/values/02-strings.xml
index b9dd4a493851..3e5c825a7e3e 100644
--- a/AnkiDroid/src/main/res/values/02-strings.xml
+++ b/AnkiDroid/src/main/res/values/02-strings.xml
@@ -161,14 +161,12 @@
     <string name="import_log_insufficient_space_error">There is not enough space to import the package.\nNeeded - %1$s \nAvailable - %2$s.\n\nHaving Trouble? Try to free space on your phone if possible. Alternatively, sync uses less space than import. You may try importing the package with a device with more space (for example Anki Desktop) and then sync it to this device.</string>
     <string name="import_log_file_cache_cleared">Error importing file, likely a cache clear during processing.\nPlease try again</string>
     <string name="import_succeeded_but_check_database">Data import succeeded but post-import cleanup failed. Run check database later. Root cause: %s</string>
-    <string name="import_error_unhandled_request">Unable to process import request</string>
     <string name="import_error_corrupt_zip">The apkg file is corrupt. Please delete and re-download it.\n\nRoot cause: %s</string>
-    <string name="import_error_exception">Failed to import package\n\n%s</string>
+    <string name="import_error_handle_exception">Failed to import file\n\n%s</string>
     <string name="import_error_not_apkg_extension">Filename “%s” doesn’t have .apkg or .colpkg extension</string>
     <string name="import_error_load_imported_database">Anki Database (.anki2) replacements are not yet supported. Please see the manual for replacement instructions.</string>
     <string name="import_error_content_provider">The selected file couldn’t be imported automatically by AnkiDroid. Please see the user manual for how to manually import anki files: \n%s</string>
     <string name="import_error_copy_file_to_cache">copyFileToCache() failed (possibly out of storage space)</string>
-    <string name="import_error_unhandled_scheme">Unhandled import from: “%s”</string>
     <string name="import_error_multiple_colpkg">Multiple colpkg files were selected.</string>
     <string name="import_error_colpkg_apkg">Both apkg &amp; colpkg files were selected at once.</string>
     <string name="import_stats_error">Some errors occurred while importing the following files:\n%s</string>>
diff --git a/AnkiDroid/src/main/res/values/03-dialogs.xml b/AnkiDroid/src/main/res/values/03-dialogs.xml
index 75b774460c28..6cd676b091f8 100644
--- a/AnkiDroid/src/main/res/values/03-dialogs.xml
+++ b/AnkiDroid/src/main/res/values/03-dialogs.xml
@@ -266,7 +266,7 @@
 
     <string name="import_deck_package">Deck package (.apkg)</string>
     <string name="import_collection_package">Collection package (.colpkg)</string>
-
+    <string name="import_csv">Text file (.txt, .csv)</string>
     <!-- Deck selection dialog -->
     <string name="cannot_create_subdeck_for_all_decks">You cannot create a subdeck for all decks</string>
 </resources>
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/analytics/AnalyticsConstantsTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/analytics/AnalyticsConstantsTest.kt
index f3d8122439b5..8a4cc539af68 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/analytics/AnalyticsConstantsTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/analytics/AnalyticsConstantsTest.kt
@@ -67,6 +67,7 @@ object AnalyticsConstantsTest {
         listOfConstantFields.add("Exception Report")
         listOfConstantFields.add("Import APKG")
         listOfConstantFields.add("Import COLPKG")
+        listOfConstantFields.add("Import CSV")
     }
 
     internal val analyticsConstantFields
diff --git a/AnkiDroid/src/test/java/com/ichi2/utils/ImportUtilsTest.kt b/AnkiDroid/src/test/java/com/ichi2/utils/ImportUtilsTest.kt
index 1557c2581f0e..328ba9d16988 100644
--- a/AnkiDroid/src/test/java/com/ichi2/utils/ImportUtilsTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/utils/ImportUtilsTest.kt
@@ -130,7 +130,7 @@ class ImportUtilsTest : RobolectricTest() {
             return true
         }
 
-        override fun getFileNameFromContentProvider(context: Context, data: Uri?): String? {
+        override fun getFileNameFromContentProvider(context: Context, data: Uri): String? {
             return fileName
         }
     }
