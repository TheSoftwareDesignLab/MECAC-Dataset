diff --git a/res/drawable/widget_big_deckfield.9.png b/res/drawable/widget_big_deckfield.9.png
deleted file mode 100644
index 3d4ce88b4452..000000000000
Binary files a/res/drawable/widget_big_deckfield.9.png and /dev/null differ
diff --git a/res/layout/widget_big.xml b/res/layout/widget_big.xml
index bc6402a392d8..20ca204362e4 100644
--- a/res/layout/widget_big.xml
+++ b/res/layout/widget_big.xml
@@ -38,6 +38,7 @@
 			    android:layout_height="wrap_content"
 			    android:orientation="vertical"
 			    android:layout_margin="8dip"
+			    android:clickable="true"
 			    android:layout_gravity="center"
 			    android:background="@drawable/widget_big_deckfield"
 			    android:visibility="invisible">
diff --git a/src/com/ichi2/anki/CardEditor.java b/src/com/ichi2/anki/CardEditor.java
index 3c5897697cbd..ed0348ba2313 100644
--- a/src/com/ichi2/anki/CardEditor.java
+++ b/src/com/ichi2/anki/CardEditor.java
@@ -50,14 +50,12 @@
 
 import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.anim.ViewAnimation;
-import com.ichi2.anki.DeckPicker.AnkiFilter;
 import com.ichi2.anki.Fact.Field;
 import com.ichi2.themes.StyledDialog;
 import com.ichi2.themes.Themes;
 import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
diff --git a/src/com/ichi2/anki/DeckManager.java b/src/com/ichi2/anki/DeckManager.java
index 5962afe223a6..74109ba72eb9 100644
--- a/src/com/ichi2/anki/DeckManager.java
+++ b/src/com/ichi2/anki/DeckManager.java
@@ -87,7 +87,9 @@ public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck,
 			                	deckInformation.mOpenedBy = new ArrayList<Integer>();
 		                	} else {
 			                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
-			                	closingTask.get();
+			                	while (closingTask.getStatus() == AsyncTask.Status.RUNNING) {
+				                	closingTask.get();			                		
+			                	}
 			                	return getDeck(deckpath, setAsMainDeck, doSafetyBackupIfNeeded, requestingActivity, rebuild);
 		                	}
 		                }
@@ -156,10 +158,10 @@ public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck,
 					deck = null;
 		        }
 			}
+		} finally {
 			if (setAsMainDeck && deck != null) {
 				sMainDeckPath = deckpath;
 			}
-		} finally {
 			unlockDeck(deckpath);
 		}
 		return deck;
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
index 898bd56afb51..8487470ffc36 100644
--- a/src/com/ichi2/anki/DeckTask.java
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -362,7 +362,7 @@ private TaskData doInBackgroundLoadDeck(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
 
     	// load deck and set it as main deck
-        Deck deck = DeckManager.getDeck(deckFilename, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+        Deck deck = DeckManager.getDeck(deckFilename, params[0].getBoolean(), DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
         if (deck == null) {
             Log.i(AnkiDroidApp.TAG, "The database " + deckFilename + " could not be opened");
             BackupManager.cleanUpAfterBackupCreation(false);
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 4d4da56331ba..630f943a96c8 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -89,6 +89,7 @@
 import com.ichi2.themes.Themes;
 import com.ichi2.utils.DiffEngine;
 import com.ichi2.utils.RubyParser;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import org.amr.arabic.ArabicUtilities;
@@ -864,6 +865,7 @@ protected void onCreate(Bundle savedInstanceState) {
         if (deck == null) {
             setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
 			finish();
+			return;
         } else {
             mMediaDir = setupMedia(deck);
             restorePreferences();
@@ -1005,9 +1007,13 @@ protected void onStop() {
       if (!isFinishing()) {
           // Save changes
           if (deck != null) {
-	            deck.commitToDB();
+	         	deck.commitToDB();
           }
       }
+      if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
+    	  AnkiDroidWidgetBig.setCard(mCurrentCard);
+    	  AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_SHOW_QUESTION);
+      }
       WidgetStatus.update(this, WidgetStatus.getDeckStatus(deck));
     }
 
@@ -1418,7 +1424,7 @@ private boolean editCard() {
             return false;
         } else {
             Intent editCard = new Intent(Reviewer.this, CardEditor.class);
-            editCard.putExtra(CardEditor.EXTRA_DECKPATH, CardEditor.CALLER_REVIEWER);
+            editCard.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_REVIEWER);
             editCard.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
         	sEditorCard = mCurrentCard;
         	setOutAnimation(true);
@@ -1771,10 +1777,10 @@ private boolean[] postAnswerCard(DeckTask.TaskData... values) {
             setOutAnimation(true);
         } else {
             // session limits not reached, show next card
-            Card newCard = values[0].getCard();
+        	mCurrentCard = values[0].getCard();
 
             // If the card is null means that there are no more cards scheduled for review.
-            if (newCard == null) {
+            if (mCurrentCard == null) {
             	noMoreCards = true;
                 mProgressDialog = ProgressDialog.show(Reviewer.this, "", getResources()
                         .getString(R.string.saving_changes), true);
@@ -1783,7 +1789,6 @@ private boolean[] postAnswerCard(DeckTask.TaskData... values) {
             }
 
             // Start reviewing next card
-            mCurrentCard = newCard;
             if (mPrefWriteAnswers) { //only bother query deck if needed
             	String[] answer = mCurrentCard.getComparedFieldAnswer();
             	comparedFieldAnswer = answer[0];
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 9703c30a592f..19bfd077296c 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -204,6 +204,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     // private boolean deckSelected;
     private boolean mInDeckPicker;
     private boolean mInReviewer;
+    private boolean mStartedByBigWidget = false;
     private String mDeckFilename;
     private int mStartupMode;
     private boolean mSwipeEnabled;
@@ -642,7 +643,10 @@ protected void onCreate(Bundle savedInstanceState) {
 
         Log.i(AnkiDroidApp.TAG, "StudyOptions - OnCreate()");
 
-        if (hasErrorFiles()) {
+        Intent intent = getIntent();
+        mStartedByBigWidget = intent.hasExtra(EXTRA_START_REVIEWER) || intent.hasExtra(EXTRA_START_DECKPICKER);
+
+        if (hasErrorFiles() && !mStartedByBigWidget) {
             Intent i = new Intent(this, Feedback.class);
             startActivityForResult(i, REPORT_ERROR);
         }
@@ -656,16 +660,13 @@ protected void onCreate(Bundle savedInstanceState) {
 
         initAllContentViews();
 
-        boolean startReviewer = false;
-        Intent intent = getIntent();
         if (Intent.ACTION_VIEW.equalsIgnoreCase(intent.getAction())
                 && intent.getDataString() != null) {
             mDeckFilename = Uri.parse(intent.getDataString()).getPath();
             Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from VIEW intent: " + mDeckFilename);
         } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction()) && intent.getBooleanExtra(EXTRA_START_REVIEWER, false)) {
-        	startReviewer = true;
+        	openReviewer();
         } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction()) && intent.getBooleanExtra(EXTRA_START_DECKPICKER, false)) {
-        	mDeckFilename = preferences.getString("deckFilename", null);
         	openDeckPicker();
         } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction()) && intent.hasExtra(EXTRA_DECK)) {
             mDeckFilename = intent.getStringExtra(EXTRA_DECK);
@@ -679,16 +680,13 @@ protected void onCreate(Bundle savedInstanceState) {
             mDeckFilename = preferences.getString("deckFilename", null);
             Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from preferences: " + mDeckFilename);
         }
+
         if (!mSdCardAvailable) {
             showContentView(CONTENT_NO_EXTERNAL_STORAGE);
-        } if (startReviewer) {
-        	mCurrentContentView = CONTENT_STUDY_OPTIONS;
-        	openReviewer();
-        	showContentView();
         } else {
             if (mDeckFilename == null || !new File(mDeckFilename).exists()) {
                 showContentView(CONTENT_NO_DECK);
-            } else if (!mInDeckPicker) {
+            } else if (!mStartedByBigWidget) {
             	if ((showDeckPickerOnStartup()) && (!hasErrorFiles())) {
             		openDeckPicker();
             	} else {
@@ -931,7 +929,7 @@ private void restartApp() {
 
 
     private void openReviewer() {
-    	if (mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) {
+    	if (mStartedByBigWidget || mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) {
     		mInReviewer = true;
     		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
             reviewer.putExtra("deckFilename", mDeckFilename);
@@ -2119,7 +2117,7 @@ public boolean onOptionsItemSelected(MenuItem item) {
 
             case MENU_ADD_FACT:
             	Intent intent = new Intent(StudyOptions.this, CardEditor.class);
-            	intent.putExtra(CardEditor.EXTRA_DECKPATH, CardEditor.CALLER_STUDYOPTIONS);
+            	intent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_STUDYOPTIONS);
             	intent.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
             	startActivityForResult(intent, ADD_FACT);
                 if (getApiLevel() > 4) {
@@ -2261,6 +2259,14 @@ private void syncDeck(String conflictResolution) {
     protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
         super.onActivityResult(requestCode, resultCode, intent);
 
+        if (mStartedByBigWidget && (requestCode == REQUEST_REVIEW || (requestCode == PICK_DECK_REQUEST && resultCode != RESULT_OK))) {
+        	DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+        	finish();
+        	return;
+        } else {
+        	mStartedByBigWidget = false;
+        }
+
         if (resultCode == CONTENT_NO_EXTERNAL_STORAGE) {
             showContentView(CONTENT_NO_EXTERNAL_STORAGE);
         } else if (requestCode == PICK_DECK_REQUEST || requestCode == DOWNLOAD_PERSONAL_DECK
@@ -2540,9 +2546,9 @@ private void displayProgressDialogAndLoadDeck(boolean updateAllCards) {
 
             if (updateAllCards) {
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS, mLoadDeckHandler,
-                        new DeckTask.TaskData(mDeckFilename));
+                        new DeckTask.TaskData(mDeckFilename, 0, true));
             } else {
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(mDeckFilename));
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(mDeckFilename, 0, true));
             }
         } else {
             if (mDeckFilename == null) {
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
index aebbf0a611ee..cbeab9a05559 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -155,6 +155,7 @@ public static class UpdateService extends Service {
         public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
         public static final String ACTION_LEARN_MORE = "org.ichi2.anki.AnkiDroidWidgetBig.LEARNMORE";
         public static final String ACTION_REVIEW_EARLY = "org.ichi2.anki.AnkiDroidWidgetBig.REVIEWEARLY";
+        public static final String ACTION_SHOW_TOMORROW_DUES = "org.ichi2.anki.AnkiDroidWidgetBig.TOMORROWDUES";
 
 
         public static final String EXTRA_DECK_PATH = "deckPath";
@@ -389,21 +390,37 @@ public void onStart(Intent intent, int startId) {
             		if (sGetTomorrowCountAsyncTask != null && sGetTomorrowCountAsyncTask.getStatus() == AsyncTask.Status.RUNNING) {
             			sGetTomorrowCountAsyncTask.cancel(true);
             		}
-            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(intent.getStringExtra(EXTRA_DECK_PATH)));
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(intent.getStringExtra(EXTRA_DECK_PATH), 0, false));
                 } else if (ACTION_CLOSEDECK.equals(action)) {
-            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(sLoadedDeck.getDeckPath()));
+                	if (sLoadedDeck != null) {
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(sLoadedDeck.getDeckPath()));                		
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
                 } else if (ACTION_UNDO.equals(action)) {
-                	if (sLoadedDeck.undoAvailable()) {
-                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard.getId(), true));                		
+                	if (sLoadedDeck != null) {
+                    	if (sLoadedDeck.undoAvailable()) {
+                    		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard.getId(), true));                		
+                    	}                		
+                	} else {
+                		updateViews(VIEW_DECKS);
                 	}
                 } else if (ACTION_BURY_CARD.equals(action)) {
-            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard));
+                	if (sLoadedDeck != null) {
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard));                		
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
                 } else if (action.startsWith(ACTION_ANSWER)) {
                 	int ease = intent.getIntExtra(EXTRA_EASE, 0);
                 	if (ease == 0) {
                 		updateViews(VIEW_SHOW_ANSWER);
                 	} else {
-                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(ease, sLoadedDeck, sCard));
+                    	if (sLoadedDeck != null) {
+                    		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(ease, sLoadedDeck, sCard));
+                    	} else {
+                    		updateViews(VIEW_DECKS);
+                    	}
                 	}
                 } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
                 	Intent dialogIntent = new Intent(this, WidgetDialog.class);
@@ -452,7 +469,9 @@ public void onStart(Intent intent, int startId) {
 	                	sShowProgressDialog = false;
 	                	sCurrentMessage = null;
         	        	updateViews(VIEW_SHOW_QUESTION); 
-                	}			
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
                 } else if (ACTION_REVIEW_EARLY.equals(action)) {
                 	if (sLoadedDeck != null) {
                 		sLoadedDeck.setupReviewEarlyScheduler();
@@ -461,7 +480,20 @@ public void onStart(Intent intent, int startId) {
 	                	sShowProgressDialog = false;
 	                	sCurrentMessage = null;
         	        	updateViews(VIEW_SHOW_QUESTION); 
+                	} else {
+                		updateViews(VIEW_DECKS);
                 	}			
+                } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
+                	if (sTomorrowDues == null) {
+                		if (sGetTomorrowCountAsyncTask == null || sGetTomorrowCountAsyncTask.getStatus() != AsyncTask.Status.RUNNING) {
+                    		showProgressDialog();
+                    		sWaitForAsyncTask = true;
+                			sGetTomorrowCountAsyncTask = new GetTomorrowDueAsyncTask();
+                			sGetTomorrowCountAsyncTask.execute(PrefSettings.getSharedPrefs(AnkiDroidWidgetBig.UpdateService.this).getString("deckPath", AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
+        				}
+    				} else {
+        	        	updateViews(VIEW_CONGRATS);
+    				}
                 }
             }
         }
@@ -519,6 +551,8 @@ private synchronized RemoteViews buildUpdate(Context context) {
             	updateViews.setTextViewText(R.id.widget_big_deckname, "");
             	updateCounts(updateViews, sCurrentView);
 
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_deckfield, sCurrentView == VIEW_DECKS ? getTomorrowDuePendingIntent(context) : getUpdatePendingIntent(context, VIEW_DECKS));
+            	
             	updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getShowDeckSelectionPendingIntent(context));
             	updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
             	updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
@@ -738,25 +772,10 @@ private void updateCounts(RemoteViews updateViews, int view) {
 				updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
 
 				setDeckCounts(updateViews, decks);
-				if (due != 0) {
-            			updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
-            			updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
-        	    		updateViews.setTextViewText(R.id.widget_big_decketa, "─────\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
-				} else if (sTomorrowDues == null) {
-						updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
-            			sShowProgressDialog = true;
-            			updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-
-            			sWaitForAsyncTask = true;
-            			if (sGetTomorrowCountAsyncTask == null || sGetTomorrowCountAsyncTask.getStatus() != AsyncTask.Status.RUNNING) {
-            				sGetTomorrowCountAsyncTask = new GetTomorrowDueAsyncTask();
-            				sGetTomorrowCountAsyncTask.execute(PrefSettings.getSharedPrefs(AnkiDroidWidgetBig.UpdateService.this).getString("deckPath", AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
-            			}
-				} else {
-					updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.VISIBLE);
-					sCurrentView = VIEW_CONGRATS;
-					updateCounts(updateViews, VIEW_CONGRATS);
-				}
+
+				updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
+    			updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
+	    		updateViews.setTextViewText(R.id.widget_big_decketa, "─────\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
         		break;
     		}
     	}
@@ -801,6 +820,9 @@ private void setDeckCounts(RemoteViews updateViews, DeckStatus[] decks) {
        	pos = duesSb.length() - 1;
        	if (pos != -1) {
        		duesSb.delete(pos, pos + 1);
+       	}
+       	if (namesSb.length() == 0 || duesSb.length() == 0) {
+       		updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
        	}
    		updateViews.setTextViewText(R.id.widget_big_decknames, namesSb);
    		updateViews.setTextViewText(R.id.widget_big_deckdues, duesSb);
@@ -877,6 +899,12 @@ private PendingIntent getHelpPendingIntent(Context context) {
             return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
         }
 
+        private PendingIntent getTomorrowDuePendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_SHOW_TOMORROW_DUES);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
         private PendingIntent getUpdatePendingIntent(Context context, int view) {
             Intent ankiDroidIntent = new Intent(context, UpdateService.class);
             ankiDroidIntent.setAction(ACTION_UPDATE);
@@ -900,29 +928,23 @@ protected DeckStatus[] doInBackground(String... params) {
                 File dir = new File(params[0]);
                 File[] fileList = dir.listFiles(new WidgetStatus.AnkiFileFilter());
 
+                DeckStatus[] todayDues = WidgetStatus.fetch(sContext);
+
                 ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
 
-                if (fileList != null && fileList.length != 0) {
-                    for (File file : fileList) {
-                    	String absPath = file.getAbsolutePath();
-                    	try {
-                    		Deck deck = DeckManager.getDeck(absPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
-                    		if (deck != null) {
-                    			int failedCards = deck.getFailedDelayedCount();
-                    			int dueCards = deck.getNextDueCards(1);
-                    			int newCards = deck.getNextNewCards();
-                    			decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards, deck.getETA(failedCards, dueCards, newCards, true), 0));
-                    		}
-                    		DeckManager.closeDeck(absPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-                    	} catch (RuntimeException e) {
-                    		Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
-                    	}
-                    }
-                    if (this.isCancelled()) {
-                    	sTomorrowDues = null;
-                    	return null;
-                    }
-                    Collections.sort(decks, new WidgetStatus.ByNameComparator());
+                for (DeckStatus s : todayDues) {
+                	try {
+                		Deck deck = DeckManager.getDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
+                		if (deck != null) {
+                			int failedCards = deck.getFailedDelayedCount() + s.mFailedCards;
+                			int dueCards = deck.getNextDueCards(1) + s.mDueCards;
+                			int newCards = deck.getNextNewCards() + s.mNewCards;
+                			decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards, deck.getETA(failedCards, dueCards, newCards, true), 0));
+                		}
+                		DeckManager.closeDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+                	} catch (RuntimeException e) {
+                		Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
+                	}
                 }
                 return decks.toArray(new DeckStatus[0]);
             }
