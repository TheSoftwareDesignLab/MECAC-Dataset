diff --git a/AnkiDroid/src/main/assets/scripts/ankidroid.js b/AnkiDroid/src/main/assets/scripts/ankidroid.js
index abdebeba608d..9ea635487b15 100644
--- a/AnkiDroid/src/main/assets/scripts/ankidroid.js
+++ b/AnkiDroid/src/main/assets/scripts/ankidroid.js
@@ -61,12 +61,16 @@ globalThis.ankidroid.showAllHints = function () {
 
             const endX = event.changedTouches[0].clientX;
             const endY = event.changedTouches[0].clientY;
+            const scrollDirection = getScrollDirection(event.target);
             const params = new URLSearchParams({
                 x: Math.round(endX),
                 y: Math.round(endY),
                 deltaX: Math.round(endX - startX),
                 deltaY: Math.round(endY - startY),
             });
+            if (scrollDirection !== null) {
+                params.append("scrollDirection", scrollDirection);
+            }
             const requestUrl = `${SCHEME}://tapOrSwipe/?${params.toString()}`;
 
             tapTimer = setTimeout(() => {
@@ -111,4 +115,38 @@ globalThis.ankidroid.showAllHints = function () {
     function isTextSelected() {
         return !document.getSelection().isCollapsed;
     }
+
+    /**
+     * Checks if an element or its parents are scrollable and returns the direction(s).
+     * It traverses up the DOM from the event target, checking the first scrollable ancestor.
+     * @param {HTMLElement} target - The element where the touch ended.
+     * @returns {'h'|'v'|'hv'|null} - The scroll direction(s) if found, otherwise null.
+     */
+    function getScrollDirection(target) {
+        let node = target;
+        while (node && node.nodeType === Node.ELEMENT_NODE) {
+            const style = window.getComputedStyle(node);
+
+            const isHorizontallyScrollable =
+                (style.overflowX === "auto" || style.overflowX === "scroll") &&
+                node.scrollWidth > node.clientWidth;
+
+            const isVerticallyScrollable =
+                (style.overflowY === "auto" || style.overflowY === "scroll") &&
+                node.scrollHeight > node.clientHeight;
+
+            if (isHorizontallyScrollable && isVerticallyScrollable) {
+                return "hv";
+            }
+            if (isHorizontallyScrollable) {
+                return "h";
+            }
+            if (isVerticallyScrollable) {
+                return "v";
+            }
+            node = node.parentNode;
+        }
+        // No scrollable parent was found.
+        return null;
+    }
 })();
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
index c650642be9c3..c542b82b5ed8 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
@@ -592,9 +592,28 @@ class ReviewerFragment :
                     val absDeltaX = abs(deltaX)
                     val absDeltaY = abs(deltaY)
 
-                    // Constant that when divided by the scale allows minimum movement while tapping
                     val swipeThreshold = 18 / scale
-                    if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) return true
+                    if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) {
+                        val scrollDirection = url.getQueryParameter("scrollDirection")
+                        val swipeGesture =
+                            if (absDeltaX > absDeltaY) { // horizontal
+                                if (scrollDirection?.contains('h') == true) return true
+                                if (deltaX > 0) { // right
+                                    Gesture.SWIPE_RIGHT
+                                } else { // left
+                                    Gesture.SWIPE_LEFT
+                                }
+                            } else { // vertical
+                                if (scrollDirection?.contains('v') == true) return true
+                                if (deltaY > 0) { // down
+                                    Gesture.SWIPE_DOWN
+                                } else { // top
+                                    Gesture.SWIPE_UP
+                                }
+                            }
+                        viewModel.onGesture(swipeGesture)
+                        return true
+                    }
 
                     /** Gets the corresponding index of a dimension (X or Y) in the [gestureGrid] */
                     fun getGridIndex(
