diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index be5c62f427b1..eefd350fa096 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -140,14 +140,14 @@
 		</receiver>
 		<!-- Service to perform web API queries -->
 		<service android:name=".AnkiDroidWidgetSmall$UpdateService" />
-		<receiver android:name="AnkiDroidWidgetBig" android:label="@string/widget_big">
+		<receiver android:name="com.ichi2.widget.AnkiDroidWidgetBig" android:label="@string/widget_big">
 			<intent-filter>
 			<action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
 			</intent-filter>
 			<meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_big" />
 		</receiver>
 		<!-- Service to perform web API queries -->
-		<service android:name=".AnkiDroidWidgetBig$UpdateService" />
+		<service android:name="com.ichi2.widget.AnkiDroidWidgetBig$UpdateService" />
 </application>
 	<uses-sdk  android:minSdkVersion="3"
 		android:targetSdkVersion="11"/>
diff --git a/res/drawable-hdpi/widget_big_bg.9.png b/res/drawable-hdpi/widget_big_bg.9.png
index c6f20e1a5fb3..37783b329c63 100644
Binary files a/res/drawable-hdpi/widget_big_bg.9.png and b/res/drawable-hdpi/widget_big_bg.9.png differ
diff --git a/res/drawable-hdpi/widget_big_button_normal.9.png b/res/drawable-hdpi/widget_big_button_normal.9.png
index a1535d4e01be..3c6597f8a01f 100644
Binary files a/res/drawable-hdpi/widget_big_button_normal.9.png and b/res/drawable-hdpi/widget_big_button_normal.9.png differ
diff --git a/res/drawable-hdpi/widget_big_deckfield.9.png b/res/drawable-hdpi/widget_big_deckfield.9.png
index c20500c7268a..3d4ce88b4452 100644
Binary files a/res/drawable-hdpi/widget_big_deckfield.9.png and b/res/drawable-hdpi/widget_big_deckfield.9.png differ
diff --git a/res/drawable-hdpi/widget_big_star.9.png b/res/drawable-hdpi/widget_big_star.9.png
index 334b9629d90e..4ffb50b4b888 100644
Binary files a/res/drawable-hdpi/widget_big_star.9.png and b/res/drawable-hdpi/widget_big_star.9.png differ
diff --git a/res/drawable/widget_big_button_normal.9.png b/res/drawable/widget_big_button_normal.9.png
index a1535d4e01be..3c6597f8a01f 100644
Binary files a/res/drawable/widget_big_button_normal.9.png and b/res/drawable/widget_big_button_normal.9.png differ
diff --git a/res/drawable/widget_big_deckfield.9.png b/res/drawable/widget_big_deckfield.9.png
new file mode 100644
index 000000000000..3d4ce88b4452
Binary files /dev/null and b/res/drawable/widget_big_deckfield.9.png differ
diff --git a/res/layout/widget_big.xml b/res/layout/widget_big.xml
index 2d37917ed2a0..db13f334172e 100644
--- a/res/layout/widget_big.xml
+++ b/res/layout/widget_big.xml
@@ -5,9 +5,9 @@
         android:layout_width="fill_parent"
     	android:layout_height="fill_parent">
     	<FrameLayout
-		    android:layout_marginBottom="11.33dip"
-	    	android:layout_marginRight="44dip"
-	    	android:layout_marginLeft="11.33dip"
+		    android:layout_marginBottom="30dip"
+	    	android:layout_marginRight="43.3333dip"
+	    	android:layout_marginLeft="11.3333dip"
 	    	android:layout_marginTop="30dip"
 		    android:layout_width="fill_parent"
 		    android:background="#ffffff"
@@ -30,6 +30,8 @@
 			    android:layout_width="fill_parent"
 			    android:layout_height="fill_parent"
 		    	android:gravity="center"
+			    android:layout_marginLeft="5dip"
+			    android:layout_marginRight="5dip"
 		    	android:textSize="18sp"
 		    	android:textColor="#000000"/>
 		    <LinearLayout  android:id="@+id/widget_big_deckfield"
@@ -156,11 +158,11 @@
 	    android:background="@drawable/widget_big_bg">
 		<LinearLayout
 		    android:id="@+id/widget_big_side"
-		    android:layout_width="35.33dip"
+		    android:layout_width="35.3333dip"
 		    android:layout_height="fill_parent"
-		    android:layout_marginTop="42.67dip"
-		    android:layout_marginBottom="23.33dip"
-		    android:layout_marginRight="8.67dip"
+		    android:layout_marginTop="36dip"
+		    android:layout_marginBottom="36dip"
+		    android:layout_marginRight="8dip"
 		    android:focusable="false"
 		    android:orientation="vertical"
 		    android:padding="0dip"
@@ -232,13 +234,13 @@
 				        android:layout_weight="1"
 					android:clickable="true"
 					android:background="@drawable/widget_big_button">
-				        <TextView android:id="@+id/widget_big_ease2_normal"
+				        <TextView android:id="@+id/widget_big_ease2_rec"
 				    	    android:layout_width="fill_parent"
 				    	    android:layout_height="fill_parent"
 				    	    android:background="@drawable/widget_big_ease2"
 				    	    android:clickable="false"
 				    	    android:visibility="visible"/>
-				        <TextView android:id="@+id/widget_big_ease2_rec"
+				        <TextView android:id="@+id/widget_big_ease2_normal"
 				    	    android:layout_width="fill_parent"
 				    	    android:layout_height="fill_parent"
 				    	    android:background="@drawable/widget_big_ease2_rec"
@@ -270,13 +272,13 @@
 				        android:layout_height="fill_parent"
 				        android:background="@drawable/widget_big_flipcard"
 				        android:clickable="false"
-				        android:visibility="visible"/>
+				        android:visibility="invisible"/>
 				    <TextView android:id="@+id/widget_big_help"
 				        android:layout_width="fill_parent"
 				        android:layout_height="fill_parent"
 				        android:background="@drawable/widget_big_help"
 				        android:clickable="false"
-				        android:visibility="invisible"/>
+				        android:visibility="visible"/>
 				</FrameLayout>
 			</FrameLayout>
 		</LinearLayout>
@@ -286,7 +288,7 @@
 	    	android:layout_height="22dip"
 		    android:focusable="false"
 		    android:layout_marginTop="8dip"
-	    	android:layout_marginLeft="22dip"
+	    	android:layout_marginLeft="18dip"
 		    android:orientation="horizontal"
 		    android:clickable="false"
 		    android:layout_toLeftOf="@+id/widget_big_side"
@@ -303,11 +305,26 @@
 		    <TextView android:id="@+id/widget_big_counts"
 				android:gravity="center"
 	    	    android:singleLine="true"
-	    	    android:layout_marginRight="4sp"
+	    	    android:layout_marginRight="2sp"
 	        	android:layout_width="wrap_content"
 		        android:layout_height="fill_parent"
 				android:layout_alignParentRight="true"
 	    	    android:layout_weight="1"/>
 		</RelativeLayout>
+		<TextView android:id="@+id/widget_big_message"
+		    android:layout_width="fill_parent"
+	    	android:layout_height="22dip"
+		    android:focusable="false"
+	    	android:singleLine="true"
+	        android:textColor="#000000"
+			android:gravity="center"
+		    android:layout_marginBottom="9dip"
+	    	android:layout_marginLeft="18dip"
+    	    android:layout_marginRight="2sp"
+		    android:orientation="horizontal"
+		    android:clickable="false"
+		    android:textSize="13sp"
+		    android:layout_toLeftOf="@+id/widget_big_side"
+		    android:layout_alignParentBottom="true"/>
 	</RelativeLayout>
 </FrameLayout>
diff --git a/src/com/ichi2/anki/AnkiDroidWidgetMedium.java b/src/com/ichi2/anki/AnkiDroidWidgetMedium.java
index b7e1b9aa2304..9c144c66f286 100644
--- a/src/com/ichi2/anki/AnkiDroidWidgetMedium.java
+++ b/src/com/ichi2/anki/AnkiDroidWidgetMedium.java
@@ -197,7 +197,7 @@ public void onReceive(Context context, Intent intent) {
                         	if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                                 Log.i(AnkiDroidApp.TAG, "mMountReceiver - Action = Media Mounted");
                                 if (remounted) {
-                                    WidgetStatus.update(getBaseContext());                                	
+                                    WidgetStatus.update(getBaseContext());
                                 	remounted = false;
                                     if (mMountReceiver != null) {
                                         unregisterReceiver(mMountReceiver);
diff --git a/src/com/ichi2/anki/CardEditor.java b/src/com/ichi2/anki/CardEditor.java
index 9461f2946f5f..9d8832af9ef5 100644
--- a/src/com/ichi2/anki/CardEditor.java
+++ b/src/com/ichi2/anki/CardEditor.java
@@ -54,6 +54,7 @@
 import com.ichi2.anki.Fact.Field;
 import com.ichi2.themes.StyledDialog;
 import com.ichi2.themes.Themes;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import java.io.File;
diff --git a/src/com/ichi2/anki/DeckManager.java b/src/com/ichi2/anki/DeckManager.java
index a184bb827066..a705a2de93a3 100644
--- a/src/com/ichi2/anki/DeckManager.java
+++ b/src/com/ichi2/anki/DeckManager.java
@@ -4,12 +4,13 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.TreeSet;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
 import com.ichi2.anki.DeckPicker.AnkiFilter;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.widget.AnkiDroidWidgetBig;
+import com.ichi2.widget.WidgetDeckOperation;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import android.content.Context;
@@ -31,17 +32,14 @@ public class DeckManager {
 	public static final int REQUESTING_ACTIVITY_CARDEDITOR = 6;
 	public static final int REQUESTING_ACTIVITY_DOWNLOADMANAGER = 7;
 
-	private static HashMap<String,DeckInformation> sLoadedDecks = new HashMap<String,DeckInformation>();
+	private static HashMap<String, DeckInformation> sLoadedDecks = new HashMap<String, DeckInformation>();
+	private static HashMap<String, ReentrantLock> sDeckLocks = new HashMap<String, ReentrantLock>();
 
 	private static HashMap<String, String> sDeckPaths;
 	private static String[] sDeckNames;
 
 	private static String sMainDeckPath;
 
-	private static ReentrantLock mLock = new ReentrantLock(true);
-	private static Condition mCondFinished = mLock.newCondition();
-	private static String mOpeningDeck;
-	private static String mClosingDeck;
 
     /**
      * Gets deck from its path. Opens it if needed.
@@ -73,37 +71,30 @@ public static Deck getDeck(String deckpath, boolean setAsMainDeck, int requestin
      * @return the loaded deck
      */
 	public static Deck getDeck(String deckpath, int requestingActivity, boolean rebuild) {
-		return getDeck(deckpath, false, requestingActivity);
+		return getDeck(deckpath, false, true, requestingActivity, rebuild);
 	}
-	public static Deck getDeck(String deckpath, boolean setAsMainDeck, boolean doSafetyBackupIfNeeded, int requestingActivity, boolean rebuild) {
+	public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck, boolean doSafetyBackupIfNeeded, int requestingActivity, boolean rebuild) {
 		Deck deck = null;
-		mLock.lock();
-		mOpeningDeck = deckpath;
+		lockDeck(deckpath);
 		try {
-			while (mClosingDeck != null && mClosingDeck.equals(deckpath)) {
-				Log.e(AnkiDroidApp.TAG, "DeckManager: waitForDeckClosing (" + deckpath + ")");
-					mCondFinished.await();
-			}
 			if (sLoadedDecks.containsKey(deckpath)) {
-		        DeckInformation deckInformation = sLoadedDecks.get(deckpath);
-	        	try {
-	                if ((deckInformation.mClosingAsyncTask != null) && (deckInformation.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
-	                	// wait for closing deck async task before reopening it
-	                	Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
-	                	deckInformation.mClosingAsyncTask.get();
-	                	return getDeck(deckpath, requestingActivity);
-	                }
-	            } catch (Exception e) {
-	            	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
-	            }
-
 				// do not open deck if already loaded
+			        DeckInformation deckInformation = sLoadedDecks.get(deckpath);
+		        	try {
+		                if ((deckInformation.mClosingAsyncTask != null) && (deckInformation.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
+		                	Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
+		                	deckInformation.mClosingAsyncTask.get();
+		                	return getDeck(deckpath, setAsMainDeck, doSafetyBackupIfNeeded, requestingActivity, rebuild);
+		                }
+		            } catch (Exception e) {
+		            	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
+		            }
 		        ArrayList<Integer> openList = deckInformation.mOpenedBy;
 		        if (!openList.contains(requestingActivity)) {
 			        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " already loaded, adding requesting activity");
 		        	openList.add(requestingActivity);
 		        } else {
-			        Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " already loaded by this activity!");
+			        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " already loaded by this activity!");
 		        }
 		        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is now opened by " + openList.toString());
 	        	deck = deckInformation.mDeck;                	
@@ -133,8 +124,18 @@ public static Deck getDeck(String deckpath, boolean setAsMainDeck, boolean doSaf
     				} else if (deckInformation.mOpenedBy.contains(REQUESTING_ACTIVITY_SYNCCLIENT)) {
                     	// do not allow deck opening by other activities during syncing
                     	deck = null;
-                    }
-        		}
+    				}
+    			} else if (rebuild) {
+            		if (!deckInformation.mInitiallyRebuilt) {
+        					Log.i(AnkiDroidApp.TAG, "DeckManager: reopen deck in order to rebuild");
+        					deck.closeDeck(false);
+        					deckInformation.mDeck = Deck.openDeck(deckpath, true, requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
+        					deckInformation.mInitiallyRebuilt = true;
+        					WidgetStatus.update(AnkiDroidApp.getInstance().getBaseContext(), WidgetStatus.getDeckStatus(deck));
+            		} else {
+            			deckInformation.mDeck.reset();
+            		}
+                }
 			} else {
 		        try {
 		            Log.i(AnkiDroidApp.TAG, "DeckManager: try to load deck " + deckpath + " (" + requestingActivity + ")");
@@ -153,24 +154,47 @@ public static Deck getDeck(String deckpath, boolean setAsMainDeck, boolean doSaf
 			if (setAsMainDeck && deck != null) {
 				sMainDeckPath = deckpath;
 			}
-		} catch (InterruptedException e) {
-			e.printStackTrace();
 		} finally {
-			mOpeningDeck = null;
-			mCondFinished.signal();
-			mLock.unlock();
+			unlockDeck(deckpath);
 		}
 		return deck;
 	}
 
 
+	public static void lockDeck(String path) {
+		if (!sDeckLocks.containsKey(path)) {
+			sDeckLocks.put(path, new ReentrantLock(true));
+		}
+		sDeckLocks.get(path).lock();
+	}
+
+
+	public static void unlockDeck(String path) {
+		if (sDeckLocks.containsKey(path)) {
+			sDeckLocks.get(path).unlock();
+		}
+	}
+
+
+//	public static void waitForDeckOperation(String path) {
+//		if (sDeckLocks.containsKey(path)) {
+//			if (sDeckLocks.get(path).is)
+//			Log.i(AnkiDroidApp.TAG, "DeckManager: waitForDeckOperation");
+////			while (mClosingDeck != null && mClosingDeck.equals(deckpath)) {
+////				Log.e(AnkiDroidApp.TAG, "DeckManager: waitForDeckClosing (" + deckpath + ")");
+////					mCondFinished.await();
+////			}
+//		}
+//	}
+
+
     /** get main deck path */
 	public static String getMainDeckPath() {
 		return sMainDeckPath;
 	}
 
 
-    /** get main deck, does not reloads the deck if it's not loaded anymore */
+	/** get main deck, does not reloads the deck if it's not loaded anymore */
 	public static Deck getMainDeck() {
 		if (sMainDeckPath == null || !sLoadedDecks.containsKey(sMainDeckPath)) {
 			return null;
@@ -280,15 +304,9 @@ public static void closeDeck(String deckpath, int requestingActivity) {
 		closeDeck(deckpath, requestingActivity, true);
 	}
 	public static void closeDeck(String deckpath, int requestingActivity, boolean waitToFinish) {
-		mLock.lock();
-		mClosingDeck = deckpath;
+		lockDeck(deckpath);
 		try {
 			if (sLoadedDecks.containsKey(deckpath)) {
-				// wait for potential deck openings to finish
-				while (mOpeningDeck != null && mOpeningDeck.equals(deckpath)) {
-					Log.e(AnkiDroidApp.TAG, "DeckManager: waitForDeckOpening (" + deckpath + ")");
-					mCondFinished.await();
-				}
 				DeckInformation di = sLoadedDecks.get(deckpath);
 				if ((di.mClosingAsyncTask != null) && (di.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
 					Log.i(AnkiDroidApp.TAG, "DeckManager: closeDeck - deck " + deckpath + " is already closing");
@@ -305,14 +323,8 @@ public static void closeDeck(String deckpath, int requestingActivity, boolean wa
 					}
 				} else {
 					Log.i(AnkiDroidApp.TAG, "DeckManager: closing deck " + deckpath + " (" + requestingActivity + ")");
-					if (waitToFinish && (openList.contains(REQUESTING_ACTIVITY_STUDYOPTIONS))) {
-						DeckTask.waitToFinish();
-					} else if (waitToFinish && (openList.contains(REQUESTING_ACTIVITY_BIGWIDGET))) {
-						WidgetStatus.deckOperationWaitToFinish();
-					}
-
 					sLoadedDecks.get(deckpath).mClosingAsyncTask = new CloseDeckAsyncTask();
-					sLoadedDecks.get(deckpath).mClosingAsyncTask.execute(sLoadedDecks.get(deckpath));
+					sLoadedDecks.get(deckpath).mClosingAsyncTask.execute(new CloseDeckInformation(deckpath, requestingActivity));
 
 					// close widget learning screen when deck is closed by other activity
 					if (openList.contains(REQUESTING_ACTIVITY_BIGWIDGET)) {
@@ -325,19 +337,15 @@ public static void closeDeck(String deckpath, int requestingActivity, boolean wa
 			} else {
 				Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is not a loaded deck");
 			}			
-		} catch (InterruptedException e) {
-			e.printStackTrace();
 		} finally {
-			mClosingDeck = null;
-			mCondFinished.signal();
-			mLock.unlock();
+    		unlockDeck(deckpath);
 		}
 	}
 
 
 	private static void sendWidgetBigClosedNotification() {
-		AnkiDroidWidgetBig.setDeckAndLoadCard(null);
-    	AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED);
+		AnkiDroidWidgetBig.setDeck(null);
+    	AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_DECKS);
 	}
 
 
@@ -387,16 +395,27 @@ public static StyledDialog getSelectDeckDialog(Context context, OnClickListener
 	}
 
 
-    private static class CloseDeckAsyncTask extends AsyncTask<DeckInformation, Void, DeckInformation> {
+    private static class CloseDeckAsyncTask extends AsyncTask<CloseDeckInformation, Void, DeckInformation> {
 
     	@Override
-        protected DeckInformation doInBackground(DeckInformation... params) {
+        protected DeckInformation doInBackground(CloseDeckInformation... params) {
             Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.doInBackground()");
-            DeckInformation di = params[0];
-            String deckpath = di.mDeck.getDeckPath();
+            String deckpath = params[0].mDeckPath;
+            int requestingActivity = params[0].mCaller;
+            DeckInformation di = sLoadedDecks.get(deckpath);
+            
+            if (di.mOpenedBy.contains(REQUESTING_ACTIVITY_STUDYOPTIONS) && requestingActivity != REQUESTING_ACTIVITY_STUDYOPTIONS) {
+            	// wait for any decktask operation
+            	DeckTask.waitToFinish();
+            }
+//            if (di.mOpenedBy.contains(REQUESTING_ACTIVITY_BIGWIDGET) && requestingActivity != REQUESTING_ACTIVITY_BIGWIDGET) {
+//            	// wait for any widget deck operation
+//            	WidgetDeckOperation.waitToFinish(deckpath);
+//            }
+
             try {
                 di.mDeck.closeDeck(false);
-                Log.i(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask: deck " + deckpath + " successfully closed");
+                Log.e(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask: deck " + deckpath + " successfully closed");
             } catch (RuntimeException e) {
             	Log.e(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask: could not close deck " + deckpath + ": " + e);
             }
@@ -417,16 +436,27 @@ protected void onPostExecute(DeckInformation deckInformation) {
 	public static class DeckInformation {
 		public String mKey;
 		public Deck mDeck;
-		public boolean mRebuilt = true;
+		public boolean mInitiallyRebuilt = true;
 		public boolean mDeleteJournalModeForced = false;
 		public ArrayList<Integer> mOpenedBy = new ArrayList<Integer>();
-		public AsyncTask<DeckInformation, Void, DeckInformation> mClosingAsyncTask;
+		public AsyncTask<CloseDeckInformation, Void, DeckInformation> mClosingAsyncTask;
 
-		DeckInformation(String key, Deck deck, int openedBy, boolean rebuilt) {
+		DeckInformation(String key, Deck deck, int openedBy, boolean initiallyRebuilt) {
 			this.mKey = key;
 			this.mDeck = deck;
 			this.mOpenedBy.add(openedBy);
-			this.mRebuilt = rebuilt;
+			this.mInitiallyRebuilt = initiallyRebuilt;
+		}
+	}
+
+
+	public static class CloseDeckInformation {
+		public String mDeckPath;
+		public int mCaller;
+
+		CloseDeckInformation(String deckpath, int caller) {
+			this.mDeckPath = deckpath;
+			this.mCaller = caller;
 		}
 	}
 }
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
index ba3615722b78..9ec595a25f23 100644
--- a/src/com/ichi2/anki/DeckTask.java
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -31,10 +31,7 @@
 
 import android.content.Context;
 import android.content.res.Resources;
-import android.database.CursorIndexOutOfBoundsException;
-import android.database.SQLException;
 import android.database.sqlite.SQLiteDiskIOException;
-import android.database.sqlite.SQLiteException;
 import android.os.AsyncTask;
 import android.util.Log;
 
@@ -64,6 +61,7 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     public static final int TASK_TYPE_SORT_CARDS = 18;
     public static final int TASK_TYPE_LOAD_TUTORIAL = 19;
     public static final int TASK_TYPE_REPAIR_DECK = 20;
+    public static final int TASK_TYPE_CLOSE_DECK = 21;
 
 
     /**
@@ -98,6 +96,7 @@ public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData.
     public static void waitToFinish() {
         try {
             if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
+		Log.i(AnkiDroidApp.TAG, "DeckTask: wait to finish");
                 sInstance.get();
             }
         } catch (Exception e) {
@@ -210,6 +209,9 @@ protected TaskData doInBackground(TaskData... params) {
             case TASK_TYPE_REPAIR_DECK:
                 return doInBackgroundRepairDeck(params);
 
+            case TASK_TYPE_CLOSE_DECK:
+                return doInBackgroundCloseDeck(params);
+
             default:
                 return null;
         }
@@ -363,7 +365,7 @@ private TaskData doInBackgroundLoadDeck(TaskData... params) {
         	deck.finishScheduler();
         }
         publishProgress(new TaskData(backupResult));
-        return new TaskData(DECK_LOADED);
+        return new TaskData(DECK_LOADED, deck, null);
     }
 
 
@@ -641,6 +643,14 @@ private TaskData doInBackgroundRepairDeck(TaskData... params) {
     }
 
 
+    private TaskData doInBackgroundCloseDeck(TaskData... params) {
+    	Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseDeck");
+    	String deckPath = params[0].getString();
+    	DeckManager.closeDeck(deckPath, false);
+    	return null;
+    }
+
+
     private TaskData doInBackgroundSetJournalMode(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundSetJournalMode");
         String path = params[0].getString();
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 47d566e87af5..57da4798aadb 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -1001,14 +1001,14 @@ protected void onStop() {
       }
       super.onStop();
       DeckTask.waitToFinish();
+      Deck deck = DeckManager.getMainDeck();
       if (!isFinishing()) {
           // Save changes
-          Deck deck = DeckManager.getMainDeck();
           if (deck != null) {
 	            deck.commitToDB();
           }
       }
-      WidgetStatus.update(getBaseContext(), true);
+      WidgetStatus.update(this, WidgetStatus.getDeckStatus(deck));
     }
 
     @Override
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 2dd63d1ec2ad..b3f79ea50e47 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -852,9 +852,9 @@ protected void onStop() {
         // Update the widget when stopping this activity (all when closing, only current when pressing home).
         if (!mInDeckPicker && !mInReviewer) {
         	if (isFinishing()) {
-                WidgetStatus.update(getBaseContext());
+        		WidgetStatus.update(this, null);
         	} else {
-                WidgetStatus.update(getBaseContext(), true);
+        		WidgetStatus.update(this, WidgetStatus.getDeckStatus(DeckManager.getMainDeck()));
         	}
         }
     }
@@ -1918,7 +1918,7 @@ public static String getCongratsMessage(Context context, Deck deck) {
 
     private void resetAndUpdateValuesFromDeck() {
         Deck deck = DeckManager.getMainDeck();
-        DeckTask.waitToFinish();
+//        DeckTask.waitToFinish();
         if (deck != null) {
             deck.reset();
         	updateValuesFromDeck();        	
diff --git a/src/com/ichi2/anki/WidgetStatus.java b/src/com/ichi2/anki/WidgetStatus.java
index f3050b9172f3..36128fdd2ebf 100644
--- a/src/com/ichi2/anki/WidgetStatus.java
+++ b/src/com/ichi2/anki/WidgetStatus.java
@@ -15,6 +15,7 @@
 package com.ichi2.anki;
 
 import com.ichi2.anki.services.NotificationService;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import android.content.Context;
@@ -38,27 +39,21 @@ public final class WidgetStatus {
 
 	private static boolean mediumWidget = false;
 	private static boolean smallWidget = false;
+	private static boolean bigWidget = false;
 	private static boolean notification = false;
-	private static boolean onlyCurrentDeck = false;
+	private static DeckStatus sDeckStatus;
 	private static AsyncTask<Context,Void,Context> sUpdateDeckStatusAsyncTask;
-	private static AsyncTask<WidgetDeckTaskData,Void,WidgetDeckTaskData> sDeckOperationTask;
-	private static int sDeckOperationType;
-	public static final int TASK_OPEN_DECK = 0;
-	public static final int TASK_ANSWER_CARD = 1;
-	public static final int TASK_CLOSE_DECK = 2;
-	public static final int TASK_UNDO = 3;
-	public static final int TASK_BURY_CARD = 4;
 
     /** This class should not be instantiated. */
     private WidgetStatus() {}
 
     /** Request the widget to update its status. */
     public static void update(Context context) {
-    	update(context, false);
+    	update(context, null);
     }
     /** Request the widget to update its status. */
-    public static void update(Context context, boolean onlyCurrent) {
-    	onlyCurrentDeck = onlyCurrent;
+    public static void update(Context context, DeckStatus deckStatus) {
+    	sDeckStatus = deckStatus;
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
         if (preferences.getBoolean("widgetMediumEnabled", false)) {
             mediumWidget = true;
@@ -70,12 +65,17 @@ public static void update(Context context, boolean onlyCurrent) {
         } else {
             smallWidget = false;
         }
-        if (Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25")) < 1000000 && !onlyCurrentDeck) {
+        if (preferences.getBoolean("widgetBidEnabled", false)) {
+            bigWidget = true;
+        } else {
+            bigWidget = false;
+        }
+        if (Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25")) < 1000000 && sDeckStatus == null) {
         	notification = true;
         } else {
         	notification = false;
         }
-        if ((mediumWidget || smallWidget || notification) && ((sUpdateDeckStatusAsyncTask == null) || (sUpdateDeckStatusAsyncTask.getStatus() == AsyncTask.Status.FINISHED))) {
+        if ((mediumWidget || smallWidget || bigWidget || notification) && ((sUpdateDeckStatusAsyncTask == null) || (sUpdateDeckStatusAsyncTask.getStatus() == AsyncTask.Status.FINISHED))) {
             Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): updating");
             sUpdateDeckStatusAsyncTask = new UpdateDeckStatusAsyncTask();
             sUpdateDeckStatusAsyncTask.execute(context);
@@ -99,38 +99,23 @@ public static int fetchDue(Context context) {
         return MetaDB.getNotificationStatus(context);
     }
 
-
-    public static void deckOperation(int type, WidgetDeckTaskData params) {
-        try {
-            if ((sDeckOperationTask != null) && (sDeckOperationTask.getStatus() != AsyncTask.Status.FINISHED)) {
-            	sDeckOperationTask.get();
-            }
-        } catch (Exception e) {
-            Log.e(AnkiDroidApp.TAG,
-                    "deckOperation - Got exception while waiting for thread to finish: " + e.getMessage());
-        }
-
-    	sDeckOperationType = type;
-    	sDeckOperationTask = new DeckOperationAsyncTask();
-    	sDeckOperationTask.execute(params);
-    }
-
-
-    /**
-     * Block the current thread until the currently running DeckOperationAsyncTask instance (if any) has finished.
-     */
-    public static void deckOperationWaitToFinish() {
-	if (sDeckOperationType == TASK_CLOSE_DECK) {
-		// prevent deadlock when calling this from deckmanager.closedeck
-		return;
-	}
-        try {
-            if ((sUpdateDeckStatusAsyncTask != null) && (sUpdateDeckStatusAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
-            	sUpdateDeckStatusAsyncTask.get();
-            }
-        } catch (Exception e) {
-            return;
+    public static DeckStatus getDeckStatus(Deck deck) {
+		if (deck == null) {
+			return null;
+		}
+        int dueCards = 0;
+        int newCards = 0;
+        int failedCards = deck.getFailedSoonCount();
+        int eta = 0;
+        int reps = deck.getSessionFinishedCards();
+
+
+        if(!deck.hasFinishScheduler()) {
+            dueCards = deck.getRevCount();
+            newCards = deck.getNewCountToday();
+            eta = deck.getETA();
         }
+        return new DeckStatus(deck.getDeckPath(), deck.getDeckName(), newCards, dueCards, failedCards, eta, reps);
     }
 
 
@@ -151,34 +136,17 @@ protected Context doInBackground(Context... params) {
             // For the deck information
             ArrayList<DeckStatus> decks;
 
-            if (false){//onlyCurrentDeck) {
-//                decks = new ArrayList<DeckStatus>(mDecks.length);
-//
-//                Deck currentDeck = AnkiDroidApp.deck();
-//                if (currentDeck != null) {
-//                	String currentDeckPath = currentDeck.getDeckPath();
-//                	try {
-//                		for (DeckStatus m : mDecks) {
-//                			if (m.mDeckPath.equals(currentDeckPath)) {
-//	                    			Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + currentDeckPath);
-//						if (!currentDeck.hasFinishScheduler()) {
-//		                			decks.add(new DeckStatus(currentDeckPath, currentDeck.getDeckName(), currentDeck.getNewCountToday(), currentDeck.getRevCount(), currentDeck.getFailedSoonCount(), currentDeck.getETA(), currentDeck.getSessionFinishedCards()));
-//						} else {
-//		                			decks.add(new DeckStatus(currentDeckPath, currentDeck.getDeckName(), 0, 0, currentDeck.getFailedSoonCount(), 0, currentDeck.getSessionFinishedCards()));
-//						}
-//                			} else {
-//                    			Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
-//                				decks.add(m);
-//                			}
-//                		}
-//                    } catch (SQLException e) {
-//                        Log.i(AnkiDroidApp.TAG, "Widget: Could not retrieve deck information");
-//                        Log.e(AnkiDroidApp.TAG, e.toString());
-//                        if (currentDeckPath != null) {
-//                            BackupManager.restoreDeckIfMissing(currentDeckPath);                    	
-//                        }
-//                    }
-//                }
+            if (sDeckStatus != null) {
+            	decks = new ArrayList<DeckStatus>(mDecks.length);
+            		for (DeckStatus m : mDecks) {
+            			if (m.mDeckPath.equals(sDeckStatus.mDeckPath)) {
+            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + sDeckStatus.mDeckPath);
+            				decks.add(sDeckStatus);
+            			} else {
+            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
+            				decks.add(m);
+            			}
+            		}
             } else {
                 SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
                 String deckPath = preferences.getString("deckPath",
@@ -204,7 +172,7 @@ protected Context doInBackground(Context... params) {
 
                         Log.i(AnkiDroidApp.TAG, "WidgetStatus: Found deck: " + absPath);
 
-                        Deck deck = DeckManager.getDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS);
+                        Deck deck = DeckManager.getDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS, false);
                         if (deck == null) {
                             Log.e(AnkiDroidApp.TAG, "Widget: Skipping null deck: " + absPath);
                             // Use the data from the last time we updated the deck, if available.
@@ -271,15 +239,17 @@ protected void onPostExecute(Context context) {
                 intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);            	
                 context.startService(intent);
             }
+            if (bigWidget) {
+            	Intent intent;
+                intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);            	
+		intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
+                context.startService(intent);
+            }
             if (notification) {
             	Intent intent;
                 intent = new Intent(context, NotificationService.class);
                 context.startService(intent);
             }
-        	Intent intent;
-            intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-            intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
-            context.startService(intent);
         }
 
         /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
@@ -299,190 +269,4 @@ public boolean accept(File pathname) {
             }
         }
     }
-
-    private static class DeckOperationAsyncTask extends AsyncTask<WidgetDeckTaskData, Void, WidgetDeckTaskData> {
-
-        @Override
-        protected WidgetDeckTaskData doInBackground(WidgetDeckTaskData... params) {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.DeckOperationAsyncTask.doInBackground()");
-
-            switch (sDeckOperationType) {
-            case TASK_OPEN_DECK:
-            	return doInBackgroundOpenDeck(params);
-            case TASK_ANSWER_CARD:
-            	return doInBackgroundAnswerCard(params);
-            case TASK_CLOSE_DECK:
-            	return doInBackgroundCloseDeck(params);
-            case TASK_UNDO:
-            	return doInBackgroundUndo(params);
-            case TASK_BURY_CARD:
-            	return doInBackgroundBury(params);
-            }
-            return params[0];
-        }
-
-        protected WidgetDeckTaskData doInBackgroundOpenDeck(WidgetDeckTaskData... params) {
-        	Log.i(AnkiDroidApp.TAG, "DeckOperationAsyncTask: doInBackgroundOpenDeck");
-        	Deck deck = DeckManager.getDeck(params[0].getString(), DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-        	return new WidgetDeckTaskData(params[0].getContext(), deck);
-        }
-
-        protected WidgetDeckTaskData doInBackgroundAnswerCard(WidgetDeckTaskData... params) {
-        	Log.e(AnkiDroidApp.TAG, "DeckOperationAsyncTask: doInBackgroundAnswerCard");
-        	Context context = params[0].getContext();
-        	Card card = params[0].getCard();
-        	Deck deck = params[0].getDeck();
-        	Card newCard;
-        	int ease = params[0].getInt();
-        	if (ease == 0) {
-        		return new WidgetDeckTaskData(context, deck, card);
-        	}
-//            try {
-Log.e("suchen"," doInBackgroundAnswerCard1");
-    	        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-Log.e("suchen"," doInBackgroundAnswerCard2");
-    	        ankiDB.getDatabase().beginTransaction();
-Log.e("suchen"," doInBackgroundAnswerCard3");
-    	        try {
-    	            if (card != null) {
-    	            	if (card.thinkingTime() >= 20) {
-    	            		// user restarted learning
-    	            		card.startTimer();
-    	            	}
-Log.e("suchen"," doInBackgroundAnswerCard4");
-    	                deck.answerCard(card, ease);
-Log.e("suchen"," doInBackgroundAnswerCard5");
-    	                Log.e(AnkiDroidApp.TAG, "WidgetBig: answering card with ease " + ease);
-    	            }
-    	            newCard = deck.getCard();
-Log.e("suchen"," doInBackgroundAnswerCard6");
-
-    	            AnkiDroidWidgetBig.setCard(newCard);
-Log.e("suchen"," doInBackgroundAnswerCard7");
-
-    	            ankiDB.getDatabase().setTransactionSuccessful();
-Log.e("suchen"," doInBackgroundAnswerCard8");
-    	        } finally {
-    	            ankiDB.getDatabase().endTransaction();
-Log.e("suchen"," doInBackgroundAnswerCard9");
-    	        }
-    	    
-        	return new WidgetDeckTaskData(params[0].getContext(), deck, newCard);
-        }
-
-        protected WidgetDeckTaskData doInBackgroundCloseDeck(WidgetDeckTaskData... params) {
-        	Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseDeck");
-        	DeckManager.closeDeck(params[0].getString(), DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
-        	return new WidgetDeckTaskData(params[0].getContext());
-        }
-
-
-        protected WidgetDeckTaskData doInBackgroundUndo(WidgetDeckTaskData... params) {
-        	Log.e(AnkiDroidApp.TAG, "doInBackgroundUndo");
-        	Deck deck = params[0].getDeck();
-        	deck.undo(0, true);
-        	AnkiDroidWidgetBig.setCard(deck.getCard());//deck.cardFromId(deck.undo(0, true)));
-        	return new WidgetDeckTaskData(params[0].getContext());
-        }
-
-
-        protected WidgetDeckTaskData doInBackgroundBury(WidgetDeckTaskData... params) {
-        	Log.e(AnkiDroidApp.TAG, "doInBackgroundBury");
-        	Card card = params[0].getCard();
-        	long id = card.getId();
-        	Deck deck = params[0].getDeck();
-        	deck.buryFact(card.getFactId(), id);
-        	deck.reset();
-
-        	AnkiDroidWidgetBig.setCard(deck.getCard());
-        	return new WidgetDeckTaskData(params[0].getContext());
-        }
-        
-
-        @Override
-        protected void onPostExecute(WidgetDeckTaskData params) {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.DeckOperationAsyncTask.onPostExecute()");
-            switch(sDeckOperationType) {
-            case TASK_OPEN_DECK:
-                AnkiDroidWidgetBig.setDeckAndLoadCard(params.getDeck());            	
-            	break;
-            case TASK_CLOSE_DECK:
-            	break;
-            case TASK_ANSWER_CARD:
-            	break;
-            case TASK_UNDO:
-            	break;
-            case TASK_BURY_CARD:
-            	break;            	
-            }
-
-        }
-    }
-
-
-    public static class WidgetDeckTaskData {
-    	private Context context;
-    	private String string;
-    	private Deck deck;
-    	private Card card;
-    	private int integer;
-
-    	public WidgetDeckTaskData(Context context) {
-    		this.context = context;
-        }
-
-    	public WidgetDeckTaskData(Context context, String string) {
-    		this.context = context;
-    		this.string = string;
-        }
-
-    	public WidgetDeckTaskData(Context context, Deck deck, String string) {
-    		this.deck = deck;
-    		this.context = context;
-    		this.string = string;
-        }
-
-    	public WidgetDeckTaskData(Context context, Card card) {
-    		this.context = context;
-    		this.card = card;
-        }
-
-    	public WidgetDeckTaskData(Context context, Deck deck) {
-    		this.context = context;
-    		this.deck = deck;
-        }
-
-    	public WidgetDeckTaskData(Context context, Deck deck, Card card) {
-    		this.context = context;
-    		this.deck = deck;
-    		this.card = card;
-        }
-
-    	public WidgetDeckTaskData(Context context, Deck deck, Card card, int integer) {
-    		this.context = context;
-    		this.deck = deck;
-    		this.card = card;
-    		this.integer = integer;
-        }
-
-    	public String getString() {
-    		return string;
-    	}
-
-    	public Card getCard() {
-    		return card;
-    	}
-
-    	public Deck getDeck() {
-    		return deck;
-    	}
-
-    	public Context getContext() {
-    		return context;
-    	}
-
-    	public int getInt() {
-    		return integer;
-    	}
-    }
 }
diff --git a/src/com/ichi2/anki/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
similarity index 66%
rename from src/com/ichi2/anki/AnkiDroidWidgetBig.java
rename to src/com/ichi2/widget/AnkiDroidWidgetBig.java
index 0ed76aa4a79a..9c30ae3df011 100644
--- a/src/com/ichi2/anki/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -12,12 +12,23 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
  ****************************************************************************************/
 
-package com.ichi2.anki;
-
-import java.util.ArrayList;
-
-import com.ichi2.anki.WidgetStatus.WidgetDeckTaskData;
-import com.ichi2.widget.WidgetDialog;
+package com.ichi2.widget;
+
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.BackupManager;
+import com.ichi2.anki.Card;
+import com.ichi2.anki.CardEditor;
+import com.ichi2.anki.Deck;
+import com.ichi2.anki.DeckManager;
+import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.DeckTask;
+import com.ichi2.anki.R;
+import com.ichi2.anki.Reviewer;
+import com.ichi2.anki.StudyOptions;
+import com.ichi2.anki.Utils;
+import com.ichi2.anki.WidgetStatus;
+import com.ichi2.themes.Themes;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import android.app.PendingIntent;
@@ -31,6 +42,7 @@
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.graphics.Color;
+import android.graphics.Typeface;
 import android.net.Uri;
 import android.os.IBinder;
 import android.text.Html;
@@ -38,6 +50,7 @@
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
 import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
 import android.util.Log;
 import android.view.View;
@@ -51,13 +64,14 @@ public class AnkiDroidWidgetBig extends AppWidgetProvider {
     private static Card sCard;
     private static boolean mShowProgressDialog = false;
     private static int mCurrentView;
+    private static String mCurrentMessage;
 
     private static Context sContext;
 
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
         Log.i(AnkiDroidApp.TAG, "BigWidget: onUpdate");
-//        WidgetStatus.update(context);
+        WidgetStatus.update(context);
         sContext = context;
         Intent intent;
         intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);            	
@@ -79,6 +93,10 @@ public void onEnabled(Context context) {
         }
         preferences.edit().putBoolean("widgetBigEnabled", true).commit();
         sContext = context;
+	mCurrentView = UpdateService.VIEW_NOT_SPECIFIED;
+	sLoadedDeck = null;
+	sCard = null;
+	mShowProgressDialog = false;
     }
 
     @Override
@@ -90,12 +108,9 @@ public void onDisabled(Context context) {
     }
 
 
-    public static void setDeckAndLoadCard(Deck deck) {
+    public static void setDeck(Deck deck) {
     	sLoadedDeck = deck;
-    	if (deck != null) {
-        	sCard = sLoadedDeck.getCard();
-    	}
-    	updateWidget(UpdateService.VIEW_SHOW_QUESTION);
+    	updateWidget(UpdateService.VIEW_NOT_SPECIFIED);
     }
 
 
@@ -114,14 +129,14 @@ public static void updateWidget(int view) {
         Intent intent;
         if (sContext != null) {
             intent = new Intent(sContext, AnkiDroidWidgetBig.UpdateService.class);
-            intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
-            intent.putExtra(UpdateService.EXTRA_CURRENT_VIEW, view);
+            intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE + Integer.toString(view));
             sContext.startService(intent);        	
         }
     }
 
 
     public static class UpdateService extends Service {
+    	public static final String ACTION_NOTHING = "org.ichi2.anki.AnkiDroidWidgetBig.NOTHING";
     	public static final String ACTION_OPENDECK = "org.ichi2.anki.AnkiDroidWidgetBig.OPENDECK";
         public static final String ACTION_CLOSEDECK = "org.ichi2.anki.AnkiDroidWidgetBig.CLOSEDECK";
         public static final String ACTION_ANSWER = "org.ichi2.anki.AnkiDroidWidgetBig.ANSWER";
@@ -132,7 +147,7 @@ public static class UpdateService extends Service {
         public static final String ACTION_CARDEDITOR = "org.ichi2.anki.AnkiDroidWidgetBig.CARDEDITOR";
         public static final String ACTION_HELP = "org.ichi2.anki.AnkiDroidWidgetBig.HELP";
         public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
-        public static final String EXTRA_CURRENT_VIEW = "currentView";
+
         public static final String EXTRA_DECK_PATH = "deckPath";
 
 
@@ -185,6 +200,28 @@ private CharSequence getDeckStatusString(int failed, int rev, int newCount, Card
         }
 
 
+    	private CharSequence getNextTimeString(Card card) {
+            SpannableStringBuilder sb = new SpannableStringBuilder();
+
+            SpannableString hard = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 2) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            hard.setSpan(new ForegroundColorSpan(getResources().getColor(card.isRev() ? R.color.next_time_usual_color : R.color.next_time_recommended_color)), 0, hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            SpannableString easy = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 3) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            easy.setSpan(new ForegroundColorSpan(getResources().getColor(card.isRev() ? R.color.next_time_recommended_color : R.color.next_time_usual_color)), 0, easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            SpannableString veryEasy = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 4) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            veryEasy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.next_time_usual_color)), 0, veryEasy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            sb.append(hard);
+            sb.append(" \u2027 ");
+            sb.append(easy);
+            sb.append(" \u2027 ");
+            sb.append(veryEasy);
+
+            return sb;
+        }
+
+
         private CharSequence[] getDeckNamesAndDues() {
         	DeckStatus[] decks = WidgetStatus.fetch(this);
         	StringBuilder namesSb = new StringBuilder();
@@ -207,6 +244,136 @@ private CharSequence[] getDeckNamesAndDues() {
         }
 
 
+        private DeckTask.TaskListener mOpenDeckHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	Resources res = getResources();
+            	String message = values[0].getString();
+            	if (message == null) {
+    				switch (values[0].getInt()) {
+            		case BackupManager.RETURN_BACKUP_CREATED:
+                		mCurrentMessage = res.getString(R.string.backup_deck_success);
+                		break;
+            		case BackupManager.RETURN_TODAY_ALREADY_BACKUP_DONE:
+            		case BackupManager.RETURN_DECK_NOT_CHANGED:
+            			mCurrentMessage = res.getString(R.string.loading_deck);
+            			break;
+            		case BackupManager.RETURN_ERROR:
+            			mCurrentMessage = "backup error";
+            			break;
+            		case BackupManager.RETURN_NOT_ENOUGH_SPACE:
+            			mCurrentMessage = "not enough space";
+            			break;
+            		case BackupManager.RETURN_LOW_SYSTEM_SPACE:
+            			mCurrentMessage = "low system space";
+            			break;
+            		}
+            	} else {
+            		mCurrentMessage = message;
+            	}
+            	updateViews();
+            }
+
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (result.getInt() == DeckTask.DECK_LOADED) {
+                	sLoadedDeck = result.getDeck();
+                	if (sLoadedDeck != null) {
+                    	sCard = sLoadedDeck.getCard();
+                	}
+                	mShowProgressDialog = false;
+                	mCurrentMessage = null;
+                	updateViews(VIEW_SHOW_QUESTION);            		
+            	} else {
+                	mShowProgressDialog = false;
+                	mCurrentMessage = "deck could not be loaded";
+                	updateViews(VIEW_DECKS);
+            	}
+            }
+        };
+
+
+        private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	sCard = values[0].getCard();
+                if (values[0].isPreviousCardLeech()) {
+                    if (values[0].isPreviousCardSuspended()) {
+                    	mCurrentMessage = getResources().getString(R.string.leech_suspend_notification);
+                    } else {
+                    	mCurrentMessage = getResources().getString(R.string.leech_notification);
+                    }
+                } else {
+                	mCurrentMessage = null;
+                }
+            	mShowProgressDialog = false;
+            	updateViews(VIEW_SHOW_QUESTION);
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (!result.getBoolean()) {
+            		// TODO: db error handling
+            	}
+            }
+        };
+
+
+        private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	sCard = values[0].getCard();
+            	mShowProgressDialog = false;
+            	mCurrentMessage = null;
+            	updateViews(VIEW_SHOW_QUESTION);
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (!result.getBoolean()) {
+            		// TODO: db error handling
+            	}
+                String str = result.getString();
+                if (str != null) {
+                    if (str.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
+                    	mCurrentMessage = getResources().getString(R.string.card_unsuspended);
+                    } else if (str.equals("redo suspend")) {
+                    	mCurrentMessage = getResources().getString(R.string.card_suspended);
+                    }
+                    updateViews();
+                }
+            }
+        };
+
+
+        private DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	sLoadedDeck = null;
+            	sCard = null;
+            	mShowProgressDialog = false;
+            	mCurrentMessage = null;
+            	updateViews(VIEW_DECKS);
+            }
+        };
+
         @Override
         public void onStart(Intent intent, int startId) {
             Log.i(AnkiDroidApp.TAG, "BigWidget: OnStart");
@@ -214,30 +381,34 @@ public void onStart(Intent intent, int startId) {
 
             if (intent != null && intent.getAction() != null) {
             	String action = intent.getAction();
-            	if (ACTION_UPDATE.equals(action)) {
+            	if (ACTION_NOTHING.equals(action)) {
+			// do nothing
+            	} else if (action.startsWith(ACTION_UPDATE)) {
             		mShowProgressDialog = false;
-            		updateViews(intent.getIntExtra(EXTRA_CURRENT_VIEW, VIEW_NOT_SPECIFIED));
+            		int view;
+            		try {
+            			view = Integer.parseInt(action.substring(action.length() - 1));
+            		} catch (NumberFormatException e) {
+            			view = VIEW_NOT_SPECIFIED;
+            		}
+            		updateViews(view);
             	} else if (ACTION_OPENDECK.equals(action)) {
             		showProgressDialog();
-                	WidgetStatus.deckOperation(WidgetStatus.TASK_OPEN_DECK, new WidgetDeckTaskData(AnkiDroidWidgetBig.UpdateService.this, intent.getStringExtra(EXTRA_DECK_PATH)));
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(intent.getStringExtra(EXTRA_DECK_PATH)));
                 } else if (ACTION_CLOSEDECK.equals(action)) {
-                	showProgressDialog();
-                	if (sLoadedDeck != null) {
-                    	WidgetStatus.deckOperation(WidgetStatus.TASK_CLOSE_DECK, new WidgetDeckTaskData(this, sLoadedDeck.getDeckPath()));
-                	}
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(sLoadedDeck.getDeckPath()));
                 } else if (ACTION_UNDO.equals(action)) {
-                	showProgressDialog();
-                	WidgetStatus.deckOperation(WidgetStatus.TASK_UNDO, new WidgetDeckTaskData(this, sLoadedDeck));
+                	if (sLoadedDeck.undoAvailable()) {
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard.getId(), true));                		
+                	}
                 } else if (ACTION_BURY_CARD.equals(action)) {
-                	showProgressDialog();
-                	WidgetStatus.deckOperation(WidgetStatus.TASK_BURY_CARD, new WidgetDeckTaskData(this, sLoadedDeck, sCard));
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new DeckTask.TaskData(0, sLoadedDeck, sCard));
                 } else if (action.startsWith(ACTION_ANSWER)) {
                 	int ease = Integer.parseInt(action.substring(action.length() - 1));
                 	if (ease == 0) {
                 		updateViews(VIEW_SHOW_ANSWER);
                 	} else {
-                    	showProgressDialog();
-                    	WidgetStatus.deckOperation(WidgetStatus.TASK_ANSWER_CARD, new WidgetDeckTaskData(this, sLoadedDeck, sCard, ease));                		
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(ease, sLoadedDeck, sCard));
                 	}
                 } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
                 	Intent dialogIntent = new Intent(this, WidgetDialog.class);
@@ -248,7 +419,7 @@ public void onStart(Intent intent, int startId) {
                 	DeckManager.getDeck(intent.getData().getPath(), true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
                 	Intent newIntent = StudyOptions.getLoadDeckIntent(this, "");
                 	newIntent.removeExtra(StudyOptions.EXTRA_DECK);
-                	newIntent.putExtra(StudyOptions.EXTRA_START_REVIEWER, true);
+                	newIntent.putExtra(StudyOptions.EXTRA_START_REVIEWER, (mCurrentView != VIEW_NOTHING_DUE));
                 	startActivity(newIntent);
                 } else if (ACTION_CARDEDITOR.equals(action)) {
                     Intent editIntent = new Intent(this, CardEditor.class);
@@ -263,6 +434,10 @@ public void onStart(Intent intent, int startId) {
         }
 
 
+        private void hideProgressDialog() {
+        	mShowProgressDialog = false;
+        	updateViews();
+        }
         private void showProgressDialog() {
         	mShowProgressDialog = true;
         	updateViews();
@@ -283,7 +458,7 @@ private void updateViews() {
 
 
     	private RemoteViews buildUpdate(Context context) {
-            Log.i(AnkiDroidApp.TAG, "BigWidget: buildUpdate");
+            Log.i(AnkiDroidApp.TAG, "BigWidget: buildUpdate (" + mCurrentView + ")");
             Resources res = getResources();
             RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
 
@@ -294,11 +469,24 @@ private RemoteViews buildUpdate(Context context) {
             	mCurrentView = VIEW_NOTHING_DUE;
             }
 
+            PendingIntent doNothingIntent = getDoNothingPendingIntent(context);
+
+    		if (mCurrentMessage != null) {
+    			updateViews.setTextViewText(R.id.widget_big_message, mCurrentMessage);				
+    		} else {
+    			updateViews.setTextViewText(R.id.widget_big_message, "");				
+    		}
+
             if (mShowProgressDialog) {
             	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
+
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, doNothingIntent);
+
+            		disableCardAreaListeners(updateViews, false, doNothingIntent);
             } else {
             	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);            	
             }
@@ -310,14 +498,15 @@ private RemoteViews buildUpdate(Context context) {
         		updateViews.setTextViewText(R.id.widget_big_counts, "");
 
         		updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
-        		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getHelpPendingIntent(this));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, mCurrentView == VIEW_SHOW_HELP ? getUpdatePendingIntent(this, VIEW_DECKS) : getHelpPendingIntent(this));
         		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
 
         		updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
         		if (!mShowProgressDialog) {
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getShowDeckSelectionPendingIntent(context));        			
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getShowDeckSelectionPendingIntent(context));
+            		disableCardAreaListeners(updateViews, false, doNothingIntent);
         		}
 
         		updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
@@ -331,13 +520,6 @@ private RemoteViews buildUpdate(Context context) {
 
             case VIEW_SHOW_ANSWER:
             	if (!mShowProgressDialog) {
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_topleft, getOpenPendingIntent(this, sLoadedDeck.getDeckPath()));
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(context));
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(context, 1));
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(context));
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(context));
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(context, sCard.isRev() ? 3 : 2));            		
-
             		updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, getAnswerPendingIntent(context, 1));
             		updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, getAnswerPendingIntent(context, 2));
             		updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, getAnswerPendingIntent(context, 3));
@@ -355,7 +537,14 @@ private RemoteViews buildUpdate(Context context) {
             			updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.INVISIBLE);            			
             		}
             		updateViews.setViewVisibility(R.id.widget_big_empty, View.INVISIBLE);
-            	}
+        			enableCardAreaListeners(updateViews, false);
+        			updateViews.setTextViewText(R.id.widget_big_message, getNextTimeString(sCard));
+            	} else {
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_ease4, doNothingIntent);
+		}
 
             	updateViews.setTextViewText(R.id.widget_big_cardcontent,  Html.fromHtml(sCard.getQuestion() 
             			+ "<br><br>" 
@@ -368,8 +557,7 @@ private RemoteViews buildUpdate(Context context) {
                 		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getAnswerPendingIntent(context, 0));            			
                 		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.VISIBLE);            		
                 		updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);            		
-                		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(context, 0));
-                		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(context, 0));
+                		enableCardAreaListeners(updateViews, true);
             		}
 
             		updateViews.setTextViewText(R.id.widget_big_cardcontent,  Html.fromHtml(sCard.getQuestion())); 
@@ -379,7 +567,7 @@ private RemoteViews buildUpdate(Context context) {
         		updateViews.setTextViewText(R.id.widget_big_counts, getDeckStatusString(sLoadedDeck, sCard));
         		updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
         		if (!mShowProgressDialog) {
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));        			
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
         		}
         		updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
 
@@ -392,14 +580,14 @@ private RemoteViews buildUpdate(Context context) {
         		updateViews.setTextViewText(R.id.widget_big_counts, getDeckStatusString(sLoadedDeck, sCard));
 
         		if (!mShowProgressDialog) {
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(context));
-
             		updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
             		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
             		updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
             		updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
             		updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
-            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getShowDeckSelectionPendingIntent(context));            		
+
+            		disableCardAreaListeners(updateViews, true, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
         		}
 
         		updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
@@ -419,13 +607,15 @@ private RemoteViews buildUpdate(Context context) {
         		updateViews.setTextViewText(R.id.widget_big_topright, values[9]);
         		updateViews.setTextViewText(R.id.widget_big_middleright, values[7]);
         		updateViews.setTextViewText(R.id.widget_big_bottomright, values[5]);
-        		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getUpdatePendingIntent(this, VIEW_DECKS));
         		updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
         		updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
         		updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
         		updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
+			if (!mShowProgressDialog) {
+				disableCardAreaListeners(updateViews, false, doNothingIntent);
+			}
             } else {
         		updateViews.setTextViewText(R.id.widget_big_topleft, "");
         		updateViews.setTextViewText(R.id.widget_big_middleleft, "");
@@ -457,6 +647,23 @@ private RemoteViews buildUpdate(Context context) {
             return updateViews;
         }
 
+	private void disableCardAreaListeners(RemoteViews updateViews, boolean keepUndoOpening, PendingIntent doNothingIntent) {
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_topleft, keepUndoOpening ? getOpenPendingIntent(this, sLoadedDeck.getDeckPath()) : doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_topright, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, keepUndoOpening ? getUndoPendingIntent(this) : doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, doNothingIntent);
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, doNothingIntent);
+	}
+
+	private void enableCardAreaListeners(RemoteViews updateViews, boolean questionsShown) {
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_topleft, getOpenPendingIntent(this, sLoadedDeck.getDeckPath()));
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(this));
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, questionsShown ? 0 : 1));
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(this));
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
+            		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, questionsShown ? 0 : (sCard.isRev() ? 3 : 2)));
+	}
 
         private PendingIntent getAnswerPendingIntent(Context context, int ease) {
             Intent ankiDroidIntent = new Intent(context, UpdateService.class);
@@ -467,6 +674,7 @@ private PendingIntent getAnswerPendingIntent(Context context, int ease) {
         private PendingIntent getShowDeckSelectionPendingIntent(Context context) {
             Intent ankiDroidIntent = new Intent(context, WidgetDialog.class);
             ankiDroidIntent.setAction(WidgetDialog.ACTION_SHOW_DECK_SELECTION_DIALOG);
+            ankiDroidIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
             return PendingIntent.getActivity(context, 0, ankiDroidIntent, 0);
         }
 
@@ -509,8 +717,13 @@ private PendingIntent getHelpPendingIntent(Context context) {
 
         private PendingIntent getUpdatePendingIntent(Context context, int view) {
             Intent ankiDroidIntent = new Intent(context, UpdateService.class);
-            ankiDroidIntent.setAction(ACTION_UPDATE);
-            ankiDroidIntent.putExtra(EXTRA_CURRENT_VIEW, view);
+            ankiDroidIntent.setAction(ACTION_UPDATE + Integer.toString(view));
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getDoNothingPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_NOTHING);
             return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
         }
 
diff --git a/src/com/ichi2/widget/WidgetDialog.java b/src/com/ichi2/widget/WidgetDialog.java
index a1dc236776e0..1134beb7c66e 100644
--- a/src/com/ichi2/widget/WidgetDialog.java
+++ b/src/com/ichi2/widget/WidgetDialog.java
@@ -17,7 +17,6 @@
 
 package com.ichi2.widget;
 
-import com.ichi2.anki.AnkiDroidWidgetBig;
 import com.ichi2.anki.DeckManager;
 import com.ichi2.anki.R;
 import com.ichi2.themes.StyledDialog;
