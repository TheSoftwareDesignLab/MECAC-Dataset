diff --git a/.gitignore b/.gitignore
index 79b9441aaf66..b3947448422e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,7 @@
 local.properties
 bin/
 gen/
+/testbin/com/ichi2/anki/AllTests.class
+/testbin/com/ichi2/anki/AnkiDroidTest.class
+/test/com/ichi2/anki/AllTests.java
+/test/com/ichi2/anki/AnkiDroidTest.java
diff --git a/src/com/ichi2/anki/AnkiDroid.java b/src/com/ichi2/anki/AnkiDroid.java
index e783d4ba3fb9..50cdf6058664 100644
--- a/src/com/ichi2/anki/AnkiDroid.java
+++ b/src/com/ichi2/anki/AnkiDroid.java
@@ -262,7 +262,7 @@ public void onClick(View view)
 			DeckTask.launchDeckTask(
 					DeckTask.TASK_TYPE_ANSWER_CARD,
 					mAnswerCardHandler,
-					new DeckTask.TaskData(ease, AnkiDroidApp.deck(), currentCard));
+					new DeckTask.TaskData(ease, AnkiDroidApp.getDeck(), currentCard));
 		}
 	};
 
@@ -272,7 +272,7 @@ public void onClick(View view)
 		{
 			Log.i(TAG, "mButtonReviewEarlyHandler");
 			mButtonReviewEarly.setVisibility(View.GONE);
-			Deck d = AnkiDroidApp.deck();
+			Deck d = AnkiDroidApp.getDeck();
 			d.setReviewEarly(true);
 			currentCard = d.getCard();
 			if (currentCard != null){
@@ -285,7 +285,7 @@ public void onClick(View view)
 				mWhiteboard.clear();
 				mCardTimer.setBase(SystemClock.elapsedRealtime());
 				mCardTimer.start();
-				long timelimit = AnkiDroidApp.deck().getSessionTimeLimit() * 1000;
+				long timelimit = AnkiDroidApp.getDeck().getSessionTimeLimit() * 1000;
 				Log.i(TAG, "SessionTimeLimit: " + timelimit + " ms.");
 				mSessionTimeLimit = System.currentTimeMillis() + timelimit;
 				mSessionCurrReps = 0;
@@ -500,7 +500,7 @@ public boolean onOptionsItemSelected(MenuItem item)
 			mFlipCard.setChecked(true);
 			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, 
 					mAnswerCardHandler,
-					new DeckTask.TaskData(0, AnkiDroidApp.deck(), currentCard));
+					new DeckTask.TaskData(0, AnkiDroidApp.getDeck(), currentCard));
 		    return true;
         case MENU_EDIT:
             editorCard = currentCard;
@@ -518,8 +518,8 @@ public void openDeckPicker()
 	{
     	Log.i(TAG, "openDeckPicker - deckSelected = " + deckSelected);
     	
-    	if(AnkiDroidApp.deck() != null && sdCardAvailable)
-    		AnkiDroidApp.deck().closeDeck();
+    	if(AnkiDroidApp.getDeck() != null && sdCardAvailable)
+    		AnkiDroidApp.getDeck().closeDeck();
     	deckLoaded = false;
 		Intent decksPicker = new Intent(this, DeckPicker.class);
 		inDeckPicker = true;
@@ -529,8 +529,8 @@ public void openDeckPicker()
 
 	public void openSharedDeckPicker()
 	{
-    	if(AnkiDroidApp.deck() != null && sdCardAvailable)
-    		AnkiDroidApp.deck().closeDeck();
+    	if(AnkiDroidApp.getDeck() != null && sdCardAvailable)
+    		AnkiDroidApp.getDeck().closeDeck();
     	deckLoaded = false;
 		Intent intent = new Intent(AnkiDroid.this, SharedDeckPicker.class);
 		startActivityForResult(intent, GET_SHARED_DECK);
@@ -685,7 +685,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent intent)
             		    DeckTask.launchDeckTask(
                                 DeckTask.TASK_TYPE_UPDATE_FACT,
                                 mUpdateCardHandler,
-                                new DeckTask.TaskData(0, AnkiDroidApp.deck(), currentCard));
+                                new DeckTask.TaskData(0, AnkiDroidApp.getDeck(), currentCard));
             //TODO: code to save the changes made to the current card.
             mFlipCard.setChecked(true);
             displayCardQuestion();
@@ -938,8 +938,8 @@ private void updateCard(String content)
 		// Add CSS for font colour and font size
 		content = enrichWithCSSForFontColorSize(content
 				, fontSize
-				, currentCard.cardModel
-				, null);
+				, Model.getModel(currentCard.cardModelId, false)
+				, currentCard.cardModelId);
 
 		Log.i(TAG, "content card = \n" + content);
 		String card = cardTemplate.replace("::content::", content);
@@ -949,10 +949,35 @@ private void updateCard(String content)
 	
 	private final static String enrichWithCSSForFontColorSize(String htmlContent
 			, int defaultFontSize
-			, CardModel cardModel
-			, TreeSet<FieldModel> fieldModels) {
+			, Model myModel
+			, long myCardModelId) {
+		StringBuffer sb = new StringBuffer();
+		sb.append("<style type=\"text/css\">");
+		CardModel myCardModel = myModel.getCardModel(myCardModelId);
+		
+		//FIXME: start just for testing
+		myCardModel.lastFontColour = "#FFFF00"; //yellow
+		myCardModel.questionFontColour = "#FF0000"; //red
+		myCardModel.answerFontColour = "#00FF00"; //green
 		
-		return htmlContent;
+		//FIXME: end just for testing
+
+		//body background
+		if (null != myCardModel.lastFontColour && 0 < myCardModel.lastFontColour.trim().length()) {
+			sb.append("body {background-color:").append(myCardModel.lastFontColour).append(";}\n");
+		}
+		//question font color
+		if (null != myCardModel.questionFontColour && 0 < myCardModel.questionFontColour.trim().length()) {
+			sb.append(".").append(QUESTION_CLASS).append(" {color:").append(myCardModel.questionFontColour).append(";}\n");
+		}
+		//answer font color
+		if (null != myCardModel.answerFontColour && 0 < myCardModel.answerFontColour.trim().length()) {
+			sb.append(".").append(ANSWER_CLASS).append(" {color:").append(myCardModel.answerFontColour).append(";}\n");
+		}
+		//finish
+		sb.append("</style>");
+		sb.append(htmlContent);
+		return sb.toString();
 	}
 	
 	/**
@@ -1091,8 +1116,8 @@ public void onReceive(Context context, Intent intent) {
 
     private void closeExternalStorageFiles()
     {
-    	if(AnkiDroidApp.deck() != null)
-    		AnkiDroidApp.deck().closeDeck();
+    	if(AnkiDroidApp.getDeck() != null)
+    		AnkiDroidApp.getDeck().closeDeck();
     	deckLoaded = false;
     	displaySdError();
     }
@@ -1219,7 +1244,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
 		    mSessionCurrReps++; // increment number reps counter
 
 		    // Check to see if session rep or time limit has been reached
-		    Deck deck = AnkiDroidApp.deck();
+		    Deck deck = AnkiDroidApp.getDeck();
 		    long sessionRepLimit = deck.getSessionRepLimit();
 		    long sessionTime = deck.getSessionTimeLimit();
 		    Toast sessionMessage = null;
@@ -1288,7 +1313,7 @@ public void onPostExecute(DeckTask.TaskData result) {
 				case DECK_LOADED:
 					// Set the deck in the application instance, so other activities
 					// can access the loaded deck.
-				    AnkiDroidApp.setDeck( result.getDeck() );
+					AnkiDroidApp.setDeck( result.getDeck() );
 					currentCard = result.getCard();
 					showControls(true);
 					deckLoaded = true;
@@ -1299,7 +1324,7 @@ public void onPostExecute(DeckTask.TaskData result) {
 					mWhiteboard.clear();
 					mCardTimer.setBase(SystemClock.elapsedRealtime());
 					mCardTimer.start();
-					long timelimit = AnkiDroidApp.deck().getSessionTimeLimit() * 1000;
+					long timelimit = AnkiDroidApp.getDeck().getSessionTimeLimit() * 1000;
 					Log.i(TAG, "SessionTimeLimit: " + timelimit + " ms.");
 					mSessionTimeLimit = System.currentTimeMillis() + timelimit;
 					mSessionCurrReps = 0;
diff --git a/src/com/ichi2/anki/AnkiDroidApp.java b/src/com/ichi2/anki/AnkiDroidApp.java
index 8ca162589460..c15f35c40cb8 100644
--- a/src/com/ichi2/anki/AnkiDroidApp.java
+++ b/src/com/ichi2/anki/AnkiDroidApp.java
@@ -103,7 +103,7 @@ public static Resources getAppResources()
     	return instance.res;
     }
     
-    public static Deck deck()
+    public static Deck getDeck()
     {
         return instance.loadedDeck;
     }
diff --git a/src/com/ichi2/anki/Card.java b/src/com/ichi2/anki/Card.java
index ee7384567bfc..9c7a93b83f8a 100644
--- a/src/com/ichi2/anki/Card.java
+++ b/src/com/ichi2/anki/Card.java
@@ -86,7 +86,7 @@ public class Card {
     // END SQL table entries
 
     // BEGIN JOINed variables
-    CardModel cardModel;
+    private CardModel cardModel;
     Fact fact;
     // END JOINed variables
 
@@ -231,12 +231,11 @@ public boolean hasTag(String tag) {
         return true;
     }
     
-    public CardModel getCardModel()
-    {
-        CardModel returnModel = new CardModel();
-        returnModel.fromDb(cardModelId);
-        return returnModel;
-    }
+    //FIXME: Should be removed. Calling code should directly interact with Model
+	public CardModel getCardModel() {
+		Model myModel = Model.getModel(cardModelId, false);
+		return myModel.getCardModel(cardModelId);
+	}
 
     public boolean fromDB(long id) {
     	Cursor cursor = null;
diff --git a/src/com/ichi2/anki/CardModel.java b/src/com/ichi2/anki/CardModel.java
index 3c2e989a4f6d..c36643e374b4 100644
--- a/src/com/ichi2/anki/CardModel.java
+++ b/src/com/ichi2/anki/CardModel.java
@@ -16,7 +16,9 @@
 
 package com.ichi2.anki;
 
+import java.util.Comparator;
 import java.util.HashMap;
+import java.util.TreeMap;
 
 import android.database.Cursor;
 
@@ -28,7 +30,7 @@
  * 
  * @see http://ichi2.net/anki/wiki/ModelProperties#Card_Templates
  */
-public class CardModel {
+public class CardModel implements Comparator<CardModel> {
 
 	// TODO: Javadoc.
 	// TODO: Methods for reading/writing from/to DB.
@@ -94,29 +96,79 @@ public CardModel() {
 		this("", "q", "a", true);
 	}
 
-	public void fromDb(long id)
-	{
+	/** SELECT string with only those fields, which are used in AnkiDroid */
+	private final static String SELECT_STRING = "SELECT id, ordinal, modelId, name, description, active, qformat, aformat" //lformat left out
+		//qedformat, aedformat, questionInAnswer left out
+		+ ", questionFontColour" //questionFontFamily, questionFontSize, questionAlign left out
+		+ ", answerFontColour" //same as for question
+		+ ", lastFontColour" //lastFontFamily, lastFontSize left out
+		//rest left out
+		+ " FROM cardModels";
+
+	/**
+	 * 
+	 * @param modelId
+	 * @param active if true then only CardModels are returned, which currently are active
+	 * @param models will be changed by adding all found CardModels into it
+	 * @return unordered CardModels which are related to a given Model and eventually active put into the parameter "models"
+	 */
+	protected static final void fromDb(long modelId, boolean active, TreeMap<Long, CardModel> models) {
 		Cursor cursor = null;
+		CardModel myCardModel = null;
 		try {
-		    cursor = AnkiDb.database.rawQuery(
-	                "SELECT id, ordinal, modelId, name, description, qformat, " +
-	                "aformat " +
-	                "FROM cardModels " +
-	                "WHERE id = " +
-	                id,
-	                null);
+			StringBuffer query = new StringBuffer(SELECT_STRING);
+			query.append(" WHERE modelId = ");
+			query.append(modelId);
+			if (active) {
+				query.append(" AND active = 1");
+			}
+			
+			cursor = AnkiDb.database.rawQuery(query.toString(), null);
+
+			if (cursor.moveToFirst()) {
+				do {
+					myCardModel = new CardModel();
+					
+					myCardModel.id = cursor.getLong(0);
+					myCardModel.ordinal = cursor.getInt(1);
+					myCardModel.modelId = cursor.getLong(2);
+					myCardModel.name = cursor.getString(3);
+					myCardModel.description = cursor.getString(4);
+					myCardModel.active = cursor.getInt(5);
+					myCardModel.qformat = cursor.getString(6);
+					myCardModel.aformat = cursor.getString(7);
+					myCardModel.questionFontColour = cursor.getString(8);
+					myCardModel.answerFontColour = cursor.getString(9);
+					myCardModel.lastFontColour = cursor.getString(10);
+					models.put(myCardModel.id, myCardModel);
+				} while (cursor.moveToNext());
+			}
+		} finally {
+			if (cursor != null && !cursor.isClosed()) {
+				cursor.close();
+			}
+		}
+	}
 	
-		    cursor.moveToFirst();
-	        this.id = cursor.getLong(0);
-	        this.ordinal = cursor.getInt(1);
-	        this.modelId = cursor.getLong(2);
-	        this.name = cursor.getString(3);
-	        this.description = cursor.getString(4);
-	        this.qformat = cursor.getString(5);
-	        this.aformat = cursor.getString(6);
+	/**
+	 * 
+	 * @param cardModelId
+	 * @return the modelId for a given cardModel or 0, if it cannot be found
+	 */
+	protected static final long modelIdFromDB(long cardModelId) {
+		Cursor cursor = null;
+		long modelId = -1;
+		try {
+			String query = "SELECT modelId FROM cardModels WHERE id = " + cardModelId;
+			cursor = AnkiDb.database.rawQuery(query, null);
+			cursor.moveToFirst();
+			modelId = cursor.getLong(0);
 		} finally {
-			if (cursor != null) cursor.close();
+			if (cursor != null && !cursor.isClosed()) {
+				cursor.close();
+			}
 		}
+		return modelId;
 	}
 	
 	/**
@@ -200,4 +252,14 @@ private static String replaceField(String replaceFrom, Fact fact, int replaceAt,
         }
         return replaceFrom;
     }
+    
+	/**
+	 * Implements Comparator by comparing the field "ordinal".
+	 * @param object1
+	 * @param object2
+	 * @return 
+	 */
+	public int compare(CardModel object1, CardModel object2) {
+		return object1.ordinal - object2.ordinal;
+	}
 }
diff --git a/src/com/ichi2/anki/DeckPreferences.java b/src/com/ichi2/anki/DeckPreferences.java
index fdc310a84734..64f6c21d2236 100644
--- a/src/com/ichi2/anki/DeckPreferences.java
+++ b/src/com/ichi2/anki/DeckPreferences.java
@@ -53,12 +53,12 @@ public DeckPreferenceHack()
         protected void cacheValues()
         {
         	Log.i(TAG, "DeckPreferences - CacheValues");
-            values.put( "newCardsPDay", String.valueOf( AnkiDroidApp.deck().getNewCardsPerDay() ) );
-            values.put( "sessionQLimit", String.valueOf( AnkiDroidApp.deck().getSessionRepLimit() ) );
-            values.put( "sessionTLimit", String.valueOf( AnkiDroidApp.deck().getSessionTimeLimit()/60 ) );
-            values.put( "newCardOrder", String.valueOf( AnkiDroidApp.deck().getNewCardOrder() ) );
-            values.put( "newCardSpacing", String.valueOf( AnkiDroidApp.deck().getNewCardSpacing() ) );
-            values.put( "revCardOrder", String.valueOf( AnkiDroidApp.deck().getRevCardOrder() ) );
+            values.put( "newCardsPDay", String.valueOf( AnkiDroidApp.getDeck().getNewCardsPerDay() ) );
+            values.put( "sessionQLimit", String.valueOf( AnkiDroidApp.getDeck().getSessionRepLimit() ) );
+            values.put( "sessionTLimit", String.valueOf( AnkiDroidApp.getDeck().getSessionTimeLimit()/60 ) );
+            values.put( "newCardOrder", String.valueOf( AnkiDroidApp.getDeck().getNewCardOrder() ) );
+            values.put( "newCardSpacing", String.valueOf( AnkiDroidApp.getDeck().getNewCardSpacing() ) );
+            values.put( "revCardOrder", String.valueOf( AnkiDroidApp.getDeck().getRevCardOrder() ) );
         }
 
         public class Editor implements SharedPreferences.Editor
@@ -84,27 +84,27 @@ public boolean commit()
                 {
                     if ( entry.getKey().equals( "newCardsPDay" ) )
                     {
-                        AnkiDroidApp.deck().setNewCardsPerDay( Integer.parseInt( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setNewCardsPerDay( Integer.parseInt( entry.getValue().toString() ) );
                     }
                     else if ( entry.getKey().equals( "sessionQLimit" ) )
                     {
-                        AnkiDroidApp.deck().setSessionRepLimit( Long.parseLong( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setSessionRepLimit( Long.parseLong( entry.getValue().toString() ) );
                     }
                     else if ( entry.getKey().equals( "sessionTLimit" ) )
                     {
-                        AnkiDroidApp.deck().setSessionTimeLimit( 60 * Long.parseLong( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setSessionTimeLimit( 60 * Long.parseLong( entry.getValue().toString() ) );
                     }
                     else if( entry.getKey().equals( "newCardOrder" ))
                     {
-                        AnkiDroidApp.deck().setNewCardOrder( Integer.parseInt( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setNewCardOrder( Integer.parseInt( entry.getValue().toString() ) );
                     }
                     else if( entry.getKey().equals( "newCardSpacing" ))
                     {
-                        AnkiDroidApp.deck().setNewCardSpacing( Integer.parseInt( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setNewCardSpacing( Integer.parseInt( entry.getValue().toString() ) );
                     }
                     else if( entry.getKey().equals( "revCardOrder" ))
                     {
-                        AnkiDroidApp.deck().setRevCardOrder( Integer.parseInt( entry.getValue().toString() ) );
+                        AnkiDroidApp.getDeck().setRevCardOrder( Integer.parseInt( entry.getValue().toString() ) );
                     }
                 }
                 // make sure we refresh the parent cached values
@@ -229,7 +229,7 @@ public void onCreate( Bundle icicle )
     {
         super.onCreate( icicle );
 
-        if ( AnkiDroidApp.deck() == null )
+        if ( AnkiDroidApp.getDeck() == null )
         {
             Log.i( TAG, "DeckPreferences - Selected Deck is NULL" );
             finish();
diff --git a/src/com/ichi2/anki/FieldModel.java b/src/com/ichi2/anki/FieldModel.java
index 3b571d8576b2..9e9482009c0d 100644
--- a/src/com/ichi2/anki/FieldModel.java
+++ b/src/com/ichi2/anki/FieldModel.java
@@ -16,11 +16,13 @@
 
 package com.ichi2.anki;
 
+import java.util.Comparator;
+
 /**
  * Fields are the different pieces of data which make up a fact. 
  * @see http://ichi2.net/anki/wiki/ModelProperties#Fields
  */
-public class FieldModel {
+public class FieldModel implements Comparator<FieldModel> {
 
 	// BEGIN SQL table entries
 	long id;
@@ -85,5 +87,15 @@ public FieldModel copy() {
 
 		return fieldModel;
 	}
+	
+	/**
+	 * Implements Comparator by comparing the field "ordinal".
+	 * @param object1
+	 * @param object2
+	 * @return 
+	 */
+	public int compare(FieldModel object1, FieldModel object2) {
+		return object1.ordinal - object2.ordinal;
+	}
 
 }
diff --git a/src/com/ichi2/anki/Model.java b/src/com/ichi2/anki/Model.java
index cc0390de9dec..388833e2ef4f 100644
--- a/src/com/ichi2/anki/Model.java
+++ b/src/com/ichi2/anki/Model.java
@@ -16,15 +16,34 @@
 
 package com.ichi2.anki;
 
-import java.util.Comparator;
+import java.util.TreeMap;
 import java.util.TreeSet;
 
+import android.database.Cursor;
+
 /**
  * Anki model.
  * A model describes the type of information you want to input, and the type of cards which should be generated.
  * See http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Models
+ * There can be several models in a Deck.
+ * A Model is related to a Deck via attribute deckId.
+ * A CardModel is related to a Model via CardModel's modelId.
+ * A FieldModel is related to a Model via FieldModel's modelId
+ * A Card has a link to CardModel via Card's cardModelId
+ * A Card has a link to a Fact via Card's factId
+ * A Field has a link to a Fact via Field's factId
+ * A Field has a link to a FieldModel via Field's fieldModelId
+ * => In order to get the CardModel and all FieldModels for a given Card:
+ *     % the CardModel can directly be retrieved from the DB using the Card's cardModelId
+ *     % then from the retrieved CardModel we can get the modelId
+ *     % using the modelId we can get all FieldModels from the DB
+ *     % (alternatively in the CardModel the qformat and aformat fields could be parsed for relevant field names and 
+ *     then this used to only get the necessary fields. But this adds a lot overhead vs. using a bit more memory)
  */
 public class Model {
+	
+	/** Singleton */
+	private static Model currentModel;
 
 	// TODO: Javadoc.
 	// TODO: Methods for reading/writing from/to DB.
@@ -44,18 +63,24 @@ public class Model {
 	// BEGIN SQL table entries
 
 	// BEGIN JOINed entries
-	TreeSet<FieldModel> fieldModels;
-	TreeSet<CardModel> cardModels;
+	TreeSet<FieldModel> fieldModels; //FIXME: is this used at all?
+	TreeSet<CardModel> cardModels; //FIXME: is this used at all?
 	// END JOINed entries
+	
+	/** Map for convenience and speed which contains CardModels from current model */
+	private TreeMap<Long, CardModel> cardModelsMap = new TreeMap<Long, CardModel>();
+	
+	/** Map for convenience and speed which contains FieldModels from current model */
+	private TreeMap<Long, FieldModel> fieldModelsMap = new TreeMap<Long, FieldModel>();
 
-	public Model(String name) {
-		this.fieldModels = new TreeSet<FieldModel>(new FieldModelOrdinalComparator());
-		this.cardModels = new TreeSet<CardModel>(new CardModelOrdinalComparator());
+	private Model(String name) {
+		this.fieldModels = new TreeSet<FieldModel>();
+		this.cardModels = new TreeSet<CardModel>();
 		this.name = name;
 		this.id = Utils.genID();
 	}
 
-	public Model() {
+	private Model() {
 		this("");
 	}
 
@@ -74,18 +99,84 @@ public void addCardModel(CardModel card) {
 		this.cardModels.add(card);
 		//this.toDB();
 	}
-
-
-	public static final class FieldModelOrdinalComparator implements Comparator<FieldModel> {
-		public int compare(FieldModel object1, FieldModel object2) {
-			return object1.ordinal - object2.ordinal;
+	
+	/**
+	 * Returns a Model based on the submitted identifier.
+	 * If a model id is submitted (isModelId = true), then the Model data and all related CardModel and FieldModel data are loaded,
+	 * unless the id is the same as one of the currentModel.
+	 * If a cardModel id is submitted, then the related Model data and all related CardModel and FieldModel data are loaded
+	 * unless the cardModel id is already in the cardModel map.
+	 * FIXME: nothing is done to treat db failure or non-existing identifiers
+	 * @param identifier a cardModel id or a model id
+	 * @param isModelId if true then the submitted identifier is a model id; otherwise the identifier is a cardModel id
+	 * @return
+	 */
+	protected static Model getModel(long identifier, boolean isModelId) {
+		if (false == isModelId) {
+			//check whether the identifier is in the cardModelsMap
+			if (null == currentModel || currentModel.cardModelsMap.containsKey(identifier)) {
+				//get the modelId
+				long myModelId = CardModel.modelIdFromDB(identifier);
+				//get the model
+				loadFromDBPlusRelatedModels(myModelId);
+			}
+		} else {
+			if (null == currentModel || currentModel.id != identifier) {
+				//get the model
+				loadFromDBPlusRelatedModels(identifier);
+			}
 		}
+		return currentModel;
+	}
+	
+	protected final CardModel getCardModel(long identifier) {
+		return cardModelsMap.get(identifier);
+	}
+	
+	private static final void loadFromDBPlusRelatedModels(long modelId) {
+		currentModel = fromDb(modelId);
+		//load related card models
+		CardModel.fromDb(currentModel.id, true, currentModel.cardModelsMap);
+		//load related field models
+		//SELECT id FROM fieldmodels where modelid = -4541298410707851455
 	}
+	
+	/**
+	 * Loads a model from the database based on the id
+	 * FIXME: nothing is done in case of db error or no returned row
+	 * @param id
+	 * @return
+	 */
+	private static final Model fromDb(long id) {
+		Cursor cursor = null;
+		Model model = null;
+		try {
+			StringBuffer query = new StringBuffer();
+			query.append("SELECT id, deckId, created, modified, tags, name, description");
+			query.append(", features, spacing, initialSpacing, source");
+			query.append(" FROM models");
+			query.append(" WHERE id = ").append(id);
+			cursor = AnkiDb.database.rawQuery(query.toString(), null);
 
-	public static final class CardModelOrdinalComparator implements Comparator<CardModel> {
-		public int compare(CardModel object1, CardModel object2) {
-			return object1.ordinal - object2.ordinal;
+			cursor.moveToFirst();
+			model = new Model();
+			
+			model.id = cursor.getLong(0); // Primary key
+			model.deckId = cursor.getLong(1); // Foreign key
+			model.created = cursor.getDouble(2);
+			model.modified = cursor.getDouble(3);
+			model.tags = cursor.getString(4);
+			model.name = cursor.getString(5);
+			model.description = cursor.getString(6);
+			model.features = cursor.getString(7);
+			model.spacing = cursor.getDouble(8);
+			model.initialSpacing = cursor.getDouble(9);
+			model.source = cursor.getInt(10);
+		} finally {
+			if (cursor != null)
+				cursor.close();
 		}
+		return model;
 	}
 
 }
