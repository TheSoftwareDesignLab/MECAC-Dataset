diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/FieldEditLineTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/FieldEditLineTest.kt
index 0f36b8845588..7e63e70b1d6d 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/FieldEditLineTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/FieldEditLineTest.kt
@@ -57,8 +57,8 @@ class FieldEditLineTest : NoteEditorTest() {
 
     private fun fieldEditLine(): FieldEditLine {
         val reference = AtomicReference<FieldEditLine>()
-        activityRule!!.scenario.onActivity { noteEditor: NoteEditor? ->
-            reference.set(FieldEditLine(noteEditor!!))
+        activityRule!!.scenario.onActivity { activity ->
+            reference.set(FieldEditLine(activity.baseContext))
         }
         return reference.get()
     }
diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorIntentTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorIntentTest.kt
index beb68a081af4..43cf6c94daa6 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorIntentTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorIntentTest.kt
@@ -15,15 +15,15 @@
  */
 package com.ichi2.anki
 
-import android.content.ComponentName
 import android.content.Intent
+import android.os.Bundle
 import androidx.lifecycle.Lifecycle
-import androidx.test.core.app.ActivityScenario
 import androidx.test.ext.junit.rules.ActivityScenarioRule
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.NoteEditor.Companion.intentLaunchedWithImage
 import com.ichi2.anki.tests.InstrumentedTest
 import com.ichi2.anki.testutil.GrantStoragePermission
+import com.ichi2.anki.testutil.getEditor
 import com.ichi2.testutils.common.Flaky
 import com.ichi2.testutils.common.OS
 import com.ichi2.utils.AssetHelper.TEXT_PLAIN
@@ -34,7 +34,6 @@ import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestRule
 import org.junit.runner.RunWith
-import java.util.concurrent.atomic.AtomicReference
 
 @RunWith(AndroidJUnit4::class)
 class NoteEditorIntentTest : InstrumentedTest() {
@@ -42,7 +41,7 @@ class NoteEditorIntentTest : InstrumentedTest() {
     var runtimePermissionRule: TestRule? = GrantStoragePermission.instance
 
     @get:Rule
-    var activityRuleIntent: ActivityScenarioRule<NoteEditor>? = ActivityScenarioRule(
+    var activityRuleIntent: ActivityScenarioRule<SingleFragmentActivity>? = ActivityScenarioRule(
         noteEditorTextIntent
     )
 
@@ -53,10 +52,12 @@ class NoteEditorIntentTest : InstrumentedTest() {
         val scenario = activityRuleIntent!!.scenario
         scenario.moveToState(Lifecycle.State.RESUMED)
 
-        onActivity(scenario) { editor ->
-            val currentFieldStrings = editor.currentFieldStrings
-            MatcherAssert.assertThat(currentFieldStrings[0], Matchers.equalTo("sample text"))
+        var currentFieldStrings: String? = null
+        scenario.onActivity { activity ->
+            val editor = activity.getEditor()
+            currentFieldStrings = editor.currentFieldStrings[0]
         }
+        MatcherAssert.assertThat(currentFieldStrings!![0], Matchers.equalTo("sample text"))
     }
 
     @Test
@@ -70,26 +71,11 @@ class NoteEditorIntentTest : InstrumentedTest() {
 
     private val noteEditorTextIntent: Intent
         get() {
-            return Intent(testContext, NoteEditor::class.java).apply {
-                component = ComponentName(testContext, NoteEditor::class.java)
-                action = Intent.ACTION_SEND
-                putExtra(Intent.EXTRA_TEXT, "sample text")
+            val bundle = Bundle().apply {
+                putString(Intent.EXTRA_TEXT, "sample text")
             }
+            val intent = NoteEditor.getIntent(testContext, bundle)
+            intent.action = Intent.ACTION_SEND
+            return intent
         }
-
-    @Throws(Throwable::class)
-    private fun onActivity(
-        scenario: ActivityScenario<NoteEditor>,
-        noteEditorActivityAction: ActivityScenario.ActivityAction<NoteEditor>
-    ) {
-        val wrapped = AtomicReference<Throwable?>(null)
-        scenario.onActivity { a: NoteEditor ->
-            try {
-                noteEditorActivityAction.perform(a)
-            } catch (t: Throwable) {
-                wrapped.set(t)
-            }
-        }
-        wrapped.get()?.let { throw it }
-    }
 }
diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTabOrderTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTabOrderTest.kt
index a7e74c315531..19d1f159793c 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTabOrderTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTabOrderTest.kt
@@ -15,19 +15,16 @@
  */
 package com.ichi2.anki
 
-import android.app.Activity
 import android.view.KeyEvent
 import android.view.inputmethod.BaseInputConnection
 import androidx.lifecycle.Lifecycle
-import androidx.test.core.app.ActivityScenario
-import androidx.test.core.app.ActivityScenario.ActivityAction
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.ichi2.anki.testutil.onNoteEditor
 import org.hamcrest.MatcherAssert.assertThat
 import org.hamcrest.Matchers.equalTo
 import org.junit.Ignore
 import org.junit.Test
 import org.junit.runner.RunWith
-import java.util.concurrent.atomic.AtomicReference
 
 @RunWith(AndroidJUnit4::class)
 class NoteEditorTabOrderTest : NoteEditorTest() {
@@ -52,43 +49,25 @@ class NoteEditorTabOrderTest : NoteEditorTest() {
         val scenario = activityRule!!.scenario
         scenario.moveToState(Lifecycle.State.RESUMED)
 
-        onActivity(scenario) { editor: NoteEditor ->
+        scenario.onNoteEditor { editor ->
             sendKeyDownUp(editor, KeyEvent.KEYCODE_A)
             sendKeyDownUp(editor, KeyEvent.KEYCODE_TAB)
             sendKeyDownUp(editor, KeyEvent.KEYCODE_TAB)
             sendKeyDownUp(editor, KeyEvent.KEYCODE_B)
         }
 
-        onActivity(scenario) { editor: NoteEditor ->
+        scenario.onNoteEditor { editor ->
             val currentFieldStrings = editor.currentFieldStrings
             assertThat(currentFieldStrings[0], equalTo("a"))
             assertThat(currentFieldStrings[1], equalTo("b"))
         }
     }
 
-    private fun sendKeyDownUp(activity: Activity, keyCode: Int) {
-        val focusedView = activity.currentFocus
-        if (focusedView != null) {
-            val inputConnection = BaseInputConnection(focusedView, true)
-            inputConnection.sendKeyEvent(KeyEvent(KeyEvent.ACTION_DOWN, keyCode))
-            inputConnection.sendKeyEvent(KeyEvent(KeyEvent.ACTION_UP, keyCode))
-        }
-    }
-
-    @Throws(Throwable::class)
-    private fun onActivity(
-        scenario: ActivityScenario<NoteEditor>,
-        noteEditorActivityAction: ActivityAction<NoteEditor>
-    ) {
-        val wrapped = AtomicReference<Throwable?>(null)
-        scenario.onActivity { a: NoteEditor ->
-            try {
-                noteEditorActivityAction.perform(a)
-            } catch (t: Throwable) {
-                wrapped.set(t)
-            }
-        }
-        wrapped.get()?.let { throw it }
+    private fun sendKeyDownUp(editor: NoteEditor, keyCode: Int) {
+        val focusedView = editor.requireActivity().currentFocus ?: return
+        val inputConnection = BaseInputConnection(focusedView, true)
+        inputConnection.sendKeyEvent(KeyEvent(KeyEvent.ACTION_DOWN, keyCode))
+        inputConnection.sendKeyEvent(KeyEvent(KeyEvent.ACTION_UP, keyCode))
     }
 
     private fun ensureCollectionLoaded() {
diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTest.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTest.kt
index d641935eeabc..dbdf297e5386 100644
--- a/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTest.kt
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/NoteEditorTest.kt
@@ -15,10 +15,10 @@
  */
 package com.ichi2.anki
 
-import android.content.ComponentName
 import android.content.Context
 import android.content.Intent
 import android.os.Build
+import android.os.Bundle
 import androidx.test.ext.junit.rules.ActivityScenarioRule
 import androidx.test.platform.app.InstrumentationRegistry
 import com.ichi2.anki.testutil.GrantStoragePermission
@@ -35,16 +35,16 @@ abstract class NoteEditorTest protected constructor() {
     var runtimePermissionRule: TestRule? = GrantStoragePermission.instance
 
     @get:Rule
-    var activityRule: ActivityScenarioRule<NoteEditor>? = ActivityScenarioRule(
+    var activityRule: ActivityScenarioRule<SingleFragmentActivity>? = ActivityScenarioRule(
         noteEditorIntent
     )
 
     private val noteEditorIntent: Intent
         get() {
-            return Intent(targetContext, NoteEditor::class.java).apply {
-                component = ComponentName(targetContext, NoteEditor::class.java)
-                putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+            val bundle = Bundle().apply {
+                putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
             }
+            return NoteEditor.getIntent(targetContext, bundle)
         }
 
     @Before
diff --git a/AnkiDroid/src/androidTest/java/com/ichi2/anki/testutil/NoteEditor.kt b/AnkiDroid/src/androidTest/java/com/ichi2/anki/testutil/NoteEditor.kt
new file mode 100644
index 000000000000..8998585e4957
--- /dev/null
+++ b/AnkiDroid/src/androidTest/java/com/ichi2/anki/testutil/NoteEditor.kt
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (c) 2024 David Allison <davidallisongithub@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free Software
+ *  Foundation; either version 3 of the License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.anki.testutil
+
+import androidx.test.core.app.ActivityScenario
+import com.ichi2.anki.NoteEditor
+import com.ichi2.anki.R
+import com.ichi2.anki.SingleFragmentActivity
+import java.util.concurrent.atomic.AtomicReference
+
+/**
+ * Executes a block of code with the NoteEditor fragment on the activity's main thread.
+ * @param block The block of code to execute with the NoteEditor fragment.
+ * @throws Throwable if any exception is thrown during the execution of the block.
+ */
+@Throws(Throwable::class)
+fun ActivityScenario<SingleFragmentActivity>.onNoteEditor(
+    block: (NoteEditor) -> Unit
+) {
+    val wrapped = AtomicReference<Throwable?>(null)
+    this.onActivity { activity: SingleFragmentActivity ->
+        try {
+            val editor = activity.getEditor()
+            activity.runOnUiThread {
+                try {
+                    block(editor)
+                } catch (t: Throwable) {
+                    wrapped.set(t)
+                }
+            }
+        } catch (t: Throwable) {
+            wrapped.set(t)
+        }
+    }
+    wrapped.get()?.let { throw it }
+}
+
+/**
+ * Extension function for SingleFragmentActivity to find the NoteEditor fragment
+ */
+fun SingleFragmentActivity.getEditor(): NoteEditor {
+    return supportFragmentManager.findFragmentById(R.id.fragment_container) as NoteEditor
+}
diff --git a/AnkiDroid/src/main/AndroidManifest.xml b/AnkiDroid/src/main/AndroidManifest.xml
index 77d9594bccf3..cff14262f7c2 100644
--- a/AnkiDroid/src/main/AndroidManifest.xml
+++ b/AnkiDroid/src/main/AndroidManifest.xml
@@ -367,7 +367,7 @@
             android:name="com.ichi2.anki.AnkiCardContextMenuAction"
             android:label="@string/context_menu_anki_card_label"
             android:enabled="true"
-            android:targetActivity=".NoteEditor"
+            android:targetActivity=".IntentHandler2"
             android:exported="true">
             <intent-filter>
                 <action android:name="android.intent.action.PROCESS_TEXT" />
@@ -376,7 +376,7 @@
             </intent-filter>
         </activity-alias>
         <activity
-            android:name="com.ichi2.anki.NoteEditor"
+            android:name="com.ichi2.anki.IntentHandler2"
             android:label="@string/fact_adder_intent_title"
             android:theme="@style/Theme_Dark.Launcher"
             android:exported="true"
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractIntentHandler.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractIntentHandler.kt
new file mode 100644
index 000000000000..2e85a68a3891
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractIntentHandler.kt
@@ -0,0 +1,35 @@
+/****************************************************************************************
+ * Copyright (c) 2024 Sanjay Sargam <sargamsanjaykumar@gmail.com>                          *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.anki
+
+import android.app.Activity
+import android.os.Bundle
+import com.ichi2.themes.Themes
+import com.ichi2.themes.Themes.disableXiaomiForceDarkMode
+
+/**
+ * This class is an abstract base class that extends Activity and provides common initialization logic for [IntentHandler] and [IntentHandler2].
+ * By centralizing common setup tasks here, it promotes code reuse.
+ */
+abstract class AbstractIntentHandler : Activity() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        Themes.setTheme(this)
+        disableXiaomiForceDarkMode(this)
+        setContentView(R.layout.progress_bar)
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AnkiActivity.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AnkiActivity.kt
index bef6d77cd8df..147c815c515b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AnkiActivity.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AnkiActivity.kt
@@ -82,13 +82,6 @@ open class AnkiActivity : AppCompatActivity, SimpleMessageDialogListener {
         activityName = javaClass.simpleName
     }
 
-    // This functions will remain here only for a single commit to ensure moving to fragment require little code change
-    fun requireContext(): AnkiActivity = this
-
-    fun requireActivity(): AnkiActivity = this
-
-    fun requireArguments(): Bundle = intent.extras!!
-
     @Suppress("deprecation") // #9332: UI Visibility -> Insets
     override fun onCreate(savedInstanceState: Bundle?) {
         // The hardware buttons should control the music volume
@@ -305,7 +298,7 @@ open class AnkiActivity : AppCompatActivity, SimpleMessageDialogListener {
     }
 
     /** The action to take when there was an error loading the collection  */
-    protected fun onCollectionLoadError() {
+    fun onCollectionLoadError() {
         val deckPicker = Intent(this, DeckPicker::class.java)
         deckPicker.putExtra("collectionLoadError", true) // don't currently do anything with this
         deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
@@ -333,6 +326,15 @@ open class AnkiActivity : AppCompatActivity, SimpleMessageDialogListener {
         }
     }
 
+    /**
+     * Opens a URL in a custom tab, with fallback to a browser if no custom tab implementation is available.
+     *
+     * This method first checks if there is a web browser available on the device. If no browser is found,
+     * a snackbar message is displayed informing the user. If a browser is available, a custom tab is
+     * opened with customized appearance and animations.
+     *
+     * @param url The URI to be opened.
+     */
     @KotlinCleanup("toast -> snackbar")
     open fun openUrl(url: Uri) {
         if (!AdaptionUtil.hasWebBrowser(this)) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AnkiFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AnkiFragment.kt
new file mode 100644
index 000000000000..1c34f059cd9b
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AnkiFragment.kt
@@ -0,0 +1,221 @@
+/*
+ Copyright (c) 2024 Sanjay Sargam <sargamsanjaykumar@gmail.com>
+
+ This program is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free Software
+ Foundation; either version 3 of the License, or (at your option) any later
+ version.
+
+ This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License along with
+ this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki
+
+import android.content.BroadcastReceiver
+import android.net.Uri
+import android.os.Bundle
+import android.view.Menu
+import android.view.View
+import androidx.annotation.AttrRes
+import androidx.annotation.IdRes
+import androidx.annotation.LayoutRes
+import androidx.annotation.StringRes
+import androidx.appcompat.widget.ThemeUtils
+import androidx.appcompat.widget.Toolbar
+import androidx.fragment.app.DialogFragment
+import androidx.fragment.app.Fragment
+import com.ichi2.async.CollectionLoader
+import com.ichi2.libanki.Collection
+import com.ichi2.utils.increaseHorizontalPaddingOfOverflowMenuIcons
+import com.ichi2.utils.tintOverflowMenuIcons
+import timber.log.Timber
+
+/**
+ * Base class for fragments in the AnkiDroid.
+ * This class provides common functionality and convenience methods for all fragments that extend it.
+ *
+ * Why Extend AnkiFragment:
+ * - **Consistency**: Provides a consistent setup for fragments, ensuring they all handle common tasks in the same way.
+ * - **Helper Methods**: Contains helper methods to reduce boilerplate code in descendant classes.
+ * - **Common Initialization**: Ensures fragments have consistent initialization, such as setting navigation bar colors or checking storage permissions.
+ *
+ * @param layout Resource ID of the layout to be used for this fragment.
+ */
+// TODO: Consider refactoring to create AnkiInterface to consolidate common implementations between AnkiFragment and AnkiActivity.
+//  This could help reduce code repetition and improve maintainability.
+open class AnkiFragment(@LayoutRes layout: Int) : Fragment(layout) {
+
+    val getColUnsafe: Collection
+        get() = CollectionManager.getColUnsafe()
+
+    val ankiActivity: AnkiActivity
+        get() = requireAnkiActivity()
+
+    val mainToolbar: Toolbar
+        get() = requireView().findViewById(R.id.toolbar)
+
+    // Open function: These can be overridden to react to specific parts of the lifecycle
+
+    /**
+     * Callback for [startLoadingCollection], executed once the collection is available.
+     */
+    protected open fun onCollectionLoaded(col: Collection) {
+        hideProgressBar()
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        requireActivity().window.statusBarColor = ThemeUtils.getThemeAttrColor(requireContext(), R.attr.appBarColor)
+        super.onViewCreated(view, savedInstanceState)
+    }
+
+    // Helper functions: These make fragment code shorter
+
+    /**
+     * Check whether animation is enabled
+     *
+     * @see AnkiActivity.animationEnabled
+     */
+    protected fun animationEnabled() = ankiActivity.animationEnabled()
+
+    /**
+     * Open `url` in a custom tab or in a browser.
+     *
+     * @see AnkiActivity.openUrl
+     */
+    protected fun openUrl(url: Uri) = ankiActivity.openUrl(url)
+
+    /**
+     * Checks whether we are allowed to change the schema
+     *
+     * @see AnkiActivity.userAcceptsSchemaChange
+     */
+    protected suspend fun userAcceptsSchemaChange() = ankiActivity.userAcceptsSchemaChange()
+
+    fun setNavigationBarColor(@AttrRes attr: Int) {
+        requireActivity().window.navigationBarColor = ThemeUtils.getThemeAttrColor(requireContext(), attr)
+    }
+
+    /**
+     * Finds a view in the fragment's layout by the specified ID.
+     *
+     */
+    fun <T : View> findViewById(@IdRes id: Int): T {
+        return requireView().findViewById(id)
+    }
+
+    /**
+     * Hides progress bar.
+     */
+    private fun hideProgressBar() = ankiActivity.hideProgressBar()
+
+    /**
+     * Shows progress bar.
+     */
+    private fun showProgressBar() = ankiActivity.showProgressBar()
+
+    /**
+     * Unregisters a previously registered broadcast receiver.
+     *
+     * @param unmountReceiver The BroadcastReceiver instance to unregister.
+     */
+    protected fun unregisterReceiver(unmountReceiver: BroadcastReceiver?) {
+        requireActivity().unregisterReceiver(unmountReceiver)
+    }
+
+    /**
+     * Increases the horizontal padding of overflow menu icons in the given Menu.
+     *
+     * @see AnkiActivity.increaseHorizontalPaddingOfOverflowMenuIcons
+     */
+    protected fun increaseHorizontalPaddingOfOverflowMenuIcons(menu: Menu) {
+        requireContext().increaseHorizontalPaddingOfOverflowMenuIcons(menu)
+    }
+
+    /**
+     * Sets color to icons of overflow menu items in given Menu.
+     *
+     * @see AnkiActivity.tintOverflowMenuIcons
+     */
+    protected fun tintOverflowMenuIcons(menu: Menu) {
+        requireContext().tintOverflowMenuIcons(menu)
+    }
+
+    /**
+     * Invalidates the options menu, causing it to be recreated.
+     */
+    protected fun invalidateMenu() {
+        requireActivity().invalidateMenu()
+    }
+
+    /**
+     * Sets the title of the toolbar.
+     *
+     */
+    protected fun setTitle(@StringRes title: Int) {
+        mainToolbar.setTitle(title)
+    }
+
+    /**
+     * Starts loading the Anki collection asynchronously if it hasn't been opened yet.
+     * If the collection is already open, calls `onCollectionLoaded` synchronously.
+     * Shows a progress bar during loading.
+     */
+    protected fun startLoadingCollection() {
+        Timber.d("AnkiFragment.startLoadingCollection()")
+        if (CollectionManager.isOpenUnsafe()) {
+            Timber.d("Synchronously calling onCollectionLoaded")
+            onCollectionLoaded(getColUnsafe)
+            return
+        }
+        // Open collection asynchronously if it hasn't already been opened
+        showProgressBar()
+        CollectionLoader.load(
+            this
+        ) { col: Collection? ->
+            if (col != null) {
+                Timber.d("Asynchronously calling onCollectionLoaded")
+                onCollectionLoaded(col)
+            } else {
+                ankiActivity.onCollectionLoadError()
+            }
+        }
+    }
+
+    /**
+     * Method to show dialog fragment including adding it to back stack
+     *
+     * @see AnkiActivity.showDialogFragment
+     */
+    protected open fun showDialogFragment(newFragment: DialogFragment) = ankiActivity.showDialogFragment(newFragment)
+
+    /**
+     * Run the provided operation, showing a progress window with the provided
+     * message until the operation completes.
+     */
+    protected suspend fun <T> Fragment.withProgress(
+        message: String = resources.getString(R.string.dialog_processing),
+        block: suspend () -> T
+    ): T =
+        requireActivity().withProgress(message, block)
+
+    /**
+     * If storage permissions are not granted, shows a toast message and finishes the activity.
+     *
+     * This should be called AFTER a call to `super.`[onCreate]
+     *
+     * @return `true`: activity may continue to start, `false`: [onCreate] should stop executing
+     * as storage permissions are mot granted
+     */
+    protected fun ensureStoragePermissions(): Boolean {
+        if (IntentHandler.grantedStoragePermissions(requireContext(), showToast = true)) {
+            return true
+        }
+        Timber.w("finishing activity. No storage permission")
+        requireActivity().finish()
+        return false
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.kt b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.kt
index 4390ea6c9073..dc67224284cb 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.kt
@@ -2222,13 +2222,14 @@ open class CardBrowser :
 
         @VisibleForTesting
         fun createAddNoteIntent(context: Context, viewModel: CardBrowserViewModel): Intent {
-            val intent = Intent(context, NoteEditor::class.java)
-            intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD)
-            if (viewModel.lastDeckId?.let { id -> id > 0 } == true) {
-                intent.putExtra(NoteEditor.EXTRA_DID, viewModel.lastDeckId)
+            val bundle = Bundle().apply {
+                putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD)
+                if (viewModel.lastDeckId?.let { id -> id > 0 } == true) {
+                    putLong(NoteEditor.EXTRA_DID, viewModel.lastDeckId!!)
+                }
+                putString(NoteEditor.EXTRA_TEXT_FROM_SEARCH_VIEW, viewModel.searchTerms)
             }
-            intent.putExtra(NoteEditor.EXTRA_TEXT_FROM_SEARCH_VIEW, viewModel.searchTerms)
-            return intent
+            return NoteEditor.getIntent(context, bundle)
         }
 
         @CheckResult
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt b/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
index 1c8b4aa4a7b8..db405ca527f6 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CoroutineHelpers.kt
@@ -487,6 +487,12 @@ suspend fun AnkiActivity.userAcceptsSchemaChange(col: Collection): Boolean {
     }
 }
 
+/**
+ * Returns whether we are allowed to change the schema.
+ *
+ * If changing the schema would require the next sync to be a full sync, and it's not already required, ask
+ * the user whether or not they still allow the schema change.
+ */
 suspend fun AnkiActivity.userAcceptsSchemaChange(): Boolean {
     if (withCol { schemaChanged() }) {
         return true
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index 9ac5248a0acd..f0acbb89a6d4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -1511,8 +1511,10 @@ open class DeckPicker :
     }
 
     fun addNote() {
-        val intent = Intent(this@DeckPicker, NoteEditor::class.java)
-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+        val bundle = Bundle().apply {
+            putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+        }
+        val intent = NoteEditor.getIntent(this, bundle)
         startActivity(intent)
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckSpinnerSelection.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckSpinnerSelection.kt
index 9de5cb98d252..aab7566afda8 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckSpinnerSelection.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckSpinnerSelection.kt
@@ -63,10 +63,9 @@ class DeckSpinnerSelection(
     private val spinner: Spinner,
     private val showAllDecks: Boolean,
     private val alwaysShowDefault: Boolean,
-    private val showFilteredDecks: Boolean
-) {
-
+    private val showFilteredDecks: Boolean,
     private val fragmentManagerSupplier: FragmentManagerSupplier = context.asFragmentManagerSupplier()
+) {
 
     private var deckDropDownAdapter: DeckDropDownAdapter? = null
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ImageOcclusionIntentBuilder.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ImageOcclusionIntentBuilder.kt
index 045964b6e149..39a7992780fa 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ImageOcclusionIntentBuilder.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ImageOcclusionIntentBuilder.kt
@@ -19,15 +19,17 @@ package com.ichi2.anki
 import android.content.Context
 import android.content.Intent
 import android.net.Uri
+import android.os.Bundle
 /**
  * Builder class for creating intents related to image occlusion in the [NoteEditor].
  */
 class ImageOcclusionIntentBuilder(private val context: Context) {
 
     fun buildIntent(imageUri: Uri?): Intent {
-        return Intent(context, NoteEditor::class.java).apply {
-            putExtra(NoteEditor.EXTRA_IMG_OCCLUSION, imageUri)
-            putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_IMG_OCCLUSION)
+        val bundle = Bundle().apply {
+            putParcelable(NoteEditor.EXTRA_IMG_OCCLUSION, imageUri)
+            putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_IMG_OCCLUSION)
         }
+        return NoteEditor.getIntent(context, bundle)
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler.kt b/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler.kt
index e765dc4c91a5..89307dd06981 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler.kt
@@ -16,7 +16,6 @@
 
 package com.ichi2.anki
 
-import android.app.Activity
 import android.content.Context
 import android.content.Intent
 import android.net.Uri
@@ -34,8 +33,6 @@ import com.ichi2.anki.servicelayer.ScopedStorageService
 import com.ichi2.anki.services.ReminderService
 import com.ichi2.anki.worker.SyncWorker
 import com.ichi2.annotations.NeedsTest
-import com.ichi2.themes.Themes
-import com.ichi2.themes.Themes.disableXiaomiForceDarkMode
 import com.ichi2.utils.FileUtil
 import com.ichi2.utils.ImportUtils.handleFileImport
 import com.ichi2.utils.ImportUtils.isInvalidViewIntent
@@ -54,16 +51,14 @@ import kotlin.math.min
 /**
  * Class which handles how the application responds to different intents, forcing it to always be single task,
  * but allowing custom behavior depending on the intent
+ * It inherits from [AbstractIntentHandler]
  *
  * @author Tim
  */
-class IntentHandler : Activity() {
+class IntentHandler : AbstractIntentHandler() {
     override fun onCreate(savedInstanceState: Bundle?) {
         // Note: This is our entry point from the launcher with intent: android.intent.action.MAIN
         super.onCreate(savedInstanceState)
-        Themes.setTheme(this)
-        disableXiaomiForceDarkMode(this)
-        setContentView(R.layout.progress_bar)
         val intent = intent
         Timber.v(intent.toString())
         val reloadIntent = Intent(this, DeckPicker::class.java)
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler2.kt b/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler2.kt
new file mode 100644
index 000000000000..bb6ba9728041
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/IntentHandler2.kt
@@ -0,0 +1,41 @@
+/****************************************************************************************
+ * Copyright (c) 2024 Sanjay Sargam <sargamsanjaykumar@gmail.com>                          *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.anki
+
+import android.os.Bundle
+import timber.log.Timber
+
+/**
+ * This activity serves as an intermediate handler to process various types of intents and forward them to the NoteEditor fragment hosted within the SingleFragmentActivity.
+ *
+ * The main reason for using this IntentHandler2 is to avoid conflicts in the manifest file. We can't have multiple
+ * ACTION_SEND intents in same activity (IntentHandler) that only differ by their labels. By using this handler, we can manage these intents
+ * and make sure they are sent to the NoteEditor correctly.
+ */
+class IntentHandler2 : AbstractIntentHandler() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        if (NoteEditor.intentLaunchedWithImage(intent)) {
+            Timber.i("Intent contained an image")
+            intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_ADD_IMAGE)
+        }
+        val noteEditorIntent = NoteEditor.getIntent(this, intent.extras!!, intent.action)
+        noteEditorIntent.setDataAndType(intent.data, intent.type)
+        startActivity(noteEditorIntent)
+        finish()
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/NavigationDrawerActivity.kt b/AnkiDroid/src/main/java/com/ichi2/anki/NavigationDrawerActivity.kt
index 961eae2fbfed..9d0eac4f7cf3 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/NavigationDrawerActivity.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/NavigationDrawerActivity.kt
@@ -440,7 +440,7 @@ abstract class NavigationDrawerActivity :
                 .build()
 
             // Add Shortcut
-            val intentAddNote = Intent(context, NoteEditor::class.java)
+            val intentAddNote = Intent(context, IntentHandler2::class.java)
             intentAddNote.action = Intent.ACTION_VIEW
             intentAddNote.flags = Intent.FLAG_ACTIVITY_CLEAR_TASK
             intentAddNote.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.kt b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.kt
index 890852b1c833..1d0037b45df0 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.kt
@@ -19,6 +19,7 @@
 package com.ichi2.anki
 
 import android.annotation.SuppressLint
+import android.app.Activity
 import android.content.BroadcastReceiver
 import android.content.ClipData
 import android.content.ClipboardManager
@@ -63,9 +64,9 @@ import androidx.appcompat.widget.PopupMenu
 import androidx.appcompat.widget.TooltipCompat
 import androidx.core.content.ContextCompat
 import androidx.core.content.FileProvider
-import androidx.core.content.IntentCompat
 import androidx.core.content.edit
 import androidx.core.content.res.ResourcesCompat
+import androidx.core.os.BundleCompat
 import androidx.core.text.HtmlCompat
 import androidx.core.view.isVisible
 import androidx.lifecycle.lifecycleScope
@@ -99,7 +100,6 @@ import com.ichi2.anki.multimediacard.impl.MultimediaEditableNote
 import com.ichi2.anki.noteeditor.CustomToolbarButton
 import com.ichi2.anki.noteeditor.FieldState
 import com.ichi2.anki.noteeditor.FieldState.FieldChangeType
-import com.ichi2.anki.noteeditor.Toolbar
 import com.ichi2.anki.noteeditor.Toolbar.TextFormatListener
 import com.ichi2.anki.noteeditor.Toolbar.TextWrapper
 import com.ichi2.anki.pages.ImageOcclusion
@@ -114,6 +114,7 @@ import com.ichi2.anki.snackbar.SnackbarBuilder
 import com.ichi2.anki.snackbar.showSnackbar
 import com.ichi2.anki.ui.setupNoteTypeSpinner
 import com.ichi2.anki.utils.ext.isImageOcclusion
+import com.ichi2.anki.utils.ext.sharedPrefs
 import com.ichi2.anki.utils.getTimestamp
 import com.ichi2.anki.widgets.DeckDropDownAdapter.SubtitleListener
 import com.ichi2.annotations.NeedsTest
@@ -167,17 +168,22 @@ import kotlin.collections.ArrayList
 import kotlin.math.max
 import kotlin.math.min
 import kotlin.math.roundToInt
+import androidx.appcompat.widget.Toolbar as MainToolbar
+import com.ichi2.anki.noteeditor.Toolbar as Toolbar
 
 /**
  * Allows the user to edit a note, for instance if there is a typo. A card is a presentation of a note, and has two
  * sides: a question and an answer. Any number of fields can appear on each side. When you add a note to Anki, cards
  * which show that note are generated. Some models generate one card, others generate more than one.
+ * Features:
+ * - Implements [MainToolbar.OnMenuItemClickListener] to handle toolbar menu item clicks.
+ * - Implements [DispatchKeyEventListener] to handle key events.
  *
  * @see [the Anki Desktop manual](https://docs.ankiweb.net/getting-started.html.cards)
  */
 @KotlinCleanup("Go through the class and select elements to fix")
 @KotlinCleanup("see if we can lateinit")
-class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, TagsDialogListener, BaseSnackbarBuilderProvider {
+class NoteEditor : AnkiFragment(R.layout.note_editor), DeckSelectionListener, SubtitleListener, TagsDialogListener, BaseSnackbarBuilderProvider, MainToolbar.OnMenuItemClickListener, DispatchKeyEventListener {
     /** Whether any change are saved. E.g. multimedia, new card added, field changed and saved. */
     private var changed = false
     private var isTagsEdited = false
@@ -241,14 +247,13 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
 
     // save field index as key and text as value when toggle sticky clicked in Field Edit Text
     private var toggleStickyText: HashMap<Int, String?> = HashMap()
-    private val onboarding = Onboarding.NoteEditor(this)
 
     var clipboard: ClipboardManager? = null
 
     private val requestAddLauncher = registerForActivityResult(
         ActivityResultContracts.StartActivityForResult(),
         NoteEditorActivityResultCallback {
-            if (it.resultCode != RESULT_CANCELED) {
+            if (it.resultCode != Activity.RESULT_CANCELED) {
                 changed = true
             }
         }
@@ -258,7 +263,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         ActivityResultContracts.StartActivityForResult(),
         @NeedsTest("test to guard against changes in the REQUEST_MULTIMEDIA_EDIT clause preventing text fields to be updated")
         NoteEditorActivityResultCallback { result ->
-            if (result.resultCode != RESULT_CANCELED) {
+            if (result.resultCode != Activity.RESULT_CANCELED) {
                 val col = getColUnsafe
                 val extras = result.data!!.extras ?: return@NoteEditorActivityResultCallback
                 val index = extras.getInt(MultimediaEditFieldActivity.EXTRA_RESULT_FIELD_INDEX)
@@ -328,7 +333,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
     private val requestIOEditorCloser = registerForActivityResult(
         ActivityResultContracts.StartActivityForResult(),
         NoteEditorActivityResultCallback { result ->
-            if (result.resultCode != RESULT_CANCELED) {
+            if (result.resultCode != Activity.RESULT_CANCELED) {
                 changed = true
                 if (!addNote) {
                     reloadRequired = true
@@ -414,17 +419,10 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
     // ----------------------------------------------------------------------------
     @KotlinCleanup("fix suppress")
     override fun onCreate(savedInstanceState: Bundle?) {
-        if (showedActivityFailedScreen(savedInstanceState)) {
-            return
-        }
-        tagsDialogFactory = TagsDialogFactory(this).attachToActivity<TagsDialogFactory>(this)
+        tagsDialogFactory = TagsDialogFactory(this).attachToFragmentManager<TagsDialogFactory>(parentFragmentManager)
         mediaRegistration = MediaRegistration(requireContext())
         super.onCreate(savedInstanceState)
-        if (!ensureStoragePermissions()) {
-            return
-        }
         fieldState.setInstanceState(savedInstanceState)
-        setContentView(R.layout.note_editor)
         val intent = requireActivity().intent
         if (savedInstanceState != null) {
             caller = savedInstanceState.getInt("caller")
@@ -438,10 +436,6 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
                 savedInstanceState.getSerializableCompat<HashMap<Int, String?>>("toggleSticky")!!
             changed = savedInstanceState.getBoolean(NOTE_CHANGED_EXTRA_KEY)
         } else {
-            if (intentLaunchedWithImage(intent)) {
-                Timber.i("Intent contained an image")
-                requireArguments().putInt(EXTRA_CALLER, CALLER_ADD_IMAGE)
-            }
             caller = requireArguments().getInt(EXTRA_CALLER, CALLER_NO_CALLER)
             if (caller == CALLER_NO_CALLER) {
                 val action = intent.action
@@ -450,6 +444,10 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
                 }
             }
         }
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
         // Set up toolbar
         toolbar = findViewById(R.id.editor_toolbar)
         toolbar.apply {
@@ -467,10 +465,9 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
             )
             setIconColor(MaterialColors.getColor(requireContext(), R.attr.toolbarIconColor, 0))
         }
-        val mainView = findViewById<View>(android.R.id.content)
-        // Enable toolbar
-        enableToolbar(mainView)
         startLoadingCollection()
+        // Onboarding must be initialised after creating view
+        val onboarding = Onboarding.NoteEditor(this)
         onboarding.onCreate()
         // TODO this callback doesn't handle predictive back navigation!
         // see #14678, added to temporarily fix for a bug
@@ -480,12 +477,30 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         }
 
         setNavigationBarColor(R.attr.toolbarBackgroundColor)
+
+        // R.id.home is handled in setNavigationOnClickListener
+        // Set a listener for back button clicks in the toolbar
+        mainToolbar.setNavigationOnClickListener {
+            Timber.i("NoteEditor:: Back button on the menu was pressed")
+            requireActivity().onBackPressedDispatcher.onBackPressed()
+        }
+
+        configureMainToolbar()
     }
 
     @NeedsTest("Test when the user directly passes image to the edit note field")
+    /**
+     * Handles the intent for sharing an image to the NoteEditor.
+     *
+     * This method is invoked when an image is shared from the gallery using the "Add Image" option.
+     * It extracts the image URI from the intent data and then opens the multimedia field editor to
+     * add the image to a new note.
+     *
+     * @param data The intent containing the image data.
+     */
     private fun handleImageIntent(data: Intent) {
         val imageUri = if (data.action == Intent.ACTION_SEND) {
-            IntentCompat.getParcelableExtra(data, Intent.EXTRA_STREAM, Uri::class.java)
+            BundleCompat.getParcelable(requireArguments(), Intent.EXTRA_STREAM, Uri::class.java)
         } else {
             data.data
         }
@@ -520,7 +535,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
     private val fieldsAsBundleForPreview: Bundle
         get() = NoteService.getFieldsAsBundleForPreview(editFields, shouldReplaceNewlines())
 
-    // Finish initializing the activity after the collection has been correctly loaded
+    // Finish initializing the fragment after the collection has been correctly loaded
     override fun onCollectionLoaded(col: Collection) {
         super.onCollectionLoaded(col)
         val intent = requireActivity().intent
@@ -600,7 +615,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
                         }
                     }
                 imageOcclusionBottomSheet.show(
-                    supportFragmentManager,
+                    parentFragmentManager,
                     "ImageOcclusionBottomSheetFragment"
                 )
             }
@@ -648,7 +663,8 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
                 findViewById(R.id.note_deck_spinner),
                 showAllDecks = false,
                 alwaysShowDefault = true,
-                showFilteredDecks = false
+                showFilteredDecks = false,
+                fragmentManagerSupplier = { childFragmentManager }
             )
         deckSpinnerSelection!!.initializeNoteEditorDeckSpinner(col)
         deckId = requireArguments().getLong(EXTRA_DID, deckId)
@@ -732,7 +748,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
 
         if (caller == CALLER_IMG_OCCLUSION) {
             // val saveImageUri = ImageIntentManager.getImageUri()
-            val saveImageUri = IntentCompat.getParcelableExtra(intent, EXTRA_IMG_OCCLUSION, Uri::class.java)
+            val saveImageUri = BundleCompat.getParcelable(requireArguments(), EXTRA_IMG_OCCLUSION, Uri::class.java)
             if (saveImageUri != null) {
                 ImportUtils.getFileCachedCopy(requireContext(), saveImageUri)?.let { path ->
                     setupImageOcclusionEditor(path)
@@ -826,13 +842,16 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
 
     override fun onStop() {
         super.onStop()
-        if (!isFinishing) {
+        if (!isRemoving) {
             WidgetStatus.updateInBackground(requireContext())
         }
     }
 
     @KotlinCleanup("convert KeyUtils to extension functions")
-    override fun onKeyUp(keyCode: Int, event: KeyEvent): Boolean {
+    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
+        // We want to behave as onKeyUp and thus only react to ACTION_UP
+        if (event.action != KeyEvent.ACTION_UP) return false
+        val keyCode = event.keyCode
         if (toolbar.onKeyUp(keyCode, event)) {
             // Toolbar was able to handle this key event. No need to handle it in NoteEditor too.
             return true
@@ -885,14 +904,14 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
 
         // 7573: Ctrl+Shift+[Num] to select a field
         if (event.isCtrlPressed && event.isShiftPressed) {
-            val digit = KeyUtils.getDigit(event) ?: return super.onKeyUp(keyCode, event)
+            val digit = KeyUtils.getDigit(event) ?: return false
             // '0' is after '9' on the keyboard, so a user expects '10'
             val humanReadableDigit = if (digit == 0) 10 else digit
             // Subtract 1 to map to field index. '1' is the first field (index 0)
             selectFieldIndex(humanReadableDigit - 1)
             return true
         }
-        return super.onKeyUp(keyCode, event)
+        return false
     }
 
     private fun selectFieldIndex(index: Int) {
@@ -1201,8 +1220,13 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         updateToolbar()
     }
 
-    override fun onCreateOptionsMenu(menu: Menu): Boolean {
-        menuInflater.inflate(R.menu.note_editor, menu)
+    /**
+     * Configures the main toolbar with the appropriate menu items and their visibility based on the current state.
+     */
+    private fun configureMainToolbar() {
+        mainToolbar.setOnMenuItemClickListener(this)
+        mainToolbar.inflateMenu(R.menu.note_editor)
+        val menu = mainToolbar.menu
         if (addNote) {
             menu.findItem(R.id.action_copy_note).isVisible = false
             val iconVisible = allowSaveAndPreview()
@@ -1225,10 +1249,9 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         menu.findItem(R.id.action_show_toolbar).isChecked =
             !shouldHideToolbar()
         menu.findItem(R.id.action_capitalize).isChecked =
-            this.sharedPrefs().getBoolean(PREF_NOTE_EDITOR_CAPITALIZE, true)
+            sharedPrefs().getBoolean(PREF_NOTE_EDITOR_CAPITALIZE, true)
         menu.findItem(R.id.action_scroll_toolbar).isChecked =
-            this.sharedPrefs().getBoolean(PREF_NOTE_EDITOR_SCROLL_TOOLBAR, true)
-        return super.onCreateOptionsMenu(menu)
+            sharedPrefs().getBoolean(PREF_NOTE_EDITOR_SCROLL_TOOLBAR, true)
     }
 
     /**
@@ -1241,13 +1264,8 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         else -> true
     }
 
-    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+    override fun onMenuItemClick(item: MenuItem): Boolean {
         when (item.itemId) {
-            android.R.id.home -> {
-                Timber.i("NoteEditor:: Home button pressed")
-                closeCardEditorWithCheck()
-                return true
-            }
             R.id.action_preview -> {
                 Timber.i("NoteEditor:: Preview button pressed")
                 if (allowSaveAndPreview()) {
@@ -1301,7 +1319,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
                 updateToolbar()
             }
         }
-        return super.onOptionsItemSelected(item)
+        return false
     }
 
     private fun toggleCapitalize(value: Boolean) {
@@ -1341,20 +1359,22 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
     }
 
     fun copyNote() {
-        openNewNoteEditor { intent: Intent ->
-            intent.putExtra(EXTRA_CONTENTS, fieldsText)
+        openNewNoteEditor { bundle: Bundle ->
+            bundle.putString(EXTRA_CONTENTS, fieldsText)
             if (selectedTags != null) {
-                intent.putExtra(EXTRA_TAGS, selectedTags!!.toTypedArray())
+                bundle.putStringArray(EXTRA_TAGS, selectedTags!!.toTypedArray())
             }
         }
     }
 
-    private fun openNewNoteEditor(intentEnricher: Consumer<Intent>) {
-        val intent = Intent(this@NoteEditor, NoteEditor::class.java)
-        intent.putExtra(EXTRA_CALLER, CALLER_NOTEEDITOR)
-        intent.putExtra(EXTRA_DID, deckId)
+    private fun openNewNoteEditor(intentEnricher: Consumer<Bundle>) {
+        val bundle = Bundle().apply {
+            putInt(EXTRA_CALLER, CALLER_NOTEEDITOR)
+            putLong(EXTRA_DID, deckId)
+        }
+        val intent = getIntent(requireContext(), bundle)
         // mutate event with additional properties
-        intentEnricher.accept(intent)
+        intentEnricher.accept(bundle)
         requestAddLauncher.launch(intent)
     }
 
@@ -1410,7 +1430,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
             }
             val iFilter = IntentFilter()
             iFilter.addAction(SdCardReceiver.MEDIA_EJECT)
-            registerReceiverCompat(unmountReceiver, iFilter, ContextCompat.RECEIVER_EXPORTED)
+            requireContext().registerReceiverCompat(unmountReceiver, iFilter, ContextCompat.RECEIVER_EXPORTED)
         }
     }
 
@@ -1436,9 +1456,9 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
 
     private fun closeNoteEditor(intent: Intent = Intent()) {
         val result: Int = if (changed) {
-            RESULT_OK
+            Activity.RESULT_OK
         } else {
-            RESULT_CANCELED
+            Activity.RESULT_CANCELED
         }
         if (reloadRequired) {
             intent.putExtra(RELOAD_REQUIRED_EXTRA_KEY, true)
@@ -1460,13 +1480,13 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
             CardTemplateNotetype.clearTempModelFiles()
 
             // Set the finish animation if there is one on the intent which created the activity
-            val animation = IntentCompat.getParcelableExtra(
-                this.intent,
-                FINISH_ANIMATION_EXTRA,
+            val animation = BundleCompat.getParcelable(
+                requireArguments(),
+                AnkiActivity.FINISH_ANIMATION_EXTRA,
                 ActivityTransitionAnimation.Direction::class.java
             )
             if (animation != null) {
-                finishWithAnimation(animation)
+                ankiActivity.finishWithAnimation(animation)
             } else {
                 finish()
             }
@@ -1936,7 +1956,7 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
     }
 
     @KotlinCleanup("remove 'requireNoNulls'")
-    private val fieldsText: String
+    val fieldsText: String
         get() {
             val fields = arrayOfNulls<String>(editFields!!.size)
             for (i in editFields!!.indices) {
@@ -2499,8 +2519,8 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
         const val EXTRA_DID = "DECK_ID"
         const val EXTRA_TEXT_FROM_SEARCH_VIEW = "SEARCH"
         const val EXTRA_EDIT_FROM_CARD_ID = "editCid"
-        private const val ACTION_CREATE_FLASHCARD = "org.openintents.action.CREATE_FLASHCARD"
-        private const val ACTION_CREATE_FLASHCARD_SEND = "android.intent.action.SEND"
+        const val ACTION_CREATE_FLASHCARD = "org.openintents.action.CREATE_FLASHCARD"
+        const val ACTION_CREATE_FLASHCARD_SEND = "android.intent.action.SEND"
         const val NOTE_CHANGED_EXTRA_KEY = "noteChanged"
         const val RELOAD_REQUIRED_EXTRA_KEY = "reloadRequired"
         const val EXTRA_IMG_OCCLUSION = "image_uri"
@@ -2545,5 +2565,9 @@ class NoteEditor : AnkiActivity(), DeckSelectionListener, SubtitleListener, Tags
             return !AnkiDroidApp.instance.sharedPrefs()
                 .getBoolean(PREF_NOTE_EDITOR_SHOW_TOOLBAR, true)
         }
+
+        fun getIntent(context: Context, arguments: Bundle, action: String? = null): Intent {
+            return SingleFragmentActivity.getIntent(context, NoteEditor::class, arguments, action)
+        }
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
index c29787aa6a9a..8305705ffc19 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
@@ -685,10 +685,12 @@ open class Reviewer :
     }
 
     fun addNote(fromGesture: Gesture? = null) {
-        val intent = Intent(this, NoteEditor::class.java)
         val animation = getAnimationTransitionFromGesture(fromGesture)
-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD)
-        intent.putExtra(FINISH_ANIMATION_EXTRA, getInverseTransition(animation) as Parcelable)
+        val bundle = Bundle().apply {
+            putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD)
+            putParcelable(FINISH_ANIMATION_EXTRA, getInverseTransition(animation) as Parcelable)
+        }
+        val intent = NoteEditor.getIntent(this, bundle)
         addNoteLauncher.launch(intent)
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/SingleFragmentActivity.kt b/AnkiDroid/src/main/java/com/ichi2/anki/SingleFragmentActivity.kt
index e66e0bcb4c7a..31930a4babb0 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/SingleFragmentActivity.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/SingleFragmentActivity.kt
@@ -42,6 +42,9 @@ open class SingleFragmentActivity : AnkiActivity() {
             return
         }
         super.onCreate(savedInstanceState)
+        if (!ensureStoragePermissions()) {
+            return
+        }
         setContentView(R.layout.single_fragment_activity)
         setTransparentStatusBar()
 
@@ -75,10 +78,11 @@ open class SingleFragmentActivity : AnkiActivity() {
         const val FRAGMENT_NAME_EXTRA = "fragmentName"
         const val FRAGMENT_ARGS_EXTRA = "fragmentArgs"
 
-        fun getIntent(context: Context, fragmentClass: KClass<out Fragment>, arguments: Bundle? = null): Intent {
+        fun getIntent(context: Context, fragmentClass: KClass<out Fragment>, arguments: Bundle? = null, intentAction: String? = null): Intent {
             return Intent(context, SingleFragmentActivity::class.java).apply {
                 putExtra(FRAGMENT_NAME_EXTRA, fragmentClass.jvmName)
                 putExtra(FRAGMENT_ARGS_EXTRA, arguments)
+                action = intentAction
             }
         }
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/instantnoteeditor/InstantNoteEditorActivity.kt b/AnkiDroid/src/main/java/com/ichi2/anki/instantnoteeditor/InstantNoteEditorActivity.kt
index 9a5b577ddaea..c196c6c99021 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/instantnoteeditor/InstantNoteEditorActivity.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/instantnoteeditor/InstantNoteEditorActivity.kt
@@ -183,10 +183,11 @@ class InstantNoteEditorActivity : AnkiActivity(), DeckSelectionDialog.DeckSelect
 
     private fun openNoteEditor() {
         val sharedText = clozeEditTextField.text.toString()
-        val noteEditorIntent = Intent(this, NoteEditor::class.java).apply {
-            putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.INSTANT_NOTE_EDITOR)
-            putExtra(Intent.EXTRA_TEXT, sharedText)
+        val bundle = Bundle().apply {
+            putInt(NoteEditor.EXTRA_CALLER, NoteEditor.INSTANT_NOTE_EDITOR)
+            putString(Intent.EXTRA_TEXT, sharedText)
         }
+        val noteEditorIntent = NoteEditor.getIntent(this, bundle)
         startActivity(noteEditorIntent)
         finish()
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/noteeditor/EditCardDestination.kt b/AnkiDroid/src/main/java/com/ichi2/anki/noteeditor/EditCardDestination.kt
index 02083698eebc..322d99e2e637 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/noteeditor/EditCardDestination.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/noteeditor/EditCardDestination.kt
@@ -18,6 +18,7 @@ package com.ichi2.anki.noteeditor
 
 import android.content.Context
 import android.content.Intent
+import android.os.Bundle
 import android.os.Parcelable
 import androidx.annotation.CheckResult
 import com.ichi2.anim.ActivityTransitionAnimation
@@ -34,9 +35,10 @@ data class EditCardDestination(val cardId: CardId)
 
 @CheckResult
 fun EditCardDestination.toIntent(context: Context, animation: ActivityTransitionAnimation.Direction): Intent {
-    return Intent(context, NoteEditor::class.java).apply {
-        putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_EDIT)
-        putExtra(NoteEditor.EXTRA_CARD_ID, cardId)
-        putExtra(AnkiActivity.FINISH_ANIMATION_EXTRA, animation as Parcelable)
+    val bundle = Bundle().apply {
+        putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_EDIT)
+        putLong(NoteEditor.EXTRA_CARD_ID, cardId)
+        putParcelable(AnkiActivity.FINISH_ANIMATION_EXTRA, animation as Parcelable)
     }
+    return NoteEditor.getIntent(context, bundle)
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/previewer/PreviewerHelpers.kt b/AnkiDroid/src/main/java/com/ichi2/anki/previewer/PreviewerHelpers.kt
index 1275355d22f9..3b426e1fc066 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/previewer/PreviewerHelpers.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/previewer/PreviewerHelpers.kt
@@ -18,6 +18,7 @@ package com.ichi2.anki.previewer
 import android.R
 import android.content.Context
 import android.content.Intent
+import android.os.Bundle
 import com.google.android.material.color.MaterialColors
 import com.ichi2.anki.AnkiDroidApp
 import com.ichi2.anki.LanguageUtils
@@ -27,11 +28,11 @@ import com.ichi2.utils.toRGBHex
 import org.intellij.lang.annotations.Language
 
 class NoteEditorDestination(val cardId: Long) {
-    fun toIntent(context: Context): Intent =
-        Intent(context, NoteEditor::class.java).apply {
-            putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_PREVIEWER_EDIT)
-            putExtra(NoteEditor.EXTRA_EDIT_FROM_CARD_ID, cardId)
-        }
+    val bundle = Bundle().apply {
+        putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_PREVIEWER_EDIT)
+        putLong(NoteEditor.EXTRA_EDIT_FROM_CARD_ID, cardId)
+    }
+    fun toIntent(context: Context): Intent = NoteEditor.getIntent(context, bundle)
 }
 
 /**
diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/AddNoteWidget.kt b/AnkiDroid/src/main/java/com/ichi2/widget/AddNoteWidget.kt
index 2ae04f270504..33d709a3a0f4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/widget/AddNoteWidget.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/widget/AddNoteWidget.kt
@@ -17,7 +17,7 @@ package com.ichi2.widget
 import android.appwidget.AppWidgetManager
 import android.appwidget.AppWidgetProvider
 import android.content.Context
-import android.content.Intent
+import android.os.Bundle
 import android.widget.RemoteViews
 import androidx.core.app.PendingIntentCompat
 import com.ichi2.anki.IntentHandler
@@ -63,8 +63,10 @@ class AddNoteWidget : AppWidgetProvider() {
             appWidgetIds: IntArray
         ) {
             val remoteViews = RemoteViews(context.packageName, R.layout.widget_add_note)
-            val intent = Intent(context, NoteEditor::class.java)
-            intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+            val bundle = Bundle().apply {
+                putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+            }
+            val intent = NoteEditor.getIntent(context, bundle)
             val pendingIntent = PendingIntentCompat.getActivity(context, 0, intent, 0, false)
             remoteViews.setOnClickPendingIntent(R.id.widget_add_note_button, pendingIntent)
             appWidgetManager.updateAppWidget(appWidgetIds, remoteViews)
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerTest.kt
index 2615c701638c..732569e28a6b 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerTest.kt
@@ -2,18 +2,18 @@
 
 package com.ichi2.anki
 
-import android.app.Application
-import android.content.Context
 import android.content.Intent
 import android.os.Build
+import android.os.Bundle
+import android.os.Parcelable
 import android.webkit.RenderProcessGoneDetail
 import androidx.annotation.CheckResult
-import androidx.core.content.IntentCompat
-import androidx.test.core.app.ApplicationProvider
+import androidx.core.os.BundleCompat
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.SdkSuppress
 import anki.config.ConfigKey
 import com.ichi2.anim.ActivityTransitionAnimation
+import com.ichi2.anki.AbstractFlashcardViewer.Companion.toAnimationTransition
 import com.ichi2.anki.AbstractFlashcardViewer.WebViewSignalParserUtils.ANSWER_ORDINAL_1
 import com.ichi2.anki.AbstractFlashcardViewer.WebViewSignalParserUtils.ANSWER_ORDINAL_2
 import com.ichi2.anki.AbstractFlashcardViewer.WebViewSignalParserUtils.ANSWER_ORDINAL_3
@@ -50,7 +50,6 @@ import org.junit.jupiter.params.provider.MethodSource
 import org.junit.runner.RunWith
 import org.mockito.Mockito.mock
 import org.robolectric.Robolectric
-import org.robolectric.Shadows
 import org.robolectric.android.controller.ActivityController
 import timber.log.Timber
 import java.util.Locale
@@ -204,11 +203,15 @@ class AbstractFlashcardViewerTest : RobolectricTest() {
             val expectedInverseAnimation =
                 ActivityTransitionAnimation.getInverseTransition(expectedAnimation)
 
-            viewer.executeCommand(ViewerCommand.EDIT, gesture)
-            val actual = Shadows.shadowOf(ApplicationProvider.getApplicationContext<Context>() as Application).nextStartedActivity
-
-            val actualInverseAnimation = IntentCompat.getParcelableExtra(
-                actual,
+            val animation = gesture.toAnimationTransition().invert()
+            val bundle = Bundle().apply {
+                putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_EDIT)
+                putLong(NoteEditor.EXTRA_CARD_ID, viewer.currentCard!!.id)
+                putParcelable(FINISH_ANIMATION_EXTRA, animation as Parcelable)
+            }
+            val noteEditor = NoteEditorTest().openNoteEditorWithArgs(bundle)
+            val actualInverseAnimation = BundleCompat.getParcelable(
+                noteEditor.requireArguments(),
                 FINISH_ANIMATION_EXTRA,
                 Direction::class.java
             )
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ActivityStartupUnderBackupTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/ActivityStartupUnderBackupTest.kt
index e6949e7a453e..a7fd53e1efd8 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/ActivityStartupUnderBackupTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ActivityStartupUnderBackupTest.kt
@@ -52,6 +52,7 @@ class ActivityStartupUnderBackupTest : RobolectricTest() {
     fun before() {
         notYetHandled(CropImageActivity::class.java.simpleName, "cannot implemented - activity from canhub.cropper")
         notYetHandled(IntentHandler::class.java.simpleName, "Not working (or implemented) - inherits from Activity")
+        notYetHandled(IntentHandler2::class.java.simpleName, "Not working (or implemented) - inherits from Activity")
         notYetHandled(Preferences::class.java.simpleName, "Not working (or implemented) - inherits from AppCompatPreferenceActivity")
         notYetHandled(FilteredDeckOptions::class.java.simpleName, "Not working (or implemented) - inherits from AppCompatPreferenceActivity")
         notYetHandled(SingleFragmentActivity::class.java.simpleName, "Implemented, but the test fails because the activity throws if a specific intent extra isn't set")
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.kt
index f88be9f6aeeb..5d6c2941af5f 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.kt
@@ -490,8 +490,8 @@ class CardBrowserTest : RobolectricTest() {
         assertThat("The target deck should be selected", b.lastDeckId, equalTo(targetDid))
 
         val addIntent = b.addNoteIntent
-
-        IntentAssert.hasExtra(addIntent, NoteEditor.EXTRA_DID, targetDid)
+        val bundle = addIntent.getBundleExtra(SingleFragmentActivity.FRAGMENT_ARGS_EXTRA)
+        IntentAssert.hasExtra(bundle, NoteEditor.EXTRA_DID, targetDid)
     }
 
     /** 7420  */
@@ -504,8 +504,8 @@ class CardBrowserTest : RobolectricTest() {
         assertThat("The initial deck should be selected", b.lastDeckId, equalTo(initialDid))
 
         val addIntent = b.addNoteIntent
-
-        IntentAssert.hasExtra(addIntent, NoteEditor.EXTRA_DID, initialDid)
+        val bundle = addIntent.getBundleExtra(SingleFragmentActivity.FRAGMENT_ARGS_EXTRA)
+        IntentAssert.hasExtra(bundle, NoteEditor.EXTRA_DID, initialDid)
     }
 
     @Test
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/DeckPickerTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/DeckPickerTest.kt
index 0044dbf18743..0aef8c1ae9ea 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/DeckPickerTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/DeckPickerTest.kt
@@ -423,7 +423,7 @@ class DeckPickerTest : RobolectricTest() {
 
             supportFragmentManager.selectContextMenuOption(DeckPickerContextMenuOption.ADD_CARD, didA)
             val noteEditor = Shadows.shadowOf(this).nextStartedActivity!!
-            assertEquals("com.ichi2.anki.NoteEditor", noteEditor.component!!.className)
+            assertEquals("com.ichi2.anki.SingleFragmentActivity", noteEditor.component!!.className)
             onBackPressedDispatcher.onBackPressed()
 
             supportFragmentManager.selectContextMenuOption(DeckPickerContextMenuOption.BROWSE_CARDS, didA)
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/NoteEditorTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/NoteEditorTest.kt
index 6c7a2ab0ce1a..9559eb9c186d 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/NoteEditorTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/NoteEditorTest.kt
@@ -20,6 +20,8 @@ package com.ichi2.anki
 import android.app.Activity
 import android.content.ClipData
 import android.content.Intent
+import android.os.Bundle
+import android.os.Parcelable
 import android.widget.EditText
 import android.widget.Spinner
 import android.widget.TextView
@@ -32,9 +34,8 @@ import com.ichi2.anki.NoteEditorTest.FromScreen.REVIEWER
 import com.ichi2.anki.api.AddContentApi.Companion.DEFAULT_DECK_ID
 import com.ichi2.anki.dialogs.DeckSelectionDialog.SelectableDeck
 import com.ichi2.anki.multimediacard.activity.MultimediaEditFieldActivity
-import com.ichi2.anki.noteeditor.EditCardDestination
-import com.ichi2.anki.noteeditor.toIntent
 import com.ichi2.anki.utils.ext.isImageOcclusion
+import com.ichi2.annotations.DuplicatedCode
 import com.ichi2.libanki.Consts
 import com.ichi2.libanki.DeckId
 import com.ichi2.libanki.Decks.Companion.CURRENT_DECK
@@ -52,6 +53,7 @@ import org.junit.Test
 import org.junit.runner.RunWith
 import org.robolectric.Shadows.shadowOf
 import org.robolectric.annotation.Config
+import java.util.concurrent.atomic.AtomicReference
 import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
 import kotlin.test.assertTrue
@@ -62,7 +64,7 @@ class NoteEditorTest : RobolectricTest() {
     @Config(qualifiers = "en")
     fun verifyCardsList() {
         val n = getNoteEditorEditingExistingBasicNote("Test", "Note", DECK_LIST)
-        assertThat("Cards list is correct", (n.findViewById<TextView>(R.id.CardEditorCardsButton)).text.toString(), equalTo("Cards: Card 1"))
+        assertThat("Cards list is correct", (n.requireView().findViewById<TextView>(R.id.CardEditorCardsButton)).text.toString(), equalTo("Cards: Card 1"))
     }
 
     @Test
@@ -76,7 +78,7 @@ class NoteEditorTest : RobolectricTest() {
         openAdvancedTextEditor(n, fieldIndex)
 
         // Assert
-        val intent = shadowOf(n).nextStartedActivityForResult
+        val intent = shadowOf(n.requireActivity()).nextStartedActivityForResult
         val actualField = MultimediaEditFieldActivity.getFieldFromIntent(intent.intent)!!
         assertThat("Provided value should be the updated value", actualField.second.formattedValue, equalTo("Good Afternoon"))
     }
@@ -197,10 +199,14 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun verifyStartupAndCloseWithNoCollectionDoesNotCrash() {
         enableNullCollection()
-        ActivityScenario.launchActivityForResult(NoteEditor::class.java).use { scenario ->
-            scenario.onActivity { noteEditor: NoteEditor ->
-                noteEditor.onBackPressedDispatcher.onBackPressed()
-                assertThat("Pressing back should finish the activity", noteEditor.isFinishing)
+        val bundle = Bundle().apply {
+            putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_NO_CALLER)
+        }
+        val intent = NoteEditor.getIntent(targetContext, bundle)
+        ActivityScenario.launchActivityForResult<SingleFragmentActivity>(intent).use { scenario ->
+            scenario.onNoteEditor { noteEditor ->
+                noteEditor.requireActivity().onBackPressedDispatcher.onBackPressed()
+                assertThat("Pressing back should finish the activity", noteEditor.requireActivity().isFinishing)
             }
             val result = scenario.result
             assertThat("Activity should be cancelled as no changes were made", result.resultCode, equalTo(Activity.RESULT_CANCELED))
@@ -215,10 +221,10 @@ class NoteEditorTest : RobolectricTest() {
         n.notetype.put("did", currentDid)
         val editor = getNoteEditorEditingExistingBasicNote("Test", "Note", DECK_LIST)
         col.config.set(CURRENT_DECK, Consts.DEFAULT_DECK_ID) // Change DID if going through default path
-        val copyNoteIntent = getCopyNoteIntent(editor)
-        val newNoteEditor = super.startActivityNormallyOpenCollectionWithIntent(NoteEditor::class.java, copyNoteIntent)
+        val copyNoteBundle = getCopyNoteIntent(editor)
+        val newNoteEditor = openNoteEditorWithArgs(copyNoteBundle)
         assertThat("Selected deck ID should be the current deck id", editor.deckId, equalTo(currentDid))
-        assertThat("Deck ID in the intent should be the selected deck id", copyNoteIntent.getLongExtra(NoteEditor.EXTRA_DID, -404L), equalTo(currentDid))
+        assertThat("Deck ID in the intent should be the selected deck id", copyNoteBundle.getLong(NoteEditor.EXTRA_DID, -404L), equalTo(currentDid))
         assertThat("Deck ID in the new note should be the ID provided in the intent", newNoteEditor.deckId, equalTo(currentDid))
     }
 
@@ -250,10 +256,9 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun processTextIntentShouldCopyFirstField() {
         ensureCollectionLoadIsSynchronous()
-
         val i = Intent(Intent.ACTION_PROCESS_TEXT)
         i.putExtra(Intent.EXTRA_PROCESS_TEXT, "hello\nworld")
-        val editor = startActivityNormallyOpenCollectionWithIntent(NoteEditor::class.java, i)
+        val editor = openNoteEditorWithArgs(i.extras!!, i.action)
         val actual = editor.currentFieldStrings.toList()
 
         assertThat(actual, contains("hello\nworld", ""))
@@ -262,14 +267,14 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun previewWorksWithNoError() {
         // #6923 regression test - Low value - Could not make this fail as onSaveInstanceState did not crash under Robolectric.
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         assertDoesNotThrow { runBlocking { editor.performPreview() } }
     }
 
     @Test
     fun clearFieldWorks() {
         // #7522
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         editor.setFieldValueFromUi(1, "Hello")
         assertThat(editor.currentFieldStrings[1], equalTo("Hello"))
         editor.clearField(1)
@@ -278,7 +283,7 @@ class NoteEditorTest : RobolectricTest() {
 
     @Test
     fun insertIntoFocusedFieldStartsAtSelection() {
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         val field: EditText = editor.getFieldForTest(0)
         editor.insertStringInField(field, "Hello")
         field.setSelection(3)
@@ -288,7 +293,7 @@ class NoteEditorTest : RobolectricTest() {
 
     @Test
     fun insertIntoFocusedFieldReplacesSelection() {
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         val field: EditText = editor.getFieldForTest(0)
         editor.insertStringInField(field, "12345")
         field.setSelection(2, 3) // select "3"
@@ -299,7 +304,7 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun insertIntoFocusedFieldReplacesSelectionIfBackwards() {
         // selections can be backwards if the user uses keyboards
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         val field: EditText = editor.getFieldForTest(0)
         editor.insertStringInField(field, "12345")
         field.setSelection(3, 2) // select "3" (right to left)
@@ -310,13 +315,13 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun defaultsToCapitalized() {
         // Requested in #3758, this seems like a sensible default
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         assertThat("Fields should have their first word capitalized by default", editor.getFieldForTest(0).isCapitalized, equalTo(true))
     }
 
     @Test
     fun pasteHtmlAsPlainTextTest() {
-        val editor = getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java)
+        val editor = getNoteEditorAddingNote(DECK_LIST)
         editor.setCurrentlySelectedModel(col.notetypes.byName("Basic")!!.getLong("id"))
         val field = editor.getFieldForTest(0)
         field.clipboard!!.setPrimaryClip(ClipData.newHtmlText("text", "text", """<span style="color: red">text</span>"""))
@@ -367,7 +372,7 @@ class NoteEditorTest : RobolectricTest() {
     @Test
     fun `can open with corrupt current deck - Issue 14096`() {
         col.config.set(CURRENT_DECK, '"' + "1688546411954" + '"')
-        getNoteEditorAddingNote(DECK_LIST, NoteEditor::class.java).apply {
+        getNoteEditorAddingNote(DECK_LIST).apply {
             assertThat("current deck is default after corruption", deckId, equalTo(DEFAULT_DECK_ID))
         }
     }
@@ -397,7 +402,7 @@ class NoteEditorTest : RobolectricTest() {
         assertThat("current deck", note.firstCard().did, not(equalTo(homeDeckId)))
 
         // act
-        val editor = getNoteEditorEditingExistingBasicNote(note, REVIEWER, NoteEditor::class.java)
+        val editor = getNoteEditorEditingExistingBasicNote(note, REVIEWER)
 
         // assert
         assertThat("current deck is the home deck", editor.deckId, equalTo(homeDeckId))
@@ -438,7 +443,7 @@ class NoteEditorTest : RobolectricTest() {
         assertThat("home deck", note.firstCard().oDid, equalTo(homeDeckId))
         assertThat("current deck", note.firstCard().did, not(equalTo(homeDeckId)))
 
-        getNoteEditorEditingExistingBasicNote(note, REVIEWER, NoteEditor::class.java).apply {
+        getNoteEditorEditingExistingBasicNote(note, REVIEWER).apply {
             setField(0, "Hello")
             saveNote()
         }
@@ -465,10 +470,11 @@ class NoteEditorTest : RobolectricTest() {
         }
     }
 
-    private fun getCopyNoteIntent(editor: NoteEditor): Intent {
-        val editorShadow = shadowOf(editor)
+    private fun getCopyNoteIntent(editor: NoteEditor): Bundle {
+        val editorShadow = shadowOf(editor.requireActivity())
         editor.copyNote()
-        return editorShadow.peekNextStartedActivityForResult().intent
+        val intent = editorShadow.peekNextStartedActivityForResult().intent
+        return intent.getBundleExtra(SingleFragmentActivity.FRAGMENT_ARGS_EXTRA)!!
     }
 
     private fun Spinner.getItemIndex(toFind: Any): Int? {
@@ -511,30 +517,62 @@ class NoteEditorTest : RobolectricTest() {
         n.setFieldValueFromUi(i, newText)
     }
 
-    private fun <T : NoteEditor?> getNoteEditorAddingNote(from: FromScreen, clazz: Class<T>): T {
+    private fun getNoteEditorAddingNote(from: FromScreen): NoteEditor {
         ensureCollectionLoadIsSynchronous()
-        val i = Intent()
-        when (from) {
-            REVIEWER -> i.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD)
-            DECK_LIST -> i.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+        val bundle = Bundle().apply {
+            when (from) {
+                REVIEWER -> putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD)
+                DECK_LIST -> putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
+            }
         }
-        return super.startActivityNormallyOpenCollectionWithIntent(clazz, i)
+        return openNoteEditorWithArgs(bundle)
     }
 
     private fun getNoteEditorEditingExistingBasicNote(front: String, back: String, from: FromScreen): NoteEditor {
         val n = super.addNoteUsingBasicModel(front, back)
-        return getNoteEditorEditingExistingBasicNote(n, from, NoteEditor::class.java)
+        return getNoteEditorEditingExistingBasicNote(n, from)
     }
 
-    private fun <T : NoteEditor?> getNoteEditorEditingExistingBasicNote(n: Note, from: FromScreen, clazz: Class<T>): T {
-        var i = Intent()
+    private fun getNoteEditorEditingExistingBasicNote(n: Note, from: FromScreen): NoteEditor {
+        val bundle = Bundle()
         when (from) {
             REVIEWER -> {
-                i = EditCardDestination(n.firstCard().id).toIntent(targetContext, DEFAULT)
+                bundle.putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_EDIT)
+                bundle.putLong(NoteEditor.EXTRA_CARD_ID, n.firstCard().id)
+                bundle.putParcelable(AnkiActivity.FINISH_ANIMATION_EXTRA, DEFAULT as Parcelable)
+            }
+            DECK_LIST -> {
+                bundle.putInt(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
             }
-            DECK_LIST -> i.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER)
         }
-        return super.startActivityNormallyOpenCollectionWithIntent(clazz, i)
+        return openNoteEditorWithArgs(bundle)
+    }
+
+    fun openNoteEditorWithArgs(arguments: Bundle, action: String? = null): NoteEditor {
+        val activity = startActivityNormallyOpenCollectionWithIntent(SingleFragmentActivity::class.java, NoteEditor.getIntent(targetContext, arguments, action))
+        return activity.getEditor()
+    }
+
+    @DuplicatedCode("NoteEditor in androidTest")
+    @Throws(Throwable::class)
+    fun ActivityScenario<SingleFragmentActivity>.onNoteEditor(
+        block: (NoteEditor) -> Unit
+    ) {
+        val wrapped = AtomicReference<Throwable?>(null)
+        this.onActivity { activity: SingleFragmentActivity ->
+            try {
+                val editor = activity.getEditor()
+                block(editor)
+            } catch (t: Throwable) {
+                wrapped.set(t)
+            }
+        }
+        wrapped.get()?.let { throw it }
+    }
+
+    @DuplicatedCode("NoteEditor in androidTest")
+    fun SingleFragmentActivity.getEditor(): NoteEditor {
+        return supportFragmentManager.findFragmentById(R.id.fragment_container) as NoteEditor
     }
 
     private enum class FromScreen {
@@ -556,7 +594,7 @@ class NoteEditorTest : RobolectricTest() {
         private var firstField: String? = null
         private var secondField: String? = null
         fun build(): NoteEditor {
-            val editor = build(NoteEditor::class.java)
+            val editor = buildInternal()
             advanceRobolectricLooper()
             advanceRobolectricLooper()
             advanceRobolectricLooper()
@@ -567,9 +605,9 @@ class NoteEditorTest : RobolectricTest() {
             return editor
         }
 
-        fun <T : NoteEditor?> build(clazz: Class<T>): T {
+        fun buildInternal(): NoteEditor {
             col.notetypes.setCurrent(notetype)
-            val noteEditor = getNoteEditorAddingNote(REVIEWER, clazz)!!
+            val noteEditor = getNoteEditorAddingNote(REVIEWER)
             advanceRobolectricLooper()
             // image occlusion does not need a first field
             if (this.firstField != null) {
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.kt
index b1e371aa7aa0..5d57a5041a18 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ReviewerTest.kt
@@ -19,8 +19,8 @@ import android.app.Application
 import android.content.Intent
 import android.view.Menu
 import androidx.annotation.CheckResult
-import androidx.core.content.IntentCompat
 import androidx.core.content.edit
+import androidx.core.os.BundleCompat
 import androidx.test.core.app.ActivityScenario
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -132,8 +132,9 @@ class ReviewerTest : RobolectricTest() {
         // Assert
         val shadowApplication = Shadows.shadowOf(ApplicationProvider.getApplicationContext<Application>())
         val intent = shadowApplication.nextStartedActivity
-        val actualAnimation = IntentCompat.getParcelableExtra(
-            intent,
+        val fragmentBundle = intent.getBundleExtra(SingleFragmentActivity.FRAGMENT_ARGS_EXTRA)
+        val actualAnimation = BundleCompat.getParcelable(
+            fragmentBundle!!,
             AnkiActivity.FINISH_ANIMATION_EXTRA,
             ActivityTransitionAnimation.Direction::class.java
         )
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/browser/CardBrowserViewModelTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/browser/CardBrowserViewModelTest.kt
index 6984f0c0dc8f..6df37abbb53d 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/browser/CardBrowserViewModelTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/browser/CardBrowserViewModelTest.kt
@@ -25,6 +25,7 @@ import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.DeckSpinnerSelection
 import com.ichi2.anki.Flag
 import com.ichi2.anki.NoteEditor
+import com.ichi2.anki.SingleFragmentActivity
 import com.ichi2.anki.browser.CardBrowserColumn.ANSWER
 import com.ichi2.anki.browser.CardBrowserColumn.CARD
 import com.ichi2.anki.browser.CardBrowserColumn.FSRS_DIFFICULTY
@@ -134,8 +135,8 @@ class CardBrowserViewModelTest : JvmTest() {
         assertThat("All decks should be selected", hasSelectedAllDecks())
 
         val addIntent = CardBrowser.createAddNoteIntent(mockIt(), this)
-
-        IntentAssert.doesNotHaveExtra(addIntent, NoteEditor.EXTRA_DID)
+        val bundle = addIntent.getBundleExtra(SingleFragmentActivity.FRAGMENT_ARGS_EXTRA)
+        IntentAssert.doesNotHaveExtra(bundle, NoteEditor.EXTRA_DID)
     }
 
     @Test
diff --git a/AnkiDroid/src/test/java/com/ichi2/testutils/ActivityList.kt b/AnkiDroid/src/test/java/com/ichi2/testutils/ActivityList.kt
index 390d8f844818..bd1876ddc8a2 100644
--- a/AnkiDroid/src/test/java/com/ichi2/testutils/ActivityList.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/testutils/ActivityList.kt
@@ -30,11 +30,11 @@ import com.ichi2.anki.DrawingActivity
 import com.ichi2.anki.FilteredDeckOptions
 import com.ichi2.anki.Info
 import com.ichi2.anki.IntentHandler
+import com.ichi2.anki.IntentHandler2
 import com.ichi2.anki.IntroductionActivity
 import com.ichi2.anki.LoginActivity
 import com.ichi2.anki.ModelFieldEditor
 import com.ichi2.anki.MyAccount
-import com.ichi2.anki.NoteEditor
 import com.ichi2.anki.Reviewer
 import com.ichi2.anki.SharedDecksActivity
 import com.ichi2.anki.SingleFragmentActivity
@@ -66,6 +66,7 @@ object ActivityList {
                     1L
                 )
             },
+            get(IntentHandler2::class.java),
             get(StudyOptionsActivity::class.java),
             get(CardBrowser::class.java),
             get(ModelFieldEditor::class.java),
@@ -78,8 +79,6 @@ object ActivityList {
             get(DrawingActivity::class.java),
             // Info has unhandled intents
             get(Info::class.java),
-            // NoteEditor has unhandled intents
-            get(NoteEditor::class.java),
             get(MultimediaEditFieldActivity::class.java),
             get(CardTemplateEditor::class.java) { intentForCardTemplateEditor() },
             get(CardTemplateBrowserAppearanceEditor::class.java) { intentForCardTemplateBrowserAppearanceEditor() },
diff --git a/AnkiDroid/src/test/java/com/ichi2/testutils/IntentAssert.kt b/AnkiDroid/src/test/java/com/ichi2/testutils/IntentAssert.kt
index a05a241ef65c..46c4a242750a 100644
--- a/AnkiDroid/src/test/java/com/ichi2/testutils/IntentAssert.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/testutils/IntentAssert.kt
@@ -15,7 +15,7 @@
  */
 package com.ichi2.testutils
 
-import android.content.Intent
+import android.os.Bundle
 import org.hamcrest.CoreMatchers.equalTo
 import org.hamcrest.CoreMatchers.hasItem
 import org.hamcrest.CoreMatchers.not
@@ -23,15 +23,21 @@ import org.hamcrest.MatcherAssert.assertThat
 import kotlin.test.assertNotNull
 
 object IntentAssert {
-    fun doesNotHaveExtra(intent: Intent, extraKey: String?) {
-        val keySet = assertNotNull(intent.extras).keySet()
+    /**
+     * Check that bundle does noe have [extraKey]
+     */
+    fun doesNotHaveExtra(arguments: Bundle?, extraKey: String?) {
+        val keySet = assertNotNull(arguments).keySet()
         assertThat("Intent should not have extra '$extraKey'", keySet, not(hasItem(extraKey)))
     }
 
-    fun hasExtra(intent: Intent, extraKey: String?, value: Long) {
-        val keySet = assertNotNull(intent.extras).keySet()
+    /**
+     * Check that bundle has [extraKey]
+     */
+    fun hasExtra(arguments: Bundle?, extraKey: String?, value: Long) {
+        val keySet = assertNotNull(arguments).keySet()
         assertThat("Intent should have extra '$extraKey'", keySet, hasItem(extraKey))
 
-        assertThat(intent.getLongExtra(extraKey, -1337), equalTo(value))
+        assertThat(arguments.getLong(extraKey, -1337), equalTo(value))
     }
 }
