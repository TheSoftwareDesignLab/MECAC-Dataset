diff --git a/res/values/constants.xml b/res/values/constants.xml
index b53a5cdf2dd1..e52ed7383455 100644
--- a/res/values/constants.xml
+++ b/res/values/constants.xml
@@ -148,16 +148,7 @@
 	<!--<string name="change_report_format">&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;%1$s&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;%2$s&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;%3$s&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%4$s&lt;/td&gt;&lt;td&gt;%5$s&lt;/td&gt;&lt;td&gt;%6$s&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%7$s&lt;/td&gt;&lt;td&gt;%8$s&lt;/td>&lt;td&gt;9$s&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%10$s&lt;/td&gt;&lt;td&gt;%11$s&lt;/td&gt;&lt;td&gt;%12$s&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%13$s&lt;/td&gt;&lt;td&gt;%14$s&lt;/td&gt;&lt;td&gt;%15$s&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</string>-->
 
 	<string-array name="new_version_features">
-		<item>gestures can be chosen now</item>
-		<item>better sibling spacing</item>
-		<item>increase in deck picker startup</item>
-		<item>speed improvements for answering cards</item>
-		<item>whiteboard state is now saved for every deck</item>
-		<item>sort order in deckpicker can be changed now</item>
-		<item>time estimation for tomorrow\'s workload</item>
-		<item>Arabic support</item>
-		<item>support for custom fonts</item>
-		<item>improvements in card browser</item>
-		<item>a lot of bugfixes</item>
+		<item>two new themes</item>
+		<item>animations</item>
 	</string-array>
 </resources>
diff --git a/src/com/ichi2/anim/Animation3D.java b/src/com/ichi2/anim/Animation3D.java
index 89b1c87a2943..745c415de929 100644
--- a/src/com/ichi2/anim/Animation3D.java
+++ b/src/com/ichi2/anim/Animation3D.java
@@ -26,6 +26,11 @@
 import android.graphics.Matrix;
 
 public class Animation3D extends Animation {
+	
+	public static final int ANIMATION_TURN = 0;
+	public static final int ANIMATION_EXCHANGE_CARD = 1;
+	public static final int ANIMATION_SLIDE_IN_CARD = 2;
+
     private final float mValueX;
     private final float mValueY;
     private final float mDepthZ;
@@ -33,16 +38,16 @@ public class Animation3D extends Animation {
     private Reviewer mReviewer;
     boolean mDirection;
     boolean mFlipped = false;
-    boolean mTurn;
+    int mAction;
     boolean mRealTurn;
 
-    public Animation3D(float valueX, float valueY, float depthZ, boolean direction, boolean turn, boolean realturn, Reviewer reviewer) {
+    public Animation3D(float valueX, float valueY, float depthZ, int action, boolean direction, boolean realturn, Reviewer reviewer) {
         mValueX = valueX;
         mValueY = valueY;
         mDepthZ = depthZ;
         mReviewer = reviewer;
         mDirection = direction;
-        mTurn = turn;
+        mAction = action;
         mRealTurn = realturn;
     }
 
@@ -55,14 +60,15 @@ public void initialize(int width, int height, int parentWidth, int parentHeight)
 
     @Override
     protected void applyTransformation(float interpolatedTime, Transformation t) {
-        float centerX;
-        float centerY;
+        float centerX = 0;
+        float centerY = 0;
         final Camera camera = mCamera;
         final Matrix matrix = t.getMatrix();
         camera.save();
         float time;
 
-        if (mTurn) {
+        switch (mAction) {
+        case ANIMATION_TURN:
         	if (mRealTurn) {
                 time = interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;        		
         	} else {
@@ -83,7 +89,8 @@ protected void applyTransformation(float interpolatedTime, Transformation t) {
                 centerY = mValueY / 2;
             	camera.rotateY(degrees);
             }
-        } else {
+            break;
+        case ANIMATION_EXCHANGE_CARD:
             if (mDirection) {
             	time = interpolatedTime >= 0.5f ? -(interpolatedTime - 1.0f) : -interpolatedTime;
             } else {
@@ -96,6 +103,21 @@ protected void applyTransformation(float interpolatedTime, Transformation t) {
             camera.translate(mValueX * time * 2, 0.0f, mDepthZ * Math.abs(time * 180));
             centerX = mValueX / 2;
             centerY = mValueY / 2;
+            break;
+        case ANIMATION_SLIDE_IN_CARD:
+            if (mDirection) {
+            	time = 1 - interpolatedTime;
+            } else {
+            	time = -1 + interpolatedTime;
+            }
+            if (interpolatedTime >= 0.0f && !mFlipped) {
+                mReviewer.fillFlashcard(false);
+                mFlipped = true;
+            }
+            camera.translate(mValueX * time * 2, 0.0f, mDepthZ * Math.abs(time * 180));
+            centerX = mValueX / 2;
+            centerY = mValueY / 2;
+            break;        	
         }
 
         camera.getMatrix(matrix);
diff --git a/src/com/ichi2/anim/ViewAnimation.java b/src/com/ichi2/anim/ViewAnimation.java
index d54d6e5d9aa7..f55fc1e79034 100644
--- a/src/com/ichi2/anim/ViewAnimation.java
+++ b/src/com/ichi2/anim/ViewAnimation.java
@@ -1,11 +1,9 @@
 package com.ichi2.anim;
 
-import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.AccelerateInterpolator;
 import android.view.animation.AlphaAnimation;
 import android.view.animation.Animation;
-import android.view.animation.AnimationSet;
-import android.view.animation.LayoutAnimationController;
-import android.view.animation.LinearInterpolator;
+import android.view.animation.DecelerateInterpolator;
 import android.view.animation.TranslateAnimation;
 
 public class ViewAnimation {
@@ -28,37 +26,41 @@ public static Animation slide(int type, int duration, int offset) {
                     Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                 );
+            animation.setInterpolator(new DecelerateInterpolator());
         	break;
         case SLIDE_OUT_TO_RIGHT:
             animation = new TranslateAnimation(
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, +1.0f,
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                 );
+            animation.setInterpolator(new AccelerateInterpolator());
         	break;
         case SLIDE_IN_FROM_LEFT:
             animation = new TranslateAnimation(
                     Animation.RELATIVE_TO_SELF, -1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                 );
+            animation.setInterpolator(new DecelerateInterpolator());
         	break;
         case SLIDE_OUT_TO_LEFT:
             animation = new TranslateAnimation(
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, -1.0f,
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                 );
+            animation.setInterpolator(new AccelerateInterpolator());
         	break;
         case SLIDE_IN_FROM_BOTTOM:
             animation = new TranslateAnimation(
                     Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                     Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f
                 );
+            animation.setInterpolator(new DecelerateInterpolator());
         	break;
     	default:
     		animation = null;
         }
         animation.setDuration(duration);
         animation.setStartOffset(offset);
-        animation.setInterpolator(new LinearInterpolator());
         return animation;
 	}
 
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 96fefc85d143..ebf3b95a1efa 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -66,6 +66,7 @@
 import android.view.Window;
 import android.view.WindowManager;
 import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
 import android.view.inputmethod.InputMethodManager;
 import android.webkit.JsResult;
 import android.webkit.WebChromeClient;
@@ -463,6 +464,32 @@ public void onPostExecute(DeckTask.TaskData result) {
         }
     };
 
+    private DeckTask.TaskListener mDismissCardHandler = new DeckTask.TaskListener() {
+        @Override
+        public void onPreExecute() {
+        }
+
+
+        @Override
+        public void onProgressUpdate(DeckTask.TaskData... values) {
+            mCurrentCard = values[0].getCard();
+            if (mPrefWhiteboard) {
+                mWhiteboard.clear();
+            }
+
+            if (mPrefTimer) {
+                mCardTimer.setBase(SystemClock.elapsedRealtime());
+                mCardTimer.start();
+            }
+            displayCardQuestion();
+        }
+
+
+        @Override
+        public void onPostExecute(DeckTask.TaskData result) {
+        }
+    };
+
     private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
@@ -482,7 +509,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
                 mCardTimer.setBase(SystemClock.elapsedRealtime());
                 mCardTimer.start();
             }
-            reviewNextCard();
+            displayCardQuestion();
             mProgressDialog.dismiss();
         }
 
@@ -568,7 +595,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
                 Reviewer.this.setProgressBarIndeterminateVisibility(false);
                 // Reviewer.this.enableControls();
                 Reviewer.this.unblockControls();
-                Reviewer.this.reviewNextCard();
+                Reviewer.this.displayCardQuestion();
             }
 
             // Show a message to user if a session limit has been reached.
@@ -890,9 +917,8 @@ public void onConfigurationChanged(Configuration newConfig) {
 
         Log.i(AnkiDroidApp.TAG, "onConfigurationChanged");
 
-        mFirstCard = true;
         mConfigurationChanged = true;
-        
+
         long savedTimer = mCardTimer.getBase();
         CharSequence savedAnswerField = mAnswerField.getText();
 
@@ -911,14 +937,6 @@ public void onConfigurationChanged(Configuration newConfig) {
         mCardTemplate = mCardTemplate.replaceFirst("var availableWidth = \\d*;", "var availableWidth = "
                 + getAvailableWidthInCard() + ";");
 
-        // If the card hasn't loaded yet, don't refresh it
-        // Also skipping the counts (because we don't know which one to underline)
-        // They will be updated when the card loads anyway
-        if (mCurrentCard != null) {
-            refreshCard();
-            updateScreenCounts();
-        }
-
         if (mPrefTimer) {
             mCardTimer.setBase(savedTimer);
             mCardTimer.start();
@@ -932,7 +950,16 @@ public void onConfigurationChanged(Configuration newConfig) {
         if (mInvertedColors) {
             invertColors();
         }
-        updateStatisticBars();
+
+        // If the card hasn't loaded yet, don't refresh it
+        // Also skipping the counts (because we don't know which one to underline)
+        // They will be updated when the card loads anyway
+        if (mCurrentCard != null) {
+        	mFirstCard = true;
+            fillFlashcard(false);
+        	updateForNewCard();
+        }
+
         mConfigurationChanged = false;
     }
 
@@ -1064,12 +1091,12 @@ public boolean onOptionsItemSelected(MenuItem item) {
             	return editCard();
 
             case MENU_REMOVE_BURY:
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                         AnkiDroidApp.deck(), mCurrentCard));
                 return true;
 
             case MENU_REMOVE_SUSPEND:
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                         AnkiDroidApp.deck(), mCurrentCard));
                 return true;
 
@@ -1106,6 +1133,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 
         if (requestCode == EDIT_CURRENT_CARD) {
             mFirstCard = true;
+            mFlipToRight = true;
             if (resultCode == RESULT_OK) {
                 Log.i(AnkiDroidApp.TAG, "Saving card...");
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT, mUpdateCardHandler, new DeckTask.TaskData(0,
@@ -1119,7 +1147,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                 finishNoStorageAvailable();
             } else if (mShowAnimations) {
             	mCardContainer.setVisibility(View.VISIBLE);
-            	mCardContainer.setAnimation(ViewAnimation.slide(ViewAnimation.SLIDE_IN_FROM_RIGHT, mAnimationDurationMove, 0));
+            	mCardContainer.setAnimation(ViewAnimation.slide(ViewAnimation.SLIDE_IN_FROM_LEFT, mAnimationDurationMove, 0));
             }
         }
     }
@@ -1260,7 +1288,7 @@ private void showDeleteCardDialog() {
                 new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
-                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mAnswerCardHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), mCurrentCard));
+                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mDismissCardHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), mCurrentCard));
                     }
                 });
         builder.setNegativeButton(res.getString(R.string.no), null);
@@ -1312,7 +1340,7 @@ private void initLayout(Integer layout) {
         Themes.setContentStyle(mMainLayout, Themes.CALLER_REVIEWER);
 
         mCardContainer = (FrameLayout) findViewById(R.id.flashcard_frame);
-		mCardContainer.setVisibility(mShowAnimations && !mConfigurationChanged ? View.INVISIBLE : View.VISIBLE);
+		mCardContainer.setVisibility(mShowAnimations ? View.INVISIBLE : View.VISIBLE);
 
         mCard = (WebView) findViewById(R.id.flashcard);
         mCard.setScrollBarStyle(WebView.SCROLLBARS_OUTSIDE_OVERLAY);
@@ -1528,8 +1556,10 @@ private void hideEaseButtons() {
     		switchVisibility(mNext3, View.INVISIBLE);
     		switchVisibility(mNext4, View.INVISIBLE);
     	}
-		switchVisibility(mFlipCard, View.VISIBLE);
-    	mFlipCard.requestFocus();
+    	if (mFlipCard.getVisibility() != View.VISIBLE) {
+    		switchVisibility(mFlipCard, View.VISIBLE);
+        	mFlipCard.requestFocus();    		
+    	}
     }
 
 
@@ -1637,7 +1667,7 @@ private void setDueMessage() {
     }
 
 
-    private void reviewNextCard() {
+    private void updateForNewCard() {
     	updateScreenCounts();
     	if (mShowProgressBars) {
             updateStatisticBars();    	    
@@ -1656,8 +1686,6 @@ private void reviewNextCard() {
             mCardTimer.setBase(SystemClock.elapsedRealtime());
             mCardTimer.start();
         }
-
-        displayCardQuestion();
     }
 
 
@@ -1667,6 +1695,7 @@ private void updateScreenCounts() {
             if (mShowProgressBars) {
                 mProgressBars.setVisibility(View.VISIBLE);
             }
+            mFirstCard = false;
     	}
     	
         Deck deck = AnkiDroidApp.deck();
@@ -1767,8 +1796,6 @@ private void displayCardQuestion() {
         updateCard(displayString);
         if (!mFirstCard) {
             hideEaseButtons();
-        } else {
-            mFirstCard = false;        	
         }
 
         // If the user want to show answer automatically
@@ -1943,33 +1970,38 @@ private void updateCard(String content) {
 
     public void fillFlashcard(boolean flip) {
     	if (!flip) {
+    		if (mFirstCard) {
+    			mCardContainer.setVisibility(View.VISIBLE);
+        		updateForNewCard();
+    		} else if (!sDisplayAnswer) {
+        		updateForNewCard();
+    		}
     		mCard.loadDataWithBaseURL(mBaseUrl, mCardContent, "text/html", "utf-8", null);
     		if (!sDisplayAnswer && mShowWhiteboard) {
 				mWhiteboard.clear();
     		}
     	} else {
-    		if (mFirstCard && !mConfigurationChanged) {
+    		Animation3D rotation;
+    		if (mFirstCard) {
         		mCard.loadDataWithBaseURL(mBaseUrl, mCardContent, "text/html", "utf-8", null);
-        		mCardContainer.setVisibility(View.VISIBLE);
-        		mCardContainer.setAnimation(ViewAnimation.slide(ViewAnimation.SLIDE_IN_FROM_RIGHT, mAnimationDurationMove, 0));
+    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_SLIDE_IN_CARD, !mFlipToRight, true, this);
+    			rotation.setDuration(mAnimationDurationMove);
+    			rotation.setInterpolator(new DecelerateInterpolator());
+    		} else if (sDisplayAnswer) {
+    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 5, Animation3D.ANIMATION_TURN, true, true, this);
+    			rotation.setDuration(mAnimationDurationTurn);
+    			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
     		} else {
-        		Animation3D rotation;
-        		if (sDisplayAnswer) {
-        			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 5, true, true, true, this);
-        			rotation.setDuration(mAnimationDurationTurn);
-        			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
-        		} else {
-        			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, !mFlipToRight, false, true, this);
-        			mFlipToRight = false;
-        			rotation.setDuration(mAnimationDurationMove);
-        			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
-        		}
-    			rotation.reset();
-    			mCardContainer.setDrawingCacheEnabled(true);
-    			mCardContainer.setDrawingCacheBackgroundColor(Themes.getBackgroundColor());
-    	    	mCardContainer.clearAnimation();
-    	    	mCardContainer.startAnimation(rotation);
+    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_EXCHANGE_CARD, !mFlipToRight, true, this);
+    			mFlipToRight = false;
+    			rotation.setDuration(mAnimationDurationMove);
+    			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
     		}
+			rotation.reset();
+			mCardContainer.setDrawingCacheEnabled(true);
+			mCardContainer.setDrawingCacheBackgroundColor(Themes.getBackgroundColor());
+	    	mCardContainer.clearAnimation();
+	    	mCardContainer.startAnimation(rotation);
     	}
     }
 
