diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehavior.kt b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehavior.kt
new file mode 100644
index 000000000000..ac935e0ebd00
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehavior.kt
@@ -0,0 +1,138 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.anki.snackbar
+
+import android.view.MotionEvent
+import android.view.View
+import android.view.ViewGroup
+import androidx.annotation.VisibleForTesting
+import androidx.coordinatorlayout.widget.CoordinatorLayout
+import androidx.core.view.marginLeft
+import androidx.core.view.marginRight
+import androidx.customview.widget.ViewDragHelper
+import com.google.android.material.behavior.SwipeDismissBehavior
+import com.ichi2.anki.AnkiDroidApp
+import com.ichi2.anki.UIUtils
+import kotlin.math.absoluteValue
+import kotlin.math.sign
+
+/**
+ * This is more a fix for the inconsistent behavior of `SwipeDismissBehavior`,
+ * rather than a custom implementation. This addresses the following issues:
+ *
+ *   * When the snackbar is swiped to the right, its opacity changes,
+ *     but not when swiped to the left;
+ *
+ *   * When moving the snackbar to dismiss it, the target distance calculation does not take
+ *     the margins into account, which makes the snackbar briefly appear stuck near the edge;
+ *
+ *   * Any amount of horizontal velocity will dismiss the snackbar,
+ *     which can result in user dismissing the snackbar even though they didn't want to;
+ *
+ *   * If you drag the snackbar to the right, and then flinging it to the left,
+ *     it will suddenly change course and start moving to the right.
+ */
+open class SensibleSwipeDismissBehavior<V : View> : SwipeDismissBehavior<V>() {
+    private var viewDragHelper: ViewDragHelper? = null
+
+    override fun onInterceptTouchEvent(parent: CoordinatorLayout, child: V, event: MotionEvent): Boolean {
+        ensureViewDragHelper(parent)
+        return viewDragHelper!!.shouldInterceptTouchEvent(event)
+    }
+
+    override fun onTouchEvent(parent: CoordinatorLayout, child: V, event: MotionEvent): Boolean {
+        viewDragHelper?.processTouchEvent(event)
+        return viewDragHelper != null
+    }
+
+    private fun ensureViewDragHelper(parent: ViewGroup) {
+        if (viewDragHelper == null) {
+            viewDragHelper = ViewDragHelper.create(parent, ViewDragHelperCallback())
+        }
+    }
+
+    /** See [com.google.android.material.behavior.SwipeDismissBehavior.dragCallback] */
+    inner class ViewDragHelperCallback : ViewDragHelper.Callback() {
+        @VisibleForTesting var initialChildLeft = Int.MIN_VALUE
+
+        override fun getViewHorizontalDragRange(child: View) = child.width
+
+        override fun clampViewPositionHorizontal(child: View, left: Int, dx: Int) = left
+
+        override fun clampViewPositionVertical(child: View, top: Int, dy: Int) = child.top
+
+        override fun tryCaptureView(child: View, pointerId: Int) = true
+
+        override fun onViewCaptured(child: View, pointerId: Int) {
+            if (initialChildLeft == Int.MIN_VALUE) {
+                initialChildLeft = child.left
+            }
+            child.parent?.requestDisallowInterceptTouchEvent(true)
+        }
+
+        override fun onViewReleased(child: View, xvel: Float, yvel: Float) {
+            val targetChildLeft = when (shouldDismiss(child, xvel)) {
+                Dismiss.DoNotDismiss -> initialChildLeft
+                Dismiss.ToTheRight -> initialChildLeft + child.width + child.marginRight
+                Dismiss.ToTheLeft -> initialChildLeft - child.width - child.marginLeft
+            }
+
+            if (viewDragHelper?.settleCapturedViewAt(targetChildLeft, child.top) == true) {
+                child.postOnAnimation(object : Runnable {
+                    override fun run() {
+                        if (viewDragHelper?.continueSettling(true) == true) {
+                            child.postOnAnimation(this)
+                        }
+                    }
+                })
+            }
+        }
+
+        /**
+         * The finger was lifted off the snackbar, which may still have horizontal velocity.
+         * This decides whether the snackbar should be dismissed.
+         *
+         *   * If current snackbar speed is high, dismiss to the direction of fling;
+         *
+         *   * If snackbar traveled a lot, and currently is either stationary,
+         *     or is moving away from the original position,
+         *     dismiss to the direction of the closest edge;
+         *
+         *   * Else do not dismiss, and return to original position.
+         */
+        @VisibleForTesting fun shouldDismiss(child: View, xvel: Float): Dismiss {
+            return if (xvel.absoluteValue > FLING_TO_DISMISS_SPEED_THRESHOLD) {
+                if (xvel > 0f) Dismiss.ToTheRight else Dismiss.ToTheLeft
+            } else {
+                val distanceTraveled = child.left - initialChildLeft
+                val distanceTraveledRatio = distanceTraveled.absoluteValue.toFloat() / child.width
+                val shouldDismiss = distanceTraveledRatio > DRAG_TO_DISMISS_DISTANCE_RATIO &&
+                    (xvel == 0f || xvel.sign.toInt() == distanceTraveled.sign)
+                when {
+                    !shouldDismiss -> Dismiss.DoNotDismiss
+                    distanceTraveled > 0 -> Dismiss.ToTheRight
+                    else -> Dismiss.ToTheLeft
+                }
+            }
+        }
+    }
+}
+
+@VisibleForTesting enum class Dismiss { DoNotDismiss, ToTheLeft, ToTheRight }
+
+private val FLING_TO_DISMISS_SPEED_THRESHOLD =
+    UIUtils.convertDpToPixel(1000f, AnkiDroidApp.getInstance().applicationContext)
+
+private const val DRAG_TO_DISMISS_DISTANCE_RATIO = .5f
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/Snackbars.kt b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/Snackbars.kt
index 7df19af8999a..7c35134a4a8a 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/Snackbars.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/Snackbars.kt
@@ -179,7 +179,6 @@ fun View.showSnackbar(
     val snackbar = Snackbar.make(this, text, duration)
     snackbar.setMaxLines(2)
     snackbar.fixSwipeDismissBehavior()
-    snackbar.actualBehavior?.setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_ANY)
 
     if (snackbarBuilder != null) { snackbar.snackbarBuilder() }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SwipeDismissBehaviorFix.kt b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SwipeDismissBehaviorFix.kt
index a7da0c8f787c..d0b6f2c4e0d8 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SwipeDismissBehaviorFix.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/snackbar/SwipeDismissBehaviorFix.kt
@@ -52,8 +52,11 @@ import com.google.android.material.behavior.SwipeDismissBehavior
  * This does prevent the user from moving snackbar if they put a finger on it,
  * move it directly upwards, and then to the side.
  * However, this inconvenience is rather minor and fixing it properly might require too much effort.
+ *
+ * Note that this fix is currently used for [SensibleSwipeDismissBehavior],
+ * but is applicable to [SwipeDismissBehavior] as well.
  */
-class SwipeDismissBehaviorFix<V : View> : SwipeDismissBehavior<V>() {
+class SwipeDismissBehaviorFix<V : View> : SensibleSwipeDismissBehavior<V>() {
     private var ignoreCallsToOnTouchEvent = false
 
     override fun onInterceptTouchEvent(parent: CoordinatorLayout, child: V, event: MotionEvent): Boolean {
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehaviorTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehaviorTest.kt
new file mode 100644
index 000000000000..e20ef5b278a1
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/snackbar/SensibleSwipeDismissBehaviorTest.kt
@@ -0,0 +1,93 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.anki.snackbar
+
+import android.view.View
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import org.junit.Test
+import org.junit.jupiter.api.Assertions.assertEquals
+import org.junit.runner.RunWith
+import org.mockito.Mockito.mock
+import org.mockito.kotlin.whenever
+
+@RunWith(AndroidJUnit4::class)
+internal class SensibleSwipeDismissBehaviorTest {
+    private val behavior = SensibleSwipeDismissBehavior().ViewDragHelperCallback().apply {
+        initialChildLeft = 0
+    }
+
+    private val snackbar = mock(View::class.java).apply {
+        whenever(width).thenReturn(100)
+    }
+
+    private fun positionSnackbarAtX(x: Int) {
+        whenever(snackbar.left).thenReturn(x)
+    }
+
+    @Test fun `Stationary snackbar isn't dismissed if it hasn't traveled`() {
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, 0f))
+    }
+
+    @Test fun `Stationary snackbar isn't dismissed if it hasn't traveled far`() {
+        positionSnackbarAtX(-5)
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, 0f))
+
+        positionSnackbarAtX(+5)
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, 0f))
+    }
+
+    @Test fun `Stationary snackbar is dismissed if it has traveled far`() {
+        positionSnackbarAtX(+80)
+        assertEquals(Dismiss.ToTheRight, behavior.shouldDismiss(snackbar, 0f))
+
+        positionSnackbarAtX(-80)
+        assertEquals(Dismiss.ToTheLeft, behavior.shouldDismiss(snackbar, 0f))
+    }
+
+    @Test fun `Moving snackbar isn't dismissed if it hasn't traveled far and is moving slowly`() {
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, 100f))
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, -100f))
+
+        positionSnackbarAtX(+5)
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, 100f))
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, -100f))
+    }
+
+    @Test fun `Moving snackbar isn't dismissed if it has traveled far, but is moving slowly towards initial position`() {
+        positionSnackbarAtX(+80)
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, -100f))
+
+        positionSnackbarAtX(-80)
+        assertEquals(Dismiss.DoNotDismiss, behavior.shouldDismiss(snackbar, +100f))
+    }
+
+    @Test fun `Moving snackbar is dismissed if it has traveled far and is moving towards the closest edge, even if slowly`() {
+        positionSnackbarAtX(+80)
+        assertEquals(Dismiss.ToTheRight, behavior.shouldDismiss(snackbar, +100f))
+
+        positionSnackbarAtX(-80)
+        assertEquals(Dismiss.ToTheLeft, behavior.shouldDismiss(snackbar, -100f))
+    }
+
+    @Test fun `Moving snackbar is dismissed if it is moving fast`() {
+        assertEquals(Dismiss.ToTheRight, behavior.shouldDismiss(snackbar, +1000000f))
+
+        positionSnackbarAtX(+80)
+        assertEquals(Dismiss.ToTheLeft, behavior.shouldDismiss(snackbar, -1000000f))
+
+        positionSnackbarAtX(-80)
+        assertEquals(Dismiss.ToTheRight, behavior.shouldDismiss(snackbar, +1000000f))
+    }
+}
