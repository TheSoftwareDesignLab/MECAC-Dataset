diff --git a/AnkiDroid/src/main/java/com/ichi2/widget/cardanalysis/CardAnalysisWidgetConfig.kt b/AnkiDroid/src/main/java/com/ichi2/widget/cardanalysis/CardAnalysisWidgetConfig.kt
index 2dc37ecd5b28..5c4c60ea228b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/widget/cardanalysis/CardAnalysisWidgetConfig.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/widget/cardanalysis/CardAnalysisWidgetConfig.kt
@@ -1,5 +1,6 @@
 /*
  *  Copyright (c) 2024 Anoop <xenonnn4w@gmail.com>
+ *  Copyright (c) 2025 lukstbit <52494258+lukstbit@users.noreply.github.com>
  *
  *  This program is free software; you can redistribute it and/or modify it under
  *  the terms of the GNU General Public License as published by the Free Software
@@ -22,202 +23,94 @@ import android.content.Context
 import android.content.Intent
 import android.content.IntentFilter
 import android.os.Bundle
-import android.view.View
-import android.widget.Button
-import androidx.activity.OnBackPressedCallback
-import androidx.annotation.StringRes
-import androidx.annotation.VisibleForTesting
-import androidx.core.view.isVisible
-import androidx.lifecycle.lifecycleScope
-import androidx.recyclerview.widget.LinearLayoutManager
-import androidx.recyclerview.widget.RecyclerView
-import com.google.android.material.floatingactionbutton.FloatingActionButton
-import com.google.android.material.snackbar.Snackbar
+import android.widget.TextView
+import androidx.core.os.BundleCompat
+import com.google.android.material.button.MaterialButton
 import com.ichi2.anki.AnkiActivity
 import com.ichi2.anki.R
 import com.ichi2.anki.dialogs.DeckSelectionDialog
 import com.ichi2.anki.dialogs.DeckSelectionDialog.DeckSelectionListener
-import com.ichi2.anki.dialogs.DiscardChangesDialog
 import com.ichi2.anki.isCollectionEmpty
+import com.ichi2.anki.launchCatchingTask
 import com.ichi2.anki.model.SelectableDeck
 import com.ichi2.anki.showThemedToast
-import com.ichi2.anki.snackbar.BaseSnackbarBuilderProvider
-import com.ichi2.anki.snackbar.SnackbarBuilder
 import com.ichi2.anki.utils.ext.unregisterReceiverSilently
+import com.ichi2.anki.withProgress
 import com.ichi2.widget.AppWidgetId.Companion.INVALID_APPWIDGET_ID
 import com.ichi2.widget.AppWidgetId.Companion.getAppWidgetId
-import com.ichi2.widget.WidgetConfigScreenAdapter
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.withContext
+import com.ichi2.widget.cardanalysis.CardAnalysisWidget.Companion.EXTRA_SELECTED_DECK_ID
 import timber.log.Timber
 
-// TODO: Ensure that the Deck Selection Dialog does not close automatically while the user is interacting with it.
-
+/**
+ * Configuration activity for [CardAnalysisWidget]. Only allows selecting a deck.
+ *
+ * Behavior:
+ *  - shows a single centered card with the selected deck name(if any) and a button to trigger the
+ *    deck selection dialog
+ *  - when the user first adds the widget this activity will start with the deck selection dialog
+ *    already open, if there is a deck selected then, the activity will start without the selection
+ *    dialog
+ *  - storing the user selection is done automatically on every deck change
+ *  - handles user not selecting anything(widget also handles this state)
+ *  - finishes immediately when the collection is empty and shows a toast('Collection is empty')
+ *  - shows loading state if querying the collection takes time
+ *
+ * @see CardAnalysisWidget
+ * @see CardAnalysisWidgetPreferences
+ */
 class CardAnalysisWidgetConfig :
     AnkiActivity(),
-    DeckSelectionListener,
-    BaseSnackbarBuilderProvider {
+    DeckSelectionListener {
     private var appWidgetId = INVALID_APPWIDGET_ID
-    lateinit var deckAdapter: WidgetConfigScreenAdapter
-    private lateinit var cardAnalysisWidgetPreferences: CardAnalysisWidgetPreferences
-
-    private var hasUnsavedChanges = false
-    private var isAdapterObserverRegistered = false
-    private lateinit var onBackPressedCallback: OnBackPressedCallback
-
-    /** Tracks coroutine running [initializeUIComponents]: must be run on a non-empty collection */
-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
-    internal lateinit var initTask: Job
+    private var deck: SelectableDeck.Deck? = null
+    private lateinit var preferences: CardAnalysisWidgetPreferences
+    private lateinit var deckName: TextView
 
     override fun onCreate(savedInstanceState: Bundle?) {
         if (showedActivityFailedScreen(savedInstanceState)) {
             return
         }
-
         super.onCreate(savedInstanceState)
 
         if (!ensureStoragePermissions()) {
             return
         }
 
-        setContentView(R.layout.widget_deck_picker_config)
-
-        cardAnalysisWidgetPreferences = CardAnalysisWidgetPreferences(this)
-
+        setContentView(R.layout.activity_card_analysis_widget_config)
+        preferences = CardAnalysisWidgetPreferences(this)
         appWidgetId = intent.getAppWidgetId()
-
         if (appWidgetId == INVALID_APPWIDGET_ID) {
             Timber.v("Invalid App Widget ID")
             finish()
             return
         }
-
-        // Check if the collection is empty before proceeding and if the collection is empty, show a toast instead of the configuration view.
-        this.initTask =
-            lifecycleScope.launch {
-                if (isCollectionEmpty()) {
-                    Timber.w("Closing: Collection is empty")
-                    showThemedToast(
-                        this@CardAnalysisWidgetConfig,
-                        R.string.app_not_initialized_new,
-                        false,
-                    )
-                    finish()
-                    return@launch
-                }
-
-                initializeUIComponents()
-                // Show the Deck selection dialog only when there are no decks selected while opening the configuration screen.
-                val selectedDeckId = cardAnalysisWidgetPreferences.getSelectedDeckIdFromPreferences(appWidgetId)
-                if (selectedDeckId == null) {
-                    showDeckSelectionDialog()
-                }
-            }
-    }
-
-    fun showSnackbar(message: CharSequence) {
-        showSnackbar(
-            message,
-            Snackbar.LENGTH_LONG,
-        )
-    }
-
-    fun showSnackbar(
-        @StringRes messageResId: Int,
-    ) {
-        showSnackbar(getString(messageResId))
-    }
-
-    private fun initializeUIComponents() {
-        deckAdapter =
-            WidgetConfigScreenAdapter { deck, _ ->
-                deckAdapter.removeDeck(deck.deckId)
-                showSnackbar(R.string.deck_removed_from_widget)
-                updateViewVisibility()
-                updateFabVisibility()
-                updateSubmitButtonText()
-                setUnsavedChanges(true)
-            }
-
-        findViewById<RecyclerView>(R.id.recyclerViewSelectedDecks).apply {
-            layoutManager = LinearLayoutManager(context)
-            adapter = this@CardAnalysisWidgetConfig.deckAdapter
-        }
-
-        // Find and update the submit button text based on the initial deck selection state
-        val submitButton = findViewById<Button>(R.id.submit_button)
-        updateSubmitButtonText()
-
-        submitButton.setOnClickListener {
-            finish() // Close the configuration screen when the button is clicked
-        }
-
-        findViewById<FloatingActionButton>(R.id.fabWidgetDeckPicker).setOnClickListener {
-            showDeckSelectionDialog()
+        deckName = findViewById(R.id.deck_name)
+        if (savedInstanceState != null) {
+            deck =
+                BundleCompat.getParcelable(
+                    savedInstanceState,
+                    KEY_DECK,
+                    SelectableDeck.Deck::class.java,
+                )
+            deckName.text = deck?.name
+        } else {
+            loadContent()
         }
-
-        lifecycleScope.launch { updateViewWithSavedPreferences() }
-
-        // Update the visibility of the "no decks" placeholder and the widget configuration container
-        updateViewVisibility()
-
-        registerReceiver(widgetRemovedReceiver, IntentFilter(AppWidgetManager.ACTION_APPWIDGET_DELETED))
-
-        onBackPressedCallback =
-            object : OnBackPressedCallback(hasUnsavedChanges) {
-                override fun handleOnBackPressed() {
-                    if (isEnabled) {
-                        showDiscardChangesDialog()
-                    }
-                }
+        findViewById<MaterialButton>(R.id.change_btn).setOnClickListener {
+            launchCatchingTask {
+                withProgress { showDeckSelectionDialog() }
             }
-
-        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)
-
-        // Register the AdapterDataObserver if not already registered
-        if (!isAdapterObserverRegistered) {
-            deckAdapter.registerAdapterDataObserver(
-                object : RecyclerView.AdapterDataObserver() {
-                    override fun onChanged() {
-                    }
-                },
-            )
-            isAdapterObserverRegistered = true
-        }
-    }
-
-    /** Updates the text of the submit button based on the selected deck count. */
-    private fun updateSubmitButtonText() {
-        val submitButton = findViewById<Button>(R.id.submit_button)
-        if (deckAdapter.itemCount > 0) {
-            submitButton.text = getString(R.string.dialog_cancel)
-            submitButton.visibility = View.VISIBLE
-        } else {
-            submitButton.visibility = View.GONE
         }
-    }
-
-    private fun showDiscardChangesDialog() {
-        DiscardChangesDialog.showDialog(
-            context = this@CardAnalysisWidgetConfig,
-            positiveMethod = {
-                // Discard changes and finish the activity
-                hasUnsavedChanges = false
-                finish()
-            },
+        findViewById<MaterialButton>(R.id.done_btn).setOnClickListener { close() }
+        registerReceiver(
+            widgetRemovedReceiver,
+            IntentFilter(AppWidgetManager.ACTION_APPWIDGET_DELETED),
         )
     }
 
-    private fun updateCallbackState() {
-        onBackPressedCallback.isEnabled = hasUnsavedChanges
-    }
-
-    // Call this method when there are unsaved changes
-    private fun setUnsavedChanges(unsaved: Boolean) {
-        hasUnsavedChanges = unsaved
-        updateCallbackState()
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+        outState.putParcelable(KEY_DECK, deck)
     }
 
     override fun onDestroy() {
@@ -225,50 +118,51 @@ class CardAnalysisWidgetConfig :
         unregisterReceiverSilently(widgetRemovedReceiver)
     }
 
-    override val baseSnackbarBuilder: SnackbarBuilder = {
-        anchorView = findViewById<FloatingActionButton>(R.id.fabWidgetDeckPicker)
-    }
-
-    /** Updates the visibility of the FloatingActionButton based on the number of selected decks */
-    private fun updateFabVisibility() {
-        // Directly check if there's exactly one deck selected
-        val selectedDeckCount = deckAdapter.itemCount
-
-        // Find the FloatingActionButton by its ID
-        val fab = findViewById<FloatingActionButton>(R.id.fabWidgetDeckPicker)
-
-        // Make the FAB visible only if no deck is selected (allow adding one deck)
-        fab.isVisible = selectedDeckCount == 0
-    }
-
-    /** Updates the view according to the saved preference for appWidgetId.*/
-    suspend fun updateViewWithSavedPreferences() {
-        val selectedDeckId = cardAnalysisWidgetPreferences.getSelectedDeckIdFromPreferences(appWidgetId) ?: return
-
-        val decks = fetchDecks()
-        val selectedDecks = decks.filter { it.deckId == selectedDeckId }
-        selectedDecks.forEach { deckAdapter.addDeck(it) }
-        updateViewVisibility()
-        updateFabVisibility()
-        updateSubmitButtonText()
-    }
-
-    /** Asynchronously displays the list of deck in the selection dialog. */
-    private fun showDeckSelectionDialog() {
-        lifecycleScope.launch {
-            val decks = fetchDecks()
-            displayDeckSelectionDialog(decks)
+    override fun onDeckSelected(deck: SelectableDeck?) {
+        if (deck == null || deck !is SelectableDeck.Deck?) {
+            showThemedToast(this, R.string.something_wrong, false)
+            setResult(RESULT_CANCELED)
+            finish()
+            return
+        }
+        // if the deck was null before the selection then the widget was just added so update the
+        // widget and finish
+        val shouldClose = this.deck == null
+        this.deck = deck
+        deckName.text = deck.name
+        preferences.saveSelectedDeck(appWidgetId, deck.deckId)
+        updateWidget()
+        if (shouldClose) {
+            close()
         }
     }
 
-    /** Returns the list of standard deck. */
-    private suspend fun fetchDecks(): List<SelectableDeck.Deck> =
-        withContext(Dispatchers.IO) {
-            SelectableDeck.fromCollection(includeFiltered = true)
+    private fun loadContent() {
+        launchCatchingTask {
+            withProgress {
+                if (isCollectionEmpty()) {
+                    Timber.w("CardAnalysisWidgetConfig: collection is empty")
+                    showThemedToast(
+                        this@CardAnalysisWidgetConfig,
+                        R.string.no_cards_placeholder_title,
+                        false,
+                    )
+                    finish()
+                    return@withProgress
+                }
+                val selectedDeckId = preferences.getSelectedDeckIdFromPreferences(appWidgetId)
+                if (selectedDeckId == null) {
+                    showDeckSelectionDialog()
+                } else {
+                    deck = SelectableDeck.Deck.fromId(selectedDeckId)
+                    deckName.text = deck?.name ?: getString(R.string.select_deck)
+                }
+            }
         }
+    }
 
-    /** Displays the deck selection dialog with the provided list of decks. */
-    private fun displayDeckSelectionDialog(decks: List<SelectableDeck>) {
+    private suspend fun showDeckSelectionDialog() {
+        val decks = SelectableDeck.fromCollection(includeFiltered = true)
         val dialog =
             DeckSelectionDialog.newInstance(
                 title = getString(R.string.select_deck_title),
@@ -276,69 +170,29 @@ class CardAnalysisWidgetConfig :
                 keepRestoreDefaultButton = false,
                 decks = decks,
             )
-        dialog.show(supportFragmentManager, "DeckSelectionDialog")
-    }
-
-    /**
-     * Called when a deck is selected from the deck selection dialog.
-     *
-     * This method adds the selected deck to the `deckAdapter`, updates the visibility of views,
-     * and immediately saves the selected deck to preferences.
-     *
-     * @param deck The selected deck, or `null` if no deck was selected.
-     */
-    override fun onDeckSelected(deck: SelectableDeck?) {
-        if (deck == null) {
-            return
-        }
-        require(deck is SelectableDeck.Deck)
-
-        // Check if the deck is being added to a fully occupied selection
-        if (deckAdapter.itemCount >= MAX_DECKS_ALLOWED) {
-            return
-        } else {
-            // Add the deck and update views
-            deckAdapter.addDeck(deck)
-            updateViewVisibility()
-            updateFabVisibility()
-            setUnsavedChanges(true)
-
-            // Save the selected deck immediately
-            saveSelectedDecksToPreferencesCardAnalysisWidget()
-            setUnsavedChanges(false)
-
-            // Update the widget with the new selected deck ID
-            cardAnalysisWidgetPreferences.getSelectedDeckIdFromPreferences(appWidgetId)
-            val appWidgetManager = AppWidgetManager.getInstance(this)
-            CardAnalysisWidget.updateWidget(this, appWidgetManager, appWidgetId)
-
-            val resultValue = Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId.id)
-            setResult(RESULT_OK, resultValue)
-            finish()
+        if (!supportFragmentManager.isStateSaved) {
+            dialog.show(supportFragmentManager, "DeckSelectionDialog")
         }
     }
 
-    /** Updates the visibility of the "no decks" placeholder and the widget configuration container */
-    fun updateViewVisibility() {
-        val noDecksPlaceholder = findViewById<View>(R.id.no_decks_placeholder)
-        val widgetConfigContainer = findViewById<View>(R.id.widgetConfigContainer)
-
-        noDecksPlaceholder.isVisible = deckAdapter.itemCount == 0
-        widgetConfigContainer.isVisible = deckAdapter.itemCount > 0
-    }
-
-    fun saveSelectedDecksToPreferencesCardAnalysisWidget() {
-        val selectedDeck = deckAdapter.deckIds.getOrNull(0)
-        cardAnalysisWidgetPreferences.saveSelectedDeck(appWidgetId, selectedDeck)
-
+    private fun updateWidget() {
         val updateIntent =
             Intent(this, CardAnalysisWidget::class.java).apply {
                 action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
                 putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, intArrayOf(appWidgetId.id))
-                putExtra(EXTRA_SELECTED_DECK_IDS, selectedDeck)
+                putExtra(EXTRA_SELECTED_DECK_ID, deck?.deckId)
             }
 
         sendBroadcast(updateIntent)
+
+        val appWidgetManager = AppWidgetManager.getInstance(this)
+        CardAnalysisWidget.updateWidget(this, appWidgetManager, appWidgetId)
+    }
+
+    private fun close() {
+        val intent = Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId.id)
+        setResult(RESULT_OK, intent)
+        finish()
     }
 
     /** BroadcastReceiver to handle widget removal. */
@@ -357,15 +211,11 @@ class CardAnalysisWidgetConfig :
                     return
                 }
 
-                cardAnalysisWidgetPreferences.deleteDeckData(appWidgetId)
+                preferences.deleteDeckData(appWidgetId)
             }
         }
 
     companion object {
-        /**
-         * Maximum number of decks allowed in the widget.
-         */
-        private const val MAX_DECKS_ALLOWED = 1
-        private const val EXTRA_SELECTED_DECK_IDS = "card_analysis_widget_selected_deck_ids"
+        private const val KEY_DECK = "key_deck"
     }
 }
diff --git a/AnkiDroid/src/main/res/layout/activity_card_analysis_widget_config.xml b/AnkiDroid/src/main/res/layout/activity_card_analysis_widget_config.xml
new file mode 100644
index 000000000000..291d465006cb
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/activity_card_analysis_widget_config.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/root_layout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:padding="16dp">
+
+        <androidx.cardview.widget.CardView
+            android:id="@+id/deck_card"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            app:cardCornerRadius="16dp"
+            style="@style/Widget.Material3.CardView.Filled"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintBottom_toTopOf="@id/done_btn"
+            tools:visibility="visible">
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:orientation="vertical"
+                android:padding="16dp">
+
+                <TextView
+                    android:id="@+id/deck_name"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_horizontal"
+                    android:textAppearance="?attr/textAppearanceTitleLarge"
+                    />
+
+                <com.google.android.material.button.MaterialButton
+                    android:id="@+id/change_btn"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_marginTop="8dp"
+                    android:text="@string/select_deck"
+                    android:layout_gravity="center_horizontal"
+                    />
+            </LinearLayout>
+        </androidx.cardview.widget.CardView>
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/done_btn"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:maxWidth="320dp"
+            android:text="@string/multimedia_editor_field_editing_done"
+            android:gravity="center"
+            app:layout_constraintWidth_max="320dp"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            tools:visibility="visible"
+            />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</androidx.coordinatorlayout.widget.CoordinatorLayout>
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/widget/cardanalysis/CardAnalysisWidgetConfigTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/widget/cardanalysis/CardAnalysisWidgetConfigTest.kt
index 24127b3460a0..6787514f821d 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/widget/cardanalysis/CardAnalysisWidgetConfigTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/widget/cardanalysis/CardAnalysisWidgetConfigTest.kt
@@ -1,5 +1,6 @@
 /*
  *  Copyright (c) 2024 Anoop <xenonnn4w@gmail.com>
+ *  Copyright (c) 2025 lukstbit <52494258+lukstbit@users.noreply.github.com>
  *
  *  This program is free software; you can redistribute it and/or modify it under
  *  the terms of the GNU General Public License as published by the Free Software
@@ -17,118 +18,189 @@
 package com.ichi2.anki.widget.cardanalysis
 
 import android.appwidget.AppWidgetManager
+import android.content.ComponentName
 import android.content.Intent
-import android.view.View
-import androidx.recyclerview.widget.RecyclerView
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.click
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.RootMatchers.isDialog
+import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
+import androidx.test.espresso.matcher.ViewMatchers.withId
+import androidx.test.espresso.matcher.ViewMatchers.withText
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.R
 import com.ichi2.anki.RobolectricTest
-import com.ichi2.anki.model.SelectableDeck
 import com.ichi2.widget.AppWidgetId
+import com.ichi2.widget.AppWidgetId.Companion.updateWidget
+import com.ichi2.widget.cardanalysis.CardAnalysisWidget
 import com.ichi2.widget.cardanalysis.CardAnalysisWidgetConfig
 import com.ichi2.widget.cardanalysis.CardAnalysisWidgetPreferences
-import kotlinx.coroutines.runBlocking
-import org.hamcrest.MatcherAssert.assertThat
-import org.hamcrest.Matchers.equalTo
-import org.junit.Before
+import kotlinx.coroutines.test.advanceUntilIdle
 import org.junit.Test
 import org.junit.runner.RunWith
+import org.robolectric.shadows.ShadowAppWidgetManager
+import org.robolectric.shadows.ShadowLooper
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import kotlin.test.assertTrue
 
-val testWidgetId = AppWidgetId(1)
-
+// TODO CardAnalysisWidgetPreferences should be refactored for injection/easier use in tests
 @RunWith(AndroidJUnit4::class)
 class CardAnalysisWidgetConfigTest : RobolectricTest() {
-    private lateinit var activity: CardAnalysisWidgetConfig
-    private val widgetPreferences = CardAnalysisWidgetPreferences(targetContext)
-
-    /**
-     * Sets up the test environment before each test.
-     *
-     * Initializes the `CardAnalysisWidgetConfig` activity and associated components like
-     * `WidgetPreferences`. This setup is executed before each test method.
-     */
-    @Before
+    private lateinit var preferences: CardAnalysisWidgetPreferences
+
     override fun setUp() {
         super.setUp()
-        ensureNonEmptyCollection()
-
-        val intent =
-            Intent(targetContext, CardAnalysisWidgetConfig::class.java).apply {
-                putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, 1)
-            }
-
-        activity = startActivityNormallyOpenCollectionWithIntent(CardAnalysisWidgetConfig::class.java, intent)
+        val mgr = AppWidgetManager.getInstance(targetContext)
+        mgr.bindAppWidgetIdIfAllowed(
+            testWidgetId.id,
+            ComponentName(targetContext, CardAnalysisWidget::class.java),
+        )
+        preferences = CardAnalysisWidgetPreferences(targetContext)
+    }
 
-        // Ensure deckAdapter is initialized
-        runBlocking { activity.initTask.join() }
+    override fun tearDown() {
+        super.tearDown()
+        ShadowAppWidgetManager.reset()
     }
 
-    /**
-     * Tests the functionality of saving selected decks to preferences.
-     *
-     * This test adds a deck to the adapter and verifies if it gets correctly saved to the
-     * `WidgetPreferences`.
-     */
     @Test
-    fun testSaveSelectedDecksToPreferences() {
-        // Add decks to adapter
-        val deck1 = SelectableDeck.Deck(1, "Deck 1")
-        activity.deckAdapter.addDeck(deck1)
-
-        // Save selected decks
-        activity.saveSelectedDecksToPreferencesCardAnalysisWidget()
+    fun `finishes at start when collection is empty`() =
+        runTest {
+            val activity = startTestActivity(withEmptyCollection = true)
+            advanceUntilIdle()
+            assertTrue(activity.isFinishing)
+        }
 
-        // Verify saved decks
-        val selectedDeckId = widgetPreferences.getSelectedDeckIdFromPreferences(testWidgetId)
-        assertThat(selectedDeckId, equalTo(deck1.deckId))
-    }
+    @Test
+    fun `finishes at start if provided widget id is INVALID_APPWIDGET_ID`() =
+        runTest {
+            val activity =
+                startTestActivity(widgetId = AppWidgetId(AppWidgetManager.INVALID_APPWIDGET_ID))
+            advanceUntilIdle()
+            assertTrue(activity.isFinishing)
+        }
 
-    /**
-     * Tests the loading of saved preferences into the activity's view.
-     *
-     * This test saves decks to preferences, then loads them into the activity and checks if the
-     * `RecyclerView` displays the correct number of items based on the saved preferences.
-     */
     @Test
-    fun testLoadSavedPreferences() =
+    fun `configures correctly a new widget`() =
         runTest {
-            // Save decks to preferences
-            val deckId = 1L
-            widgetPreferences.saveSelectedDeck(testWidgetId, deckId)
+            val testDeckId = addDeck(TEST_DECK_NAME1)
+            val activity = startTestActivity()
+            advanceUntilIdle()
+            // first setup of the widget, no deck selected so deck name view should be empty
+            onView(withId(R.id.deck_name)).check(matches(withText("")))
+            // select dialog already open, select deck 1
+            onView(withText(R.string.select_deck_title))
+                .inRoot(isDialog())
+                .check(matches(isDisplayed()))
+            onView(withText(TEST_DECK_NAME1)).inRoot(isDialog()).perform(click())
+            // check if UI shows the selected deck and if it was saved in preferences
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME1)))
+            assertEquals(testDeckId, preferences.getSelectedDeckIdFromPreferences(testWidgetId))
+            // the activity is closed on first deck selection
+            assertTrue(activity.isFinishing)
+        }
 
-            // Load preferences
-            activity.updateViewWithSavedPreferences()
+    @Test
+    fun `ui is updated based on user deck selection`() =
+        runTest {
+            val testDeck1Id = addDeck(TEST_DECK_NAME1)
+            preferences.saveSelectedDeck(testWidgetId, testDeck1Id)
+            val testDeck2Id = addDeck(TEST_DECK_NAME2)
+            startTestActivity()
+            advanceUntilIdle()
+            // deck 1 is already selected
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME1)))
+            // open deck selection, select deck 2 and verify that is displayed and selected in ui
+            onView(withId(R.id.change_btn)).perform(click())
+            onView(withText(TEST_DECK_NAME2)).inRoot(isDialog()).perform(click())
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME2)))
+            // set configuration as done
+            onView(withId(R.id.done_btn)).perform(click())
+            // check that the correct deck is saved in preferences
+            assertEquals(testDeck2Id, preferences.getSelectedDeckIdFromPreferences(testWidgetId))
+        }
 
-            // Get the RecyclerView and its adapter
-            val recyclerView = activity.findViewById<RecyclerView>(R.id.recyclerViewSelectedDecks)
-            val adapter = recyclerView.adapter
+    @Test
+    fun `handles correctly user not selecting a deck`() =
+        runTest {
+            startTestActivity()
+            advanceUntilIdle()
+            // no selection yet
+            onView(withId(R.id.deck_name)).check(matches(withText("")))
+            // cancel deck selection
+            onView(withText(R.string.dialog_cancel)).inRoot(isDialog()).perform(click())
+            // still no deck selected, so deck name should still be empty
+            onView(withId(R.id.deck_name)).check(matches(withText("")))
+            // set configuration as done
+            onView(withId(R.id.done_btn)).perform(click())
+            // no deck selected so there shouldn't be any deck saved in preferences
+            assertNull(preferences.getSelectedDeckIdFromPreferences(testWidgetId))
+        }
 
-            // Verify the adapter has the correct item count
-            assertThat(adapter?.itemCount, equalTo(1))
+    @Test
+    fun `handles widget removal while configuring`() =
+        runTest {
+            val testDeckId = addDeck(TEST_DECK_NAME1)
+            preferences.saveSelectedDeck(testWidgetId, testDeckId)
+
+            startTestActivity()
+            advanceUntilIdle()
+            // check that we have a deck previously selected
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME1)))
+
+            val deleteWidgetIntent = Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED)
+            deleteWidgetIntent.updateWidget(testWidgetId)
+            targetContext.sendBroadcast(deleteWidgetIntent)
+            ShadowLooper.runUiThreadTasksIncludingDelayedTasks()
+            // check that the previous preferences data is deleted
+            assertNull(preferences.getSelectedDeckIdFromPreferences(testWidgetId))
         }
 
-    /**
-     * Tests the visibility of different views based on the selected decks.
-     *
-     * This test checks the visibility of the placeholder and configuration container views
-     * before and after adding a deck.
-     */
     @Test
-    fun testUpdateViewVisibility() {
-        val noDecksPlaceholder = activity.findViewById<View>(R.id.no_decks_placeholder)
-        val widgetConfigContainer = activity.findViewById<View>(R.id.widgetConfigContainer)
-
-        // Initially, no decks should be selected
-        activity.updateViewVisibility()
-        assertThat(noDecksPlaceholder.visibility, equalTo(View.VISIBLE))
-        assertThat(widgetConfigContainer.visibility, equalTo(View.GONE))
-
-        // Add a deck and update view visibility
-        val deck = SelectableDeck.Deck(1, "Deck 1")
-        activity.deckAdapter.addDeck(deck)
-        activity.updateViewVisibility()
-
-        assertThat(noDecksPlaceholder.visibility, equalTo(View.GONE))
-        assertThat(widgetConfigContainer.visibility, equalTo(View.VISIBLE))
+    fun `handles decks selection on configuration change`() =
+        runTest {
+            val testDeck1Id = addDeck(TEST_DECK_NAME1)
+            val testDeck2Id = addDeck(TEST_DECK_NAME2)
+            preferences.saveSelectedDeck(testWidgetId, testDeck1Id)
+            val activity = startTestActivity()
+            advanceUntilIdle()
+            // verify that deck 1 is selected
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME1)))
+            // open deck selection, select deck 2 and verify this new selection
+            onView(withId(R.id.change_btn)).perform(click())
+            onView(withText(TEST_DECK_NAME2)).inRoot(isDialog()).perform(click())
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME2)))
+            // simulate a configuration change by recreating the activity
+            activity.recreate()
+            // check that the previously deck 2 is still displayed
+            onView(withId(R.id.deck_name)).check(matches(withText(TEST_DECK_NAME2)))
+            // click done
+            onView(withId(R.id.done_btn)).perform(click())
+            // check that the last selected deck is saved in preferences
+            assertEquals(testDeck2Id, preferences.getSelectedDeckIdFromPreferences(testWidgetId))
+        }
+
+    private fun startTestActivity(
+        widgetId: AppWidgetId = testWidgetId,
+        withEmptyCollection: Boolean = false,
+    ): CardAnalysisWidgetConfig {
+        if (!withEmptyCollection) {
+            ensureNonEmptyCollection()
+        }
+        val intent =
+            Intent(targetContext, CardAnalysisWidgetConfig::class.java).apply {
+                putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId.id)
+            }
+        return startActivityNormallyOpenCollectionWithIntent(
+            CardAnalysisWidgetConfig::class.java,
+            intent,
+        )
+    }
+
+    companion object {
+        private val testWidgetId = AppWidgetId(1)
+        private const val TEST_DECK_NAME1 = "TestDeckName1"
+        private const val TEST_DECK_NAME2 = "TestDeckName2"
     }
 }
