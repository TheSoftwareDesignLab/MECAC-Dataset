diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.kt b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.kt
index c99737c4adcc..e1203ed13b63 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.kt
@@ -34,7 +34,6 @@ import com.ichi2.utils.FileUtil
 import com.ichi2.utils.KotlinCleanup
 import net.ankiweb.rsdroid.BackendException.BackendDbException.BackendDbFileTooNewException
 import net.ankiweb.rsdroid.BackendException.BackendDbException.BackendDbLockedException
-import net.ankiweb.rsdroid.BackendFactory
 import timber.log.Timber
 import java.io.File
 import java.io.IOException
@@ -68,26 +67,6 @@ open class CollectionHelper {
         isCollectionLocked = false
     }
 
-    /**
-     * Opens the collection without checking to see if the directory exists.
-     *
-     * @param Path The path to the collection.anki2 database. Should be unicode.
-     * path should be tested with File.exists() and File.canWrite() before this is called.
-     */
-    private fun openCollection(context: Context, path: String): Collection {
-        Timber.i("Begin openCollection: %s", path)
-        val backend = BackendFactory.getBackend(context)
-        val collection = Storage.collection(
-            context,
-            path,
-            server = false,
-            log = true,
-            backend = backend
-        )
-        Timber.i("End openCollection: %s", path)
-        return collection
-    }
-
     /**
      * Get the single instance of the [Collection], creating it if necessary  (lazy initialization).
      * @param context is no longer used, as the global AnkidroidApp instance is used instead
@@ -98,29 +77,6 @@ open class CollectionHelper {
         return CollectionManager.getColUnsafe()
     }
 
-    /**
-     * Given a path to a .anki2 file returns an open [Collection] associated with the path.
-     *
-     * This operation does not call [initializeAnkiDroidDirectory] and does not set [CollectionManager.collection]
-     *
-     * @param path The path to collection.anki2
-     * @return An open [Collection] object
-     *
-     * @throws StorageAccessException the file at `path` is not writable
-     * @throws StorageAccessException `path` does not exist
-     */
-    @Throws(StorageAccessException::class)
-    fun getColFromPath(path: String, context: Context): Collection {
-        val f = File(path)
-        if (!f.exists()) {
-            throw StorageAccessException("$path does not exist")
-        }
-        if (!f.canWrite()) {
-            throw StorageAccessException("$path is not writable")
-        }
-        return openCollection(context, path)
-    }
-
     /**
      * Calls [getCol] inside a try / catch statement.
      * Send exception report if [reportException] is set and return null if there was an exception.
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionManager.kt b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionManager.kt
index 42f105941ebe..f15f98ed2f8d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionManager.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionManager.kt
@@ -17,9 +17,12 @@
 package com.ichi2.anki
 
 import android.annotation.SuppressLint
+import android.content.Context
 import androidx.annotation.VisibleForTesting
 import androidx.annotation.WorkerThread
 import anki.backend.backendError
+import com.ichi2.anki.servicelayer.ValidatedMigrationSourceAndDestination
+import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles
 import com.ichi2.libanki.Collection
 import com.ichi2.libanki.CollectionV16
 import com.ichi2.libanki.Storage.collection
@@ -221,7 +224,7 @@ object CollectionManager {
             throw BackendException.BackendDbException.BackendDbLockedException(backendError {})
         }
         if (collection == null || collection!!.dbClosed) {
-            val path = createCollectionPath()
+            val path = collectionPathInValidFolder()
             collection =
                 collection(AnkiDroidApp.instance, path, server = false, log = true, backend)
         }
@@ -239,7 +242,7 @@ object CollectionManager {
 
     /** Ensures the AnkiDroid directory is created, then returns the path to the collection file
      * inside it. */
-    private fun createCollectionPath(): String {
+    fun collectionPathInValidFolder(): String {
         val dir = getCollectionDirectory().path
         CollectionHelper.initializeAnkiDroidDirectory(dir)
         return File(dir, "collection.anki2").absolutePath
@@ -385,7 +388,27 @@ object CollectionManager {
         withQueue {
             ensureClosedInner()
             ensureBackendInner()
-            importCollectionPackage(backend!!, createCollectionPath(), colpkgPath)
+            importCollectionPackage(backend!!, collectionPathInValidFolder(), colpkgPath)
+        }
+    }
+
+    /** Migrate collection and media databases to scoped storage.
+     * * Closes the collection, and performs the work in our queue so no
+     * other code can open the collection while the operation runs. Reopens
+     * at the end, and rolls back the path change if reopening fails.
+     */
+    suspend fun migrateEssentialFiles(context: Context, folders: ValidatedMigrationSourceAndDestination) {
+        withQueue {
+            ensureClosedInner(true)
+            val migrator = MigrateEssentialFiles(context, folders)
+            migrator.migrateFiles()
+            migrator.updateCollectionPath()
+            try {
+                ensureOpenInner()
+            } catch (e: Exception) {
+                migrator.restoreOldCollectionPath()
+                throw e
+            }
         }
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index a6ce02ce148d..ed2c912fdc04 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -93,6 +93,7 @@ import com.ichi2.anki.servicelayer.*
 import com.ichi2.anki.servicelayer.SchedulerService.NextCard
 import com.ichi2.anki.servicelayer.ScopedStorageService.isLegacyStorage
 import com.ichi2.anki.servicelayer.ScopedStorageService.mediaMigrationIsInProgress
+import com.ichi2.anki.servicelayer.ScopedStorageService.prepareAndValidateSourceAndDestinationFolders
 import com.ichi2.anki.services.MediaMigrationState
 import com.ichi2.anki.services.MigrationService
 import com.ichi2.anki.services.PREF_MIGRATION_ERROR_TEXT
@@ -2583,15 +2584,12 @@ open class DeckPicker :
         launchCatchingTask {
             val elapsedMillisDuringEssentialFilesMigration = measureTimeMillis {
                 withProgress(getString(R.string.start_migration_progress_message)) {
-                    withContext(Dispatchers.IO) {
-                        loadDeckCounts?.cancel()
-                        CollectionHelper.instance.closeCollection(false, "migration to scoped storage")
-                        ScopedStorageService.migrateEssentialFiles(baseContext)
-
-                        updateDeckList()
-                        handleStartup()
-                        startMigrateUserDataService()
-                    }
+                    loadDeckCounts?.cancel()
+                    val folders = prepareAndValidateSourceAndDestinationFolders(baseContext)
+                    CollectionManager.migrateEssentialFiles(baseContext, folders)
+                    updateDeckList()
+                    handleStartup()
+                    startMigrateUserDataService()
                 }
             }
             if (elapsedMillisDuringEssentialFilesMigration > 800) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/exception/RetryableException.kt b/AnkiDroid/src/main/java/com/ichi2/anki/exception/RetryableException.kt
deleted file mode 100644
index 784b6e92a40f..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/anki/exception/RetryableException.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *  Copyright (c) 2022 David Allison <davidallisongithub@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free Software
- *  Foundation; either version 3 of the License, or (at your option) any later
- *  version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
- *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.ichi2.anki.exception
-
-import timber.log.Timber
-
-/**
- * An exception wrapper signifying that the operation throwing the wrapped exception may be retried
- * @param inner wrapped exception
- */
-class RetryableException(private val inner: Throwable) : java.lang.RuntimeException(inner) {
-    companion object {
-        /**
-         * Retries the provided action if a [RetryableException] is thrown
-         */
-        fun retryOnce(action: (() -> Unit)) {
-            try {
-                action.invoke()
-            } catch (e: RetryableException) {
-                Timber.w(e, "Found retryable exception, retrying")
-                try {
-                    action.invoke()
-                } catch (e: RetryableException) {
-                    Timber.w(e, "action was retried once, throwing")
-                    throw e.inner
-                }
-            }
-        }
-    }
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/ScopedStorageService.kt b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/ScopedStorageService.kt
index a45506adbaee..c03b5dd9d35f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/ScopedStorageService.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/ScopedStorageService.kt
@@ -24,32 +24,30 @@ import android.os.Environment
 import androidx.annotation.VisibleForTesting
 import com.ichi2.anki.AnkiDroidApp
 import com.ichi2.anki.CollectionHelper
+import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.model.Directory
 import com.ichi2.anki.servicelayer.ScopedStorageService.isLegacyStorage
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.MigrateUserData
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.UserDataMigrationPreferences
 import com.ichi2.anki.ui.windows.managespace.isInsideDirectoriesRemovedWithTheApp
+import com.ichi2.compat.CompatHelper
+import com.ichi2.libanki.Utils
 import com.ichi2.utils.FileUtil.getParentsAndSelfRecursive
 import com.ichi2.utils.FileUtil.isDescendantOf
 import com.ichi2.utils.Permissions
 import timber.log.Timber
 import java.io.File
 
-/** A path to the AnkiDroid directory, named "AnkiDroid" by default */
-typealias AnkiDroidDirectory = Directory
-
-/** A path to collection.anki2 */
-typealias CollectionFilePath = String
-
-/** The collection.anki2 CollectionFilePath of [this] AnkiDroid directory */
-fun AnkiDroidDirectory.getCollectionAnki2Path(): CollectionFilePath =
+fun Directory.getCollectionAnki2Path(): String =
     File(this.directory, CollectionHelper.COLLECTION_FILENAME).canonicalPath
 
-/**
- * An [AnkiDroidDirectory] for an AnkiDroid collection which is under scoped storage
+/** Validated source and destination folders.
+ *
+ * - [unscopedSourceDirectory] is the existing AnkiDroid directory, named AnkiDroid by default.
+ * - [scopedDestinationDirectory] is the new directory inside scoped storage where files will be copied.
  * This storage directory is accessible without permissions after scoped storage changes,
- * and is much faster to access
+ * and is much faster to access.
  *
  * When uninstalling: A user will be asked if they want to delete this folder
  * A folder here may be modifiable via USB. In the case of AnkiDroid, all collection folders should
@@ -57,29 +55,33 @@ fun AnkiDroidDirectory.getCollectionAnki2Path(): CollectionFilePath =
  *
  * @see [isLegacyStorage]
  */
-class ScopedAnkiDroidDirectory private constructor(val path: AnkiDroidDirectory) {
-    companion object {
-        /**
-         * Creates an instance of [ScopedAnkiDroidDirectory] from [directory]
-         * @param directory The [AnkiDroidDirectory] which should contain the AnkiDroid collection.
-         * This should not be a directory which is under the legacy (non-scoped storage) model
-         *
-         * @return The directory, or `null` if the provided [directory] was a [legacy directory][isLegacyStorage]
-         * @see [isLegacyStorage]
-         */
-        fun createInstance(directory: Directory, context: Context): ScopedAnkiDroidDirectory? {
-            if (isLegacyStorage(directory.directory.absolutePath, context)) {
-                return null
-            }
+data class ValidatedMigrationSourceAndDestination(val unscopedSourceDirectory: Directory, val scopedDestinationDirectory: Directory)
+
+/** Overrides for testing. If root is provided, a subfolder is automatically created in it.
+ * If subfolder is provided, the exact folder provided is used. */
+sealed class DestFolderOverride {
+    object None : DestFolderOverride()
+    class Root(val folder: File) : DestFolderOverride()
+    class Subfolder(val folder: File) : DestFolderOverride()
+}
 
-            return ScopedAnkiDroidDirectory(directory)
-        }
+fun DestFolderOverride.rootFolder(): File? {
+    return when (this) {
+        is DestFolderOverride.Root -> folder
+        else -> null
+    }
+}
+
+fun DestFolderOverride.subFolder(): File? {
+    return when (this) {
+        is DestFolderOverride.Subfolder -> folder
+        else -> null
     }
 }
 
 object ScopedStorageService {
     /**
-     * Preference listing the [AnkiDroidDirectory] where a scoped storage migration is occurring from
+     * Preference listing the [UnscopedSourceDirectory] where a scoped storage migration is occurring from
      *
      * This directory should exist if the preference is set
      *
@@ -90,7 +92,7 @@ object ScopedStorageService {
     const val PREF_MIGRATION_SOURCE = "migrationSourcePath"
 
     /**
-     * Preference listing the [AnkiDroidDirectory] where a scoped storage migration is migrating to.
+     * Preference listing the [UnscopedSourceDirectory] where a scoped storage migration is migrating to.
      *
      * This directory should exist if the preference is set
      *
@@ -111,42 +113,84 @@ object ScopedStorageService {
     private const val MAX_ANKIDROID_DIRECTORIES = 100
 
     /**
-     * Migrates from the current directory to a directory under scoped storage
-     *
-     * @throws MigrateEssentialFiles.UserActionRequiredException Subclasses define user action required
-     * @throws NoSuchElementException if no directory was valid
-     * @throws IllegalStateException An internal error occurred. Examples:
-     * * If current directory is already under scoped storage
-     * * If destination is not under scoped storage
+     * The buffer space required to migrate files (in addition to the size of the files that we move)
      */
-    fun migrateEssentialFiles(context: Context): File {
-        val collectionPath = AnkiDroidApp.getSharedPrefs(context).getString(CollectionHelper.PREF_COLLECTION_PATH, null)!!
-
-        // Get the scoped storage directory to migrate to. This is based on the location
-        // of the current collection path
-        val bestRootDestination = getBestDefaultRootDirectory(context, File(collectionPath))
-
-        // append a folder name to the root destination.
-        // If the root destination was /storage/emulated/0/Android/com.ichi2.anki/files
-        // we add a subfolder name to allow for more than one AnkiDroid data directory to be migrated.
-        // This is useful as:
-        // * Multiple installations of AnkiDroid go to different folders
-        // * It will allow us to add profiles without changing directories again
-        val bestProfileDirectory = (1..MAX_ANKIDROID_DIRECTORIES).asSequence()
-            .map { File(bestRootDestination, "AnkiDroid$it") }
-            .first { !it.exists() } // skip directories which exist
+    private const val SAFETY_MARGIN_BYTES = 10 * 1024 * 1024
+
+    /** See [ValidatedMigrationSourceAndDestination] */
+    fun prepareAndValidateSourceAndDestinationFolders(
+        context: Context,
+        // used for testing
+        sourceOverride: File? = null,
+        destOverride: DestFolderOverride = DestFolderOverride.None,
+        checkSourceDir: Boolean = true
+    ): ValidatedMigrationSourceAndDestination {
+        // this is checked by deckpicker already, but left here for unit tests
+        if (mediaMigrationIsInProgress(context)) {
+            throw IllegalStateException("Migration is already in progress")
+        }
 
-        try {
-            MigrateEssentialFiles.migrateEssentialFiles(context, bestProfileDirectory)
-        } catch (e: Exception) {
-            try {
-                // MigrateEssentialFiles performs a COPY. Delete the data so we don't take up space.
-                bestProfileDirectory.deleteRecursively()
-            } catch (_: Exception) {
-            }
-            throw e
+        val sourceDirectory = sourceOverride ?: getSourceDirectory()
+        if (checkSourceDir) {
+            validateSourceDirectory(context, sourceDirectory)
+        }
+
+        val destinationRoot = destOverride.rootFolder() ?: getBestDefaultRootDirectory(context, sourceDirectory)
+        val destinationDirectory = destOverride.subFolder() ?: determineBestNewProfileDirectory(destinationRoot)
+        CompatHelper.compat.createDirectories(destinationDirectory)
+
+        validateDestinationDirectory(context, destinationDirectory)
+        ensureSpaceAvailable(sourceDirectory, destinationDirectory)
+
+        Timber.i("will migrate %s -> %s", sourceDirectory, destinationDirectory)
+
+        return ValidatedMigrationSourceAndDestination(
+            Directory.createInstance(sourceDirectory)!!,
+            Directory.createInstance(destinationDirectory)!!
+        )
+    }
+
+    private fun getSourceDirectory(): File {
+        val path = CollectionManager.collectionPathInValidFolder()
+        return File(path).parentFile!!
+    }
+
+    private fun validateSourceDirectory(context: Context, dir: File) {
+        if (!isLegacyStorage(dir, context)) {
+            throw IllegalStateException("Source directory is already under scoped storage")
+        }
+    }
+
+    private fun validateDestinationDirectory(context: Context, destFolder: File) {
+        if (CompatHelper.compat.hasFiles(destFolder)) {
+            throw IllegalStateException("Target directory was not empty: '$destFolder'")
+        }
+
+        if (isLegacyStorage(destFolder, context)) {
+            throw IllegalStateException("Destination folder was not under scoped storage '$destFolder'")
         }
-        return bestProfileDirectory
+    }
+
+    private fun ensureSpaceAvailable(sourceDirectory: File, destDirectory: File) {
+        // Ensure we have space.
+        // This must be after .mkdirs(): determineBytesAvailable works on non-empty directories,
+        MigrateEssentialFiles.UserActionRequiredException.OutOfSpaceException.throwIfInsufficient(
+            available = Utils.determineBytesAvailable(destDirectory.absolutePath),
+            required = MigrateEssentialFiles.PRIORITY_FILES.sumOf { it.spaceRequired(sourceDirectory.path) } + SAFETY_MARGIN_BYTES
+        )
+    }
+
+    /** append a folder name to the root destination.
+     If the root destination was /storage/emulated/0/Android/com.ichi2.anki/files
+     we add a subfolder name to allow for more than one AnkiDroid data directory to be migrated.
+     This is useful as:
+     * Multiple installations of AnkiDroid go to different folders
+     * It will allow us to add profiles without changing directories again
+     */
+    private fun determineBestNewProfileDirectory(rootDestination: File): File {
+        return (1..MAX_ANKIDROID_DIRECTORIES).asSequence()
+            .map { File(rootDestination, "AnkiDroid$it") }
+            .first { !it.exists() } // skip directories which exist
     }
 
     /**
@@ -196,7 +240,8 @@ object ScopedStorageService {
         val parentToSharedDirectoryPath = HashMap<File, File>()
         for (externalPath in externalPaths) {
             for (parent in externalPath.getParentsAndSelfRecursive()) {
-                val firstExternalPathContainedInParent = parentToSharedDirectoryPath.getOrDefault(parent, null)
+                val firstExternalPathContainedInParent =
+                    parentToSharedDirectoryPath.getOrDefault(parent, null)
                 if (firstExternalPathContainedInParent != null) {
                     // We generally prefer the first shared path. So if we already found a shared path contained in this [parent]
                     // (and hence all of its parents)
@@ -213,7 +258,12 @@ object ScopedStorageService {
         }
 
         return templatePath.getParentsAndSelfRecursive()
-            .firstNotNullOfOrNull { parent -> parentToSharedDirectoryPath.getOrDefault(parent, null) }!!
+            .firstNotNullOfOrNull { parent ->
+                parentToSharedDirectoryPath.getOrDefault(
+                    parent,
+                    null
+                )
+            }!!
     }
 
     /**
@@ -226,7 +276,7 @@ object ScopedStorageService {
      * @return `true` if AnkiDroid is storing user data in a Legacy Storage Directory.
      */
     fun isLegacyStorage(context: Context): Boolean {
-        return isLegacyStorage(CollectionHelper.getCurrentAnkiDroidDirectory(context), context)
+        return isLegacyStorage(File(CollectionHelper.getCurrentAnkiDroidDirectory(context)), context)
     }
 
     /**
@@ -238,10 +288,12 @@ object ScopedStorageService {
      * if `isLegacyStorage` is called when obtaining the collection path
      */
     fun isLegacyStorage(context: Context, setCollectionPath: Boolean): Boolean? {
-        if (!setCollectionPath && !AnkiDroidApp.getSharedPrefs(context).contains(CollectionHelper.PREF_COLLECTION_PATH)) {
+        if (!setCollectionPath && !AnkiDroidApp.getSharedPrefs(context)
+            .contains(CollectionHelper.PREF_COLLECTION_PATH)
+        ) {
             return null
         }
-        return isLegacyStorage(CollectionHelper.getCurrentAnkiDroidDirectory(context), context)
+        return isLegacyStorage(File(CollectionHelper.getCurrentAnkiDroidDirectory(context)), context)
     }
 
     /**
@@ -251,10 +303,12 @@ object ScopedStorageService {
      *   [com.ichi2.anki.ui.windows.managespace.isInsideDirectoriesRemovedWithTheApp].
      *
      */
-    fun isLegacyStorage(currentDirPath: String, context: Context): Boolean {
-        val internalScopedDirPath = CollectionHelper.getAppSpecificInternalAnkiDroidDirectory(context)
-        val currentDir = File(currentDirPath).canonicalFile
-        val externalScopedDirs = CollectionHelper.getAppSpecificExternalDirectories(context).map { it.canonicalFile }
+    fun isLegacyStorage(currentDirPath: File, context: Context): Boolean {
+        val internalScopedDirPath =
+            CollectionHelper.getAppSpecificInternalAnkiDroidDirectory(context)
+        val currentDir = currentDirPath.canonicalFile
+        val externalScopedDirs =
+            CollectionHelper.getAppSpecificExternalDirectories(context).map { it.canonicalFile }
         val internalScopedDir = File(internalScopedDirPath).canonicalFile
         Timber.i(
             "isLegacyStorage(): current dir: %s\nscoped external dirs: %s\nscoped internal dir: %s",
@@ -271,6 +325,7 @@ object ScopedStorageService {
         while (currentDirParent != null) {
             for (scopedDir in scopedDirectories) {
                 if (currentDirParent.compareTo(scopedDir) == 0) {
+                    Timber.i("isLegacyStorage(): false")
                     return false
                 }
             }
@@ -279,6 +334,7 @@ object ScopedStorageService {
 
         // If the current AnkiDroid directory isn't a sub directory of the app-private external or internal storage
         // directories, then it must be in a legacy storage directory
+        Timber.i("isLegacyStorage(): true")
         return true
     }
 
@@ -353,6 +409,8 @@ object ScopedStorageService {
     }
 
     fun userIsPromptedToDeleteCollectionOnUninstall(context: Context): Boolean {
-        return File(CollectionHelper.getCollectionPath(context)).isInsideDirectoriesRemovedWithTheApp(context)
+        return File(CollectionHelper.getCollectionPath(context)).isInsideDirectoriesRemovedWithTheApp(
+            context
+        )
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
index 2eff6fa1acce..1d7064d314ee 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFiles.kt
@@ -22,27 +22,18 @@ import androidx.annotation.VisibleForTesting
 import androidx.core.content.edit
 import com.ichi2.anki.AnkiDroidApp
 import com.ichi2.anki.CollectionHelper
-import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.CrashReportService
-import com.ichi2.anki.exception.RetryableException
 import com.ichi2.anki.model.Directory
 import com.ichi2.anki.servicelayer.*
 import com.ichi2.anki.servicelayer.ScopedStorageService.PREF_MIGRATION_DESTINATION
 import com.ichi2.anki.servicelayer.ScopedStorageService.PREF_MIGRATION_SOURCE
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.Companion.PRIORITY_FILES
-import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.Companion.SAFETY_MARGIN_BYTES
-import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.Companion.migrateEssentialFiles
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.UserActionRequiredException
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.NumberOfBytes
 import com.ichi2.annotations.NeedsTest
 import com.ichi2.compat.CompatHelper
-import com.ichi2.libanki.Collection
-import com.ichi2.libanki.Storage
-import com.ichi2.libanki.Utils
-import kotlinx.coroutines.runBlocking
 import net.ankiweb.rsdroid.BackendFactory
 import timber.log.Timber
-import java.io.Closeable
 import java.io.File
 
 /**
@@ -56,9 +47,9 @@ import java.io.File
  * Many of our users are low on space, and leaving "difficult to delete" files in the app private
  * directory is user-hostile.
  *
- * See: [execute]
+ * See: [migrateFiles]
  *
- * Preconditions (verified inside [migrateEssentialFiles] and [execute] - exceptions thrown if not met):
+ * Preconditions (verified inside [migrateEssentialFiles] and [migrateFiles] - exceptions thrown if not met):
  * * Collection is not corrupt and can be opened
  * * Collection basic check passes [UserActionRequiredException.CheckDatabaseException]
  * * Collection can be closed and locked
@@ -69,18 +60,19 @@ open class MigrateEssentialFiles
 @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
 internal constructor(
     private val context: Context,
-    private val sourceDirectory: AnkiDroidDirectory,
-    private val destinationDirectory: ScopedAnkiDroidDirectory
+    private val folders: ValidatedMigrationSourceAndDestination
 ) {
+    private var oldPrefValues: Map<String, String?>? = null
+
     /**
      * Copies (not moves) the [essential files][PRIORITY_FILES] to [destinationDirectory]
      *
      * Then opens a collection at the new location, and updates [CollectionHelper.PREF_COLLECTION_PATH] there.
      *
-     * After:
+     * After, call updateCollectionPath(), and then:
      *
-     * [PREF_MIGRATION_SOURCE] contains the [AnkiDroidDirectory] with the remaining items to move ([sourceDirectory])
-     * [PREF_MIGRATION_DESTINATION] contains an [AnkiDroidDirectory] with the copied collection.anki2/media ([destinationDirectory])
+     * [PREF_MIGRATION_SOURCE] contains the unscopedSourceDirectory with the remaining items to move ([sourceDirectory])
+     * [PREF_MIGRATION_DESTINATION] contains the scopedDestinationDirectory with the copied collection.anki2/media ([destinationDirectory])
      * [CollectionHelper.PREF_COLLECTION_PATH] now points to the new location of the collection in private storage
      * [ScopedStorageService.UserDataMigrationPreferences.migrationInProgress] returns `true`
      *
@@ -90,82 +82,35 @@ internal constructor(
      * @throws UserActionRequiredException.CheckDatabaseException if 'Check Database' needs to be done first
      * @throws IllegalStateException If a lock cannot be acquired on the collection
      */
-    fun execute() {
-        val destinationPath = destinationDirectory.path
-
-        ensureFolderIsEmpty(destinationPath)
-
-        // ensure the current collection is the one in sourcePath
-        ensurePathIsCurrentCollectionPath(sourceDirectory)
-
-        // Throws MissingEssentialFileException if the files we need to copy don't exist
-        throwIfEssentialFilesDoNotExistInDestination(sourceDirectory)
+    fun migrateFiles() {
+        val (unscopedSourceDirectory, scopedDestinationDirectory) = folders
 
-        // Close the collection before we lock the files.
-        // ensureCollectionNotCorrupted is not compatible with an already open collection
-        closeCollection()
-
-        // Race Condition! - The collection could be opened here before locking (maybe by API?).
-        // This is resolved as a RetryableException is thrown if the collection is open
-
-        // open the collection directly and ensure it's not corrupted (must be closed and not locked)
-        throwIfCollectionIsCorrupted(sourceDirectory.getCollectionAnki2Path())
+        try {
+            // Throws MissingEssentialFileException if the files we need to copy don't exist
+            throwIfEssentialFilesDoNotExistInDirectory(unscopedSourceDirectory)
 
-        // Lock the collection & journal, to ensure that nobody can open/corrupt it
-        // Also ensures the collection may not be opened
-        lockCollection().use {
             // Copy essential files to new location. Guaranteed to be empty
-            for (file in iterateEssentialFiles(sourceDirectory)) {
-                copyTopLevelFile(file, destinationPath)
+            for (file in iterateEssentialFiles(unscopedSourceDirectory)) {
+                copyTopLevelFile(file, scopedDestinationDirectory)
             }
-        }
-
-        val destinationCollectionAnki2Path = destinationPath.getCollectionAnki2Path()
-
-        throwIfEssentialFilesAreMutated(sourceDirectory, destinationDirectory)
-
-        // Open the collection in the new location, checking for corruption
-        throwIfCollectionIsCorrupted(destinationCollectionAnki2Path)
 
-        // set the preferences to the new deck path + checks CollectionHelper
-        // sets migration variables (migrationIsInProgress will be true)
-        updatePreferences(destinationPath)
-
-        // updatePreferences() opened the collection in the new location, which will have created
-        // a -wal file if the new backend code is active. Close it again, so that tests don't
-        // fail due to the presence of a -wal file in the destination folder.
-        if (!BackendFactory.defaultLegacySchema) {
-            closeCollection()
-        }
-    }
-
-    /**
-     * Ensures that [directory] is empty
-     * @throws IllegalStateException if [directory] is not empty
-     */
-    private fun ensureFolderIsEmpty(directory: AnkiDroidDirectory) {
-        val listFiles = directory.listFiles()
-
-        if (listFiles.any()) {
-            throw IllegalStateException("destination was non-empty '$directory'")
-        }
-    }
-
-    /**
-     * Ensures that the provided [path] represents the current AnkiDroid collection ([CollectionHelper.getCol])
-     */
-    private fun ensurePathIsCurrentCollectionPath(path: AnkiDroidDirectory) {
-        val currentCollectionFilePath = getCurrentCollectionPath()
-        if (path.directory.canonicalPath != currentCollectionFilePath.directory.canonicalPath) {
-            throw IllegalStateException("paths did not match: '$path' and '$currentCollectionFilePath' (Collection)")
+            // Check that the files in the target location are identical.
+            throwIfEssentialFilesAreMutated(unscopedSourceDirectory, scopedDestinationDirectory)
+        } catch (e: Exception) {
+            try {
+                // MigrateEssentialFiles performs a COPY. Delete the data so we don't take up space.
+                folders.scopedDestinationDirectory.directory.deleteRecursively()
+            } catch (_: Exception) {
+            }
+            throw e
         }
     }
 
     @SuppressLint("NewApi") // contentEquals is API 26, we're guaranteed to be above this if performing a migration
     @NeedsTest("untested, needs documentation")
-    private fun throwIfEssentialFilesAreMutated(sourceDirectory: AnkiDroidDirectory, destinationDirectory: ScopedAnkiDroidDirectory) {
+    private fun throwIfEssentialFilesAreMutated(sourceDirectory: Directory, destinationDirectory: Directory) {
         // TODO: For Arthur to improve
-        for ((source, destination) in iterateEssentialFiles(sourceDirectory).zip(iterateEssentialFiles(destinationDirectory.path))) {
+        for ((source, destination) in iterateEssentialFiles(sourceDirectory).zip(iterateEssentialFiles(destinationDirectory))) {
             try {
                 throwIfContentUnequal(source, destination)
             } catch (e: Exception) {
@@ -184,7 +129,7 @@ internal constructor(
      * Ensures that all files in [PRIORITY_FILES] and that are in the source exists in the destination.
      * @throws UserActionRequiredException.MissingEssentialFileException if a file does not exist
      */
-    private fun throwIfEssentialFilesDoNotExistInDestination(sourcePath: AnkiDroidDirectory) {
+    private fun throwIfEssentialFilesDoNotExistInDirectory(sourcePath: Directory) {
         for (file in iterateEssentialFiles(sourcePath)) {
             if (!file.exists()) {
                 throw UserActionRequiredException.MissingEssentialFileException(file)
@@ -195,7 +140,7 @@ internal constructor(
     /**
      * Copies [file] to [destinationDirectory], retaining the same filename
      */
-    fun copyTopLevelFile(file: File, destinationDirectory: AnkiDroidDirectory) {
+    fun copyTopLevelFile(file: File, destinationDirectory: Directory) {
         val destinationPath = File(destinationDirectory.directory, file.name).path
         Timber.i("Migrating essential file: '${file.name}'")
         Timber.d("Copying '$file' to '$destinationPath'")
@@ -207,184 +152,29 @@ internal constructor(
      * The collection is opened with this new preference.
      * Any error in opening the collection are thrown, and the preference change is reverted.
      */
-    private fun updatePreferences(destinationDirectory: AnkiDroidDirectory) {
+    fun updateCollectionPath() {
         val prefs = AnkiDroidApp.getSharedPrefs(context)
 
         // keep the old values in case we need to restore them
-        val oldPrefValues = listOf(PREF_MIGRATION_SOURCE, PREF_MIGRATION_DESTINATION, CollectionHelper.PREF_COLLECTION_PATH)
+        oldPrefValues = listOf(PREF_MIGRATION_SOURCE, PREF_MIGRATION_DESTINATION, CollectionHelper.PREF_COLLECTION_PATH)
             .associateWith { prefs.getString(it, null) }
 
         prefs.edit {
             // specify that a migration is in progress
-            putString(PREF_MIGRATION_SOURCE, sourceDirectory.directory.absolutePath)
-            putString(PREF_MIGRATION_DESTINATION, destinationDirectory.directory.absolutePath)
-            putString(CollectionHelper.PREF_COLLECTION_PATH, destinationDirectory.directory.absolutePath)
-        }
-
-        // open the collection in the new location - data is now migrated
-        try {
-            throwIfCollectionCannotBeOpened()
-        } catch (e: Throwable) {
-            // if we can't open the migrated collection, revert the preference change so the user
-            // can still use their collection.
-            Timber.w("error opening new collection, restoring old values")
-            prefs.edit {
-                oldPrefValues.forEach {
-                    putString(it.key, it.value)
-                }
-            }
-            throw e
-        }
-    }
-
-    /**
-     * Checks that the default collection (from [CollectionHelper.getCol]) can be opened
-     * @throws IllegalStateException If collection can't be opened
-     */
-    @VisibleForTesting
-    open fun throwIfCollectionCannotBeOpened() {
-        CollectionHelper.instance.getCol(context) ?: throw IllegalStateException("collection could not be opened")
-    }
-
-    /**
-     * Ensures that the collection is closed.
-     * This will temporarily open the collection during the operation if it was already closed
-     */
-    private fun closeCollection() {
-        runBlocking { CollectionManager.ensureClosed() }
-    }
-
-    /** Converts the current AnkiDroid collection path to an [AnkiDroidDirectory] instance */
-    private fun getCurrentCollectionPath(): AnkiDroidDirectory {
-        val collectionAnki2Path = File(CollectionHelper.getCollectionPath(context))
-        // happy with the !! here: the parent of the AnkiDroid file is a directory
-        return AnkiDroidDirectory.createInstance(File(collectionAnki2Path.canonicalPath).parent!!)!!
-    }
-
-    /**
-     * Locks the collection and returns a [Closeable] when the closeable is closed, the collection is unlocked
-     *
-     * @throws IllegalStateException Collection is openable after lock acquired
-     */
-    private fun lockCollection(): Closeable {
-        return createLockedCollection().also {
-            // Since we locked the files, we want to ensure that the collection can no longer be opened
-            try {
-                ensureCollectionNotOpenable()
-            } catch (e: Exception) {
-                Timber.w(e, "collection was openable")
-                it.close()
-                throw e
-            }
+            putString(PREF_MIGRATION_SOURCE, folders.unscopedSourceDirectory.directory.absolutePath)
+            putString(PREF_MIGRATION_DESTINATION, folders.scopedDestinationDirectory.directory.absolutePath)
+            putString(CollectionHelper.PREF_COLLECTION_PATH, folders.scopedDestinationDirectory.directory.absolutePath)
         }
     }
 
-    /**
-     * Locks the collection and returns a [LockedCollection] which allows the collection to be unlocked
-     */
-    @VisibleForTesting
-    fun createLockedCollection() = LockedCollection.createLockedInstance()
-
-    /**
-     * Check that the collection is not openable. This is expected to be called after the collection is locked, to check whether it was correctly locked.
-     * We must check it because improperly locked collections may lead to database corruption. (copying may mean the DB is out of sync with the journal)
-     * If the collection is openable or open, close it.
-     * @throws RetryableException ([IllegalStateException]) if the collection was openable
-     */
-    private fun ensureCollectionNotOpenable() {
-        val lockedCollection: Collection?
-        try {
-            lockedCollection = CollectionHelper.instance.getCol(context)
-        } catch (e: Exception) {
-            Timber.i("Expected exception thrown: ", e)
-            return
-        }
-
-        // Unexpected: collection was opened. Close it and report an error.
-        // Note: it shouldn't be null - a null value infers a new collection can't be created
-        // or if the storage media is removed
-        try {
-            lockedCollection?.close()
-        } catch (e: Exception) {
-        }
-
-        throw RetryableException(IllegalStateException("Collection not locked correctly"))
-    }
-
-    /**
-     * Given the path to a `collection.anki2` which is not open, ensures the collection is usable
-     *
-     * Otherwise: throws an exception
-     *
-     * @throws UserActionRequiredException.CheckDatabaseException If "check database" is required
-     *
-     * This may also fail for the following, less likely reasons:
-     * * Collection is already open
-     * * Collection directory does not exist
-     * * Collection directory is not writable
-     * * Error opening collection
-     */
-    open fun throwIfCollectionIsCorrupted(path: CollectionFilePath) {
-        var result: Collection? = null
-        var firstException: Throwable? = null
-        try {
-            // Store the collection in `result` so we can close it in the `finally`
-            // this can throw [StorageAccessException]: locked or invalid
-            result = CollectionHelper.instance.getColFromPath(path, context)
-            if (!result.basicCheck()) {
-                throw UserActionRequiredException.CheckDatabaseException()
-            }
-        } catch (e: Throwable) {
-            firstException = e
-        }
-        // this can throw, which ruins the stack trace if the above block threw
-        try {
-            result?.close()
-        } catch (ex: Exception) {
-            Timber.w("exception thrown closing database", ex)
-            firstException = firstException ?: ex
-        }
-
-        // If close() threw in the finally {}, we want to abort.
-        if (firstException != null) {
-            throw firstException
-        }
-    }
-
-    /**
-     * Represents a locked collection. Unlocks the collection when [close] is called.
-     *
-     * Note that collection locking is related to being unable to open the collection.
-     * An open collection may still exist after this lock is taken.
-     *
-     * Usage:
-     * ```kotlin
-     * LockedCollection.createLockedInstance().use {
-     *      // do something requiring the collection to be closed
-     * } // collection is unlocked here
-     * ```
-     */
-    class LockedCollection private constructor() : Closeable {
-        companion object {
-            /**
-             * Locks the collection and creates an instance of [LockedCollection]
-             * @see Storage.lockCollection
-             */
-            fun createLockedInstance(): LockedCollection {
-                // Ideally, we would want to lock the files.
-                // However, on macOS, file locking is only advisor and not mandatory to follow,
-                // meaning that even if the lock succeed, another thread can still open the file.
-                // This is why we instead decided to lock with static variable.
-                // Locked using the static lock in [Storage]
-                Storage.lockCollection()
-                return LockedCollection()
+    /** Can be called if collection fails to open after migration completes. */
+    fun restoreOldCollectionPath() {
+        val prefs = AnkiDroidApp.getSharedPrefs(context)
+        prefs.edit {
+            oldPrefValues?.forEach {
+                putString(it.key, it.value)
             }
         }
-
-        /** Unlocks the collection */
-        override fun close() {
-            Storage.unlockCollection()
-        }
     }
 
     /**
@@ -484,11 +274,6 @@ internal constructor(
     }
 
     companion object {
-        /**
-         * The buffer space required to migrate files (in addition to the size of the files that we move)
-         */
-        private const val SAFETY_MARGIN_BYTES = 10 * 1024 * 1024
-
         /**
          * Lists the files to be moved by [MigrateEssentialFiles]
          * Priority files are files to be moved if they exist.
@@ -501,72 +286,17 @@ internal constructor(
             } else {
                 // this is created on demand in the new backend
                 OptionalFile("collection.media.db")
-            }, // media database + journal
-            OptionalFile(".nomedia"), // written immediately
+            },
+            OptionalFile("collection.anki2-wal"),
+            OptionalFile("collection.media.db-wal"),
+            OptionalFile(".nomedia"),
             OptionalFile("collection.log") // written immediately and conflicts
         )
 
         /**
          * A collection of [File] objects to be moved by [MigrateEssentialFiles]
          */
-        fun iterateEssentialFiles(sourcePath: AnkiDroidDirectory) =
+        fun iterateEssentialFiles(sourcePath: Directory) =
             PRIORITY_FILES.flatMap { it.getEssentialFiles(sourcePath.directory.canonicalPath) }
-
-        /**
-         * Creates and invokes a [MigrateEssentialFiles] instance.
-         *
-         * Validates the paths are scoped and non-scoped and that the user has space.
-         * Creates [destination] optionally
-         * Runs the migration and handles retries
-         *
-         * @param destination The directory which is to be created and migrated to.
-         * Does not need to exist. Must be non-legacy. If it does exist, it must be empty
-         * @param transformAlgo test-only: Allows wrapping the generated [MigrateEssentialFiles] to allow for mocking
-         *
-         * @throws IllegalStateException The current collection was under scoped storage
-         * @throws IllegalStateException [destination] was non-empty
-         * @throws IllegalStateException [destination] was not under scoped storage
-         * @throws UserActionRequiredException.OutOfSpaceException if insufficient space to migrate
-         * @throws UserActionRequiredException.MissingEssentialFileException if an essential file does not exist
-         * @throws UserActionRequiredException.CheckDatabaseException if 'Check Database' needs to be done first
-         *
-         * @see [execute] for other failures
-         */
-        internal fun migrateEssentialFiles(
-            context: Context,
-            destination: File,
-        ) {
-            val collectionPath: CollectionFilePath = CollectionHelper.instance.getCol(context)!!.path
-            val sourceDirectory = File(collectionPath).parent!!
-
-            if (!ScopedStorageService.isLegacyStorage(sourceDirectory, context)) {
-                throw IllegalStateException("Directory is already under scoped storage")
-            }
-
-            // creates directory and ensures it's empty
-            CompatHelper.compat.createDirectories(destination)
-            if (CompatHelper.compat.hasFiles(destination)) {
-                throw IllegalStateException("Target directory was not empty: '$destination'")
-            }
-
-            // ensure we have space
-            // this must be after .mkdirs(): determineBytesAvailable works on non-empty directories,
-            UserActionRequiredException.OutOfSpaceException.throwIfInsufficient(
-                available = Utils.determineBytesAvailable(destination.absolutePath),
-                required = PRIORITY_FILES.sumOf { it.spaceRequired(sourceDirectory) } + SAFETY_MARGIN_BYTES
-            )
-
-            val destinationDirectory = Directory.createInstance(destination)!!
-            // ensure destination is under scoped storage
-            val destinationAnkiDroidDirectory = ScopedAnkiDroidDirectory.createInstance(destinationDirectory, context) ?: throw IllegalStateException("Destination folder was not under scoped storage '$destinationDirectory'")
-
-            RetryableException.retryOnce {
-                MigrateEssentialFiles(
-                    context,
-                    AnkiDroidDirectory.createInstance(sourceDirectory)!!, // !! is fine here - parent of collection.anki2 is a directory
-                    destinationAnkiDroidDirectory
-                ).execute()
-            }
-        }
     }
 }
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/exception/RetryableExceptionTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/exception/RetryableExceptionTest.kt
deleted file mode 100644
index 6b29582930db..000000000000
--- a/AnkiDroid/src/test/java/com/ichi2/anki/exception/RetryableExceptionTest.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *  Copyright (c) 2022 David Allison <davidallisongithub@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free Software
- *  Foundation; either version 3 of the License, or (at your option) any later
- *  version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
- *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.ichi2.anki.exception
-
-import com.ichi2.testutils.TestException
-import org.hamcrest.CoreMatchers.equalTo
-import org.hamcrest.MatcherAssert.assertThat
-import org.junit.Test
-import kotlin.test.assertFailsWith
-
-/** Tests [RetryableException] */
-class RetryableExceptionTest {
-    var called = 0
-
-    @Test
-    fun non_throwing_function_works() {
-        RetryableException.retryOnce { called++ }
-        assertThat("function should only be called once", called, equalTo(1))
-    }
-
-    @Test
-    fun conditionally_throwing_function_retries() {
-        RetryableException.retryOnce { called++; if (called == 1) { throw RetryableException(TestException("throwing_function_retries")) } }
-        assertThat("function should be called twice", called, equalTo(2))
-    }
-
-    @Test
-    fun throwing_function_fails_with_inner() {
-        val exception = assertFailsWith<TestException> {
-            RetryableException.retryOnce { called++; throw RetryableException(TestException("throwing_function_retries")) }
-        }
-        assertThat("exception message is retained", exception.message, equalTo("throwing_function_retries"))
-        assertThat("function should be called twice", called, equalTo(2))
-    }
-}
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/ScopedStorageAnkiDroidTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/ScopedStorageAnkiDroidTest.kt
index cfb5e1536622..1f4e24b30f9c 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/ScopedStorageAnkiDroidTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/ScopedStorageAnkiDroidTest.kt
@@ -19,18 +19,18 @@ package com.ichi2.anki.servicelayer
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.AnkiDroidApp
 import com.ichi2.anki.CollectionHelper
+import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.RobolectricTest
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles
+import com.ichi2.anki.servicelayer.scopedstorage.migrateEssentialFilesForTest
 import com.ichi2.anki.servicelayer.scopedstorage.setLegacyStorage
 import com.ichi2.libanki.Collection
 import com.ichi2.testutils.ShadowStatFs
-import com.ichi2.testutils.TestException
+import com.ichi2.testutils.assertFalse
 import com.ichi2.testutils.createTransientDirectory
 import io.mockk.*
 import org.hamcrest.MatcherAssert.assertThat
 import org.hamcrest.Matchers.equalTo
-import org.hamcrest.Matchers.not
-import org.hamcrest.io.FileMatchers
 import org.junit.Test
 import org.junit.runner.RunWith
 import java.io.File
@@ -41,57 +41,66 @@ class ScopedStorageAnkiDroidTest : RobolectricTest() {
 
     override fun useInMemoryDatabase(): Boolean = false
 
+    private fun getMigrationSourcePath() = File(col.path).parent!!
+
     @Test
-    fun migrate_essential_files_successful() {
+    fun migrate_essential_files_successful() = runTest {
         val colPath = setupCol().path
         ShadowStatFs.markAsNonEmpty(getBestRootDirectory())
         val migratedFrom = File(colPath).parentFile!!
-        val migratedTo = ScopedStorageService.migrateEssentialFiles(targetContext)
+
+        val migratedTo = migrateEssentialFilesForTest(targetContext, getMigrationSourcePath())
+
+        // close collection again so -wal doesn't end up in the list
+        CollectionManager.ensureClosed()
 
         val from = migratedFrom.listFiles()!!.associateBy { it.name }.toMutableMap()
         val to = migratedTo.listFiles()!!.associateBy { it.name }.toMutableMap()
 
         assertThat("target folder name should be set", migratedTo.name, equalTo("AnkiDroid1"))
-        assertThat("target should be under scoped storage", ScopedStorageService.isLegacyStorage(migratedTo.absolutePath, targetContext), equalTo(false))
+        assertThat("target should be under scoped storage", ScopedStorageService.isLegacyStorage(migratedTo.absoluteFile, targetContext), equalTo(false))
         assertThat("bare files should be moved", to.keys, equalTo(from.keys))
     }
 
     @Test
-    fun migrate_essential_files_second_directory() {
+    fun migrate_essential_files_second_directory() = runTest {
         setupCol()
-        getBestRootDirectory().createTransientDirectory("AnkiDroid1")
-        mockkObject(MigrateEssentialFiles) {
-            val destinationFile = slot<File>()
-            every { MigrateEssentialFiles.migrateEssentialFiles(any(), destination = capture(destinationFile)) } returns Unit
-
-            ScopedStorageService.migrateEssentialFiles(targetContext)
+        val root = getBestRootDirectory()
+        root.createTransientDirectory("AnkiDroid1")
 
-            assertThat(destinationFile.captured.name, equalTo("AnkiDroid2"))
-        }
+        val destinationFile = migrateEssentialFilesForTest(targetContext, getMigrationSourcePath(), destOverride = DestFolderOverride.Root(root))
+        assertThat(destinationFile.name, equalTo("AnkiDroid2"))
     }
 
     @Test
-    fun migrate_essential_files_fails_on_no_available_directory() {
+    fun migrate_essential_files_fails_on_no_available_directory() = runTest {
         setupCol()
+        val root = getBestRootDirectory()
         for (i in 1..100) {
-            getBestRootDirectory().createTransientDirectory("AnkiDroid$i")
+            root.createTransientDirectory("AnkiDroid$i")
         }
 
         // if "AnkiDroid100" can't be created
-        assertFailsWith<NoSuchElementException> { ScopedStorageService.migrateEssentialFiles(targetContext) }
+        assertFailsWith<NoSuchElementException> { migrateEssentialFilesForTest(targetContext, getMigrationSourcePath(), destOverride = DestFolderOverride.Root(root)) }
     }
 
     @Test
-    fun migrate_essential_files_deletes_created_directory_on_failure() {
+    fun migrate_essential_files_deletes_created_directory_on_failure() = runTest {
         setupCol()
-        mockkObject(MigrateEssentialFiles) {
-            val destinationFile = slot<File>()
-            every { MigrateEssentialFiles.migrateEssentialFiles(any(), destination = capture(destinationFile)) } throws TestException("failed")
 
-            assertFailsWith<TestException> { ScopedStorageService.migrateEssentialFiles(targetContext) }
+        File(col.path).delete()
+
+        val folder = getBestRootDirectory()
 
-            assertThat("destination was deleted on failure", destinationFile.captured, not(FileMatchers.anExistingDirectory()))
+        assertFailsWith<MigrateEssentialFiles.UserActionRequiredException.MissingEssentialFileException> {
+            migrateEssentialFilesForTest(
+                targetContext,
+                getMigrationSourcePath(),
+                destOverride = DestFolderOverride.Subfolder(folder)
+            )
         }
+
+        assertFalse("folder should not exist", folder.exists())
     }
 
     /**
@@ -99,6 +108,7 @@ class ScopedStorageAnkiDroidTest : RobolectricTest() {
      */
     private fun setupCol(): Collection {
         setLegacyStorage()
+        ShadowStatFs.markAsNonEmpty(getBestRootDirectory())
         return col
     }
 
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesIntegrationTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesIntegrationTest.kt
index 857ecc5bf869..8af083cfc8a8 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesIntegrationTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesIntegrationTest.kt
@@ -16,13 +16,11 @@
 
 package com.ichi2.anki.servicelayer.scopedstorage
 
-import androidx.core.content.edit
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.ichi2.anki.CollectionHelper
 import com.ichi2.anki.RobolectricTest
+import com.ichi2.anki.servicelayer.DestFolderOverride
 import com.ichi2.anki.servicelayer.ScopedStorageService
 import com.ichi2.annotations.NeedsTest
-import com.ichi2.testutils.AnkiAssert.assertDoesNotThrow
 import org.hamcrest.CoreMatchers.containsString
 import org.hamcrest.CoreMatchers.equalTo
 import org.hamcrest.MatcherAssert.assertThat
@@ -30,10 +28,6 @@ import org.junit.After
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
-import org.mockito.ArgumentMatchers
-import org.mockito.Mockito
-import org.mockito.kotlin.KStubbing
-import org.mockito.kotlin.spy
 import org.robolectric.shadows.ShadowStatFs
 import java.io.File
 import java.io.FileOutputStream
@@ -42,7 +36,7 @@ import kotlin.io.path.pathString
 import kotlin.test.assertFailsWith
 
 /**
- * Test for [MigrateEssentialFiles.migrateEssentialFiles]
+ * Test for [MigrateEssentialFiles]
  */
 @RunWith(AndroidJUnit4::class)
 @NeedsTest("fails when you can't create the destination directory")
@@ -76,12 +70,12 @@ class MigrateEssentialFilesIntegrationTest : RobolectricTest() {
     }
 
     @Test
-    fun migrate_essential_files_success() {
+    fun migrate_essential_files_success() = runTest {
         assertMigrationNotInProgress()
 
         val oldDeckPath = getPreferences().getString("deckPath", "")
 
-        migrateEssentialFiles()
+        migrateEssentialFilesForTest(targetContext, File(col.path).parent!!, DestFolderOverride.Subfolder(destinationPath))
 
         // assert the collection is open, working, and has been moved to the outPath
         assertThat(col.basicCheck(), equalTo(true))
@@ -101,7 +95,7 @@ class MigrateEssentialFilesIntegrationTest : RobolectricTest() {
         ShadowStatFs.reset()
 
         val ex = assertFailsWith<MigrateEssentialFiles.UserActionRequiredException.OutOfSpaceException> {
-            migrateEssentialFiles()
+            ScopedStorageService.prepareAndValidateSourceAndDestinationFolders(targetContext)
         }
 
         assertThat(ex.message, containsString("More free space is required"))
@@ -109,23 +103,22 @@ class MigrateEssentialFilesIntegrationTest : RobolectricTest() {
 
     @Test
     fun exception_if_source_already_scoped() {
-        getPreferences().edit { putString(DECK_PATH, destinationPath.canonicalPath) }
-        CollectionHelper.instance.setColForTests(null)
-
-        val newDestination = File(destinationPath, "again")
-
         val ex = assertFailsWith<IllegalStateException> {
-            MigrateEssentialFiles.migrateEssentialFiles(targetContext, newDestination)
+            ScopedStorageService.prepareAndValidateSourceAndDestinationFolders(targetContext, sourceOverride = destinationPath)
         }
 
-        assertThat(ex.message, containsString("Directory is already under scoped storage"))
+        assertThat(ex.message, containsString("Source directory is already under scoped storage"))
     }
 
     @Test
-    fun no_exception_if_directory_is_empty_directory_migrate_essential_files() {
+    fun no_exception_if_directory_is_empty_directory_migrate_essential_files() = runTest {
         assertThat("destination should not exist ($destinationPath)", destinationPath.exists(), equalTo(false))
 
-        assertDoesNotThrow { migrateEssentialFiles() }
+        migrateEssentialFilesForTest(
+            targetContext,
+            File(col.path).parent!!,
+            DestFolderOverride.Subfolder(destinationPath)
+        )
     }
 
     @Test
@@ -138,39 +131,9 @@ class MigrateEssentialFilesIntegrationTest : RobolectricTest() {
         }
 
         val ex = assertFailsWith<IllegalStateException> {
-            migrateEssentialFiles()
+            ScopedStorageService.prepareAndValidateSourceAndDestinationFolders(targetContext, destOverride = DestFolderOverride.Subfolder(destinationPath))
         }
 
         assertThat(ex.message, containsString("Target directory was not empty"))
     }
-
-    /**
-     * A race condition can occur between closing and locking the collection.
-     *
-     * We add a retry mechanism to confirm that this works
-     */
-    @Test
-    fun retry_succeeds_if_race_condition_occurs() {
-        var timesCalled = 0
-
-        migrateEssentialFiles {
-            Mockito.doAnswer {
-                // if it's the first time, open the collection instead of checking for corruption
-                // on the retry this is not true
-                if (timesCalled == 0) {
-                    col.basicCheck()
-                }
-                timesCalled++
-            }.`when`(it).throwIfCollectionIsCorrupted(ArgumentMatchers.anyString())
-        }
-
-        assertThat(timesCalled, equalTo(3))
-    }
-
-    private fun migrateEssentialFiles(stubbing: (KStubbing<MigrateEssentialFiles>.(MigrateEssentialFiles) -> Unit)? = null) {
-        fun mock(e: MigrateEssentialFiles): MigrateEssentialFiles {
-            return if (stubbing == null) e else spy(e, stubbing)
-        }
-        MigrateEssentialFiles.migrateEssentialFiles(targetContext, destinationPath, ::mock)
-    }
 }
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesTest.kt
index 8bd8243615ac..cdfec46061ea 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/MigrateEssentialFilesTest.kt
@@ -16,23 +16,22 @@
 
 package com.ichi2.anki.servicelayer.scopedstorage
 
+import android.content.Context
 import android.database.sqlite.SQLiteDatabaseCorruptException
-import androidx.annotation.CheckResult
 import androidx.core.content.edit
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.ichi2.anki.CollectionHelper
+import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.RobolectricTest
-import com.ichi2.anki.exception.RetryableException
-import com.ichi2.anki.model.Directory
-import com.ichi2.anki.servicelayer.ScopedAnkiDroidDirectory
+import com.ichi2.anki.servicelayer.DestFolderOverride
 import com.ichi2.anki.servicelayer.ScopedStorageService
-import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.LockedCollection
+import com.ichi2.anki.servicelayer.ScopedStorageService.prepareAndValidateSourceAndDestinationFolders
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles.UserActionRequiredException.MissingEssentialFileException
 import com.ichi2.compat.CompatHelper
-import com.ichi2.libanki.Storage
+import com.ichi2.libanki.bool
 import com.ichi2.testutils.CollectionDBCorruption
-import com.ichi2.testutils.TestException
 import com.ichi2.testutils.createTransientDirectory
+import net.ankiweb.rsdroid.BackendException
 import org.hamcrest.CoreMatchers.*
 import org.hamcrest.MatcherAssert.assertThat
 import org.hamcrest.io.FileMatchers
@@ -40,8 +39,8 @@ import org.junit.After
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
-import org.mockito.Mockito
 import org.mockito.kotlin.*
+import org.robolectric.shadows.ShadowStatFs
 import java.io.File
 import kotlin.io.path.Path
 import kotlin.io.path.pathString
@@ -67,27 +66,30 @@ class MigrateEssentialFilesTest : RobolectricTest() {
         CollectionHelper.instance.setColForTests(null)
         super.setUp()
         defaultCollectionSourcePath = getMigrationSourcePath()
+        // arbitrary large values
+        ShadowStatFs.registerStats(getMigrationDestinationPath(targetContext), 100, 20, 10000)
     }
 
     @After
     override fun tearDown() {
         super.tearDown()
+        ShadowStatFs.reset()
         if (checkCollectionAfter) {
             assertThat("col is still valid", col.basicCheck())
         }
     }
 
     @Test
-    fun successful_migration() {
+    fun successful_migration() = runTest {
         assertMigrationNotInProgress()
 
-        this.addNoteUsingBasicModel("Hello", "World")
+        addNoteUsingBasicModel("Hello", "World")
 
         val collectionSourcePath = getMigrationSourcePath()
 
         val oldDeckPath = getPreferences().getString(DECK_PATH, "")
 
-        val outPath = executeAlgorithmSuccessfully(collectionSourcePath)
+        val outPath = migrateEssentialFilesForTest(targetContext, collectionSourcePath)
 
         // assert the collection is open, working, and has been moved to the outPath
         assertThat(col.basicCheck(), equalTo(true))
@@ -114,79 +116,41 @@ class MigrateEssentialFilesTest : RobolectricTest() {
         }
         assertMigrationInProgress()
 
-        val ex = assertFailsWith<IllegalStateException> { executeAlgorithmSuccessfully(defaultCollectionSourcePath) }
+        val ex = assertFailsWith<IllegalStateException> {
+            prepareAndValidateSourceAndDestinationFolders(targetContext)
+        }
 
         assertThat(ex.message, containsString("Migration is already in progress"))
     }
 
     @Test
     fun exception_thrown_if_destination_is_not_empty() {
+        val source = getMigrationSourcePath()
         // This is not handled upstream as it's a logic error - the directory passed in should be created
-        val nonEmptyDestination = getMigrationDestinationPath().also {
+        val nonEmptyDestination = getMigrationDestinationPath(targetContext).also {
             File(it, "tmp.txt").createNewFile()
         }
 
-        val exception = assertFailsWith<IllegalStateException> { executeAlgorithmSuccessfully(getMigrationSourcePath(), optionalDestinationPath = nonEmptyDestination) }
-        assertThat(exception.message, startsWith("destination was non-empty"))
-    }
-
-    @Test
-    fun fails_if_source_path_is_not_current_ankiDroid_collection() {
-        val invalidSourcePath = createTransientDirectory().absolutePath
-        // preliminary check, not part of the test assertion.
-        assertThat("source path should be invalid", invalidSourcePath, not(equalTo(col.path)))
-        assertThat(Directory.createInstance(invalidSourcePath), notNullValue())
-        val algo = getAlgorithm(invalidSourcePath, getMigrationDestinationPath())
-        val exception = assertFailsWith<IllegalStateException> { algo.execute() }
-        assertThat(exception.message, containsString("paths did not match"))
+        val exception = assertFailsWith<IllegalStateException> {
+            prepareAndValidateSourceAndDestinationFolders(targetContext, sourceOverride = File(source), destOverride = DestFolderOverride.Subfolder(nonEmptyDestination), checkSourceDir = false)
+        }
+        assertThat(exception.message, containsString("not empty"))
     }
 
     @Test
-    fun exception_thrown_if_database_corrupt() {
+    fun exception_thrown_if_database_corrupt() = runTest {
         checkCollectionAfter = false
         val collectionAnki2Path = CollectionDBCorruption.closeAndCorrupt(targetContext)
 
         val collectionSourcePath = File(collectionAnki2Path).parent!!
 
-        assertFailsWith<SQLiteDatabaseCorruptException> { executeAlgorithmSuccessfully(collectionSourcePath) }
+        assertFailsWith<SQLiteDatabaseCorruptException> { migrateEssentialFilesForTest(targetContext, collectionSourcePath) }
 
         assertMigrationNotInProgress()
     }
 
     @Test
-    fun collection_is_not_locked_if_copy_fails() {
-        var called = false
-
-        assertFailsWith<TestException> {
-            executeAlgorithmSuccessfully(defaultCollectionSourcePath) {
-                Mockito
-                    .doAnswer {
-                        called = true
-                        assertThat("collection should be locked", Storage.isLocked, equalTo(true))
-                        throw TestException("")
-                    }
-                    .whenever(it)
-                    .copyTopLevelFile(any(), any())
-            }
-        }
-
-        assertThat("mock was unused", called, equalTo(true))
-        assertThat("the collection is no longer locked", Storage.isLocked, equalTo(false))
-    }
-
-    @Test
-    fun fails_if_collection_can_still_be_opened() {
-        val ex = assertFailsWith<RetryableException> {
-            executeAlgorithmSuccessfully(defaultCollectionSourcePath) {
-                Mockito.doReturn(Mockito.mock(LockedCollection::class.java)).whenever(it).createLockedCollection()
-            }
-        }
-
-        assertThat(ex.message, containsString("Collection not locked correctly"))
-    }
-
-    @Test
-    fun prefs_are_restored_if_reopening_fails() {
+    fun prefs_are_restored_if_reopening_fails() = runTest {
         // after preferences are set, we make one final check with these new preferences
         // if this check fails, we want to revert the changes to preferences that we made
         val collectionSourcePath = getMigrationSourcePath()
@@ -195,11 +159,11 @@ class MigrateEssentialFilesTest : RobolectricTest() {
         val oldPrefValues = prefKeys
             .associateWith { getPreferences().getString(it, null) }
 
-        assertFailsWith<TestException> {
-            executeAlgorithmSuccessfully(collectionSourcePath) {
-                Mockito.doThrow(TestException("simulating final collection open failure")).whenever(it).throwIfCollectionCannotBeOpened()
-            }
+        CollectionManager.emulateOpenFailure = true
+        assertFailsWith<BackendException.BackendDbException.BackendDbLockedException> {
+            migrateEssentialFilesForTest(targetContext, collectionSourcePath)
         }
+        CollectionManager.emulateOpenFailure = false
 
         oldPrefValues.forEach {
             assertThat("Pref ${it.key} should be unchanged", getPreferences().getString(it.key, null), equalTo(it.value))
@@ -210,7 +174,7 @@ class MigrateEssentialFilesTest : RobolectricTest() {
 
     @Test
     @Suppress("UNUSED_VARIABLE")
-    fun fails_if_missing_essential_file() {
+    fun fails_if_missing_essential_file() = runTest {
         val unused = col.usnForSync
 
         col.close() // required for Windows, can't delete if locked.
@@ -218,47 +182,42 @@ class MigrateEssentialFilesTest : RobolectricTest() {
         CompatHelper.compat.deleteFile(File(defaultCollectionSourcePath, "collection.anki2"))
 
         val ex = assertFailsWith<MissingEssentialFileException> {
-            executeAlgorithmSuccessfully(defaultCollectionSourcePath) {
-                Mockito.doReturn(Mockito.mock(LockedCollection::class.java)).whenever(it).createLockedCollection()
-            }
+            migrateEssentialFilesForTest(targetContext, defaultCollectionSourcePath)
         }
 
         assertThat(ex.file.name, equalTo("collection.anki2"))
     }
 
-    /**
-     * Executes the collection migration algorithm, moving from the local test directory /AnkiDroid, to /migration
-     * This is only the initial stage which does not delete data
-     */
-    private fun executeAlgorithmSuccessfully(
-        ankiDroidFolder: String,
-        optionalDestinationPath: File? = null,
-        stubbing: (KStubbing<MigrateEssentialFiles>.(MigrateEssentialFiles) -> Unit)? = null
-    ): File {
-        val destinationPath = optionalDestinationPath ?: getMigrationDestinationPath()
-
-        var algo = getAlgorithm(ankiDroidFolder, destinationPath)
-
-        if (stubbing != null) {
-            algo = spy(algo, stubbing)
-        }
-        algo.execute()
-
-        return destinationPath
-    }
+    private fun getMigrationSourcePath() = File(col.path).parent!!
+}
 
-    private fun getMigrationDestinationPath(): File {
-        return File(Path(targetContext.getExternalFilesDir(null)!!.canonicalPath, "AnkiDroid-1").pathString).also {
-            it.mkdirs()
-        }
+/**
+ * Executes the collection migration algorithm, moving from the local test directory /AnkiDroid, to /migration
+ * This is only the initial stage which does not delete data
+ */
+suspend fun migrateEssentialFilesForTest(
+    context: Context,
+    ankiDroidFolder: String,
+    destOverride: DestFolderOverride = DestFolderOverride.None,
+    checkSourceDir: bool = false
+): File {
+    val destOverrideUpdated = when (destOverride) {
+        is DestFolderOverride.None -> DestFolderOverride.Root(getMigrationDestinationPath(context))
+        else -> destOverride
     }
+    val sourceFolder = File(ankiDroidFolder)
+    val folders = prepareAndValidateSourceAndDestinationFolders(
+        context,
+        sourceOverride = sourceFolder,
+        destOverride = destOverrideUpdated,
+        checkSourceDir = checkSourceDir
+    )
+    CollectionManager.migrateEssentialFiles(context, folders)
+    return folders.scopedDestinationDirectory.directory
+}
 
-    private fun getMigrationSourcePath() = File(col.path).parent!!
-
-    @CheckResult
-    private fun getAlgorithm(sourcePath: String, destinationPath: File): MigrateEssentialFiles {
-        val destinationDir = Directory.createInstance(destinationPath) ?: throw IllegalStateException("'$destinationPath' was not a directory")
-        val destinationDirectory = ScopedAnkiDroidDirectory.createInstance(destinationDir, targetContext) ?: throw IllegalStateException("'$destinationPath' was not under scoped storage")
-        return MigrateEssentialFiles(targetContext, Directory.createInstance(sourcePath)!!, destinationDirectory)
+private fun getMigrationDestinationPath(context: Context): File {
+    return File(Path(context.getExternalFilesDir(null)!!.canonicalPath, "AnkiDroid1").pathString).also {
+        it.mkdirs()
     }
 }
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
index 5de25cd17ddd..448d9426dea7 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
@@ -17,8 +17,10 @@
 package com.ichi2.anki.servicelayer.scopedstorage
 
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.RobolectricTest
 import com.ichi2.anki.model.Directory
+import com.ichi2.anki.servicelayer.DestFolderOverride
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.MigrateUserData
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.MigrateUserData.*
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.MigrationProgressListener
@@ -59,7 +61,7 @@ class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
     }
 
     @Test
-    fun `Valid migration`() {
+    fun `Valid migration`() = runTest {
         setLegacyStorage()
 
         underTest = MigrateUserDataTester.create()
@@ -72,13 +74,16 @@ class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
         ShadowStatFs.markAsNonEmpty(inputDirectory)
 
         // migrate the essential files
-        MigrateEssentialFiles.migrateEssentialFiles(targetContext, validDestination)
+        migrateEssentialFilesForTest(targetContext, inputDirectory.path, DestFolderOverride.Subfolder(validDestination))
 
         underTest = MigrateUserDataTester.create(inputDirectory, validDestination)
         val result = underTest.execTask()
 
         assertThat("execution of user data should succeed", result, equalTo(true))
 
+        // close collection again so -wal doesn't end up in the list
+        CollectionManager.ensureClosed()
+
         // 5 files remain: [collection.log, collection.media.ad.db2, collection.anki2-journal, collection.anki2, .nomedia]
         underTest.integrationAssertOnlyIntendedFilesRemain()
         assertThat(underTest.migratedFilesCount, equalTo(underTest.filesToMigrateCount))
@@ -91,7 +96,7 @@ class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
     }
 
     @Test
-    fun `Migration without space fails`() {
+    fun `Migration without space fails`() = runTest {
         setLegacyStorage()
         // use all the real components on a real collection.
         val inputDirectory = File(col.path).parentFile!!
@@ -102,7 +107,7 @@ class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
         ShadowStatFs.markAsNonEmpty(inputDirectory)
 
         // migrate the essential files
-        MigrateEssentialFiles.migrateEssentialFiles(targetContext, validDestination)
+        migrateEssentialFilesForTest(targetContext, inputDirectory.path, DestFolderOverride.Root(validDestination))
 
         underTest = MigrateUserDataTester.create(inputDirectory, validDestination)
         underTest.executor = object : Executor(ArrayDeque()) {
