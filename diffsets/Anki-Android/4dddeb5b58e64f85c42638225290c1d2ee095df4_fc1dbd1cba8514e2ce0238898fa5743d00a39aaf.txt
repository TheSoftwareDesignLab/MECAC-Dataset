diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewreminders/ScheduleReminders.kt b/AnkiDroid/src/main/java/com/ichi2/anki/reviewreminders/ScheduleReminders.kt
index 7bf3b96affa1..84020e121c0f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewreminders/ScheduleReminders.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewreminders/ScheduleReminders.kt
@@ -25,6 +25,7 @@ import androidx.appcompat.app.AppCompatActivity
 import androidx.core.os.BundleCompat
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.setFragmentResult
+import androidx.fragment.app.setFragmentResultListener
 import androidx.recyclerview.widget.DividerItemDecoration
 import androidx.recyclerview.widget.LinearLayoutManager
 import androidx.recyclerview.widget.RecyclerView
@@ -38,6 +39,10 @@ import com.ichi2.anki.launchCatchingTask
 import com.ichi2.anki.libanki.DeckId
 import com.ichi2.anki.model.SelectableDeck
 import com.ichi2.anki.showError
+import com.ichi2.anki.snackbar.BaseSnackbarBuilderProvider
+import com.ichi2.anki.snackbar.SnackbarBuilder
+import com.ichi2.anki.snackbar.showSnackbar
+import com.ichi2.anki.utils.ext.showDialogFragment
 import com.ichi2.anki.withProgress
 import kotlinx.serialization.SerializationException
 import timber.log.Timber
@@ -47,7 +52,8 @@ import timber.log.Timber
  */
 class ScheduleReminders :
     Fragment(R.layout.fragment_schedule_reminders),
-    DeckSelectionDialog.DeckSelectionListener {
+    DeckSelectionDialog.DeckSelectionListener,
+    BaseSnackbarBuilderProvider {
     /**
      * Whether this fragment has been opened to edit all review reminders or just a specific deck's reminders.
      * @see ReviewReminderScope
@@ -64,6 +70,10 @@ class ScheduleReminders :
     private lateinit var recyclerView: RecyclerView
     private lateinit var adapter: ScheduleRemindersAdapter
 
+    override val baseSnackbarBuilder: SnackbarBuilder = {
+        anchorView = requireView().findViewById<ExtendedFloatingActionButton>(R.id.schedule_reminders_add_reminder_fab)
+    }
+
     /**
      * The reminders currently being displayed in the UI. To make changes to this list show up on screen,
      * use [triggerUIUpdate]. Note that editing this map does not also automatically write to the database.
@@ -110,6 +120,26 @@ class ScheduleReminders :
 
         // Retrieve reminders based on the editing scope
         launchCatchingTask { loadDatabaseRemindersIntoUI() }
+
+        // If the user creates or edits a review reminder, the dialog for doing so opens
+        // Once their changes are complete, the dialog closes and this fragment is reloaded
+        // Hence, we check for any fragment results here and update the database accordingly
+        setFragmentResultListener(ADD_EDIT_DIALOG_RESULT_REQUEST_KEY) { _, bundle ->
+            val modeOfFinishedDialog =
+                BundleCompat.getParcelable(
+                    requireArguments(),
+                    ACTIVE_DIALOG_MODE_ARGUMENTS_KEY,
+                    AddEditReminderDialog.DialogMode::class.java,
+                ) ?: return@setFragmentResultListener
+            val newOrModifiedReminder =
+                BundleCompat.getParcelable(
+                    bundle,
+                    ADD_EDIT_DIALOG_RESULT_REQUEST_KEY,
+                    ReviewReminder::class.java,
+                )
+            Timber.d("Dialog result received with recent dialog mode: %s", modeOfFinishedDialog)
+            handleAddEditDialogResult(newOrModifiedReminder, modeOfFinishedDialog)
+        }
     }
 
     private fun reloadToolbarText() {
@@ -142,6 +172,112 @@ class ScheduleReminders :
         Timber.d("Database review reminders successfully loaded")
     }
 
+    /**
+     * When a [AddEditReminderDialog] instance finishes, we handle the result of the dialog fragment via this method.
+     */
+    private fun handleAddEditDialogResult(
+        newOrModifiedReminder: ReviewReminder?,
+        modeOfFinishedDialog: AddEditReminderDialog.DialogMode,
+    ) {
+        Timber.d("Handling add/edit dialog result: mode=%s reminder=%s", modeOfFinishedDialog, newOrModifiedReminder)
+        updateDatabaseForAddEditDialog(newOrModifiedReminder, modeOfFinishedDialog)
+        updateUIForAddEditDialog(newOrModifiedReminder, modeOfFinishedDialog)
+        // Feedback
+        showSnackbar(
+            when (modeOfFinishedDialog) {
+                is AddEditReminderDialog.DialogMode.Add -> "Successfully added new review reminder"
+                is AddEditReminderDialog.DialogMode.Edit -> {
+                    when (newOrModifiedReminder) {
+                        null -> "Successfully deleted review reminder"
+                        else -> "Successfully edited review reminder"
+                    }
+                }
+            },
+        )
+    }
+
+    /**
+     * Write the new or modified reminder to the database.
+     * @see handleAddEditDialogResult
+     */
+    private fun updateDatabaseForAddEditDialog(
+        newOrModifiedReminder: ReviewReminder?,
+        modeOfFinishedDialog: AddEditReminderDialog.DialogMode,
+    ) {
+        launchCatchingTask {
+            catchDatabaseExceptions {
+                if (modeOfFinishedDialog is AddEditReminderDialog.DialogMode.Edit) {
+                    // Delete the existing reminder if we're in edit mode
+                    // This action must be separated from writing the modified reminder because the user may have updated the reminder's deck,
+                    // meaning we need to delete the old reminder in the old deck, then add a new reminder to the new deck
+                    val reminderToDelete = modeOfFinishedDialog.reminderToBeEdited
+                    Timber.d("Deleting old reminder from database")
+                    when (reminderToDelete.scope) {
+                        is ReviewReminderScope.Global -> ReviewRemindersDatabase.editAllAppWideReminders(deleteReminder(reminderToDelete))
+                        is ReviewReminderScope.DeckSpecific ->
+                            ReviewRemindersDatabase.editRemindersForDeck(
+                                reminderToDelete.scope.did,
+                                deleteReminder(reminderToDelete),
+                            )
+                    }
+                }
+                newOrModifiedReminder?.let { reminder ->
+                    Timber.d("Writing new or modified reminder to database")
+                    when (reminder.scope) {
+                        is ReviewReminderScope.Global -> ReviewRemindersDatabase.editAllAppWideReminders(upsertReminder(reminder))
+                        is ReviewReminderScope.DeckSpecific ->
+                            ReviewRemindersDatabase.editRemindersForDeck(
+                                reminder.scope.did,
+                                upsertReminder(reminder),
+                            )
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Lambda that can be fed into [ReviewRemindersDatabase.editRemindersForDeck] or
+     * [ReviewRemindersDatabase.editAllAppWideReminders] which deletes the given review reminder.
+     */
+    private fun deleteReminder(reminder: ReviewReminder) =
+        { reminders: HashMap<ReviewReminderId, ReviewReminder> ->
+            reminders.remove(reminder.id)
+            reminders
+        }
+
+    /**
+     * Lambda that can be fed into [ReviewRemindersDatabase.editRemindersForDeck] or
+     * [ReviewRemindersDatabase.editAllAppWideReminders] which updates the given review reminder if it
+     * exists or inserts it if it doesn't (an "upsert" operation)
+     */
+    private fun upsertReminder(reminder: ReviewReminder) =
+        { reminders: HashMap<ReviewReminderId, ReviewReminder> ->
+            reminders[reminder.id] = reminder
+            reminders
+        }
+
+    /**
+     * Update the RecyclerView with the new or modified reminder.
+     * @see handleAddEditDialogResult
+     */
+    private fun updateUIForAddEditDialog(
+        newOrModifiedReminder: ReviewReminder?,
+        modeOfFinishedDialog: AddEditReminderDialog.DialogMode,
+    ) {
+        if (modeOfFinishedDialog is AddEditReminderDialog.DialogMode.Edit) {
+            Timber.d("Deleting old reminder from UI")
+            reminders.remove(modeOfFinishedDialog.reminderToBeEdited.id)
+        }
+        newOrModifiedReminder?.let {
+            if (scheduleRemindersScope == ReviewReminderScope.Global || scheduleRemindersScope == it.scope) {
+                Timber.d("Adding new reminder to UI")
+                reminders[it.id] = it
+            }
+        }
+        triggerUIUpdate()
+    }
+
     /**
      * Sets a TextView's text based on a [ReviewReminderScope].
      * The text is either the scope's associated deck's name, or "All Decks" if the scope is global.
@@ -152,7 +288,7 @@ class ScheduleReminders :
         view: TextView,
     ) {
         when (scope) {
-            is ReviewReminderScope.Global -> view.text = "All Decks"
+            is ReviewReminderScope.Global -> view.text = getString(R.string.card_browser_all_decks)
             is ReviewReminderScope.DeckSpecific -> {
                 launchCatchingTask {
                     val deckName = cachedDeckNames.getOrPut(scope.did) { scope.getDeckName() }
@@ -202,6 +338,11 @@ class ScheduleReminders :
      */
     private fun addReminder() {
         Timber.d("Adding new review reminder")
+        val dialogMode = AddEditReminderDialog.DialogMode.Add(scheduleRemindersScope)
+        val dialog = AddEditReminderDialog.getInstance(dialogMode)
+        // Save the dialog mode so that we refer back to it once the dialog closes
+        requireArguments().putParcelable(ACTIVE_DIALOG_MODE_ARGUMENTS_KEY, dialogMode)
+        showDialogFragment(dialog)
     }
 
     /**
@@ -210,6 +351,11 @@ class ScheduleReminders :
      */
     private fun editReminder(reminder: ReviewReminder) {
         Timber.d("Editing review reminder: %s", reminder.id)
+        val dialogMode = AddEditReminderDialog.DialogMode.Edit(reminder)
+        val dialog = AddEditReminderDialog.getInstance(dialogMode)
+        // Save the dialog mode so that we refer back to it once the dialog closes
+        requireArguments().putParcelable(ACTIVE_DIALOG_MODE_ARGUMENTS_KEY, dialogMode)
+        showDialogFragment(dialog)
     }
 
     /**
