diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
index dc94f464730b..7611b724edcb 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
@@ -73,11 +73,9 @@ import com.ichi2.anki.servicelayer.AnkiMethod
 import com.ichi2.anki.servicelayer.LanguageHintService.applyLanguageHint
 import com.ichi2.anki.servicelayer.NoteService.isMarked
 import com.ichi2.anki.servicelayer.SchedulerService.*
-import com.ichi2.anki.servicelayer.ScopedStorageService
 import com.ichi2.anki.servicelayer.TaskListenerBuilder
 import com.ichi2.anki.servicelayer.Undo
-import com.ichi2.anki.services.MigrationService
-import com.ichi2.anki.services.ServiceConnection
+import com.ichi2.anki.services.migrationServiceWhileStartedOrNull
 import com.ichi2.anki.snackbar.BaseSnackbarBuilderProvider
 import com.ichi2.anki.snackbar.SnackbarBuilder
 import com.ichi2.anki.snackbar.showSnackbar
@@ -103,15 +101,11 @@ import com.ichi2.utils.*
 import com.ichi2.utils.AdaptionUtil.hasWebBrowser
 import com.ichi2.utils.AndroidUiUtils.isRunningOnTv
 import com.ichi2.utils.AssetHelper.guessMimeType
-import com.ichi2.utils.BlocksSchemaUpgrade
 import com.ichi2.utils.ClipboardUtil.getText
-import com.ichi2.utils.Computation
 import com.ichi2.utils.HandlerUtils.executeFunctionWithDelay
 import com.ichi2.utils.HandlerUtils.newHandler
 import com.ichi2.utils.HashUtil.HashSetInit
-import com.ichi2.utils.KotlinCleanup
 import com.ichi2.utils.WebViewDebugging.initializeDebugging
-import com.ichi2.utils.iconAttr
 import kotlinx.coroutines.Job
 import net.ankiweb.rsdroid.BackendFactory
 import net.ankiweb.rsdroid.RustCleanup
@@ -126,7 +120,6 @@ import java.util.concurrent.locks.ReentrantReadWriteLock
 import java.util.function.Consumer
 import java.util.function.Function
 import java.util.function.Supplier
-import kotlin.collections.HashSet
 import kotlin.math.abs
 
 @KotlinCleanup("lots to deal with")
@@ -295,7 +288,7 @@ abstract class AbstractFlashcardViewer :
         displayCardAnswer()
     }
 
-    private val migrationService = ServiceConnection<MigrationService>()
+    private val migrationService by migrationServiceWhileStartedOrNull()
 
     init {
         ChangeManager.subscribe(this)
@@ -561,18 +554,6 @@ abstract class AbstractFlashcardViewer :
         mGestureDetectorImpl = LinkDetectingGestureDetector()
     }
 
-    override fun onStart() {
-        super.onStart()
-        if (ScopedStorageService.userMigrationIsInProgress(this)) {
-            migrationService.bind(this, MigrationService::class.java)
-        }
-    }
-
-    override fun onStop() {
-        super.onStop()
-        migrationService.unbind(this)
-    }
-
     protected open fun getContentViewAttr(fullscreenMode: FullScreenMode): Int {
         return R.layout.reviewer
     }
@@ -1605,7 +1586,7 @@ abstract class AbstractFlashcardViewer :
             }
 
             private fun handleStorageMigrationError(file: File): Boolean {
-                val migrationService = migrationService.instance ?: return false
+                val migrationService = migrationService ?: return false
                 if (handledError.contains(file.absolutePath)) {
                     return false
                 }
@@ -2261,7 +2242,7 @@ abstract class AbstractFlashcardViewer :
                 if (isLoadedFromProtocolRelativeUrl(request.url.toString())) {
                     mMissingImageHandler.processInefficientImage { displayMediaUpgradeRequiredSnackbar() }
                 }
-                url.path?.let { path -> migrationService.instance?.migrateFileImmediately(File(path)) }
+                url.path?.let { path -> migrationService?.migrateFileImmediately(File(path)) }
             }
             return null
         }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index 69a03cb74802..4a10090e022f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -36,7 +36,6 @@ import android.util.TypedValue
 import android.view.*
 import android.view.View.OnLongClickListener
 import android.widget.*
-import androidx.activity.viewModels
 import androidx.annotation.VisibleForTesting
 import androidx.appcompat.app.AlertDialog
 import androidx.appcompat.widget.SearchView
@@ -48,6 +47,8 @@ import androidx.core.content.pm.ShortcutManagerCompat
 import androidx.core.graphics.drawable.IconCompat
 import androidx.core.os.bundleOf
 import androidx.fragment.app.commit
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.flowWithLifecycle
 import androidx.lifecycle.lifecycleScope
 import androidx.recyclerview.widget.DividerItemDecoration
 import androidx.recyclerview.widget.LinearLayoutManager
@@ -88,12 +89,11 @@ import com.ichi2.anki.servicelayer.*
 import com.ichi2.anki.servicelayer.SchedulerService.NextCard
 import com.ichi2.anki.servicelayer.ScopedStorageService.isLegacyStorage
 import com.ichi2.anki.servicelayer.ScopedStorageService.userMigrationIsInProgress
-import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.toMB
+import com.ichi2.anki.servicelayer.Undo
 import com.ichi2.anki.services.MigrationService
-import com.ichi2.anki.services.ServiceConnection
+import com.ichi2.anki.services.withBoundTo
 import com.ichi2.anki.snackbar.showSnackbar
 import com.ichi2.anki.stats.AnkiStatsTaskHandler
-import com.ichi2.anki.viewmodels.MigrationProgressViewModel
 import com.ichi2.anki.web.HostNumFactory
 import com.ichi2.anki.widgets.DeckAdapter
 import com.ichi2.annotations.NeedsTest
@@ -204,9 +204,6 @@ open class DeckPicker :
     private var mStartupError = false
     private var mEmptyCardTask: Cancellable? = null
 
-    // MigrationProgress Dialog state flow viewModel
-    private val migrationProgressViewModel by viewModels<MigrationProgressViewModel>()
-
     /** See [OptionsMenuState]. */
     @VisibleForTesting
     var optionsMenuState: OptionsMenuState? = null
@@ -254,15 +251,6 @@ open class DeckPicker :
     var createMenuJob: Job? = null
     private var loadDeckCounts: Job? = null
 
-    private val migrationService: ServiceConnection<MigrationService> = object : ServiceConnection<MigrationService>() {
-        override fun onServiceConnected(service: MigrationService) {
-            service.migrationCompletedListener = { onStorageMigrationCompleted() }
-        }
-        override fun onServiceDisconnected(service: MigrationService) {
-            service.migrationCompletedListener = null
-        }
-    }
-
     init {
         ChangeManager.subscribe(this)
     }
@@ -601,28 +589,52 @@ open class DeckPicker :
         return super.onCreateOptionsMenu(menu)
     }
 
-    private fun updateMigrationState(menu: Menu, migrationInProgress: Boolean) {
-        val menuProgressIcon: MenuItem = menu.findItem(R.id.action_migration_progress)
-        menuProgressIcon.isVisible = migrationInProgress
-        val progressBar: ProgressBar =
-            menuProgressIcon.actionView!!.findViewById(R.id.ic_progressDonut)
-        if (migrationInProgress) {
-            migrationService.instance?.let { service ->
-                service.totalToTransfer?.let { totalToTransfer ->
-                    val total = totalToTransfer.toDouble().toInt()
-                    progressBar.max = total
-                    lifecycleScope.launch {
-                        while (service.currentProgress < total) {
-                            progressBar.progress = service.currentProgress.toInt()
-                            delay(50)
-                        }
-                        progressBar.progress = total
-                    }
+    private var migrationProgressPublishingJob: Job? = null
+
+    private fun setupMigrationProgressMenuItem(menu: Menu, migrationInProgress: Boolean) {
+        val migrationProgressMenuItem = menu.findItem(R.id.action_migration_progress)
+            .apply { isVisible = migrationInProgress }
+
+        suspend fun ProgressBar.publishProgress(progress: MigrationService.Progress) {
+            when (progress) {
+                is MigrationService.Progress.CalculatingTransferSize -> {
+                    this.isIndeterminate = true
+                }
+
+                is MigrationService.Progress.Transferring -> {
+                    val shownProgressRatio = progress.ratio.translate(fromRange = 0f..1f, toRange = 0.05f..1f)
+
+                    this.isIndeterminate = false
+                    this.progress = (shownProgressRatio * Int.MAX_VALUE).toInt()
+                }
+
+                // TODO Perhaps handle the cases of success & failure differently?
+                is MigrationService.Progress.Done -> {
+                    updateMenuState()
+                    updateMenuFromState(menu)
                 }
             }
-            progressBar.setOnClickListener {
-                warnNoSyncDuringMigration()
+        }
+
+        if (migrationInProgress) {
+            val progressBar = migrationProgressMenuItem.actionView!!
+                .findViewById<ProgressBar>(R.id.ic_progressDonut)
+                .apply {
+                    max = Int.MAX_VALUE
+                    setOnClickListener { warnNoSyncDuringMigration() }
+                }
+
+            migrationProgressPublishingJob?.cancel()
+            migrationProgressPublishingJob = lifecycleScope.launch {
+                withBoundTo<MigrationService> { service ->
+                    service.flowOfProgress
+                        .flowWithLifecycle(lifecycle, Lifecycle.State.STARTED)
+                        .collect { progress -> progressBar.publishProgress(progress) }
+                }
             }
+        } else {
+            migrationProgressPublishingJob?.cancel()
+            migrationProgressPublishingJob = null
         }
     }
 
@@ -670,7 +682,7 @@ open class DeckPicker :
             updateUndoIconFromState(menu.findItem(R.id.action_undo), undoIcon)
             updateSyncIconFromState(menu.findItem(R.id.action_sync), syncIcon)
             menu.findItem(R.id.action_scoped_storage_migrate).isVisible = offerToMigrate
-            updateMigrationState(menu, migrationInProgress)
+            setupMigrationProgressMenuItem(menu, migrationInProgress)
         }
     }
 
@@ -941,18 +953,6 @@ open class DeckPicker :
         }
     }
 
-    fun onStorageMigrationCompleted() {
-        migrationService.unbind(this)
-        invalidateOptionsMenu() // reapply the sync icon
-    }
-
-    override fun onStart() {
-        super.onStart()
-        if (userMigrationIsInProgress(this)) {
-            migrationService.bind(this, MigrationService::class.java)
-        }
-    }
-
     override fun onPause() {
         Timber.d("onPause()")
         mActivityPaused = true
@@ -964,7 +964,6 @@ open class DeckPicker :
     override fun onStop() {
         Timber.d("onStop()")
         super.onStop()
-        migrationService.unbind(this)
         if (colIsOpen()) {
             WidgetStatus.update(this)
             // Ignore the modification - a change in deck shouldn't trigger the icon for "pending changes".
@@ -2475,29 +2474,14 @@ open class DeckPicker :
     private fun startMigrateUserDataService() {
         // TODO: Handle lack of disk space - most common error
         Timber.i("Starting Migrate User Data Service")
-        migrationService.startForeground(this, MigrationService::class.java)
+        ContextCompat.startForegroundService(this, Intent(this, MigrationService::class.java))
     }
 
     /**
      * Show a dialog that explains no sync can occur during migration.
      */
     private fun warnNoSyncDuringMigration() {
-        // TODO: maybe handle onStorageMigrationCompleted()
-        migrationService.instance?.let { service ->
-            service.totalToTransfer?.let { totalToTransfer ->
-                lifecycleScope.launch {
-                    while (migrationService.instance?.totalToTransfer != null) {
-                        migrationProgressViewModel.migrationProgressFlow.value = MigrationProgress(
-                            service.currentProgress.toMB(),
-                            totalToTransfer.toMB()
-                        )
-                        delay(100)
-                    }
-                }
-            }
-        }
-        val progressDialog = MigrationProgressDialogFragment()
-        progressDialog.show(supportFragmentManager, "MigrationProgressDialogFragment")
+        MigrationProgressDialogFragment().show(supportFragmentManager, "MigrationProgressDialogFragment")
     }
 
     /**
@@ -2697,3 +2681,9 @@ class ForceFullSyncDialog(val message: String?) : DialogHandlerMessage(
             ForceFullSyncDialog(message.data.getString("message"))
     }
 }
+
+// TODO Move to a file dedicated to math utils
+private fun Float.translate(fromRange: ClosedFloatingPointRange<Float>, toRange: ClosedFloatingPointRange<Float>): Float {
+    val ratio = (this - fromRange.start) / (fromRange.endInclusive - fromRange.start)
+    return toRange.start + ratio * (toRange.endInclusive - toRange.start)
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/MigrationProgressDialogFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/MigrationProgressDialogFragment.kt
index 5a9e8d09c16d..1b5d43b0e58f 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/MigrationProgressDialogFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/MigrationProgressDialogFragment.kt
@@ -19,51 +19,78 @@ package com.ichi2.anki.dialogs
 import android.app.AlertDialog
 import android.app.Dialog
 import android.os.Bundle
+import android.text.format.Formatter.formatShortFileSize
 import android.widget.ProgressBar
 import android.widget.TextView
 import androidx.fragment.app.DialogFragment
-import androidx.fragment.app.activityViewModels
 import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.flowWithLifecycle
 import androidx.lifecycle.lifecycleScope
-import androidx.lifecycle.repeatOnLifecycle
 import com.ichi2.anki.AnkiActivity
 import com.ichi2.anki.R
-import com.ichi2.anki.viewmodels.MigrationProgressViewModel
+import com.ichi2.anki.services.MigrationService
+import com.ichi2.anki.services.withBoundTo
 import kotlinx.coroutines.launch
 
-class MigrationProgressDialogFragment :
-    DialogFragment() {
-    private val progressViewModel by activityViewModels<MigrationProgressViewModel>()
+/**
+ * A dialog showing the progress of migration of the collection
+ * from public storage to app-private storage.
+ * It attaches to the migration service, and, while showing,
+ * constantly updates the amount of transferred data,
+ * and displays messages in cases of success or failure.
+ * Dismissible.
+ */
+class MigrationProgressDialogFragment : DialogFragment() {
 
     override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
-        val messageTextView: TextView
-        val progressBar: ProgressBar
-        val progressView =
-            requireActivity().layoutInflater.inflate(R.layout.indeterminate_progress_bar, null)
-        progressBar = progressView.findViewById(R.id.indeterminate_progressBar)
-        messageTextView = progressView.findViewById(R.id.migration_text)
+        val layout = requireActivity().layoutInflater.inflate(R.layout.indeterminate_progress_bar, null)
+        val progressBar = layout.findViewById<ProgressBar>(R.id.indeterminate_progressBar)
+        val textView = layout.findViewById<TextView>(R.id.migration_text)
 
-        lifecycleScope.launch {
-            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
-                progressViewModel.migrationProgressFlow.collect { state ->
-                    progressBar.max = state.totalMb
-                    progressBar.progress = state.transferredMb
-                    messageTextView.text = resources.getString(
-                        R.string.scoped_storage_migration_progress
-                    )
+        progressBar.max = Int.MAX_VALUE
+
+        fun publishProgress(progress: MigrationService.Progress) {
+            when (progress) {
+                is MigrationService.Progress.CalculatingTransferSize -> {
+                    progressBar.isIndeterminate = true
+                    textView.text = getString(R.string.migration__calculating_transfer_size)
+                }
+
+                is MigrationService.Progress.Transferring -> {
+                    val transferredSizeText = formatShortFileSize(requireContext(), progress.transferredBytes)
+                    val totalSizeText = formatShortFileSize(requireContext(), progress.totalBytes)
+
+                    progressBar.isIndeterminate = false
+                    progressBar.progress = (progress.ratio * Int.MAX_VALUE).toInt()
+                    textView.text = getString(R.string.migration__transferred_x_of_y, transferredSizeText, totalSizeText)
+                }
+
+                is MigrationService.Progress.Success -> {
+                    progressBar.isIndeterminate = false
+                    progressBar.progress = Int.MAX_VALUE
+                    textView.text = getString(R.string.migration_successful_message)
+                }
+
+                is MigrationService.Progress.Failure -> {
+                    textView.text = getString(R.string.migration__failed, progress.e)
                 }
             }
         }
-        return AlertDialog.Builder(activity)
-            .setView(progressView)
-            .setPositiveButton(R.string.dialog_ok) { _, _ ->
-                dismiss()
+
+        lifecycleScope.launch {
+            requireContext().withBoundTo<MigrationService> { service ->
+                service.flowOfProgress
+                    .flowWithLifecycle(lifecycle, Lifecycle.State.STARTED)
+                    .collect { progress -> publishProgress(progress) }
             }
+        }
+
+        return AlertDialog.Builder(activity)
+            .setView(layout)
+            .setPositiveButton(R.string.dialog_ok) { _, _ -> dismiss() }
             .setNegativeButton(R.string.scoped_storage_learn_more) { _, _ ->
                 (requireActivity() as AnkiActivity).openUrl(R.string.link_scoped_storage_faq)
             }
             .create()
     }
 }
-
-data class MigrationProgress(val transferredMb: Int, val totalMb: Int)
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/migrateuserdata/MigrateUserData.kt b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/migrateuserdata/MigrateUserData.kt
index 2c01fd1fd350..47f952fb579a 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/migrateuserdata/MigrateUserData.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/servicelayer/scopedstorage/migrateuserdata/MigrateUserData.kt
@@ -18,8 +18,6 @@ package com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata
 
 import android.content.SharedPreferences
 import androidx.annotation.VisibleForTesting
-import com.ichi2.anki.AnkiDroidApp
-import com.ichi2.anki.R
 import com.ichi2.anki.model.Directory
 import com.ichi2.anki.model.DiskFile
 import com.ichi2.anki.model.RelativeFilePath
@@ -507,7 +505,7 @@ open class MigrateUserData protected constructor(val source: Directory, val dest
      * @throws AggregateException If multiple exceptions were thrown when executing
      * @throws RuntimeException Various other failings if only a single exception was thrown
      */
-    fun migrateFiles(progressListener: MigrationProgressListener): Boolean {
+    fun migrateFiles(progressListener: MigrationProgressListener) {
         val context = initializeContext(progressListener)
 
         // define the function here, so we can execute it on retry
@@ -529,14 +527,11 @@ open class MigrateUserData protected constructor(val source: Directory, val dest
         // otherwise, there were a few exceptions which didn't stop execution, throw these.
         if (!context.successfullyCompleted) {
             context.terminatedWith?.let { throw it }
-            val migrationFailedMessage = AnkiDroidApp.instance.getString(R.string.migration_failed_message)
-            throw AggregateException.raise(migrationFailedMessage, context.loggedExceptions)
+            throw AggregateException.raise("Migration failed", context.loggedExceptions)
         }
 
         // we are successfully migrated here
         // TODO: fix "conflicts" - check to see if conflicts are due to partially copied files in the destination
-
-        return true
     }
 
     @VisibleForTesting
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/services/MigrationService.kt b/AnkiDroid/src/main/java/com/ichi2/anki/services/MigrationService.kt
index 5cc06ce9c534..e4b48170f9a4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/services/MigrationService.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/services/MigrationService.kt
@@ -16,260 +16,164 @@
 
 package com.ichi2.anki.services
 
-import android.app.Service
+import android.app.Notification
 import android.content.Context
 import android.content.Intent
-import android.os.Binder
-import android.os.IBinder
+import android.os.Build
+import android.text.format.Formatter
 import androidx.core.app.NotificationCompat
-import androidx.core.app.NotificationManagerCompat
 import androidx.core.content.edit
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LifecycleOwner
+import androidx.lifecycle.lifecycleScope
+import androidx.lifecycle.repeatOnLifecycle
 import com.ichi2.anki.*
 import com.ichi2.anki.servicelayer.ScopedStorageService.PREF_MIGRATION_DESTINATION
 import com.ichi2.anki.servicelayer.ScopedStorageService.PREF_MIGRATION_SOURCE
+import com.ichi2.anki.servicelayer.ScopedStorageService.userMigrationIsInProgress
 import com.ichi2.anki.servicelayer.scopedstorage.MigrateEssentialFiles
 import com.ichi2.anki.servicelayer.scopedstorage.MoveConflictedFile
 import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.MigrateUserData
-import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.NumberOfBytes
-import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.toKB
-import com.ichi2.anki.servicelayer.scopedstorage.migrateuserdata.toMB
-import com.ichi2.compat.CompatHelper.Companion.compat
+import com.ichi2.compat.CompatHelper
 import com.ichi2.utils.FileUtil
-import com.ichi2.utils.Repeater
-import com.ichi2.utils.runOnUiThread
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.suspendCancellableCoroutine
 import timber.log.Timber
 import java.io.File
-import kotlin.concurrent.thread
+import kotlin.properties.ReadOnlyProperty
 
 /**
  * A service which migrates the AnkiDroid collection from a legacy directory to an app-private directory.
  */
-class MigrationService : Service() {
-    private lateinit var migrateUserDataTask: MigrateUserData
-    private lateinit var migrateDataThread: Thread
-    private lateinit var notificationUpdater: Repeater
-    private var isStarted = false
-
-    /** the current progress (may be ahead of the notification) */
-    var currentProgress: NumberOfBytes = 0
-        private set
-
-    /** the current progress which is displayed on the notification */
-    var notificationDisplayedProgress: NumberOfBytes = 0
-        private set
-
-    /**
-     * The total bytes required to be transferred. 0 on error
-     * Note: currently this is recalculated each time the service is started
-     */
-    var totalToTransfer: NumberOfBytes? = null
-        private set
-
-    var migrationCompletedListener: (() -> Unit)? = null
-
-    private inner class MigrateUserDataProgressListener(val context: Context) {
-        private var notification: Notification? = null
-
-        fun initNotification(totalToTransfer: NumberOfBytes?) {
-            // startForeground must be called within 5 seconds. Otherwise a crash occurs:
-            // `Context.startForegroundService() did not then call Service.startForeground()`
-            val sourceSize = totalToTransfer ?: 0 // TODO: error handling
-            notification = Notification.createInstance(context, sourceSize).also {
-                Timber.i("Running in foreground with notification")
-                startForeground(it.id, it.build())
-            }
-
-            notificationUpdater = Repeater.createAndStart(delayMs = 2000L) {
-                notificationDisplayedProgress = currentProgress
-                notification?.notifyUpdate(currentProgress)
-            }
-        }
-
-        fun onProgressUpdate(value: NumberOfBytes?) {
-            /** @see notificationUpdater for where this is used */
-            currentProgress += value ?: 0
-        }
-
-        fun onResult(result: Boolean) {
-            if (result) {
-                Timber.i("Marking migration as completed")
-                AnkiDroidApp.getSharedPrefs(context).edit {
-                    remove(PREF_MIGRATION_DESTINATION)
-                    remove(PREF_MIGRATION_SOURCE)
-                }
-                migrationCompletedListener?.invoke()
-            }
-            notification?.notifyCompletion(result)
+class MigrationService : ServiceWithALifecycleScope(), ServiceWithASimpleBinder<MigrationService> {
 
-            // display a toast to the user.
-            displayMigrationCompleted(result)
-            stopSelf()
-        }
+    sealed interface Progress {
+        object CalculatingTransferSize : Progress
 
-        private fun displayMigrationCompleted(result: Boolean) {
-            // TODO: This should be discussed
-            val message =
-                if (result) R.string.migration_successful_message else R.string.migration_failed_message
-
-            // fixes: "Can't toast on a thread that has not called Looper.prepare()"
-            runOnUiThread {
-                UIUtils.showThemedToast(context, message, true)
-            }
+        data class Transferring(val transferredBytes: Long, val totalBytes: Long) : Progress {
+            val ratio get() = if (totalBytes == 0L) 1f else transferredBytes.toFloat() / totalBytes
         }
 
-        fun onError(e: Exception) {
-            notificationUpdater.terminate()
-            notification?.notifyError(e)
-        }
+        sealed interface Done : Progress
+        object Success : Done
+        data class Failure(val e: Exception) : Done
     }
 
-    private class Notification private constructor(
-        private val context: Context,
-        private val manager: NotificationManagerCompat,
-        private val sourceSize: NumberOfBytes
-    ) {
-        private var notificationBuilder: NotificationCompat.Builder = NotificationCompat.Builder(
-            context,
-            Channel.SCOPED_STORAGE_MIGRATION.id
-        )
-            .setSmallIcon(R.drawable.ic_star_notify)
-            .setContentTitle(context.resources.getString(R.string.migrating_data_message))
-            .setContentText(context.resources.getString(R.string.migration_transferred_size, 0f, sourceSize / 1024f))
-            .setPriority(NotificationCompat.PRIORITY_LOW)
-            .setOngoing(true)
-            .setSilent(true)
-            .setProgress(100, 0, false)
-
-        /** The id of the notification for in-progress user data migration. */
-        val id = 2
-
-        fun build() = this.notificationBuilder.build()
-        fun notifyUpdate(currentProgress: NumberOfBytes) {
-            Timber.v("update: %d", currentProgress)
-            notificationBuilder.setProgress(sourceSize.toKB(), currentProgress.toKB(), false)
-            notificationBuilder.setContentText(
-                context.resources.getString(
-                    R.string.migration_transferred_size,
-                    currentProgress.toMB().toFloat(),
-                    sourceSize.toMB().toFloat()
-                )
-            )
-            manager.notify(id, notificationBuilder.build())
-        }
+    var flowOfProgress: MutableStateFlow<Progress> = MutableStateFlow(Progress.CalculatingTransferSize)
 
-        fun notifyCompletion(result: Boolean) {
-            val titleRes = if (result) R.string.migration_successful_message else R.string.migration_failed_message
-            val notificationTitle = context.resources.getString(titleRes)
-            notificationBuilder.setContentTitle(notificationTitle)
-                .setOngoing(false)
-                .hideProgressBar()
-            manager.notify(id, notificationBuilder.build())
-        }
+    private lateinit var migrateUserDataTask: MigrateUserData
 
-        fun notifyError(e: Exception) {
-            // TODO: Add a button for 'Get Help'
-            val copyIntent = IntentHandler.copyStringToClipboardIntent(this.context, e.toString())
+    private var serviceHasBeenStarted = false
 
-            val copyDebugIntent = compat.getImmutableActivityIntent(this.context, COPY_DEBUG, copyIntent, 0)
-            notificationBuilder.setContentTitle(context.getString(R.string.migration_failed_message))
-                .setContentText(e.toString())
-                .setOngoing(false)
-                .hideProgressBar()
-                .addAction(R.drawable.ic_star_notify, context.getString(R.string.feedback_copy_debug), copyDebugIntent)
+    // TODO Emit the according `flowOfProgress` here.
+    //   I think it would simplify things if we could always bind to the service,
+    //   even if `onStartCommand` is not going to be called.
+    //   This way the UI elements that need service progress can always get it
+    //   directly from the service, instead of relying on the last view model reading.
+    override fun onCreate() {}
 
-            manager.notify(id, notificationBuilder.build())
-        }
+    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
+        Timber.w("onStartCommand(%s, ...)", intent)
 
-        companion object {
-            const val COPY_DEBUG: Int = 1
-            fun createInstance(context: Context, sourceSize: NumberOfBytes): Notification {
-                val notificationManager = NotificationManagerCompat.from(context)
-                return Notification(context, notificationManager, sourceSize)
-            }
+        if (serviceHasBeenStarted) {
+            Timber.w("MigrationService.onStartCommand has been called twice")
+            return START_STICKY
         }
-    }
 
-    private fun getRestartBehavior() = START_STICKY
-
-    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
-        // If a service is called twice, onStartCommand is called twice
-        if (isStarted) {
-            Timber.v("rejected onStartCommand")
-            return getRestartBehavior()
-        }
-        isStarted = true
-        Timber.d("onStartCommand")
+        serviceHasBeenStarted = true
 
+        // TODO `MigrateUserData.createInstance` is doing I/O and can throw I/O errors.
+        //   Figure out what's going on and move all I/O into a thread.
+        // TODO Previous code re-threw MigrateUserData.MissingDirectoryException.
+        //   Figure out why.
         val migrateUserDataTask = try {
             MigrateUserData.createInstance(AnkiDroidApp.getSharedPrefs(this))
-        } catch (e: MigrateUserData.MissingDirectoryException) {
-            // TODO: Log and handle - likely SD card removal
-            throw e
         } catch (e: Exception) {
+            Timber.e(e, "Could not instantiate MigrateUserData")
             stopSelf()
-            return getRestartBehavior()
+            return START_STICKY
         }
 
-        // a migration is not taking place
+        // TODO Instead of returning `null,` have `MigrateUserData.createInstance` throw an exception.
         if (migrateUserDataTask == null) {
             Timber.w("MigrationService started when a migration was not taking place")
             stopSelf()
-            return getRestartBehavior()
+            return START_STICKY
         }
 
         this.migrateUserDataTask = migrateUserDataTask
-        this.migrateDataThread = thread(name = "Storage Migration") {
-            this.totalToTransfer = getRemainingTransferSize(migrateUserDataTask)
-            val listener = MigrateUserDataProgressListener(this)
-            listener.initNotification(totalToTransfer)
+
+        lifecycleScope.launch(Dispatchers.IO) {
+            flowOfProgress.emit(Progress.CalculatingTransferSize)
+
             try {
-                val result = migrateUserDataTask.migrateFiles { bytesTransferred -> listener.onProgressUpdate(bytesTransferred) }
-                listener.onResult(result)
+                val totalBytesToTransfer = getRemainingTransferSize(migrateUserDataTask)
+                var transferredBytes = 0L
+
+                migrateUserDataTask.migrateFiles(progressListener = { deltaTransferredBytes ->
+                    transferredBytes += deltaTransferredBytes
+                    flowOfProgress.tryEmit(Progress.Transferring(transferredBytes, totalBytesToTransfer))
+                })
+
+                // TODO This is probably not supposed to be here
+                AnkiDroidApp.getSharedPrefs(this@MigrationService).edit {
+                    remove(PREF_MIGRATION_DESTINATION)
+                    remove(PREF_MIGRATION_SOURCE)
+                }
+
+                flowOfProgress.emit(Progress.Success)
             } catch (e: Exception) {
-                CrashReportService.sendExceptionReport(e, "Storage Migration Failed")
-                listener.onError(e)
+                CrashReportService.sendExceptionReport(e, "Storage migration failed")
+                flowOfProgress.emit(Progress.Failure(e))
             }
         }
 
-        return getRestartBehavior()
-    }
+        lifecycleScope.launch {
+            flowOfProgress.collect { progress ->
+                startForeground(2, makeMigrationProgressNotification(progress))
 
-    override fun onDestroy() {
-        Timber.d("onDestroy")
-        if (::migrateUserDataTask.isInitialized) { migrateUserDataTask.executor.terminate() }
-        if (::notificationUpdater.isInitialized) { notificationUpdater.terminate() }
-        super.onDestroy()
-    }
+                // TODO Replace the toast with a dialog that is shown either
+                //   * now, if deck picker is shown,
+                //   * whenever the deck picker is shown, if not, perhaps even after app death.
+                if (progress is Progress.Success) {
+                    UIUtils.showThemedToast(this@MigrationService, R.string.migration_successful_message, true)
+                }
 
-    private fun getRemainingTransferSize(
-        task: MigrateUserData
-    ): NumberOfBytes? {
-        return try {
-            val ignoredFiles = MigrateEssentialFiles.iterateEssentialFiles(task.source) +
-                File(task.source.directory, MoveConflictedFile.CONFLICT_DIRECTORY)
-            val ignoredSpace = ignoredFiles.sumOf { FileUtil.getSize(it) }
-            val folderSize = FileUtil.DirectoryContentInformation.fromDirectory(task.source.directory).totalBytes
-            val remainingSpaceToMigrate = folderSize - ignoredSpace
-            Timber.d("folder size: %d, safe: %d, remaining: %d", folderSize, ignoredSpace, remainingSpaceToMigrate)
-            return remainingSpaceToMigrate
-        } catch (e: Exception) {
-            Timber.w(e, "Failed to get directory size")
-            null
+                if (progress is Progress.Done) {
+                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
+                        @Suppress("DEPRECATION")
+                        stopForeground(false)
+                    } else {
+                        stopForeground(STOP_FOREGROUND_DETACH)
+                    }
+
+                    stopSelf()
+                }
+            }
         }
+
+        return START_STICKY
     }
 
-    /**
-     * Class used for the client Binder.  Because we know this service always
-     * runs in the same process as its clients, we don't need to deal with IPC.
-     *
-     * See: https://developer.android.com/guide/components/bound-services#Binder
-     */
-    inner class LocalBinder : Binder(), SimpleBinder<MigrationService> {
-        @Suppress("unused")
-        override fun getService(): MigrationService = this@MigrationService
+    // TODO This is inadequate, instead of calculating the remaining transfer size
+    //   every time migration is started,
+    //   we should be calculating this size only when starting migration for the first time,
+    //   and keeping track of the transferred and the remaining files.
+    // TODO Between this call and the subsequent migration the contents of the folder can change.
+    //   This can lead to inconsistent readings in the UI.
+    private fun getRemainingTransferSize(task: MigrateUserData): Long {
+        val ignoredFiles = MigrateEssentialFiles.iterateEssentialFiles(task.source) +
+            File(task.source.directory, MoveConflictedFile.CONFLICT_DIRECTORY)
+        val ignoredSpace = ignoredFiles.sumOf { FileUtil.getSize(it) }
+        val folderSize = FileUtil.DirectoryContentInformation.fromDirectory(task.source.directory).totalBytes
+        val remainingSpaceToMigrate = folderSize - ignoredSpace
+        Timber.d("folder size: %d, safe: %d, remaining: %d", folderSize, ignoredSpace, remainingSpaceToMigrate)
+        return remainingSpaceToMigrate
     }
 
-    override fun onBind(intent: Intent): IBinder = LocalBinder()
+    override fun onBind(intent: Intent) = SimpleBinder(this)
 
     /**
      * A file was expected at the provided location, but wasn't found
@@ -288,6 +192,75 @@ class MigrationService : Service() {
     }
 }
 
-/** Hides a progress bar if previously shown on a notification */
-private fun NotificationCompat.Builder.hideProgressBar(): NotificationCompat.Builder =
-    this.setProgress(0, 0, false)
+private fun Context.makeMigrationProgressNotification(progress: MigrationService.Progress): Notification {
+    val builder = NotificationCompat.Builder(this, Channel.SCOPED_STORAGE_MIGRATION.id )
+        .setSmallIcon(R.drawable.ic_star_notify)
+        .setContentTitle(getString(R.string.migration__migrating_data))
+        .setPriority(NotificationCompat.PRIORITY_LOW)
+        .setSilent(true)
+
+    when (progress) {
+        is MigrationService.Progress.CalculatingTransferSize -> {
+            builder.setOngoing(true)
+            builder.setProgress(0, 0, true)
+            builder.setContentText(getString(R.string.migration__calculating_transfer_size))
+        }
+
+        is MigrationService.Progress.Transferring -> {
+            val transferredSizeText = Formatter.formatShortFileSize(this, progress.transferredBytes)
+            val totalSizeText = Formatter.formatShortFileSize(this, progress.totalBytes)
+
+            builder.setOngoing(true)
+            builder.setProgress(Int.MAX_VALUE, (progress.ratio * Int.MAX_VALUE).toInt(), false)
+            builder.setContentText(getString(R.string.migration__transferred_x_of_y, transferredSizeText, totalSizeText))
+        }
+
+        is MigrationService.Progress.Success -> {
+            builder.setProgress(100, 100, false)
+            builder.setContentText(getString(R.string.migration_successful_message))
+        }
+
+        // TODO: Add a “Get help” button
+        is MigrationService.Progress.Failure -> {
+            val copyDebugInfoIntent = IntentHandler
+                .copyStringToClipboardIntent(this, progress.e.stackTraceToString())
+            val copyDebugInfoPendingIntent = CompatHelper.compat
+                .getImmutableActivityIntent(this, 1, copyDebugInfoIntent, 0)
+
+            builder.addAction(R.drawable.ic_star_notify, getString(R.string.feedback_copy_debug), copyDebugInfoPendingIntent)
+            builder.setContentText(getString(R.string.migration__failed, progress.e))
+        }
+    }
+
+    return builder.build()
+}
+
+/**
+ * A delegate for a property that yields:
+ *   * the [MigrationService] if the migration is in progress, and when the owner is started,
+ *   * or `null` otherwise.
+ *
+ * Note: binding to the service happens fast, but not immediately,
+ * so expect this property to be `null` when reading right after `onStart()`.
+ */
+fun <O> O.migrationServiceWhileStartedOrNull(): ReadOnlyProperty<Any?, MigrationService?>
+        where O : Context, O : LifecycleOwner {
+    var service: MigrationService? = null
+
+    lifecycleScope.launch {
+        lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
+            if (userMigrationIsInProgress(this@migrationServiceWhileStartedOrNull)) {
+                try {
+                    withBoundTo<MigrationService> {
+                        service = it
+                        suspendCancellableCoroutine {}
+                    }
+                } finally {
+                    service = null
+                }
+            }
+        }
+    }
+
+    return ReadOnlyProperty { _, _ -> service }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceConnection.kt b/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceConnection.kt
deleted file mode 100644
index 4f6d48cb19a9..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceConnection.kt
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Copyright (c) 2023 David Allison <davidallisongithub@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free Software
- *  Foundation; either version 3 of the License, or (at your option) any later
- *  version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
- *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.ichi2.anki.services
-
-import android.app.Service
-import android.content.*
-import android.content.ServiceConnection
-import android.os.IBinder
-import androidx.core.content.ContextCompat
-import timber.log.Timber
-
-/**
- * Simplifies the interface for binding to a running service
- * Access the service via [instance].
- *
- *
- * @param T The service to encapsulate. Note: service's [Service.onBind] must return a [SimpleBinder]
- */
-open class ServiceConnection<T : Service> {
-    var instance: T? = null
-        private set
-
-    /** Whether [bind] was called and succeeded */
-    private var serviceBound = false
-
-    val connection = object : ServiceConnection {
-        override fun onServiceConnected(name: ComponentName, service: IBinder) {
-            if (service !is SimpleBinder<*>) {
-                throw IllegalStateException("$name must return a binder implementing SimpleBinder")
-            }
-            val binder = service as SimpleBinder<*>
-            Timber.d("%s connected", name.shortClassName)
-            @Suppress("UNCHECKED_CAST")
-            this@ServiceConnection.instance = (binder.getService() as T).also {
-                onServiceConnected(it)
-            }
-        }
-
-        override fun onServiceDisconnected(name: ComponentName) {
-            Timber.d("%s disconnected", name.shortClassName)
-            instance?.let {
-                onServiceDisconnected(it)
-                instance = null
-            }
-        }
-    }
-
-    fun startForeground(context: Context, clazz: Class<T>) {
-        ContextCompat.startForegroundService(context, Intent(context, clazz))
-        bind(context, clazz)
-    }
-
-    fun unbind(context: Context) {
-        instance?.let { onServiceDisconnected(it) }
-        if (serviceBound) {
-            context.unbindService(connection)
-        }
-        serviceBound = false
-    }
-
-    /**
-     * @param flags @see `Context.BindServiceFlags`
-     */
-    fun bind(context: Context, clazz: Class<T>, flags: Int = Context.BIND_AUTO_CREATE) {
-        Intent(context, clazz).also { intent ->
-            context.bindService(intent, connection, flags)
-            serviceBound = true
-        }
-    }
-
-    open fun onServiceConnected(service: T) {}
-    open fun onServiceDisconnected(service: T) {}
-}
-
-/**
- * Marker interface to allow a [Service] to be usable with [ServiceConnection]
- */
-interface SimpleBinder<T : Service> {
-    fun getService(): T
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceUtils.kt b/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceUtils.kt
new file mode 100644
index 000000000000..0065459395d4
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/services/ServiceUtils.kt
@@ -0,0 +1,88 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.ichi2.anki.services
+
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.Intent
+import android.content.ServiceConnection
+import android.os.Binder
+import android.os.IBinder
+import androidx.annotation.CallSuper
+import androidx.lifecycle.LifecycleCoroutineScope
+import com.ichi2.anki.*
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlin.coroutines.Continuation
+import kotlin.coroutines.resume
+
+class SimpleBinder<S : Service>(val service: S) : Binder()
+
+interface ServiceWithASimpleBinder<S : Service> {
+    fun onBind(intent: Intent): SimpleBinder<S>
+}
+
+/**
+ * A service with a [lifecycleScope] that is cancelled when the service is destroyed.
+ * It is not an actual [LifecycleCoroutineScope],
+ * as a service can't meaningfully be in a started or resumed state.
+ */
+abstract class ServiceWithALifecycleScope : Service() {
+    protected val lifecycleScope = CoroutineScope(Dispatchers.Main)
+
+    @CallSuper
+    override fun onDestroy() {
+        lifecycleScope.coroutineContext.cancel()
+    }
+}
+
+/**
+ * Bind to a service and run [block],
+ * unbinding from the service after the block has finished, or if the coroutine is cancelled.
+ *
+ *     withBoundTo<MigrationService> { service ->
+ *         // Bound to service
+ *     }
+ *     // Unbound from service
+ *
+ * Note: the block will not be executed in sync, but *very* soon in practice;
+ * if at the same time we post on some view, the posted block will run after this block.
+ */
+suspend inline fun <reified S> Context.withBoundTo(block: (S) -> Unit)
+        where S : Service, S : ServiceWithASimpleBinder<S> {
+    lateinit var continuation: Continuation<S>
+
+    val connection = object : ServiceConnection {
+        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
+            @Suppress("UNCHECKED_CAST")
+            continuation.resume((binder as SimpleBinder<S>).service)
+        }
+
+        override fun onServiceDisconnected(name: ComponentName?) {}
+    }
+
+    bindService(Intent(this, S::class.java), connection, Context.BIND_AUTO_CREATE)
+
+    val service = suspendCancellableCoroutine { continuation = it }
+
+    try {
+        block(service)
+    } finally {
+        unbindService(connection)
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/viewmodels/MigrationProgressViewModel.kt b/AnkiDroid/src/main/java/com/ichi2/anki/viewmodels/MigrationProgressViewModel.kt
deleted file mode 100644
index fd698b0c01c5..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/anki/viewmodels/MigrationProgressViewModel.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- Copyright (c) 2023 Ashish Yadav <mailtoashish693@gmail.com>
-
- This program is free software; you can redistribute it and/or modify it under
- the terms of the GNU General Public License as published by the Free Software
- Foundation; either version 3 of the License, or (at your option) any later
- version.
-
- This program is distributed in the hope that it will be useful, but WITHOUT ANY
- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
- PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.ichi2.anki.viewmodels
-
-import androidx.lifecycle.ViewModel
-import com.ichi2.anki.dialogs.MigrationProgress
-import kotlinx.coroutines.flow.MutableStateFlow
-
-class MigrationProgressViewModel : ViewModel() {
-    val migrationProgressFlow = MutableStateFlow(MigrationProgress(0, 0))
-}
diff --git a/AnkiDroid/src/main/res/values/01-core.xml b/AnkiDroid/src/main/res/values/01-core.xml
index 8c407b12b7cd..b751895a69ac 100644
--- a/AnkiDroid/src/main/res/values/01-core.xml
+++ b/AnkiDroid/src/main/res/values/01-core.xml
@@ -238,11 +238,14 @@
         translatable="false"
         >@string/webview_crash_unknown</string>
 
-    <!-- Scoped Storage Migration -->
-    <string name="migrating_data_message">Migrating your data</string>
+    <!-- Scoped storage migration -->
+    <string name="migration__migrating_data">Migrating data</string>
+    <string name="migration__calculating_transfer_size">Calculating transfer size…</string>
+    <string name="migration__transferred_x_of_y"
+        comment="The placeholders will be replaced with short localized byte amounts,
+        e.g. Transferred 10 kB of 5.2 MB">Transferred %1$s of %2$s</string>
     <string name="migration_successful_message">Migration successful</string>
-    <string name="migration_failed_message">Migration failed</string>
-    <string name="migration_transferred_size">Migrated %1$.0f MB of %2$.0f MB</string>
+    <string name="migration__failed">Migration failed: %s</string>
 
     <string name="directory_inaccessible_after_uninstall" comment="Dialog title if AnkiDroid can't access the collection once the app is installed">Inaccessible collection</string>
     <string name="directory_inaccessible_after_uninstall_summary" comment="the parameter is the path to the AnkiDroid folder. Typically /storage/emulated/0/AnkiDroid">We are unable to access your collection after AnkiDroid is uninstalled due to a change in Play Store Policy\n\nYour data is safe and can be restored. It is located at\n%s\n\nSelect an option below to restore:</string>
diff --git a/AnkiDroid/src/main/res/values/02-strings.xml b/AnkiDroid/src/main/res/values/02-strings.xml
index 26d8500adadb..d1fd37f5df61 100644
--- a/AnkiDroid/src/main/res/values/02-strings.xml
+++ b/AnkiDroid/src/main/res/values/02-strings.xml
@@ -400,7 +400,6 @@
     <string name="scoped_storage_learn_more">Learn More</string>
     <string name="scoped_storage_postpone">Postpone</string>
     <string name="scoped_storage_migrate">Migrate</string>
-    <string name="scoped_storage_migration_progress">Syncing is disabled until storage migration is completed.\nLoading...</string>
 
     <string name="search_card_js_api_no_results">Search returned no results</string>
 
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
index 912b20cf8f9d..c2d7cdeb7374 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/servicelayer/scopedstorage/ScopedStorageMigrationIntegrationTest.kt
@@ -213,7 +213,12 @@ class ScopedStorageMigrationIntegrationTest : RobolectricTest() {
     }
 
     private fun MigrateUserDataTester.execTask(): Boolean {
-        return this.migrateFiles(mock())
+        this.migrateFiles(mock())
+
+        // TODO BEFORE-RELEASE This method always returns true, as before this change
+        //   it returned the result of `migrateFiles`, which was also always true.
+        //   Figure out why and apply the necessary changes.
+        return true
     }
 }
 
