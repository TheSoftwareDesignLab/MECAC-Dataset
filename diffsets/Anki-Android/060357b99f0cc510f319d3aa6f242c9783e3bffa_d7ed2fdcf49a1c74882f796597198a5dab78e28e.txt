diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
index 8bda5898a17d..40c2ac1d7b5d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
@@ -1963,7 +1963,7 @@ protected void restoreCollectionPreferences() {
 
         // These are preferences we pull out of the collection instead of SharedPreferences
         try {
-            mShowNextReviewTime = getCol().getConf().getBoolean("estTimes");
+            mShowNextReviewTime = getCol().get_config_boolean("estTimes");
 
             // Dynamic don't have review options; attempt to get deck-specific auto-advance options
             // but be prepared to go with all default if it's a dynamic deck
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
index b2b94753a29c..a8f27c21cf58 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
@@ -623,7 +623,7 @@ protected void onCollectionLoaded(Collection col) {
         mActionBarTitle = findViewById(R.id.toolbar_title);
 
         mOrder = CARD_ORDER_NONE;
-        String colOrder = getCol().getConf().getString("sortType");
+        String colOrder = getCol().get_config_string("sortType");
         for (int c = 0; c < fSortTypes.length; ++c) {
             if (fSortTypes[c].equals(colOrder)) {
                 mOrder = c;
@@ -637,7 +637,7 @@ protected void onCollectionLoaded(Collection col) {
         //setConf. However older version of AnkiDroid didn't call
         //upgradeJSONIfNecessary during setConf, which means the
         //conf saved may still have this bug.
-        mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), getCol().getConf(), "sortBackwards", false);
+        mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), "sortBackwards", false);
 
         mCards.reset();
         mCardsListView = findViewById(R.id.card_browser_list);
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
index 928e58fd8355..f0a9df5bcd46 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/NoteEditor.java
@@ -1801,10 +1801,9 @@ private void setDid(Note note) {
             return;
         }
         if (note == null || mAddNote || mCurrentEditedCard == null) {
-            JSONObject conf = getCol().getConf();
             JSONObject model = getCol().getModels().current();
             if (getCol().get_config("addToCur", true)) {
-                mCurrentDid = conf.getLong("curDeck");
+                mCurrentDid = getCol().get_config_long("curDeck");
                 if (getCol().getDecks().isDyn(mCurrentDid)) {
                     /*
                      * If the deck in mCurrentDid is a filtered (dynamic) deck, then we can't create cards in it,
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Preferences.java b/AnkiDroid/src/main/java/com/ichi2/anki/Preferences.java
index a295f7cca721..d6f7b4c751ea 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Preferences.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Preferences.java
@@ -299,25 +299,24 @@ private void initPreference(android.preference.Preference pref) {
             Collection col = getCol();
             if (col != null) {
                 try {
-                    JSONObject conf = col.getConf();
                     switch (pref.getKey()) {
                         case SHOW_ESTIMATE:
-                            ((android.preference.CheckBoxPreference)pref).setChecked(conf.getBoolean("estTimes"));
+                            ((android.preference.CheckBoxPreference)pref).setChecked(col.get_config_boolean("estTimes"));
                             break;
                         case SHOW_PROGRESS:
-                            ((android.preference.CheckBoxPreference)pref).setChecked(conf.getBoolean("dueCounts"));
+                            ((android.preference.CheckBoxPreference)pref).setChecked(col.get_config_boolean("dueCounts"));
                             break;
                         case LEARN_CUTOFF:
-                            ((NumberRangePreference)pref).setValue(conf.getInt("collapseTime") / 60);
+                            ((NumberRangePreference)pref).setValue(col.get_config_int("collapseTime") / 60);
                             break;
                         case TIME_LIMIT:
-                            ((NumberRangePreference)pref).setValue(conf.getInt("timeLim") / 60);
+                            ((NumberRangePreference)pref).setValue(col.get_config_int("timeLim") / 60);
                             break;
                         case USE_CURRENT:
                             ((android.preference.ListPreference)pref).setValueIndex(col.get_config("addToCur", true) ? 0 : 1);
                             break;
                         case NEW_SPREAD:
-                            ((android.preference.ListPreference)pref).setValueIndex(conf.getInt("newSpread"));
+                            ((android.preference.ListPreference)pref).setValueIndex(col.get_config_int("newSpread"));
                             break;
                         case DAY_OFFSET:
                             ((SeekBarPreference)pref).setValue(getDayOffset(col));
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
index 0be948624dc3..07e88b5b1565 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java
@@ -1116,7 +1116,7 @@ protected void initControls() {
 
     protected void restoreCollectionPreferences() {
         super.restoreCollectionPreferences();
-        mShowRemainingCardCount = getCol().getConf().getBoolean("dueCounts");
+        mShowRemainingCardCount = getCol().get_config_boolean("dueCounts");
     }
 
     @Override
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
index 836980c02728..90d185169f1b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java
@@ -529,7 +529,7 @@ public int nextID(String type) {
         type = "next" + Character.toUpperCase(type.charAt(0)) + type.substring(1);
         int id;
         try {
-            id = mConf.getInt(type);
+            id = get_config_int(type);
         } catch (JSONException e) {
             Timber.w(e);
             id = 1;
@@ -1260,7 +1260,7 @@ public void setTimeLimit(long seconds) {
 
 
     public long getTimeLimit() {
-        return mConf.getLong("timeLim");
+        return get_config_long("timeLim");
     }
 
 
@@ -1272,13 +1272,13 @@ public void startTimebox() {
 
     /* Return (elapsedTime, reps) if timebox reached, or null. */
     public Pair<Integer, Integer> timeboxReached() {
-        if (mConf.getLong("timeLim") == 0) {
+        if (get_config_long("timeLim") == 0) {
             // timeboxing disabled
             return null;
         }
         long elapsed = getTime().intTime() - mStartTime;
-        if (elapsed > mConf.getLong("timeLim")) {
-            return new Pair<>(mConf.getInt("timeLim"), mSched.getReps() - mStartReps);
+        if (elapsed > get_config_long("timeLim")) {
+            return new Pair<>(get_config_int("timeLim"), mSched.getReps() - mStartReps);
         }
         return null;
     }
@@ -2075,7 +2075,7 @@ public void setConf(JSONObject conf) {
         // bug #5523. This bug should occur only for people using anki
         // prior to version 2.16 and has been corrected with
         // dae/anki#347
-        Upgrade.upgradeJSONIfNecessary(this, conf, "sortBackwards", false);
+        Upgrade.upgradeJSONIfNecessary(this, "sortBackwards", false);
         mConf = conf;
     }
 
@@ -2088,6 +2088,35 @@ public void setConf(JSONObject conf) {
     // methods with a default can be named `get_config` as the `defaultValue` argument defines the return type
     // NOTE: get_config("key", 1) and get_config("key", 1L) will return different types
 
+    /** @throws JSONException object does not exist or can't be cast */
+    public boolean get_config_boolean(@NonNull String key) {
+        return mConf.getBoolean(key);
+    }
+
+    /** @throws JSONException object does not exist or can't be cast */
+    public long get_config_long(@NonNull String key) {
+        return mConf.getLong(key);
+    }
+
+    /** @throws JSONException object does not exist or can't be cast */
+    public int get_config_int(@NonNull String key) {
+        return mConf.getInt(key);
+    }
+
+    /** @throws JSONException object does not exist or can't be cast */
+    public double get_config_double(@NonNull String key) {
+        return mConf.getDouble(key);
+    }
+
+    /**
+     * If the value is null in the JSON, a string of "null" will be returned
+     * @throws JSONException object does not exist, or can't be cast
+     */
+    @NonNull
+    public String get_config_string(@NonNull String key) {
+        return mConf.getString(key);
+    }
+
     @Nullable
     @Contract("_, !null -> !null")
     public Boolean get_config(@NonNull String key, @Nullable Boolean defaultValue) {
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
index e2ee967c1f81..092b1b9ecef1 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
@@ -1071,7 +1071,7 @@ public LinkedList<Long> active() {
      * The currently selected did.
      */
     public long selected() {
-        return mCol.getConf().getLong("curDeck");
+        return mCol.get_config_long("curDeck");
     }
 
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/DecksV16.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/DecksV16.kt
index 7b90f2dd45d0..2f1e0d466a88 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/DecksV16.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/DecksV16.kt
@@ -518,7 +518,7 @@ class DeckManager(private val col: Collection, private val mDecksBackend: DecksB
 
     /** The currently selected did. */
     fun selected(): did {
-        return this.col.conf.getLong("curDeck")
+        return this.col.get_config_long("curDeck")
     }
 
     fun current(): DeckV16 {
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java
index aac61d92b498..f5a870d25072 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java
@@ -415,7 +415,7 @@ private Pair<String, Boolean> _order(Boolean order) {
             return new Pair<>("", false);
         }
         // use deck default
-        String type = mCol.getConf().getString("sortType");
+        String type = mCol.get_config_string("sortType");
         String sort = null;
         if (type.startsWith("note")) {
             if (type.startsWith("noteCrt")) {
@@ -444,7 +444,7 @@ private Pair<String, Boolean> _order(Boolean order) {
             // deck has invalid sort order; revert to noteCrt
             sort = "n.id, c.ord";
         }
-        boolean sortBackwards = mCol.getConf().getBoolean("sortBackwards");
+        boolean sortBackwards = mCol.get_config_boolean("sortBackwards");
         return new Pair<>(" ORDER BY " + sort, sortBackwards);
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
index 4ffb72ad1bc4..2240422629cd 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
@@ -387,7 +387,7 @@ mDayCutoff, currentCardId(), mReportLimit)) {
         if (_fillLrn()) {
             long cutoff = getTime().intTime();
             if (collapse) {
-                cutoff += mCol.getConf().getInt("collapseTime");
+                cutoff += mCol.get_config_int("collapseTime");
             }
             if (mLrnQueue.getFirstDue() < cutoff) {
                 return mLrnQueue.removeFirstCard();
@@ -592,7 +592,7 @@ private int _lrnForDeck(long did) {
                     "SELECT sum(left / 1000) FROM (SELECT left FROM cards WHERE did = ?"
                             + " AND queue = " + Consts.QUEUE_TYPE_LRN + " AND due < ?"
                             + " LIMIT ?)",
-                    did, (getTime().intTime() + mCol.getConf().getInt("collapseTime")), mReportLimit);
+                    did, (getTime().intTime() + mCol.get_config_int("collapseTime")), mReportLimit);
             return cnt + mCol.getDb().queryScalar(
                     "SELECT count() FROM (SELECT 1 FROM cards WHERE did = ?"
                             + " AND queue = " + Consts.QUEUE_TYPE_DAY_LEARN_RELEARN + " AND due <= ?"
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
index 0ade9fba5af9..1ebecddc1c1d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
@@ -899,7 +899,7 @@ private boolean _fillNew(boolean allowSibling) {
 
 
     private void _updateNewCardRatio() {
-        if (mCol.getConf().getInt("newSpread") == Consts.NEW_CARDS_DISTRIBUTE) {
+        if (mCol.get_config_int("newSpread") == Consts.NEW_CARDS_DISTRIBUTE) {
             if (mNewCount != 0) {
                 mNewCardModulus = (mNewCount + mRevCount) / mNewCount;
                 // if there are cards to review, ensure modulo >= 2
@@ -920,7 +920,7 @@ protected boolean _timeForNewCard() {
         if (mHaveCounts && mNewCount == 0) {
             return false;
         }
-        @Consts.NEW_CARD_ORDER int spread = mCol.getConf().getInt("newSpread");
+        @Consts.NEW_CARD_ORDER int spread = mCol.get_config_int("newSpread");
         if (spread == Consts.NEW_CARDS_LAST) {
             return false;
         } else if (spread == Consts.NEW_CARDS_FIRST) {
@@ -1015,7 +1015,7 @@ public int totalNewForCurrentDeck() {
      */
 
     private boolean _updateLrnCutoff(boolean force) {
-        long nextCutoff = getTime().intTime() + mCol.getConf().getInt("collapseTime");
+        long nextCutoff = getTime().intTime() + mCol.get_config_int("collapseTime");
         if (nextCutoff - mLrnCutoff > 60 || force) {
             mLrnCutoff = nextCutoff;
             return true;
@@ -1076,7 +1076,7 @@ protected boolean _fillLrn() {
         if (!mLrnQueue.isEmpty()) {
             return true;
         }
-        long cutoff = getTime().intTime() + mCol.getConf().getLong("collapseTime");
+        long cutoff = getTime().intTime() + mCol.get_config_long("collapseTime");
         mLrnQueue.clear();
         /* Difference with upstream: Current card can't come in the queue.
              *
@@ -1107,7 +1107,7 @@ protected boolean _fillLrn() {
         if (_fillLrn()) {
             long cutoff = getTime().intTime();
             if (collapse) {
-                cutoff += mCol.getConf().getInt("collapseTime");
+                cutoff += mCol.get_config_int("collapseTime");
             }
             if (mLrnQueue.getFirstDue() < cutoff) {
                 return mLrnQueue.removeFirstCard();
@@ -1123,7 +1123,7 @@ protected boolean _preloadLrnCard(boolean collapse) {
         if (_fillLrn()) {
             long cutoff = getTime().intTime();
             if (collapse) {
-                cutoff += mCol.getConf().getInt("collapseTime");
+                cutoff += mCol.get_config_int("collapseTime");
             }
             // mLrnCount -= 1; see decrementCounts()
             return mLrnQueue.getFirstDue() < cutoff;
@@ -1275,7 +1275,7 @@ private int _rescheduleLrnCard(@NonNull Card card, @NonNull JSONObject conf, @Nu
             int fuzz = new Random().nextInt(Math.max(maxExtra, 1));
             card.setDue(Math.min(mDayCutoff - 1, card.getDue() + fuzz));
             card.setQueue(Consts.QUEUE_TYPE_LRN);
-            if (card.getDue() < (getTime().intTime() + mCol.getConf().getInt("collapseTime"))) {
+            if (card.getDue() < (getTime().intTime() + mCol.get_config_int("collapseTime"))) {
                 mLrnCount += 1;
                 // if the queue is not empty and there's nothing else to do, make
                 // sure we don't put it at the head of the queue and end up showing
@@ -1476,7 +1476,7 @@ private int _lrnForDeck(long did) {
                     "SELECT count() FROM (SELECT null FROM cards WHERE did = ?"
                             + " AND queue = " + Consts.QUEUE_TYPE_LRN + " AND due < ?"
                             + " LIMIT ?)",
-                    did, (getTime().intTime() + mCol.getConf().getInt("collapseTime")), mReportLimit);
+                    did, (getTime().intTime() + mCol.get_config_int("collapseTime")), mReportLimit);
             return cnt + mCol.getDb().queryScalar(
                     "SELECT count() FROM (SELECT null FROM cards WHERE did = ?"
                             + " AND queue = " + Consts.QUEUE_TYPE_DAY_LEARN_RELEARN + " AND due <= ?"
@@ -2431,7 +2431,7 @@ public boolean haveBuried() {
             return context.getString(R.string.sched_end);
         }
         String s = Utils.timeQuantityNextIvl(context, ivl);
-        if (ivl < mCol.getConf().getInt("collapseTime")) {
+        if (ivl < mCol.get_config_int("collapseTime")) {
             s = context.getString(R.string.less_than_time, s);
         }
         return s;
diff --git a/AnkiDroid/src/main/java/com/ichi2/upgrade/Upgrade.java b/AnkiDroid/src/main/java/com/ichi2/upgrade/Upgrade.java
index 366453a39a41..f79508604708 100644
--- a/AnkiDroid/src/main/java/com/ichi2/upgrade/Upgrade.java
+++ b/AnkiDroid/src/main/java/com/ichi2/upgrade/Upgrade.java
@@ -10,15 +10,15 @@
 
 public class Upgrade {
 
-    public static boolean upgradeJSONIfNecessary(Collection col, JSONObject conf, String name, boolean defaultValue) {
+    public static boolean upgradeJSONIfNecessary(Collection col, String name, boolean defaultValue) {
         boolean val = defaultValue;
         try {
-            val = conf.getBoolean(name);
+            val = col.get_config_boolean(name);
         } catch (JSONException e) {
             Timber.w(e);
             // workaround to repair wrong values from older libanki versions
             try {
-                conf.put(name, val);
+                 col.set_config(name, val);
             } catch (JSONException e1) {
                 Timber.w(e1);
                 // do nothing
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
index d14255e1fbc8..79be7ba989c8 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
@@ -598,7 +598,7 @@ public void checkDisplayOrderPersistence() {
         advanceRobolectricLooperWithSleep();
 
         // Make sure card has default value in sortType field
-        assertThat("Initially Card Browser has order = noteFld", getCol().getConf().get("sortType"), is("noteFld"));
+        assertThat("Initially Card Browser has order = noteFld", getCol().get_config_string("sortType"), is("noteFld"));
 
         // Store the current (before changing the database) Mod Time
         long initialMod = getCol().getMod();
@@ -616,7 +616,7 @@ public void checkDisplayOrderPersistence() {
         // Find the current (after database has been changed) Mod time
         long finalMod = getCol().getMod();
 
-        assertThat("Card Browser has the new sortType field", getCol().getConf().get("sortType"), is("cardEase"));
+        assertThat("Card Browser has the new sortType field", getCol().get_config_string("sortType"), is("cardEase"));
         Assert.assertNotEquals("Modification time must change", initialMod, finalMod);
     }
 
