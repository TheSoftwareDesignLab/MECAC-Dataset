diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/audiorecord/AudioRecordView.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/audiorecord/AudioRecordView.kt
new file mode 100644
index 000000000000..f3ae6b306cba
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/audiorecord/AudioRecordView.kt
@@ -0,0 +1,477 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates code from https://github.com/varunjohn/Audio-Recording-Animation
+ * under the Apache License, Version 2.0.
+ */
+package com.ichi2.anki.ui.windows.reviewer.audiorecord
+
+import android.content.Context
+import android.os.Parcel
+import android.os.Parcelable
+import android.os.SystemClock
+import android.util.AttributeSet
+import android.view.GestureDetector
+import android.view.LayoutInflater
+import android.view.MotionEvent
+import android.view.View
+import android.view.animation.AnimationUtils
+import android.view.animation.LinearInterpolator
+import android.view.animation.OvershootInterpolator
+import android.widget.Chronometer
+import android.widget.ImageView
+import androidx.appcompat.widget.AppCompatImageView
+import androidx.appcompat.widget.ThemeUtils
+import androidx.constraintlayout.widget.ConstraintLayout
+import androidx.core.util.TypedValueCompat
+import androidx.core.view.isVisible
+import com.ichi2.anki.R
+import com.ichi2.compat.CompatHelper
+import com.ichi2.utils.Permissions
+import kotlin.math.abs
+import kotlin.math.max
+import kotlin.time.Duration.Companion.milliseconds
+
+/**
+ * A view that can serve as an audio recorder.
+ *
+ * The main functionalities work around the record button:
+ * * Tap to start recording
+ * * Long press to record while pressed
+ *     * Swipe up to 'lock' and keep recording until the stop button is pressed
+ *     * Swipe left to cancel the recording
+ * * Check if the microphone permission has been granted before doing any action
+ *
+ * It also displays a recording icon and time
+ */
+class AudioRecordView : ConstraintLayout {
+    // region Views
+    private val recordButton: View
+    private val recordButtonIcon: ImageView
+    private val lockArrow: View
+    private val imageViewLock: View
+    private val recordDisplayIcon: AppCompatImageView
+    private val layoutSlideCancel: View
+    private val layoutLock: View
+    private val chronometer: Chronometer
+    // endregion
+
+    // region Animations
+    private val animBlink = AnimationUtils.loadAnimation(context, R.anim.blink)
+    private val animJump = AnimationUtils.loadAnimation(context, R.anim.jump)
+    private val animJumpFast = AnimationUtils.loadAnimation(context, R.anim.jump_fast)
+    // endregion
+
+    // region State & Logic
+    private var state = ViewState.IDLE
+    private var stopTrackingAction = false
+    private var chronometerBase: Long = 0
+    private val recordEnabledColor = context.getColor(R.color.material_red_600)
+    private val recordDisabledColor = ThemeUtils.getThemeAttrColor(context, R.attr.editTextDisabled)
+
+    private var firstX = 0f
+    private var firstY = 0f
+    private var lastX = 0f
+    private var lastY = 0f
+
+    private val dp = TypedValueCompat.dpToPx(1F, resources.displayMetrics)
+    private val cancelOffset: Float
+    private val cancelFadeOffset: Float
+    private val lockOffset: Float
+
+    private var recordingListener: RecordingListener? = null
+
+    fun setRecordingListener(recordingListener: RecordingListener) {
+        this.recordingListener = recordingListener
+    }
+
+    private lateinit var gestureDetector: GestureDetector
+    // endregion
+
+    constructor(context: Context) : this(context, null, 0, 0)
+    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0, 0)
+    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : this(context, attrs, defStyleAttr, 0)
+    constructor(
+        context: Context,
+        attrs: AttributeSet?,
+        defStyleAttr: Int,
+        defStyleRes: Int,
+    ) : super(context, attrs, defStyleAttr, defStyleRes) {
+        LayoutInflater.from(context).inflate(R.layout.audio_record_view, this, true)
+        recordButton = findViewById(R.id.recordButton)
+        recordButtonIcon = findViewById(R.id.recordIcon)
+        imageViewLock = findViewById(R.id.lock_icon)
+        lockArrow = findViewById(R.id.lock_arrow_icon)
+        chronometer = findViewById(R.id.chronometer)
+        layoutSlideCancel = findViewById(R.id.layout_slide_cancel)
+        layoutLock = findViewById(R.id.layoutLock)
+        recordDisplayIcon = findViewById(R.id.recording_status_icon)
+        cancelOffset = max((resources.displayMetrics.widthPixels * 0.25f), 60f * dp)
+        cancelFadeOffset = cancelOffset * 0.8f
+        lockOffset = max((resources.displayMetrics.heightPixels * 0.25f), 80f * dp)
+
+        setupTouchListener()
+    }
+
+    private enum class ViewState {
+        IDLE,
+        RECORDING,
+        LOCKED,
+    }
+
+    enum class RecordingBehavior {
+        CANCEL,
+        LOCK,
+        RELEASE,
+    }
+
+    interface RecordingListener {
+        fun onRecordingPermissionRequired()
+
+        fun onRecordingStarted()
+
+        fun onRecordingCanceled()
+
+        fun onRecordingCompleted()
+    }
+
+    private fun setupTouchListener() {
+        gestureDetector =
+            GestureDetector(
+                context,
+                object : GestureDetector.SimpleOnGestureListener() {
+                    override fun onDown(e: MotionEvent): Boolean {
+                        if (!Permissions.canRecordAudio(context)) {
+                            recordingListener?.onRecordingPermissionRequired()
+                            return true
+                        }
+                        startRecording()
+                        recordButton
+                            .animate()
+                            .scaleX(1.25f)
+                            .scaleY(1.25f)
+                            .setDuration(150)
+                            .start()
+                        return true
+                    }
+
+                    override fun onSingleTapUp(e: MotionEvent): Boolean {
+                        if (!Permissions.canRecordAudio(context)) return true
+                        lock()
+                        return true
+                    }
+
+                    override fun onLongPress(e: MotionEvent) {
+                        if (!Permissions.canRecordAudio(context)) return
+                        CompatHelper.compat.vibrate(context, 20.milliseconds)
+                        showCancelAndLockSliders()
+                        firstX = e.rawX
+                        firstY = e.rawY
+                    }
+                },
+            )
+        recordButton.setOnTouchListener(gestureListener)
+    }
+
+    private val gestureListener =
+        OnTouchListener { _, motionEvent ->
+            gestureDetector.onTouchEvent(motionEvent)
+
+            if (motionEvent.action == MotionEvent.ACTION_UP || motionEvent.action == MotionEvent.ACTION_CANCEL) {
+                if (state == ViewState.IDLE) {
+                    reset(animate = true)
+                }
+            }
+
+            if (state == ViewState.RECORDING) {
+                when (motionEvent.action) {
+                    MotionEvent.ACTION_UP -> stopRecording(RecordingBehavior.RELEASE)
+                    MotionEvent.ACTION_MOVE -> handleMove(motionEvent)
+                }
+            }
+            true
+        }
+
+    private fun handleMove(motionEvent: MotionEvent) {
+        if (stopTrackingAction) return
+
+        val behavior = getBehaviorFromDirection(motionEvent.rawX, motionEvent.rawY)
+        when (behavior) {
+            RecordingBehavior.CANCEL -> translateX(motionEvent.rawX - firstX)
+            RecordingBehavior.LOCK -> translateY(motionEvent.rawY - firstY)
+            else -> {}
+        }
+
+        lastX = motionEvent.rawX
+        lastY = motionEvent.rawY
+    }
+
+    /**
+     * @return the behavior based on the predominant movement, which can be:
+     * * [RecordingBehavior.LOCK] if it's a vertical movement to the top
+     * * [RecordingBehavior.CANCEL] if it's an horizontal movement to the left
+     * * `null` otherwise
+     */
+    private fun getBehaviorFromDirection(
+        currentX: Float,
+        currentY: Float,
+    ): RecordingBehavior? {
+        val motionX = abs(firstX - currentX)
+        val motionY = abs(firstY - currentY)
+
+        return when {
+            motionY > motionX && currentY < firstY -> RecordingBehavior.LOCK
+            motionX > motionY && currentX < firstX -> RecordingBehavior.CANCEL
+            else -> null
+        }
+    }
+
+    /**
+     * Moves the record button and lock slider vertically based on [y].
+     * If [lockOffset] is reached, the recording is locked and the vertical positions are reset.
+     */
+    private fun translateY(y: Float) {
+        if (y < -lockOffset) {
+            lock()
+            recordButton.translationY = 0f
+            return
+        }
+
+        layoutLock.visibility = VISIBLE
+        recordButton.translationY = y
+        layoutLock.translationY = y / 2
+        recordButton.translationX = 0f
+    }
+
+    /**
+     * Moves the record button and cancel slider horizontally based on [x].
+     * If [cancelOffset] is reached, the recording is canceled
+     * and the horizontal positions are reset.
+     */
+    private fun translateX(x: Float) {
+        if (x < -cancelOffset) {
+            cancel()
+            recordButton.translationX = 0f
+            layoutSlideCancel.translationX = 0f
+            return
+        }
+
+        val alpha = (cancelFadeOffset - abs(x)) / cancelFadeOffset
+        layoutSlideCancel.alpha = alpha.coerceIn(0f, 1f)
+
+        recordButton.translationX = x
+        layoutSlideCancel.translationX = x
+        layoutLock.translationY = 0f
+        recordButton.translationY = 0f
+
+        if (abs(x) < recordButton.width / 2) {
+            layoutLock.visibility = VISIBLE
+        } else {
+            layoutLock.visibility = GONE
+        }
+    }
+
+    private fun startRecording() {
+        state = ViewState.RECORDING
+        stopTrackingAction = false
+        recordingListener?.onRecordingStarted()
+        displayRunningRecord()
+    }
+
+    private fun showCancelAndLockSliders() {
+        recordButton
+            .animate()
+            .scaleX(1.8f)
+            .scaleY(1.8f)
+            .setDuration(200)
+            .setInterpolator(OvershootInterpolator())
+            .start()
+
+        layoutLock.visibility = VISIBLE
+        layoutSlideCancel.visibility = VISIBLE
+        lockArrow.startAnimation(animJumpFast)
+        imageViewLock.startAnimation(animJump)
+    }
+
+    /**
+     * Sets the visibility of the record timer and icon to [isVisible]
+     */
+    fun setRecordDisplayVisibility(isVisible: Boolean) {
+        chronometer.isVisible = isVisible
+        recordDisplayIcon.isVisible = isVisible
+    }
+
+    private fun displayRunningRecord() {
+        setRecordDisplayVisibility(true)
+
+        recordDisplayIcon.setColorFilter(recordEnabledColor)
+        recordDisplayIcon.startAnimation(animBlink)
+
+        chronometer.base = if (chronometerBase > 0) chronometerBase else SystemClock.elapsedRealtime()
+        chronometer.isEnabled = true
+        chronometer.start()
+    }
+
+    private fun lock() {
+        state = ViewState.LOCKED
+        stopTrackingAction = true
+
+        recordButtonIcon.setImageResource(R.drawable.ic_stop)
+        recordButton.animate().cancel()
+        recordButton.scaleX = 1f
+        recordButton.scaleY = 1f
+
+        recordButton.setOnTouchListener(null)
+        recordButton.setOnClickListener {
+            stopRecording(RecordingBehavior.LOCK)
+        }
+        layoutSlideCancel.visibility = GONE
+        layoutLock.visibility = GONE
+    }
+
+    private fun cancel() {
+        stopTrackingAction = true
+        stopRecording(RecordingBehavior.CANCEL)
+    }
+
+    private fun stopRecording(outcome: RecordingBehavior) {
+        if (state != ViewState.RECORDING && state != ViewState.LOCKED) return
+
+        val animateRelease = outcome == RecordingBehavior.RELEASE
+        reset(animate = animateRelease)
+        chronometer.stop()
+
+        when (outcome) {
+            RecordingBehavior.CANCEL -> {
+                recordingListener?.onRecordingCanceled()
+            }
+            RecordingBehavior.RELEASE, RecordingBehavior.LOCK -> {
+                recordingListener?.onRecordingCompleted()
+            }
+        }
+    }
+
+    private fun reset(animate: Boolean) {
+        state = ViewState.IDLE
+        stopTrackingAction = false
+        firstX = 0f
+        firstY = 0f
+        lastX = 0f
+        lastY = 0f
+        chronometerBase = 0
+
+        recordButtonIcon.setImageResource(R.drawable.ic_action_mic)
+        recordButton.setOnClickListener(null)
+        recordButton.setOnTouchListener(gestureListener)
+
+        if (animate) {
+            recordButton
+                .animate()
+                .scaleX(1f)
+                .scaleY(1f)
+                .translationX(0f)
+                .translationY(0f)
+                .setDuration(100)
+                .setInterpolator(LinearInterpolator())
+                .start()
+        } else {
+            recordButton.animate().cancel()
+            recordButton.scaleX = 1f
+            recordButton.scaleY = 1f
+            recordButton.translationX = 0f
+            recordButton.translationY = 0f
+        }
+
+        layoutSlideCancel.visibility = GONE
+        layoutLock.visibility = GONE
+        chronometer.visibility = INVISIBLE
+        recordDisplayIcon.visibility = INVISIBLE
+
+        // Reset the translation of the sliders to ensure they start from the correct position next time
+        layoutLock.translationY = 0f
+        layoutSlideCancel.translationX = 0f
+        layoutSlideCancel.alpha = 1f
+
+        setRecordDisplayVisibility(true)
+        chronometer.base = SystemClock.elapsedRealtime()
+        chronometer.isEnabled = false
+        recordDisplayIcon.setColorFilter(recordDisabledColor)
+        recordDisplayIcon.clearAnimation()
+        lockArrow.clearAnimation()
+        imageViewLock.clearAnimation()
+    }
+
+    /**
+     * Immediately stops all actions and animations, and returns the view to its initial state.
+     */
+    fun forceReset() {
+        chronometer.stop()
+        recordButton.clearAnimation()
+        recordDisplayIcon.clearAnimation()
+        reset(animate = false)
+    }
+
+    override fun onSaveInstanceState(): Parcelable {
+        val superState = super.onSaveInstanceState()
+        val savedState = SavedState(superState)
+        savedState.state = state
+        savedState.chronometerBase = chronometer.base
+        return savedState
+    }
+
+    override fun onRestoreInstanceState(state: Parcelable?) {
+        if (state is SavedState) {
+            super.onRestoreInstanceState(state.superState)
+            this.state = state.state
+            this.chronometerBase = state.chronometerBase
+            when (this.state) {
+                ViewState.LOCKED -> {
+                    displayRunningRecord()
+                    lock()
+                }
+                else -> reset(false)
+            }
+        } else {
+            super.onRestoreInstanceState(state)
+        }
+    }
+
+    private class SavedState : BaseSavedState {
+        var state: ViewState = ViewState.IDLE
+        var chronometerBase: Long = 0
+
+        constructor(superState: Parcelable?) : super(superState)
+
+        private constructor(source: Parcel) : super(source) {
+            state = ViewState.valueOf(source.readString() ?: ViewState.IDLE.name)
+            chronometerBase = source.readLong()
+        }
+
+        override fun writeToParcel(
+            out: Parcel,
+            flags: Int,
+        ) {
+            super.writeToParcel(out, flags)
+            out.writeString(state.name)
+            out.writeLong(chronometerBase)
+        }
+
+        companion object CREATOR : Parcelable.Creator<SavedState> {
+            override fun createFromParcel(source: Parcel): SavedState = SavedState(source)
+
+            override fun newArray(size: Int): Array<SavedState?> = arrayOfNulls(size)
+        }
+    }
+}
diff --git a/AnkiDroid/src/main/res/anim/blink.xml b/AnkiDroid/src/main/res/anim/blink.xml
new file mode 100644
index 000000000000..1dea0aed8bca
--- /dev/null
+++ b/AnkiDroid/src/main/res/anim/blink.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright 2018 Varun John
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <alpha android:fromAlpha="0.0"
+        android:toAlpha="1.0"
+        android:interpolator="@android:anim/accelerate_interpolator"
+        android:duration="600"
+        android:repeatMode="reverse"
+        android:repeatCount="infinite"/>
+</set>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/anim/jump.xml b/AnkiDroid/src/main/res/anim/jump.xml
new file mode 100644
index 000000000000..0891a55860ad
--- /dev/null
+++ b/AnkiDroid/src/main/res/anim/jump.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright 2018 Varun John
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <translate
+        android:duration="600"
+        android:fromYDelta="-2%p"
+        android:interpolator="@android:anim/bounce_interpolator"
+        android:repeatCount="infinite"
+        android:repeatMode="reverse"
+        android:toYDelta="2%p" />
+</set>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/anim/jump_fast.xml b/AnkiDroid/src/main/res/anim/jump_fast.xml
new file mode 100644
index 000000000000..b2093fa09835
--- /dev/null
+++ b/AnkiDroid/src/main/res/anim/jump_fast.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright 2018 Varun John
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <translate
+        android:duration="300"
+        android:fromYDelta="-2%p"
+        android:interpolator="@android:anim/bounce_interpolator"
+        android:repeatCount="infinite"
+        android:repeatMode="reverse"
+        android:toYDelta="2%p" />
+</set>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/drawable/ic_lock_open.xml b/AnkiDroid/src/main/res/drawable/ic_lock_open.xml
new file mode 100644
index 000000000000..63193717f1b7
--- /dev/null
+++ b/AnkiDroid/src/main/res/drawable/ic_lock_open.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="960"
+    android:viewportHeight="960"
+    android:tint="?attr/colorControlNormal">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M240,320L600,320L600,240Q600,190 565,155Q530,120 480,120Q430,120 395,155Q360,190 360,240L280,240Q280,157 338.5,98.5Q397,40 480,40Q563,40 621.5,98.5Q680,157 680,240L680,320L720,320Q753,320 776.5,343.5Q800,367 800,400L800,800Q800,833 776.5,856.5Q753,880 720,880L240,880Q207,880 183.5,856.5Q160,833 160,800L160,400Q160,367 183.5,343.5Q207,320 240,320ZM240,800L720,800Q720,800 720,800Q720,800 720,800L720,400Q720,400 720,400Q720,400 720,400L240,400Q240,400 240,400Q240,400 240,400L240,800Q240,800 240,800Q240,800 240,800ZM480,680Q513,680 536.5,656.5Q560,633 560,600Q560,567 536.5,543.5Q513,520 480,520Q447,520 423.5,543.5Q400,567 400,600Q400,633 423.5,656.5Q447,680 480,680ZM240,800Q240,800 240,800Q240,800 240,800L240,400Q240,400 240,400Q240,400 240,400L240,400Q240,400 240,400Q240,400 240,400L240,800Q240,800 240,800Q240,800 240,800Z"/>
+</vector>
diff --git a/AnkiDroid/src/main/res/drawable/ic_record.xml b/AnkiDroid/src/main/res/drawable/ic_record.xml
index ba071425410d..fdf8b50284d8 100644
--- a/AnkiDroid/src/main/res/drawable/ic_record.xml
+++ b/AnkiDroid/src/main/res/drawable/ic_record.xml
@@ -1,4 +1,4 @@
-<vector android:height="24dp" android:tint="#000000"
+<vector android:height="24dp" android:tint="?colorControlNormal"
     android:viewportHeight="24" android:viewportWidth="24"
     android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
     <path android:fillColor="@android:color/white" android:pathData="M12,12m-7,0a7,7 0,1 1,14 0a7,7 0,1 1,-14 0"/>
diff --git a/AnkiDroid/src/main/res/layout/audio_record_view.xml b/AnkiDroid/src/main/res/layout/audio_record_view.xml
new file mode 100644
index 000000000000..148905aca9b5
--- /dev/null
+++ b/AnkiDroid/src/main/res/layout/audio_record_view.xml
@@ -0,0 +1,141 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.com>
+
+  This program is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free Software
+  Foundation; either version 3 of the License, or (at your option) any later
+  version.
+
+  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+  PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program. If not, see <http://www.gnu.org/licenses/>.
+
+  This file incorporates code from https://github.com/varunjohn/Audio-Recording-Animation
+  under the Apache License, Version 2.0.
+-->
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:clipChildren="false"
+    android:elevation="2dp">
+
+    <androidx.appcompat.widget.AppCompatImageView
+        android:id="@+id/recording_status_icon"
+        android:layout_width="16dp"
+        android:layout_height="16dp"
+        android:layout_marginStart="4dp"
+        app:layout_constraintTop_toTopOf="@id/recordButton"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        android:src="@drawable/ic_record"
+        app:tint="?editTextDisabled"
+        android:visibility="visible"
+        />
+
+    <Chronometer
+        android:id="@+id/chronometer"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintStart_toEndOf="@id/recording_status_icon"
+        app:layout_constraintTop_toTopOf="@id/recordButton"
+        app:layout_constraintBottom_toBottomOf="parent"
+        android:elevation="2dp"
+        android:enabled="false"
+        android:layout_marginStart="8dp"
+        android:textSize="16sp"
+        android:visibility="visible"/>
+
+    <LinearLayout
+        android:id="@+id/layout_slide_cancel"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toTopOf="@id/recordButton"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@id/recordButton"
+        android:layout_marginEnd="28dp"
+        android:gravity="center"
+        android:clipChildren="false"
+        android:visibility="gone"
+        tools:visibility="visible"
+        tools:ignore="UseCompoundDrawables">
+
+        <ImageView
+            android:layout_width="16dp"
+            android:layout_height="16dp"
+            android:layout_marginEnd="8dp"
+            android:rotation="-90"
+            android:src="@drawable/ic_expand_less_black_24dp"
+            tools:ignore="ContentDescription" />
+
+        <TextView
+            android:id="@+id/textViewSlide"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/slide_to_cancel"
+            android:textColor="#898f9d"
+            android:textSize="16sp"
+            android:textStyle="normal" />
+
+    </LinearLayout>
+
+    <androidx.cardview.widget.CardView
+        android:id="@+id/layoutLock"
+        style="@style/Widget.AnkiDroid.CardView.Recording"
+        android:layout_width="48dp"
+        android:layout_height="180dp"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintBottom_toBottomOf="parent"
+        android:clipChildren="false"
+        android:visibility="gone"
+        tools:visibility="visible"
+        >
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:gravity="center|top"
+            android:orientation="vertical"
+            android:clipChildren="false">
+
+            <ImageView
+                android:id="@+id/lock_icon"
+                android:layout_width="20dp"
+                android:layout_height="20dp"
+                android:layout_marginTop="18dp"
+                android:layout_gravity="center_horizontal"
+                android:src="@drawable/ic_lock_open" />
+
+            <ImageView
+                android:id="@+id/lock_arrow_icon"
+                android:layout_width="16dp"
+                android:layout_height="16dp"
+                android:layout_marginTop="10dp"
+                android:src="@drawable/ic_expand_less_black_24dp" />
+
+        </LinearLayout>
+
+    </androidx.cardview.widget.CardView>
+
+    <androidx.cardview.widget.CardView
+        android:id="@+id/recordButton"
+        style="@style/Widget.AnkiDroid.CardView.Recording"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent">
+
+        <ImageView
+            android:id="@+id/recordIcon"
+            android:layout_gravity="center"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            app:srcCompat="@drawable/ic_action_mic"/>
+
+    </androidx.cardview.widget.CardView>
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/values/02-strings.xml b/AnkiDroid/src/main/res/values/02-strings.xml
index 047fe81be54e..eb0528cf2466 100644
--- a/AnkiDroid/src/main/res/values/02-strings.xml
+++ b/AnkiDroid/src/main/res/values/02-strings.xml
@@ -60,6 +60,7 @@
     <string name="webview_crash_fatal">Fatal Error: WebView renderer crashed. Cause: %s</string>
     <string name="webview_crash_loop_dialog_title">System WebView Rendering Failure</string>
     <string name="webview_crash_loop_dialog_content">System WebView failed to render card \'%1$s\'.\n %2$s</string>
+    <string name="slide_to_cancel" comment="Message shown when pressing the record button">Slide to cancel</string>
 
     <string name="filter_by_flags" maxLength="41">Flags</string>
 
diff --git a/AnkiDroid/src/main/res/values/styles.xml b/AnkiDroid/src/main/res/values/styles.xml
index fb6fee853bc4..64744a8a538a 100644
--- a/AnkiDroid/src/main/res/values/styles.xml
+++ b/AnkiDroid/src/main/res/values/styles.xml
@@ -254,4 +254,16 @@
     <style name="ThemeOverlay.App.BottomSheetDialog" parent="ThemeOverlay.Material3.BottomSheetDialog">
         <item name="android:navigationBarColor" tools:ignore="NewApi">@android:color/transparent</item>
     </style>
+
+    <style name="Widget.AnkiDroid.CardView.Recording" parent="CardView">
+        <item name="cardElevation">@dimen/study_screen_elevation</item>
+        <item name="cardPreventCornerOverlap">false</item>
+        <item name="contentPadding">0dp</item>
+        <item name="android:clickable">true</item>
+        <item name="android:focusable">true</item>
+        <item name="android:elevation">@dimen/study_screen_elevation</item>
+        <item name="cardCornerRadius">16dp</item>
+        <item name="cardUseCompatPadding">false</item>
+        <item name="cardBackgroundColor">?popupBackgroundColor</item>
+    </style>
 </resources>
