diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/StudyOptionsFragment.java b/AnkiDroid/src/main/java/com/ichi2/anki/StudyOptionsFragment.java
index 949c37155889..13d9cd5ae972 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/StudyOptionsFragment.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/StudyOptionsFragment.java
@@ -341,51 +341,74 @@ public boolean onMenuItemClick(MenuItem item) {
     }
 
     public void configureToolbar() {
-        mToolbar.setOnMenuItemClickListener(this);
-        Menu menu = mToolbar.getMenu();
-        // Switch on or off rebuild/empty/custom study depending on whether or not filtered deck
-        if (getCol().getDecks().isDyn(getCol().getDecks().selected())) {
-            menu.findItem(R.id.action_rebuild).setVisible(true);
-            menu.findItem(R.id.action_empty).setVisible(true);
-            menu.findItem(R.id.action_custom_study).setVisible(false);
-        } else {
-            menu.findItem(R.id.action_rebuild).setVisible(false);
-            menu.findItem(R.id.action_empty).setVisible(false);
-            menu.findItem(R.id.action_custom_study).setVisible(true);
-        }
-        // Don't show custom study icon if congrats shown
-        if (mCurrentContentView == CONTENT_CONGRATS) {
-            menu.findItem(R.id.action_custom_study).setVisible(false);
-        }
-        // Switch on rename / delete / export if tablet layout
-        if (mFragmented) {
-            menu.findItem(R.id.action_rename).setVisible(true);
-            menu.findItem(R.id.action_delete).setVisible(true);
-            menu.findItem(R.id.action_export).setVisible(true);
-        } else {
-            menu.findItem(R.id.action_rename).setVisible(false);
-            menu.findItem(R.id.action_delete).setVisible(false);
-            menu.findItem(R.id.action_export).setVisible(false);
-        }
-        // Switch on or off unbury depending on if there are cards to unbury
-        menu.findItem(R.id.action_unbury).setVisible(getCol().getSched().haveBuried());
-        // Switch on or off undo depending on whether undo is available
-        if (!getCol().undoAvailable()) {
-            menu.findItem(R.id.action_undo).setVisible(false);
-        } else {
-            menu.findItem(R.id.action_undo).setVisible(true);
-            Resources res = AnkiDroidApp.getAppResources();
-            menu.findItem(R.id.action_undo).setTitle(res.getString(R.string.studyoptions_congrats_undo, getCol().undoName(res)));
-        }
-        // Set the back button listener
-        if (!mFragmented) {
-            mToolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp);
-            mToolbar.setNavigationOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    ((AnkiActivity) getActivity()).finishWithAnimation(ActivityTransitionAnimation.RIGHT);
+        configureToolbarInternal(true);
+    }
+
+    // This will allow a maximum of one recur in order to workaround database closes
+    // caused by sync on startup where this might be running then have the collection close
+    private void configureToolbarInternal(boolean recur) {
+        try {
+            mToolbar.setOnMenuItemClickListener(this);
+            Menu menu = mToolbar.getMenu();
+            // Switch on or off rebuild/empty/custom study depending on whether or not filtered deck
+            if (getCol().getDecks().isDyn(getCol().getDecks().selected())) {
+                menu.findItem(R.id.action_rebuild).setVisible(true);
+                menu.findItem(R.id.action_empty).setVisible(true);
+                menu.findItem(R.id.action_custom_study).setVisible(false);
+            } else {
+                menu.findItem(R.id.action_rebuild).setVisible(false);
+                menu.findItem(R.id.action_empty).setVisible(false);
+                menu.findItem(R.id.action_custom_study).setVisible(true);
+            }
+            // Don't show custom study icon if congrats shown
+            if (mCurrentContentView == CONTENT_CONGRATS) {
+                menu.findItem(R.id.action_custom_study).setVisible(false);
+            }
+            // Switch on rename / delete / export if tablet layout
+            if (mFragmented) {
+                menu.findItem(R.id.action_rename).setVisible(true);
+                menu.findItem(R.id.action_delete).setVisible(true);
+                menu.findItem(R.id.action_export).setVisible(true);
+            } else {
+                menu.findItem(R.id.action_rename).setVisible(false);
+                menu.findItem(R.id.action_delete).setVisible(false);
+                menu.findItem(R.id.action_export).setVisible(false);
+            }
+            // Switch on or off unbury depending on if there are cards to unbury
+            menu.findItem(R.id.action_unbury).setVisible(getCol().getSched().haveBuried());
+            // Switch on or off undo depending on whether undo is available
+            if (!getCol().undoAvailable()) {
+                menu.findItem(R.id.action_undo).setVisible(false);
+            } else {
+                menu.findItem(R.id.action_undo).setVisible(true);
+                Resources res = AnkiDroidApp.getAppResources();
+                menu.findItem(R.id.action_undo).setTitle(res.getString(R.string.studyoptions_congrats_undo, getCol().undoName(res)));
+            }
+            // Set the back button listener
+            if (!mFragmented) {
+                mToolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp);
+                mToolbar.setNavigationOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        ((AnkiActivity) getActivity()).finishWithAnimation(ActivityTransitionAnimation.RIGHT);
+                    }
+                });
+            }
+        } catch (IllegalStateException e) {
+            if (!CollectionHelper.getInstance().colIsOpen()) {
+                if (recur) {
+                    Timber.i(e, "Database closed while working. Probably auto-sync. Will re-try after sleep.");
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException ex) {
+                        Timber.i(ex, "Thread interrupted while waiting to retry. Likely unimportant.");
+                        Thread.currentThread().interrupt();
+                    }
+                    configureToolbarInternal(false);
+                } else {
+                    Timber.w(e, "Database closed while working. No re-tries left.");
                 }
-            });
+            }
         }
     }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/services/ReminderService.java b/AnkiDroid/src/main/java/com/ichi2/anki/services/ReminderService.java
index 5f9a01c6c029..6e034195447b 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/services/ReminderService.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/services/ReminderService.java
@@ -23,6 +23,7 @@
 import androidx.core.app.NotificationCompat;
 import androidx.core.app.NotificationManagerCompat;
 import androidx.core.content.ContextCompat;
+import timber.log.Timber;
 
 import com.ichi2.anki.CollectionHelper;
 import com.ichi2.anki.IntentHandler;
@@ -52,14 +53,7 @@ public void onReceive(Context context, Intent intent) {
             alarmManager.cancel(reminderIntent);
         }
 
-        Sched.DeckDueTreeNode deckDue = null;
-
-        for (Sched.DeckDueTreeNode node : CollectionHelper.getInstance().getCol(context).getSched().deckDueTree()) {
-            if (node.did == deckId) {
-                deckDue = node;
-                break;
-            }
-        }
+        Sched.DeckDueTreeNode deckDue = getDeckDue(context, deckId, true);
 
         if (null == deckDue) {
             return;
@@ -98,4 +92,32 @@ public void onReceive(Context context, Intent intent) {
             notificationManager.notify((int) deckId, notification);
         }
     }
+
+    // getDeckDue information, will recur one time to workaround collection close if recur is true
+    private Sched.DeckDueTreeNode getDeckDue(Context context, long deckId, boolean recur) {
+        try {
+            for (Sched.DeckDueTreeNode node : CollectionHelper.getInstance().getCol(context).getSched().deckDueTree()) {
+                if (node.did == deckId) {
+                    return node;
+                }
+            }
+        } catch (IllegalStateException e) {
+            if (!CollectionHelper.getInstance().colIsOpen()) {
+                if (recur) {
+                    Timber.i(e, "Database closed while working. Probably auto-sync. Will re-try after sleep.");
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException ex) {
+                        Timber.i(ex, "Thread interrupted while waiting to retry. Likely unimportant.");
+                        Thread.currentThread().interrupt();
+                    }
+                    return getDeckDue(context, deckId, false);
+                } else {
+                    Timber.w(e, "Database closed while working. No re-tries left.");
+                }
+            }
+        }
+
+        return null;
+    }
 }
