diff --git a/src/com/ichi2/anki/AbstractFlashcardViewer.java b/src/com/ichi2/anki/AbstractFlashcardViewer.java
index 826e55863d6b..fe7106e7bbc9 100644
--- a/src/com/ichi2/anki/AbstractFlashcardViewer.java
+++ b/src/com/ichi2/anki/AbstractFlashcardViewer.java
@@ -307,7 +307,6 @@ public abstract class AbstractFlashcardViewer extends AnkiActivity {
      */
     private boolean mUseQuickUpdate = false;
 
-
     /**
      * Swipe Detection
      */
@@ -323,7 +322,7 @@ public abstract class AbstractFlashcardViewer extends AnkiActivity {
     private int mGestureSwipeUp;
     private int mGestureSwipeDown;
     private int mGestureSwipeLeft;
-    private int mGestureSwipeRight;    
+    private int mGestureSwipeRight;
     private int mGestureDoubleTap;
     private int mGestureTapLeft;
     private int mGestureTapRight;
@@ -590,7 +589,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
 
             if (sDisplayAnswer) {
                 Sound.resetSounds(); // load sounds from scratch, to expose any edit changes
-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded            
+                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded
                 generateQuestionSoundList(); // questions must be intentionally regenerated
                 displayCardAnswer();
             } else {
@@ -771,7 +770,7 @@ private void updateTypeAnswerInfo() {
     /**
      * Format question field when it contains typeAnswer or clozes. If there was an error during type text extraction, a
      * warning is displayed
-     *
+     * 
      * @param buf The question text
      * @return The formatted question text
      */
@@ -786,7 +785,7 @@ private String typeAnsQuestionFilter(String buf) {
 
     /**
      * Format answer field when it contains typeAnswer or clozes
-     *
+     * 
      * @param buf The answer text
      * @return The formatted answer text
      */
@@ -799,9 +798,9 @@ private String typeAnsAnswerFilter(String buf, String userAnswer, String correct
         if (userAnswer.equals(correctAnswer)) {
             return m.replaceFirst("<div><code id=typeans>" + diffUserAnswer + "\u2714</code></div>");
         } else {
-            return m.replaceFirst("<div><code id=typeans>" + diffUserAnswer + "<br>&darr;<br>" +
-                    diff.diff_prettyHtml(diff.diff_main(correctAnswer, correctAnswer), mNightMode) + "</code></div>");
-    }
+            return m.replaceFirst("<div><code id=typeans>" + diffUserAnswer + "<br>&darr;<br>"
+                    + diff.diff_prettyHtml(diff.diff_main(correctAnswer, correctAnswer), mNightMode) + "</code></div>");
+        }
     }
 
 
@@ -914,7 +913,7 @@ protected void initActivity(Collection col) {
             mShowWhiteboard = true;
             mWhiteboard.setVisibility(View.VISIBLE);
         }
-        
+
         // Initialize dictionary lookup feature
         Lookup.initialize(this);
     }
@@ -935,6 +934,7 @@ protected void onPause() {
         Sound.stopSounds();
     }
 
+
     @Override
     protected void onResume() {
         mInBackground = false;
@@ -1043,6 +1043,7 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         return super.onKeyDown(keyCode, event);
     }
 
+
     private void updateBigWidget(boolean showProgressDialog) {
         // if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
         // Log.i(AnkiDroidApp.TAG, "Reviewer: updateBigWidget");
@@ -1116,7 +1117,7 @@ private void clipboardSetText(CharSequence text) {
     /**
      * Returns the text stored in the clipboard or the empty string if the clipboard is empty or contains something that
      * cannot be convered to text.
-     *
+     * 
      * @return the text in clipboard or the empty string.
      */
     private CharSequence clipboardGetText() {
@@ -1149,8 +1150,8 @@ public boolean onCreateOptionsMenu(Menu menu) {
             }
         }
         if (AnkiDroidApp.SDK_VERSION < 11 && !mDisableClipboard) {
-            menu.findItem(R.id.action_search_dictionary).setVisible(true).setEnabled(!mShowWhiteboard).setTitle(
-                    clipboardHasText() ? Lookup.getSearchStringTitle() : res.getString(R.string.menu_select));
+            menu.findItem(R.id.action_search_dictionary).setVisible(true).setEnabled(!mShowWhiteboard)
+                    .setTitle(clipboardHasText() ? Lookup.getSearchStringTitle() : res.getString(R.string.menu_select));
         }
         return super.onCreateOptionsMenu(menu);
     }
@@ -1322,6 +1323,7 @@ private void restartTimer() {
         }
     }
 
+
     private void undo() {
         if (mSched.getCol().undoAvailable()) {
             if (mProgressDialog != null && mProgressDialog.isShowing()) {
@@ -1351,7 +1353,7 @@ protected boolean editCard() {
 
 
     protected void generateQuestionSoundList() {
-        Sound.addSounds(mBaseUrl, mCurrentCard.qSimple(), Sound.SOUNDS_QUESTION);        
+        Sound.addSounds(mBaseUrl, mCurrentCard.qSimple(), Sound.SOUNDS_QUESTION);
     }
 
 
@@ -1374,6 +1376,7 @@ private boolean lookUp() {
         return true;
     }
 
+
     private void showLookupButtonIfNeeded() {
         if (!mDisableClipboard && mClipboard != null) {
             if (clipboardGetText().length() != 0 && Lookup.isAvailable() && mLookUpIcon.getVisibility() != View.VISIBLE) {
@@ -1386,6 +1389,7 @@ private void showLookupButtonIfNeeded() {
         }
     }
 
+
     private void hideLookupButton() {
         if (!mDisableClipboard && mLookUpIcon.getVisibility() != View.GONE) {
             mLookUpIcon.setVisibility(View.GONE);
@@ -1394,6 +1398,7 @@ private void hideLookupButton() {
         }
     }
 
+
     protected void showDeleteNoteDialog() {
         Dialog dialog;
         Resources res = getResources();
@@ -1434,6 +1439,7 @@ private int getRecommendedEase(boolean easy) {
         }
     }
 
+
     private void answerCard(int ease) {
         if (mInAnswer) {
             return;
@@ -1607,6 +1613,7 @@ public void onClick(View arg0) {
         initControls();
     }
 
+
     @SuppressLint("NewApi") // because of setDisplayZoomControls.
     private WebView createWebView() {
         WebView webView = new MyWebView(this);
@@ -1625,7 +1632,7 @@ private WebView createWebView() {
         if (AnkiDroidApp.SDK_VERSION > 7) {
             webView.setFocusableInTouchMode(false);
         }
-        if (mPrefEInkDisplay){
+        if (mPrefEInkDisplay) {
             AnkiDroidApp.getCompat().setScrollbarFadingEnabled(webView, false);
         }
         Log.i(AnkiDroidApp.TAG,
@@ -1649,10 +1656,10 @@ private void invertColors(boolean invert) {
         mEase4.setTextColor(mNextTimeTextColor);
         mCardTimer.setTextColor(mForegroundColor);
         mTextBarNew.setTextColor(invert ? res.getColor(R.color.new_count_night) : res.getColor(R.color.new_count));
-        mTextBarLearn.setTextColor(
-                invert ? res.getColor(R.color.learn_count_night) : res.getColor(R.color.learn_count));
-        mTextBarReview.setTextColor(
-                invert ? res.getColor(R.color.review_count_night) : res.getColor(R.color.review_count));
+        mTextBarLearn
+                .setTextColor(invert ? res.getColor(R.color.learn_count_night) : res.getColor(R.color.learn_count));
+        mTextBarReview.setTextColor(invert ? res.getColor(R.color.review_count_night) : res
+                .getColor(R.color.review_count));
         mAnswerField.setTextColor(mForegroundColor);
 
         if (mSimpleCard != null) {
@@ -1666,6 +1673,7 @@ private void invertColors(boolean invert) {
                 invert ? R.color.white_background_night : R.color.actionbar_background);
     }
 
+
     protected void showEaseButtons() {
         Resources res = getResources();
 
@@ -1751,6 +1759,7 @@ protected void hideEaseButtons() {
         }
     }
 
+
     private void switchTopBarVisibility(int visible) {
         if (mShowTimer) {
             mCardTimer.setVisibility(visible);
@@ -1779,14 +1788,14 @@ private void initControls() {
         }
         mAnswerField.setVisibility(typeAnswer() ? View.VISIBLE : View.GONE);
         mAnswerField.setOnEditorActionListener(new EditText.OnEditorActionListener() {
-                @Override
-                public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
-                    if (actionId == EditorInfo.IME_ACTION_DONE) {
-                        mFlipCardLayout.performClick();
-                    }
-                    return false;  // We don’t “handle” this. Let Android hide the input method.
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_DONE) {
+                    mFlipCardLayout.performClick();
                 }
-            });
+                return false; // We don’t “handle” this. Let Android hide the input method.
+            }
+        });
     }
 
 
@@ -1859,6 +1868,7 @@ private SharedPreferences restorePreferences() {
         return preferences;
     }
 
+
     private void setInterface() {
         if (mCurrentCard == null) {
             return;
@@ -1924,6 +1934,7 @@ private void setInterface() {
         }
     }
 
+
     private void setDueMessage() {
         // Decks deck = DeckManager.getMainDeck();
         // if (mCurrentCard != null && deck != null && deck.getScheduler().equals("reviewEarly") &&
@@ -1947,6 +1958,7 @@ private void updateForNewCard() {
         }
     }
 
+
     protected void updateScreenCounts() {
         if (mCurrentCard == null) {
             return;
@@ -2013,6 +2025,7 @@ public void run() {
         }
     };
 
+
     protected void initTimer() {
         mShowTimer = mCurrentCard.showTimer();
         if (mShowTimer && mCardTimer.getVisibility() == View.INVISIBLE) {
@@ -2023,6 +2036,8 @@ protected void initTimer() {
         mCardTimer.setBase(SystemClock.elapsedRealtime());
         mCardTimer.start();
     }
+
+
     protected void displayCardQuestion() {
         sDisplayAnswer = false;
 
@@ -2085,21 +2100,22 @@ protected void displayCardQuestion() {
         }
     }
 
-    protected String getAnswerText(String answer)
-    {
+
+    protected String getAnswerText(String answer) {
         if (answer == null || answer.equals("")) {
             return "";
         }
 
-         Matcher matcher = sSpanPattern.matcher(Utils.stripHTMLMedia(answer));
-         String answerText = matcher.replaceAll("");
-         matcher = sBrPattern.matcher(answerText);
-         answerText = matcher.replaceAll("\n");
-         matcher = Sound.sSoundPattern.matcher(answerText);
-         answerText = matcher.replaceAll("");
-         return answerText;
+        Matcher matcher = sSpanPattern.matcher(Utils.stripHTMLMedia(answer));
+        String answerText = matcher.replaceAll("");
+        matcher = sBrPattern.matcher(answerText);
+        answerText = matcher.replaceAll("\n");
+        matcher = Sound.sSoundPattern.matcher(answerText);
+        answerText = matcher.replaceAll("");
+        return answerText;
     }
 
+
     protected void displayCardAnswer() {
         Log.i(AnkiDroidApp.TAG, "displayCardAnswer");
 
@@ -2135,18 +2151,18 @@ protected void displayCardAnswer() {
                 answer = ArabicUtilities.reshapeSentence(answer, true);
             }
 
-                mAnswerField.setVisibility(View.GONE);
-                if (mCurrentCard != null) {
-                    if (mPrefFixArabic) {
-                        // reshape
-                        mTypeCorrect = ArabicUtilities.reshapeSentence(mTypeCorrect, true);
-                    }
-                    // Obtain the user answer and the correct answer
-                    String userAnswer = getAnswerText(mAnswerField.getText().toString());
-                    String correctAnswer = getAnswerText(mTypeCorrect);
-                    Log.i(AnkiDroidApp.TAG, "correct answer = " + correctAnswer);
+            mAnswerField.setVisibility(View.GONE);
+            if (mCurrentCard != null) {
+                if (mPrefFixArabic) {
+                    // reshape
+                    mTypeCorrect = ArabicUtilities.reshapeSentence(mTypeCorrect, true);
+                }
+                // Obtain the user answer and the correct answer
+                String userAnswer = getAnswerText(mAnswerField.getText().toString());
+                String correctAnswer = getAnswerText(mTypeCorrect);
+                Log.i(AnkiDroidApp.TAG, "correct answer = " + correctAnswer);
 
-                    answer = typeAnsAnswerFilter(answer, userAnswer, correctAnswer);
+                answer = typeAnsAnswerFilter(answer, userAnswer, correctAnswer);
                 displayString = enrichWithQADiv(answer, true);
             }
         }
@@ -2181,6 +2197,7 @@ public String getAnswerFormat() {
         }
     }
 
+
     private void updateCard(String content) {
         Log.i(AnkiDroidApp.TAG, "updateCard");
 
@@ -2276,7 +2293,7 @@ private void updateCard(String content) {
     /**
      * Converts characters in Unicode Supplementary Multilingual Plane (SMP) to their equivalent Html Entities. This is
      * done because webview has difficulty displaying these characters.
-     *
+     * 
      * @param text
      * @return
      */
@@ -2294,9 +2311,9 @@ private String SmpToHtmlEntity(String text) {
 
     /**
      * Plays sounds (or TTS, if configured) for currently shown side of card.
-     *
+     * 
      * @param doAudioReplay indicates an anki desktop-like replay call is desired, whose behavior is identical to
-     *      pressing the keyboard shortcut R on the desktop
+     *            pressing the keyboard shortcut R on the desktop
      */
     protected void playSounds(boolean doAudioReplay) {
         boolean replayQuestion = getConfigForCurrentCard().optBoolean("replayq", true);
@@ -2332,6 +2349,7 @@ protected void playSounds(boolean doAudioReplay) {
 
     /**
      * Reads the text (using TTS) for the given side of a card.
+     * 
      * @param card The card to play TTS for
      * @param cardSide The side of the current card to play TTS for
      */
@@ -2348,6 +2366,7 @@ private static void readCardText(final Card card, final int cardSide) {
 
     /**
      * Returns the configuration for the current {@link Card}.
+     * 
      * @return The configuration for the current {@link Card}
      */
     private JSONObject getConfigForCurrentCard() {
@@ -2357,7 +2376,7 @@ private JSONObject getConfigForCurrentCard() {
 
     /**
      * Returns the deck ID of the given {@link Card}.
-     *
+     * 
      * @param card The {@link Card} to get the deck ID
      * @return The deck ID of the {@link Card}
      */
@@ -2367,6 +2386,7 @@ private static long getDeckIdForCard(final Card card) {
         return card.getODid() == 0 ? card.getDid() : card.getODid();
     }
 
+
     public void fillFlashcard() {
         Log.i(AnkiDroidApp.TAG, "base url = " + mBaseUrl);
         if (mCurrentSimpleInterface && mSimpleCard != null) {
@@ -2422,7 +2442,7 @@ public void fillFlashcard() {
                 mWhiteboard.clear();
             }
         }
-     }
+    }
 
 
     public void showFlashcard(boolean visible) {
@@ -2437,7 +2457,7 @@ public static Card getEditorCard() {
 
     /**
      * Adds a div html tag around the contents to have an indication, where answer/question is displayed
-     *
+     * 
      * @param content
      * @param isAnswer if true then the class attribute is set to "answer", "question" otherwise.
      * @return
@@ -2466,7 +2486,7 @@ private static String enrichWithQADiv(String content, boolean isAnswer) {
      * this logic, eg nested span/divs with CSS classes having font-size declarations with relative units (40% dif
      * inside 120% div inside 60% div). Broken HTML also breaks this. Feel free to improve, but please keep it short and
      * fast.
-     *
+     * 
      * @param content The HTML content that will be font-size-adjusted.
      * @param percentage The relative font size percentage defined in preferences
      * @return
@@ -2534,10 +2554,11 @@ private final boolean typeAnswer() {
         return false;
     }
 
+
     /**
      * Calculates a dynamic font size depending on the length of the contents taking into account that the input string
      * contains html-tags, which will not be displayed and therefore should not be taken into account.
-     *
+     * 
      * @param htmlContents
      * @return font size respecting MIN_DYNAMIC_FONT_SIZE and MAX_DYNAMIC_FONT_SIZE
      */
@@ -2700,7 +2721,7 @@ private boolean isNookDevice() {
      * WebView.
      * <p>
      * It is also needed to solve a refresh issue on Nook devices.
-     *
+     * 
      * @return true if we should use a single WebView
      */
     private boolean shouldUseQuickUpdate() {
@@ -2821,10 +2842,12 @@ public boolean onJsAlert(WebView view, String url, String message, JsResult resu
     public final class JavaScriptInterface {
         private AbstractFlashcardViewer mCtx;
 
+
         JavaScriptInterface(AbstractFlashcardViewer ctx) {
             mCtx = ctx;
         }
 
+
         /**
          * This is not called on the UI thread. Send a message that will be handled on the UI thread.
          */
@@ -2834,6 +2857,8 @@ public void playSound(String soundPath) {
             msg.obj = soundPath;
             mHandler.sendMessage(msg);
         }
+
+
         @JavascriptInterface
         public int getAvailableWidth() {
             if (mCtx.mAvailableInCardWidth == 0) {
@@ -2843,6 +2868,7 @@ public int getAvailableWidth() {
         }
     }
 
+
     /** Calculate the width that is available to the webview for content */
     public int calcAvailableInCardWidth() {
         // The available width of the webview equals to the container's width, minus the container's padding
@@ -2854,6 +2880,8 @@ public int calcAvailableInCardWidth() {
         }
         return 0;
     }
+
+
     protected void closeReviewer(int result, boolean saveDeck) {
         mTimeoutHandler.removeCallbacks(mShowAnswerTask);
         mTimeoutHandler.removeCallbacks(mShowQuestionTask);
@@ -2872,6 +2900,7 @@ protected void closeReviewer(int result, boolean saveDeck) {
         ActivityTransitionAnimation.slide(AbstractFlashcardViewer.this, ActivityTransitionAnimation.RIGHT);
     }
 
+
     private void refreshActionBar() {
         AnkiDroidApp.getCompat().invalidateOptionsMenu(AbstractFlashcardViewer.this);
     }
@@ -2883,6 +2912,7 @@ public MyWebView(Context context) {
             super(context);
         }
 
+
         @Override
         public boolean onCheckIsTextEditor() {
             if (mInputWorkaround) {
@@ -2892,6 +2922,7 @@ public boolean onCheckIsTextEditor() {
             }
         }
 
+
         @Override
         protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert) {
             super.onScrollChanged(horiz, vert, oldHoriz, oldVert);
@@ -3021,6 +3052,7 @@ public ScrollTextView(Context context) {
             super(context);
         }
 
+
         @Override
         protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert) {
             super.onScrollChanged(horiz, vert, oldHoriz, oldVert);
@@ -3075,6 +3107,7 @@ public void handleTag(boolean opening, String tag, Editable output, XMLReader xm
             }
         }
 
+
         private Object getLast(Editable text, Class kind) {
             Object[] objs = text.getSpans(0, text.length(), kind);
 
@@ -3106,6 +3139,7 @@ public Drawable getDrawable(String source) {
         }
     };
 
+
     private Spanned convertToSimple(String text) {
         return Html.fromHtml(text, mSimpleInterfaceImagegetter, mSimpleInterfaceTagHandler);
     }
diff --git a/src/com/ichi2/anki/AnkiDatabaseManager.java b/src/com/ichi2/anki/AnkiDatabaseManager.java
index 97c238fc38e5..96831a63031a 100644
--- a/src/com/ichi2/anki/AnkiDatabaseManager.java
+++ b/src/com/ichi2/anki/AnkiDatabaseManager.java
@@ -29,7 +29,7 @@ private AnkiDatabaseManager() {
 
     /**
      * Get a reference over an Anki database, creating the connection if needed.
-     *
+     * 
      * @param pathDB the path to the database.
      * @return the Anki database.
      */
@@ -52,7 +52,7 @@ public static AnkiDb getDatabase(String pathDB) {
 
     /**
      * Close connection to a given database.
-     *
+     * 
      * @param pathDB the path to the database to close.
      */
     public static void closeDatabase(String pathDB) {
@@ -76,7 +76,7 @@ public static void closeAllDatabases() {
 
     /**
      * Check if there is a valid connection to the given database.
-     *
+     * 
      * @param pathDB the path to the database we want to check.
      * @return True if the database is already opened, false otherwise.
      */
diff --git a/src/com/ichi2/anki/AnkiDb.java b/src/com/ichi2/anki/AnkiDb.java
index c42e41d5a56b..12c57336f305 100644
--- a/src/com/ichi2/anki/AnkiDb.java
+++ b/src/com/ichi2/anki/AnkiDb.java
@@ -67,7 +67,8 @@ public void closeDatabase() {
             // set journal mode again to delete in order to make the db accessible for anki desktop and for full upload
             setDeleteJournalMode();
             mDatabase.close();
-            Log.i(AnkiDroidApp.TAG, "AnkiDb - closeDatabase, database " + mDatabase.getPath() + " closed = " + !mDatabase.isOpen());
+            Log.i(AnkiDroidApp.TAG, "AnkiDb - closeDatabase, database " + mDatabase.getPath() + " closed = "
+                    + !mDatabase.isOpen());
             mDatabase = null;
         }
     }
@@ -100,7 +101,7 @@ public boolean getMod() {
 
     /**
      * Convenience method for querying the database for a single integer result.
-     *
+     * 
      * @param query The raw SQL query to use.
      * @return The integer result of the query.
      */
@@ -180,7 +181,7 @@ public long queryLongScalar(String query, boolean throwException) throws SQLExce
     /**
      * Convenience method for querying the database for an entire column. The column will be returned as an ArrayList of
      * the specified class. See Deck.initUndo() for a usage example.
-     *
+     * 
      * @param type The class of the column's data type. Example: int.class, String.class.
      * @param query The SQL query statement.
      * @param column The column id in the result set to return.
@@ -220,7 +221,7 @@ public <T> ArrayList<T> queryColumn(Class<T> type, String query, int column) {
 
     /**
      * Mapping of Java type names to the corresponding Cursor.get method.
-     *
+     * 
      * @param typeName The simple name of the type's class. Example: String.class.getSimpleName().
      * @return The name of the Cursor method to be called.
      */
@@ -317,10 +318,11 @@ private void setWalJournalMode() {
         }
     }
 
+
     /**
      * Attempts to disable write ahead logging using a method on the {@link SQLiteDatabase} object.
-     *
-     * <p>The method might not exist (it is only included in API level 16) but we attempt anyway since it is part of
+     * <p>
+     * The method might not exist (it is only included in API level 16) but we attempt anyway since it is part of
      * present in a number of implementations.
      */
     private void disableWriteAheadLogging() {
diff --git a/src/com/ichi2/anki/AnkiDroidApp.java b/src/com/ichi2/anki/AnkiDroidApp.java
index 9e5f9c68721f..e359c56a71ae 100644
--- a/src/com/ichi2/anki/AnkiDroidApp.java
+++ b/src/com/ichi2/anki/AnkiDroidApp.java
@@ -77,14 +77,12 @@ public class AnkiDroidApp extends Application {
     private int mAccessThreadCount = 0;
     private static final Lock mLock = new ReentrantLock();
 
-
     /** Global hooks */
     private Hooks mHooks;
 
     /** Compatibility interface, Used to perform operation in a platform specific way. */
     private Compat mCompat;
 
-
     /**
      * The name of the shared preferences for this class, as supplied to
      * {@link Context#getSharedPreferences(String, int)}.
@@ -101,20 +99,19 @@ public class AnkiDroidApp extends Application {
     private static final int SWIPE_THRESHOLD_VELOCITY_DIP = 120;
 
     /**
-     * The latest package version number that included important changes to the database
-     * integrity check routine. All collections being upgraded to (or after) this version
-     * must run an integrity check as it will contain fixes that all collections should
-     * have.
+     * The latest package version number that included important changes to the database integrity check routine. All
+     * collections being upgraded to (or after) this version must run an integrity check as it will contain fixes that
+     * all collections should have.
      */
     public static final int CHECK_DB_AT_VERSION = 40;
 
     /**
-     * The latest package version number that included changes to the preferences
-     * that requires handling. All collections being upgraded to (or after) this version
-     * must update preferences.
+     * The latest package version number that included changes to the preferences that requires handling. All
+     * collections being upgraded to (or after) this version must update preferences.
      */
     public static final int CHECK_PREFERENCES_AT_VERSION = 20100108;
 
+
     /**
      * On application creation.
      */
@@ -175,20 +172,19 @@ public void onConfigurationChanged(Configuration newConfig) {
 
 
     private boolean isNookHdPlus() {
-        return android.os.Build.BRAND.equals("NOOK")
-                && android.os.Build.PRODUCT.equals("HDplus")
+        return android.os.Build.BRAND.equals("NOOK") && android.os.Build.PRODUCT.equals("HDplus")
                 && android.os.Build.DEVICE.equals("ovation");
     }
 
 
     private boolean isNook() {
-        return android.os.Build.MODEL.equalsIgnoreCase("nook")
-                || android.os.Build.DEVICE.equalsIgnoreCase("nook");
+        return android.os.Build.MODEL.equalsIgnoreCase("nook") || android.os.Build.DEVICE.equalsIgnoreCase("nook");
     }
 
 
     /**
      * Convenience method for accessing Shared preferences
+     * 
      * @param context Context to get preferences for.
      * @return A SharedPreferences object for this instance of the app.
      */
@@ -206,12 +202,14 @@ private static String getStorageDirectory() {
         return Environment.getExternalStorageDirectory().getAbsolutePath();
     }
 
+
     public static String getCacheStorageDirectory() {
         return sInstance.getCacheDir().getAbsolutePath();
     }
 
+
     public static String getCollectionPath() {
-    	return getCurrentAnkiDroidDirectory() + AnkiDroidApp.COLLECTION_PATH;
+        return getCurrentAnkiDroidDirectory() + AnkiDroidApp.COLLECTION_PATH;
     }
 
 
@@ -225,10 +223,12 @@ public static String getCurrentAnkiDroidDirectory() {
         return prefs.getString("deckPath", AnkiDroidApp.getDefaultAnkiDroidDirectory());
     }
 
+
     public static String getCurrentAnkiDroidMediaDir() {
         return getCurrentAnkiDroidDirectory() + File.separator + "collection.media";
     }
 
+
     public static void createDirectoryIfMissing(File decksDirectory) {
         if (!decksDirectory.isDirectory()) {
             decksDirectory.mkdirs();
@@ -280,7 +280,7 @@ public static int getDisplayWidth() {
 
     /**
      * Get package name as defined in the manifest.
-     *
+     * 
      * @return the package name.
      */
     public static String getAppName() {
@@ -300,7 +300,7 @@ public static String getAppName() {
 
     /**
      * Get the package versionName as defined in the manifest.
-     *
+     * 
      * @return the package version.
      */
     public static String getPkgVersionName() {
@@ -320,6 +320,7 @@ public static String getPkgVersionName() {
 
     /**
      * Get the package versionCode as defined in the manifest.
+     * 
      * @return
      */
     public static int getPkgVersionCode() {
@@ -336,7 +337,7 @@ public static int getPkgVersionCode() {
 
     /**
      * Get the DropBox folder
-     *
+     * 
      * @return the absolute path to the DropBox public folder, or null if it is not found
      */
     public static String getDropboxDir() {
@@ -355,7 +356,7 @@ public static void saveExceptionReportFile(Throwable e, String origin) {
 
     /**
      * Sets the user language.
-     *
+     * 
      * @param language The language to set
      * @return True if the language has changed, else false
      */
@@ -376,9 +377,10 @@ public static Hooks getHooks() {
         return sInstance.mHooks;
     }
 
+
     public static boolean initiateGestures(Context context, SharedPreferences preferences) {
-    	mGesturesEnabled = preferences.getBoolean("swipe", false);
-    	if (mGesturesEnabled && sSwipeMinDistance == -1) {
+        mGesturesEnabled = preferences.getBoolean("swipe", false);
+        if (mGesturesEnabled && sSwipeMinDistance == -1) {
             // Convert dip to pixel, code in parts from http://code.google.com/p/k9mail/
             final float gestureScale = context.getResources().getDisplayMetrics().density;
             int sensibility = preferences.getInt("swipeSensibility", 100);
@@ -392,68 +394,77 @@ public static boolean initiateGestures(Context context, SharedPreferences prefer
                 sSwipeThresholdVelocity = (int) (SWIPE_THRESHOLD_VELOCITY_DIP * gestureScale + 0.5f);
                 sSwipeMaxOffPath = (int) (SWIPE_MAX_OFF_PATH_DIP * gestureScale + 0.5f);
             }
-    	}
+        }
         return mGesturesEnabled;
     }
 
+
     public static Compat getCompat() {
         return sInstance.mCompat;
     }
 
+
     public static synchronized Collection openCollection(String path) {
-    	mLock.lock();
-    	Log.i(AnkiDroidApp.TAG, "openCollection: " + path);
+        mLock.lock();
+        Log.i(AnkiDroidApp.TAG, "openCollection: " + path);
         try {
-        	if (!colIsOpen() || !sInstance.mCurrentCollection.getPath().equals(path)) {
-        		if (colIsOpen()) {
-        			// close old collection prior to opening new one
-        			sInstance.mCurrentCollection.close();
-        			sInstance.mAccessThreadCount = 0;
-        		}
-        		sInstance.mCurrentCollection = Storage.Collection(path);
-        		sInstance.mAccessThreadCount++;
-        		Log.i(AnkiDroidApp.TAG, "Access to collection is requested: collection has been opened");
-        	} else {
-        		sInstance.mAccessThreadCount++;
-        		Log.i(AnkiDroidApp.TAG, "Access to collection is requested: collection has not been reopened (count: " + sInstance.mAccessThreadCount + ")");
-        	}
+            if (!colIsOpen() || !sInstance.mCurrentCollection.getPath().equals(path)) {
+                if (colIsOpen()) {
+                    // close old collection prior to opening new one
+                    sInstance.mCurrentCollection.close();
+                    sInstance.mAccessThreadCount = 0;
+                }
+                sInstance.mCurrentCollection = Storage.Collection(path);
+                sInstance.mAccessThreadCount++;
+                Log.i(AnkiDroidApp.TAG, "Access to collection is requested: collection has been opened");
+            } else {
+                sInstance.mAccessThreadCount++;
+                Log.i(AnkiDroidApp.TAG, "Access to collection is requested: collection has not been reopened (count: "
+                        + sInstance.mAccessThreadCount + ")");
+            }
             return sInstance.mCurrentCollection;
-		} finally {
-			mLock.unlock();
+        } finally {
+            mLock.unlock();
         }
     }
 
+
     public static Collection getCol() {
-    	return sInstance.mCurrentCollection;
+        return sInstance.mCurrentCollection;
     }
 
+
     public static void closeCollection(boolean save) {
-    	mLock.lock();
-    	Log.i(AnkiDroidApp.TAG, "closeCollection");
+        mLock.lock();
+        Log.i(AnkiDroidApp.TAG, "closeCollection");
         try {
             if (sInstance.mAccessThreadCount > 0) {
                 sInstance.mAccessThreadCount--;
             }
-            Log.i(AnkiDroidApp.TAG, "Access to collection jas been closed: (count: " + sInstance.mAccessThreadCount + ")");
+            Log.i(AnkiDroidApp.TAG, "Access to collection jas been closed: (count: " + sInstance.mAccessThreadCount
+                    + ")");
             if (sInstance.mAccessThreadCount == 0 && sInstance.mCurrentCollection != null) {
                 Collection col = sInstance.mCurrentCollection;
                 sInstance.mCurrentCollection = null;
                 col.close(save);
             }
         } finally {
-    		mLock.unlock();
-    	}
-
+            mLock.unlock();
+        }
 
     }
 
+
     public static boolean colIsOpen() {
-    	return sInstance.mCurrentCollection != null && sInstance.mCurrentCollection.getDb() != null && sInstance.mCurrentCollection.getDb().getDatabase() != null && sInstance.mCurrentCollection.getDb().getDatabase().isOpen();
+        return sInstance.mCurrentCollection != null && sInstance.mCurrentCollection.getDb() != null
+                && sInstance.mCurrentCollection.getDb().getDatabase() != null
+                && sInstance.mCurrentCollection.getDb().getDatabase().isOpen();
     }
 
+
     public static void resetAccessThreadCount() {
-    	sInstance.mAccessThreadCount = 0;
-    	sInstance.mCurrentCollection = null;
-		Log.i(AnkiDroidApp.TAG, "Access has been reset to 0");
+        sInstance.mAccessThreadCount = 0;
+        sInstance.mCurrentCollection = null;
+        Log.i(AnkiDroidApp.TAG, "Access has been reset to 0");
     }
 }
diff --git a/src/com/ichi2/anki/AnkiFont.java b/src/com/ichi2/anki/AnkiFont.java
index 012c33ce4fe2..30c392d2faa5 100644
--- a/src/com/ichi2/anki/AnkiFont.java
+++ b/src/com/ichi2/anki/AnkiFont.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.anki;
 
 import android.content.Context;
@@ -25,6 +26,7 @@ public class AnkiFont {
     private static final String fAssetPathPrefix = "/android_asset/fonts/";
     private static Set<String> corruptFonts = new HashSet<String>();
 
+
     private AnkiFont(String name, String family, List<String> attributes, String path) {
         mName = name;
         mFamily = family;
@@ -36,8 +38,8 @@ private AnkiFont(String name, String family, List<String> attributes, String pat
 
 
     /**
-     * Factory for AnkiFont creation.
-     * Creates a typeface wrapper from a font file representing.
+     * Factory for AnkiFont creation. Creates a typeface wrapper from a font file representing.
+     * 
      * @param ctx Activity context, needed to access assets
      * @param path Path to typeface file, needed when this is a custom font.
      * @param fromAssets True if the font is to be found in assets of application
@@ -102,11 +104,14 @@ public static AnkiFont createAnkiFont(Context ctx, String path, boolean fromAsse
         return createdFont;
     }
 
+
     public String getDeclaration() {
         StringBuilder sb = new StringBuilder("@font-face {");
         sb.append(getCSS()).append(" src: url(\"file://").append(mPath).append("\");}");
         return sb.toString();
     }
+
+
     public String getCSS() {
         StringBuilder sb = new StringBuilder("font-family: \"").append(mFamily);
         if (mIsOverride) {
@@ -121,18 +126,25 @@ public String getCSS() {
                     sb.deleteCharAt(sb.length() - 1);
                     sb.append(" !important;");
                 } else {
-                    Log.d(AnkiDroidApp.TAG, "AnkiFont.getCSS() - unable to set a font attribute important while override is set.");
+                    Log.d(AnkiDroidApp.TAG,
+                            "AnkiFont.getCSS() - unable to set a font attribute important while override is set.");
                 }
             }
         }
         return sb.toString();
     }
+
+
     public String getName() {
         return mName;
     }
+
+
     public String getPath() {
         return mPath;
     }
+
+
     public static Typeface getTypeface(Context ctx, String path) {
         try {
             if (path.startsWith(fAssetPathPrefix)) {
@@ -154,10 +166,14 @@ public static Typeface getTypeface(Context ctx, String path) {
             return null;
         }
     }
+
+
     private void setAsDefault() {
         mIsDefault = true;
         mIsOverride = false;
     }
+
+
     private void setAsOverride() {
         mIsOverride = true;
         mIsDefault = false;
diff --git a/src/com/ichi2/anki/BackupManager.java b/src/com/ichi2/anki/BackupManager.java
index 12d6a6e9b23e..633ccafb7e96 100644
--- a/src/com/ichi2/anki/BackupManager.java
+++ b/src/com/ichi2/anki/BackupManager.java
@@ -74,7 +74,8 @@ public static boolean isActivated() {
 
     private static File getBackupDirectory() {
         SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
-        File directory = new File(prefs.getString("deckPath", AnkiDroidApp.getCurrentAnkiDroidDirectory()) + BACKUP_SUFFIX);
+        File directory = new File(prefs.getString("deckPath", AnkiDroidApp.getCurrentAnkiDroidDirectory())
+                + BACKUP_SUFFIX);
         if (!directory.isDirectory()) {
             directory.mkdirs();
         }
@@ -84,7 +85,8 @@ private static File getBackupDirectory() {
 
     private static File getBrokenDirectory() {
         SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
-        File directory = new File(prefs.getString("deckPath", AnkiDroidApp.getCurrentAnkiDroidDirectory()) + BROKEN_DECKS_SUFFIX);
+        File directory = new File(prefs.getString("deckPath", AnkiDroidApp.getCurrentAnkiDroidDirectory())
+                + BROKEN_DECKS_SUFFIX);
         if (!directory.isDirectory()) {
             directory.mkdirs();
         }
@@ -317,7 +319,7 @@ public static boolean repairDeck(String deckPath) {
             process.waitFor();
 
             if (!new File(deckPath + ".tmp").exists()) {
-            	return false;
+                return false;
             }
 
             if (!moveDatabaseToBrokenFolder(deckPath, false)) {
@@ -377,7 +379,7 @@ public static boolean moveDatabaseToBrokenFolder(String colPath, boolean moveCon
     public static File[] getBackups(File colFile) {
         File[] files = getBackupDirectory().listFiles();
         if (files == null) {
-        	files = new File[0];
+            files = new File[0];
         }
         ArrayList<File> deckBackups = new ArrayList<File>();
         for (File aktFile : files) {
diff --git a/src/com/ichi2/anki/BroadcastMessages.java b/src/com/ichi2/anki/BroadcastMessages.java
index 82f53dfa92eb..8aa9e88286c6 100644
--- a/src/com/ichi2/anki/BroadcastMessages.java
+++ b/src/com/ichi2/anki/BroadcastMessages.java
@@ -70,7 +70,7 @@ private static int compareVersions(String ver1, String ver2) {
             try {
                 com = Integer.valueOf(version1[i]).compareTo(Integer.valueOf(version2[i]));
             } catch (NumberFormatException e) {
-            	// 1.0alpha4EXPERIMENTAL --> 1.0.alpha.EXPERIMENTAL
+                // 1.0alpha4EXPERIMENTAL --> 1.0.alpha.EXPERIMENTAL
                 String[] subVersion1 = version1[i].replaceAll("([:alpha:])[\\s|\\.|-]*([:digit:])", "$1.$2")
                         .replaceAll("([:digit:])[\\s|\\.|-]*([:alpha:])", "$1.$2").split("\\.");
                 String[] subVersion2 = version2[i].replaceAll("([:alpha:])[\\s|\\.|-]*([:digit:])", "$1.$2")
@@ -86,23 +86,23 @@ private static int compareVersions(String ver1, String ver2) {
                     }
                 }
                 if (subVersion1.length > subVersion2.length) {
-                	try {
-                		int test = Integer.valueOf(subVersion1[subVersion2.length]);
-                		// subversion of --> later
-                		return 1;
+                    try {
+                        int test = Integer.valueOf(subVersion1[subVersion2.length]);
+                        // subversion of --> later
+                        return 1;
                     } catch (NumberFormatException f) {
-                    	// not a number --> e.g. "EXPERIMENTAL" --> drop it
-                    	return -1;
-                	}
+                        // not a number --> e.g. "EXPERIMENTAL" --> drop it
+                        return -1;
+                    }
                 } else if (subVersion1.length < subVersion2.length) {
-                	try {
-                		int test = Integer.valueOf(subVersion2[subVersion1.length]);
-                		// subversion of --> later
-                		return -1;
+                    try {
+                        int test = Integer.valueOf(subVersion2[subVersion1.length]);
+                        // subversion of --> later
+                        return -1;
                     } catch (NumberFormatException f) {
-                    	// not a number --> e.g. "EXPERIMENTAL" --> drop it
-                    	return 1;
-                	}
+                        // not a number --> e.g. "EXPERIMENTAL" --> drop it
+                        return 1;
+                    }
                 }
             }
             if (com != 0) {
@@ -188,13 +188,15 @@ protected Context doInBackground(Activity... params) {
                         mMinVersion = getXmlValue(el, MIN_VERSION);
                         if (mMinVersion != null && mMinVersion.length() > 0
                                 && compareVersions(mMinVersion, currentVersion) > 0) {
-                            Log.i(AnkiDroidApp.TAG, "BroadcastMessage - too low AnkiDroid version (" + currentVersion + "), message " + mNum + " only for >= " + mMinVersion);
+                            Log.i(AnkiDroidApp.TAG, "BroadcastMessage - too low AnkiDroid version (" + currentVersion
+                                    + "), message " + mNum + " only for >= " + mMinVersion);
                             continue;
                         }
                         mMaxVersion = getXmlValue(el, MAX_VERSION);
                         if (mMaxVersion != null && mMaxVersion.length() > 0
                                 && compareVersions(mMaxVersion, currentVersion) < 0) {
-                            Log.i(AnkiDroidApp.TAG, "BroadcastMessage - too high AnkiDroid version (" + currentVersion + "), message " + mNum + " only for <= " + mMaxVersion);
+                            Log.i(AnkiDroidApp.TAG, "BroadcastMessage - too high AnkiDroid version (" + currentVersion
+                                    + "), message " + mNum + " only for <= " + mMaxVersion);
                             continue;
                         }
 
@@ -306,4 +308,3 @@ private static String getXmlValue(Element e, String tag) {
         return text;
     }
 }
-
diff --git a/src/com/ichi2/anki/CardBrowser.java b/src/com/ichi2/anki/CardBrowser.java
index c3e84ec920ab..612f64b3d1a9 100644
--- a/src/com/ichi2/anki/CardBrowser.java
+++ b/src/com/ichi2/anki/CardBrowser.java
@@ -130,7 +130,7 @@ public class CardBrowser extends ActionBarActivity implements ActionBar.OnNaviga
 
     // Should match order of R.array.card_browser_order_labels
     private static final int CARD_ORDER_NONE = 0;
-    private static final String[] fSortTypes = new String[]{
+    private static final String[] fSortTypes = new String[] {
         "",
         "noteFld",
         "noteCrt",
@@ -142,7 +142,8 @@ public class CardBrowser extends ActionBarActivity implements ActionBar.OnNaviga
         "cardReps",
         "cardLapses"};
     String[] mOrderByFields;
-    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings. Note: the last 6 are currently hidden
+    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings.
+    // Note: the last 6 are currently hidden
     private static final String[] COLUMN_KEYS = {"answer",
         "card",
         "deck",
@@ -156,7 +157,7 @@ public class CardBrowser extends ActionBarActivity implements ActionBar.OnNaviga
         "due",
         "ease",
         "edited",
-        "interval"};    
+        "interval"};
 
     private int[] mBackground;
 
@@ -182,9 +183,10 @@ public class CardBrowser extends ActionBarActivity implements ActionBar.OnNaviga
         public void onClick(DialogInterface dialog, int which) {
             switch (which) {
                 case CONTEXT_MENU_MARK:
-                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mUpdateCardHandler, new DeckTask.TaskData(
-                            mCol.getSched(), mCol.getCard(Long.parseLong(mCards.get(mPositionInCardsList).get("id"))),
-                            0));
+                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD,
+                            mUpdateCardHandler,
+                            new DeckTask.TaskData(mCol.getSched(), mCol.getCard(Long.parseLong(mCards.get(
+                                    mPositionInCardsList).get("id"))), 0));
                     return;
 
                 case CONTEXT_MENU_SUSPEND:
@@ -220,8 +222,7 @@ public void onClick(DialogInterface dialog, int which) {
                     Themes.htmlOkDialog(
                             CardBrowser.this,
                             getResources().getString(R.string.card_browser_card_details),
-                            CardStats.report(CardBrowser.this, tempCard, mCol))
-                            .show();
+                            CardStats.report(CardBrowser.this, tempCard, mCol)).show();
                     return;
             }
         }
@@ -246,7 +247,7 @@ protected void onCreate(Bundle savedInstanceState) {
         View mainView = getLayoutInflater().inflate(R.layout.card_browser, null);
         setContentView(mainView);
         Themes.setContentStyle(mainView, Themes.CALLER_CARDBROWSER);
-        // Try to load the collection 
+        // Try to load the collection
         mCol = AnkiDroidApp.getCol();
         if (mCol == null) {
             // Reload the collection asynchronously, let onPostExecute method call initActivity()
@@ -254,12 +255,13 @@ protected void onCreate(Bundle savedInstanceState) {
             return;
         } else {
             // If collection was not null then we can safely call initActivity() directly
-            initActivity(mCol);    
-        }        
+            initActivity(mCol);
+        }
     }
 
+
     // Finish initializing the activity after the collection has been correctly loaded
-    private void initActivity(Collection col){
+    private void initActivity(Collection col) {
 
         mDeckNames = new HashMap<String, String>();
         for (long did : mCol.getDecks().allIds()) {
@@ -314,7 +316,7 @@ private void initActivity(Collection col){
                 R.array.browser_column1_headings, android.R.layout.simple_spinner_item);
         column1Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
         mCardsColumn1Spinner.setAdapter(column1Adapter);
-        mCardsColumn1Spinner.setClickable(false);   // We disable and set plain background since it only has 1 item
+        mCardsColumn1Spinner.setClickable(false); // We disable and set plain background since it only has 1 item
         // Load default value for column2 selection
         mColumn2Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt("cardBrowserColumn2", 0);
         // Setup the column 2 heading as a spinner so that users can easily change the column type
@@ -331,12 +333,14 @@ public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
                 if (pos != mColumn2Index) {
                     mColumn2Index = pos;
                     AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
-                    .putInt("cardBrowserColumn2", mColumn2Index).commit();
+                            .putInt("cardBrowserColumn2", mColumn2Index).commit();
                     String[] fromMap = mCardsAdapter.getFromMapping();
                     fromMap[1] = COLUMN_KEYS[mColumn2Index];
                     mCardsAdapter.setFromMapping(fromMap);
                 }
             }
+
+
             @Override
             public void onNothingSelected(AdapterView<?> parent) {
                 // Do Nothing
@@ -356,7 +360,7 @@ public void onNothingSelected(AdapterView<?> parent) {
                 sflRelativeFontSize,
                 sflCustomFont);
         // link the adapter to the main mCardsListView
-        mCardsListView.setAdapter(mCardsAdapter);   
+        mCardsListView.setAdapter(mCardsAdapter);
         // set the spinner index
         mCardsColumn2Spinner.setSelection(mColumn2Index);
 
@@ -465,6 +469,8 @@ public boolean onCreateOptionsMenu(Menu menu) {
             public boolean onMenuItemActionExpand(MenuItem item) {
                 return true;
             }
+
+
             @Override
             public boolean onMenuItemActionCollapse(MenuItem item) {
                 // SearchView doesn't support empty queries
@@ -480,6 +486,8 @@ public boolean onMenuItemActionCollapse(MenuItem item) {
             public boolean onQueryTextChange(String newText) {
                 return true;
             }
+
+
             @Override
             public boolean onQueryTextSubmit(String query) {
                 onSearch();
@@ -577,42 +585,42 @@ protected Dialog onCreateDialog(int id) {
                 builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
                 builder.setSingleChoiceItems(res.getStringArray(R.array.card_browser_order_labels), mOrder,
                         new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface arg0, int which) {
-                        if (which != mOrder) {
-                            mOrder = which;
-                            mOrderAsc = false;
-                            try {
-                                if (mOrder == 0) {
-                                    mCol.getConf().put("sortType", fSortTypes[1]);
-                                    AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
-                                    .putBoolean("cardBrowserNoSorting", true).commit();
-                                } else {
-                                    mCol.getConf().put("sortType", fSortTypes[mOrder]);
-                                    AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
-                                    .putBoolean("cardBrowserNoSorting", false).commit();
-                                }
-                                // default to descending for non-text fields
-                                if (fSortTypes[mOrder].equals("noteFld")) {
-                                    mOrderAsc = true;
+                            @Override
+                            public void onClick(DialogInterface arg0, int which) {
+                                if (which != mOrder) {
+                                    mOrder = which;
+                                    mOrderAsc = false;
+                                    try {
+                                        if (mOrder == 0) {
+                                            mCol.getConf().put("sortType", fSortTypes[1]);
+                                            AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
+                                                    .putBoolean("cardBrowserNoSorting", true).commit();
+                                        } else {
+                                            mCol.getConf().put("sortType", fSortTypes[mOrder]);
+                                            AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
+                                                    .putBoolean("cardBrowserNoSorting", false).commit();
+                                        }
+                                        // default to descending for non-text fields
+                                        if (fSortTypes[mOrder].equals("noteFld")) {
+                                            mOrderAsc = true;
+                                        }
+                                        mCol.getConf().put("sortBackwards", mOrderAsc);
+                                    } catch (JSONException e) {
+                                        throw new RuntimeException(e);
+                                    }
+                                    searchCards();
+                                } else if (which != CARD_ORDER_NONE) {
+                                    mOrderAsc = !mOrderAsc;
+                                    try {
+                                        mCol.getConf().put("sortBackwards", mOrderAsc);
+                                    } catch (JSONException e) {
+                                        throw new RuntimeException(e);
+                                    }
+                                    Collections.reverse(mCards);
+                                    updateList();
                                 }
-                                mCol.getConf().put("sortBackwards", mOrderAsc);
-                            } catch (JSONException e) {
-                                throw new RuntimeException(e);
-                            }
-                            searchCards();
-                        } else if (which != CARD_ORDER_NONE) {
-                            mOrderAsc = !mOrderAsc;
-                            try {
-                                mCol.getConf().put("sortBackwards", mOrderAsc);
-                            } catch (JSONException e) {
-                                throw new RuntimeException(e);
                             }
-                            Collections.reverse(mCards);
-                            updateList();
-                        }
-                    }
-                });
+                        });
                 dialog = builder.create();
                 break;
 
@@ -787,47 +795,42 @@ private void searchCards() {
 
 
     private void reloadCollection() {
-        DeckTask.launchDeckTask(
-                DeckTask.TASK_TYPE_OPEN_COLLECTION,
-                new DeckTask.TaskListener() {
+        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, new DeckTask.TaskListener() {
 
-                    @Override
-                    public void onPostExecute(DeckTask.TaskData result) {
-                        if (mOpenCollectionDialog.isShowing()) {
-                            try {
-                                mOpenCollectionDialog.dismiss();
-                            } catch (Exception e) {
-                                Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
-                            }
-                        }
-                        mCol = result.getCollection();
-                        if (mCol == null) {
-                            finish();
-                        } else {
-                            initActivity(AnkiDroidApp.getCol());
-                        }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+                if (mOpenCollectionDialog.isShowing()) {
+                    try {
+                        mOpenCollectionDialog.dismiss();
+                    } catch (Exception e) {
+                        Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
                     }
+                }
+                mCol = result.getCollection();
+                if (mCol == null) {
+                    finish();
+                } else {
+                    initActivity(AnkiDroidApp.getCol());
+                }
+            }
 
 
-                    @Override
-                    public void onPreExecute() {
-                        mOpenCollectionDialog = StyledOpenCollectionDialog.show(
-                                CardBrowser.this,
-                                getResources().getString(R.string.open_collection),
-                                new OnCancelListener() {
-                                    @Override
-                                    public void onCancel(DialogInterface arg0) {
-                                        finish();
-                                    }
-                                });
-                    }
+            @Override
+            public void onPreExecute() {
+                mOpenCollectionDialog = StyledOpenCollectionDialog.show(CardBrowser.this,
+                        getResources().getString(R.string.open_collection), new OnCancelListener() {
+                            @Override
+                            public void onCancel(DialogInterface arg0) {
+                                finish();
+                            }
+                        });
+            }
 
 
-                    @Override
-                    public void onProgressUpdate(DeckTask.TaskData... values) {
-                    }
-                },
-                new DeckTask.TaskData(AnkiDroidApp.getCurrentAnkiDroidDirectory() + AnkiDroidApp.COLLECTION_PATH));
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            }
+        }, new DeckTask.TaskData(AnkiDroidApp.getCurrentAnkiDroidDirectory() + AnkiDroidApp.COLLECTION_PATH));
     }
 
 
@@ -897,23 +900,22 @@ private void deleteNote(Card card) {
         updateList();
     }
 
-
     private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
             Resources res = getResources();
-            if(mProgressDialog==null)
-                mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res.getString(R.string.saving_changes),
-                        true);
+            if (mProgressDialog == null)
+                mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "",
+                        res.getString(R.string.saving_changes), true);
         }
 
 
         @Override
         public void onProgressUpdate(DeckTask.TaskData... values) {
-            //            // Update list if search involved marked
-            //            if (fSearchMarkedPattern.matcher(mSearchTerms).find()) {
-            //                updateCardsList();
-            //            }
+            // // Update list if search involved marked
+            // if (fSearchMarkedPattern.matcher(mSearchTerms).find()) {
+            // updateCardsList();
+            // }
             updateCardInList(values[0].getCard(), values[0].getString());
         }
 
@@ -945,10 +947,10 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
             if (result.getBoolean()) {
-                //                // Update list if search on suspended
-                //                if (fSearchSuspendedPattern.matcher(mSearchTerms).find()) {
-                //                    updateCardsList();
-                //                }
+                // // Update list if search on suspended
+                // if (fSearchSuspendedPattern.matcher(mSearchTerms).find()) {
+                // updateCardsList();
+                // }
                 updateCardInList(mCol.getCard(Long.parseLong(mCards.get(mPositionInCardsList).get("id"))), null);
             } else {
                 closeCardBrowser(DeckPicker.RESULT_DB_ERROR);
@@ -991,7 +993,7 @@ public void onProgressUpdate(TaskData... values) {
         @Override
         public void onPreExecute() {
             Resources res = getResources();
-            if(mProgressDialog==null){
+            if (mProgressDialog == null) {
                 mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "",
                         res.getString(R.string.card_browser_filtering_cards), true);
             } else {
@@ -1012,7 +1014,7 @@ public void onPostExecute(TaskData result) {
             }
             // After the initial searchCards query, start rendering the question and answer in the background
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA, mRenderQAHandler, new DeckTask.TaskData(
-                    new Object[] { mCol, mCards}));            
+                    new Object[] { mCol, mCards }));
         }
     };
 
@@ -1022,13 +1024,15 @@ public void onProgressUpdate(TaskData... values) {
             mCardsAdapter.notifyDataSetChanged();
         }
 
+
         @Override
         public void onPreExecute() {
         }
 
+
         @Override
         public void onPostExecute(TaskData result) {
-            if (result!=null){
+            if (result != null) {
                 Log.i(AnkiDroidApp.TAG, "Completed doInBackgroundRenderBrowserQA Successfuly");
             } else {
                 // Might want to do something more proactive here like show a message box?
@@ -1106,7 +1110,6 @@ private void closeCardBrowser(int result) {
         ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
     }
 
-
     private final class MultiColumnListAdapter extends BaseAdapter {
         private ArrayList<HashMap<String, String>> mData;
         private final int mResource;
@@ -1120,7 +1123,7 @@ private final class MultiColumnListAdapter extends BaseAdapter {
 
 
         public MultiColumnListAdapter(Context context, ArrayList<HashMap<String, String>> data, int resource,
-                String[] from, int[] to, String colorFlagKey, int fontSizeScalePcent, String customFont) {            
+                String[] from, int[] to, String colorFlagKey, int fontSizeScalePcent, String customFont) {
             mData = data;
             mResource = resource;
             mFromKeys = from;
@@ -1136,15 +1139,15 @@ public MultiColumnListAdapter(Context context, ArrayList<HashMap<String, String>
 
         public View getView(int position, View convertView, ViewGroup parent) {
             // Get the main container view if it doesn't already exist, and call bindView
-            View v;            
-            if (convertView == null){
+            View v;
+            if (convertView == null) {
                 v = mInflater.inflate(mResource, parent, false);
                 final int count = mToIds.length;
                 final View[] columns = new View[count];
                 for (int i = 0; i < count; i++) {
                     columns[i] = v.findViewById(mToIds[i]);
                 }
-                v.setTag(columns);                
+                v.setTag(columns);
             } else {
                 v = convertView;
             }
@@ -1152,6 +1155,7 @@ public View getView(int position, View convertView, ViewGroup parent) {
             return v;
         }
 
+
         private void bindView(int position, View v) {
             // Draw the content in the columns
             View[] columns = (View[]) v.getTag();
@@ -1165,9 +1169,10 @@ private void bindView(int position, View v) {
                 col.setBackgroundResource(mBackground[color]);
                 // set text for column
                 col.setText(dataSet.get(mFromKeys[i]));
-            }           
+            }
         }
 
+
         private void setFont(TextView v) {
             // Set the font and font size for a TextView v
             float currentSize = v.getTextSize();
@@ -1184,7 +1189,8 @@ private void setFont(TextView v) {
             }
         }
 
-        private int getColor(String flag){
+
+        private int getColor(String flag) {
             int which = BACKGROUND_NORMAL;
             if (flag.equals("1")) {
                 which = BACKGROUND_SUSPENDED;
@@ -1192,18 +1198,21 @@ private int getColor(String flag){
                 which = BACKGROUND_MARKED;
             } else if (flag.equals("3")) {
                 which = BACKGROUND_MARKED_SUSPENDED;
-            }            
+            }
             return which;
         }
 
-        public void setFromMapping(String[] from){
+
+        public void setFromMapping(String[] from) {
             mFromKeys = from;
             notifyDataSetChanged();
         }
 
-        public String[] getFromMapping(){
+
+        public String[] getFromMapping() {
             return mFromKeys;
-        }        
+        }
+
 
         @Override
         public int getCount() {
@@ -1223,22 +1232,24 @@ public long getItemId(int position) {
         }
     }
 
-
     private final class DeckDropDownAdapter extends BaseAdapter {
 
         private Context context;
         private ArrayList<JSONObject> decks;
 
+
         public DeckDropDownAdapter(Context context, ArrayList<JSONObject> decks) {
             this.context = context;
             this.decks = decks;
         }
 
+
         @Override
         public int getCount() {
             return decks.size() + 1;
         }
 
+
         @Override
         public Object getItem(int position) {
             if (position == 0) {
@@ -1248,11 +1259,13 @@ public Object getItem(int position) {
             }
         }
 
+
         @Override
         public long getItemId(int position) {
             return position;
         }
 
+
         @Override
         public View getView(int position, View convertView, ViewGroup parent) {
             TextView deckNameView;
diff --git a/src/com/ichi2/anki/CardEditor.java b/src/com/ichi2/anki/CardEditor.java
index 2987a82a473c..8bf949a082db 100644
--- a/src/com/ichi2/anki/CardEditor.java
+++ b/src/com/ichi2/anki/CardEditor.java
@@ -299,21 +299,22 @@ protected void onCreate(Bundle savedInstanceState) {
                     mCaller = CALLER_INDICLASH;
                 }
             }
-        }        
+        }
         // Try to load the collection
         mCol = AnkiDroidApp.getCol();
         if (mCol == null) {
-            // Reload the collection asynchronously, let onPostExecute method call initActivity()            
+            // Reload the collection asynchronously, let onPostExecute method call initActivity()
             reloadCollection();
             return;
         } else {
-            // If collection was not null then we can safely call initActivity() directly            
+            // If collection was not null then we can safely call initActivity() directly
             initActivity(mCol);
         }
     }
 
-    // Finish initializing the activity after the collection has been correctly loaded    
-    private void initActivity(Collection col){
+
+    // Finish initializing the activity after the collection has been correctly loaded
+    private void initActivity(Collection col) {
         this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
 
         Intent intent = getIntent();
@@ -329,7 +330,7 @@ private void initActivity(Collection col){
                     + getResources().getString(R.string.CardEditorLaterMessage), false);
             finish();
             return;
-        }        
+        }
 
         registerExternalStorageListener();
 
@@ -532,7 +533,7 @@ public void onClick(View v) {
                 closeCardEditor();
             }
 
-        });        
+        });
     }
 
 
@@ -578,6 +579,7 @@ private void fetchIntentInformation(Intent intent) {
         }
     }
 
+
     private void openReviewer() {
         Intent reviewer = new Intent(CardEditor.this, Previewer.class);
         startActivity(reviewer);
@@ -609,11 +611,11 @@ public void onPostExecute(DeckTask.TaskData result) {
             public void onPreExecute() {
                 mOpenCollectionDialog = StyledOpenCollectionDialog.show(CardEditor.this,
                         getResources().getString(R.string.open_collection), new OnCancelListener() {
-                    @Override
-                    public void onCancel(DialogInterface arg0) {
-                        finish();
-                    }
-                });
+                            @Override
+                            public void onCancel(DialogInterface arg0) {
+                                finish();
+                            }
+                        });
             }
 
 
@@ -664,12 +666,12 @@ private void resetEditFields(String[] content) {
 
 
     private void saveNote() {
-        // treat add new note and edit existing note independently 
+        // treat add new note and edit existing note independently
         if (mAddNote) {
             // load all of the fields into the note
             for (FieldEditText f : mEditFields) {
                 f.updateField();
-            }            
+            }
             try {
                 // Save deck to model
                 mEditorNote.model().put("did", mCurrentDid);
@@ -688,7 +690,7 @@ private void saveNote() {
         } else {
             boolean modified = false;
             // changed did? this has to be done first as remFromDyn() involves a direct write to the database
-            if (mCurrentEditedCard.getDid() != mCurrentDid){
+            if (mCurrentEditedCard.getDid() != mCurrentDid) {
                 // remove card from filtered deck first (if relevant)
                 AnkiDroidApp.getCol().getSched().remFromDyn(new long[] { mCurrentEditedCard.getId() });
                 // refresh the card object to reflect the database changes in remFromDyn()
@@ -702,7 +704,7 @@ private void saveNote() {
             // now load any changes to the fields from the form
             for (FieldEditText f : mEditFields) {
                 modified = modified | f.updateField();
-            }            
+            }
             // added tag?
             for (String t : mCurrentTags) {
                 modified = modified || !mEditorNote.hasTag(t);
@@ -711,7 +713,8 @@ private void saveNote() {
             modified = modified || mEditorNote.getTags().size() > mCurrentTags.size();
             if (modified) {
                 mEditorNote.setTagsFromStr(tagsAsString(mCurrentTags));
-                // set a flag so that changes to card object will be written to DB later via onActivityResult() in CardBrowser
+                // set a flag so that changes to card object will be written to DB later via onActivityResult() in
+                // CardBrowser
                 mChanged = true;
             }
             closeCardEditor();
@@ -920,18 +923,22 @@ public void onDismiss(DialogInterface dialog) {
                         mNewTagEditText.setText("");
                     }
                 });
-                
+
                 mNewTagEditText = new EditText(this);
                 mNewTagEditText.setHint(R.string.add_new_filter_tags);
-                
+
                 mNewTagEditText.addTextChangedListener(new TextWatcher() {
                     @Override
                     public void onTextChanged(CharSequence s, int start, int before, int count) {
                         mTagsDialog.filterList(s.toString());
                     }
+
+
                     @Override
                     public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                     }
+
+
                     @Override
                     public void afterTextChanged(Editable s) {
                     }
@@ -985,7 +992,7 @@ public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                         mCurrentTags = mTagsDialog.getCheckedItems();
                     }
                 });
-                
+
                 dialog = builder.create();
                 mTagsDialog = dialog;
                 break;
@@ -1204,7 +1211,7 @@ protected void onPrepareDialog(int id, Dialog dialog) {
                 if (mSelectedTags == null) {
                     mSelectedTags = new ArrayList<String>();
                 }
-                mCurrentTags = new ArrayList<String>(mSelectedTags);                
+                mCurrentTags = new ArrayList<String>(mSelectedTags);
                 actualizeTagDialog(ad);
                 break;
 
@@ -1259,13 +1266,13 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 
 
     private void actualizeTagDialog(StyledDialog ad) {
-        //without this the dialog goes up the screen in a way that the user isn't able to see the full item list.
+        // without this the dialog goes up the screen in a way that the user isn't able to see the full item list.
         ad.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
         TreeSet<String> tags = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
         for (String tag : mCol.getTags().all()) {
             tags.add(tag);
         }
-        
+
         tags.addAll(mCurrentTags);
         int len = tags.size();
         allTags = new String[len];
@@ -1341,7 +1348,8 @@ private void swapText(boolean reset) {
         if (targetText != null) {
             mEditFields.get(mTargetPosition).setText(targetText);
         }
-    }   
+    }
+
 
     private void populateEditFields() {
         mFieldsLayoutContainer.removeAllViews();
@@ -1479,7 +1487,7 @@ private void updateDeck() {
         try {
             mDeckButton.setText(getResources().getString(
                     mAddNote ? R.string.CardEditorNoteDeck : R.string.CardEditorCardDeck,
-                            mCol.getDecks().get(mCurrentDid).getString("name")));
+                    mCol.getDecks().get(mCurrentDid).getString("name")));
         } catch (NotFoundException e) {
             throw new RuntimeException(e);
         } catch (JSONException e) {
diff --git a/src/com/ichi2/anki/CramDeckOptions.java b/src/com/ichi2/anki/CramDeckOptions.java
index 8a55bebe559a..f1b368efb999 100644
--- a/src/com/ichi2/anki/CramDeckOptions.java
+++ b/src/com/ichi2/anki/CramDeckOptions.java
@@ -110,6 +110,7 @@ public class Editor implements SharedPreferences.Editor {
 
             private ContentValues mUpdate = new ContentValues();
 
+
             @Override
             public SharedPreferences.Editor clear() {
                 Log.d(AnkiDroidApp.TAG, "clear()");
@@ -414,6 +415,7 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         return super.onKeyDown(keyCode, event);
     }
 
+
     @Override
     protected void onDestroy() {
         super.onDestroy();
@@ -422,6 +424,7 @@ protected void onDestroy() {
         }
     }
 
+
     protected void updateSummaries() {
         mAllowCommit = false;
         // for all text preferences, set summary as current database value
@@ -470,7 +473,6 @@ protected void buildLists() {
         }
     }
 
-
     public class JSONNameComparator implements Comparator<JSONObject> {
         @Override
         public int compare(JSONObject lhs, JSONObject rhs) {
@@ -486,6 +488,7 @@ public int compare(JSONObject lhs, JSONObject rhs) {
         }
     }
 
+
     /**
      * finish when sd card is ejected
      */
diff --git a/src/com/ichi2/anki/DeckOptions.java b/src/com/ichi2/anki/DeckOptions.java
index 42fb3324f2fc..60c6f968faa0 100644
--- a/src/com/ichi2/anki/DeckOptions.java
+++ b/src/com/ichi2/anki/DeckOptions.java
@@ -75,10 +75,12 @@ public class DeckPreferenceHack implements SharedPreferences {
         private Map<String, String> mSummaries = new HashMap<String, String>();
         private StyledProgressDialog mProgressDialog;
 
+
         public DeckPreferenceHack() {
             this.cacheValues();
         }
 
+
         protected void cacheValues() {
             Log.i(AnkiDroidApp.TAG, "DeckOptions - CacheValues");
 
@@ -119,8 +121,8 @@ protected void cacheValues() {
                 // options group management
                 mValues.put("currentConf", mCol.getDecks().getConf(mDeck.getLong("conf")).getString("name"));
             } catch (JSONException e) {
-            	addMissingValues();
-            	finish();
+                addMissingValues();
+                finish();
             }
         }
 
@@ -128,6 +130,7 @@ public class Editor implements SharedPreferences.Editor {
 
             private ContentValues mUpdate = new ContentValues();
 
+
             @Override
             public SharedPreferences.Editor clear() {
                 Log.d(AnkiDroidApp.TAG, "clear()");
@@ -142,7 +145,7 @@ public boolean commit() {
 
                 try {
                     for (Entry<String, Object> entry : mUpdate.valueSet()) {
-                        String key =  entry.getKey();
+                        String key = entry.getKey();
                         Object value = entry.getValue();
                         Log.i(AnkiDroidApp.TAG, "Change value for key '" + key + "': " + value);
 
@@ -157,18 +160,18 @@ public boolean commit() {
                             if (oldValue != newValue) {
                                 mOptions.getJSONObject("new").put("order", newValue);
                                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REORDER, mConfChangeHandler,
-                                        new DeckTask.TaskData(new Object[]{mCol, mOptions}));
+                                        new DeckTask.TaskData(new Object[] { mCol, mOptions }));
                             }
                             mOptions.getJSONObject("new").put("order", Integer.parseInt((String) value));
                         } else if (key.equals("newPerDay")) {
                             mOptions.getJSONObject("new").put("perDay", (Integer) value);
                         } else if (key.equals("newGradIvl")) {
-                            JSONArray ja = new JSONArray(); //[graduating, easy]
+                            JSONArray ja = new JSONArray(); // [graduating, easy]
                             ja.put((Integer) value);
                             ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(1));
                             mOptions.getJSONObject("new").put("ints", ja);
                         } else if (key.equals("newEasy")) {
-                            JSONArray ja = new JSONArray(); //[graduating, easy]
+                            JSONArray ja = new JSONArray(); // [graduating, easy]
                             ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(0));
                             ja.put((Integer) value);
                             mOptions.getJSONObject("new").put("ints", ja);
@@ -209,12 +212,13 @@ public boolean commit() {
                         } else if (key.equals("newSteps")) {
                             mOptions.getJSONObject("new").put("delays", StepsPreference.convertToJSON((String) value));
                         } else if (key.equals("lapSteps")) {
-                            mOptions.getJSONObject("lapse").put("delays", StepsPreference.convertToJSON((String) value));
+                            mOptions.getJSONObject("lapse")
+                                    .put("delays", StepsPreference.convertToJSON((String) value));
                         } else if (key.equals("deckConf")) {
                             long newConfId = Long.parseLong((String) value);
                             mOptions = mCol.getDecks().getConf(newConfId);
                             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_CHANGE, mConfChangeHandler,
-                                    new DeckTask.TaskData(new Object[]{mCol, mDeck, mOptions}));
+                                    new DeckTask.TaskData(new Object[] { mCol, mDeck, mOptions }));
                         } else if (key.equals("confRename")) {
                             String newName = (String) value;
                             if (!TextUtils.isEmpty(newName)) {
@@ -223,7 +227,7 @@ public boolean commit() {
                         } else if (key.equals("confReset")) {
                             if ((Boolean) value) {
                                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_RESET, mConfChangeHandler,
-                                        new DeckTask.TaskData(new Object[]{mCol, mOptions}));
+                                        new DeckTask.TaskData(new Object[] { mCol, mOptions }));
                             }
                         } else if (key.equals("confAdd")) {
                             String newName = (String) value;
@@ -239,13 +243,13 @@ public boolean commit() {
                                         getResources().getString(R.string.default_conf_delete_error), false);
                             } else {
                                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_REMOVE, mConfChangeHandler,
-                                        new DeckTask.TaskData(new Object[]{mCol, mOptions}));
+                                        new DeckTask.TaskData(new Object[] { mCol, mOptions }));
                                 mDeck.put("conf", 1);
                             }
                         } else if (key.equals("confSetSubdecks")) {
                             if ((Boolean) value) {
                                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_SET_SUBDECKS, mConfChangeHandler,
-                                        new DeckTask.TaskData(new Object[]{mCol, mDeck, mOptions}));
+                                        new DeckTask.TaskData(new Object[] { mCol, mDeck, mOptions }));
                             }
                         }
                     }
@@ -490,6 +494,7 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         return super.onKeyDown(keyCode, event);
     }
 
+
     @Override
     protected void onDestroy() {
         super.onDestroy();
@@ -498,6 +503,7 @@ protected void onDestroy() {
         }
     }
 
+
     protected void updateSummaries() {
         Resources res = getResources();
         // for all text preferences, set summary as current database value
@@ -506,8 +512,7 @@ protected void updateSummaries() {
             if (key.equals("deckConf")) {
                 String groupName = getOptionsGroupName();
                 int count = getOptionsGroupCount();
-                pref.setSummary(res.getQuantityString(R.plurals.deck_conf_group_summ,
-                        count, groupName, count));
+                pref.setSummary(res.getQuantityString(R.plurals.deck_conf_group_summ, count, groupName, count));
                 continue;
             }
 
@@ -536,8 +541,8 @@ protected void updateSummaries() {
         }
         // Update summaries of preference items that don't have values (aren't in mValues)
         int subDeckCount = getSubdeckCount();
-        this.findPreference("confSetSubdecks").setSummary(res.getQuantityString(
-                R.plurals.deck_conf_set_subdecks_summ, subDeckCount, subDeckCount));
+        this.findPreference("confSetSubdecks").setSummary(
+                res.getQuantityString(R.plurals.deck_conf_set_subdecks_summ, subDeckCount, subDeckCount));
     }
 
 
@@ -572,9 +577,6 @@ protected void buildLists() {
     }
 
 
-
-
-
     /**
      * Returns the number of decks using the options group of the current deck.
      */
@@ -596,6 +598,7 @@ private int getOptionsGroupCount() {
         return count;
     }
 
+
     /**
      * Get the name of the currently set options group
      */
@@ -608,6 +611,7 @@ private String getOptionsGroupName() {
         }
     }
 
+
     /**
      * Get the number of (non-dynamic) subdecks for the current deck
      */
@@ -644,6 +648,7 @@ public int compare(JSONObject lhs, JSONObject rhs) {
         }
     }
 
+
     /**
      * finish when sd card is ejected
      */
@@ -663,18 +668,19 @@ public void onReceive(Context context, Intent intent) {
         }
     }
 
+
     private void addMissingValues() {
-    	try {
-    		for (JSONObject o : mCol.getDecks().all()) {
-    			JSONObject conf = mCol.getDecks().confForDid(o.getLong("id"));
-    			if (!conf.has("replayq")) {
-    				conf.put("replayq", true);
-					mCol.getDecks().save(conf);
-    			}
-    		}
-		} catch (JSONException e1) {
-			// nothing
-		}
+        try {
+            for (JSONObject o : mCol.getDecks().all()) {
+                JSONObject conf = mCol.getDecks().confForDid(o.getLong("id"));
+                if (!conf.has("replayq")) {
+                    conf.put("replayq", true);
+                    mCol.getDecks().save(conf);
+                }
+            }
+        } catch (JSONException e1) {
+            // nothing
+        }
     }
 
 }
diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index 4e37cd399097..0c45410027aa 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -482,8 +482,7 @@ public void onPostExecute(Payload data) {
                                     break;
                             }
                         } else if (result[0] instanceof String) {
-                            mDialogMessage = res.getString(R.string.sync_log_error_specific,
-                                    -1, (String) result[0]);
+                            mDialogMessage = res.getString(R.string.sync_log_error_specific, -1, (String) result[0]);
                         } else {
                             mDialogMessage = res.getString(R.string.sync_generic_error);
                         }
@@ -494,7 +493,8 @@ public void onPostExecute(Payload data) {
                 updateDecksList((TreeSet<Object[]>) data.result, (Integer) data.data[2], (Integer) data.data[3]);
                 if (data.data[4] != null) {
                     mDialogMessage = (String) data.data[4];
-                } else if (data.data.length > 0 && data.data[0] instanceof String && ((String) data.data[0]).length() > 0) {
+                } else if (data.data.length > 0 && data.data[0] instanceof String
+                        && ((String) data.data[0]).length() > 0) {
                     String dataString = (String) data.data[0];
                     if (dataString.equals("upload")) {
                         mDialogMessage = res.getString(R.string.sync_log_uploading_message);
@@ -528,7 +528,6 @@ public void onPostExecute(Payload data) {
         }
     };
 
-
     DeckTask.TaskListener mOpenCollectionHandler = new DeckTask.TaskListener() {
 
         @Override
@@ -562,15 +561,16 @@ public void onPostExecute(DeckTask.TaskData result) {
         @Override
         public void onPreExecute() {
             if (mOpenCollectionDialog == null || !mOpenCollectionDialog.isShowing()) {
-                mOpenCollectionDialog = StyledOpenCollectionDialog.show(DeckPicker.this, getResources().getString(R.string.open_collection), new OnCancelListener() {
+                mOpenCollectionDialog = StyledOpenCollectionDialog.show(DeckPicker.this,
+                        getResources().getString(R.string.open_collection), new OnCancelListener() {
 
-                    @Override
-                    public void onCancel(DialogInterface arg0) {
-                        // TODO: close dbs?
-                        DeckTask.cancelTask();
-                        finishWithAnimation();
-                    }
-                });
+                            @Override
+                            public void onCancel(DialogInterface arg0) {
+                                // TODO: close dbs?
+                                DeckTask.cancelTask();
+                                finishWithAnimation();
+                            }
+                        });
             }
             if (mNotMountedDialog != null && mNotMountedDialog.isShowing()) {
                 try {
@@ -610,7 +610,7 @@ public void onPostExecute(DeckTask.TaskData result) {
                     setSelectedDeck(AnkiDroidApp.getCol().getDecks().current().getLong("id"));
                 }
             } catch (JSONException e) {
-                throw  new RuntimeException();
+                throw new RuntimeException();
             }
         }
 
@@ -709,43 +709,45 @@ public void onProgressUpdate(TaskData... values) {
 
     };
 
+    DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {
+
+        @Override
+        public void onPreExecute() {
+            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
+                    getResources().getString(R.string.backup_restore_deck), true);
+        }
+
+
+        @Override
+        public void onPostExecute(DeckTask.TaskData result) {
+            switch (result.getInt()) {
+                case BackupManager.RETURN_DECK_RESTORED:
+                    loadCollection();
+                    Collection col = AnkiDroidApp.getCol();
+                    if (col != null) {
+                        col.modSchema(false);
+                    }
+                    break;
+                case BackupManager.RETURN_ERROR:
+                    Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_restore_error),
+                            true);
+                    showDialog(DIALOG_ERROR_HANDLING);
+                    break;
+                case BackupManager.RETURN_NOT_ENOUGH_SPACE:
+                    showDialog(DIALOG_NO_SPACE_LEFT);
+                    break;
+            }
+            if (mProgressDialog != null && mProgressDialog.isShowing()) {
+                mProgressDialog.dismiss();
+            }
+        }
+
 
-     DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {
-
-     @Override
-     public void onPreExecute() {
-         mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources().getString(R.string.backup_restore_deck), true);
-     }
-
-
-     @Override
-     public void onPostExecute(DeckTask.TaskData result) {
-         switch (result.getInt()) {
-         case BackupManager.RETURN_DECK_RESTORED:
-             loadCollection();
-             Collection col = AnkiDroidApp.getCol();
-             if (col != null) {
-                 col.modSchema(false);
-             }
-             break;
-         case BackupManager.RETURN_ERROR:
-             Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_restore_error), true);
-             showDialog(DIALOG_ERROR_HANDLING);
-             break;
-         case BackupManager.RETURN_NOT_ENOUGH_SPACE:
-             showDialog(DIALOG_NO_SPACE_LEFT);
-             break;
-         }
-         if (mProgressDialog != null && mProgressDialog.isShowing()) {
-             mProgressDialog.dismiss();
-         }
-     }
-
-     @Override
-     public void onProgressUpdate(TaskData... values) {
-     }
-
-     };
+        @Override
+        public void onProgressUpdate(TaskData... values) {
+        }
+
+    };
 
     DeckTask.TaskListener mImportAddListener = new DeckTask.TaskListener() {
         @Override
@@ -773,14 +775,18 @@ public void onPostExecute(DeckTask.TaskData result) {
                 handleDbError();
             }
         }
+
+
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = StyledProgressDialog
-                        .show(DeckPicker.this, getResources().getString(R.string.import_title),
-                                getResources().getString(R.string.import_importing), true, false);
+                mProgressDialog = StyledProgressDialog.show(DeckPicker.this,
+                        getResources().getString(R.string.import_title),
+                        getResources().getString(R.string.import_importing), true, false);
             }
         }
+
+
         @Override
         public void onProgressUpdate(DeckTask.TaskData... values) {
             mProgressDialog.setMessage(values[0].getString());
@@ -809,14 +815,18 @@ public void onPostExecute(DeckTask.TaskData result) {
                 showDialog(DIALOG_IMPORT_LOG);
             }
         }
+
+
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = StyledProgressDialog
-                        .show(DeckPicker.this, getResources().getString(R.string.import_title),
-                                getResources().getString(R.string.import_importing), true, false);
+                mProgressDialog = StyledProgressDialog.show(DeckPicker.this,
+                        getResources().getString(R.string.import_title),
+                        getResources().getString(R.string.import_importing), true, false);
             }
         }
+
+
         @Override
         public void onProgressUpdate(DeckTask.TaskData... values) {
             mProgressDialog.setMessage(values[0].getString());
@@ -827,11 +837,12 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = StyledProgressDialog
-                        .show(DeckPicker.this, getString(R.string.export_progress_title),
-                                getString(R.string.export_progress_exporting), true, false);
+                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, getString(R.string.export_progress_title),
+                        getString(R.string.export_progress_exporting), true, false);
             }
         }
+
+
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
             if (mProgressDialog != null && mProgressDialog.isShowing()) {
@@ -850,8 +861,8 @@ public void onPostExecute(DeckTask.TaskData result) {
                 builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
-                        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext())
-                                .edit().putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
+                        AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+                                .putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
                     }
                 });
             }
@@ -859,17 +870,21 @@ public void onClick(DialogInterface dialog, int which) {
                 @Override
                 public void onClick(DialogInterface dialog, int which) {
                     showUpgradeScreen(true, Info.UPGRADE_SCREEN_BASIC1);
-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext())
-                            .edit().putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
+                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+                            .putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
                 }
             });
             dialog = builder.create();
             dialog.show();
         }
+
+
         @Override
-        public void onProgressUpdate(TaskData... values) { }
+        public void onProgressUpdate(TaskData... values) {
+        }
     };
 
+
     // ----------------------------------------------------------------------------
     // ANDROID METHODS
     // ----------------------------------------------------------------------------
@@ -880,7 +895,8 @@ protected void onCreate(Bundle savedInstanceState) throws SQLException {
         Log.i(AnkiDroidApp.TAG, "DeckPicker - onCreate");
         Intent intent = getIntent();
         if (!isTaskRoot()) {
-            Log.i(AnkiDroidApp.TAG, "DeckPicker - onCreate: Detected multiple instance of this activity, closing it and return to root activity");
+            Log.i(AnkiDroidApp.TAG,
+                    "DeckPicker - onCreate: Detected multiple instance of this activity, closing it and return to root activity");
             Intent reloadIntent = new Intent(DeckPicker.this, DeckPicker.class);
             reloadIntent.setAction(Intent.ACTION_MAIN);
             if (intent != null && intent.getExtras() != null) {
@@ -931,7 +947,8 @@ protected void onCreate(Bundle savedInstanceState) throws SQLException {
         View studyoptionsFrame = findViewById(R.id.studyoptions_fragment);
         mFragmented = studyoptionsFrame != null && studyoptionsFrame.getVisibility() == View.VISIBLE;
 
-        Themes.setContentStyle(mFragmented ? mainView : mainView.findViewById(R.id.deckpicker_view), Themes.CALLER_DECKPICKER);
+        Themes.setContentStyle(mFragmented ? mainView : mainView.findViewById(R.id.deckpicker_view),
+                Themes.CALLER_DECKPICKER);
 
         registerExternalStorageListener();
 
@@ -995,47 +1012,44 @@ public boolean setViewValue(View view, Object data, String text) {
                     }
                 } else if (view.getId() == R.id.deckpicker_new) {
                     // Set the right color, light gray or blue.
-                    ((TextView) view).setTextColor(
-                            (text.equals("0")) ? getResources().getColor(R.color.zero_count) :
-                            getResources().getColor(R.color.new_count));
-                    return false;  // Let SimpleAdapter take care of binding the number to the TextView.
+                    ((TextView) view).setTextColor((text.equals("0")) ? getResources().getColor(R.color.zero_count)
+                            : getResources().getColor(R.color.new_count));
+                    return false; // Let SimpleAdapter take care of binding the number to the TextView.
                 } else if (view.getId() == R.id.deckpicker_lrn) {
                     // ... or red.
-                    ((TextView) view).setTextColor(
-                            (text.equals("0")) ? getResources().getColor(R.color.zero_count) :
-                            getResources().getColor(R.color.learn_count));
+                    ((TextView) view).setTextColor((text.equals("0")) ? getResources().getColor(R.color.zero_count)
+                            : getResources().getColor(R.color.learn_count));
                     return false;
                 } else if (view.getId() == R.id.deckpicker_rev) {
                     // ... or green.
-                    ((TextView) view).setTextColor(
-                            (text.equals("0")) ? getResources().getColor(R.color.zero_count) :
-                            getResources().getColor(R.color.review_count));
+                    ((TextView) view).setTextColor((text.equals("0")) ? getResources().getColor(R.color.zero_count)
+                            : getResources().getColor(R.color.review_count));
                     return false;
                 }
-                    // } else if (view.getId() == R.id.deckpicker_bar_mat || view.getId() == R.id.deckpicker_bar_all) {
-                    // if (text.length() > 0 && !text.equals("-1.0")) {
-                    // View parent = (View)view.getParent().getParent();
-                    // if (text.equals("-2")) {
-                    // parent.setVisibility(View.GONE);
-                    // } else {
-                    // Utils.updateProgressBars(view, (int) UIUtils.getDensityAdjustedValue(DeckPicker.this, 3.4f),
-                    // (int) (Double.parseDouble(text) * ((View)view.getParent().getParent().getParent()).getHeight()));
-                    // if (parent.getVisibility() == View.INVISIBLE) {
-                    // parent.setVisibility(View.VISIBLE);
-                    // parent.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
-                    // }
-                    // }
-                    // }
-                    // return true;
-                    // } else if (view.getVisibility() == View.INVISIBLE) {
-                    // if (!text.equals("-1")) {
-                    // view.setVisibility(View.VISIBLE);
-                    // view.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
-                    // return false;
-                    // }
-                    // } else if (text.equals("-1")){
-                    // view.setVisibility(View.INVISIBLE);
-                    // return false;
+                // } else if (view.getId() == R.id.deckpicker_bar_mat || view.getId() == R.id.deckpicker_bar_all) {
+                // if (text.length() > 0 && !text.equals("-1.0")) {
+                // View parent = (View)view.getParent().getParent();
+                // if (text.equals("-2")) {
+                // parent.setVisibility(View.GONE);
+                // } else {
+                // Utils.updateProgressBars(view, (int) UIUtils.getDensityAdjustedValue(DeckPicker.this, 3.4f),
+                // (int) (Double.parseDouble(text) * ((View)view.getParent().getParent().getParent()).getHeight()));
+                // if (parent.getVisibility() == View.INVISIBLE) {
+                // parent.setVisibility(View.VISIBLE);
+                // parent.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
+                // }
+                // }
+                // }
+                // return true;
+                // } else if (view.getVisibility() == View.INVISIBLE) {
+                // if (!text.equals("-1")) {
+                // view.setVisibility(View.VISIBLE);
+                // view.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
+                // return false;
+                // }
+                // } else if (text.equals("-1")){
+                // view.setVisibility(View.INVISIBLE);
+                // return false;
                 return false;
             }
         });
@@ -1083,17 +1097,20 @@ protected void onResume() {
 
     @Override
     public void onSaveInstanceState(Bundle savedInstanceState) {
-      super.onSaveInstanceState(savedInstanceState);
-      savedInstanceState.putLong("mCurrentDid", mCurrentDid);
-//      savedInstanceState.putSerializable("mDeckList", mDeckList);
+        super.onSaveInstanceState(savedInstanceState);
+        savedInstanceState.putLong("mCurrentDid", mCurrentDid);
+        // savedInstanceState.putSerializable("mDeckList", mDeckList);
     }
+
+
     @Override
     public void onRestoreInstanceState(Bundle savedInstanceState) {
-      super.onRestoreInstanceState(savedInstanceState);
-      mCurrentDid = savedInstanceState.getLong("mCurrentDid");
-//      mDeckList = (ArrayList<HashMap<String, String>>) savedInstanceState.getSerializable("mDeckList");
+        super.onRestoreInstanceState(savedInstanceState);
+        mCurrentDid = savedInstanceState.getLong("mCurrentDid");
+        // mDeckList = (ArrayList<HashMap<String, String>>) savedInstanceState.getSerializable("mDeckList");
     }
 
+
     private void loadCollection() {
         if (!AnkiDroidApp.isSdCardMounted()) {
             showDialog(DIALOG_SD_CARD_NOT_MOUNTED);
@@ -1102,7 +1119,8 @@ private void loadCollection() {
         String path = AnkiDroidApp.getCollectionPath();
         Collection col = AnkiDroidApp.getCol();
         if (col == null || !col.getPath().equals(path) || mDeckListView == null || mDeckListView.getChildCount() == 0) {
-            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler, new DeckTask.TaskData(path));
+            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler, new DeckTask.TaskData(
+                    path));
         } else {
             loadCounts();
         }
@@ -1111,13 +1129,14 @@ private void loadCollection() {
 
     public void loadCounts() {
         if (AnkiDroidApp.colIsOpen()) {
-            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_COUNTS, mLoadCountsHandler, new TaskData(AnkiDroidApp.getCol()));
+            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_COUNTS, mLoadCountsHandler,
+                    new TaskData(AnkiDroidApp.getCol()));
         }
     }
 
 
     private void addNote() {
-        Preferences.COMING_FROM_ADD=true;
+        Preferences.COMING_FROM_ADD = true;
         Intent intent = new Intent(DeckPicker.this, CardEditor.class);
         intent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_DECKPICKER);
         startActivityForResult(intent, ADD_NOTE);
@@ -1142,19 +1161,22 @@ private boolean hasErrorFiles() {
         return false;
     }
 
+
     private void showUpgradeScreen(boolean animation, int stage) {
         showUpgradeScreen(animation, stage, true);
     }
 
+
     private void showUpgradeScreen(boolean animation, int stage, boolean left) {
         Intent upgradeIntent = new Intent(this, Info.class);
         upgradeIntent.putExtra(Info.TYPE_EXTRA, Info.TYPE_UPGRADE_DECKS);
         upgradeIntent.putExtra(Info.TYPE_UPGRADE_STAGE, stage);
         startActivityForResult(upgradeIntent, SHOW_INFO_UPGRADE_DECKS);
-        ActivityTransitionAnimation.slide(this,
-                left ? ActivityTransitionAnimation.LEFT : ActivityTransitionAnimation.RIGHT);
+        ActivityTransitionAnimation.slide(this, left ? ActivityTransitionAnimation.LEFT
+                : ActivityTransitionAnimation.RIGHT);
     }
 
+
     private boolean upgradeNeeded() {
         if (!AnkiDroidApp.isSdCardMounted()) {
             showDialog(DIALOG_SD_CARD_NOT_MOUNTED);
@@ -1174,6 +1196,7 @@ private boolean upgradeNeeded() {
         return false;
     }
 
+
     private SharedPreferences restorePreferences() {
         SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
         mPrefDeckPath = AnkiDroidApp.getCurrentAnkiDroidDirectory();
@@ -1208,8 +1231,8 @@ private void showStartupScreensAndDialogs(SharedPreferences preferences, int ski
         } else if (skip < 3 && upgradeNeeded()) {
             // Note that the "upgrade needed" refers to upgrading Anki 1.x decks, not to newer
             // versions of AnkiDroid.
-            AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext())
-                    .edit().putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
+            AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
+                    .putInt("lastUpgradeVersion", AnkiDroidApp.getPkgVersionCode()).commit();
             showUpgradeScreen(skip != 0, Info.UPGRADE_SCREEN_BASIC1);
         } else if (skip < 4 && hasErrorFiles()) {
             Intent i = new Intent(this, Feedback.class);
@@ -1255,8 +1278,7 @@ private void showStartupScreensAndDialogs(SharedPreferences preferences, int ski
             }
             final int previous = previousTemp;
             preferences.edit().putInt("lastUpgradeVersion", current).commit();
-            if (previous < AnkiDroidApp.CHECK_DB_AT_VERSION ||
-                    previous < AnkiDroidApp.CHECK_PREFERENCES_AT_VERSION) {
+            if (previous < AnkiDroidApp.CHECK_DB_AT_VERSION || previous < AnkiDroidApp.CHECK_PREFERENCES_AT_VERSION) {
 
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, new Listener() {
                     @Override
@@ -1270,10 +1292,12 @@ public void onPostExecute(DeckTask task, TaskData result) {
                         }
                     }
 
+
                     @Override
                     public void onPreExecute(DeckTask task) {
                     }
 
+
                     @Override
                     public void onProgressUpdate(DeckTask task, TaskData... values) {
                     }
@@ -1314,7 +1338,8 @@ protected void onStop() {
         super.onStop();
         if (!mDontSaveOnStop) {
             if (isFinishing()) {
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseCollectionHandler, new TaskData(AnkiDroidApp.getCol()));
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseCollectionHandler, new TaskData(
+                        AnkiDroidApp.getCol()));
             } else {
                 StudyOptionsFragment frag = getFragment();
                 if (!(frag != null && !frag.dbSaveNecessary())) {
@@ -1424,12 +1449,10 @@ public void onClick(DialogInterface dialog, int which) {
                                 i.putExtra("request", RESULT_DB_ERROR);
                                 dialog.dismiss();
                                 startActivityForResult(i, REPORT_ERROR);
-                                ActivityTransitionAnimation.slide(DeckPicker.this,
-                                        ActivityTransitionAnimation.RIGHT);
+                                ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.RIGHT);
                             }
                         });
-                builder.setNegativeButton(res.getString(R.string.close),
-                        new DialogInterface.OnClickListener() {
+                builder.setNegativeButton(res.getString(R.string.close), new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
                         if (!AnkiDroidApp.colIsOpen()) {
@@ -1526,46 +1549,45 @@ public void onClick(DialogInterface dialog, int which) {
                 // Message is set in onPrepareDialog
                 builder.setTitle(res.getString(R.string.delete_deck_title));
                 builder.setIcon(R.drawable.ic_dialog_alert);
-                builder.setPositiveButton(res.getString(R.string.yes),
-                        new DialogInterface.OnClickListener() {
+                builder.setPositiveButton(res.getString(R.string.yes), new DialogInterface.OnClickListener() {
 
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_DECK, new DeckTask.TaskListener() {
                             @Override
-                            public void onClick(DialogInterface dialog, int which) {
-                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_DECK, new DeckTask.TaskListener() {
-                                    @Override
-                                    public void onPreExecute() {
-                                        mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
-                                                .getString(R.string.delete_deck), true);
-                                    }
+                            public void onPreExecute() {
+                                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
+                                        .getString(R.string.delete_deck), true);
+                            }
 
 
-                                    @Override
-                                    public void onPostExecute(TaskData result) {
-                                        if (result == null) {
-                                            return;
-                                        }
-                                        Object[] res = result.getObjArray();
-                                        updateDecksList((TreeSet<Object[]>) res[0], (Integer) res[1], (Integer) res[2]);
-                                        if (mFragmented) {
-                                            selectDeck(AnkiDroidApp.getCol().getDecks().selected());
-                                        }
-                                        if (mProgressDialog.isShowing()) {
-                                            try {
-                                                mProgressDialog.dismiss();
-                                            } catch (Exception e) {
-                                                Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = "
-                                                        + e.getMessage());
-                                            }
-                                        }
+                            @Override
+                            public void onPostExecute(TaskData result) {
+                                if (result == null) {
+                                    return;
+                                }
+                                Object[] res = result.getObjArray();
+                                updateDecksList((TreeSet<Object[]>) res[0], (Integer) res[1], (Integer) res[2]);
+                                if (mFragmented) {
+                                    selectDeck(AnkiDroidApp.getCol().getDecks().selected());
+                                }
+                                if (mProgressDialog.isShowing()) {
+                                    try {
+                                        mProgressDialog.dismiss();
+                                    } catch (Exception e) {
+                                        Log.e(AnkiDroidApp.TAG,
+                                                "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
                                     }
+                                }
+                            }
 
 
-                                    @Override
-                                    public void onProgressUpdate(TaskData... values) {
-                                    }
-                                }, new TaskData(AnkiDroidApp.getCol(), mCurrentDid));
+                            @Override
+                            public void onProgressUpdate(TaskData... values) {
                             }
-                        });
+                        }, new TaskData(AnkiDroidApp.getCol(), mCurrentDid));
+                    }
+                });
                 builder.setNegativeButton(res.getString(R.string.cancel), null);
                 dialog = builder.create();
                 break;
@@ -1579,9 +1601,9 @@ public void onClick(DialogInterface dialog, int which) {
                         DeckTask.launchDeckTask(
                                 DeckTask.TASK_TYPE_LOAD_STATISTICS,
                                 mLoadStatisticsHandler,
-                                new DeckTask.TaskData(AnkiDroidApp.getCol(), which, mFragmented ? AnkiDroidApp.getSharedPrefs(
-                                        AnkiDroidApp.getInstance().getBaseContext()).getBoolean("statsRange", true)
-                                        : true));
+                                new DeckTask.TaskData(AnkiDroidApp.getCol(), which, mFragmented ? AnkiDroidApp
+                                        .getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean(
+                                                "statsRange", true) : true));
                     }
                 }, mFragmented);
                 break;
@@ -1709,19 +1731,21 @@ public void onCancel(DialogInterface arg0) {
 
             case DIALOG_SD_CARD_NOT_MOUNTED:
                 if (mNotMountedDialog == null || !mNotMountedDialog.isShowing()) {
-                    mNotMountedDialog = StyledOpenCollectionDialog.show(DeckPicker.this, getResources().getString(R.string.sd_card_not_mounted), new OnCancelListener() {
+                    mNotMountedDialog = StyledOpenCollectionDialog.show(DeckPicker.this,
+                            getResources().getString(R.string.sd_card_not_mounted), new OnCancelListener() {
 
-                        @Override
-                        public void onCancel(DialogInterface arg0) {
-                            finishWithAnimation();
-                        }
-                    }, new View.OnClickListener() {
+                                @Override
+                                public void onCancel(DialogInterface arg0) {
+                                    finishWithAnimation();
+                                }
+                            }, new View.OnClickListener() {
 
-                        @Override
-                        public void onClick(View v) {
-                            startActivityForResult(new Intent(DeckPicker.this, Preferences.class), PREFERENCES_UPDATE);
-                        }
-                    });
+                                @Override
+                                public void onClick(View v) {
+                                    startActivityForResult(new Intent(DeckPicker.this, Preferences.class),
+                                            PREFERENCES_UPDATE);
+                                }
+                            });
                 }
                 dialog = null;
                 break;
@@ -1729,36 +1753,39 @@ public void onClick(View v) {
             case DIALOG_IMPORT:
                 builder.setTitle(res.getString(R.string.import_title));
                 builder.setMessage(res.getString(R.string.import_message, mImportPath));
-                builder.setPositiveButton(res.getString(R.string.import_message_add), new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT, mImportAddListener,
-                                new TaskData(AnkiDroidApp.getCol(), mImportPath, false));
-                        mImportPath = null;
-                    }
-                });
-                builder.setNeutralButton(res.getString(R.string.import_message_replace), new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        Resources res = getResources();
-                        StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
-                        builder.setTitle(res.getString(R.string.import_title));
-                        builder.setMessage(res.getString(R.string.import_message_replace_confirm, mImportPath));
-                        builder.setPositiveButton(res.getString(R.string.yes), new DialogInterface.OnClickListener() {
-
+                builder.setPositiveButton(res.getString(R.string.import_message_add),
+                        new DialogInterface.OnClickListener() {
                             @Override
-                            public void onClick(DialogInterface dialog,
-                                    int which) {
-                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT_REPLACE, mImportReplaceListener,
-                                        new TaskData(AnkiDroidApp.getCol(), mImportPath));
+                            public void onClick(DialogInterface dialog, int which) {
+                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT, mImportAddListener, new TaskData(
+                                        AnkiDroidApp.getCol(), mImportPath, false));
                                 mImportPath = null;
                             }
+                        });
+                builder.setNeutralButton(res.getString(R.string.import_message_replace),
+                        new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                Resources res = getResources();
+                                StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
+                                builder.setTitle(res.getString(R.string.import_title));
+                                builder.setMessage(res.getString(R.string.import_message_replace_confirm, mImportPath));
+                                builder.setPositiveButton(res.getString(R.string.yes),
+                                        new DialogInterface.OnClickListener() {
+
+                                            @Override
+                                            public void onClick(DialogInterface dialog, int which) {
+                                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT_REPLACE,
+                                                        mImportReplaceListener, new TaskData(AnkiDroidApp.getCol(),
+                                                                mImportPath));
+                                                mImportPath = null;
+                                            }
 
+                                        });
+                                builder.setNegativeButton(res.getString(R.string.no), null);
+                                builder.show();
+                            }
                         });
-                        builder.setNegativeButton(res.getString(R.string.no), null);
-                        builder.show();
-                    }
-                });
                 builder.setNegativeButton(res.getString(R.string.cancel), null);
                 builder.setCancelable(true);
                 dialog = builder.create();
@@ -1772,13 +1799,13 @@ public void onClick(DialogInterface dialog,
             case DIALOG_IMPORT_HINT:
                 builder.setTitle(res.getString(R.string.import_title));
                 builder.setMessage(res.getString(R.string.import_hint, AnkiDroidApp.getCurrentAnkiDroidDirectory()));
-                builder.setPositiveButton(res.getString(R.string.ok),  new DialogInterface.OnClickListener() {
+                builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
                         showDialog(DIALOG_IMPORT_SELECT);
                     }
                 });
-                builder.setNegativeButton(res.getString(R.string.cancel),  null);
+                builder.setNegativeButton(res.getString(R.string.cancel), null);
                 dialog = builder.create();
                 break;
 
@@ -1815,110 +1842,112 @@ public void onCancel(DialogInterface arg0) {
                 dialog = builder.create();
                 break;
 
-             case DIALOG_RESTORE_BACKUP:
-                 File[] files = BackupManager.getBackups(new File(AnkiDroidApp.getCollectionPath()));
-                 mBackups = new File[files.length];
-                 for (int i = 0; i < files.length; i++) {
-                     mBackups[i] = files[files.length - 1 - i];
-                 }
-                 if (mBackups.length == 0) {
-                     builder.setTitle(getResources().getString(R.string.backup_restore));
-                     builder.setMessage(res.getString(R.string.backup_restore_no_backups));
-                     builder.setPositiveButton(res.getString(R.string.ok), new
-                             Dialog.OnClickListener() {
-                         @Override
-                         public void onClick(DialogInterface dialog, int which) {
-                             showDialog(DIALOG_ERROR_HANDLING);
-                         }
-                     });
-                     builder.setCancelable(true).setOnCancelListener(new OnCancelListener() {
-                         @Override
-                         public void onCancel(DialogInterface arg0) {
-                             showDialog(DIALOG_ERROR_HANDLING);
-                         }
-                     });
-                 } else {
-                     String[] dates = new String[mBackups.length];
-                     for (int i = 0; i < mBackups.length; i++) {
-                         dates[i] = mBackups[i].getName().replaceAll(".*-(\\d{4}-\\d{2}-\\d{2})-(\\d{2})-(\\d{2}).anki2", "$1 ($2:$3 h)");
-                     }
-                     builder.setTitle(res.getString(R.string.backup_restore_select_title));
-                     builder.setIcon(android.R.drawable.ic_input_get);
-                     builder.setSingleChoiceItems(dates, dates.length, new DialogInterface.OnClickListener(){
-
-                         @Override
-                         public void onClick(DialogInterface dialog, int which) {
-                              DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RESTORE_DECK, mRestoreDeckHandler, new DeckTask.TaskData(new Object[]{AnkiDroidApp.getCol(), AnkiDroidApp.getCollectionPath(), mBackups[which].getPath()}));
-                         }
-                        });
-                     builder.setCancelable(true).setOnCancelListener(new OnCancelListener() {
-                         @Override
-                         public void onCancel(DialogInterface arg0) {
-                             showDialog(DIALOG_ERROR_HANDLING);
-                         }
-                     });
-                 }
-                 dialog = builder.create();
-                 break;
-
-             case DIALOG_NEW_COLLECTION:
-                 builder.setTitle(res.getString(R.string.backup_new_collection));
-                 builder.setMessage(res.getString(R.string.backup_del_collection_question));
-                 builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
-                     @Override
-                     public void onClick(DialogInterface dialog, int which) {
-                         AnkiDroidApp.closeCollection(false);
-                         String path = AnkiDroidApp.getCollectionPath();
-                         AnkiDatabaseManager.closeDatabase(path);
-                         if (BackupManager.moveDatabaseToBrokenFolder(path, false)) {
-                             loadCollection();
-                        } else {
+            case DIALOG_RESTORE_BACKUP:
+                File[] files = BackupManager.getBackups(new File(AnkiDroidApp.getCollectionPath()));
+                mBackups = new File[files.length];
+                for (int i = 0; i < files.length; i++) {
+                    mBackups[i] = files[files.length - 1 - i];
+                }
+                if (mBackups.length == 0) {
+                    builder.setTitle(getResources().getString(R.string.backup_restore));
+                    builder.setMessage(res.getString(R.string.backup_restore_no_backups));
+                    builder.setPositiveButton(res.getString(R.string.ok), new Dialog.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
                             showDialog(DIALOG_ERROR_HANDLING);
                         }
-                     }
-                 });
-                 builder.setNegativeButton(res.getString(R.string.no), new
-                         DialogInterface.OnClickListener() {
+                    });
+                    builder.setCancelable(true).setOnCancelListener(new OnCancelListener() {
                         @Override
-                        public void onClick(DialogInterface arg0, int arg1) {
+                        public void onCancel(DialogInterface arg0) {
                             showDialog(DIALOG_ERROR_HANDLING);
-                         }
-                  });
-                 builder.setCancelable(true);
-                 builder.setOnCancelListener(new OnCancelListener() {
-                     @Override
-                     public void onCancel(DialogInterface arg0) {
-                         showDialog(DIALOG_ERROR_HANDLING);
-                     }
-                 });
-                 dialog = builder.create();
-                 break;
-
-             case DIALOG_FULL_SYNC_FROM_SERVER:
-                 builder.setTitle(res.getString(R.string.backup_full_sync_from_server));
-                 builder.setMessage(res.getString(R.string.backup_full_sync_from_server_question));
-                 builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
-                     @Override
-                     public void onClick(DialogInterface dialog, int which) {
-                         sync("download", mSyncMediaUsn);
-                     }
-                 });
-                 builder.setNegativeButton(res.getString(R.string.no), new
-                         DialogInterface.OnClickListener() {
+                        }
+                    });
+                } else {
+                    String[] dates = new String[mBackups.length];
+                    for (int i = 0; i < mBackups.length; i++) {
+                        dates[i] = mBackups[i].getName().replaceAll(
+                                ".*-(\\d{4}-\\d{2}-\\d{2})-(\\d{2})-(\\d{2}).anki2", "$1 ($2:$3 h)");
+                    }
+                    builder.setTitle(res.getString(R.string.backup_restore_select_title));
+                    builder.setIcon(android.R.drawable.ic_input_get);
+                    builder.setSingleChoiceItems(dates, dates.length, new DialogInterface.OnClickListener() {
+
                         @Override
-                        public void onClick(DialogInterface arg0, int arg1) {
+                        public void onClick(DialogInterface dialog, int which) {
+                            DeckTask.launchDeckTask(
+                                    DeckTask.TASK_TYPE_RESTORE_DECK,
+                                    mRestoreDeckHandler,
+                                    new DeckTask.TaskData(new Object[] { AnkiDroidApp.getCol(),
+                                            AnkiDroidApp.getCollectionPath(), mBackups[which].getPath() }));
+                        }
+                    });
+                    builder.setCancelable(true).setOnCancelListener(new OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            showDialog(DIALOG_ERROR_HANDLING);
+                        }
+                    });
+                }
+                dialog = builder.create();
+                break;
+
+            case DIALOG_NEW_COLLECTION:
+                builder.setTitle(res.getString(R.string.backup_new_collection));
+                builder.setMessage(res.getString(R.string.backup_del_collection_question));
+                builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        AnkiDroidApp.closeCollection(false);
+                        String path = AnkiDroidApp.getCollectionPath();
+                        AnkiDatabaseManager.closeDatabase(path);
+                        if (BackupManager.moveDatabaseToBrokenFolder(path, false)) {
+                            loadCollection();
+                        } else {
                             showDialog(DIALOG_ERROR_HANDLING);
-                         }
-                  });
-                 builder.setCancelable(true);
-                 builder.setOnCancelListener(new OnCancelListener() {
-                     @Override
-                     public void onCancel(DialogInterface arg0) {
-                         showDialog(DIALOG_ERROR_HANDLING);
-                     }
-                 });
-                 dialog = builder.create();
-                 break;
+                        }
+                    }
+                });
+                builder.setNegativeButton(res.getString(R.string.no), new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface arg0, int arg1) {
+                        showDialog(DIALOG_ERROR_HANDLING);
+                    }
+                });
+                builder.setCancelable(true);
+                builder.setOnCancelListener(new OnCancelListener() {
+                    @Override
+                    public void onCancel(DialogInterface arg0) {
+                        showDialog(DIALOG_ERROR_HANDLING);
+                    }
+                });
+                dialog = builder.create();
+                break;
+
+            case DIALOG_FULL_SYNC_FROM_SERVER:
+                builder.setTitle(res.getString(R.string.backup_full_sync_from_server));
+                builder.setMessage(res.getString(R.string.backup_full_sync_from_server_question));
+                builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        sync("download", mSyncMediaUsn);
+                    }
+                });
+                builder.setNegativeButton(res.getString(R.string.no), new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface arg0, int arg1) {
+                        showDialog(DIALOG_ERROR_HANDLING);
+                    }
+                });
+                builder.setCancelable(true);
+                builder.setOnCancelListener(new OnCancelListener() {
+                    @Override
+                    public void onCancel(DialogInterface arg0) {
+                        showDialog(DIALOG_ERROR_HANDLING);
+                    }
+                });
+                dialog = builder.create();
+                break;
 
             default:
                 dialog = null;
@@ -1955,7 +1984,12 @@ protected void onPrepareDialog(int id, Dialog dialog) {
                 }
                 mCurrentDid = Long.parseLong(mDeckList.get(mContextMenuPosition).get("did"));
                 try {
-                    ad.changeListItem(CONTEXT_MENU_COLLAPSE_DECK, getResources().getString(AnkiDroidApp.getCol().getDecks().get(mCurrentDid).getBoolean("collapsed") ? R.string.contextmenu_deckpicker_inflate_deck : R.string.contextmenu_deckpicker_collapse_deck));
+                    ad.changeListItem(
+                            CONTEXT_MENU_COLLAPSE_DECK,
+                            getResources()
+                                    .getString(
+                                            AnkiDroidApp.getCol().getDecks().get(mCurrentDid).getBoolean("collapsed") ? R.string.contextmenu_deckpicker_inflate_deck
+                                                    : R.string.contextmenu_deckpicker_collapse_deck));
                 } catch (NotFoundException e) {
                     // do nothing
                 } catch (JSONException e) {
@@ -1968,7 +2002,7 @@ protected void onPrepareDialog(int id, Dialog dialog) {
             case DIALOG_SYNC_LOG:
             case DIALOG_SYNC_SANITY_ERROR:
                 // If both have text, separate them by a new line.
-                if (!TextUtils.isEmpty(mDialogMessage) &&  !TextUtils.isEmpty(mSyncMessage)) {
+                if (!TextUtils.isEmpty(mDialogMessage) && !TextUtils.isEmpty(mSyncMessage)) {
                     ad.setMessage(mDialogMessage + "\n\n" + mSyncMessage);
                 } else if (!TextUtils.isEmpty(mDialogMessage)) {
                     ad.setMessage(mDialogMessage);
@@ -2050,8 +2084,8 @@ public void onClick(DialogInterface dialog, int which) {
             case DIALOG_IMPORT_SELECT:
                 List<File> fileList = Utils.getImportableDecks();
                 if (fileList.size() == 0) {
-                    Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.upgrade_import_no_file_found),
-                            false);
+                    Themes.showThemedToast(DeckPicker.this,
+                            getResources().getString(R.string.upgrade_import_no_file_found), false);
                 }
                 ad.setEnabled(fileList.size() != 0);
                 String[] tts = new String[fileList.size()];
@@ -2064,14 +2098,14 @@ public void onClick(DialogInterface dialog, int which) {
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
                         mImportPath = mImportValues[which];
-                        //If the apkg file is called "collection.apkg", we assume the collection will be replaced
-                        if (mImportPath.split("/")[mImportPath.split("/").length-1].equals("collection.apkg")){
-                                mImportMethod=IMPORT_METHOD_REPLACE;
+                        // If the apkg file is called "collection.apkg", we assume the collection will be replaced
+                        if (mImportPath.split("/")[mImportPath.split("/").length - 1].equals("collection.apkg")) {
+                            mImportMethod = IMPORT_METHOD_REPLACE;
                         }
                         switch (mImportMethod) {
                             case IMPORT_METHOD_ADD:
-                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT, mImportAddListener,
-                                        new TaskData(AnkiDroidApp.getCol(), mImportPath, false));
+                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT, mImportAddListener, new TaskData(
+                                        AnkiDroidApp.getCol(), mImportPath, false));
                                 mImportPath = null;
                                 break;
                             case IMPORT_METHOD_REPLACE:
@@ -2105,11 +2139,13 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         return super.onKeyDown(keyCode, event);
     }
 
+
     private void finishWithAnimation() {
         finish();
         ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.DIALOG_EXIT);
     }
 
+
     // ----------------------------------------------------------------------------
     // CUSTOM METHODS
     // ----------------------------------------------------------------------------
@@ -2117,12 +2153,13 @@ private void finishWithAnimation() {
     public void setStudyContentView(long deckId, Bundle cramConfig) {
         StudyOptionsFragment details = StudyOptionsFragment.newInstance(deckId, false, cramConfig);
         FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
-//      ft.setCustomAnimations(R.anim.fade_in, R.anim.fade_out);
+        // ft.setCustomAnimations(R.anim.fade_in, R.anim.fade_out);
         ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_CLOSE);
         ft.replace(R.id.studyoptions_fragment, details);
         ft.commit();
     }
 
+
     public StudyOptionsFragment getFragment() {
         Fragment frag = (Fragment) getSupportFragmentManager().findFragmentById(R.id.studyoptions_fragment);
         if (frag != null && (frag instanceof StudyOptionsFragment)) {
@@ -2131,6 +2168,7 @@ public StudyOptionsFragment getFragment() {
         return null;
     }
 
+
     /**
      * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)
      */
@@ -2201,7 +2239,7 @@ private void sync() {
      * The mother of all syncing attempts. This might be called from sync() as first attempt to sync a collection OR
      * from the mSyncConflictResolutionListener if the first attempt determines that a full-sync is required. In the
      * second case, we have passed the mediaUsn that was obtained during the first attempt.
-     *
+     * 
      * @param syncConflictResolution Either "upload" or "download", depending on the user's choice.
      * @param syncMediaUsn The media Usn, as determined during the prior sync() attempt that determined that full
      *            syncing was required.
@@ -2212,9 +2250,9 @@ private void sync(String syncConflictResolution, int syncMediaUsn) {
         if (hkey.length() == 0) {
             showDialog(DIALOG_USER_NOT_LOGGED_IN_SYNC);
         } else {
-            Connection.sync(mSyncListener, new Connection.Payload(new Object[] { hkey,
-                    preferences.getBoolean("syncFetchesMedia", true),
-                    syncConflictResolution, syncMediaUsn }));
+            Connection.sync(mSyncListener,
+                    new Connection.Payload(new Object[] { hkey, preferences.getBoolean("syncFetchesMedia", true),
+                            syncConflictResolution, syncMediaUsn }));
         }
     }
 
@@ -2428,9 +2466,8 @@ public void onClick(DialogInterface dialog, int which) {
             case R.id.action_online:
             case R.id.action_faq:
                 if (Utils.isIntentAvailable(DeckPicker.this, "android.intent.action.VIEW")) {
-                    Intent intent = new Intent("android.intent.action.VIEW", Uri
-                            .parse(getResources().getString(
-                                    item.getItemId() == R.id.action_online ? R.string.link_help : R.string.link_faq)));
+                    Intent intent = new Intent("android.intent.action.VIEW", Uri.parse(getResources().getString(
+                            item.getItemId() == R.id.action_online ? R.string.link_help : R.string.link_faq)));
                     startActivity(intent);
                 } else {
                     startActivity(new Intent(DeckPicker.this, Info.class));
@@ -2472,8 +2509,8 @@ protected void onActivityResult(int requestCode, int resultCode, Intent intent)
             loadCounts();
         } else if (requestCode == ADD_NOTE && resultCode != RESULT_CANCELED) {
             loadCounts();
-        } else if (requestCode == BROWSE_CARDS &&
-                (resultCode == Activity.RESULT_OK || resultCode == Activity.RESULT_CANCELED)) {
+        } else if (requestCode == BROWSE_CARDS
+                && (resultCode == Activity.RESULT_OK || resultCode == Activity.RESULT_CANCELED)) {
             loadCounts();
         } else if (requestCode == ADD_CRAM_DECK) {
             // TODO: check, if ok has been clicked
@@ -2656,7 +2693,9 @@ public void onProgressUpdate(TaskData... values) {
     private void openStudyOptions(long deckId) {
         openStudyOptions(deckId, null);
     }
-        private void openStudyOptions(long deckId, Bundle cramInitialConfig) {
+
+
+    private void openStudyOptions(long deckId, Bundle cramInitialConfig) {
         if (mFragmented) {
             setStudyContentView(deckId, cramInitialConfig);
         } else {
@@ -2682,6 +2721,7 @@ private void openStudyOptions(long deckId, Bundle cramInitialConfig) {
 
     /**
      * Programmatically click on a deck in the deck list.
+     * 
      * @param did The deck ID of the deck to select.
      */
     private void selectDeck(long did) {
@@ -2701,11 +2741,13 @@ public void onGlobalLayout() {
         }
     }
 
+
     /**
      * Set which deck is selected (highlighted) in the deck list.
      * <p>
-     * Note that this method does not change the currently selected deck in the collection, only the highlighted
-     * deck in the deck list. To select a deck, see {@link #selectDeck(long)}.
+     * Note that this method does not change the currently selected deck in the collection, only the highlighted deck in
+     * the deck list. To select a deck, see {@link #selectDeck(long)}.
+     * 
      * @param did The deck ID of the deck to select.
      */
     public void setSelectedDeck(long did) {
@@ -2717,6 +2759,7 @@ public void setSelectedDeck(long did) {
         }
     }
 
+
     private void handleDeckSelection(int id) {
         if (!AnkiDroidApp.colIsOpen()) {
             loadCollection();
@@ -2822,7 +2865,8 @@ private void updateDecksList(TreeSet<Object[]> decks, int eta, int count) {
             if (eta != -1) {
                 time = res.getQuantityString(R.plurals.deckpicker_title_minutes, eta, eta);
             }
-            AnkiDroidApp.getCompat().setSubtitle(this, res.getQuantityString(R.plurals.deckpicker_title, due, due, count, time));
+            AnkiDroidApp.getCompat().setSubtitle(this,
+                    res.getQuantityString(R.plurals.deckpicker_title, due, due, count, time));
         }
 
         // update widget
@@ -2843,13 +2887,13 @@ private void updateDecksList(TreeSet<Object[]> decks, int eta, int count) {
     // INNER CLASSES
     // ----------------------------------------------------------------------------
 
-
     class MyGestureDetector extends SimpleOnGestureListener {
         @Override
         public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
             if (mSwipeEnabled && !mFragmented) {
                 try {
-                    if (e1.getX() - e2.getX() > AnkiDroidApp.sSwipeMinDistance && Math.abs(velocityX) > AnkiDroidApp.sSwipeThresholdVelocity
+                    if (e1.getX() - e2.getX() > AnkiDroidApp.sSwipeMinDistance
+                            && Math.abs(velocityX) > AnkiDroidApp.sSwipeThresholdVelocity
                             && Math.abs(e1.getY() - e2.getY()) < AnkiDroidApp.sSwipeMaxOffPath) {
                         mDontSaveOnStop = true;
                         float pos = e1.getY();
@@ -2858,14 +2902,16 @@ public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float ve
                             Rect rect = new Rect();
                             v.getHitRect(rect);
                             if (rect.top < pos && rect.bottom > pos) {
-                                HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter.getItem(mDeckListView.getPositionForView(v));
+                                HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter
+                                        .getItem(mDeckListView.getPositionForView(v));
                                 Collection col = AnkiDroidApp.getCol();
                                 if (col != null) {
                                     col.getDecks().select(Long.parseLong(data.get("did")));
                                     col.reset();
                                     Intent reviewer = new Intent(DeckPicker.this, Reviewer.class);
                                     startActivityForResult(reviewer, REQUEST_REVIEW);
-                                    ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.LEFT);
+                                    ActivityTransitionAnimation
+                                            .slide(DeckPicker.this, ActivityTransitionAnimation.LEFT);
                                     return true;
                                 }
                             }
@@ -2907,6 +2953,7 @@ public static String readableDeckName(String[] name) {
         return sb.toString();
     }
 
+
     @Override
     public void onAttachedToWindow() {
 
diff --git a/src/com/ichi2/anki/Feedback.java b/src/com/ichi2/anki/Feedback.java
index 4b2fbbf1f455..89846f5df781 100644
--- a/src/com/ichi2/anki/Feedback.java
+++ b/src/com/ichi2/anki/Feedback.java
@@ -369,7 +369,7 @@ private void getErrorFiles() {
 
     /**
      * Delete the crash log files.
-     *
+     * 
      * @param onlyProcessed only delete the log files that have been sent.
      * @param keepLatest keep the latest log file. If the file has not been sent yet, it is not deleted even if this
      *            value is set to false.
@@ -561,7 +561,7 @@ private static List<NameValuePair> extractPairsFromError(String type, String err
 
     /**
      * Posting feedback or error info to the server. This is called from the AsyncTask.
-     *
+     * 
      * @param url The url to post the feedback to.
      * @param type The type of the info, eg Feedback.TYPE_CRASH_STACKTRACE.
      * @param feedback For feedback types this is the message. For error/crash types this is the path to the error file.
@@ -627,4 +627,3 @@ public static Payload postFeedback(String url, String type, String feedback, Str
     }
 
 }
-
diff --git a/src/com/ichi2/anki/Info.java b/src/com/ichi2/anki/Info.java
index f6db34fa900c..7dea7837d040 100644
--- a/src/com/ichi2/anki/Info.java
+++ b/src/com/ichi2/anki/Info.java
@@ -125,6 +125,7 @@ public class Info extends ActionBarActivity {
     private StyledProgressDialog mProgressDialog;
     private StyledDialog mNoConnectionAlert;
 
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         Log.i(AnkiDroidApp.TAG, "Info - onCreate()");
@@ -150,7 +151,8 @@ protected void onCreate(Bundle savedInstanceState) {
             @Override
             public void onClick(View arg0) {
                 if (mType == TYPE_ABOUT) {
-                    Info.this.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=com.ichi2.anki")));
+                    Info.this.startActivity(new Intent(Intent.ACTION_VIEW, Uri
+                            .parse("market://details?id=com.ichi2.anki")));
                     return;
                 }
                 setResult(RESULT_OK);
@@ -279,7 +281,8 @@ public void onClick(View arg0) {
                         but.setOnClickListener(new OnClickListener() {
                             @Override
                             public void onClick(View arg0) {
-                                Themes.showThemedToast(Info.this, getString(R.string.deck_upgrade_start_again_to_upgrade_toast), false);
+                                Themes.showThemedToast(Info.this,
+                                        getString(R.string.deck_upgrade_start_again_to_upgrade_toast), false);
                                 setResult(RESULT_CANCELED);
                                 finish();
                             }
@@ -420,8 +423,8 @@ public void onClick(View arg0) {
                             @Override
                             public void onClick(View arg0) {
                                 lockScreenOrientation();
-                                Connection.upgradeDecks(mWebUpgradeListener,
-                                        new Connection.Payload(new Object[]{AnkiDroidApp.getCurrentAnkiDroidDirectory()}));
+                                Connection.upgradeDecks(mWebUpgradeListener, new Connection.Payload(
+                                        new Object[] { AnkiDroidApp.getCurrentAnkiDroidDirectory() }));
                             }
                         });
                         break;
@@ -483,7 +486,8 @@ public void onClick(View arg0) {
                                         DeckPicker.IMPORT_REPLACE_COLLECTION_NAME);
                                 List<File> importables = Utils.getImportableDecks();
                                 if (importables == null || !importables.contains(apkgFile)) {
-                                    Themes.showThemedToast(Info.this,
+                                    Themes.showThemedToast(
+                                            Info.this,
                                             getResources().getString(R.string.upgrade_import_no_file_found,
                                                     DeckPicker.IMPORT_REPLACE_COLLECTION_NAME), false);
                                 } else {
@@ -532,23 +536,24 @@ public void onClick(DialogInterface dialog, int which) {
                         break;
                 }
 
-//                File[] fileList = (new File(AnkiDroidApp.getCurrentAnkiDroidDirectory())).listFiles(new OldAnkiDeckFilter());
-//                StringBuilder fsb = new StringBuilder();
-//                fsb.append("<ul>");
-//                for (File f : fileList) {
-//                	fsb.append("<li>").append(f.getName().replace(".anki", "")).append("</li>");
-//                }
-//            	fsb.append("</ul>");
-//                sb.append(res.getString(R.string.upgrade_decks_message, fsb.toString()));
-//                sb.append("<ul><li>");
-//                sb.append(res.getString(R.string.upgrade_decks_message_pos1,
-//                		AnkiDroidApp.getCurrentAnkiDroidDirectory()));
-//                sb.append("</li><li>");
-//                sb.append(res.getString(R.string.upgrade_decks_message_pos2, res.getString(R.string.link_anki)));
-//                sb.append("</li><li>");
-//                sb.append(res.getString(R.string.upgrade_decks_message_pos3));
-//                sb.append("</li></ul>");
-//                sb.append(res.getString(R.string.upgrade_decks_message_finish));
+                // File[] fileList = (new File(AnkiDroidApp.getCurrentAnkiDroidDirectory())).listFiles(new
+                // OldAnkiDeckFilter());
+                // StringBuilder fsb = new StringBuilder();
+                // fsb.append("<ul>");
+                // for (File f : fileList) {
+                // fsb.append("<li>").append(f.getName().replace(".anki", "")).append("</li>");
+                // }
+                // fsb.append("</ul>");
+                // sb.append(res.getString(R.string.upgrade_decks_message, fsb.toString()));
+                // sb.append("<ul><li>");
+                // sb.append(res.getString(R.string.upgrade_decks_message_pos1,
+                // AnkiDroidApp.getCurrentAnkiDroidDirectory()));
+                // sb.append("</li><li>");
+                // sb.append(res.getString(R.string.upgrade_decks_message_pos2, res.getString(R.string.link_anki)));
+                // sb.append("</li><li>");
+                // sb.append(res.getString(R.string.upgrade_decks_message_pos3));
+                // sb.append("</li></ul>");
+                // sb.append(res.getString(R.string.upgrade_decks_message_finish));
                 sb.append("</body></html>");
                 mWebView.loadDataWithBaseURL("", sb.toString(), "text/html", "utf-8", null);
 
@@ -566,6 +571,7 @@ public void onClick(DialogInterface dialog, int which) {
         }
     }
 
+
     @Override
     protected Dialog onCreateDialog(int id) {
         StyledDialog dialog = null;
@@ -578,14 +584,14 @@ protected Dialog onCreateDialog(int id) {
                 builder.setMessage(R.string.no_user_password_error_message);
                 builder.setNegativeButton(R.string.cancel, null);
                 builder.setPositiveButton(R.string.log_in, new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialog, int which) {
-                                Intent myAccount = new Intent(Info.this, MyAccount.class);
-                                myAccount.putExtra("notLoggedIn", true);
-                                startActivityForResult(myAccount, LOG_IN_FOR_SYNC);
-                                ActivityTransitionAnimation.slide(Info.this, ActivityTransitionAnimation.FADE);
-                            }
-                        });
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        Intent myAccount = new Intent(Info.this, MyAccount.class);
+                        myAccount.putExtra("notLoggedIn", true);
+                        startActivityForResult(myAccount, LOG_IN_FOR_SYNC);
+                        ActivityTransitionAnimation.slide(Info.this, ActivityTransitionAnimation.FADE);
+                    }
+                });
                 dialog = builder.create();
                 break;
 
@@ -610,11 +616,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
             case DIALOG_SYNC_UPGRADE_REQUIRED:
                 builder.setMessage(res.getString(R.string.upgrade_required, res.getString(R.string.link_anki)));
                 builder.setPositiveButton(R.string.retry, new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialog, int which) {
-                                downloadCollection();
-                            }
-                        });
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        downloadCollection();
+                    }
+                });
                 builder.setNegativeButton(R.string.cancel, null);
                 builder.setTitle(R.string.sync_log_title);
                 dialog = builder.create();
@@ -623,6 +629,7 @@ public void onClick(DialogInterface dialog, int which) {
         return dialog;
     }
 
+
     @Override
     protected void onPrepareDialog(int id, Dialog dialog) {
         Resources res = getResources();
@@ -635,17 +642,20 @@ protected void onPrepareDialog(int id, Dialog dialog) {
         }
     }
 
+
     private void downloadCollection() {
         SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
         String hkey = preferences.getString("hkey", "");
         if (hkey.length() == 0) {
             showDialog(DIALOG_USER_NOT_LOGGED_IN_SYNC);
         } else {
-            Connection.sync(mSyncListener, new Connection.Payload(new Object[]{
-                    hkey, preferences.getBoolean("syncFetchesMedia", true), "download", 0}));
+            Connection.sync(mSyncListener,
+                    new Connection.Payload(new Object[] { hkey, preferences.getBoolean("syncFetchesMedia", true),
+                            "download", 0 }));
         }
     }
 
+
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
         super.onActivityResult(requestCode, resultCode, intent);
@@ -654,6 +664,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent intent)
         }
     }
 
+
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
@@ -699,6 +710,7 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         return super.onKeyDown(keyCode, event);
     }
 
+
     private String getTitleString() {
         StringBuilder appName = new StringBuilder();
         appName.append(AnkiDroidApp.getAppName());
@@ -711,6 +723,7 @@ private class MobileAnkiWebview extends WebViewClient {
         WebView mWebView;
         String mUrl;
 
+
         @Override
         public boolean shouldOverrideUrlLoading(WebView view, String url) {
             Log.i(AnkiDroidApp.TAG, "LoadSharedDecks: loading: " + url);
@@ -718,13 +731,13 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
             return true;
         }
 
+
         @Override
         public void onPageStarted(WebView view, String url, Bitmap favicon) {
             if (mUrl != null && mUrl.equals(url)) {
                 super.onPageStarted(view, url, favicon);
             } else if (url.matches(".*/shared/download/[0-9]*")) {
-                Connection.downloadSharedDeck(mDownloadDeckListener,
-                        new Connection.Payload(new Object[]{url}));
+                Connection.downloadSharedDeck(mDownloadDeckListener, new Connection.Payload(new Object[] { url }));
             } else {
                 mLoadingLayer.setVisibility(View.VISIBLE);
                 mWebView = view;
@@ -809,11 +822,12 @@ public String handleResponse(HttpResponse response) throws ClientProtocolExcepti
                 if (start == -1 || end <= 0) {
                     return "error";
                 } else {
-                    return mShareDecksTemplate.replace("::content::",
-                            pageHTML.substring(start, end)).replaceAll(">\nDownload(.|\n)*", ">Import</a></div>");
+                    return mShareDecksTemplate.replace("::content::", pageHTML.substring(start, end)).replaceAll(
+                            ">\nDownload(.|\n)*", ">Import</a></div>");
                 }
             }
 
+
             @Override
             protected void onPostExecute(String html) {
                 super.onPostExecute(html);
@@ -847,6 +861,7 @@ public void onProgressUpdate(Object... values) {
             }
         }
 
+
         @Override
         public void onPreExecute() {
             Log.i(AnkiDroidApp.TAG, "Info: UpgradeDecks - onPreExcecute");
@@ -854,14 +869,15 @@ public void onPreExecute() {
                 mProgressDialog = StyledProgressDialog.show(Info.this, "",
                         getResources().getString(R.string.upgrade_decks_zipping), true, false,
                         new DialogInterface.OnCancelListener() {
-                    @Override
-                    public void onCancel(DialogInterface dialogInterface) {
-                        Connection.cancelTask();
-                    }
-                });
+                            @Override
+                            public void onCancel(DialogInterface dialogInterface) {
+                                Connection.cancelTask();
+                            }
+                        });
             }
         }
 
+
         @Override
         public void onPostExecute(Payload data) {
             Log.i(AnkiDroidApp.TAG, "Info: UpgradeDecks - onPostExecute, success = " + data.success);
@@ -906,12 +922,12 @@ public void onPostExecute(Payload data) {
                     }
                     builder.setMessage(failures);
                     builder.setPositiveButton(res.getString(R.string.ok), new Dialog.OnClickListener() {
-                                @Override
-                                public void onClick(DialogInterface dialog, int which) {
-                                    setResult(RESULT_OK);
-                                    finishWithAnimation();
-                                }
-                            });
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            setResult(RESULT_OK);
+                            finishWithAnimation();
+                        }
+                    });
                     builder.setCancelable(false);
                     builder.show();
                 }
@@ -933,6 +949,7 @@ public void onClick(DialogInterface dialog, int which) {
             }
         }
 
+
         @Override
         public void onDisconnected() {
             if (mNoConnectionAlert != null) {
@@ -940,6 +957,7 @@ public void onDisconnected() {
             }
         }
 
+
         @Override
         public void onCancelled() {
             upgradeCancelled();
@@ -960,14 +978,17 @@ public void onPostExecute(DeckTask.TaskData result) {
                 finishWithAnimation();
             }
         }
+
+
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = StyledProgressDialog
-                        .show(Info.this, getResources().getString(R.string.import_title),
-                                getResources().getString(R.string.import_importing), true, false);
+                mProgressDialog = StyledProgressDialog.show(Info.this, getResources().getString(R.string.import_title),
+                        getResources().getString(R.string.import_importing), true, false);
             }
         }
+
+
         @Override
         public void onProgressUpdate(DeckTask.TaskData... values) {
             mProgressDialog.setMessage(values[0].getString());
@@ -977,6 +998,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
     Connection.TaskListener mDownloadDeckListener = new Connection.TaskListener() {
         int countDown = 0;
 
+
         @Override
         public void onProgressUpdate(Object... values) {
             countDown = ((Integer) values[0]).intValue();
@@ -986,6 +1008,7 @@ public void onProgressUpdate(Object... values) {
             }
         }
 
+
         @Override
         public void onPreExecute() {
             Log.i(AnkiDroidApp.TAG, "Info: mDownloadDeckListener - onPreExcecute");
@@ -995,6 +1018,7 @@ public void onPreExecute() {
             }
         }
 
+
         @Override
         public void onPostExecute(Payload data) {
             Log.i(AnkiDroidApp.TAG, "Info: mDownloadDeckListener - onPostExecute, success = " + data.success);
@@ -1023,6 +1047,7 @@ public void onPostExecute(Payload data) {
             }
         }
 
+
         @Override
         public void onDisconnected() {
             if (mNoConnectionAlert != null) {
@@ -1037,6 +1062,7 @@ public void onDisconnected() {
         long countUp;
         long countDown;
 
+
         @Override
         public void onDisconnected() {
             if (mNoConnectionAlert != null) {
@@ -1044,6 +1070,7 @@ public void onDisconnected() {
             }
         }
 
+
         @Override
         public void onPreExecute() {
             countUp = 0;
@@ -1057,6 +1084,7 @@ public void onPreExecute() {
             }
         }
 
+
         @Override
         public void onProgressUpdate(Object... values) {
             Resources res = getResources();
@@ -1083,6 +1111,7 @@ public void onProgressUpdate(Object... values) {
             }
         }
 
+
         @Override
         public void onPostExecute(Payload data) {
             Log.i(AnkiDroidApp.TAG, "onPostExecute");
@@ -1146,16 +1175,19 @@ public void onPostExecute(Payload data) {
         }
     };
 
+
     private void finishWithAnimation() {
         finishWithAnimation(true);
     }
 
+
     private void finishWithAnimation(boolean left) {
         finish();
-        ActivityTransitionAnimation.slide(Info.this, left ?
-                ActivityTransitionAnimation.LEFT : ActivityTransitionAnimation.RIGHT);
+        ActivityTransitionAnimation.slide(Info.this, left ? ActivityTransitionAnimation.LEFT
+                : ActivityTransitionAnimation.RIGHT);
     }
 
+
     private void lockScreenOrientation() {
         if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
             setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
@@ -1164,6 +1196,7 @@ private void lockScreenOrientation() {
         }
     }
 
+
     public void upgradeCancelled() {
         StyledDialog.Builder builder = new StyledDialog.Builder(Info.this);
         builder.setTitle(getString(R.string.upgrade_deck_cancelled_title));
@@ -1181,5 +1214,4 @@ public void onClick(DialogInterface dialogInterface, int i) {
         builder.show();
     }
 
-
 }
diff --git a/src/com/ichi2/anki/Lookup.java b/src/com/ichi2/anki/Lookup.java
index 86f643b89183..f19bf752dfb8 100644
--- a/src/com/ichi2/anki/Lookup.java
+++ b/src/com/ichi2/anki/Lookup.java
@@ -17,8 +17,8 @@ public class Lookup {
     /**
      * Searches
      */
-    private static final int DICTIONARY_NONE = 0;      // use no dictionary
-    private static final int DICTIONARY_AEDICT = 1;     // Japanese dictionary
+    private static final int DICTIONARY_NONE = 0;    // use no dictionary
+    private static final int DICTIONARY_AEDICT = 1;  // Japanese dictionary
     private static final int DICTIONARY_EIJIRO_WEB = 2; // japanese web dictionary
     private static final int DICTIONARY_LEO_WEB = 3; // German web dictionary for English, French, Spanish, Italian,
                                                      // Chinese, Russian
@@ -76,9 +76,9 @@ public static boolean initialize(Context context) {
 
 
     public static boolean lookUp(String text) {
-    	if (!mIsDictionaryAvailable) {
-    		return false;
-    	}
+        if (!mIsDictionaryAvailable) {
+            return false;
+        }
         // clear text from leading and closing dots, commas, brackets etc.
         text = text.trim().replaceAll("[,;:\\s\\(\\[\\)\\]\\.]*$", "").replaceAll("^[,;:\\s\\(\\[\\)\\]\\.]*", "");
         switch (mDictionary) {
diff --git a/src/com/ichi2/anki/MetaDB.java b/src/com/ichi2/anki/MetaDB.java
index d4b1ef457b91..bbedcad41e8f 100644
--- a/src/com/ichi2/anki/MetaDB.java
+++ b/src/com/ichi2/anki/MetaDB.java
@@ -215,17 +215,16 @@ public static boolean resetIntentInformation(Context context) {
 
     /**
      * Associates a language to a deck, model, and card model for a given type.
-     *
+     * 
      * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
      *            {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED}
      * @param language the language to associate, as a two-characters, lowercase string
      */
-    public static void storeLanguage(Context context, long did, int ord, int qa,
-            String language) {
+    public static void storeLanguage(Context context, long did, int ord, int qa, String language) {
         openDBIfClosed(context);
         try {
-            mMetaDb.execSQL("INSERT INTO languages (did, ord, qa, language) "
-                    + " VALUES (?, ?, ?, ?);", new Object[] { did, ord, qa, language });
+            mMetaDb.execSQL("INSERT INTO languages (did, ord, qa, language) " + " VALUES (?, ?, ?, ?);", new Object[] {
+                    did, ord, qa, language });
             Log.i(AnkiDroidApp.TAG, "Store language for deck " + did);
         } catch (Exception e) {
             Log.e("Error", "Error storing language in MetaDB ", e);
@@ -235,7 +234,7 @@ public static void storeLanguage(Context context, long did, int ord, int qa,
 
     /**
      * Returns the language associated with the given deck, model and card model, for the given type.
-     *
+     * 
      * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
      *            {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED} return the language associate with
      *            the type, as a two-characters, lowercase string, or the empty string if no association is defined
@@ -245,8 +244,8 @@ public static String getLanguage(Context context, long did, int ord, int qa) {
         String language = "";
         Cursor cur = null;
         try {
-            String query = "SELECT language FROM languages " + "WHERE did = " + did + " AND ord = " + ord + " AND qa = " + qa
-                    + " " + "LIMIT 1";
+            String query = "SELECT language FROM languages " + "WHERE did = " + did + " AND ord = " + ord
+                    + " AND qa = " + qa + " " + "LIMIT 1";
             cur = mMetaDb.rawQuery(query, null);
             Log.i(AnkiDroidApp.TAG, "getLanguage: " + query);
             if (cur.moveToNext()) {
@@ -265,7 +264,7 @@ public static String getLanguage(Context context, long did, int ord, int qa) {
 
     /**
      * Resets all the language associates for a given deck.
-     *
+     * 
      * @return whether an error occurred while resetting the language for the deck
      */
     public static boolean resetDeckLanguages(Context context, long did) {
@@ -283,7 +282,7 @@ public static boolean resetDeckLanguages(Context context, long did) {
 
     /**
      * Returns the state of the whiteboard for the given deck.
-     *
+     * 
      * @return 1 if the whiteboard should be shown, 0 otherwise
      */
     public static int getWhiteboardState(Context context, long did) {
@@ -309,7 +308,7 @@ public static int getWhiteboardState(Context context, long did) {
 
     /**
      * Stores the state of the whiteboard for a given deck.
-     *
+     * 
      * @param state 1 if the whiteboard should be shown, 0 otherwise
      */
     public static void storeWhiteboardState(Context context, long did, int state) {
@@ -322,8 +321,7 @@ public static void storeWhiteboardState(Context context, long did, int state) {
                         + Integer.toString(state) + " " + "WHERE _id=" + cur.getString(0) + ";");
                 Log.i(AnkiDroidApp.TAG, "Store whiteboard state (" + state + ") for deck " + did);
             } else {
-                mMetaDb.execSQL("INSERT INTO whiteboardState (did, state) VALUES (?, ?)", new Object[] { did,
-                        state });
+                mMetaDb.execSQL("INSERT INTO whiteboardState (did, state) VALUES (?, ?)", new Object[] { did, state });
                 Log.i(AnkiDroidApp.TAG, "Store whiteboard state (" + state + ") for deck " + did);
             }
         } catch (Exception e) {
@@ -338,15 +336,14 @@ public static void storeWhiteboardState(Context context, long did, int state) {
 
     /**
      * Returns a custom dictionary associated to a deck
-     *
+     * 
      * @return integer number of dictionary, -1 if not set (standard dictionary will be used)
      */
     public static int getLookupDictionary(Context context, long did) {
         openDBIfClosed(context);
         Cursor cur = null;
         try {
-            cur = mMetaDb.rawQuery("SELECT dictionary FROM customDictionary" + " WHERE did = "
-                    + did, null);
+            cur = mMetaDb.rawQuery("SELECT dictionary FROM customDictionary" + " WHERE did = " + did, null);
             if (cur.moveToNext()) {
                 return cur.getInt(0);
             } else {
@@ -365,7 +362,7 @@ public static int getLookupDictionary(Context context, long did) {
 
     /**
      * Stores a custom dictionary for a given deck.
-     *
+     * 
      * @param dictionary integer number of dictionary, -1 if not set (standard dictionary will be used)
      */
     public static void storeLookupDictionary(Context context, long did, int dictionary) {
@@ -378,8 +375,8 @@ public static void storeLookupDictionary(Context context, long did, int dictiona
                         + Integer.toString(dictionary) + " " + "WHERE _id=" + cur.getString(0) + ";");
                 Log.i(AnkiDroidApp.TAG, "Store custom dictionary (" + dictionary + ") for deck " + did);
             } else {
-                mMetaDb.execSQL("INSERT INTO customDictionary (did, dictionary) VALUES (?, ?)", new Object[] {
-                        did, dictionary });
+                mMetaDb.execSQL("INSERT INTO customDictionary (did, dictionary) VALUES (?, ?)", new Object[] { did,
+                        dictionary });
                 Log.i(AnkiDroidApp.TAG, "Store custom dictionary (" + dictionary + ") for deck " + did);
             }
         } catch (Exception e) {
@@ -394,7 +391,7 @@ public static void storeLookupDictionary(Context context, long did, int dictiona
 
     /**
      * Return the current status of the widget.
-     *
+     * 
      * @return an array of {@link DeckStatus} objects, each representing the status of one of the known decks
      */
     public static DeckStatus[] getWidgetStatus(Context context) {
@@ -430,16 +427,17 @@ public static DeckStatus[] getWidgetStatus(Context context) {
 
     /**
      * Return the current status of the widget.
-     *
+     * 
      * @return an int array, containing due, progress, eta
      */
     public static int[] getWidgetSmallStatus(Context context) {
         openDBIfClosed(context);
         Cursor cursor = null;
         try {
-            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "progress", "left", "eta" }, null, null, null, null, null);
+            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "progress", "left", "eta" }, null, null, null,
+                    null, null);
             while (cursor.moveToNext()) {
-            	return (new int[]{ cursor.getInt(0), cursor.getInt(1), cursor.getInt(2)});
+                return (new int[] { cursor.getInt(0), cursor.getInt(1), cursor.getInt(2) });
             }
         } catch (SQLiteException e) {
             Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
@@ -457,14 +455,13 @@ public static int getNotificationStatus(Context context) {
         Cursor cursor = null;
         int due = 0;
         try {
-            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "left" }, null, null,
-                    null, null, null);
+            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "left" }, null, null, null, null, null);
             if (cursor.moveToFirst()) {
-            	return cursor.getInt(0);
+                return cursor.getInt(0);
             }
-//            while (cursor.moveToNext()) {
-//                due += cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
-//            }
+            // while (cursor.moveToNext()) {
+            // due += cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
+            // }
         } catch (SQLiteException e) {
             Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
         } finally {
@@ -483,7 +480,8 @@ public static void storeSmallWidgetStatus(Context context, float[] progress) {
             try {
                 // First clear all the existing content.
                 mMetaDb.execSQL("DELETE FROM smallWidgetStatus");
-                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(progress, left, eta) VALUES (?, ?, ?)", new Object[] {(int)(progress[1] * 1000), (int)progress[2], (int)progress[3]});
+                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(progress, left, eta) VALUES (?, ?, ?)", new Object[] {
+                        (int) (progress[1] * 1000), (int) progress[2], (int) progress[3] });
                 mMetaDb.setTransactionSuccessful();
             } finally {
                 mMetaDb.endTransaction();
@@ -502,7 +500,7 @@ public static void storeSmallWidgetStatus(Context context, float[] progress) {
      * Stores the current state of the widget.
      * <p>
      * It replaces any stored state for the widget.
-     *
+     * 
      * @param decks an array of {@link DeckStatus} objects, one for each of the know decks.
      */
     public static void storeWidgetStatus(Context context, DeckStatus[] decks) {
@@ -546,13 +544,13 @@ public static ArrayList<HashMap<String, String>> getIntentInformation(Context co
                 String source = null;
                 String target = null;
                 for (int i = 0; i < split.length; i++) {
-                	if (source == null || source.length() == 0) {
-                		source = split[i];
-                	} else if (target == null || target.length() == 0) {
-                		target = split[i];
-                	} else {
-                		break;
-                	}
+                    if (source == null || source.length() == 0) {
+                        source = split[i];
+                    } else if (target == null || target.length() == 0) {
+                        target = split[i];
+                    } else {
+                        break;
+                    }
                 }
                 item.put("source", source);
                 item.put("target", target);
diff --git a/src/com/ichi2/anki/MyAccount.java b/src/com/ichi2/anki/MyAccount.java
index 30f562c1ac1d..98111e09b3b3 100644
--- a/src/com/ichi2/anki/MyAccount.java
+++ b/src/com/ichi2/anki/MyAccount.java
@@ -155,7 +155,8 @@ private void logout() {
 
         setContentView(mLoginToMyAccountView);
     }
-    
+
+
     private void resetPassword() {
         Intent intent = new Intent(Intent.ACTION_VIEW);
         intent.setData(Uri.parse(getResources().getString(R.string.resetpw_url)));
@@ -184,11 +185,11 @@ public void onClick(View v) {
         Button resetPWButton = (Button) mLoginToMyAccountView.findViewById(R.id.reset_password_button);
         resetPWButton.setOnClickListener(new OnClickListener() {
 
-			@Override
-			public void onClick(View v) {
-				resetPassword();		
-			}
-		});
+            @Override
+            public void onClick(View v) {
+                resetPassword();
+            }
+        });
 
         Button signUpButton = (Button) mLoginToMyAccountView.findViewById(R.id.sign_up_button);
         signUpButton.setOnClickListener(new OnClickListener() {
diff --git a/src/com/ichi2/anki/Pair.java b/src/com/ichi2/anki/Pair.java
index 994f70fe2061..332728429222 100644
--- a/src/com/ichi2/anki/Pair.java
+++ b/src/com/ichi2/anki/Pair.java
@@ -14,10 +14,12 @@ public Pair(FIRST first, SECOND second) {
         this.second = second;
     }
 
+
     public static <FIRST, SECOND> Pair<FIRST, SECOND> create(FIRST first, SECOND second) {
         return new Pair<FIRST, SECOND>(first, second);
     }
 
+
     @Override
     public int hashCode() {
         return 31 * hashcode(first) + hashcode(second);
diff --git a/src/com/ichi2/anki/Preferences.java b/src/com/ichi2/anki/Preferences.java
index aa0e53dc262a..e003d32eb204 100644
--- a/src/com/ichi2/anki/Preferences.java
+++ b/src/com/ichi2/anki/Preferences.java
@@ -72,7 +72,7 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     private static final int DIALOG_BACKUP = 2;
     private static final int DIALOG_HEBREW_FONT = 3;
     private static final int DIALOG_WRITE_ANSWERS = 4;
-    public static boolean COMING_FROM_ADD=false;
+    public static boolean COMING_FROM_ADD = false;
 
     // private boolean mVeecheckStatus;
     private Collection mCol;
@@ -88,13 +88,13 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     private ListPreference mLanguageSelection;
     private CharSequence[] mLanguageDialogLabels;
     private CharSequence[] mLanguageDialogValues;
-    private static String[] mAppLanguages = { "ar", "bg", "ca", "cs", "de", "el", "es-AR", "es-ES", "et", "fa", "fi", "fr", "gl", "hi", "hu", "id",
-            "it", "ja", "ko", "lt", "nl", "no", "pl", "pt_PT", "pt_BR", "ro", "ru", "sk", "sl", "sr", "sv", "th", "tr", "uk", "vi",
-            "zh_CN", "zh_TW", "en" };
+    private static String[] mAppLanguages = { "ar", "bg", "ca", "cs", "de", "el", "es-AR", "es-ES", "et", "fa", "fi",
+            "fr", "gl", "hi", "hu", "id", "it", "ja", "ko", "lt", "nl", "no", "pl", "pt_PT", "pt_BR", "ro", "ru", "sk",
+            "sl", "sr", "sv", "th", "tr", "uk", "vi", "zh_CN", "zh_TW", "en" };
     private static String[] mShowValueInSummList = { "language", "dictionary", "reportErrorMode",
             "minimumCardsDueForNotification", "gestureSwipeUp", "gestureSwipeDown", "gestureSwipeLeft",
             "gestureSwipeRight", "gestureDoubleTap", "gestureTapTop", "gestureTapBottom", "gestureTapRight",
-            "gestureLongclick", "gestureTapLeft", "newSpread", "useCurrent"};//, "theme" };
+            "gestureLongclick", "gestureTapLeft", "newSpread", "useCurrent" };// , "theme" };
     private static String[] mShowValueInSummSeek = { "relativeDisplayFontSize", "relativeCardBrowserFontSize",
             "relativeImageSize", "answerButtonSize", "whiteBoardStrokeWidth", "swipeSensibility",
             "timeoutAnswerSeconds", "timeoutQuestionSeconds", "backupMax", "dayOffset" };
@@ -117,6 +117,7 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     private ListPreference newSpread;
     private SeekBarPreference dayOffset;
 
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         // Workaround for bug 4611: http://code.google.com/p/android/issues/detail?id=4611
@@ -136,7 +137,7 @@ protected void onCreate(Bundle savedInstanceState) {
         showAnswerCheckBoxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("timeoutAnswer");
         useBackupPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("useBackup");
         eInkDisplayPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("eInkDisplay");
-//        ListPreference listpref = (ListPreference) getPreferenceScreen().findPreference("theme");
+        // ListPreference listpref = (ListPreference) getPreferenceScreen().findPreference("theme");
         convertFenText = (CheckBoxPreference) getPreferenceScreen().findPreference("convertFenText");
         fixHebrewText = (CheckBoxPreference) getPreferenceScreen().findPreference("fixHebrewText");
         syncAccount = (Preference) getPreferenceScreen().findPreference("syncAccount");
@@ -147,9 +148,8 @@ protected void onCreate(Bundle savedInstanceState) {
         useCurrent = (ListPreference) getPreferenceScreen().findPreference("useCurrent");
         newSpread = (ListPreference) getPreferenceScreen().findPreference("newSpread");
         dayOffset = (SeekBarPreference) getPreferenceScreen().findPreference("dayOffset");
-//        String theme = listpref.getValue();
-//        animationsCheckboxPreference.setEnabled(theme.equals("2") || theme.equals("3"));
-
+        // String theme = listpref.getValue();
+        // animationsCheckboxPreference.setEnabled(theme.equals("2") || theme.equals("3"));
 
         initializeLanguageDialog();
         initializeCustomFontsDialog();
@@ -157,7 +157,7 @@ protected void onCreate(Bundle savedInstanceState) {
         if (mCol != null) {
             // For collection preferences, we need to fetch the correct values from the collection
             mStartDate = GregorianCalendar.getInstance();
-            Timestamp timestamp = new Timestamp(mCol.getCrt()*1000);
+            Timestamp timestamp = new Timestamp(mCol.getCrt() * 1000);
             mStartDate.setTimeInMillis(timestamp.getTime());
             dayOffset.setValue(mStartDate.get(Calendar.HOUR_OF_DAY));
             try {
@@ -167,7 +167,7 @@ protected void onCreate(Bundle savedInstanceState) {
                 showEstimates.setChecked(conf.getBoolean("estTimes"));
                 showProgress.setChecked(conf.getBoolean("dueCounts"));
                 newSpread.setValueIndex(conf.getInt("newSpread"));
-                useCurrent.setValueIndex(conf.optBoolean("addToCur",true) ? 0 : 1);
+                useCurrent.setValueIndex(conf.optBoolean("addToCur", true) ? 0 : 1);
             } catch (JSONException e) {
                 throw new RuntimeException();
             } catch (NumberFormatException e) {
@@ -186,7 +186,6 @@ protected void onCreate(Bundle savedInstanceState) {
             useCurrent.setEnabled(false);
         }
 
-
         for (String key : mShowValueInSummList) {
             updateListPreference(key);
         }
@@ -236,14 +235,14 @@ private void updateEditTextPreference(String key) {
             entry = "?";
         }
         if (mListsToUpdate.containsKey(key)) {
-        	pref.setSummary(replaceString(mListsToUpdate.get(key), entry));
+            pref.setSummary(replaceString(mListsToUpdate.get(key), entry));
         } else {
             String oldsum = (String) pref.getSummary();
             if (oldsum.contains("XXX")) {
                 mListsToUpdate.put(key, oldsum);
                 pref.setSummary(replaceString(oldsum, entry));
             } else {
-            	pref.setSummary(entry);
+                pref.setSummary(entry);
             }
         }
     }
@@ -275,20 +274,21 @@ private void updateNumberRangePreference(String key) {
             String value = Integer.toString(numPref.getValue());
             if (mListsToUpdate.containsKey(key)) {
                 numPref.setSummary(replaceString(mListsToUpdate.get(key), value));
-             } else {
-                 String oldSum = (String) numPref.getSummary();
-                 if (oldSum.contains("XXX")) {
-                     mListsToUpdate.put(key,  oldSum);
-                     numPref.setSummary(replaceString(oldSum, value));
-                 } else {
-                     numPref.setSummary(value);
-                 }
-             }
+            } else {
+                String oldSum = (String) numPref.getSummary();
+                if (oldSum.contains("XXX")) {
+                    mListsToUpdate.put(key, oldSum);
+                    numPref.setSummary(replaceString(oldSum, value));
+                } else {
+                    numPref.setSummary(value);
+                }
+            }
         } catch (NullPointerException e) {
             Log.e(AnkiDroidApp.TAG, "Exception when updating NumberRangePreference: " + e);
         }
     }
 
+
     private String replaceString(String str, String value) {
         if (str.contains("XXX")) {
             return str.replace("XXX", value);
@@ -339,7 +339,8 @@ private void initializeCustomFontsDialog() {
         }
         onOverrideFontChange(overrideFontPreference, defaultFontPreference);
 
-        ListPreference browserEditorCustomFontsPreference = (ListPreference) getPreferenceScreen().findPreference("browserEditorFont");
+        ListPreference browserEditorCustomFontsPreference = (ListPreference) getPreferenceScreen().findPreference(
+                "browserEditorFont");
         browserEditorCustomFontsPreference.setEntries(getCustomFonts("System default"));
         browserEditorCustomFontsPreference.setEntryValues(getCustomFonts("", true));
     }
@@ -351,12 +352,15 @@ private void onOverrideFontChange(ListPreference overrideFontPreference, ListPre
             defaultFontPreference.setEnabled(!overrideIsSet);
         }
     }
+
+
     @Override
     protected void onPause() {
         super.onPause();
         getPreferenceScreen().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);
     }
 
+
     @Override
     protected void onResume() {
         super.onResume();
@@ -428,15 +432,15 @@ public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, Strin
                 mCol.setMod();
             } else if (key.equals("dayOffset")) {
                 int hours = dayOffset.getValue();
-                Calendar date = (Calendar)mStartDate.clone();
+                Calendar date = (Calendar) mStartDate.clone();
                 date.set(Calendar.HOUR_OF_DAY, hours);
                 mCol.setCrt(date.getTimeInMillis() / 1000);
                 mCol.setMod();
             } else if (key.equals("overrideFont")) {
-                ListPreference overrideFontPreference =
-                        (ListPreference) getPreferenceScreen().findPreference("overrideFont");
-                ListPreference defaultFontPreference =
-                        (ListPreference) getPreferenceScreen().findPreference("defaultFont");
+                ListPreference overrideFontPreference = (ListPreference) getPreferenceScreen().findPreference(
+                        "overrideFont");
+                ListPreference defaultFontPreference = (ListPreference) getPreferenceScreen().findPreference(
+                        "defaultFont");
                 onOverrideFontChange(overrideFontPreference, defaultFontPreference);
             }
             if (Arrays.asList(mShowValueInSummList).contains(key)) {
@@ -462,6 +466,8 @@ public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, Strin
     private String[] getCustomFonts(String defaultValue) {
         return getCustomFonts(defaultValue, false);
     }
+
+
     private String[] getCustomFonts(String defaultValue, boolean useFullPath) {
         List<AnkiFont> mFonts = Utils.getCustomFonts(this);
         int count = mFonts.size();
@@ -470,12 +476,12 @@ private String[] getCustomFonts(String defaultValue, boolean useFullPath) {
         names[0] = defaultValue;
         if (useFullPath) {
             for (int index = 1; index < count + 1; ++index) {
-                names[index] = mFonts.get(index-1).getPath();
+                names[index] = mFonts.get(index - 1).getPath();
                 Log.d(AnkiDroidApp.TAG, "Adding custom font: " + names[index]);
             }
         } else {
             for (int index = 1; index < count + 1; ++index) {
-                names[index] = mFonts.get(index-1).getName();
+                names[index] = mFonts.get(index - 1).getName();
                 Log.d(AnkiDroidApp.TAG, "Adding custom font: " + names[index]);
             }
         }
@@ -535,17 +541,16 @@ public void onClick(DialogInterface arg0, int arg1) {
                 builder.setTitle(res.getString(R.string.fix_hebrew_text));
                 builder.setCancelable(false);
                 builder.setMessage(res.getString(R.string.fix_hebrew_instructions,
-                		AnkiDroidApp.getCurrentAnkiDroidDirectory()));
+                        AnkiDroidApp.getCurrentAnkiDroidDirectory()));
                 builder.setNegativeButton(R.string.cancel, null);
-                builder.setPositiveButton(
-                        res.getString(R.string.fix_hebrew_download_font), new OnClickListener(){
-                            @Override
-                            public void onClick(DialogInterface dialog, int which) {
-                                Intent intent = new Intent("android.intent.action.VIEW",
-                                        Uri.parse(getResources().getString(R.string.link_hebrew_font)));
-                                startActivity(intent);
-                            }
-                        });
+                builder.setPositiveButton(res.getString(R.string.fix_hebrew_download_font), new OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        Intent intent = new Intent("android.intent.action.VIEW", Uri.parse(getResources().getString(
+                                R.string.link_hebrew_font)));
+                        startActivity(intent);
+                    }
+                });
                 break;
         }
         return builder.create();
diff --git a/src/com/ichi2/anki/Previewer.java b/src/com/ichi2/anki/Previewer.java
index 1977e486c282..ec0e6668d6fa 100644
--- a/src/com/ichi2/anki/Previewer.java
+++ b/src/com/ichi2/anki/Previewer.java
@@ -81,7 +81,8 @@ protected void displayCardAnswer() {
     protected void updateScreenCounts() {
     }
 
-    //No Gestures!
+
+    // No Gestures!
     @Override
     protected void executeCommand(int which) {
     }
diff --git a/src/com/ichi2/anki/ReadText.java b/src/com/ichi2/anki/ReadText.java
index 35c6e3daa8b5..dd3068d1db52 100644
--- a/src/com/ichi2/anki/ReadText.java
+++ b/src/com/ichi2/anki/ReadText.java
@@ -40,6 +40,7 @@ public class ReadText {
     public static ArrayList<String[]> sTextQueue = new ArrayList<String[]>();
     public static HashMap<String, String> mTtsParams;
 
+
     // private boolean mTtsReady = false;
 
     public static void speak(String text, String loc) {
@@ -47,11 +48,11 @@ public static void speak(String text, String loc) {
         if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
             Log.e(AnkiDroidApp.TAG, "Error loading locale " + loc.toString());
         } else {
-        	if (mTts.isSpeaking()) {
-        		sTextQueue.add(new String[]{text, loc});
-        	} else {
+            if (mTts.isSpeaking()) {
+                sTextQueue.add(new String[] { text, loc });
+            } else {
                 mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, mTtsParams);
-        	}
+            }
         }
     }
 
@@ -112,8 +113,7 @@ public static void textToSpeech(String text, long did, int ord, int qa) {
             builder.setItems(items, new DialogInterface.OnClickListener() {
                 @Override
                 public void onClick(DialogInterface dialog, int which) {
-                    MetaDB.storeLanguage(mReviewer, mDid, mOrd, mQuestionAnswer,
-                            dialogIds.get(which));
+                    MetaDB.storeLanguage(mReviewer, mDid, mOrd, mQuestionAnswer, dialogIds.get(which));
                     speak(mTextToSpeak, dialogIds.get(which));
                 }
             });
@@ -141,7 +141,7 @@ public void onInit(int status) {
             }
         });
         mTtsParams = new HashMap<String, String>();
-        mTtsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID,"stringId");
+        mTtsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "stringId");
     }
 
 
@@ -155,9 +155,9 @@ public static void releaseTts() {
 
     public static void stopTts() {
         if (mTts != null) {
-        	if (sTextQueue != null) {
-        		sTextQueue.clear();
-        	}
+            if (sTextQueue != null) {
+                sTextQueue.clear();
+            }
             mTts.stop();
         }
     }
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 3e2e46023eea..3acbc21485fe 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -35,19 +35,21 @@ protected void setTitle() {
         AnkiDroidApp.getCompat().setSubtitle(this, "", mInvertedColors);
     }
 
+
     @Override
     protected void initActivity(Collection col) {
         super.initActivity(col);
         // Load the first card and start reviewing. Uses the answer card
         // task to load a card, but since we send null
         // as the card to answer, no card will be answered.
-        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(mSched,
-                null, 0)); 
+        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(mSched, null,
+                0));
 
         // Since we aren't actually answering a card, decrement the rep count
         mSched.setReps(mSched.getReps() - 1);
     }
 
+
     @Override
     public void displayCardQuestion() {
         // show timer, if activated in the deck's preferences
diff --git a/src/com/ichi2/anki/StudyOptionsActivity.java b/src/com/ichi2/anki/StudyOptionsActivity.java
index 334267f4c03a..d2ab7c99998c 100644
--- a/src/com/ichi2/anki/StudyOptionsActivity.java
+++ b/src/com/ichi2/anki/StudyOptionsActivity.java
@@ -44,6 +44,7 @@ public class StudyOptionsActivity extends ActionBarActivity {
     private StyledOpenCollectionDialog mNotMountedDialog;
     private EditText mDialogEditText = null;
 
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         Themes.applyTheme(this);
@@ -58,9 +59,12 @@ protected void onCreate(Bundle savedInstanceState) {
         registerExternalStorageListener();
     }
 
+
     public void loadContent(boolean onlyFnsMsg) {
         loadContent(onlyFnsMsg, null);
     }
+
+
     public void loadContent(boolean onlyFnsMsg, Bundle cramConfig) {
         mCurrentFragment = StudyOptionsFragment.newInstance(0, false, null);
         Bundle args = getIntent().getExtras();
@@ -74,8 +78,8 @@ public void loadContent(boolean onlyFnsMsg, Bundle cramConfig) {
         getSupportFragmentManager().beginTransaction().add(R.id.studyoptions_frame, mCurrentFragment).commit();
     }
 
-    // TODO: onpause, onresume, onstop
 
+    // TODO: onpause, onresume, onstop
 
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
@@ -107,7 +111,6 @@ public void onActivityResult(int requestCode, int resultCode, Intent intent) {
     }
 
 
-
     private void closeStudyOptions() {
         closeStudyOptions(RESULT_OK);
     }
@@ -145,6 +148,7 @@ public void onStop() {
         }
     }
 
+
     @Override
     public void onDestroy() {
         super.onDestroy();
@@ -153,15 +157,17 @@ public void onDestroy() {
         }
     }
 
+
     @Override
     public boolean onTouchEvent(MotionEvent event) {
-    	if (mCurrentFragment != null) {
-    		return mCurrentFragment.onTouchEvent(event);
-    	} else {
-    		return false;
-    	}
+        if (mCurrentFragment != null) {
+            return mCurrentFragment.onTouchEvent(event);
+        } else {
+            return false;
+        }
     }
 
+
     /**
      * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)
      */
@@ -171,7 +177,8 @@ private void registerExternalStorageListener() {
                 @Override
                 public void onReceive(Context context, Intent intent) {
                     if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
-                		mNotMountedDialog = StyledOpenCollectionDialog.show(StudyOptionsActivity.this, getResources().getString(R.string.sd_card_not_mounted), new OnCancelListener() {
+                        mNotMountedDialog = StyledOpenCollectionDialog.show(StudyOptionsActivity.this, getResources()
+                                .getString(R.string.sd_card_not_mounted), new OnCancelListener() {
 
                             @Override
                             public void onCancel(DialogInterface arg0) {
@@ -179,10 +186,10 @@ public void onCancel(DialogInterface arg0) {
                             }
                         });
                     } else if (intent.getAction().equals(SdCardReceiver.MEDIA_MOUNT)) {
-                    	if (mNotMountedDialog != null && mNotMountedDialog.isShowing()) {
-                    		mNotMountedDialog.dismiss();
-                    	}
-                    	mCurrentFragment.reloadCollection();
+                        if (mNotMountedDialog != null && mNotMountedDialog.isShowing()) {
+                            mNotMountedDialog.dismiss();
+                        }
+                        mCurrentFragment.reloadCollection();
                     }
                 }
             };
diff --git a/src/com/ichi2/anki/StudyOptionsFragment.java b/src/com/ichi2/anki/StudyOptionsFragment.java
index e005330e929d..3039f7a1100d 100644
--- a/src/com/ichi2/anki/StudyOptionsFragment.java
+++ b/src/com/ichi2/anki/StudyOptionsFragment.java
@@ -116,7 +116,6 @@ public class StudyOptionsFragment extends Fragment {
 
     private int mCustomDialogChoice;
 
-
     private HashMap<Integer, StyledDialog> mDialogs = new HashMap<Integer, StyledDialog>();
 
     /**
@@ -141,9 +140,9 @@ public class StudyOptionsFragment extends Fragment {
     private Button mButtonStart;
     private Button mButtonCustomStudy;
     private Button mButtonUnbury;
-//    private Button mButtonUp;
-//    private Button mButtonDown;
-//    private ToggleButton mToggleLimitToggle;
+    // private Button mButtonUp;
+    // private Button mButtonDown;
+    // private ToggleButton mToggleLimitToggle;
     private TextView mTextDeckName;
     private TextView mTextDeckDescription;
     private TextView mTextTodayNew;
@@ -165,8 +164,8 @@ public class StudyOptionsFragment extends Fragment {
      * UI elements for "Congrats" view
      */
     private View mCongratsView;
-//    private View mLearnMoreView;
-//    private View mReviewEarlyView;
+    // private View mLearnMoreView;
+    // private View mReviewEarlyView;
     private TextView mTextCongratsMessage;
     private Button mButtonCongratsUndo;
     private Button mButtonCongratsUnbury;
@@ -201,48 +200,48 @@ public class StudyOptionsFragment extends Fragment {
     private View.OnClickListener mButtonClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
-        	Collection col = AnkiDroidApp.getCol();
-//            long timeLimit = 0;
+            Collection col = AnkiDroidApp.getCol();
+            // long timeLimit = 0;
             switch (v.getId()) {
                 case R.id.studyoptions_start:
                     openReviewer();
                     return;
                 case R.id.studyoptions_custom:
-                	showDialog(DIALOG_CUSTOM_STUDY);
-                	return;
+                    showDialog(DIALOG_CUSTOM_STUDY);
+                    return;
                 case R.id.studyoptions_unbury:
                     col.getSched().unburyCards();
                     resetAndUpdateValuesFromDeck();
                     mButtonUnbury.setVisibility(View.GONE);
                     return;
-//                case R.id.studyoptions_limitup:
-//                    timeLimit = (mCol.getTimeLimit() / 60);
-//                    mCol.setTimeLimit((timeLimit + 1) * 60);
-//                    mToggleLimitToggle.setChecked(true);
-//                    mToggleLimitToggle.setText(String.valueOf(timeLimit + 1));
-//                    return;
-//                case R.id.studyoptions_limitdown:
-//                    timeLimit = (mCol.getTimeLimit() / 60);
-//                    if (timeLimit > 1) {
-//                        mCol.setTimeLimit((timeLimit - 1) * 60);
-//                        mToggleLimitToggle.setChecked(true);
-//                        mToggleLimitToggle.setText(String.valueOf(timeLimit - 1));
-//                    } else if (timeLimit == 1) {
-//                        mCol.setTimeLimit(0);
-//                        mToggleLimitToggle.setChecked(false);
-//                    }
-//                    return;
-//                case R.id.studyoptions_limittoggle:
-//                    timeLimit = (mCol.getTimeLimit() / 60);
-//                    if (timeLimit > 0) {
-//                        mToggleLimitToggle.setChecked(false);
-//                        mCol.setTimeLimit(0);
-//                    } else {
-//                        mToggleLimitToggle.setChecked(true);
-//                        mToggleLimitToggle.setText("1");
-//                        mCol.setTimeLimit(60);
-//                    }
-//                    return;
+                    // case R.id.studyoptions_limitup:
+                    // timeLimit = (mCol.getTimeLimit() / 60);
+                    // mCol.setTimeLimit((timeLimit + 1) * 60);
+                    // mToggleLimitToggle.setChecked(true);
+                    // mToggleLimitToggle.setText(String.valueOf(timeLimit + 1));
+                    // return;
+                    // case R.id.studyoptions_limitdown:
+                    // timeLimit = (mCol.getTimeLimit() / 60);
+                    // if (timeLimit > 1) {
+                    // mCol.setTimeLimit((timeLimit - 1) * 60);
+                    // mToggleLimitToggle.setChecked(true);
+                    // mToggleLimitToggle.setText(String.valueOf(timeLimit - 1));
+                    // } else if (timeLimit == 1) {
+                    // mCol.setTimeLimit(0);
+                    // mToggleLimitToggle.setChecked(false);
+                    // }
+                    // return;
+                    // case R.id.studyoptions_limittoggle:
+                    // timeLimit = (mCol.getTimeLimit() / 60);
+                    // if (timeLimit > 0) {
+                    // mToggleLimitToggle.setChecked(false);
+                    // mCol.setTimeLimit(0);
+                    // } else {
+                    // mToggleLimitToggle.setChecked(true);
+                    // mToggleLimitToggle.setText("1");
+                    // mCol.setTimeLimit(60);
+                    // }
+                    // return;
                 case R.id.studyoptions_congrats_undo:
                     if (AnkiDroidApp.colIsOpen()) {
                         col.undo();
@@ -301,6 +300,8 @@ public void onClick(View v) {
     private void openCramDeckOptions() {
         openCramDeckOptions(null);
     }
+
+
     private void openCramDeckOptions(Bundle initialConfig) {
         Intent i = new Intent(getActivity(), CramDeckOptions.class);
         i.putExtra("cramInitialConfig", initialConfig);
@@ -313,7 +314,7 @@ private void rebuildCramDeck() {
         mProgressDialog = StyledProgressDialog.show(getActivity(), "",
                 getResources().getString(R.string.rebuild_cram_deck), true);
         DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, mUpdateValuesFromDeckListener, new DeckTask.TaskData(
-        		AnkiDroidApp.getCol(), AnkiDroidApp.getCol().getDecks().selected(), mFragmented));
+                AnkiDroidApp.getCol(), AnkiDroidApp.getCol().getDecks().selected(), mFragmented));
     }
 
 
@@ -369,10 +370,10 @@ protected View createView(LayoutInflater inflater, Bundle savedInstanceState) {
             return null;
         }
 
-//        Intent intent = getActivity().getIntent();
-//        if (intent != null && intent.hasExtra(DeckPicker.EXTRA_DECK_ID)) {
-//            mCol.getDecks().select(intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1));
-//        }
+        // Intent intent = getActivity().getIntent();
+        // if (intent != null && intent.hasExtra(DeckPicker.EXTRA_DECK_ID)) {
+        // mCol.getDecks().select(intent.getLongExtra(DeckPicker.EXTRA_DECK_ID, 1));
+        // }
 
         initAllContentViews(inflater);
 
@@ -389,10 +390,10 @@ public boolean onTouch(View v, MotionEvent event) {
         }
 
         if (getArguments().getBoolean("onlyFnsMsg")) {
-        	prepareCongratsView();
+            prepareCongratsView();
             return mCongratsView;
         } else {
-        	// clear undo if new deck is opened (do not clear if only congrats msg is shown)
+            // clear undo if new deck is opened (do not clear if only congrats msg is shown)
             AnkiDroidApp.getCol().clearUndo();
         }
 
@@ -409,10 +410,10 @@ public boolean onTouch(View v, MotionEvent event) {
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         Log.i(AnkiDroidApp.TAG, "onConfigurationChanged");
-	if (mTextDeckName == null) {
-		// layout not yet initialized
-		return;
-	}
+        if (mTextDeckName == null) {
+            // layout not yet initialized
+            return;
+        }
         mDontSaveOnStop = true;
         CharSequence title = mTextDeckName.getText();
         CharSequence desc = mTextDeckDescription.getText();
@@ -423,10 +424,10 @@ public void onConfigurationChanged(Configuration newConfig) {
         CharSequence newTotal = mTextNewTotal.getText();
         CharSequence total = mTextTotal.getText();
         CharSequence eta = mTextETA.getText();
-//        long timelimit = mCol.getTimeLimit() / 60;
+        // long timelimit = mCol.getTimeLimit() / 60;
         super.onConfigurationChanged(newConfig);
         mDontSaveOnStop = false;
-//        initAllContentViews();
+        // initAllContentViews();
         if (mCurrentContentView == CONTENT_CONGRATS) {
             setFragmentContentView(mCongratsView);
         }
@@ -442,10 +443,10 @@ public void onConfigurationChanged(Configuration newConfig) {
         mTextTotal.setText(total);
         mTextETA.setText(eta);
 
-//        mToggleLimitToggle.setChecked(timelimit > 0 ? true : false);
-//        if (timelimit > 0) {
-//            mToggleLimitToggle.setText(String.valueOf(timelimit));
-//        }
+        // mToggleLimitToggle.setChecked(timelimit > 0 ? true : false);
+        // if (timelimit > 0) {
+        // mToggleLimitToggle.setText(String.valueOf(timelimit));
+        // }
     }
 
 
@@ -459,7 +460,6 @@ public void onDestroy() {
     }
 
 
-
     @Override
     public void onPause() {
         super.onPause();
@@ -504,69 +504,69 @@ private void openReviewer() {
 
 
     private void addNote() {
-    	Preferences.COMING_FROM_ADD=true;
+        Preferences.COMING_FROM_ADD = true;
         Intent intent = new Intent(getActivity(), CardEditor.class);
         intent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_STUDYOPTIONS);
         startActivityForResult(intent, ADD_NOTE);
         animateLeft();
     }
 
+
     private void animateLeft() {
         ActivityTransitionAnimation.slide(getActivity(), ActivityTransitionAnimation.LEFT);
     }
 
 
     public void reloadCollection() {
-        DeckTask.launchDeckTask(
-                DeckTask.TASK_TYPE_OPEN_COLLECTION,
-                new DeckTask.TaskListener() {
+        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, new DeckTask.TaskListener() {
 
-                    @Override
-                    public void onPostExecute(DeckTask.TaskData result) {
-                        if (mOpenCollectionDialog.isShowing()) {
-                            try {
-                            	mOpenCollectionDialog.dismiss();
-                            } catch (Exception e) {
-                                Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
-                            }
-                        }
-                        if (!AnkiDroidApp.colIsOpen()) {
-                        	closeStudyOptions();
-                        } else if (!mFragmented) {
-                        	((StudyOptionsActivity)getActivity()).loadContent(false);
-                        }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+                if (mOpenCollectionDialog.isShowing()) {
+                    try {
+                        mOpenCollectionDialog.dismiss();
+                    } catch (Exception e) {
+                        Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
                     }
+                }
+                if (!AnkiDroidApp.colIsOpen()) {
+                    closeStudyOptions();
+                } else if (!mFragmented) {
+                    ((StudyOptionsActivity) getActivity()).loadContent(false);
+                }
+            }
 
 
-                    @Override
-                    public void onPreExecute() {
-                    	mOpenCollectionDialog = StyledOpenCollectionDialog.show(getActivity(), getResources().getString(R.string.open_collection), new OnCancelListener() {
-                                    @Override
-                                    public void onCancel(DialogInterface arg0) {
-                                    	closeStudyOptions();
-                                    }
-                                });
-                    }
+            @Override
+            public void onPreExecute() {
+                mOpenCollectionDialog = StyledOpenCollectionDialog.show(getActivity(),
+                        getResources().getString(R.string.open_collection), new OnCancelListener() {
+                            @Override
+                            public void onCancel(DialogInterface arg0) {
+                                closeStudyOptions();
+                            }
+                        });
+            }
 
 
-                    @Override
-                    public void onProgressUpdate(DeckTask.TaskData... values) {
-                    }
-                },
-                new DeckTask.TaskData(AnkiDroidApp.getCurrentAnkiDroidDirectory()
-                        + AnkiDroidApp.COLLECTION_PATH));
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            }
+        }, new DeckTask.TaskData(AnkiDroidApp.getCurrentAnkiDroidDirectory() + AnkiDroidApp.COLLECTION_PATH));
     }
 
-    private void showOrHideUnburyButton(){
-    	if (mButtonUnbury != null){
-	        if (AnkiDroidApp.colIsOpen() && AnkiDroidApp.getCol().getSched().haveBuried()) {
-	            mButtonUnbury.setVisibility(View.VISIBLE);
-	        } else{
-	        	mButtonUnbury.setVisibility(View.GONE);
-	        }
-    	}
+
+    private void showOrHideUnburyButton() {
+        if (mButtonUnbury != null) {
+            if (AnkiDroidApp.colIsOpen() && AnkiDroidApp.getCol().getSched().haveBuried()) {
+                mButtonUnbury.setVisibility(View.VISIBLE);
+            } else {
+                mButtonUnbury.setVisibility(View.GONE);
+            }
+        }
     }
 
+
     private void initAllContentViews(LayoutInflater inflater) {
         mStudyOptionsView = inflater.inflate(R.layout.studyoptions_fragment, null);
         Themes.setContentStyle(mStudyOptionsView, Themes.CALLER_STUDYOPTIONS);
@@ -576,30 +576,32 @@ private void initAllContentViews(LayoutInflater inflater) {
         mButtonCustomStudy = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_custom);
         mDeckOptions = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_options);
         mCramOptions = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_options_cram);
-//        mButtonUp = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_limitup);
-//        mButtonDown = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_limitdown);
-//        mToggleLimitToggle = (ToggleButton) mStudyOptionsView.findViewById(R.id.studyoptions_limittoggle);
+        // mButtonUp = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_limitup);
+        // mButtonDown = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_limitdown);
+        // mToggleLimitToggle = (ToggleButton) mStudyOptionsView.findViewById(R.id.studyoptions_limittoggle);
 
         // mToggleNight = (ToggleButton) mStudyOptionsView
         // .findViewById(R.id.studyoptions_night);
         // mToggle.setChecked(mInvertedColors);
 
-        if (AnkiDroidApp.colIsOpen() && AnkiDroidApp.getCol().getDecks().isDyn(AnkiDroidApp.getCol().getDecks().selected())) {
+        if (AnkiDroidApp.colIsOpen()
+                && AnkiDroidApp.getCol().getDecks().isDyn(AnkiDroidApp.getCol().getDecks().selected())) {
             Button rebBut = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_rebuild_cram);
             rebBut.setOnClickListener(mButtonClickListener);
             Button emptyBut = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_empty_cram);
             emptyBut.setOnClickListener(mButtonClickListener);
-            // If dynamic deck then enable the cram buttons group, and disable the new filtered deck / ordinary study options buttons group
+            // If dynamic deck then enable the cram buttons group, and disable the new filtered deck / ordinary study
+            // options buttons group
             ((LinearLayout) mStudyOptionsView.findViewById(R.id.studyoptions_cram_buttons)).setVisibility(View.VISIBLE);
             ((LinearLayout) mStudyOptionsView.findViewById(R.id.studyoptions_regular_buttons)).setVisibility(View.GONE);
         }
         // Show the unbury button if there are cards to unbury
         mButtonUnbury = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_unbury);
-    	mButtonUnbury.setOnClickListener(mButtonClickListener);
-    	showOrHideUnburyButton();
+        mButtonUnbury.setOnClickListener(mButtonClickListener);
+        showOrHideUnburyButton();
 
         if (!mFragmented) {
-        	// Standard non-fragmented view for non-tablets, using standard layout file (in ./res/layout/)
+            // Standard non-fragmented view for non-tablets, using standard layout file (in ./res/layout/)
             mAddNote = (ImageButton) mStudyOptionsView.findViewById(R.id.studyoptions_add);
             if (AnkiDroidApp.colIsOpen()) {
                 Collection col = AnkiDroidApp.getCol();
@@ -613,8 +615,10 @@ private void initAllContentViews(LayoutInflater inflater) {
             mCardBrowser.setOnClickListener(mButtonClickListener);
             mStatisticsButton.setOnClickListener(mButtonClickListener);
         } else {
-        	// Fragmented view for 10" tablets, which is different from smaller devices due to larger layout file (in ./res/layout-xlarge/)
-        	// This tablet view shows the study options fragment simultaneously with the deck picker, and has different buttons from standard
+            // Fragmented view for 10" tablets, which is different from smaller devices due to larger layout file (in
+            // ./res/layout-xlarge/)
+            // This tablet view shows the study options fragment simultaneously with the deck picker, and has different
+            // buttons from standard
         }
 
         // Code common to both fragmented and non-fragmented view
@@ -633,25 +637,24 @@ private void initAllContentViews(LayoutInflater inflater) {
         mButtonCustomStudy.setOnClickListener(mButtonClickListener);
         mDeckOptions.setOnClickListener(mButtonClickListener);
         mCramOptions.setOnClickListener(mButtonClickListener);
-//        mButtonUp.setOnClickListener(mButtonClickListener);
-//        mButtonDown.setOnClickListener(mButtonClickListener);
-//        mToggleLimitToggle.setOnClickListener(mButtonClickListener);
+        // mButtonUp.setOnClickListener(mButtonClickListener);
+        // mButtonDown.setOnClickListener(mButtonClickListener);
+        // mToggleLimitToggle.setOnClickListener(mButtonClickListener);
         // mToggleCram.setOnClickListener(mButtonClickListener);
         // mToggleNight.setOnClickListener(mButtonClickListener);
 
         // The view that shows the congratulations view.
         mCongratsView = inflater.inflate(R.layout.studyoptions_congrats, null);
 
-
         // The view that shows the learn more options
         mCustomStudyDetailsView = inflater.inflate(R.layout.styled_custom_study_details_dialog, null);
         mCustomStudyTextView1 = (TextView) mCustomStudyDetailsView.findViewById(R.id.custom_study_details_text1);
         mCustomStudyTextView2 = (TextView) mCustomStudyDetailsView.findViewById(R.id.custom_study_details_text2);
         mCustomStudyEditText = (EditText) mCustomStudyDetailsView.findViewById(R.id.custom_study_details_edittext2);
 
-        /* When creating a new filtered deck after reviewing, there are several options.
-         * For selecting several tags, we need a new, different dialog, that allows to select
-         * a list of tags:
+        /*
+         * When creating a new filtered deck after reviewing, there are several options. For selecting several tags, we
+         * need a new, different dialog, that allows to select a list of tags:
          */
 
         Themes.setWallpaper(mCongratsView);
@@ -668,7 +671,6 @@ private void initAllContentViews(LayoutInflater inflater) {
             mButtonCongratsOpenOtherDeck.setVisibility(View.GONE);
         }
 
-
         mButtonCongratsUndo.setOnClickListener(mButtonClickListener);
         mButtonCongratsUnbury.setOnClickListener(mButtonClickListener);
         mButtonCongratsCustomStudy.setOnClickListener(mButtonClickListener);
@@ -686,146 +688,180 @@ private void showDialog(int id) {
 
 
     private void onPrepareDialog(int id, StyledDialog styledDialog) {
-    	Resources res = getResources();
-    	switch (id) {
-        case DIALOG_CUSTOM_STUDY_DETAILS:
-        	styledDialog.setTitle(res.getStringArray(R.array.custom_study_options_labels)[mCustomDialogChoice]);
-        	switch (mCustomDialogChoice + 1) {
-        	case CUSTOM_STUDY_NEW:
-        		if (AnkiDroidApp.colIsOpen()) {
-                    Collection col = AnkiDroidApp.getCol();
-            		mCustomStudyTextView1.setText(res.getString(R.string.custom_study_new_total_new, col.getSched().totalNewForCurrentDeck()));
-        		}
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_new_extend));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("extendNew", 10)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
+        Resources res = getResources();
+        switch (id) {
+            case DIALOG_CUSTOM_STUDY_DETAILS:
+                styledDialog.setTitle(res.getStringArray(R.array.custom_study_options_labels)[mCustomDialogChoice]);
+                switch (mCustomDialogChoice + 1) {
+                    case CUSTOM_STUDY_NEW:
                         if (AnkiDroidApp.colIsOpen()) {
-                            try {
-                                int n = Integer.parseInt(mCustomStudyEditText.getText().toString());
-                                AnkiDroidApp.getSharedPrefs(getActivity()).edit().putInt("extendNew", n).commit();
-                                Collection col = AnkiDroidApp.getCol();
-                                JSONObject deck = col.getDecks().current();
-                                deck.put("extendNew", n);
-                                col.getDecks().save(deck);
-                                col.getSched().extendLimits(n, 0);
-                                resetAndUpdateValuesFromDeck();
-                                finishCongrats();
-                            } catch (NumberFormatException e) {
-                                // ignore non numerical values
-                                Themes.showThemedToast(getActivity().getBaseContext(), getResources().getString(R.string.custom_study_invalid_number), false);
-                            } catch (JSONException e) {
-                                throw new RuntimeException(e);
-                            }
+                            Collection col = AnkiDroidApp.getCol();
+                            mCustomStudyTextView1.setText(res.getString(R.string.custom_study_new_total_new, col
+                                    .getSched().totalNewForCurrentDeck()));
                         }
-                    }});
-        		break;
-
-        	case CUSTOM_STUDY_REV:
-        		if (AnkiDroidApp.colIsOpen()) {
-                    Collection col = AnkiDroidApp.getCol();
-            		mCustomStudyTextView1.setText(res.getString(R.string.custom_study_rev_total_rev, col.getSched().totalRevForCurrentDeck()));
-        		}
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_rev_extend));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("extendRev", 10)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_new_extend));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("extendNew", 10)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        if (AnkiDroidApp.colIsOpen()) {
+                                            try {
+                                                int n = Integer.parseInt(mCustomStudyEditText.getText().toString());
+                                                AnkiDroidApp.getSharedPrefs(getActivity()).edit()
+                                                        .putInt("extendNew", n).commit();
+                                                Collection col = AnkiDroidApp.getCol();
+                                                JSONObject deck = col.getDecks().current();
+                                                deck.put("extendNew", n);
+                                                col.getDecks().save(deck);
+                                                col.getSched().extendLimits(n, 0);
+                                                resetAndUpdateValuesFromDeck();
+                                                finishCongrats();
+                                            } catch (NumberFormatException e) {
+                                                // ignore non numerical values
+                                                Themes.showThemedToast(getActivity().getBaseContext(), getResources()
+                                                        .getString(R.string.custom_study_invalid_number), false);
+                                            } catch (JSONException e) {
+                                                throw new RuntimeException(e);
+                                            }
+                                        }
+                                    }
+                                });
+                        break;
+
+                    case CUSTOM_STUDY_REV:
                         if (AnkiDroidApp.colIsOpen()) {
-                            try {
-                                int n = Integer.parseInt(mCustomStudyEditText.getText().toString());
-                                AnkiDroidApp.getSharedPrefs(getActivity()).edit().putInt("extendRev", n).commit();
-                                Collection col = AnkiDroidApp.getCol();
-                                JSONObject deck = col.getDecks().current();
-                                deck.put("extendRev", n);
-                                col.getDecks().save(deck);
-                                col.getSched().extendLimits(0, n);
-                                resetAndUpdateValuesFromDeck();
-                                finishCongrats();
-                            } catch (NumberFormatException e) {
-                                // ignore non numerical values
-                                Themes.showThemedToast(getActivity().getBaseContext(), getResources().getString(R.string.custom_study_invalid_number), false);
-                            } catch (JSONException e) {
-                                throw new RuntimeException(e);
-                            }
+                            Collection col = AnkiDroidApp.getCol();
+                            mCustomStudyTextView1.setText(res.getString(R.string.custom_study_rev_total_rev, col
+                                    .getSched().totalRevForCurrentDeck()));
                         }
-                    }
-                });
-        		break;
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_rev_extend));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("extendRev", 10)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        if (AnkiDroidApp.colIsOpen()) {
+                                            try {
+                                                int n = Integer.parseInt(mCustomStudyEditText.getText().toString());
+                                                AnkiDroidApp.getSharedPrefs(getActivity()).edit()
+                                                        .putInt("extendRev", n).commit();
+                                                Collection col = AnkiDroidApp.getCol();
+                                                JSONObject deck = col.getDecks().current();
+                                                deck.put("extendRev", n);
+                                                col.getDecks().save(deck);
+                                                col.getSched().extendLimits(0, n);
+                                                resetAndUpdateValuesFromDeck();
+                                                finishCongrats();
+                                            } catch (NumberFormatException e) {
+                                                // ignore non numerical values
+                                                Themes.showThemedToast(getActivity().getBaseContext(), getResources()
+                                                        .getString(R.string.custom_study_invalid_number), false);
+                                            } catch (JSONException e) {
+                                                throw new RuntimeException(e);
+                                            }
+                                        }
+                                    }
+                                });
+                        break;
 
-        	case CUSTOM_STUDY_FORGOT:
-        		mCustomStudyTextView1.setText("");
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_forgotten));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("forgottenDays", 2)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        JSONArray ar = new JSONArray();
-                        try {
-                            int forgottenDays = Integer.parseInt(((EditText) mCustomStudyEditText).getText().toString());
-                            ar.put(0, 1);
-                            createFilteredDeck(ar, new Object[]{String.format(Locale.US, "rated:%d:1", forgottenDays), Consts.DYN_MAX_SIZE, Consts.DYN_RANDOM}, false);
-                        } catch (NumberFormatException e) {
-                            // ignore non numerical values
-                            Themes.showThemedToast(getActivity().getBaseContext(), getResources().getString(R.string.custom_study_invalid_number), false);
-                        } catch (JSONException e) {
-                            throw new RuntimeException(e);
-                        }
-                    }
-                });
-        		break;
+                    case CUSTOM_STUDY_FORGOT:
+                        mCustomStudyTextView1.setText("");
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_forgotten));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("forgottenDays", 2)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        JSONArray ar = new JSONArray();
+                                        try {
+                                            int forgottenDays = Integer.parseInt(((EditText) mCustomStudyEditText)
+                                                    .getText().toString());
+                                            ar.put(0, 1);
+                                            createFilteredDeck(
+                                                    ar,
+                                                    new Object[] {
+                                                            String.format(Locale.US, "rated:%d:1", forgottenDays),
+                                                            Consts.DYN_MAX_SIZE, Consts.DYN_RANDOM }, false);
+                                        } catch (NumberFormatException e) {
+                                            // ignore non numerical values
+                                            Themes.showThemedToast(getActivity().getBaseContext(), getResources()
+                                                    .getString(R.string.custom_study_invalid_number), false);
+                                        } catch (JSONException e) {
+                                            throw new RuntimeException(e);
+                                        }
+                                    }
+                                });
+                        break;
 
-        	case CUSTOM_STUDY_AHEAD:
-        		mCustomStudyTextView1.setText("");
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_ahead));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("aheadDays", 1)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        try {
-                            int days = Integer.parseInt(((EditText) mCustomStudyEditText).getText().toString());
-                            createFilteredDeck(new JSONArray(), new Object[]{String.format(Locale.US, "prop:due<=%d", days), Consts.DYN_MAX_SIZE, Consts.DYN_DUE}, true);
-                        } catch (NumberFormatException e) {
-                            // ignore non numerical values
-                            Themes.showThemedToast(getActivity().getBaseContext(), getResources().getString(R.string.custom_study_invalid_number), false);
-                        }
-                    }
-                });
-        		break;
+                    case CUSTOM_STUDY_AHEAD:
+                        mCustomStudyTextView1.setText("");
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_ahead));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("aheadDays", 1)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        try {
+                                            int days = Integer.parseInt(((EditText) mCustomStudyEditText).getText()
+                                                    .toString());
+                                            createFilteredDeck(new JSONArray(),
+                                                    new Object[] { String.format(Locale.US, "prop:due<=%d", days),
+                                                            Consts.DYN_MAX_SIZE, Consts.DYN_DUE }, true);
+                                        } catch (NumberFormatException e) {
+                                            // ignore non numerical values
+                                            Themes.showThemedToast(getActivity().getBaseContext(), getResources()
+                                                    .getString(R.string.custom_study_invalid_number), false);
+                                        }
+                                    }
+                                });
+                        break;
 
-        	case CUSTOM_STUDY_RANDOM:
-        		mCustomStudyTextView1.setText("");
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_random));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("randomCards", 100)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        try {
-                            int randomCards = Integer.parseInt(((EditText) mCustomStudyEditText).getText().toString());
-                            createFilteredDeck(new JSONArray(), new Object[]{"", randomCards, Consts.DYN_RANDOM}, true);
-                        } catch (NumberFormatException e) {
-                            // ignore non numerical values
-                            Themes.showThemedToast(getActivity().getBaseContext(), getResources().getString(R.string.custom_study_invalid_number), false);
-                        }
-                    }
-                });
-        		break;
+                    case CUSTOM_STUDY_RANDOM:
+                        mCustomStudyTextView1.setText("");
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_random));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("randomCards", 100)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        try {
+                                            int randomCards = Integer.parseInt(((EditText) mCustomStudyEditText)
+                                                    .getText().toString());
+                                            createFilteredDeck(new JSONArray(), new Object[] { "", randomCards,
+                                                    Consts.DYN_RANDOM }, true);
+                                        } catch (NumberFormatException e) {
+                                            // ignore non numerical values
+                                            Themes.showThemedToast(getActivity().getBaseContext(), getResources()
+                                                    .getString(R.string.custom_study_invalid_number), false);
+                                        }
+                                    }
+                                });
+                        break;
 
-        	case CUSTOM_STUDY_PREVIEW:
-        		mCustomStudyTextView1.setText("");
-        		mCustomStudyTextView2.setText(res.getString(R.string.custom_study_preview));
-        		mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity()).getInt("previewDays", 1)));
-        		styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                    	String previewDays = ((EditText) mCustomStudyEditText).getText().toString();
-                    	createFilteredDeck(new JSONArray(), new Object[]{"is:new added:" + previewDays, Consts.DYN_MAX_SIZE, Consts.DYN_OLDEST}, false);
-                    }
-                });
-        		break;
-        	}
-    	}
+                    case CUSTOM_STUDY_PREVIEW:
+                        mCustomStudyTextView1.setText("");
+                        mCustomStudyTextView2.setText(res.getString(R.string.custom_study_preview));
+                        mCustomStudyEditText.setText(Integer.toString(AnkiDroidApp.getSharedPrefs(getActivity())
+                                .getInt("previewDays", 1)));
+                        styledDialog.setButtonOnClickListener(Dialog.BUTTON_POSITIVE,
+                                new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialog, int which) {
+                                        String previewDays = ((EditText) mCustomStudyEditText).getText().toString();
+                                        createFilteredDeck(new JSONArray(),
+                                                new Object[] { "is:new added:" + previewDays, Consts.DYN_MAX_SIZE,
+                                                        Consts.DYN_OLDEST }, false);
+                                    }
+                                });
+                        break;
+                }
+        }
     }
 
 
@@ -848,51 +884,48 @@ public void onClick(DialogInterface dialog, int which) {
             case DIALOG_CUSTOM_STUDY:
                 builder1.setTitle(res.getString(R.string.custom_study));
                 builder1.setIcon(android.R.drawable.ic_menu_sort_by_size);
-                builder1.setItems(res.getStringArray(R.array.custom_study_options_labels), new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                    	mCustomDialogChoice = which;
-                    	if(which == CUSTOM_STUDY_TAGS-1){
-                    		/*
-                    		 * There is a special Dialog for CUSTOM STUDY, where instead of only collecting
-                    		 * a number, it is necessary to collect a list of tags. This case handles the
-                    		 * creation of that Dialog.
-                    		 */
-                    		showDialog(DIALOG_CUSTOM_STUDY_TAGS);
-                    		return;
-                    	}
-                    	showDialog(DIALOG_CUSTOM_STUDY_DETAILS);
-                    }
-                });
+                builder1.setItems(res.getStringArray(R.array.custom_study_options_labels),
+                        new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                mCustomDialogChoice = which;
+                                if (which == CUSTOM_STUDY_TAGS - 1) {
+                                    /*
+                                     * There is a special Dialog for CUSTOM STUDY, where instead of only collecting a
+                                     * number, it is necessary to collect a list of tags. This case handles the creation
+                                     * of that Dialog.
+                                     */
+                                    showDialog(DIALOG_CUSTOM_STUDY_TAGS);
+                                    return;
+                                }
+                                showDialog(DIALOG_CUSTOM_STUDY_DETAILS);
+                            }
+                        });
                 builder1.setCancelable(true);
                 dialog = builder1.create();
                 break;
 
             case DIALOG_CUSTOM_STUDY_TAGS:
-            	 /*
-            	  * This handles the case where we want to create a Custom Study Deck using tags.
-            	  * This dialog needs to be different from the normal Custom Study dialogs, because
-            	  * more information is required:
-            	  * --List of Tags to select.
-            	  * --Which cards to select
-            	  * 	--(New cards, Due cards, or all cards, as in the desktop version)
-            	  */
-                if (!AnkiDroidApp.colIsOpen())
-                {
-                    //TODO how should this error be handled?
+                /*
+                 * This handles the case where we want to create a Custom Study Deck using tags. This dialog needs to be
+                 * different from the normal Custom Study dialogs, because more information is required: --List of Tags
+                 * to select. --Which cards to select --(New cards, Due cards, or all cards, as in the desktop version)
+                 */
+                if (!AnkiDroidApp.colIsOpen()) {
+                    // TODO how should this error be handled?
                 }
 
                 Context context = getActivity().getBaseContext();
                 /*
-                 * The following RadioButtons and RadioGroup are to select the category of cards
-                 * to select for the Custom Study Deck (New, Due or All cards).
+                 * The following RadioButtons and RadioGroup are to select the category of cards to select for the
+                 * Custom Study Deck (New, Due or All cards).
                  */
-                RadioGroup rg = formatRGCardType(context,res);
+                RadioGroup rg = formatRGCardType(context, res);
                 mSelectWhichCards = rg;
 
                 builder1.setView(rg, false, true);
 
-                //Here we add the list of tags for the whole collection.
+                // Here we add the list of tags for the whole collection.
                 Collection col;
                 col = AnkiDroidApp.getCol();
                 List<String> tags_list = col.getTags().all();
@@ -906,28 +939,28 @@ public int compare(String lhs, String rhs) {
                 builder1.setTitle(R.string.studyoptions_limit_select_tags);
                 builder1.setMultiChoiceItems(allTags, new boolean[allTags.length],
                         new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        String tag = allTags[which];
-                        if (mSelectedTags.contains(tag)) {
-                            Log.i(AnkiDroidApp.TAG, "unchecked tag: " + tag);
-                            mSelectedTags.remove(tag);
-                        } else {
-                            Log.i(AnkiDroidApp.TAG, "checked tag: " + tag);
-                            mSelectedTags.add(tag);
-                        }
-                    }
-                }, new CompoundButton.OnCheckedChangeListener() {
-                    @Override
-                    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                        mTagsDialog.setItemListChecked(isChecked);
-                        mSelectedTags = new HashSet<String>(mTagsDialog.getCheckedItems());
-                    }
-                });
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                String tag = allTags[which];
+                                if (mSelectedTags.contains(tag)) {
+                                    Log.i(AnkiDroidApp.TAG, "unchecked tag: " + tag);
+                                    mSelectedTags.remove(tag);
+                                } else {
+                                    Log.i(AnkiDroidApp.TAG, "checked tag: " + tag);
+                                    mSelectedTags.add(tag);
+                                }
+                            }
+                        }, new CompoundButton.OnCheckedChangeListener() {
+                            @Override
+                            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                                mTagsDialog.setItemListChecked(isChecked);
+                                mSelectedTags = new HashSet<String>(mTagsDialog.getCheckedItems());
+                            }
+                        });
 
                 /*
-                 * Here's the method that gathers the final selection of tags, type of cards
-                 * and generates the search screen for the custom study deck.
+                 * Here's the method that gathers the final selection of tags, type of cards and generates the search
+                 * screen for the custom study deck.
                  */
                 builder1.setPositiveButton(res.getString(R.string.select), new OnClickListener() {
                     @Override
@@ -937,7 +970,7 @@ public void onClick(DialogInterface dialog, int which) {
                         mCustomStudyEditText.setHint(getResources().getString(R.string.card_browser_tags_shown,
                                 tags.substring(1, tags.length() - 1)));
                         StringBuilder sb = new StringBuilder();
-                        switch(mSelectedOption){
+                        switch (mSelectedOption) {
                             case 1:
                                 sb.append("is:new ");
                                 break;
@@ -950,21 +983,20 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                         int i = 0;
                         for (String tag : mSelectedTags) {
-                            if(i != 0)
-                            {
+                            if (i != 0) {
                                 sb.append("or ");
-                            }
-                            else{
-                                sb.append("("); //Only if we really have selected tags
+                            } else {
+                                sb.append("("); // Only if we really have selected tags
                             }
                             sb.append("tag:").append(tag).append(" ");
                             i++;
                         }
-                        if(i>0){
-                            sb.append(")");	//Only if we added anything to the tag list
+                        if (i > 0) {
+                            sb.append(")"); // Only if we added anything to the tag list
                         }
                         mSearchTerms = sb.toString();
-                        createFilteredDeck(new JSONArray(), new Object[]{mSearchTerms, Consts.DYN_MAX_SIZE, Consts.DYN_RANDOM}, false);
+                        createFilteredDeck(new JSONArray(), new Object[] { mSearchTerms, Consts.DYN_MAX_SIZE,
+                                Consts.DYN_RANDOM }, false);
                     }
                 });
                 builder1.setNegativeButton(res.getString(R.string.cancel), new OnClickListener() {
@@ -986,13 +1018,14 @@ public void onCancel(DialogInterface dialog) {
 
                 mTagsDialog = builder1.create();
                 dialog = mTagsDialog;
-                //without this the dialog goes up the screen in a way that the user isn't able to see the full item list.
+                // without this the dialog goes up the screen in a way that the user isn't able to see the full item
+                // list.
                 mTagsDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
                 break;
             case DIALOG_CUSTOM_STUDY_DETAILS:
                 /*
-                 * This is the normal case for creating a custom study deck, where the dialog
-                 * requires only a numeric input.
+                 * This is the normal case for creating a custom study deck, where the dialog requires only a numeric
+                 * input.
                  */
                 builder1.setContentView(mCustomStudyDetailsView);
                 builder1.setCancelable(true);
@@ -1010,32 +1043,29 @@ public void onCancel(DialogInterface dialog) {
         return dialog;
     }
 
+
     /**
-     * formatRGCardType
-     * Returns: RadioGroup - A radio group that contains the options of All Cards, New, and Due cards,
-     * 			for the selection of cards when creating a CUSTOM_STUDY_DECKS based on TAGS.
-     * Takes: context, and resources of the App.
-     *
-     * This method just creates the RadioGroup required for the dialog to select tags for a new
-     * custom study deck.
+     * formatRGCardType Returns: RadioGroup - A radio group that contains the options of All Cards, New, and Due cards,
+     * for the selection of cards when creating a CUSTOM_STUDY_DECKS based on TAGS. Takes: context, and resources of the
+     * App. This method just creates the RadioGroup required for the dialog to select tags for a new custom study deck.
      */
-    private RadioGroup formatRGCardType(Context context, Resources res){
+    private RadioGroup formatRGCardType(Context context, Resources res) {
         RadioGroup rg = new RadioGroup(context);
         final RadioButton[] radioButtonCards = new RadioButton[3];
         rg.setOrientation(RadioGroup.HORIZONTAL);
         RadioGroup.LayoutParams lp = new RadioGroup.LayoutParams(0, LayoutParams.MATCH_PARENT, 1);
         int height = context.getResources().getDrawable(R.drawable.white_btn_radio).getIntrinsicHeight();
 
-        //This array contains "All Cards", "New", and "Due", in that order.
+        // This array contains "All Cards", "New", and "Due", in that order.
         String[] text = res.getStringArray(R.array.cards_for_tag_filtered_deck_labels);
-        for(int i=0; i < radioButtonCards.length; i++){
-        	radioButtonCards[i] = new RadioButton(context);
-        	radioButtonCards[i].setClickable(true);
-        	radioButtonCards[i].setText(text[i]);
-        	radioButtonCards[i].setHeight(height*2);
-        	radioButtonCards[i].setSingleLine();
-        	radioButtonCards[i].setGravity(Gravity.CENTER_VERTICAL);
-        	rg.addView(radioButtonCards[i], lp);
+        for (int i = 0; i < radioButtonCards.length; i++) {
+            radioButtonCards[i] = new RadioButton(context);
+            radioButtonCards[i].setClickable(true);
+            radioButtonCards[i].setText(text[i]);
+            radioButtonCards[i].setHeight(height * 2);
+            radioButtonCards[i].setSingleLine();
+            radioButtonCards[i].setGravity(Gravity.CENTER_VERTICAL);
+            rg.addView(radioButtonCards[i], lp);
         }
         radioButtonCards[0].setChecked(true);
 
@@ -1052,19 +1082,20 @@ public void onCheckedChanged(RadioGroup arg0, int arg1) {
             }
         });
         rg.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, height));
-    	return rg;
+        return rg;
     }
 
+
     private void createFilteredDeck(JSONArray delays, Object[] terms, Boolean resched) {
-		JSONObject dyn;
-    	if (AnkiDroidApp.colIsOpen()) {
-    		Collection col = AnkiDroidApp.getCol();
-    		try {
-    			String deckName = col.getDecks().current().getString("name");
-    			String customStudyDeck = getResources().getString(R.string.custom_study_deck_name);
-    			JSONObject cur = col.getDecks().byName(customStudyDeck);
-    			if (cur != null) {
-    				if (cur.getInt("dyn") != 1) {
+        JSONObject dyn;
+        if (AnkiDroidApp.colIsOpen()) {
+            Collection col = AnkiDroidApp.getCol();
+            try {
+                String deckName = col.getDecks().current().getString("name");
+                String customStudyDeck = getResources().getString(R.string.custom_study_deck_name);
+                JSONObject cur = col.getDecks().byName(customStudyDeck);
+                if (cur != null) {
+                    if (cur.getInt("dyn") != 1) {
                         StyledDialog.Builder builder = new StyledDialog.Builder(getActivity());
                         builder.setMessage(R.string.custom_study_deck_exists);
                         builder.setNegativeButton(getResources().getString(R.string.cancel), new OnClickListener() {
@@ -1074,54 +1105,58 @@ public void onClick(DialogInterface dialog, int which) {
                             }
                         });
                         builder.create().show();
-    					return;
-    				} else {
-    					// safe to empty
-    					col.getSched().emptyDyn(cur.getLong("id"));
-    					// reuse; don't delete as it may have children
-    					dyn = cur;
-    					col.getDecks().select(cur.getLong("id"));
-    				}
-    			} else {
-    				long did = col.getDecks().newDyn(customStudyDeck);
-    				dyn = col.getDecks().get(did);
-    			}
-    			// and then set various options
-    			dyn.put("delays", delays);
-    			JSONArray ar = dyn.getJSONArray("terms");
-    			ar.getJSONArray(0).put(0, new StringBuilder("deck:\"").append(deckName).append("\" ").append(terms[0]).toString());
-    			ar.getJSONArray(0).put(1, terms[1]);
-    			ar.getJSONArray(0).put(2, terms[2]);
-    			dyn.put("resched", resched);
-
-    			if (mFragmented) {
+                        return;
+                    } else {
+                        // safe to empty
+                        col.getSched().emptyDyn(cur.getLong("id"));
+                        // reuse; don't delete as it may have children
+                        dyn = cur;
+                        col.getDecks().select(cur.getLong("id"));
+                    }
+                } else {
+                    long did = col.getDecks().newDyn(customStudyDeck);
+                    dyn = col.getDecks().get(did);
+                }
+                // and then set various options
+                dyn.put("delays", delays);
+                JSONArray ar = dyn.getJSONArray("terms");
+                ar.getJSONArray(0).put(0,
+                        new StringBuilder("deck:\"").append(deckName).append("\" ").append(terms[0]).toString());
+                ar.getJSONArray(0).put(1, terms[1]);
+                ar.getJSONArray(0).put(2, terms[2]);
+                dyn.put("resched", resched);
+
+                if (mFragmented) {
                     Bundle config = new Bundle();
-                    config.putString("searchSuffix", "'deck:" +dyn.getString("name") + "'");
+                    config.putString("searchSuffix", "'deck:" + dyn.getString("name") + "'");
                     initAllContentViews(getLayoutInflater(config));
                     finishCongrats();
                 } else {
-        			// Load a new fragment with the filtered deck view. The config passed is null, so it uses the
-        			// current deck. The deck we just created is internally set as the current deck.
-        			((StudyOptionsActivity)getActivity()).loadContent(false, null);
-    			}
-
-    			// Initial rebuild
-    			mProgressDialog = StyledProgressDialog.show(getActivity(), "",
-    					getResources().getString(R.string.rebuild_custom_study_deck), true);
-    			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, mRebuildCustomStudyListener, new DeckTask.TaskData(
-    					AnkiDroidApp.getCol(), AnkiDroidApp.getCol().getDecks().selected(), mFragmented));
-    		} catch (JSONException e) {
-    			throw new RuntimeException(e);
-    		}
-    	}
+                    // Load a new fragment with the filtered deck view. The config passed is null, so it uses the
+                    // current deck. The deck we just created is internally set as the current deck.
+                    ((StudyOptionsActivity) getActivity()).loadContent(false, null);
+                }
+
+                // Initial rebuild
+                mProgressDialog = StyledProgressDialog.show(getActivity(), "",
+                        getResources().getString(R.string.rebuild_custom_study_deck), true);
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, mRebuildCustomStudyListener,
+                        new DeckTask.TaskData(AnkiDroidApp.getCol(), AnkiDroidApp.getCol().getDecks().selected(),
+                                mFragmented));
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
     }
 
+
     void setFragmentContentView(View newView) {
         ViewGroup parent = (ViewGroup) this.getView();
         parent.removeAllViews();
         parent.addView(newView);
     }
 
+
     public void resetAndUpdateValuesFromDeck() {
         updateValuesFromDeck(true);
     }
@@ -1135,7 +1170,7 @@ private void updateValuesFromDeck() {
     private void updateValuesFromDeck(boolean reset) {
         String fullName;
         if (!AnkiDroidApp.colIsOpen()) {
-        	return;
+            return;
         }
         JSONObject deck = AnkiDroidApp.getCol().getDecks().current();
         try {
@@ -1171,14 +1206,14 @@ private void updateValuesFromDeck(boolean reset) {
 
         String desc;
         try {
-			if (deck.getInt("dyn") == 0) {
-			    desc = AnkiDroidApp.getCol().getDecks().getActualDescription();
-			} else {
-				desc = getResources().getString(R.string.dyn_deck_desc);
-			}
-		} catch (JSONException e) {
-			throw new RuntimeException(e);
-		}
+            if (deck.getInt("dyn") == 0) {
+                desc = AnkiDroidApp.getCol().getDecks().getActualDescription();
+            } else {
+                desc = getResources().getString(R.string.dyn_deck_desc);
+            }
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
         if (desc.length() > 0) {
             mTextDeckDescription.setText(Html.fromHtml(desc));
             mTextDeckDescription.setVisibility(View.VISIBLE);
@@ -1187,7 +1222,7 @@ private void updateValuesFromDeck(boolean reset) {
         }
 
         DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_VALUES_FROM_DECK, mUpdateValuesFromDeckListener,
-                new DeckTask.TaskData(AnkiDroidApp.getCol(), new Object[]{reset, mSmallChart != null}));
+                new DeckTask.TaskData(AnkiDroidApp.getCol(), new Object[] { reset, mSmallChart != null }));
     }
 
 
@@ -1241,6 +1276,7 @@ private void updateChart(double[][] serieslist) {
         }
     }
 
+
     public boolean congratsShowing() {
         if (mCurrentContentView == CONTENT_CONGRATS) {
             updateValuesFromDeck();
@@ -1250,8 +1286,9 @@ public boolean congratsShowing() {
         }
     }
 
+
     public void finishCongrats() {
-    	mCurrentContentView = CONTENT_STUDY_OPTIONS;
+        mCurrentContentView = CONTENT_STUDY_OPTIONS;
         mStudyOptionsView.setVisibility(View.INVISIBLE);
         mCongratsView.setVisibility(View.INVISIBLE);
         mCongratsView.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, 500, 0));
@@ -1263,14 +1300,14 @@ public void finishCongrats() {
 
 
     private void prepareCongratsView() {
-    	mCurrentContentView = CONTENT_CONGRATS;
+        mCurrentContentView = CONTENT_CONGRATS;
         if (!AnkiDroidApp.colIsOpen() || !AnkiDroidApp.getCol().undoAvailable()) {
             mButtonCongratsUndo.setEnabled(false);
             mButtonCongratsUndo.setVisibility(View.GONE);
         } else {
             Resources res = AnkiDroidApp.getAppResources();
-            mButtonCongratsUndo.setText(res.getString(R.string.studyoptions_congrats_undo,
-                    AnkiDroidApp.getCol().undoName(res)));
+            mButtonCongratsUndo.setText(res.getString(R.string.studyoptions_congrats_undo, AnkiDroidApp.getCol()
+                    .undoName(res)));
         }
         if (AnkiDroidApp.colIsOpen() && !AnkiDroidApp.getCol().getSched().haveBuried()) {
             mButtonCongratsUnbury.setVisibility(View.GONE);
@@ -1354,21 +1391,21 @@ public void onActivityResult(int requestCode, int resultCode, Intent intent) {
                 mDontSaveOnStop = false;
                 return;
             }
-        	if (requestCode == DECK_OPTIONS) {
-        	    if (mCramInitialConfig != null) {
-        	        mCramInitialConfig = null;
-        	        try {
-        	            JSONObject deck = AnkiDroidApp.getCol().getDecks().current();
-        	            if (deck.getInt("dyn") != 0 && deck.has("empty")) {
-        	                deck.remove("empty");
-        	            }
-        	        } catch (JSONException e) {
-        	            throw new RuntimeException(e);
-        	        }
-        	        rebuildCramDeck();
-        	    } else {
-        	        resetAndUpdateValuesFromDeck();
-        	    }
+            if (requestCode == DECK_OPTIONS) {
+                if (mCramInitialConfig != null) {
+                    mCramInitialConfig = null;
+                    try {
+                        JSONObject deck = AnkiDroidApp.getCol().getDecks().current();
+                        if (deck.getInt("dyn") != 0 && deck.has("empty")) {
+                            deck.remove("empty");
+                        }
+                    } catch (JSONException e) {
+                        throw new RuntimeException(e);
+                    }
+                    rebuildCramDeck();
+                } else {
+                    resetAndUpdateValuesFromDeck();
+                }
             } else if (requestCode == ADD_NOTE && resultCode != Activity.RESULT_CANCELED) {
                 resetAndUpdateValuesFromDeck();
             } else if (requestCode == REQUEST_REVIEW) {
@@ -1377,17 +1414,18 @@ public void onActivityResult(int requestCode, int resultCode, Intent intent) {
                 // TODO: handle big widget
                 switch (resultCode) {
                     default:
-                        // do not reload counts, if activity is created anew because it has been before destroyed by android
+                        // do not reload counts, if activity is created anew because it has been before destroyed by
+                        // android
                         resetAndUpdateValuesFromDeck();
                         break;
                     case Reviewer.RESULT_NO_MORE_CARDS:
-                    	prepareCongratsView();
+                        prepareCongratsView();
                         setFragmentContentView(mCongratsView);
                         break;
                 }
                 mDontSaveOnStop = false;
-            } else if (requestCode == BROWSE_CARDS &&
-                    (resultCode == Activity.RESULT_OK || resultCode == Activity.RESULT_CANCELED)) {
+            } else if (requestCode == BROWSE_CARDS
+                    && (resultCode == Activity.RESULT_OK || resultCode == Activity.RESULT_CANCELED)) {
                 mDontSaveOnStop = false;
                 resetAndUpdateValuesFromDeck();
             } else if (requestCode == STATISTICS && mCurrentContentView == CONTENT_CONGRATS) {
@@ -1411,18 +1449,22 @@ public SharedPreferences restorePreferences() {
         public void onPostExecute(TaskData result) {
             resetAndUpdateValuesFromDeck();
         }
+
+
         @Override
         public void onPreExecute() {
         }
+
+
         @Override
         public void onProgressUpdate(TaskData... values) {
         }
     };
 
-	DeckTask.TaskListener mUpdateValuesFromDeckListener = new DeckTask.TaskListener() {
+    DeckTask.TaskListener mUpdateValuesFromDeckListener = new DeckTask.TaskListener() {
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
-        	if (result != null) {
+            if (result != null) {
                 Object[] obj = result.getObjArray();
                 int newCards = (Integer) obj[0];
                 int lrnCards = (Integer) obj[1];
@@ -1434,28 +1476,28 @@ public void onPostExecute(DeckTask.TaskData result) {
 
                 updateChart(serieslist);
 
-//                JSONObject conf = mCol.getConf();
-//                long timeLimit = 0;
-//                try {
-//                    timeLimit = (conf.getLong("timeLim") / 60);
-//                } catch (JSONException e) {
-//                    throw new RuntimeException(e);
-//                }
-//                mToggleLimitToggle.setChecked(timeLimit > 0 ? true : false);
-//                mToggleLimitToggle.setText(String.valueOf(timeLimit));
-
-//                Activity act = getActivity();
-//                if (act != null) {
-//                    SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(act.getBaseContext());
-//                    mPrefHideDueCount = preferences.getBoolean("hideDueCount", true);
-//                }
+                // JSONObject conf = mCol.getConf();
+                // long timeLimit = 0;
+                // try {
+                // timeLimit = (conf.getLong("timeLim") / 60);
+                // } catch (JSONException e) {
+                // throw new RuntimeException(e);
+                // }
+                // mToggleLimitToggle.setChecked(timeLimit > 0 ? true : false);
+                // mToggleLimitToggle.setText(String.valueOf(timeLimit));
+
+                // Activity act = getActivity();
+                // if (act != null) {
+                // SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(act.getBaseContext());
+                // mPrefHideDueCount = preferences.getBoolean("hideDueCount", true);
+                // }
                 mTextTodayNew.setText(String.valueOf(newCards));
                 mTextTodayLrn.setText(String.valueOf(lrnCards));
-//                if (mPrefHideDueCount) {
-//                    mTextTodayRev.setText("???");
-//                } else {
-                    mTextTodayRev.setText(String.valueOf(revCards));
-//                }
+                // if (mPrefHideDueCount) {
+                // mTextTodayRev.setText("???");
+                // } else {
+                mTextTodayRev.setText(String.valueOf(revCards));
+                // }
                 mTextNewTotal.setText(totalNew == 1000 ? ">1000" : String.valueOf(totalNew));
                 mTextTotal.setText(String.valueOf(totalCards));
                 if (eta != -1) {
@@ -1472,7 +1514,7 @@ public void onPostExecute(DeckTask.TaskData result) {
                 if (mFragmented) {
                     ((DeckPicker) getActivity()).loadCounts();
                 }
-        	}
+            }
 
             // for rebuilding cram decks
             if (mProgressDialog != null && mProgressDialog.isShowing()) {
@@ -1577,11 +1619,13 @@ public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float ve
         }
     }
 
+
     public boolean onTouchEvent(MotionEvent event) {
-    	return mSwipeEnabled && gestureDetector.onTouchEvent(event);
+        return mSwipeEnabled && gestureDetector.onTouchEvent(event);
     }
 
+
     public boolean dbSaveNecessary() {
-    	return !mDontSaveOnStop;
+        return !mDontSaveOnStop;
     }
 }
diff --git a/src/com/ichi2/anki/UIUtils.java b/src/com/ichi2/anki/UIUtils.java
index d8186587fddf..9c936db87936 100644
--- a/src/com/ichi2/anki/UIUtils.java
+++ b/src/com/ichi2/anki/UIUtils.java
@@ -33,7 +33,7 @@ public static long getDayStart() {
 
 
     public static void saveCollectionInBackground() {
-    	if (AnkiDroidApp.colIsOpen()) {
+        if (AnkiDroidApp.colIsOpen()) {
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_COLLECTION, new DeckTask.TaskListener() {
                 @Override
                 public void onPreExecute() {
@@ -51,9 +51,10 @@ public void onPostExecute(TaskData result) {
                 public void onProgressUpdate(TaskData... values) {
                 }
             }, new DeckTask.TaskData(AnkiDroidApp.getCol()));
-    	}
+        }
     }
 
+
     public static void setFullScreen(Activity activity) {
         activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                 WindowManager.LayoutParams.FLAG_FULLSCREEN);
diff --git a/src/com/ichi2/anki/Whiteboard.java b/src/com/ichi2/anki/Whiteboard.java
index 499dc7c40759..bb65bdebc9c6 100644
--- a/src/com/ichi2/anki/Whiteboard.java
+++ b/src/com/ichi2/anki/Whiteboard.java
@@ -99,23 +99,22 @@ protected void onDraw(Canvas canvas) {
     }
 
 
-   // // We use only one big, square bitmap now. Nothing left to do here, then.
-   //  @Override
-   //  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-   //      // We want to create the bitmap again only when the screen has been rotated,
-   //      // not when the size changes in the transition between the front and the back
-   //      // of a card (that would made the Whiteboard to disappear)
-   //      if (mRecreateBitmap) {
-   //          createBitmap();
-   //          super.onSizeChanged(w, h, oldw, oldh);
-   //          mRecreateBitmap = false;
-   //      }
-   //  }
-
+    // // We use only one big, square bitmap now. Nothing left to do here, then.
+    // @Override
+    // protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+    // // We want to create the bitmap again only when the screen has been rotated,
+    // // not when the size changes in the transition between the front and the back
+    // // of a card (that would made the Whiteboard to disappear)
+    // if (mRecreateBitmap) {
+    // createBitmap();
+    // super.onSizeChanged(w, h, oldw, oldh);
+    // mRecreateBitmap = false;
+    // }
+    // }
 
     /**
      * Handle touch screen motion events.
-     *
+     * 
      * @param event The motion event.
      * @return True if the event was handled, false otherwise.
      */
@@ -153,16 +152,15 @@ public boolean onTouchEvent(MotionEvent event) {
     }
 
 
-   // // This hasn't been called anyway for a while now. See also
-   // //  onSizeChanged and createBitmap for more comments.
-   //  /**
-   //   * Create a new bitmap that fits the new screen layout. The content of the whiteboard does not survive screen
-   //   * rotation.
-   //   */
-   //  public void rotate() {
-   //      mRecreateBitmap = true;
-   //  }
-
+    // // This hasn't been called anyway for a while now. See also
+    // // onSizeChanged and createBitmap for more comments.
+    // /**
+    // * Create a new bitmap that fits the new screen layout. The content of the whiteboard does not survive screen
+    // * rotation.
+    // */
+    // public void rotate() {
+    // mRecreateBitmap = true;
+    // }
 
     /**
      * Clear the whiteboard.
@@ -193,12 +191,11 @@ private void createBitmap(int w, int h, Bitmap.Config conf) {
 
 
     private void createBitmap() {
-       // To fix issue #1336, just make the whiteboard big and
-       // square.
-       int bitmapSize = Math.max(AnkiDroidApp.getDisplayWidth(),
-                                 AnkiDroidApp.getDisplayHeight());
+        // To fix issue #1336, just make the whiteboard big and
+        // square.
+        int bitmapSize = Math.max(AnkiDroidApp.getDisplayWidth(), AnkiDroidApp.getDisplayHeight());
         if (mMonochrome && !mInvertedColors) {
-           createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);
+            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);
         } else {
             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);
         }
diff --git a/src/com/ichi2/anki/multimediacard/activity/MultimediaCardEditorActivity.java b/src/com/ichi2/anki/multimediacard/activity/MultimediaCardEditorActivity.java
index 73fa3cce9532..7c88b5269f21 100644
--- a/src/com/ichi2/anki/multimediacard/activity/MultimediaCardEditorActivity.java
+++ b/src/com/ichi2/anki/multimediacard/activity/MultimediaCardEditorActivity.java
@@ -218,7 +218,7 @@ public void onClick(View v) {
 
     /**
      * Creates the UI for editor area inside EditorLayout
-     *
+     * 
      * @param note
      */
     private void createEditorUI(IMultimediaEditableNote note) {
@@ -525,7 +525,7 @@ public void onClick(DialogInterface dialog, int item) {
     /**
      * Change current model for the Note. Changes both MultimediaNote and the mEditorNote (Note Object) and copies
      * existing values to both.
-     *
+     * 
      * @param newId
      */
     protected void changeCurrentModel(long newId) {
diff --git a/src/com/ichi2/anki/multimediacard/fields/BasicControllerFactory.java b/src/com/ichi2/anki/multimediacard/fields/BasicControllerFactory.java
index d6f51340f190..66f206d396c9 100644
--- a/src/com/ichi2/anki/multimediacard/fields/BasicControllerFactory.java
+++ b/src/com/ichi2/anki/multimediacard/fields/BasicControllerFactory.java
@@ -19,7 +19,6 @@
 
 package com.ichi2.anki.multimediacard.fields;
 
-
 public class BasicControllerFactory implements IControllerFactory {
 
     private BasicControllerFactory() {
diff --git a/src/com/ichi2/anki/multimediacard/fields/BasicTextFieldController.java b/src/com/ichi2/anki/multimediacard/fields/BasicTextFieldController.java
index bb5ee1c0a43b..c62d68c9ee6c 100644
--- a/src/com/ichi2/anki/multimediacard/fields/BasicTextFieldController.java
+++ b/src/com/ichi2/anki/multimediacard/fields/BasicTextFieldController.java
@@ -99,7 +99,7 @@ private String gtxt(int id) {
 
     /**
      * Google Image Search
-     *
+     * 
      * @param layoutTools
      * @param p
      */
diff --git a/src/com/ichi2/anki/multimediacard/fields/IControllerFactory.java b/src/com/ichi2/anki/multimediacard/fields/IControllerFactory.java
index 0aa49382fe23..272ea60b3867 100644
--- a/src/com/ichi2/anki/multimediacard/fields/IControllerFactory.java
+++ b/src/com/ichi2/anki/multimediacard/fields/IControllerFactory.java
@@ -20,7 +20,6 @@
 
 package com.ichi2.anki.multimediacard.fields;
 
-
 public interface IControllerFactory {
 
     IFieldController createControllerForField(IField field);
diff --git a/src/com/ichi2/anki/multimediacard/fields/IField.java b/src/com/ichi2/anki/multimediacard/fields/IField.java
index 82eb1409246a..0c5909a26132 100644
--- a/src/com/ichi2/anki/multimediacard/fields/IField.java
+++ b/src/com/ichi2/anki/multimediacard/fields/IField.java
@@ -66,7 +66,7 @@ public interface IField extends Serializable {
 
     /**
      * Mark if the current media path is temporary and if it should be deleted once the media has been processed.
-     *
+     * 
      * @param hasTemporaryMedia True if the media is temporary, False if it is existing media.
      * @return
      */
@@ -85,7 +85,7 @@ public interface IField extends Serializable {
     /**
      * Returns the formatted value for this field. Each implementation of IField should return in a format which will be
      * used to store in the database
-     *
+     * 
      * @return
      */
     public String getFormattedValue();
diff --git a/src/com/ichi2/anki/multimediacard/impl/NoteFactory.java b/src/com/ichi2/anki/multimediacard/impl/NoteFactory.java
index 0fb2861caf88..4fb4422e748b 100644
--- a/src/com/ichi2/anki/multimediacard/impl/NoteFactory.java
+++ b/src/com/ichi2/anki/multimediacard/impl/NoteFactory.java
@@ -1,3 +1,7 @@
+/**
+ * @author Zaur
+ */
+
 package com.ichi2.anki.multimediacard.impl;
 
 import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
@@ -5,35 +9,30 @@
 import com.ichi2.anki.multimediacard.fields.TextField;
 
 /**
- * @author Zaur
- *
- *         Creates IMultimediaEditableNotes according to various parameters.
- *
+ * Creates IMultimediaEditableNotes according to various parameters.
  */
-public class NoteFactory
-{
-	public static IMultimediaEditableNote createNote()
-	{
-		MultimediaEditableNote note = new MultimediaEditableNote();
-		note.setNumFields(4);
-
-		TextField tf = new TextField();
-		tf.setText("world");
-		note.setField(0, tf);
-
-		TextField tf2 = new TextField();
-		tf2.setText("Welt");
-		note.setField(1, tf2);
-
-		TextField tf3 = new TextField();
-		tf3.setText("Übung");
-		note.setField(2, tf3);
-
-		ImageField imageField = new ImageField();
-		imageField.setImagePath("/mnt/sdcard/img/1.jpg");
-		note.setField(3, imageField);
-
-		return note;
-	}
+public class NoteFactory {
+    public static IMultimediaEditableNote createNote() {
+        MultimediaEditableNote note = new MultimediaEditableNote();
+        note.setNumFields(4);
+
+        TextField tf = new TextField();
+        tf.setText("world");
+        note.setField(0, tf);
+
+        TextField tf2 = new TextField();
+        tf2.setText("Welt");
+        note.setField(1, tf2);
+
+        TextField tf3 = new TextField();
+        tf3.setText("Übung");
+        note.setField(2, tf3);
+
+        ImageField imageField = new ImageField();
+        imageField.setImagePath("/mnt/sdcard/img/1.jpg");
+        note.setField(3, imageField);
+
+        return note;
+    }
 
 }
diff --git a/src/com/ichi2/anki/receiver/SdCardReceiver.java b/src/com/ichi2/anki/receiver/SdCardReceiver.java
index b7f851341fa9..bf5167d307bc 100644
--- a/src/com/ichi2/anki/receiver/SdCardReceiver.java
+++ b/src/com/ichi2/anki/receiver/SdCardReceiver.java
@@ -25,33 +25,34 @@
 import com.ichi2.libanki.Collection;
 
 /**
- * This Broadcast-Receiver listens to media ejects and closes the collection prior to unmount. It then sends a broadcast intent
- * to all activities which might be open in order to show an appropriate screen
- * After media has been remounted, another broadcast intent will be sent to let the activites know about it
+ * This Broadcast-Receiver listens to media ejects and closes the collection prior to unmount. It then sends a broadcast
+ * intent to all activities which might be open in order to show an appropriate screen After media has been remounted,
+ * another broadcast intent will be sent to let the activites know about it
  */
 
 public class SdCardReceiver extends BroadcastReceiver {
 
-	public static final String MEDIA_EJECT = "com.ichi2.anki.action.MEDIA_EJECT";
-	public static final String MEDIA_MOUNT = "com.ichi2.anki.action.MEDIA_MOUNT";
+    public static final String MEDIA_EJECT = "com.ichi2.anki.action.MEDIA_EJECT";
+    public static final String MEDIA_MOUNT = "com.ichi2.anki.action.MEDIA_MOUNT";
 
-	@Override
-	public void onReceive(Context context, Intent intent) {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
         if (intent.getAction().equals(Intent.ACTION_MEDIA_EJECT)) {
-        	Log.i(AnkiDroidApp.TAG, "media eject detected - closing collection and sending broadcast");
-        	Intent i = new Intent();
-        	i.setAction(MEDIA_EJECT);
-        	context.sendBroadcast(i);
-        	Collection col = AnkiDroidApp.getCol();
+            Log.i(AnkiDroidApp.TAG, "media eject detected - closing collection and sending broadcast");
+            Intent i = new Intent();
+            i.setAction(MEDIA_EJECT);
+            context.sendBroadcast(i);
+            Collection col = AnkiDroidApp.getCol();
             if (col != null) {
-            	col.close();
+                col.close();
             }
         } else if (intent.getAction().equals(Intent.ACTION_MEDIA_MOUNTED)) {
-        	Log.i(AnkiDroidApp.TAG, "media mount detected - sending broadcast");
-        	Intent i = new Intent();
-        	i.setAction(MEDIA_MOUNT);
-        	context.sendBroadcast(i);
+            Log.i(AnkiDroidApp.TAG, "media mount detected - sending broadcast");
+            Intent i = new Intent();
+            i.setAction(MEDIA_MOUNT);
+            context.sendBroadcast(i);
         }
-	}
+    }
 
 }
diff --git a/src/com/ichi2/anki/reviewer/CustomFontsReviewerExt.java b/src/com/ichi2/anki/reviewer/CustomFontsReviewerExt.java
index bc01056289dc..8c26fca841fe 100644
--- a/src/com/ichi2/anki/reviewer/CustomFontsReviewerExt.java
+++ b/src/com/ichi2/anki/reviewer/CustomFontsReviewerExt.java
@@ -38,6 +38,7 @@ public class CustomFontsReviewerExt implements ReviewerExt {
     private String mDominantFontStyle;
     private final boolean mSupportsQuickUpdate;
 
+
     public CustomFontsReviewerExt(Context context) {
         Map<String, AnkiFont> customFontsMap = getCustomFontsMap(context);
         mCustomStyle = getCustomFontsStyle(customFontsMap) + getDominantFontStyle(context, customFontsMap);
@@ -50,6 +51,7 @@ public void updateCssStyle(StringBuilder cssStyle) {
         cssStyle.append(mCustomStyle);
     }
 
+
     @Override
     public boolean supportsQuickUpdate() {
         return mSupportsQuickUpdate;
@@ -75,6 +77,7 @@ private static String getCustomFontsStyle(Map<String, AnkiFont> customFontsMap)
 
     /**
      * Returns the CSS used to set the theme font.
+     * 
      * @return the font style, or the empty string if no font is set
      */
     private String getThemeFontStyle() {
@@ -98,6 +101,7 @@ private String getThemeFontStyle() {
 
     /**
      * Returns the CSS used to set the default font.
+     * 
      * @return the default font style, or the empty string if no default font is set
      */
     private String getDefaultFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
@@ -116,6 +120,7 @@ private String getDefaultFontStyle(Context context, Map<String, AnkiFont> custom
 
     /**
      * Returns the CSS used to set the override font.
+     * 
      * @return the override font style, or the empty string if no override font is set
      */
     private String getOverrideFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
@@ -134,6 +139,7 @@ private String getOverrideFontStyle(Context context, Map<String, AnkiFont> custo
 
     /**
      * Returns the CSS that determines font choice in a global fashion.
+     * 
      * @return the font style, or the empty string if none applies
      */
     private String getDominantFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
@@ -152,8 +158,8 @@ private String getDominantFontStyle(Context context, Map<String, AnkiFont> custo
 
     /**
      * Returns a map from custom fonts names to the corresponding {@link AnkiFont} object.
-     *
-     * <p>The list of constructed lazily the first time is needed.
+     * <p>
+     * The list of constructed lazily the first time is needed.
      */
     private static Map<String, AnkiFont> getCustomFontsMap(Context context) {
         List<AnkiFont> fonts = Utils.getCustomFonts(context);
@@ -164,5 +170,4 @@ private static Map<String, AnkiFont> getCustomFontsMap(Context context) {
         return customFontsMap;
     }
 
-
 }
diff --git a/src/com/ichi2/anki/reviewer/ReviewerExt.java b/src/com/ichi2/anki/reviewer/ReviewerExt.java
index 2a16294c9fa6..bdf7bb8820fb 100644
--- a/src/com/ichi2/anki/reviewer/ReviewerExt.java
+++ b/src/com/ichi2/anki/reviewer/ReviewerExt.java
@@ -20,16 +20,16 @@
 
 /**
  * An extension to the reviewer class.
- *
- * <p>This allows splitting parts of the code that offer a specific feature outside the activity itself.
+ * <p>
+ * This allows splitting parts of the code that offer a specific feature outside the activity itself.
  */
 public interface ReviewerExt {
 
     /**
      * Hook for updating the CSS style used by a card.
-     *
-     * <p>It should modify the content of the {@link StringBuilder} to reflect the new style.
-     *
+     * <p>
+     * It should modify the content of the {@link StringBuilder} to reflect the new style.
+     * 
      * @param cssStyle containing current style
      */
     void updateCssStyle(StringBuilder cssStyle);
diff --git a/src/com/ichi2/anki/reviewer/ReviewerExtRegistry.java b/src/com/ichi2/anki/reviewer/ReviewerExtRegistry.java
index 5afb15499ef8..95f6b65b1a73 100644
--- a/src/com/ichi2/anki/reviewer/ReviewerExtRegistry.java
+++ b/src/com/ichi2/anki/reviewer/ReviewerExtRegistry.java
@@ -31,13 +31,11 @@ public class ReviewerExtRegistry implements ReviewerExt {
 
     /**
      * Creates the list of extensions.
-     *
-     * <p>Must be called at the beginning of onCreate().
+     * <p>
+     * Must be called at the beginning of onCreate().
      */
     public ReviewerExtRegistry(Context context) {
-        mReviewerExts = new ReviewerExt[]{
-            new CustomFontsReviewerExt(context),
-        };
+        mReviewerExts = new ReviewerExt[] { new CustomFontsReviewerExt(context), };
     }
 
 
diff --git a/src/com/ichi2/anki/servicelayer/NoteService.java b/src/com/ichi2/anki/servicelayer/NoteService.java
index f0c17893ea93..d49123a1b3e6 100644
--- a/src/com/ichi2/anki/servicelayer/NoteService.java
+++ b/src/com/ichi2/anki/servicelayer/NoteService.java
@@ -43,7 +43,7 @@
 public class NoteService {
     /**
      * Creates an empty Note from given Model
-     *
+     * 
      * @param model the model in JSOBObject format
      * @return a new note instance
      */
@@ -99,7 +99,7 @@ public static void updateMultimediaNoteFromJsonNote(final Note editorNoteSrc, fi
     /**
      * Updates the JsonNote field values from MultimediaEditableNote When both notes are using the same Model, it updaes
      * the destination field values with source values. If models are different it throws an Exception
-     *
+     * 
      * @param mNoteSrc
      * @param mEditorNoteDst
      */
@@ -123,7 +123,7 @@ public static void updateJsonNoteFromMultimediaNote(final IMultimediaEditableNot
      * the note it checks for the following condition a. The field content should have changed b. The field content does
      * not already point to a media inside anki media path If both condition satisfies then it copies the file inside
      * the media path and deletes the file referenced by the note
-     *
+     * 
      * @param note
      */
     public static void saveMedia(final MultimediaEditableNote noteNew) {
@@ -155,7 +155,7 @@ public static void saveMedia(final MultimediaEditableNote noteNew) {
 
     /**
      * Considering the field is new, if it has media handle it
-     *
+     * 
      * @param field
      */
     private static void importMediaToDirectory(IField field) {
diff --git a/src/com/ichi2/async/Connection.java b/src/com/ichi2/async/Connection.java
index 94716a28ec14..bf1446324af4 100644
--- a/src/com/ichi2/async/Connection.java
+++ b/src/com/ichi2/async/Connection.java
@@ -142,6 +142,7 @@ protected void onCancelled() {
         }
     }
 
+
     /*
      * Runs on GUI thread
      */
@@ -182,6 +183,7 @@ public static boolean taskIsCancelled() {
         return sInstance.isCancelled();
     }
 
+
     public static void cancelTask() {
         try {
             if (sInstance != null && sInstance.getStatus() != AsyncTask.Status.FINISHED) {
@@ -192,6 +194,7 @@ public static void cancelTask() {
         }
     }
 
+
     public static Connection login(TaskListener listener, Payload data) {
         data.taskType = TASK_TYPE_LOGIN;
         return launchConnectionTask(listener, data);
@@ -285,7 +288,7 @@ private Payload doOneInBackground(Payload data) {
                 return doInBackgroundUpgradeDecks(data);
 
             case TASK_TYPE_DOWNLOAD_SHARED_DECK:
-            	return doInBackgroundDownloadSharedDeck(data);
+                return doInBackgroundDownloadSharedDeck(data);
 
             default:
                 return null;
@@ -302,7 +305,8 @@ private Payload doInBackgroundLogin(Payload data) {
         boolean valid = false;
         if (ret != null) {
             data.returnType = ret.getStatusLine().getStatusCode();
-            Log.i(AnkiDroidApp.TAG, "doInBackgroundLogin - response from server: " + data.returnType + " (" + ret.getStatusLine().getReasonPhrase() + ")");
+            Log.i(AnkiDroidApp.TAG, "doInBackgroundLogin - response from server: " + data.returnType + " ("
+                    + ret.getStatusLine().getReasonPhrase() + ")");
             if (data.returnType == 200) {
                 try {
                     JSONObject jo = (new JSONObject(server.stream2String(ret.getEntity().getContent())));
@@ -470,8 +474,8 @@ private Payload doInBackgroundUpgradeDecks(Payload data) {
             InputStream cont = resp.getEntity().getContent();
             if (!h.writeToFile(cont, colFilename)) {
                 data.success = false;
-                data.data = new Object[] { sContext.getString(R.string.upgrade_deck_web_upgrade_sdcard,
-                        new File(colFilename).length() / 1048576 + 1) };
+                data.data = new Object[] { sContext.getString(R.string.upgrade_deck_web_upgrade_sdcard, new File(
+                        colFilename).length() / 1048576 + 1) };
                 (new File(colFilename)).delete();
                 return data;
             }
@@ -506,7 +510,7 @@ private Payload doInBackgroundUpgradeDecks(Payload data) {
             publishProgress(new Object[] { R.string.upgrade_decks_media });
             ArrayList<String> failedMedia = new ArrayList<String>();
             File curMediaDir = null;
-            for ( File mediaDir : mediaDirs) {
+            for (File mediaDir : mediaDirs) {
                 curMediaDir = mediaDir;
                 // Check if media directory exists and is local
                 if (!curMediaDir.exists() || !curMediaDir.isDirectory()) {
@@ -528,7 +532,7 @@ private Payload doInBackgroundUpgradeDecks(Payload data) {
                 }
             }
 
-            data.data = new Object[] { failed, failedMedia, newMediaDir.getAbsolutePath()};
+            data.data = new Object[] { failed, failedMedia, newMediaDir.getAbsolutePath() };
             data.success = true;
             return data;
         } catch (FileNotFoundException e) {
@@ -576,7 +580,8 @@ private Payload doInBackgroundRegister(Payload data) {
             data.data = new String[] { username, hostkey };
         } else {
             data.success = false;
-            data.data = new String[] { status != null ? status : AnkiDroidApp.getAppResources().getString(R.string.connection_error_message)};
+            data.data = new String[] { status != null ? status : AnkiDroidApp.getAppResources().getString(
+                    R.string.connection_error_message) };
         }
         return data;
     }
@@ -594,13 +599,13 @@ private Payload doInBackgroundSync(Payload data) {
         boolean colCorruptFullSync = false;
         Collection col = AnkiDroidApp.getCol();
         if (!AnkiDroidApp.colIsOpen()) {
-        	if (conflictResolution != null && conflictResolution.equals("download")) {
-        		colCorruptFullSync = true;
-        	} else {
+            if (conflictResolution != null && conflictResolution.equals("download")) {
+                colCorruptFullSync = true;
+            } else {
                 data.success = false;
                 data.result = new Object[] { "genericError" };
                 return data;
-        	}
+            }
         }
         String path = AnkiDroidApp.getCollectionPath();
 
@@ -675,15 +680,15 @@ private Payload doInBackgroundSync(Payload data) {
                 }
                 col = AnkiDroidApp.openCollection(path);
             } catch (OutOfMemoryError e) {
-            	AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-fullSync");
+                AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-fullSync");
                 data.success = false;
-                data.result = new Object[]{"OutOfMemoryError"};
+                data.result = new Object[] { "OutOfMemoryError" };
                 data.data = new Object[] { mediaUsn };
                 return data;
             } catch (RuntimeException e) {
-            	AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-fullSync");
+                AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-fullSync");
                 data.success = false;
-                data.result = new Object[]{"IOException"};
+                data.result = new Object[] { "IOException" };
                 data.data = new Object[] { mediaUsn };
                 return data;
             }
@@ -691,7 +696,7 @@ private Payload doInBackgroundSync(Payload data) {
 
         // clear undo to avoid non syncing orphans (because undo resets usn too
         if (!noChanges) {
-        	col.clearUndo();
+            col.clearUndo();
         }
 
         // then move on to media sync
@@ -709,15 +714,16 @@ private Payload doInBackgroundSync(Payload data) {
                     if (ret.equals("noChanges")) {
                         publishProgress(R.string.sync_media_no_changes);
                         noMediaChanges = true;
-                    } if (ret.equals("sanityFailed")) {
+                    }
+                    if (ret.equals("sanityFailed")) {
                         mediaError = AnkiDroidApp.getAppResources().getString(R.string.sync_media_sanity_failed);
                     } else {
                         publishProgress(R.string.sync_media_success);
                     }
                 }
             } catch (RuntimeException e) {
-               AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-mediaSync");
-               mediaError = e.getLocalizedMessage();
+                AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSync-mediaSync");
+                mediaError = e.getLocalizedMessage();
             }
         }
         if (noChanges && noMediaChanges) {
@@ -743,7 +749,6 @@ private Payload doInBackgroundSync(Payload data) {
     }
 
 
-
     public void publishProgress(int id) {
         super.publishProgress(id);
     }
@@ -806,7 +811,7 @@ private Payload doInBackgroundSendFeedback(Payload data) {
 
     /**
      * Downloads any missing media files according to the mediaURL deckvar.
-     *
+     * 
      * @param data
      * @return The return type contains data.resultType and an array of Integer in data.data. data.data[0] is the number
      *         of total missing media, data.data[1] is the number of downloaded ones.
@@ -960,29 +965,29 @@ private Payload doInBackgroundDownloadSharedDeck(Payload data) {
         URL fileUrl;
         URLConnection conn;
         InputStream cont = null;
-		try {
-		    fileUrl = new URL(url);
-		    if (url.startsWith("https")) {
-	            SSLContext context = SSLContext.getInstance("TLS");
-	            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);
-	            HttpsURLConnection httpsConn = (HttpsURLConnection)fileUrl.openConnection();
-	            httpsConn.setSSLSocketFactory(context.getSocketFactory());
-	            conn = httpsConn;
-		    } else {
-		        conn = (HttpURLConnection)fileUrl.openConnection();
-		    }
-	        conn.setConnectTimeout(10000);
-	        conn.setReadTimeout(10000);
-	        cont = conn.getInputStream();
-		} catch (MalformedURLException e) {
+        try {
+            fileUrl = new URL(url);
+            if (url.startsWith("https")) {
+                SSLContext context = SSLContext.getInstance("TLS");
+                context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);
+                HttpsURLConnection httpsConn = (HttpsURLConnection) fileUrl.openConnection();
+                httpsConn.setSSLSocketFactory(context.getSocketFactory());
+                conn = httpsConn;
+            } else {
+                conn = (HttpURLConnection) fileUrl.openConnection();
+            }
+            conn.setConnectTimeout(10000);
+            conn.setReadTimeout(10000);
+            cont = conn.getInputStream();
+        } catch (MalformedURLException e) {
             Log.e(AnkiDroidApp.TAG, "doInBackgroundDownloadSharedDeck: ", e);
             data.success = false;
             return data;
-		} catch (IOException e) {
+        } catch (IOException e) {
             Log.e(AnkiDroidApp.TAG, "doInBackgroundDownloadSharedDeck: ", e);
             data.success = false;
             return data;
-		} catch (NoSuchAlgorithmException e) {
+        } catch (NoSuchAlgorithmException e) {
             Log.e(AnkiDroidApp.TAG, "doInBackgroundDownloadSharedDeck: ", e);
             data.success = false;
             return data;
@@ -1161,10 +1166,12 @@ public boolean accept(File pathname) {
     public class CancelCallback {
         private WeakReference<ThreadSafeClientConnManager> mConnectionManager = null;
 
+
         public void setConnectionManager(ThreadSafeClientConnManager connectionManager) {
             mConnectionManager = new WeakReference<ThreadSafeClientConnManager>(connectionManager);
         }
 
+
         public void cancelAllConnections() {
             if (mConnectionManager != null) {
                 ThreadSafeClientConnManager connectionManager = mConnectionManager.get();
diff --git a/src/com/ichi2/async/DeckTask.java b/src/com/ichi2/async/DeckTask.java
index 244d2364c9d0..263262a1f05c 100644
--- a/src/com/ichi2/async/DeckTask.java
+++ b/src/com/ichi2/async/DeckTask.java
@@ -123,7 +123,7 @@ public class DeckTask extends BaseAsyncTask<DeckTask.TaskData, DeckTask.TaskData
      * Tasks will be executed serially, in the order in which they are started.
      * <p>
      * This method must be called on the main thread.
-     *
+     * 
      * @param type of the task to start
      * @param listener to the status and result of the task
      * @param params to pass to the task
@@ -131,8 +131,9 @@ public class DeckTask extends BaseAsyncTask<DeckTask.TaskData, DeckTask.TaskData
      */
     public static DeckTask launchDeckTask(int type, Listener listener, TaskData... params) {
         // Before starting a new task, cancel rendering of Q&A for browser
-        Log.i(AnkiDroidApp.TAG, "launchDeckTask("+type+")");
-        if (sLatestInstance!=null && sLatestInstance.mType==TASK_TYPE_RENDER_BROWSER_QA && !sLatestInstance.isCancelled()){
+        Log.i(AnkiDroidApp.TAG, "launchDeckTask(" + type + ")");
+        if (sLatestInstance != null && sLatestInstance.mType == TASK_TYPE_RENDER_BROWSER_QA
+                && !sLatestInstance.isCancelled()) {
             Log.i(AnkiDroidApp.TAG, "DeckTask: cancelling render browser QA...");
             sLatestInstance.cancel(true);
             waitToFinish();
@@ -171,9 +172,10 @@ public static void cancelTask() {
         }
     }
 
+
     public static void cancelTask(int taskType) {
         try {
-            Boolean match = sLatestInstance.mType==taskType;
+            Boolean match = sLatestInstance.mType == taskType;
             if ((sLatestInstance != null) && (sLatestInstance.getStatus() != AsyncTask.Status.FINISHED) && (match)) {
                 sLatestInstance.cancel(true);
             }
@@ -205,6 +207,7 @@ public DeckTask(int type, Listener listener, DeckTask previousTask) {
         mPreviousTask = previousTask;
     }
 
+
     // This method and those that are called here are executed in a new thread
     @Override
     protected TaskData doInBackground(TaskData... params) {
@@ -220,7 +223,8 @@ protected TaskData doInBackground(TaskData... params) {
             }
             try {
                 mPreviousTask.get();
-                Log.i(AnkiDroidApp.TAG, "Finished waiting for " + mPreviousTask.mType + " to finish. Status= " + mPreviousTask.getStatus());
+                Log.i(AnkiDroidApp.TAG, "Finished waiting for " + mPreviousTask.mType + " to finish. Status= "
+                        + mPreviousTask.getStatus());
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
                 // We have been interrupted, return immediately.
@@ -234,7 +238,7 @@ protected TaskData doInBackground(TaskData... params) {
                 Log.e(AnkiDroidApp.TAG, "previously running task was cancelled: " + mPreviousTask.mType, e);
             }
         }
-        
+
         // Actually execute the task now that we are at the front of the queue.
         switch (mType) {
             case TASK_TYPE_OPEN_COLLECTION:
@@ -331,7 +335,7 @@ protected TaskData doInBackground(TaskData... params) {
                 return doInBackgroundConfSetSubdecks(params);
 
             case TASK_TYPE_RENDER_BROWSER_QA:
-            	return doInBackgroundRenderBrowserQA(params);
+                return doInBackgroundRenderBrowserQA(params);
 
             default:
                 Log.e(AnkiDroidApp.TAG, "unknown task type: " + mType);
@@ -584,7 +588,7 @@ private TaskData doInBackgroundDismissNote(TaskData... params) {
                         col.markUndo(Collection.UNDO_BURY_CARD,
                                 new Object[] { col.getDirty(), note.cards(), card.getId() });
                         // then bury
-                        sched.buryCards(new long[]{ card.getId() });
+                        sched.buryCards(new long[] { card.getId() });
                         sHadCardQueue = true;
                         break;
                     case 0:
@@ -727,54 +731,57 @@ private TaskData doInBackgroundSearchCards(TaskData... params) {
         return new TaskData(col.cardCount(col.getDecks().allIds()));
     }
 
-    private TaskData doInBackgroundRenderBrowserQA(TaskData...params) {
-        final int initialInterval=15;   // initial number of cards we render one by one
-        final int refreshInterval=250;  // number of cards to render at a time after initialInterval
-        int numRendered=0;
-    	Log.i(AnkiDroidApp.TAG, "doInBackgroundRenderBrowserQA");
+
+    private TaskData doInBackgroundRenderBrowserQA(TaskData... params) {
+        final int initialInterval = 15; // initial number of cards we render one by one
+        final int refreshInterval = 250; // number of cards to render at a time after initialInterval
+        int numRendered = 0;
+        Log.i(AnkiDroidApp.TAG, "doInBackgroundRenderBrowserQA");
         Collection col = (Collection) params[0].getObjArray()[0];
         ArrayList<HashMap<String, String>> items = (ArrayList<HashMap<String, String>>) params[0].getObjArray()[1];
         // for each card in the browser list
-        try{
-            for (HashMap<String, String> item: items) {
+        try {
+            for (HashMap<String, String> item : items) {
                 // Extract card item
-            	Card c = col.getCard(Long.parseLong(item.get("id"), 10));
+                Card c = col.getCard(Long.parseLong(item.get("id"), 10));
                 // render question and answer
-    	        HashMap<String, String> qa=c._getQA(true, true);
-            	// update the original hash map to include rendered question & answer
-    			String q = qa.get("q");
-    			String a = qa.get("a");
-    			// remove the question from the start of the answer if it exists
-    			if (a.startsWith(q)){
-    			    a=a.replaceFirst(Pattern.quote(q), "");
-    			}
-    			// put all of the fields in except for those that have already been pulled out straight from the database
-            	item.put("answer",formatQA(a));
-            	item.put("card", c.template().optString("name"));
-            	//item.put("changed",strftime("%Y-%m-%d", localtime(c.getMod())));
-            	//item.put("created",strftime("%Y-%m-%d", localtime(c.note().getId()/1000)));
-            	//item.put("due",getDueString(c));
-            	//item.put("ease","");
-            	//item.put("edited",strftime("%Y-%m-%d", localtime(c.note().getMod())));
-            	//item.put("interval","");
-            	item.put("lapses",Integer.toString(c.getLapses()));
-            	item.put("note",c.model().optString("name"));
-                item.put("question",formatQA(q));
-                item.put("reviews",Integer.toString(c.getReps()));
-        		// Send progress periodically so that QA list in browser updates
+                HashMap<String, String> qa = c._getQA(true, true);
+                // update the original hash map to include rendered question & answer
+                String q = qa.get("q");
+                String a = qa.get("a");
+                // remove the question from the start of the answer if it exists
+                if (a.startsWith(q)) {
+                    a = a.replaceFirst(Pattern.quote(q), "");
+                }
+                // put all of the fields in except for those that have already been pulled out straight from the
+                // database
+                item.put("answer", formatQA(a));
+                item.put("card", c.template().optString("name"));
+                // item.put("changed",strftime("%Y-%m-%d", localtime(c.getMod())));
+                // item.put("created",strftime("%Y-%m-%d", localtime(c.note().getId()/1000)));
+                // item.put("due",getDueString(c));
+                // item.put("ease","");
+                // item.put("edited",strftime("%Y-%m-%d", localtime(c.note().getMod())));
+                // item.put("interval","");
+                item.put("lapses", Integer.toString(c.getLapses()));
+                item.put("note", c.model().optString("name"));
+                item.put("question", formatQA(q));
+                item.put("reviews", Integer.toString(c.getReps()));
+                // Send progress periodically so that QA list in browser updates
                 if (isCancelled()) {
                     return null;
                 } else {
-                	numRendered++;
-                	if (numRendered%refreshInterval==0 || numRendered<=initialInterval){
+                    numRendered++;
+                    if (numRendered % refreshInterval == 0 || numRendered <= initialInterval) {
                         TaskData result = new TaskData(items);
-                		publishProgress(result);
-                	}
+                        publishProgress(result);
+                    }
 
                 }
             }
-        } catch (OutOfMemoryError e){
-            // TODO: Check if this is actually effective at dealing with the error, maybe the ArrayList has grown too big to recover?
+        } catch (OutOfMemoryError e) {
+            // TODO: Check if this is actually effective at dealing with the error, maybe the ArrayList has grown too
+            // big to recover?
             Log.e(AnkiDroidApp.TAG, "OutOfMemoryError rendering the Q&A for browser... probably too many cards");
             return null;
         }
@@ -783,9 +790,10 @@ private TaskData doInBackgroundRenderBrowserQA(TaskData...params) {
         return result;
     }
 
-    private String formatQA(String txt){
+
+    private String formatQA(String txt) {
         /* Strips all formatting from the string txt for use in displaying question/answer in browser */
-        String s=txt.replace("<br>"," ");
+        String s = txt.replace("<br>", " ");
         s = s.replace("<br />", " ");
         s = s.replace("<div>", " ");
         s = s.replace("\n", " ");
@@ -796,6 +804,7 @@ private String formatQA(String txt){
         return s;
     }
 
+
     private TaskData doInBackgroundLoadStatistics(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadStatistics");
         Collection col = params[0].getCollection();
@@ -853,7 +862,8 @@ private TaskData doInBackgroundCloseCollection(TaskData... params) {
                 AnkiDroidApp.closeCollection(true);
                 BackupManager.performBackup(path);
             } catch (RuntimeException e) {
-                Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseCollection: error occurred - collection not properly closed");
+                Log.i(AnkiDroidApp.TAG,
+                        "doInBackgroundCloseCollection: error occurred - collection not properly closed");
             }
         }
         return null;
@@ -1713,7 +1723,6 @@ public TaskData(List<Long> idList) {
         }
 
 
-
         public ArrayList<HashMap<String, String>> getCards() {
             return mCards;
         }
diff --git a/src/com/ichi2/charts/ChartBuilder.java b/src/com/ichi2/charts/ChartBuilder.java
index b9d25ca5d59e..3ab2e51c03e8 100644
--- a/src/com/ichi2/charts/ChartBuilder.java
+++ b/src/com/ichi2/charts/ChartBuilder.java
@@ -294,10 +294,10 @@ public static StyledDialog getStatisticsDialog(Context context, DialogInterface.
         Resources res = context.getResources();
         String[] text = res.getStringArray(R.array.stats_period);
         int height = context.getResources().getDrawable(R.drawable.white_btn_radio).getIntrinsicHeight();
-        
-        //workaround for text overlapping radiobutton. 
-        //It appears that when API Level is <= 16, the text would overlap the radio button, hence the
-        //addition of spaces.
+
+        // workaround for text overlapping radiobutton.
+        // It appears that when API Level is <= 16, the text would overlap the radio button, hence the
+        // addition of spaces.
         String spaces = "";
         if (android.os.Build.VERSION.SDK_INT <= android.os.Build.VERSION_CODES.JELLY_BEAN) {
             spaces = "         ";
diff --git a/src/com/ichi2/compat/CompatV15NookHdPlus.java b/src/com/ichi2/compat/CompatV15NookHdPlus.java
index 5d169855d723..c636145dbfd7 100644
--- a/src/com/ichi2/compat/CompatV15NookHdPlus.java
+++ b/src/com/ichi2/compat/CompatV15NookHdPlus.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
@@ -5,8 +6,8 @@
 
 /**
  * Implementation of {@link Compat} for SDK level 15 for Nook HD Plus.
- *
- * <p>This device actually supports disabling WAL via this hidden API and not doing so seems to create issues on this
+ * <p>
+ * This device actually supports disabling WAL via this hidden API and not doing so seems to create issues on this
  * device.
  */
 @TargetApi(16)
diff --git a/src/com/ichi2/compat/CompatV16.java b/src/com/ichi2/compat/CompatV16.java
index 821e23278f21..834388a3b0e4 100644
--- a/src/com/ichi2/compat/CompatV16.java
+++ b/src/com/ichi2/compat/CompatV16.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
diff --git a/src/com/ichi2/compat/CompatV7.java b/src/com/ichi2/compat/CompatV7.java
index bfd40e08355e..ee54669e106f 100644
--- a/src/com/ichi2/compat/CompatV7.java
+++ b/src/com/ichi2/compat/CompatV7.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
@@ -27,21 +28,25 @@ public String normalizeUnicode(String txt) {
         return txt;
     }
 
+
     @Override
     public void setScrollbarFadingEnabled(WebView webview, boolean enable) {
         webview.setScrollbarFadingEnabled(enable);
     }
 
+
     @Override
     public void setOverScrollModeNever(View v) {
     }
 
+
     @Override
     public void invalidateOptionsMenu(Activity activity) {
         ActionBarActivity actionBarActivity = (ActionBarActivity) activity;
         actionBarActivity.supportInvalidateOptionsMenu();
     }
 
+
     @Override
     public void setActionBarBackground(Activity activity, int color) {
         ActionBarActivity actionBarActivity = (ActionBarActivity) activity;
@@ -51,30 +56,35 @@ public void setActionBarBackground(Activity activity, int color) {
         }
     }
 
+
     @Override
     public void setTitle(Activity activity, String title, boolean inverted) {
         ActionBarActivity actionBarActivity = (ActionBarActivity) activity;
         ActionBar actionBar = actionBarActivity.getSupportActionBar();
         if (actionBar != null) {
-            CharacterStyle span = new ForegroundColorSpan(activity.getResources().getColor(inverted ? R.color.white : R.color.black));
+            CharacterStyle span = new ForegroundColorSpan(activity.getResources().getColor(
+                    inverted ? R.color.white : R.color.black));
             SpannableStringBuilder ssb = new SpannableStringBuilder(title);
             ssb.setSpan(span, 0, ssb.length(), 0);
             actionBar.setTitle(ssb);
         }
     }
 
+
     @Override
     public void setSubtitle(Activity activity, String title) {
         setSubtitle(activity, title, false);
     }
 
+
     @Override
     public void setSubtitle(Activity activity, String title, boolean inverted) {
         ActionBarActivity actionBarActivity = (ActionBarActivity) activity;
         ActionBar actionBar = actionBarActivity.getSupportActionBar();
         if (actionBar != null) {
             if (inverted) {
-                CharacterStyle span = new ForegroundColorSpan(activity.getResources().getColor(inverted ? R.color.white : R.color.black));
+                CharacterStyle span = new ForegroundColorSpan(activity.getResources().getColor(
+                        inverted ? R.color.white : R.color.black));
                 SpannableStringBuilder ssb = new SpannableStringBuilder(title);
                 ssb.setSpan(span, 0, ssb.length(), 0);
                 actionBar.setSubtitle(ssb);
@@ -84,6 +94,7 @@ public void setSubtitle(Activity activity, String title, boolean inverted) {
         }
     }
 
+
     @Override
     public void setTtsOnUtteranceProgressListener(TextToSpeech tts) {
         tts.setOnUtteranceCompletedListener(new OnUtteranceCompletedListener() {
@@ -97,14 +108,17 @@ public void onUtteranceCompleted(String utteranceId) {
         });
     }
 
+
     @Override
     public void disableDatabaseWriteAheadLogging(SQLiteDatabase db) {
     }
 
+
     @Override
     public void requestAudioFocus(AudioManager audioManager) {
     }
 
+
     @Override
     public void abandonAudioFocus(AudioManager audioManager) {
     }
diff --git a/src/com/ichi2/compat/CompatV7Nook.java b/src/com/ichi2/compat/CompatV7Nook.java
index 7902af057f05..2aa074d18d2b 100644
--- a/src/com/ichi2/compat/CompatV7Nook.java
+++ b/src/com/ichi2/compat/CompatV7Nook.java
@@ -1,11 +1,13 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
 import android.webkit.WebView;
 
-/** Implementation of {@link Compat} for SDK level 7 for Nooks, e.g. Simple Touch.
- * 
- * <p>This device does not support scrollbar fading.
+/**
+ * Implementation of {@link Compat} for SDK level 7 for Nooks, e.g. Simple Touch.
+ * <p>
+ * This device does not support scrollbar fading.
  **/
 @TargetApi(7)
 public class CompatV7Nook extends CompatV7 implements Compat {
diff --git a/src/com/ichi2/compat/CompatV8.java b/src/com/ichi2/compat/CompatV8.java
index bb02e77462b7..c4b7d23342ca 100644
--- a/src/com/ichi2/compat/CompatV8.java
+++ b/src/com/ichi2/compat/CompatV8.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
@@ -16,11 +17,14 @@ public void onAudioFocusChange(int focusChange) {
         }
     };
 
+
     @Override
     public void requestAudioFocus(AudioManager audioManager) {
-        audioManager.requestAudioFocus(afChangeListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);
+        audioManager.requestAudioFocus(afChangeListener, AudioManager.STREAM_MUSIC,
+                AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);
     }
 
+
     @Override
     public void abandonAudioFocus(AudioManager audioManager) {
         audioManager.abandonAudioFocus(afChangeListener);
diff --git a/src/com/ichi2/compat/CompatV9.java b/src/com/ichi2/compat/CompatV9.java
index 00bb86edfae2..845a8c8b6267 100644
--- a/src/com/ichi2/compat/CompatV9.java
+++ b/src/com/ichi2/compat/CompatV9.java
@@ -1,3 +1,4 @@
+
 package com.ichi2.compat;
 
 import android.annotation.TargetApi;
@@ -17,6 +18,7 @@ public String normalizeUnicode(String txt) {
         return txt;
     }
 
+
     @Override
     public void setOverScrollModeNever(View v) {
         v.setOverScrollMode(View.OVER_SCROLL_NEVER);
diff --git a/src/com/ichi2/filters/AbstractCardFilter.java b/src/com/ichi2/filters/AbstractCardFilter.java
index e99f9165d6b2..31e1d0be5a65 100644
--- a/src/com/ichi2/filters/AbstractCardFilter.java
+++ b/src/com/ichi2/filters/AbstractCardFilter.java
@@ -5,14 +5,14 @@
 
 /**
  * Abstract implementation for card filter.
- *
+ * 
  * @author evgenij.kozhevnikov@gmail.com
  */
 public abstract class AbstractCardFilter implements CardFilter {
 
     /**
      * Check filter setting.
-     *
+     * 
      * @param preferences program settings.
      * @return true, if filter could be run, otherwise false.
      */
diff --git a/src/com/ichi2/filters/CardFilter.java b/src/com/ichi2/filters/CardFilter.java
index c8cf708be7ca..a2cc508a40ac 100644
--- a/src/com/ichi2/filters/CardFilter.java
+++ b/src/com/ichi2/filters/CardFilter.java
@@ -9,14 +9,14 @@
  * Card filter for garbage information. One card filter for one message type from one application. Card filters are
  * based on regular expressions, and when reg exp didn't find garbage information, method must return origin messages.
  * Because all filters run on a chain.
- *
+ * 
  * @author evgenij.kozhevnikov@gmail.com
  */
 public interface CardFilter {
 
     /**
      * Run filter process.
-     *
+     * 
      * @param messages data, received from external application, where first attribute is the SUBJECT information and
      *            second attribute is the TEXT information.
      * @param preferences program settings.
diff --git a/src/com/ichi2/filters/FilterFacade.java b/src/com/ichi2/filters/FilterFacade.java
index 14e25bf5c574..8cde2feacb1e 100644
--- a/src/com/ichi2/filters/FilterFacade.java
+++ b/src/com/ichi2/filters/FilterFacade.java
@@ -11,7 +11,7 @@
 
 /**
  * Filter-facade execute all filtering operations.
- *
+ * 
  * @author evgenij.kozhevnikov@gmail.com
  */
 public class FilterFacade {
@@ -34,7 +34,7 @@ public FilterFacade(Context context) {
 
     /**
      * Run all filters processes. Messages in params will be updated.
-     *
+     * 
      * @param messages data, received from external application, where first attribute is the SUBJECT information and
      *            second attribute is the TEXT information.
      */
diff --git a/src/com/ichi2/filters/GoogleTranslaterFilter.java b/src/com/ichi2/filters/GoogleTranslaterFilter.java
index 01b8462a51f7..807c2abdf7b6 100644
--- a/src/com/ichi2/filters/GoogleTranslaterFilter.java
+++ b/src/com/ichi2/filters/GoogleTranslaterFilter.java
@@ -10,7 +10,7 @@
 
 /**
  * Remove unnecessary information from Google Translate.
- *
+ * 
  * @author evgenij.kozhevnikov@gmail.com
  */
 public class GoogleTranslaterFilter extends AbstractCardFilter {
@@ -36,7 +36,7 @@ public Pair<String, String> filter(Pair<String, String> messages, SharedPreferen
 
     /**
      * Check conditions to running current filter.
-     *
+     * 
      * @param messages original messages.
      * @param preferences program settings.
      * @return true, if filter could be run, otherwise false.
@@ -48,7 +48,7 @@ private boolean isCanBeExecuted(Pair<String, String> messages, SharedPreferences
 
     /**
      * Forming full text message for search.
-     *
+     * 
      * @param messages original messages.
      * @return full text message for search.
      */
diff --git a/src/com/ichi2/libanki/importer/Anki2Importer.java b/src/com/ichi2/libanki/importer/Anki2Importer.java
index fe4c27390986..4907e4533f00 100644
--- a/src/com/ichi2/libanki/importer/Anki2Importer.java
+++ b/src/com/ichi2/libanki/importer/Anki2Importer.java
@@ -52,23 +52,23 @@
 
 public class Anki2Importer {
 
-	Collection mCol;
-	ZipFile mZip;
-	int mTotal;
-	ArrayList<String> mLog;
-	long mTs;
-	String mDeckPrefix = null;
+    Collection mCol;
+    ZipFile mZip;
+    int mTotal;
+    ArrayList<String> mLog;
+    long mTs;
+    String mDeckPrefix = null;
     DeckTask.ProgressCallback mProgress;
     Resources mResources;
 
-	Collection mDst;
-	Collection mSrc;
+    Collection mDst;
+    Collection mSrc;
     String mDstMediaDir;
 
-	HashMap<String, Object[]> mNotes;
-	HashMap<String, HashMap<Integer, Long>> mCards;
-	HashMap<Long, Long> mDecks;
-	HashMap<Long, Long> mModelMap;
+    HashMap<String, Object[]> mNotes;
+    HashMap<String, HashMap<Integer, Long>> mCards;
+    HashMap<Long, Long> mDecks;
+    HashMap<Long, Long> mModelMap;
     HashMap<String, String> mChangedGuids;
     private HashMap<String, String> nameToNum;
 
@@ -79,11 +79,12 @@ public class Anki2Importer {
 
     private static final String CHECKMARK = "\u2714";
 
-	public Anki2Importer (Collection col, String file, DeckTask.ProgressCallback progressCallback) throws IOException {
-		mCol = col;
-		mZip = new ZipFile(new File(file), ZipFile.OPEN_READ);
-		mTotal = 0;
-		mLog = new ArrayList<String>();
+
+    public Anki2Importer(Collection col, String file, DeckTask.ProgressCallback progressCallback) throws IOException {
+        mCol = col;
+        mZip = new ZipFile(new File(file), ZipFile.OPEN_READ);
+        mTotal = 0;
+        mLog = new ArrayList<String>();
         mProgress = progressCallback;
         if (mProgress != null) {
             mResources = mProgress.getResources();
@@ -91,13 +92,15 @@ public Anki2Importer (Collection col, String file, DeckTask.ProgressCallback pro
         nameToNum = new HashMap<String, String>();
     }
 
+
     private void publishProgress(boolean unpacking, int notesDone, int cardsDone, boolean cleanup) {
         if (mProgress != null && mResources != null) {
             mProgress.publishProgress(new DeckTask.TaskData(mResources.getString(R.string.import_add_progress,
-                    (unpacking ? CHECKMARK: "-"), notesDone, cardsDone, (cleanup ? CHECKMARK: "-"))));
+                    (unpacking ? CHECKMARK : "-"), notesDone, cardsDone, (cleanup ? CHECKMARK : "-"))));
         }
     }
 
+
     public int run() {
         publishProgress(false, 0, 0, false);
         try {
@@ -105,8 +108,8 @@ public int run() {
             String tempDir = AnkiDroidApp.getCurrentAnkiDroidDirectory() + "/tmpzip";
             // from anki2.py
             String colFile = tempDir + "/collection.anki2";
-            if (!Utils.unzipFiles(mZip, tempDir, new String[]{"collection.anki2", "media"}, null) ||
-                    !(new File(colFile)).exists() || !Storage.Collection(colFile).validCollection()) {
+            if (!Utils.unzipFiles(mZip, tempDir, new String[] { "collection.anki2", "media" }, null)
+                    || !(new File(colFile)).exists() || !Storage.Collection(colFile).validCollection()) {
                 return -2;
             }
 
@@ -149,7 +152,7 @@ public int run() {
                     }
                     File of = new File(mediaDir, file);
                     if (!of.exists()) {
-                        Utils.unzipFiles(mZip, mediaDir, new String[]{c}, numToName);
+                        Utils.unzipFiles(mZip, mediaDir, new String[] { c }, numToName);
                     }
                 }
             }
@@ -169,59 +172,65 @@ public int run() {
         }
     }
 
-	private void _prepareFiles(String src) {
-		mDst = mCol;
+
+    private void _prepareFiles(String src) {
+        mDst = mCol;
         mDstMediaDir = mDst.getMedia().getDir() + File.separator;
         mSrc = Storage.Collection(src);
-	}
-
-	private int _import() {
-		mDecks = new HashMap<Long, Long>();
-		if (mDeckPrefix != null) {
-			long id = mDst.getDecks().id(mDeckPrefix);
-			mDst.getDecks().select(id);
-		}
-		Log.i(AnkiDroidApp.TAG, "Import - preparing");
-		_prepareTS();
-		_prepareModels();
-		Log.i(AnkiDroidApp.TAG, "Import - importing notes");
+    }
+
+
+    private int _import() {
+        mDecks = new HashMap<Long, Long>();
+        if (mDeckPrefix != null) {
+            long id = mDst.getDecks().id(mDeckPrefix);
+            mDst.getDecks().select(id);
+        }
+        Log.i(AnkiDroidApp.TAG, "Import - preparing");
+        _prepareTS();
+        _prepareModels();
+        Log.i(AnkiDroidApp.TAG, "Import - importing notes");
         _importNotes();
-		Log.i(AnkiDroidApp.TAG, "Import - importing cards");
+        Log.i(AnkiDroidApp.TAG, "Import - importing cards");
         int cnt = _importCards();
-//		_importMedia();
-		Log.i(AnkiDroidApp.TAG, "Import - finishing");
+        // _importMedia();
+        Log.i(AnkiDroidApp.TAG, "Import - finishing");
         publishProgress(true, 100, 100, false);
-		_postImport();
-		// LIBANKI: vacuum and analyze is done in DeckTask
-		return cnt;
-	}
+        _postImport();
+        // LIBANKI: vacuum and analyze is done in DeckTask
+        return cnt;
+    }
 
-	/** timestamps */
 
-	private void _prepareTS() {
-		mTs = Utils.maxID(mDst.getDb());
-	}
+    /** timestamps */
+
+    private void _prepareTS() {
+        mTs = Utils.maxID(mDst.getDb());
+    }
+
+
+    private long ts() {
+        mTs++;
+        return mTs;
+    }
 
-	private long ts() {
-		mTs++;
-		return mTs;
-	}
 
-	/** Notes */
-	// should note new for wizard
+    /** Notes */
+    // should note new for wizard
 
-	private void _importNotes() {
-		// build guid -> (id,mod,mid) hash & map of existing note ids
-		mNotes = new HashMap<String, Object[]>();
-		HashMap<Long, Boolean> existing = new HashMap<Long, Boolean>();
+    private void _importNotes() {
+        // build guid -> (id,mod,mid) hash & map of existing note ids
+        mNotes = new HashMap<String, Object[]>();
+        HashMap<Long, Boolean> existing = new HashMap<Long, Boolean>();
         Cursor cursor = null;
         try {
             // "SELECT id, guid, mod, mid FROM notes"
-            cursor = mDst.getDb().getDatabase().query("notes", new String[]{"id", "guid", "mod", "mid"}, null, null, null, null, null);
+            cursor = mDst.getDb().getDatabase()
+                    .query("notes", new String[] { "id", "guid", "mod", "mid" }, null, null, null, null, null);
             while (cursor.moveToNext()) {
-            	long id = cursor.getLong(0);
-            	mNotes.put(cursor.getString(1), new Object[]{id, cursor.getLong(2), cursor.getLong(3)});
-            	existing.put(id, true);
+                long id = cursor.getLong(0);
+                mNotes.put(cursor.getString(1), new Object[] { id, cursor.getLong(2), cursor.getLong(3) });
+                existing.put(id, true);
             }
         } finally {
             if (cursor != null) {
@@ -238,39 +247,44 @@ private void _importNotes() {
         int dupes = 0;
         try {
             // "SELECT * FROM notes"
-            cursor = mSrc.getDb().getDatabase().query("notes",
-                    new String[]{"id", "guid", "mid", "mod", "usn", "tags", "flds", "sfld", "csum", "flags", "data"},
-                    null, null, null, null, null);
+            cursor = mSrc
+                    .getDb()
+                    .getDatabase()
+                    .query("notes",
+                            new String[] { "id", "guid", "mid", "mod", "usn", "tags", "flds", "sfld", "csum", "flags",
+                                    "data" }, null, null, null, null, null);
             int total = cursor.getCount();
             int i = 0;
             while (cursor.moveToNext()) {
-            	Object[] note = new Object[]{cursor.getLong(0), cursor.getString(1), cursor.getLong(2), cursor.getLong(3), cursor.getInt(4), cursor.getString(5), cursor.getString(6), cursor.getString(7), cursor.getLong(8), cursor.getInt(9), cursor.getString(10)};
-            	boolean shouldAdd = _uniquifyNote(note);
-            	if (shouldAdd) {
-            		// ensure id is unique
-            		while (existing.containsKey(note[0])) {
-            			note[0] = ((Long)note[0]) + 999;
-            		}
-            		existing.put((Long) note[0], true);
-            		// bump usn
-            		note[4] = usn;
-            		// update media references in case of dupes
-            		note[6] = _mungeMedia((Long) note[MID], (String) note[6]);
-            		add.add(note);
-            		dirty.add((Long) note[0]);
-            		// note we have the added guid
-            		mNotes.put((String) note[GUID], new Object[]{note[0], note[3], note[MID]});
-            	} else {
-            		dupes += 1;
-//            		// update existing note - not yet tested; for post 2.0
-//            		boolean newer = note[3] > mod;
-//            		if (mAllowUpdate && _mid(mid) == mid && newer) {
-//            			note[0] = localNid;
-//            			note[4] = usn;
-//            			add.add(note);
-//            			dirty.add(note[0]);
-//            		}
-            	}
+                Object[] note = new Object[] { cursor.getLong(0), cursor.getString(1), cursor.getLong(2),
+                        cursor.getLong(3), cursor.getInt(4), cursor.getString(5), cursor.getString(6),
+                        cursor.getString(7), cursor.getLong(8), cursor.getInt(9), cursor.getString(10) };
+                boolean shouldAdd = _uniquifyNote(note);
+                if (shouldAdd) {
+                    // ensure id is unique
+                    while (existing.containsKey(note[0])) {
+                        note[0] = ((Long) note[0]) + 999;
+                    }
+                    existing.put((Long) note[0], true);
+                    // bump usn
+                    note[4] = usn;
+                    // update media references in case of dupes
+                    note[6] = _mungeMedia((Long) note[MID], (String) note[6]);
+                    add.add(note);
+                    dirty.add((Long) note[0]);
+                    // note we have the added guid
+                    mNotes.put((String) note[GUID], new Object[] { note[0], note[3], note[MID] });
+                } else {
+                    dupes += 1;
+                    // // update existing note - not yet tested; for post 2.0
+                    // boolean newer = note[3] > mod;
+                    // if (mAllowUpdate && _mid(mid) == mid && newer) {
+                    // note[0] = localNid;
+                    // note[4] = usn;
+                    // add.add(note);
+                    // dirty.add(note[0]);
+                    // }
+                }
                 ++i;
                 publishProgress(true, i * 100 / total, 0, false);
             }
@@ -280,119 +294,121 @@ private void _importNotes() {
             }
         }
         if (dupes != 0) {
-        	// TODO: notify about dupes
+            // TODO: notify about dupes
         }
         // add to col
         mDst.getDb().executeMany("INSERT OR REPLACE INTO NOTES VALUES (?,?,?,?,?,?,?,?,?,?,?)", add);
         long[] dis = Utils.arrayList2array(dirty);
         mDst.updateFieldCache(dis);
         mDst.getTags().registerNotes(dis);
-	}
-
-
-	// determine if note is a duplicate, and adjust mid and/or guid as required
-	// returns true if note should be added
-
-	private boolean _uniquifyNote(Object[] note) {
-		String origGuid = (String) note[GUID];
-		long srcMid = (Long) note[MID];
-		long dstMid = _mid(srcMid);
-		// duplicate Schemas?
-		if (srcMid == dstMid) {
-			return !mNotes.containsKey(origGuid);
-		}
-		// differing schemas
-		note[MID] = dstMid;
-		if (!mNotes.containsKey(origGuid)) {
-			return true;
-		}
-		// as the schemas differ and we already have a note with a different note type, this note needs a new guid
-		while (true) {
-			note[GUID] = Utils.incGuid((String)note[GUID]);
-			mChangedGuids.put(origGuid, (String) note[GUID]);
-			// if we don't have an existing guid, we can add
-			if (!mNotes.containsKey((String)note[GUID])) {
-				return true;
-			}
-			// if the existing guid shares the same mid, we can reuse
-			if (dstMid == (Long) mNotes.get((String)note[GUID])[MID]) {
-				return false;
-			}
-		}
-	}
-
-
-	/** Models */
-	// Models in the two decks may share an ID but not a schema, so we need to
+    }
+
+
+    // determine if note is a duplicate, and adjust mid and/or guid as required
+    // returns true if note should be added
+
+    private boolean _uniquifyNote(Object[] note) {
+        String origGuid = (String) note[GUID];
+        long srcMid = (Long) note[MID];
+        long dstMid = _mid(srcMid);
+        // duplicate Schemas?
+        if (srcMid == dstMid) {
+            return !mNotes.containsKey(origGuid);
+        }
+        // differing schemas
+        note[MID] = dstMid;
+        if (!mNotes.containsKey(origGuid)) {
+            return true;
+        }
+        // as the schemas differ and we already have a note with a different note type, this note needs a new guid
+        while (true) {
+            note[GUID] = Utils.incGuid((String) note[GUID]);
+            mChangedGuids.put(origGuid, (String) note[GUID]);
+            // if we don't have an existing guid, we can add
+            if (!mNotes.containsKey((String) note[GUID])) {
+                return true;
+            }
+            // if the existing guid shares the same mid, we can reuse
+            if (dstMid == (Long) mNotes.get((String) note[GUID])[MID]) {
+                return false;
+            }
+        }
+    }
+
+
+    /** Models */
+    // Models in the two decks may share an ID but not a schema, so we need to
     // compare the field & template signature rather than just rely on ID. If
-	// the schemas don't match, we increment the mid and try again, creating a
-	// new model if necessary.
-
-	/* Prepare index of schema hashes */
-	private void _prepareModels() {
-		mModelMap = new HashMap<Long, Long>();
-	}
-
-	/* Return local id for remote MID */
-	private long _mid(long srcMid) {
-		try {
-			// already processed this mid?
-			if (mModelMap.containsKey(srcMid)) {
-				return mModelMap.get(srcMid);
-			}
-			long mid = srcMid;
-			JSONObject srcModel = new JSONObject(Utils.jsonToString(mSrc.getModels().get(srcMid)));
-			String srcScm = mSrc.getModels().scmhash(srcModel);
-			while (true) {
-				// missing from target col?
-				if (!mDst.getModels().have(mid)) {
-					// copy it over
-					JSONObject model = new JSONObject(Utils.jsonToString(srcModel));
-					model.put("id", mid);
+    // the schemas don't match, we increment the mid and try again, creating a
+    // new model if necessary.
+
+    /* Prepare index of schema hashes */
+    private void _prepareModels() {
+        mModelMap = new HashMap<Long, Long>();
+    }
+
+
+    /* Return local id for remote MID */
+    private long _mid(long srcMid) {
+        try {
+            // already processed this mid?
+            if (mModelMap.containsKey(srcMid)) {
+                return mModelMap.get(srcMid);
+            }
+            long mid = srcMid;
+            JSONObject srcModel = new JSONObject(Utils.jsonToString(mSrc.getModels().get(srcMid)));
+            String srcScm = mSrc.getModels().scmhash(srcModel);
+            while (true) {
+                // missing from target col?
+                if (!mDst.getModels().have(mid)) {
+                    // copy it over
+                    JSONObject model = new JSONObject(Utils.jsonToString(srcModel));
+                    model.put("id", mid);
                     model.put("mod", Utils.intNow());
                     model.put("usn", mCol.usn());
-					mDst.getModels().update(model);
-					break;
-				}
-				// there's an existing model; do the schemas match?
-				JSONObject dstModel = new JSONObject(Utils.jsonToString(mDst.getModels().get(mid)));
-				String dstScm = mDst.getModels().scmhash(dstModel);
-				if (srcScm.equals(dstScm)) {
-					// they do; we can reuse this mid
-					break;
-				}
-				// as they don't match, try next id
-				mid += 1;
-			}
-			mModelMap.put(srcMid, mid);
-			return mid;
-		} catch (JSONException e) {
-			throw new RuntimeException(e);
-		}
-	}
-
-	/** Decks */
-
-	/* Given did in src col, return local id */
-	private long _did(long did) {
-		try {
-			// already converted?
-			if (mDecks.containsKey(did)) {
-				return mDecks.get(did);
-			}
-			// get the name in src
-			JSONObject g = mSrc.getDecks().get(did);
-			String name = g.getString("name");
-			// if there's a prefix, replace the top level deck
-			if (mDeckPrefix != null) {
-				String[] tmpname = name.split("::");
-				name = mDeckPrefix;
-				if (tmpname.length > 1) {
-					for (int i = 0; i < tmpname.length - 2; i++) {
-						name += "::" + tmpname[i + 1];
-					}
-				}
-			}
+                    mDst.getModels().update(model);
+                    break;
+                }
+                // there's an existing model; do the schemas match?
+                JSONObject dstModel = new JSONObject(Utils.jsonToString(mDst.getModels().get(mid)));
+                String dstScm = mDst.getModels().scmhash(dstModel);
+                if (srcScm.equals(dstScm)) {
+                    // they do; we can reuse this mid
+                    break;
+                }
+                // as they don't match, try next id
+                mid += 1;
+            }
+            mModelMap.put(srcMid, mid);
+            return mid;
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    /** Decks */
+
+    /* Given did in src col, return local id */
+    private long _did(long did) {
+        try {
+            // already converted?
+            if (mDecks.containsKey(did)) {
+                return mDecks.get(did);
+            }
+            // get the name in src
+            JSONObject g = mSrc.getDecks().get(did);
+            String name = g.getString("name");
+            // if there's a prefix, replace the top level deck
+            if (mDeckPrefix != null) {
+                String[] tmpname = name.split("::");
+                name = mDeckPrefix;
+                if (tmpname.length > 1) {
+                    for (int i = 0; i < tmpname.length - 2; i++) {
+                        name += "::" + tmpname[i + 1];
+                    }
+                }
+            }
             // Manually create any parents so we can pull in descriptions
             String head = "";
             String[] parents = name.split("::");
@@ -405,49 +421,53 @@ private long _did(long did) {
                 _did(idInSrc);
             }
             // create in local
-			long newid = mDst.getDecks().id(name);
-			// pull conf over
-			if (g.has("conf") && g.getLong("conf") != 1) {
-				mDst.getDecks().updateConf(mSrc.getDecks().getConf(g.getLong("conf")));
-				JSONObject g2 = mDst.getDecks().get(newid);
-				g2.put("conf", g.getLong("conf"));
-				mDst.getDecks().save(g2);
-			}
-			// save desc
-			JSONObject deck = mDst.getDecks().get(newid);
-			deck.put("desc", g.getString("desc"));
-			mDst.getDecks().save(deck);
-			// add to deck map and return
-			mDecks.put(did, newid);
-			return newid;
-		} catch (JSONException e) {
-			throw new RuntimeException(e);
-		}
-	}
-
-	/** Cards */
-
-	private int _importCards() {
-		// build map of (guid, ord) -> cid and used id cache
-		mCards = new HashMap<String, HashMap<Integer, Long>>();
-		HashMap<Long, Boolean> existing = new HashMap<Long, Boolean>();
+            long newid = mDst.getDecks().id(name);
+            // pull conf over
+            if (g.has("conf") && g.getLong("conf") != 1) {
+                mDst.getDecks().updateConf(mSrc.getDecks().getConf(g.getLong("conf")));
+                JSONObject g2 = mDst.getDecks().get(newid);
+                g2.put("conf", g.getLong("conf"));
+                mDst.getDecks().save(g2);
+            }
+            // save desc
+            JSONObject deck = mDst.getDecks().get(newid);
+            deck.put("desc", g.getString("desc"));
+            mDst.getDecks().save(deck);
+            // add to deck map and return
+            mDecks.put(did, newid);
+            return newid;
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    /** Cards */
+
+    private int _importCards() {
+        // build map of (guid, ord) -> cid and used id cache
+        mCards = new HashMap<String, HashMap<Integer, Long>>();
+        HashMap<Long, Boolean> existing = new HashMap<Long, Boolean>();
         Cursor cursor = null;
         try {
             // "SELECT f.guid, c.ord, c.id FROM cards c, notes f WHERE c.nid = f.id"
-            cursor = mDst.getDb().getDatabase().query("cards c, notes f", new String[]{"f.guid", "c.ord", "c.id"},
-                    "c.nid = f.id", null, null, null, null);
+            cursor = mDst
+                    .getDb()
+                    .getDatabase()
+                    .query("cards c, notes f", new String[] { "f.guid", "c.ord", "c.id" }, "c.nid = f.id", null, null,
+                            null, null);
             while (cursor.moveToNext()) {
-            	long cid = cursor.getLong(2);
-            	existing.put(cid, true);
-            	String guid = cursor.getString(0);
-            	int ord = cursor.getInt(1);
-            	if (mCards.containsKey(guid)) {
-            		mCards.get(guid).put(ord, cid);
-            	} else {
-            		HashMap<Integer, Long> map = new HashMap<Integer, Long>();
-            		map.put(ord, cid);
-            		mCards.put(guid, map);
-            	}
+                long cid = cursor.getLong(2);
+                existing.put(cid, true);
+                String guid = cursor.getString(0);
+                int ord = cursor.getInt(1);
+                if (mCards.containsKey(guid)) {
+                    mCards.get(guid).put(ord, cid);
+                } else {
+                    HashMap<Integer, Long> map = new HashMap<Integer, Long>();
+                    map.put(ord, cid);
+                    mCards.put(guid, map);
+                }
             }
         } finally {
             if (cursor != null) {
@@ -461,88 +481,87 @@ private int _importCards() {
         int usn = mDst.usn();
         long aheadBy = mSrc.getSched().getToday() - mDst.getSched().getToday();
         try {
-            cursor = mSrc.getDb().getDatabase().rawQuery(
-                    "SELECT f.guid, f.mid, c.* FROM cards c, notes f WHERE c.nid = f.id", null);
+            cursor = mSrc.getDb().getDatabase()
+                    .rawQuery("SELECT f.guid, f.mid, c.* FROM cards c, notes f WHERE c.nid = f.id", null);
             int total = cursor.getCount();
             int ci = 0;
             while (cursor.moveToNext()) {
-            	Object[] card = new Object[]{cursor.getString(0), cursor.getLong(1),
-            			cursor.getLong(2), cursor.getLong(3), cursor.getLong(4),
-            			cursor.getInt(5), cursor.getLong(6), cursor.getInt(7),
-            			cursor.getInt(8), cursor.getInt(9), cursor.getLong(10),
-            			cursor.getLong(11), cursor.getLong(12), cursor.getInt(13),
-            			cursor.getInt(14), cursor.getInt(15), cursor.getLong(16),
-            			cursor.getLong(17), cursor.getInt(18), cursor.getString(19) };
-            	String guid = (String) card[0];
-            	if (mChangedGuids.containsKey(guid)) {
-            		guid = mChangedGuids.get(guid);
-            	}
-            	// does the card's note exist in dst col?
-            	if (!mNotes.containsKey(guid)) {
-            		continue;
-            	}
-            	Object[] dnid = mNotes.get(guid);
-            	// does the card already exist in the dst col?
-            	int ord = (Integer) card[5];
-            	if (mCards.containsKey(guid) && mCards.get(guid).containsKey(ord)) {
-            		// fixme: in future, could update if newer mod time
-            		continue;
-            	}
-            	// doesn't exist. strip off note info, and save src id for later
-            	Object[] oc = card;
-            	card = new Object[oc.length - 2];
-            	for (int i = 0; i < card.length; i++) {
-            		card[i] = oc[i + 2];
-            	}
-            	long scid = (Long) card[0];
-            	// ensure the card id is unique
-            	while (existing.containsKey(card[0])) {
-            		card[0] = (Long) card[0] + 999;
-            	}
-            	existing.put((Long) card[0], true);
-            	// update cid, nid, etc
-            	card[1] = mNotes.get(guid)[0];
-            	card[2] = _did((Long) card[2]);
-            	card[4] = Utils.intNow();
-            	card[5] = usn;
-            	// review cards have a due date relative to collection
-            	if ((Integer)card[7] == 2 || (Integer)card[7] == 3 || (Integer)card[6] == 2) {
-            		card[8] = (Long) card[8] - aheadBy;
-            	}
-            	// if odid true, convert card from filtered to normal
-            	if ((Long)card[15] != 0) {
-            		// odid
-            		card[15] = 0;
-            		// odue
-            		card[8] = card[14];
-            		card[14] = 0;
-            		// queue
-            		if ((Integer)card[6] == 1) { // type
-            			card[7] = 0;
-            		} else {
-            			card[7] = card[6];
-            		}
-            		// type
-            		if ((Integer)card[6] == 1) {
-            			card[6] = 0;
-            		}
-            	}
-            	cards.add(card);
-            	// we need to import revlog, rewriting card ids and bumping usn
-            	Cursor cur2 = null;
+                Object[] card = new Object[] { cursor.getString(0), cursor.getLong(1), cursor.getLong(2),
+                        cursor.getLong(3), cursor.getLong(4), cursor.getInt(5), cursor.getLong(6), cursor.getInt(7),
+                        cursor.getInt(8), cursor.getInt(9), cursor.getLong(10), cursor.getLong(11), cursor.getLong(12),
+                        cursor.getInt(13), cursor.getInt(14), cursor.getInt(15), cursor.getLong(16),
+                        cursor.getLong(17), cursor.getInt(18), cursor.getString(19) };
+                String guid = (String) card[0];
+                if (mChangedGuids.containsKey(guid)) {
+                    guid = mChangedGuids.get(guid);
+                }
+                // does the card's note exist in dst col?
+                if (!mNotes.containsKey(guid)) {
+                    continue;
+                }
+                Object[] dnid = mNotes.get(guid);
+                // does the card already exist in the dst col?
+                int ord = (Integer) card[5];
+                if (mCards.containsKey(guid) && mCards.get(guid).containsKey(ord)) {
+                    // fixme: in future, could update if newer mod time
+                    continue;
+                }
+                // doesn't exist. strip off note info, and save src id for later
+                Object[] oc = card;
+                card = new Object[oc.length - 2];
+                for (int i = 0; i < card.length; i++) {
+                    card[i] = oc[i + 2];
+                }
+                long scid = (Long) card[0];
+                // ensure the card id is unique
+                while (existing.containsKey(card[0])) {
+                    card[0] = (Long) card[0] + 999;
+                }
+                existing.put((Long) card[0], true);
+                // update cid, nid, etc
+                card[1] = mNotes.get(guid)[0];
+                card[2] = _did((Long) card[2]);
+                card[4] = Utils.intNow();
+                card[5] = usn;
+                // review cards have a due date relative to collection
+                if ((Integer) card[7] == 2 || (Integer) card[7] == 3 || (Integer) card[6] == 2) {
+                    card[8] = (Long) card[8] - aheadBy;
+                }
+                // if odid true, convert card from filtered to normal
+                if ((Long) card[15] != 0) {
+                    // odid
+                    card[15] = 0;
+                    // odue
+                    card[8] = card[14];
+                    card[14] = 0;
+                    // queue
+                    if ((Integer) card[6] == 1) { // type
+                        card[7] = 0;
+                    } else {
+                        card[7] = card[6];
+                    }
+                    // type
+                    if ((Integer) card[6] == 1) {
+                        card[6] = 0;
+                    }
+                }
+                cards.add(card);
+                // we need to import revlog, rewriting card ids and bumping usn
+                Cursor cur2 = null;
                 try {
-//                    "SELECT * FROM revlog WHERE cid = ?"
-                    cur2 = mDst.getDb().getDatabase().query("revlog",
-                            new String[] {"id", "cid", "usn", "ease", "ivl", "lastIvl", "factor", "time", "type"},
-                            "cid = ?", new String[]{Long.toString(scid)}, null, null, null);
+                    // "SELECT * FROM revlog WHERE cid = ?"
+                    cur2 = mDst
+                            .getDb()
+                            .getDatabase()
+                            .query("revlog",
+                                    new String[] { "id", "cid", "usn", "ease", "ivl", "lastIvl", "factor", "time",
+                                            "type" }, "cid = ?", new String[] { Long.toString(scid) }, null, null, null);
                     while (cur2.moveToNext()) {
-                    	 Object[] rev = new Object[]{cur2.getLong(0), cur2.getLong(1),
-                    			cur2.getInt(2), cur2.getInt(3), cur2.getLong(4),
-                    			cur2.getLong(5), cur2.getLong(6), cur2.getLong(7),
-                    			cur2.getInt(8)};
-                    	 rev[1] = card[0];
-                    	 rev[2] = mDst.usn();
-                    	 revlog.add(rev);
+                        Object[] rev = new Object[] { cur2.getLong(0), cur2.getLong(1), cur2.getInt(2), cur2.getInt(3),
+                                cur2.getLong(4), cur2.getLong(5), cur2.getLong(6), cur2.getLong(7), cur2.getInt(8) };
+                        rev[1] = card[0];
+                        rev[2] = mDst.usn();
+                        revlog.add(rev);
                     }
                 } finally {
                     if (cur2 != null) {
@@ -562,10 +581,11 @@ private int _importCards() {
         mDst.getDb().executeMany("INSERT OR IGNORE INTO cards VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)", cards);
         mDst.getDb().executeMany("INSERT OR IGNORE INTO revlog VALUES (?,?,?,?,?,?,?,?,?)", revlog);
         return cnt;
-	}
+    }
+
 
-	private String _mungeMedia(long mid, String fields) {
-		String[] fs = Utils.splitFields(fields);
+    private String _mungeMedia(long mid, String fields) {
+        String[] fs = Utils.splitFields(fields);
 
         for (int i = 0; i < fs.length; ++i) {
             for (Pattern p : Media.fMediaRegexps) {
@@ -585,11 +605,13 @@ private String _mungeMedia(long mid, String fields) {
                     if (extPos <= 0) {
                         extPos = fname.length();
                     }
-                    String lname = String.format(Locale.US, "%s_%d%s", fname.substring(0, extPos), mid, fname.substring(extPos));
+                    String lname = String.format(Locale.US, "%s_%d%s", fname.substring(0, extPos), mid,
+                            fname.substring(extPos));
                     if (mDst.getMedia().have(lname)) {
                         m.appendReplacement(sb, m.group(0).replace(fname, lname));
                         continue;
-                    } else if (dstData == null || compareMedia(srcData, dstData)) { // if missing or the same, pass unmodified
+                    } else if (dstData == null || compareMedia(srcData, dstData)) { // if missing or the same, pass
+                                                                                    // unmodified
                         // need to copy?
                         if (dstData == null) {
                             _writeDstMedia(fname, srcData);
@@ -605,8 +627,9 @@ private String _mungeMedia(long mid, String fields) {
                 fs[i] = sb.toString();
             }
         }
-		return fields;
-	}
+        return fields;
+    }
+
 
     private boolean compareMedia(BufferedInputStream lhis, BufferedInputStream rhis) {
         byte[] lhbytes = _mediaPick(lhis);
@@ -615,9 +638,10 @@ private boolean compareMedia(BufferedInputStream lhis, BufferedInputStream rhis)
         return result;
     }
 
+
     /**
-     * Return the contents of the given input stream, limited to Anki2Importer.MEDIAPICKLIMIT bytes
-     * This is only used for comparison of media files with the limited resources of mobile devices
+     * Return the contents of the given input stream, limited to Anki2Importer.MEDIAPICKLIMIT bytes This is only used
+     * for comparison of media files with the limited resources of mobile devices
      */
     byte[] _mediaPick(BufferedInputStream is) {
         try {
@@ -626,7 +650,7 @@ byte[] _mediaPick(BufferedInputStream is) {
             int readLen;
             int readSoFar = 0;
             is.mark(MEDIAPICKLIMIT * 2);
-            while(true) {
+            while (true) {
                 readLen = is.read(buf);
                 baos.write(buf);
                 if (readLen == -1) {
@@ -648,6 +672,7 @@ byte[] _mediaPick(BufferedInputStream is) {
         }
     }
 
+
     private BufferedInputStream _mediaData(String fname, String dir) {
         try {
             return new BufferedInputStream(new FileInputStream(new File(dir, fname)), MEDIAPICKLIMIT * 2);
@@ -656,8 +681,10 @@ private BufferedInputStream _mediaData(String fname, String dir) {
         }
     }
 
+
     /**
      * Data for FNAME in src collection.
+     * 
      * @return A string containing the contents of fname, limited to Anki2Importer.MEDIAPICKLIMIT bytes
      */
     private BufferedInputStream _srcMediaData(String fname) {
@@ -671,14 +698,17 @@ private BufferedInputStream _srcMediaData(String fname) {
         return null;
     }
 
+
     /**
      * Data for FNAME in src collection.
+     * 
      * @return A string containing the contents of fname, limited to Anki2Importer.MEDIAPICKLIMIT bytes
      */
     private BufferedInputStream _dstMediaData(String fname) {
         return _mediaData(fname, mDst.getMedia().getDir());
     }
 
+
     private void _writeDstMedia(String fname, BufferedInputStream is) {
         try {
             Utils.writeToFile(is, mDstMediaDir + fname);
@@ -690,15 +720,17 @@ private void _writeDstMedia(String fname, BufferedInputStream is) {
         }
     }
 
-	/** post-import cleanup */
-
-	private void _postImport() {
-		try {
-			// make sure new position is correct
-			mDst.getConf().put("nextPos", mDst.getDb().queryLongScalar("SELECT max(due) + 1 FROM cards WHERE type = 0", false));
-			mDst.save();
-		} catch (JSONException e) {
-			throw new RuntimeException(e);
-		}
-	}
+
+    /** post-import cleanup */
+
+    private void _postImport() {
+        try {
+            // make sure new position is correct
+            mDst.getConf().put("nextPos",
+                    mDst.getDb().queryLongScalar("SELECT max(due) + 1 FROM cards WHERE type = 0", false));
+            mDst.save();
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/src/com/ichi2/libanki/sync/BasicHttpSyncer.java b/src/com/ichi2/libanki/sync/BasicHttpSyncer.java
index b0aa76f47766..ed297aca150d 100644
--- a/src/com/ichi2/libanki/sync/BasicHttpSyncer.java
+++ b/src/com/ichi2/libanki/sync/BasicHttpSyncer.java
@@ -117,12 +117,14 @@ public HttpResponse req(String method, InputStream fobj, int comp, boolean hkey)
         return req(method, fobj, comp, hkey, null);
     }
 
+
     public HttpResponse req(String method, InputStream fobj, int comp, boolean hkey, JSONObject registerData) {
         return req(method, fobj, comp, hkey, registerData, null);
     }
 
+
     public HttpResponse req(String method, InputStream fobj, int comp, boolean hkey, JSONObject registerData,
-                            Connection.CancelCallback cancelCallback) {
+            Connection.CancelCallback cancelCallback) {
         File tmpFileBuffer = null;
         try {
             String bdry = "--" + BOUNDARY;
@@ -136,8 +138,8 @@ public HttpResponse req(String method, InputStream fobj, int comp, boolean hkey,
             }
             for (String key : vars.keySet()) {
                 buf.write(bdry + "\r\n");
-                buf.write(String.format(Locale.US, "Content-Disposition: form-data; name=\"%s\"\r\n\r\n%s\r\n",
-                        key, vars.get(key)));
+                buf.write(String.format(Locale.US, "Content-Disposition: form-data; name=\"%s\"\r\n\r\n%s\r\n", key,
+                        vars.get(key)));
             }
             tmpFileBuffer = File.createTempFile("syncer", ".tmp", new File(AnkiDroidApp.getCacheStorageDirectory()));
             FileOutputStream fos = new FileOutputStream(tmpFileBuffer);
@@ -259,12 +261,15 @@ public boolean writeToFile(InputStream source, String destination) {
 
 
     public String stream2String(InputStream stream) {
-    	return stream2String(stream, -1);
+        return stream2String(stream, -1);
     }
+
+
     public String stream2String(InputStream stream, int maxSize) {
         BufferedReader rd;
         try {
-            rd = new BufferedReader(new InputStreamReader(stream, "UTF-8"), maxSize == -1 ? 4096 : Math.min(4096, maxSize));
+            rd = new BufferedReader(new InputStreamReader(stream, "UTF-8"), maxSize == -1 ? 4096 : Math.min(4096,
+                    maxSize));
             String line;
             StringBuilder sb = new StringBuilder();
             while ((line = rd.readLine()) != null && (maxSize == -1 || sb.length() < maxSize)) {
@@ -342,6 +347,7 @@ public JSONObject sanityCheck2(JSONObject client) {
         return null;
     }
 
+
     public void applyChunk(JSONObject sech) {
     }
 
diff --git a/src/com/ichi2/libanki/sync/MediaSyncer.java b/src/com/ichi2/libanki/sync/MediaSyncer.java
index 42a136924f49..02059e197578 100644
--- a/src/com/ichi2/libanki/sync/MediaSyncer.java
+++ b/src/com/ichi2/libanki/sync/MediaSyncer.java
@@ -103,15 +103,16 @@ public String sync(long mediaUsn, Connection con) {
         long sMediaSanity = mServer.mediaSanity();
         Pair<Long, Long> cMediaSanity = mediaSanity();
         if (cMediaSanity.first != 0 || sMediaSanity != cMediaSanity.second) {
-            Log.e(AnkiDroidApp.TAG,
-                    "Media sanity check failed. Diffs [local, server] - Logs: [" + cMediaSanity.first +
-                            ", 0], Counts: [" + cMediaSanity.second + ", " + sMediaSanity + "]");
+            Log.e(AnkiDroidApp.TAG, "Media sanity check failed. Diffs [local, server] - Logs: [" + cMediaSanity.first
+                    + ", 0], Counts: [" + cMediaSanity.second + ", " + sMediaSanity + "]");
             if (cMediaSanity.first != 0) {
-                AnkiDroidApp.saveExceptionReportFile(new RuntimeException(
-                        "Media sanity check failed. Logs not empty."), "doInBackgroundSync-mediaSync");
+                AnkiDroidApp.saveExceptionReportFile(
+                        new RuntimeException("Media sanity check failed. Logs not empty."),
+                        "doInBackgroundSync-mediaSync");
             } else {
-                AnkiDroidApp.saveExceptionReportFile(new RuntimeException(
-                        "Media sanity check failed. Counts are off."), "doInBackgroundSync-mediaSync");
+                AnkiDroidApp.saveExceptionReportFile(
+                        new RuntimeException("Media sanity check failed. Counts are off."),
+                        "doInBackgroundSync-mediaSync");
             }
             mCol.getMedia().resetMediaDb();
             return "sanityFailed";
@@ -137,7 +138,7 @@ private Pair<File, List<String>> files() {
 
     /**
      * Adds any media sent from the server.
-     *
+     * 
      * @param zip A temporary zip file that contains the media files.
      * @return True if zip is the last in set. Server returns new usn instead.
      */
diff --git a/src/com/ichi2/libanki/sync/RemoteServer.java b/src/com/ichi2/libanki/sync/RemoteServer.java
index c464d40273f2..7943df813810 100644
--- a/src/com/ichi2/libanki/sync/RemoteServer.java
+++ b/src/com/ichi2/libanki/sync/RemoteServer.java
@@ -71,7 +71,8 @@ public HttpResponse meta() {
         try {
             JSONObject jo = new JSONObject();
             jo.put("v", Consts.SYNC_VER);
-            jo.put("cv", String.format(Locale.US, "ankidroid,%s,%s", AnkiDroidApp.getPkgVersionName(), Utils.platDesc()));
+            jo.put("cv",
+                    String.format(Locale.US, "ankidroid,%s,%s", AnkiDroidApp.getPkgVersionName(), Utils.platDesc()));
             return super.req("meta", super.getInputStream(Utils.jsonToString(jo)));
         } catch (JSONException e) {
             throw new RuntimeException(e);
diff --git a/src/com/ichi2/libanki/sync/Syncer.java b/src/com/ichi2/libanki/sync/Syncer.java
index d2e6e39bd95e..9783a5ca75f8 100644
--- a/src/com/ichi2/libanki/sync/Syncer.java
+++ b/src/com/ichi2/libanki/sync/Syncer.java
@@ -234,11 +234,11 @@ public Object[] sync(Connection con) {
         } catch (IllegalStateException e) {
             throw new RuntimeException(e);
         } catch (OutOfMemoryError e) {
-			AnkiDroidApp.saveExceptionReportFile(e, "Syncer-sync");
-        	return new Object[] { "OutOfMemoryError" };
+            AnkiDroidApp.saveExceptionReportFile(e, "Syncer-sync");
+            return new Object[] { "OutOfMemoryError" };
         } catch (IOException e) {
-			AnkiDroidApp.saveExceptionReportFile(e, "Syncer-sync");
-        	return new Object[] { "IOException" };
+            AnkiDroidApp.saveExceptionReportFile(e, "Syncer-sync");
+            return new Object[] { "IOException" };
         }
         return new Object[] { "success" };
     }
@@ -319,8 +319,8 @@ public JSONObject sanityCheck() {
                 result.put("client", "missing notes");
                 return result;
             }
-            if (mCol.getDb().queryScalar(
-                    "SELECT count() FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)", false) != 0) {
+            if (mCol.getDb().queryScalar("SELECT count() FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)",
+                    false) != 0) {
                 Log.e(AnkiDroidApp.TAG, "Sync - SanityCheck: there are notes without cards");
                 result.put("client", "missing cards");
                 return result;
@@ -397,24 +397,25 @@ public JSONObject sanityCheck() {
             ja.put(mCol.getDecks().allConf().size());
             result.put("client", ja);
             return result;
-        } catch(JSONException e) {
+        } catch (JSONException e) {
             Log.e(AnkiDroidApp.TAG, "Syncer.sanityCheck(): ", e);
             throw new RuntimeException(e);
         }
     }
 
-//    private Map<String, Object> sanityCheck2(JSONArray client) {
-//        Object server = sanityCheck();
-//        Map<String, Object> result = new HashMap<String, Object>();
-//        if (client.equals(server)) {
-//            result.put("status", "ok");
-//        } else {
-//            result.put("status", "bad");
-//            result.put("c", client);
-//            result.put("s", server);
-//        }
-//        return result;
-//    }
+
+    // private Map<String, Object> sanityCheck2(JSONArray client) {
+    // Object server = sanityCheck();
+    // Map<String, Object> result = new HashMap<String, Object>();
+    // if (client.equals(server)) {
+    // result.put("status", "ok");
+    // } else {
+    // result.put("status", "bad");
+    // result.put("c", client);
+    // result.put("s", server);
+    // }
+    // return result;
+    // }
 
     private String usnLim() {
         if (mCol.getServer()) {
@@ -472,7 +473,8 @@ private Cursor cursorForTable(String table) {
                     .getDb()
                     .getDatabase()
                     .rawQuery(
-                            String.format(Locale.US,
+                            String.format(
+                                    Locale.US,
                                     "SELECT id, nid, did, ord, mod, %d, type, queue, due, ivl, factor, reps, lapses, left, odue, odid, flags, data FROM cards WHERE %s",
                                     mMaxUsn, lim), null);
         } else {
@@ -480,7 +482,8 @@ private Cursor cursorForTable(String table) {
                     .getDb()
                     .getDatabase()
                     .rawQuery(
-                            String.format(Locale.US,
+                            String.format(
+                                    Locale.US,
                                     "SELECT id, guid, mid, mod, %d, tags, flds, '', '', flags, data FROM notes WHERE %s",
                                     mMaxUsn, lim), null);
         }
@@ -889,6 +892,7 @@ public String getSyncMsg() {
         return mSyncMsg;
     }
 
+
     /**
      * Col config ********************************************************************
      */
diff --git a/src/com/ichi2/preferences/CustomDialogPreference.java b/src/com/ichi2/preferences/CustomDialogPreference.java
index 56ccf6ad581a..c61cf1ea133b 100644
--- a/src/com/ichi2/preferences/CustomDialogPreference.java
+++ b/src/com/ichi2/preferences/CustomDialogPreference.java
@@ -43,7 +43,7 @@ public void onClick(DialogInterface dialog, int which) {
                 // Deck Options :: Restore Defaults for Options Group
                 Editor editor = AnkiDroidApp.getSharedPrefs(mContext).edit();
                 editor.putBoolean("confReset", true);
-                editor.commit();            
+                editor.commit();
             } else if (this.getTitle().equals(mContext.getResources().getString(R.string.deck_conf_remove))) {
                 // Deck Options :: Remove Options Group
                 Editor editor = AnkiDroidApp.getSharedPrefs(mContext).edit();
diff --git a/src/com/ichi2/preferences/NumberRangePreference.java b/src/com/ichi2/preferences/NumberRangePreference.java
index 871961c7439f..80967643d841 100644
--- a/src/com/ichi2/preferences/NumberRangePreference.java
+++ b/src/com/ichi2/preferences/NumberRangePreference.java
@@ -65,10 +65,10 @@ protected void onDialogClosed(boolean positiveResult) {
 
 
     /*
-     * Since this preference deals with integers only, it makes sense to only store and retrieve
-     * integers. However, since it is extending EditTextPreference, the persistence and retrieval
-     * methods that are called are for a String type. The two methods below intercept the persistence
-     * and retrieval methods for Strings and replaces them with their Integer equivalents.
+     * Since this preference deals with integers only, it makes sense to only store and retrieve integers. However,
+     * since it is extending EditTextPreference, the persistence and retrieval methods that are called are for a String
+     * type. The two methods below intercept the persistence and retrieval methods for Strings and replaces them with
+     * their Integer equivalents.
      */
 
     @Override
@@ -84,8 +84,9 @@ protected boolean persistString(String value) {
 
 
     /**
-     * Return the string as an int with the number rounded to the nearest bound if it is outside
-     * of the acceptable range.
+     * Return the string as an int with the number rounded to the nearest bound if it is outside of the acceptable
+     * range.
+     * 
      * @param input User input in text editor.
      * @return The input value within acceptable range.
      */
@@ -103,8 +104,8 @@ private int getValidatedRangeFromString(String input) {
 
 
     /**
-     * Return the integer rounded to the nearest bound if it is outside of the acceptable
-     * range.
+     * Return the integer rounded to the nearest bound if it is outside of the acceptable range.
+     * 
      * @param input Integer to validate.
      * @return The input value within acceptable range.
      */
@@ -117,6 +118,7 @@ private int getValidatedRangeFromInt(int input) {
         return input;
     }
 
+
     /**
      * Returns the value of the min attribute, or its default value if not specified
      * <p>
@@ -133,14 +135,14 @@ private int getMinFromAttributes(AttributeSet attrs) {
      * This method should only be called once from the constructor.
      */
     private int getMaxFromAttributes(AttributeSet attrs) {
-        return attrs == null ? Integer.MAX_VALUE
-                : attrs.getAttributeIntValue(AnkiDroidApp.APP_NAMESPACE, "max", Integer.MAX_VALUE);
+        return attrs == null ? Integer.MAX_VALUE : attrs.getAttributeIntValue(AnkiDroidApp.APP_NAMESPACE, "max",
+                Integer.MAX_VALUE);
     }
 
 
     /**
-     * Update settings to only allow integer input and set the maximum number of digits allowed in the text
-     * field based on the current value of the {@link #mMax} field.
+     * Update settings to only allow integer input and set the maximum number of digits allowed in the text field based
+     * on the current value of the {@link #mMax} field.
      * <p>
      * This method should only be called once from the constructor.
      */
@@ -158,8 +160,10 @@ private void updateSettings() {
         getEditText().setFilters(newFilters);
     }
 
+
     /**
      * Get the persisted value held by this preference.
+     * 
      * @return the persisted value.
      */
     public int getValue() {
@@ -169,6 +173,7 @@ public int getValue() {
 
     /**
      * Set this preference's value. The value is validated and persisted as an Integer.
+     * 
      * @param value to set.
      */
     public void setValue(int value) {
diff --git a/src/com/ichi2/preferences/StepsPreference.java b/src/com/ichi2/preferences/StepsPreference.java
index 032d5eaaf011..4c6a64b234b4 100644
--- a/src/com/ichi2/preferences/StepsPreference.java
+++ b/src/com/ichi2/preferences/StepsPreference.java
@@ -1,4 +1,3 @@
-
 /****************************************************************************************
  * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *
  *                                                                                      *
@@ -55,6 +54,7 @@ public StepsPreference(Context context) {
         updateSettings();
     }
 
+
     /**
      * Update settings to show a numeric keyboard instead of the default keyboard.
      * <p>
@@ -65,16 +65,16 @@ private void updateSettings() {
         getEditText().setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_CLASS_TEXT);
     }
 
+
     @Override
     protected void onDialogClosed(boolean positiveResult) {
         if (positiveResult) {
             String validated = getValidatedStepsInput(getEditText().getText().toString());
             if (validated == null) {
-                Themes.showThemedToast(getContext(),
-                        getContext().getResources().getString(R.string.steps_error), false);
+                Themes.showThemedToast(getContext(), getContext().getResources().getString(R.string.steps_error), false);
             } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {
-                Themes.showThemedToast(getContext(),
-                        getContext().getResources().getString(R.string.steps_min_error), false);
+                Themes.showThemedToast(getContext(), getContext().getResources().getString(R.string.steps_min_error),
+                        false);
             } else {
                 setText(validated);
             }
@@ -83,8 +83,9 @@ protected void onDialogClosed(boolean positiveResult) {
 
 
     /**
-     * Check if the string is a valid format for steps and return that string, reformatted for better
-     * usability if needed.
+     * Check if the string is a valid format for steps and return that string, reformatted for better usability if
+     * needed.
+     * 
      * @param steps User input in text editor.
      * @return The correctly formatted string or null if the input is not valid.
      */
@@ -108,7 +109,7 @@ private String getValidatedStepsInput(String steps) {
 
     /**
      * Convert steps format.
-     *
+     * 
      * @param a JSONArray representation of steps.
      * @return The steps as a space-separated string.
      */
@@ -126,9 +127,9 @@ public static String convertFromJSON(JSONArray a) {
 
 
     /**
-     * Convert steps format. For better usability, rounded floats are converted to integers (e.g.,
-     * 1.0 is converted to 1).
-     *
+     * Convert steps format. For better usability, rounded floats are converted to integers (e.g., 1.0 is converted to
+     * 1).
+     * 
      * @param steps String representation of steps.
      * @return The steps as a JSONArray or null if the steps are not valid.
      */
diff --git a/src/com/ichi2/themes/StyledDialog.java b/src/com/ichi2/themes/StyledDialog.java
index c705558cd9e0..a192c1ccacb9 100644
--- a/src/com/ichi2/themes/StyledDialog.java
+++ b/src/com/ichi2/themes/StyledDialog.java
@@ -58,6 +58,7 @@ public class StyledDialog extends Dialog {
     private ListView mListView;
     private boolean mDoNotShow = false;
 
+
     public StyledDialog(Context context) {
         super(context, R.style.StyledDialog);
         mContext = context;
@@ -173,8 +174,9 @@ public Button getButton(int which) {
         }
     }
 
+
     public void setButtonOnClickListener(int which, OnClickListener listener) {
-    	getButton(which).setOnClickListener(new OnClickForwarder(StyledDialog.this, which, listener));
+        getButton(which).setOnClickListener(new OnClickForwarder(StyledDialog.this, which, listener));
     }
 
 
@@ -229,13 +231,15 @@ public void changeListItem(int position, String text) {
         mItemList.add(position, text);
         mListAdapter.notifyDataSetChanged();
     }
-    
+
+
     public void setItemListChecked(boolean checked) {
         for (int i = 0; i < mListView.getCount(); i++) {
             mListView.setItemChecked(i, checked);
         }
     }
 
+
     public ArrayList<String> getCheckedItems() {
         updateCheckedItems();
         ArrayList<String> selecteds = new ArrayList<String>();
@@ -243,10 +247,11 @@ public ArrayList<String> getCheckedItems() {
             if (mCheckedItems[i])
                 selecteds.add(mItemList.get(i));
         }
-        
+
         return selecteds;
     }
 
+
     public void updateCheckedItems() {
         if (mCheckedItems == null) {
             mCheckedItems = new boolean[mItemList.size()];
@@ -269,9 +274,12 @@ public void updateCheckedItems() {
         }
     }
 
+
     public void filterList(String str) {
         filterList(str, null);
     }
+
+
     public void filterList(String str, final FilterListener listener) {
         updateCheckedItems();
         mListAdapter.getFilter().filter(str, new FilterListener() {
@@ -286,6 +294,7 @@ public void onFilterComplete(int count) {
         });
     }
 
+
     private void adjustSelectAllCheckBox() {
         boolean check = true;
         for (int i = 0; i < mListView.getCount(); i++) {
@@ -337,7 +346,7 @@ public Builder(Context context) {
 
         /**
          * Set the Dialog message from String
-         *
+         * 
          * @param title
          * @return
          */
@@ -356,7 +365,7 @@ public Builder setMessage(String message, int size) {
 
         /**
          * Set the Dialog message from resource
-         *
+         * 
          * @param title
          * @return
          */
@@ -374,7 +383,7 @@ public Builder setIcon(int icon) {
 
         /**
          * Set the Dialog title from resource
-         *
+         * 
          * @param title
          * @return
          */
@@ -386,7 +395,7 @@ public Builder setTitle(int title) {
 
         /**
          * Set the Dialog title from String
-         *
+         * 
          * @param title
          * @return
          */
@@ -398,7 +407,7 @@ public Builder setTitle(String title) {
 
         /**
          * Set a custom content view for the Dialog. If a message is set, the contentView is not added to the Dialog...
-         *
+         * 
          * @param v
          * @return
          */
@@ -428,7 +437,7 @@ public Builder setView(View v, boolean isSingleView, boolean bright) {
 
         /**
          * Set the positive button resource and it's listener
-         *
+         * 
          * @param positiveButtonText
          * @param listener
          * @return
@@ -442,7 +451,7 @@ public Builder setPositiveButton(int positiveButtonText, DialogInterface.OnClick
 
         /**
          * Set the positive button text and it's listener
-         *
+         * 
          * @param positiveButtonText
          * @param listener
          * @return
@@ -456,7 +465,7 @@ public Builder setPositiveButton(String positiveButtonText, DialogInterface.OnCl
 
         /**
          * Set the negative button resource and it's listener
-         *
+         * 
          * @param negativeButtonText
          * @param listener
          * @return
@@ -470,7 +479,7 @@ public Builder setNegativeButton(int negativeButtonText, DialogInterface.OnClick
 
         /**
          * Set the negative button text and it's listener
-         *
+         * 
          * @param negativeButtonText
          * @param listener
          * @return
@@ -484,7 +493,7 @@ public Builder setNegativeButton(String negativeButtonText, DialogInterface.OnCl
 
         /**
          * Set the neutral button resource and it's listener
-         *
+         * 
          * @param neutralButtonText
          * @param listener
          * @return
@@ -498,7 +507,7 @@ public Builder setNeutralButton(int neutralButtonText, DialogInterface.OnClickLi
 
         /**
          * Set the neutral button text and it's listener
-         *
+         * 
          * @param neutralButtonText
          * @param listener
          * @return
@@ -520,7 +529,8 @@ public Builder setOnDismissListener(DialogInterface.OnDismissListener listener)
             this.dismissListener = listener;
             return this;
         }
-        
+
+
         public Builder setSelectAllListener(OnCheckedChangeListener listener) {
             this.selectAllListener = listener;
             return this;
@@ -550,8 +560,8 @@ public Builder setSingleChoiceItems(String[] values, int checked, DialogInterfac
         }
 
 
-        public Builder setMultiChoiceItems(String[] values, boolean[] checked, DialogInterface.OnClickListener listener,
-                OnCheckedChangeListener selectAllListener) {
+        public Builder setMultiChoiceItems(String[] values, boolean[] checked,
+                DialogInterface.OnClickListener listener, OnCheckedChangeListener selectAllListener) {
             this.itemTitels = values;
             this.multipleCheckedItems = checked;
             this.itemClickListener = listener;
@@ -560,11 +570,13 @@ public Builder setMultiChoiceItems(String[] values, boolean[] checked, DialogInt
             return this;
         }
 
+
         public Builder setShowFilterTags(boolean show) {
             mShowFilterEditText = show;
             return this;
         }
-        
+
+
         /**
          * Create the styled dialog
          */
@@ -687,9 +699,13 @@ public void onFilterComplete(int count) {
                             }
                         });
                     }
+
+
                     @Override
                     public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                     }
+
+
                     @Override
                     public void afterTextChanged(Editable s) {
                     }
diff --git a/src/com/ichi2/themes/StyledOpenCollectionDialog.java b/src/com/ichi2/themes/StyledOpenCollectionDialog.java
index f2e71188e8b4..e35e55e4049d 100644
--- a/src/com/ichi2/themes/StyledOpenCollectionDialog.java
+++ b/src/com/ichi2/themes/StyledOpenCollectionDialog.java
@@ -35,7 +35,8 @@
 
 public class StyledOpenCollectionDialog extends Dialog {
 
-	private View mMainLayout;
+    private View mMainLayout;
+
 
     public StyledOpenCollectionDialog(Context context) {
         super(context, R.style.StyledDialog);
@@ -63,10 +64,14 @@ public void dismiss() {
     }
 
 
-    public static StyledOpenCollectionDialog show(Context context, CharSequence message, DialogInterface.OnCancelListener cancelListener) {
-    	return show(context, message, cancelListener, null);
+    public static StyledOpenCollectionDialog show(Context context, CharSequence message,
+            DialogInterface.OnCancelListener cancelListener) {
+        return show(context, message, cancelListener, null);
     }
-    public static StyledOpenCollectionDialog show(Context context, CharSequence message, DialogInterface.OnCancelListener cancelListener, View.OnClickListener textClickListener) {
+
+
+    public static StyledOpenCollectionDialog show(Context context, CharSequence message,
+            DialogInterface.OnCancelListener cancelListener, View.OnClickListener textClickListener) {
         final StyledOpenCollectionDialog dialog = new StyledOpenCollectionDialog(context);
         LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
 
@@ -77,7 +82,7 @@ public static StyledOpenCollectionDialog show(Context context, CharSequence mess
             TextView tv = (TextView) dialog.mMainLayout.findViewById(R.id.deckpicker_loading_layer_statusline);
             tv.setText(message);
             if (textClickListener != null) {
-            	tv.setOnClickListener(textClickListener);
+                tv.setOnClickListener(textClickListener);
             }
         }
 
@@ -97,6 +102,7 @@ public static StyledOpenCollectionDialog show(Context context, CharSequence mess
 
     }
 
+
     private static boolean animationEnabled(Context context) {
         if (context instanceof AnkiActivity) {
             return ((AnkiActivity) context).animationEnabled();
@@ -105,6 +111,7 @@ private static boolean animationEnabled(Context context) {
         }
     }
 
+
     public void setMessage(CharSequence message) {
         View main = super.getWindow().getDecorView();
         ((TextView) main.findViewById(R.id.deckpicker_loading_layer_statusline)).setText(message);
diff --git a/src/com/ichi2/upgrade/Upgrade.java b/src/com/ichi2/upgrade/Upgrade.java
index 53b68af39a4e..2251a8636409 100644
--- a/src/com/ichi2/upgrade/Upgrade.java
+++ b/src/com/ichi2/upgrade/Upgrade.java
@@ -9,18 +9,18 @@
 public class Upgrade {
 
     public static boolean upgradeJSONIfNecessary(Collection col, JSONObject conf, String name, boolean defaultValue) {
-	    boolean val = defaultValue;
-	    try {
-	    	val = conf.getBoolean(name);
-	    } catch (JSONException e) {
-		    // workaround to repair wrong values from older libanki versions
-		    try {
-				conf.put(name, val);
-			} catch (JSONException e1) {
-				// do nothing
-			}
-		    col.save();
-	    }
-	    return val;
+        boolean val = defaultValue;
+        try {
+            val = conf.getBoolean(name);
+        } catch (JSONException e) {
+            // workaround to repair wrong values from older libanki versions
+            try {
+                conf.put(name, val);
+            } catch (JSONException e1) {
+                // do nothing
+            }
+            col.save();
+        }
+        return val;
     }
 }
diff --git a/src/com/ichi2/utils/Base64.java b/src/com/ichi2/utils/Base64.java
index 64e0e0462713..ff79495aa89a 100644
--- a/src/com/ichi2/utils/Base64.java
+++ b/src/com/ichi2/utils/Base64.java
@@ -319,7 +319,7 @@ private Base64() {
      * notation. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. The array
      * <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>. Code can reuse a byte array by passing a
      * four-byte array as <var>b4</var>.
-     *
+     * 
      * @param b4 A reusable byte array to reduce array instantiation
      * @param threeBytes the array to convert
      * @param numSigBytes the number of significant bytes in your array
@@ -344,7 +344,7 @@ private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes,
      * <p>
      * This is the lowest level of the encoding methods with all possible parameters.
      * </p>
-     *
+     * 
      * @param source the array to convert
      * @param srcOffset the index where conversion begins
      * @param numSigBytes the number of significant bytes in your array
@@ -406,7 +406,7 @@ private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes,
      * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> ByteBuffer.
      * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
      * {@link #GZIP}.
-     *
+     * 
      * @param raw input buffer
      * @param encoded output buffer
      * @since 2.3
@@ -428,7 +428,7 @@ public static void encode(java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded)
      * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> CharBuffer.
      * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
      * {@link #GZIP}.
-     *
+     * 
      * @param raw input buffer
      * @param encoded output buffer
      * @since 2.3
@@ -456,7 +456,7 @@ public static void encode(java.nio.ByteBuffer raw, java.nio.CharBuffer encoded)
      * retrospect that's a pretty poor way to handle it.
      * </p>
      * The object is not GZip-compressed before being encoded.
-     *
+     * 
      * @param serializableObject The object to encode
      * @return The Base64-encoded object
      * @throws java.io.IOException if there is an error
@@ -478,7 +478,7 @@ public static String encodeObject(java.io.Serializable serializableObject) throw
      * The object is not GZip-compressed before being encoded.
      * <p>
      * Example options:
-     *
+     * 
      * <pre>
      *   GZIP: gzip-compresses object before encoding it.
      *   DO_BREAK_LINES: break lines at 76 characters
@@ -487,7 +487,7 @@ public static String encodeObject(java.io.Serializable serializableObject) throw
      * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
      * <p>
      * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
-     *
+     * 
      * @param serializableObject The object to encode
      * @param options Specified options
      * @return The Base64-encoded object
@@ -560,7 +560,7 @@ public static String encodeObject(java.io.Serializable serializableObject, int o
 
     /**
      * Encodes a byte array into Base64 notation. Does not GZip-compress data.
-     *
+     * 
      * @param source The data to convert
      * @return The data in Base64-encoded form
      * @throws NullPointerException if source array is null
@@ -585,7 +585,7 @@ public static String encodeBytes(byte[] source) {
      * Encodes a byte array into Base64 notation.
      * <p>
      * Example options:
-     *
+     * 
      * <pre>
      *   GZIP: gzip-compresses object before encoding it.
      *   DO_BREAK_LINES: break lines at 76 characters
@@ -600,7 +600,7 @@ public static String encodeBytes(byte[] source) {
      * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
      * to handle it.
      * </p>
-     *
+     * 
      * @param source The data to convert
      * @param options Specified options
      * @return The Base64-encoded data as a String
@@ -621,7 +621,7 @@ public static String encodeBytes(byte[] source, int options) throws java.io.IOEx
      * As of v 2.3, if there is an error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
      * earlier versions, it just returned a null value, but in retrospect that's a pretty poor way to handle it.
      * </p>
-     *
+     * 
      * @param source The data to convert
      * @param off Offset in array where conversion should begin
      * @param len Length of data to convert
@@ -649,7 +649,7 @@ public static String encodeBytes(byte[] source, int off, int len) {
      * Encodes a byte array into Base64 notation.
      * <p>
      * Example options:
-     *
+     * 
      * <pre>
      *   GZIP: gzip-compresses object before encoding it.
      *   DO_BREAK_LINES: break lines at 76 characters
@@ -664,7 +664,7 @@ public static String encodeBytes(byte[] source, int off, int len) {
      * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
      * to handle it.
      * </p>
-     *
+     * 
      * @param source The data to convert
      * @param off Offset in array where conversion should begin
      * @param len Length of data to convert
@@ -694,7 +694,7 @@ public static String encodeBytes(byte[] source, int off, int len, int options) t
     /**
      * Similar to {@link #encodeBytes(byte[])} but returns a byte array instead of instantiating a String. This is more
      * efficient if you're working with I/O streams and have large data sets to encode.
-     *
+     * 
      * @param source The data to convert
      * @return The Base64-encoded data as a byte[] (of ASCII characters)
      * @throws NullPointerException if source array is null
@@ -714,7 +714,7 @@ public static byte[] encodeBytesToBytes(byte[] source) {
     /**
      * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns a byte array instead of instantiating a
      * String. This is more efficient if you're working with I/O streams and have large data sets to encode.
-     *
+     * 
      * @param source The data to convert
      * @param off Offset in array where conversion should begin
      * @param len Length of data to convert
@@ -853,7 +853,7 @@ public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int opt
      * <p>
      * This is the lowest level of the decoding methods with all possible parameters.
      * </p>
-     *
+     * 
      * @param source the array to convert
      * @param srcOffset the index where conversion begins
      * @param destination the array to hold the conversion
@@ -941,7 +941,7 @@ else if (source[srcOffset + 3] == EQUALS_SIGN) {
      * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
      * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
      * footprint (and aren't gzipping), consider this method.
-     *
+     * 
      * @param source The Base64 encoded data
      * @return decoded data
      * @since 2.3.1
@@ -962,7 +962,7 @@ public static byte[] decode(byte[] source) {
      * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
      * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
      * footprint (and aren't gzipping), consider this method.
-     *
+     * 
      * @param source The Base64 encoded data
      * @param off The offset of where to begin decoding
      * @param len The length of characters to decode
@@ -1040,7 +1040,7 @@ public static byte[] decode(byte[] source, int off, int len, int options) throws
 
     /**
      * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
-     *
+     * 
      * @param s the string to decode
      * @return the decoded data
      * @throws java.io.IOException If there is a problem
@@ -1053,7 +1053,7 @@ public static byte[] decode(String s) throws java.io.IOException {
 
     /**
      * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
-     *
+     * 
      * @param s the string to decode
      * @param options encode options such as URL_SAFE
      * @return the decoded data
@@ -1133,7 +1133,7 @@ public static byte[] decode(String s, int options) throws java.io.IOException {
 
     /**
      * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
-     *
+     * 
      * @param encodedObject The Base64 data to decode
      * @return The decoded and deserialized object
      * @throws NullPointerException if encodedObject is null
@@ -1150,7 +1150,7 @@ public static Object decodeToObject(String encodedObject) throws java.io.IOExcep
     /**
      * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
      * If <tt>loader</tt> is not null, it will be the class loader used when deserializing.
-     *
+     * 
      * @param encodedObject The Base64 data to decode
      * @param options Various parameters related to decoding
      * @param loader Optional class loader to use in deserializing classes.
@@ -1224,7 +1224,7 @@ public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.
      * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
      * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
      * </p>
-     *
+     * 
      * @param dataToEncode byte array of data to encode in base64 form
      * @param filename Filename for saving encoded data
      * @throws java.io.IOException if there is an error
@@ -1261,7 +1261,7 @@ public static void encodeToFile(byte[] dataToEncode, String filename) throws jav
      * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
      * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
      * </p>
-     *
+     * 
      * @param dataToDecode Base64-encoded data as a string
      * @param filename Filename for saving decoded data
      * @throws java.io.IOException if there is an error
@@ -1293,7 +1293,7 @@ public static void decodeToFile(String dataToDecode, String filename) throws jav
      * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
      * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
      * </p>
-     *
+     * 
      * @param filename Filename for reading encoded data
      * @return decoded byte array
      * @throws java.io.IOException if there is an error
@@ -1351,7 +1351,7 @@ public static byte[] decodeFromFile(String filename) throws java.io.IOException
      * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
      * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
      * </p>
-     *
+     * 
      * @param filename Filename for reading binary data
      * @return base64-encoded string
      * @throws java.io.IOException if there is an error
@@ -1404,7 +1404,7 @@ public static String encodeFromFile(String filename) throws java.io.IOException
 
     /**
      * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
-     *
+     * 
      * @param infile Input file
      * @param outfile Output file
      * @throws java.io.IOException if there is an error
@@ -1432,7 +1432,7 @@ public static void encodeFileToFile(String infile, String outfile) throws java.i
 
     /**
      * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
-     *
+     * 
      * @param infile Input file
      * @param outfile Output file
      * @throws java.io.IOException if there is an error
@@ -1462,7 +1462,7 @@ public static void decodeFileToFile(String infile, String outfile) throws java.i
     /**
      * A {@link Base64.InputStream} will read data from another <tt>java.io.InputStream</tt>, given in the constructor,
      * and encode/decode to/from Base64 notation on the fly.
-     *
+     * 
      * @see Base64
      * @since 1.3
      */
@@ -1489,7 +1489,7 @@ public static class InputStream extends java.io.FilterInputStream {
 
         /**
          * Constructs a {@link Base64.InputStream} in DECODE mode.
-         *
+         * 
          * @param in the <tt>java.io.InputStream</tt> from which to read data.
          * @since 1.3
          */
@@ -1502,7 +1502,7 @@ public InputStream(java.io.InputStream in) {
          * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE mode.
          * <p>
          * Valid options:
-         *
+         * 
          * <pre>
          *   ENCODE or DECODE: Encode or Decode as data is read.
          *   DO_BREAK_LINES: break lines at 76 characters
@@ -1510,7 +1510,7 @@ public InputStream(java.io.InputStream in) {
          * </pre>
          * <p>
          * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
-         *
+         * 
          * @param in the <tt>java.io.InputStream</tt> from which to read data.
          * @param options Specified options
          * @see Base64#ENCODE
@@ -1534,7 +1534,7 @@ public InputStream(java.io.InputStream in, int options) {
 
         /**
          * Reads enough of the input stream to convert to/from Base64 and returns the next byte.
-         *
+         * 
          * @return next byte
          * @since 1.3
          */
@@ -1639,7 +1639,7 @@ else if (i == 0) {
         /**
          * Calls {@link #read()} repeatedly until the end of stream is reached or <var>len</var> bytes are read. Returns
          * number of bytes read into array or -1 if end of stream is encountered.
-         *
+         * 
          * @param dest array to hold values
          * @param off offset for array
          * @param len max number of bytes to read into array
@@ -1671,7 +1671,7 @@ public int read(byte[] dest, int off, int len) throws java.io.IOException {
     /**
      * A {@link Base64.OutputStream} will write data to another <tt>java.io.OutputStream</tt>, given in the constructor,
      * and encode/decode to/from Base64 notation on the fly.
-     *
+     * 
      * @see Base64
      * @since 1.3
      */
@@ -1700,7 +1700,7 @@ public static class OutputStream extends java.io.FilterOutputStream {
 
         /**
          * Constructs a {@link Base64.OutputStream} in ENCODE mode.
-         *
+         * 
          * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
          * @since 1.3
          */
@@ -1713,7 +1713,7 @@ public OutputStream(java.io.OutputStream out) {
          * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE mode.
          * <p>
          * Valid options:
-         *
+         * 
          * <pre>
          *   ENCODE or DECODE: Encode or Decode as data is read.
          *   DO_BREAK_LINES: don't break lines at 76 characters
@@ -1721,7 +1721,7 @@ public OutputStream(java.io.OutputStream out) {
          * </pre>
          * <p>
          * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
-         *
+         * 
          * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
          * @param options Specified options.
          * @see Base64#ENCODE
@@ -1748,7 +1748,7 @@ public OutputStream(java.io.OutputStream out, int options) {
          * Writes the byte to the output stream after converting to/from Base64 notation. When encoding, bytes are
          * buffered three at a time before the output stream actually gets a write() call. When decoding, bytes are
          * buffered four at a time.
-         *
+         * 
          * @param theByte the byte to write
          * @since 1.3
          */
@@ -1798,7 +1798,7 @@ else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
 
         /**
          * Calls {@link #write(int)} repeatedly until <var>len</var> bytes are written.
-         *
+         * 
          * @param theBytes array from which to read bytes
          * @param off offset for array
          * @param len max number of bytes to read into array
@@ -1821,7 +1821,7 @@ public void write(byte[] theBytes, int off, int len) throws java.io.IOException
 
         /**
          * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer without closing the stream.
-         *
+         * 
          * @throws java.io.IOException if there's an error.
          */
         public void flushBase64() throws java.io.IOException {
@@ -1840,7 +1840,7 @@ public void flushBase64() throws java.io.IOException {
 
         /**
          * Flushes and closes (I think, in the superclass) the stream.
-         *
+         * 
          * @since 1.3
          */
         @Override
@@ -1860,7 +1860,7 @@ public void close() throws java.io.IOException {
         /**
          * Suspends encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
          * stream.
-         *
+         * 
          * @throws java.io.IOException if there's an error flushing
          * @since 1.5.1
          */
@@ -1873,7 +1873,7 @@ public void suspendEncoding() throws java.io.IOException {
         /**
          * Resumes encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
          * stream.
-         *
+         * 
          * @since 1.5.1
          */
         public void resumeEncoding() {
diff --git a/src/com/ichi2/utils/DiffEngine.java b/src/com/ichi2/utils/DiffEngine.java
index 426d81120730..8744a78e1584 100644
--- a/src/com/ichi2/utils/DiffEngine.java
+++ b/src/com/ichi2/utils/DiffEngine.java
@@ -33,7 +33,7 @@
 /**
  * Functions for diff, match and patch. Computes the difference between two texts to create a patch. Applies the patch
  * onto another text, allowing for errors.
- *
+ * 
  * @author fraser@google.com (Neil Fraser) Class containing the diff, match and patch methods. Also contains the
  *         behaviour settings. TODO if possible, remove the merging code, unneeded.
  */
@@ -87,7 +87,7 @@ public enum Operation {
     /**
      * Find the differences between two texts. Run a faster slightly less optimal diff This method allows the
      * 'checklines' of diff_main() to be optional. Most of the time checklines is wanted, so default to true.
-     *
+     * 
      * @param text1 Old string to be diffed.
      * @param text2 New string to be diffed.
      * @return Linked List of Diff objects.
@@ -100,7 +100,7 @@ public LinkedList<DiffAction> diff_main(String text1, String text2) {
     /**
      * Find the differences between two texts. Simplifies the problem by stripping any common prefix or suffix off the
      * texts before diffing.
-     *
+     * 
      * @param text1 Old string to be diffed.
      * @param text2 New string to be diffed.
      * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
@@ -146,7 +146,7 @@ public LinkedList<DiffAction> diff_main(String text1, String text2, boolean chec
 
     /**
      * Find the differences between two texts. Assumes that the texts do not have any common prefix or suffix.
-     *
+     * 
      * @param text1 Old string to be diffed.
      * @param text2 New string to be diffed.
      * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
@@ -276,7 +276,7 @@ protected LinkedList<DiffAction> diff_compute(String text1, String text2, boolea
     /**
      * Split two texts into a list of strings. Reduce the texts to a string of hashes where each Unicode character
      * represents one line.
-     *
+     * 
      * @param text1 First string.
      * @param text2 Second string.
      * @return An object containing the encoded text1, the encoded text2 and the List of unique strings. The zeroth
@@ -301,7 +301,7 @@ protected LinesToCharsResult diff_linesToChars(String text1, String text2) {
     /**
      * Split a text into a list of strings. Reduce the texts to a string of hashes where each Unicode character
      * represents one line.
-     *
+     * 
      * @param text String to encode.
      * @param lineArray List of unique strings.
      * @param lineHash Map of strings to indices.
@@ -337,7 +337,7 @@ private String diff_linesToCharsMunge(String text, List<String> lineArray, Map<S
 
     /**
      * Rehydrate the text in a diff from a string of line hashes to real lines of text.
-     *
+     * 
      * @param diffs LinkedList of Diff objects.
      * @param lineArray List of unique strings.
      */
@@ -355,7 +355,7 @@ protected void diff_charsToLines(LinkedList<DiffAction> diffs, List<String> line
 
     /**
      * Explore the intersection points between the two texts.
-     *
+     * 
      * @param text1 Old string to be diffed.
      * @param text2 New string to be diffed.
      * @return LinkedList of Diff objects or null if no diff available.
@@ -481,7 +481,7 @@ protected LinkedList<DiffAction> diff_map(String text1, String text2) {
 
     /**
      * Work from the middle back to the start to determine the path.
-     *
+     * 
      * @param v_map List of path sets.
      * @param text1 Old string fragment to be diffed.
      * @param text2 New string fragment to be diffed.
@@ -531,7 +531,7 @@ protected LinkedList<DiffAction> diff_path1(List<Set<Long>> v_map, String text1,
 
     /**
      * Work from the middle back to the end to determine the path.
-     *
+     * 
      * @param v_map List of path sets.
      * @param text1 Old string fragment to be diffed.
      * @param text2 New string fragment to be diffed.
@@ -584,7 +584,7 @@ protected LinkedList<DiffAction> diff_path2(List<Set<Long>> v_map, String text1,
 
     /**
      * Compute a good hash of two integers.
-     *
+     * 
      * @param x First int.
      * @param y Second int.
      * @return A long made up of both ints.
@@ -602,7 +602,7 @@ protected long diff_footprint(int x, int y) {
 
     /**
      * Determine the common prefix of two strings
-     *
+     * 
      * @param text1 First string.
      * @param text2 Second string.
      * @return The number of characters common to the start of each string.
@@ -621,7 +621,7 @@ public int diff_commonPrefix(String text1, String text2) {
 
     /**
      * Determine the common suffix of two strings
-     *
+     * 
      * @param text1 First string.
      * @param text2 Second string.
      * @return The number of characters common to the end of each string.
@@ -642,7 +642,7 @@ public int diff_commonSuffix(String text1, String text2) {
 
     /**
      * Do the two texts share a substring which is at least half the length of the longer text?
-     *
+     * 
      * @param text1 First string.
      * @param text2 Second string.
      * @return Five element String array, containing the prefix of text1, the suffix of text1, the prefix of text2, the
@@ -684,7 +684,7 @@ protected String[] diff_halfMatch(String text1, String text2) {
     /**
      * Does a substring of shorttext exist within longtext such that the substring is at least half the length of
      * longtext?
-     *
+     * 
      * @param longtext Longer string.
      * @param shorttext Shorter string.
      * @param i Start index of quarter length substring within longtext.
@@ -719,7 +719,7 @@ private String[] diff_halfMatchI(String longtext, String shorttext, int i) {
 
     /**
      * Reduce the number of edits by eliminating semantically trivial equalities.
-     *
+     * 
      * @param diffs LinkedList of Diff objects.
      */
     public void diff_cleanupSemantic(LinkedList<DiffAction> diffs) {
@@ -796,7 +796,7 @@ public void diff_cleanupSemantic(LinkedList<DiffAction> diffs) {
     /**
      * Look for single edits surrounded on both sides by equalities which can be shifted sideways to align the edit to a
      * word boundary. e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
-     *
+     * 
      * @param diffs LinkedList of Diff objects.
      */
     public void diff_cleanupSemanticLossless(LinkedList<DiffAction> diffs) {
@@ -878,7 +878,7 @@ public void diff_cleanupSemanticLossless(LinkedList<DiffAction> diffs) {
     /**
      * Given two strings, compute a score representing whether the internal boundary falls on logical boundaries. Scores
      * range from 5 (best) to 0 (worst).
-     *
+     * 
      * @param one First string.
      * @param two Second string.
      * @return The score.
@@ -922,7 +922,7 @@ private int diff_cleanupSemanticScore(String one, String two) {
     /**
      * Reorder and merge like edit sections. Merge equalities. Any edit section can move as long as it doesn't cross an
      * equality.
-     *
+     * 
      * @param diffs LinkedList of Diff objects.
      */
     public void diff_cleanupMerge(LinkedList<DiffAction> diffs) {
@@ -1065,7 +1065,7 @@ public void diff_cleanupMerge(LinkedList<DiffAction> diffs) {
 
     /**
      * Convert a Diff list into a pretty HTML report.
-     *
+     * 
      * @param diffs LinkedList of Diff objects.
      * @return HTML representation.
      */
@@ -1110,7 +1110,7 @@ public static class DiffAction {
 
         /**
          * Constructor. Initializes the diff with the provided values.
-         *
+         * 
          * @param operation One of INSERT, DELETE or EQUAL.
          * @param text The text being applied.
          */
@@ -1123,7 +1123,7 @@ public DiffAction(Operation operation, String text) {
 
         /**
          * Display a human-readable version of this Diff.
-         *
+         * 
          * @return text version.
          */
         @Override
@@ -1135,7 +1135,7 @@ public String toString() {
 
         /**
          * Is this Diff equivalent to another Diff?
-         *
+         * 
          * @param d Another Diff to compare against.
          * @return true or false.
          */
diff --git a/src/com/ichi2/utils/HtmlUtil.java b/src/com/ichi2/utils/HtmlUtil.java
index c6fae77e4e41..4642324900df 100644
--- a/src/com/ichi2/utils/HtmlUtil.java
+++ b/src/com/ichi2/utils/HtmlUtil.java
@@ -23,14 +23,15 @@
  */
 public class HtmlUtil {
 
-    private HtmlUtil() {}
+    private HtmlUtil() {
+    }
 
 
     /**
      * Unescapes all sequences within the given string of text, interpreting them as HTML escaped characters.
      * <p/>
      * Not that this code strips any HTML tags untouched, so if the text contains any HTML tags, they will be ignored.
-     *
+     * 
      * @param htmlText the text to convert
      * @return the unescaped text
      */
diff --git a/src/com/ichi2/utils/MethodLogger.java b/src/com/ichi2/utils/MethodLogger.java
index 3663392485e4..a1c6c1555cf3 100644
--- a/src/com/ichi2/utils/MethodLogger.java
+++ b/src/com/ichi2/utils/MethodLogger.java
@@ -27,10 +27,10 @@
  * Use with moderation as it spans the logcat and reduces performances.
  * <p>
  * Consider guarding calls to this method with an if statement on a static final constant, as in:
- *
+ * 
  * <pre>
  *   public static final boolean DEBUG = false;  // Enable for debugging this class.
- *
+ * 
  *   public void methodName(int value, String name) {
  *     if (DEBUG) {
  *       MethodLogger.log(value, name);
@@ -47,7 +47,7 @@ private MethodLogger() {
 
     /**
      * Logs the method being called.
-     *
+     * 
      * @param message to add to the logged statement
      */
     public static void log(String message) {
@@ -67,7 +67,7 @@ public static void log() {
      * Logs the method that made the call.
      * <p>
      * A helper method is needed to make sure the number of stack frames is the same on every path.
-     *
+     * 
      * @param message to be added to the logged message
      */
     private static void logInternal(String message) {
diff --git a/src/com/ichi2/utils/Threads.java b/src/com/ichi2/utils/Threads.java
index 3eea74bdbf77..fd9a2c74f9a6 100644
--- a/src/com/ichi2/utils/Threads.java
+++ b/src/com/ichi2/utils/Threads.java
@@ -42,7 +42,7 @@ public interface ThreadChecker {
 
     /**
      * Creates a {@link ThreadChecker} that validates all access are done on the given thread.
-     *
+     * 
      * @param thread on which accesses should occur
      */
     public static ThreadChecker newSingleThreadChecker(Thread thread) {
@@ -117,7 +117,7 @@ private static class SingleThreadChecker implements ThreadChecker {
          * <p>
          * If passed {@code null}, it will detect the first thread that calls {@link #checkThread()} and make sure all
          * future accesses are from that thread.
-         *
+         * 
          * @param thread that is allowed access
          */
         private SingleThreadChecker(Thread thread) {
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
index 4c8fdc755ff5..5bc1ce2484ad 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -1133,4 +1133,4 @@
 //            }
 //        }
 //    }
-//}
+// }
diff --git a/src/com/ichi2/widget/DeckStatus.java b/src/com/ichi2/widget/DeckStatus.java
index 367232796b70..2b9bceb47763 100644
--- a/src/com/ichi2/widget/DeckStatus.java
+++ b/src/com/ichi2/widget/DeckStatus.java
@@ -1,7 +1,6 @@
 
 package com.ichi2.widget;
 
-
 /**
  * Simple class to hold the current status of a deck.
  */
diff --git a/src/com/ichi2/widget/WidgetContentService.java b/src/com/ichi2/widget/WidgetContentService.java
index f9cf85174759..e27fd385488a 100644
--- a/src/com/ichi2/widget/WidgetContentService.java
+++ b/src/com/ichi2/widget/WidgetContentService.java
@@ -88,4 +88,4 @@
 //            return WidgetContentService.this;
 //        }
 //    }
-//}
+// }
diff --git a/src/com/ichi2/widget/WidgetDialog.java b/src/com/ichi2/widget/WidgetDialog.java
index ad2a48e73978..7d211d8b6b5b 100644
--- a/src/com/ichi2/widget/WidgetDialog.java
+++ b/src/com/ichi2/widget/WidgetDialog.java
@@ -140,4 +140,4 @@
 //            }
 //        }
 //    }
-//}
+// }
diff --git a/src/com/ichi2/widget/WidgetStatus.java b/src/com/ichi2/widget/WidgetStatus.java
index 4fcf58838752..8c37fcff85a5 100644
--- a/src/com/ichi2/widget/WidgetStatus.java
+++ b/src/com/ichi2/widget/WidgetStatus.java
@@ -76,10 +76,11 @@ public static void update(Context context, float[] smallWidgetStatus) {
     }
 
 
-    public static void update(Context context, boolean updateBigWidget, DeckStatus deckStatus, float[] smallWidgetStatus, TreeSet<Object[]> deckCounts) {
+    public static void update(Context context, boolean updateBigWidget, DeckStatus deckStatus,
+            float[] smallWidgetStatus, TreeSet<Object[]> deckCounts) {
         sDeckStatus = deckStatus;
-    	sSmallWidgetStatus = smallWidgetStatus;
-    	sDeckCounts = deckCounts;
+        sSmallWidgetStatus = smallWidgetStatus;
+        sDeckCounts = deckCounts;
 
         SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
         if (preferences.getBoolean("widgetMediumEnabled", false)) {
@@ -169,7 +170,7 @@ private static class UpdateDeckStatusAsyncTask extends BaseAsyncTask<Context, Vo
         private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];
 
         private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;
-        private static float[] mSmallWidgetStatus = new float[]{0, 0, 0, 0};
+        private static float[] mSmallWidgetStatus = new float[] { 0, 0, 0, 0 };
 
 
         @Override
@@ -183,7 +184,7 @@ protected Context doInBackground(Context... params) {
             }
 
             // For the deck information
-//            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
+            // ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
 
             // if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
             // decks = new ArrayList<DeckStatus>(mDecks.length);
@@ -201,42 +202,42 @@ protected Context doInBackground(Context... params) {
             // }
             // } else {
             try {
-            	if (sSmallWidgetStatus == null) {
+                if (sSmallWidgetStatus == null) {
                     Collection col = AnkiDroidApp.openCollection(AnkiDroidApp.getCollectionPath());
                     mSmallWidgetStatus = col.getSched().progressToday(sDeckCounts, null, true);
                     AnkiDroidApp.closeCollection(false);
-            	} else {
-            		mSmallWidgetStatus = sSmallWidgetStatus;
-            	}
-//                Collection col = Collection.currentCollection();
-//                Object[] di;
-//                float progress;
-//                if (col == null) {
-//                    col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
-//                    di = col.getSched().deckCounts();
-//                    progress = col.getSched().todaysProgress(null, true, true);
-//                    col.close(false);
-//                } else {
-//                    di = col.getSched().deckCounts();
-//                    progress = col.getSched().progressTodayAll(di);
-//                }
-//                int eta = (Integer) di[1];
-//                for (Object[] d : (TreeSet<Object[]>) di[0]) {
-//                    String[] sname = (String[]) d[0];
-//                    StringBuilder name = new StringBuilder();
-//                    name.append(sname[0]);
-//                    for (int i = 1; i < sname.length; i++) {
-//                        name.append("::").append(sname[i]);
-//                    }
-//                    decks.add(new DeckStatus((Long) d[1], name.toString(), (Integer) d[2], (Integer) d[3],
-//                            (Integer) d[4], (int) (progress * 100), eta));
-//                }
+                } else {
+                    mSmallWidgetStatus = sSmallWidgetStatus;
+                }
+                // Collection col = Collection.currentCollection();
+                // Object[] di;
+                // float progress;
+                // if (col == null) {
+                // col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
+                // di = col.getSched().deckCounts();
+                // progress = col.getSched().todaysProgress(null, true, true);
+                // col.close(false);
+                // } else {
+                // di = col.getSched().deckCounts();
+                // progress = col.getSched().progressTodayAll(di);
+                // }
+                // int eta = (Integer) di[1];
+                // for (Object[] d : (TreeSet<Object[]>) di[0]) {
+                // String[] sname = (String[]) d[0];
+                // StringBuilder name = new StringBuilder();
+                // name.append(sname[0]);
+                // for (int i = 1; i < sname.length; i++) {
+                // name.append("::").append(sname[i]);
+                // }
+                // decks.add(new DeckStatus((Long) d[1], name.toString(), (Integer) d[2], (Integer) d[3],
+                // (Integer) d[4], (int) (progress * 100), eta));
+                // }
             } catch (SQLException e) {
                 Log.i(AnkiDroidApp.TAG, "Widget: Problems on retrieving deck information");
             }
-//             }
-//
-//            mDecks = decks.toArray(EMPTY_DECK_STATUS);
+            // }
+            //
+            // mDecks = decks.toArray(EMPTY_DECK_STATUS);
             return context;
         }
 
@@ -246,24 +247,24 @@ protected void onPostExecute(Context context) {
             super.onPostExecute(context);
             Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()");
             MetaDB.storeSmallWidgetStatus(context, mSmallWidgetStatus);
-//            MetaDB.storeWidgetStatus(context, mDecks);
-//            if (mediumWidget) {
-//                Intent intent;
-//                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
-//                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
-//                context.startService(intent);
-//            }
+            // MetaDB.storeWidgetStatus(context, mDecks);
+            // if (mediumWidget) {
+            // Intent intent;
+            // intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
+            // intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
+            // context.startService(intent);
+            // }
             if (smallWidget) {
                 Intent intent;
                 intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);
                 context.startService(intent);
             }
-//            if (bigWidget) {
-//                Intent intent;
-//                intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
-//                intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
-//                context.startService(intent);
-//            }
+            // if (bigWidget) {
+            // Intent intent;
+            // intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
+            // intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
+            // context.startService(intent);
+            // }
             if (notification) {
                 Intent intent;
                 intent = new Intent(context, NotificationService.class);
