diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
index bb1276b65610..ce8825a728d7 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
@@ -86,7 +86,9 @@ import com.ichi2.libanki.*
 import com.ichi2.libanki.Collection
 import com.ichi2.libanki.Consts.BUTTON_TYPE
 import com.ichi2.libanki.Sound.OnErrorListener.ErrorHandling
+import com.ichi2.libanki.Sound.SingleSoundSide
 import com.ichi2.libanki.Sound.SoundSide
+import com.ichi2.libanki.SoundPlayer
 import com.ichi2.libanki.sched.AbstractSched
 import com.ichi2.libanki.sched.SchedV2
 import com.ichi2.themes.Themes
@@ -238,10 +240,12 @@ abstract class AbstractFlashcardViewer :
     @KotlinCleanup("made internal for tests")
     @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
     internal var sched: AbstractSched? = null
-    protected val mSoundPlayer = Sound()
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    internal lateinit var mSoundPlayer: Sound
 
     /**
-     * Time taken to play all medias in mSoundPlayer
+     * Time taken to play all medias in [mSoundPlayer]
      * This is 0 if we have "Read card" enabled, as we can't calculate the duration.
      */
     private var mUseTimerDynamicMS: Long = 0
@@ -584,8 +588,12 @@ abstract class AbstractFlashcardViewer :
         super.onCollectionLoaded(col)
         sched = col.sched
         val mediaDir = col.media.dir()
-        mBaseUrl = Utils.getBaseUrl(mediaDir)
-        mViewerUrl = mBaseUrl + "__viewer__.html"
+        mBaseUrl = Utils.getBaseUrl(mediaDir).also { baseUrl ->
+            mSoundPlayer = Sound(baseUrl).also { sound ->
+                sound.setupVideoActivityCallback()
+            }
+            mViewerUrl = baseUrl + "__viewer__.html"
+        }
         mAssetLoader = WebViewAssetLoader.Builder()
             .addPathHandler("/") { path: String ->
                 try {
@@ -622,16 +630,18 @@ abstract class AbstractFlashcardViewer :
         automaticAnswer.disable()
         mLongClickHandler.removeCallbacks(mLongClickTestRunnable)
         mLongClickHandler.removeCallbacks(mStartLongClickAction)
-        mSoundPlayer.stopSounds()
-
+        if (this::mSoundPlayer.isInitialized) {
+            mSoundPlayer.stopSounds()
+        }
         // Prevent loss of data in Cookies
         CookieManager.getInstance().flush()
     }
 
     override fun onResume() {
         super.onResume()
-        // Set the context for the Sound manager
-        mSoundPlayer.setContext(WeakReference(this))
+        if (this::mSoundPlayer.isInitialized) {
+            mSoundPlayer.setupVideoActivityCallback()
+        }
         automaticAnswer.enable()
         // Reset the activity title
         setTitle()
@@ -882,7 +892,7 @@ abstract class AbstractFlashcardViewer :
 
     fun generateQuestionSoundList() {
         val tags = Sound.extractTagsFromLegacyContent(currentCard!!.qSimple())
-        mSoundPlayer.addSounds(mBaseUrl!!, tags, SoundSide.QUESTION)
+        mSoundPlayer.addSounds(tags, SingleSoundSide.QUESTION)
     }
 
     protected fun showDeleteNoteDialog() {
@@ -1451,7 +1461,7 @@ abstract class AbstractFlashcardViewer :
         // don't add answer sounds multiple times, such as when reshowing card after exiting editor
         // additionally, this condition reduces computation time
         if (!mAnswerSoundsAdded) {
-            mSoundPlayer.addSounds(mBaseUrl!!, answerSounds.get(), SoundSide.ANSWER)
+            mSoundPlayer.addSounds(answerSounds.get(), SingleSoundSide.ANSWER)
             mAnswerSoundsAdded = true
         }
     }
@@ -1470,7 +1480,7 @@ abstract class AbstractFlashcardViewer :
             // leaving the card (such as when edited)
             mSoundPlayer.resetSounds()
             mAnswerSoundsAdded = false
-            mSoundPlayer.addSounds(mBaseUrl!!, content.getSoundTags(Side.FRONT), SoundSide.QUESTION)
+            mSoundPlayer.addSounds(content.getSoundTags(Side.FRONT), SingleSoundSide.QUESTION)
             if (automaticAnswer.isEnabled() && !mAnswerSoundsAdded && mCardSoundConfig!!.autoplay) {
                 addAnswerSounds { content.getSoundTags(Side.BACK) }
             }
@@ -1493,6 +1503,11 @@ abstract class AbstractFlashcardViewer :
         playSounds(false) // Play sounds if appropriate
     }
 
+    private fun currentSideHasSounds(): Boolean = when (displayAnswer) {
+        false -> mSoundPlayer.hasQuestion()
+        true -> mSoundPlayer.hasAnswer()
+    }
+
     /**
      * Plays sounds (or TTS, if configured) for currently shown side of card.
      *
@@ -1503,8 +1518,7 @@ abstract class AbstractFlashcardViewer :
         val replayQuestion = mCardSoundConfig!!.replayQuestion
         if (mCardSoundConfig!!.autoplay || doAudioReplay) {
             // Use TTS if TTS preference enabled and no other sound source
-            val useTTS = mTTS.enabled &&
-                !(displayAnswer && mSoundPlayer.hasAnswer()) && !(!displayAnswer && mSoundPlayer.hasQuestion())
+            val useTTS = mTTS.enabled && !currentSideHasSounds()
             // We need to play the sounds from the proper side of the card
             if (!useTTS) { // Text to speech not in effect here
                 if (doAudioReplay && replayQuestion && displayAnswer) {
@@ -1526,10 +1540,10 @@ abstract class AbstractFlashcardViewer :
                 // If the question is displayed or if the question should be replayed, read the question
                 if (mTtsInitialized) {
                     if (!displayAnswer || doAudioReplay && replayQuestion) {
-                        readCardTts(SoundSide.QUESTION)
+                        readCardTts(SingleSoundSide.QUESTION)
                     }
                     if (displayAnswer) {
-                        readCardTts(SoundSide.ANSWER)
+                        readCardTts(SingleSoundSide.ANSWER)
                     }
                 } else {
                     mReplayOnTtsInit = true
@@ -1538,11 +1552,9 @@ abstract class AbstractFlashcardViewer :
         }
     }
 
-    private fun readCardTts(soundSide: SoundSide) {
-        val tags = legacyGetTtsTags(currentCard!!, soundSide, this)
-        if (tags != null) {
-            mTTS.readCardText(tags, currentCard!!, soundSide)
-        }
+    private fun readCardTts(side: SingleSoundSide) {
+        val tags = legacyGetTtsTags(currentCard!!, side, this)
+        mTTS.readCardText(tags, currentCard!!, side.toSoundSide())
     }
 
     private fun playSounds(questionAndAnswer: SoundSide) {
@@ -2128,16 +2140,6 @@ abstract class AbstractFlashcardViewer :
         }
     }
 
-    /**
-     * Public method to start new video player activity
-     */
-    fun playVideo(path: String?) {
-        Timber.i("Launching Video: %s", path)
-        val videoPlayer = Intent(this, VideoPlayer::class.java)
-        videoPlayer.putExtra("path", path)
-        startActivityWithoutAnimation(videoPlayer)
-    }
-
     /** Callback for when TTS has been initialized.  */
     fun ttsInitialized() {
         mTtsInitialized = true
@@ -2514,15 +2516,7 @@ abstract class AbstractFlashcardViewer :
                     Sound.getSoundPath(mBaseUrl!!, it)
                 } ?: return
             }
-            if (replacedUrl != mSoundPlayer.currentAudioUri || mSoundPlayer.isCurrentAudioFinished) {
-                onCurrentAudioChanged(replacedUrl)
-            } else {
-                mSoundPlayer.playOrPauseSound()
-            }
-        }
-
-        private fun onCurrentAudioChanged(url: String) {
-            mSoundPlayer.playSound(url, null, null, soundErrorListener)
+            mSoundPlayer.playAnotherSound(replacedUrl, soundErrorListener)
         }
 
         private fun decodeUrl(url: String): String {
@@ -2687,4 +2681,26 @@ abstract class AbstractFlashcardViewer :
             }
         }
     }
+
+    /**
+     * Set the context for the calling activity (necessary for playing videos)
+     */
+    private fun SoundPlayer.setupVideoActivityCallback() {
+        val activityRef = WeakReference(this@AbstractFlashcardViewer)
+        this.playVideoExternallyCallback = { soundPath, onCompletionListener ->
+            val activity = activityRef.get()
+            if (activity == null) {
+                false
+            } else {
+                Timber.d("Requesting AbstractFlashcardViewer->VideoPlayer for video")
+                VideoPlayer.mediaCompletionListener = onCompletionListener
+                activity.startActivityWithoutAnimation(
+                    Intent(activity, VideoPlayer::class.java).apply {
+                        putExtra("path", soundPath)
+                    }
+                )
+                true
+            }
+        }
+    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/VideoPlayer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/VideoPlayer.kt
index 1834939777a8..b576b6489e68 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/VideoPlayer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/VideoPlayer.kt
@@ -24,14 +24,14 @@ import android.view.SurfaceHolder
 import android.view.WindowManager.LayoutParams
 import android.widget.VideoView
 import com.ichi2.anki.UIUtils.showThemedToast
-import com.ichi2.libanki.Sound
+import com.ichi2.libanki.VideoPlayer
 import com.ichi2.themes.Themes
 import timber.log.Timber
 
 class VideoPlayer : Activity(), SurfaceHolder.Callback {
     private lateinit var mVideoView: VideoView
-    private val mSoundPlayer: Sound = Sound()
-    private var mPath: String? = null
+    private lateinit var videoPlayer: VideoPlayer
+    private lateinit var path: String
 
     /** Called when the activity is first created.  */
     @Suppress("DEPRECATION") // #9332: UI Visibility -> Insets
@@ -40,33 +40,36 @@ class VideoPlayer : Activity(), SurfaceHolder.Callback {
         super.onCreate(savedInstanceState)
         Themes.disableXiaomiForceDarkMode(this)
         setContentView(R.layout.video_player)
-        mPath = intent.getStringExtra("path")
-        Timber.i("Video Player intent had path: %s", mPath)
-        window.setFlags(
-            LayoutParams.FLAG_FULLSCREEN,
-            LayoutParams.FLAG_FULLSCREEN
-        )
-        window.addFlags(LayoutParams.FLAG_KEEP_SCREEN_ON)
+        this.path = intent.getStringExtra("path").let { path ->
+            if (path == null) {
+                // #5911 - May happen if launched externally. Not possible inside AnkiDroid
+                Timber.w("video path was null")
+                showThemedToast(this, getString(R.string.video_creation_error), true)
+                finish()
+                return
+            }
+            path
+        }
+
+        Timber.i("Video Player launched successfully")
+        window.apply {
+            setFlags(
+                LayoutParams.FLAG_FULLSCREEN,
+                LayoutParams.FLAG_FULLSCREEN
+            )
+            addFlags(LayoutParams.FLAG_KEEP_SCREEN_ON)
+        }
         mVideoView = findViewById(R.id.video_surface)
+        videoPlayer = VideoPlayer(mVideoView)
         mVideoView.holder.addCallback(this)
     }
 
     override fun surfaceCreated(holder: SurfaceHolder) {
         Timber.i("surfaceCreated")
-        if (mPath == null) {
-            // #5911 - path shouldn't be null. I couldn't determine why this happens.
-            CrashReportService.sendExceptionReport("Video: mPath was unexpectedly null", "VideoPlayer surfaceCreated")
-            Timber.e("path was unexpectedly null")
-            showThemedToast(this, getString(R.string.video_creation_error), true)
+        videoPlayer.play(path, { mp: MediaPlayer? ->
             finish()
-            return
-        }
-        mSoundPlayer.playSound(mPath!!, { mp: MediaPlayer? ->
-            finish()
-
-            val originalListener = Sound.mediaCompletionListener
-            originalListener?.onCompletion(mp)
-        }, mVideoView, null)
+            mediaCompletionListener?.onCompletion(mp)
+        }, null)
     }
 
     override fun surfaceChanged(
@@ -75,20 +78,23 @@ class VideoPlayer : Activity(), SurfaceHolder.Callback {
         width: Int,
         height: Int
     ) {
-        // TODO Auto-generated method stub
+        // intentionally blank: required for interface
     }
 
     override fun surfaceDestroyed(holder: SurfaceHolder) {
-        mSoundPlayer.stopSounds()
+        videoPlayer.stopSounds()
         finish()
     }
 
     override fun onConfigurationChanged(newConfig: Configuration) {
         super.onConfigurationChanged(newConfig)
-        mSoundPlayer.notifyConfigurationChanged(mVideoView)
+        videoPlayer.notifyConfigurationChanged()
     }
 
-    public override fun onStop() {
-        super.onStop()
+    companion object {
+        /**
+         * OnCompletionListener so that external video player can notify to play next sound
+         */
+        var mediaCompletionListener: MediaPlayer.OnCompletionListener? = null
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/CardHtml.kt b/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/CardHtml.kt
index cd1e8f4d6592..0ccb09fc2cf6 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/CardHtml.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/CardHtml.kt
@@ -21,6 +21,9 @@ import com.ichi2.anki.R
 import com.ichi2.anki.TtsParser
 import com.ichi2.anki.cardviewer.CardAppearance.Companion.hasUserDefinedNightMode
 import com.ichi2.libanki.*
+import com.ichi2.libanki.Sound.SingleSoundSide
+import com.ichi2.libanki.Sound.SingleSoundSide.ANSWER
+import com.ichi2.libanki.Sound.SingleSoundSide.QUESTION
 import com.ichi2.libanki.template.MathJax
 import com.ichi2.themes.HtmlColors
 import com.ichi2.themes.Themes.currentTheme
@@ -213,14 +216,10 @@ class CardHtml(
             return newAnswerContent
         }
 
-        fun legacyGetTtsTags(card: Card, cardSide: Sound.SoundSide, context: Context): List<TTSTag>? {
-            val cardSideContent: String = when {
-                Sound.SoundSide.QUESTION == cardSide -> card.q(true)
-                Sound.SoundSide.ANSWER == cardSide -> card.pureAnswer
-                else -> {
-                    Timber.w("Unrecognised cardSide")
-                    return null
-                }
+        fun legacyGetTtsTags(card: Card, cardSide: SingleSoundSide, context: Context): List<TTSTag> {
+            val cardSideContent: String = when (cardSide) {
+                QUESTION -> card.q(true)
+                ANSWER -> card.pureAnswer
             }
             return TtsParser.getTextsToRead(cardSideContent, context.getString(R.string.reviewer_tts_cloze_spoken_replacement))
         }
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Sound.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/Sound.kt
index ee91a5b0d2ca..bf976668757e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Sound.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Sound.kt
@@ -17,7 +17,6 @@
 
 package com.ichi2.libanki
 
-import android.app.Activity
 import android.content.Context
 import android.media.*
 import android.media.AudioManager.OnAudioFocusChangeListener
@@ -28,261 +27,380 @@ import android.webkit.MimeTypeMap
 import android.widget.VideoView
 import androidx.annotation.CheckResult
 import androidx.annotation.VisibleForTesting
-import com.ichi2.anki.AbstractFlashcardViewer
 import com.ichi2.anki.AnkiDroidApp
 import com.ichi2.anki.ReadText
 import com.ichi2.compat.CompatHelper
 import com.ichi2.libanki.Sound.OnErrorListener.ErrorHandling.CONTINUE_AUDIO
+import com.ichi2.libanki.Sound.SoundSide.*
 import com.ichi2.utils.DisplayUtils
-import com.ichi2.utils.KotlinCleanup
 import net.ankiweb.rsdroid.BackendFactory.defaultLegacySchema
+import org.intellij.lang.annotations.Language
 import timber.log.Timber
-import java.lang.ref.WeakReference
 import java.util.*
 import java.util.regex.Pattern
 
+private typealias SoundPath = String
 // NICE_TO_HAVE: Abstract, then add tests for #6111
 /**
- * Class used to parse, load and play sound files on AnkiDroid.
+ * Parses, loads and plays sound & video files
+ * Called `Sound` Anki uses `[sound:]` for both audio and video
  */
-@KotlinCleanup("IDE Lint")
-class Sound {
+class Sound(private val soundPlayer: SoundPlayer, private val soundDir: String) : SoundPlayer by soundPlayer {
     /**
-     * Media player used to play the sounds. It's Nullable and that it is set only if a sound is playing or paused, otherwise it is null.
+     * @param soundDir base path to the media files
      */
-    private var mMediaPlayer: MediaPlayer? = null
+    constructor(soundDir: String) : this(SoundPlayerImpl(), soundDir)
 
     /**
-     * It's used to store the Uri of the current Audio in case of running or pausing.
+     * The subset of sounds to involve
+     * @param int Used for serialisation
      */
-    private var mCurrentAudioUri: Uri? = null
+    enum class SoundSide(val int: Int) {
+        QUESTION(0), ANSWER(1), QUESTION_AND_ANSWER(2);
+    }
 
-    /**
-     * AudioManager to request/release audio focus
-     */
-    private var mAudioManager: AudioManager? = null
+    /** Sounds for the question/answer of a card */
+    // Stops code paths where QUESTION_AND_ANSWER is invalid
+    enum class SingleSoundSide {
+        QUESTION, ANSWER;
+
+        fun toSoundSide(): SoundSide = when (this) {
+            QUESTION -> SoundSide.QUESTION
+            ANSWER -> SoundSide.ANSWER
+        }
+    }
 
     /**
-     * Weak reference to the activity which is attempting to play the sound
+     * Stores sounds for the current card. Maps from a side to paths paths
+     * Should be accessed via [getSounds]
      */
-    private var mCallingActivity: WeakReference<Activity?>? = null
+    private val soundPaths: MutableMap<SoundSide, MutableList<SoundPath>> = EnumMap(SoundSide::class.java)
 
+    /** Returns a non-empty list of sounds, or null if there are no values */
     @VisibleForTesting
-    fun getSounds(side: SoundSide): ArrayList<String>? {
-        if (side == SoundSide.QUESTION_AND_ANSWER) {
-            makeQuestionAnswerList()
-        }
-        return mSoundPaths[side]
+    fun getSounds(side: SoundSide) = getSoundList(side).let {
+        if (!it.any()) null else it
     }
 
-    /**
-     * Subset Flags: Flags that indicate the subset of sounds to involve
-     */
-    enum class SoundSide(val int: Int) {
-        QUESTION(0), ANSWER(1), QUESTION_AND_ANSWER(2);
+    private fun getSoundList(side: SoundSide): List<SoundPath> {
+        if (side == QUESTION_AND_ANSWER) {
+            return getSoundList(QUESTION) + getSoundList(ANSWER)
+        }
+        return soundPaths[side] ?: emptyList()
     }
 
     /**
-     * Stores sounds for the current card, key is one of the subset flags. It is intended that it not contain empty lists, and code assumes this will be true.
+     * Clears current sound paths; call before [expandSounds] + [addSounds]
+     * is called for the next card
      */
-    private val mSoundPaths: HashMap<SoundSide, ArrayList<String>> = HashMap()
-    private var mAudioFocusRequest: AudioFocusRequest? = null
-
-    // Clears current sound paths; call before parseSounds() calls
     fun resetSounds() {
-        mSoundPaths.clear()
+        soundPaths.clear()
     }
 
     /**
      * Stores entries to the filepaths for sounds, categorized as belonging to the front (question) or back (answer) of cards.
      * Note that all sounds embedded in the content will be given the same base categorization of question or answer.
      * Additionally, the result is to be sorted by the order of appearance on the card.
-     * @param soundDir -- base path to the media files
-     * @param tags -- the entries expected in display order
-     * @param qa -- the base categorization of the sounds in the content, SoundSide.SOUNDS_QUESTION or SoundSide.SOUNDS_ANSWER
+     * @param tags the entries expected in display order
+     * @param side the base categorization of the sounds in the content
      */
-    fun addSounds(soundDir: String, tags: List<SoundOrVideoTag>, qa: SoundSide) {
-        for ((filename) in tags) {
-            // Create appropriate list if needed; list must not be empty so long as code does no check
-            if (!mSoundPaths.containsKey(qa)) {
-                mSoundPaths[qa] = ArrayList(0)
+    fun addSounds(tags: List<SoundOrVideoTag>, side: SingleSoundSide) {
+        val soundPathCollection = soundPaths.getOrPut(side.toSoundSide()) { mutableListOf() }
+
+        Timber.d("Adding %d sounds to side: %s", tags.size, side)
+        val paths = tags.map { getSoundPath(soundDir, it.filename) }
+        soundPathCollection.addAll(paths)
+    }
+
+    /** Plays all the sounds for the indicated side(s)  */
+    fun playSounds(side: SoundSide, errorListener: OnErrorListener?) {
+        // If there are sounds to play for the current card, start with the first one
+        val soundPaths = getSounds(side) ?: return
+        Timber.d("playSounds: playing $side")
+        this.playSound(
+            soundPaths[0],
+            PlayAllCompletionListener(side, errorListener),
+            errorListener
+        )
+    }
+
+    /** Returns the total length of all sounds for the side in milliseconds */
+    fun getSoundsLength(side: SoundSide): Long {
+        val soundPaths = getSounds(side) ?: return 0
+        val metaRetriever = MediaMetadataRetriever()
+        val context = AnkiDroidApp.instance.applicationContext
+        return soundPaths
+            .map { Uri.parse(it) }
+            .sumOf { uri ->
+                try {
+                    metaRetriever.getDuration(context, uri)
+                } catch (e: Exception) {
+                    Timber.w(
+                        e,
+                        "metaRetriever - Error setting Data Source for mediaRetriever (media doesn't exist or forbidden?)."
+                    )
+                    0
+                }
             }
-            val soundPath = getSoundPath(soundDir, filename)
-            // Construct the sound path and store it
-            Timber.d("Adding Sound to side: %s", qa)
-            mSoundPaths[qa]!!.add(soundPath)
-        }
     }
 
     /**
-     * makeQuestionAnswerSoundList creates a single list of both the question and answer audio only if it does not
-     * already exist. It's intended for lazy evaluation, only in the rare cases when both sides are fully played
-     * together, which even when configured as supported may not be instigated
-     * @return True if a non-null list was created, or false otherwise
+     * Class used to play all sounds for a given card side
      */
-    private fun makeQuestionAnswerList(): Boolean {
-        // if combined list already exists, don't recreate
-        if (mSoundPaths.containsKey(SoundSide.QUESTION_AND_ANSWER)) {
-            return false // combined list already exists
+    private inner class PlayAllCompletionListener(
+        private val side: SoundSide,
+        private val errorListener: OnErrorListener?
+    ) : OnCompletionListener {
+        /** Index of next sound to play inside `getSounds(side)` */
+        // this is a completion listener: [onCompletion] is first called after the first sound
+        private var nextIndexToPlay = 1
+        override fun onCompletion(mp: MediaPlayer) {
+            val paths = getSounds(side) ?: emptyList() // emptyList -> stopSounds()
+            // If there are still more sounds to play for the current card, play the next one
+            if (nextIndexToPlay < paths.size) {
+                Timber.i("Play all: Playing next sound")
+                playSound(paths[nextIndexToPlay++], this, errorListener)
+            } else {
+                Timber.i("Play all: Completed - releasing sound")
+                soundPlayer.stopSounds()
+            }
         }
+    }
 
-        // make combined list only if necessary to avoid an empty combined list
-        if (mSoundPaths.containsKey(SoundSide.QUESTION) || mSoundPaths.containsKey(SoundSide.ANSWER)) {
-            // some list exists to place into combined list
-            mSoundPaths[SoundSide.QUESTION_AND_ANSWER] = ArrayList(0)
-        } else { // no need to make list
-            return false
-        }
-        val combinedSounds = mSoundPaths[SoundSide.QUESTION_AND_ANSWER]!!
-        if (mSoundPaths.containsKey(SoundSide.QUESTION)) {
-            combinedSounds.addAll(mSoundPaths[SoundSide.QUESTION]!!)
+    override fun stopSounds() {
+        soundPlayer.stopSounds()
+        ReadText.stopTts() // TODO: Reconsider design
+    }
+
+    fun hasQuestion(): Boolean = getSounds(QUESTION) != null
+
+    fun hasAnswer(): Boolean = getSounds(ANSWER) != null
+
+    /** Handle a call to play audio which may be made while audio is already playing */
+    fun playAnotherSound(replacedUrl: String, errorListener: OnErrorListener) {
+        val suppliedAudioIsCurrentlyPlaying = replacedUrl == currentAudioUri && !isCurrentAudioFinished
+        if (suppliedAudioIsCurrentlyPlaying) {
+            playOrPauseSound()
+        } else {
+            playSound(replacedUrl, null, errorListener)
         }
-        if (mSoundPaths.containsKey(SoundSide.ANSWER)) {
-            combinedSounds.addAll(mSoundPaths[SoundSide.ANSWER]!!)
+    }
+
+    fun interface OnErrorListener {
+        fun onError(mp: MediaPlayer?, which: Int, extra: Int, path: String?): ErrorHandling
+
+        enum class ErrorHandling {
+            /** Stop playing audio */
+            STOP_AUDIO,
+
+            /** Continue to the next audio (if any) */
+            CONTINUE_AUDIO,
+
+            /** Retry the current audio */
+            RETRY_AUDIO
         }
-        return true
     }
 
-    /**
-     * Plays the sounds for the indicated sides
-     * @param qa -- One of SoundSide.SOUNDS_QUESTION, SoundSide.SOUNDS_ANSWER, or SoundSide.SOUNDS_QUESTION_AND_ANSWER
-     */
-    fun playSounds(qa: SoundSide, errorListener: OnErrorListener?) {
-        // If there are sounds to play for the current card, start with the first one
-        if (mSoundPaths.containsKey(qa)) {
-            Timber.d("playSounds %s", qa)
-            playSoundInternal(
-                mSoundPaths[qa]!![0],
-                PlayAllCompletionListener(qa, errorListener),
-                null,
-                errorListener
-            )
-        } else if (qa == SoundSide.QUESTION_AND_ANSWER) {
-            if (makeQuestionAnswerList()) {
-                Timber.d("playSounds: playing both question and answer")
-                playSoundInternal(
-                    mSoundPaths[qa]!![0],
-                    PlayAllCompletionListener(qa, errorListener),
-                    null,
-                    errorListener
-                )
-            } else {
-                Timber.d("playSounds: No question answer list, not playing sound")
+    companion object {
+        /**
+         * Pattern used to identify the markers for sound files
+         */
+        val SOUND_PATTERN: Pattern = Pattern.compile("\\[sound:([^\\[\\]]*)]")
+
+        /**
+         * Pattern used to parse URI (according to http://tools.ietf.org/html/rfc3986#page-50)
+         */
+        private val sUriPattern =
+            Pattern.compile("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$")
+
+        /** Extract SoundOrVideoTag instances from content where sound tags are in the form: [sound:filename.mp3]  */
+        @CheckResult
+        fun extractTagsFromLegacyContent(content: String): List<SoundOrVideoTag> {
+            val matcher = SOUND_PATTERN.matcher(content)
+            // While there is matches of the pattern for sound markers
+            val ret = mutableListOf<SoundOrVideoTag>()
+            while (matcher.find()) {
+                // Get the sound file name
+                val sound = matcher.group(1)!!
+                ret.add(SoundOrVideoTag(sound))
             }
+            return ret
         }
-    }
 
-    /**
-     * Returns length in milliseconds.
-     * @param qa -- One of SoundSide.SOUNDS_QUESTION, SoundSide.SOUNDS_ANSWER, or SoundSide.SOUNDS_QUESTION_AND_ANSWER
-     */
-    fun getSoundsLength(qa: SoundSide): Long {
-        var length: Long = 0
-        if (qa == SoundSide.QUESTION_AND_ANSWER && makeQuestionAnswerList() || mSoundPaths.containsKey(
-                qa
-            )
-        ) {
-            val metaRetriever = MediaMetadataRetriever()
-            for (uri_string in mSoundPaths[qa]!!) {
-                val soundUri = Uri.parse(uri_string)
-                try {
-                    metaRetriever.setDataSource(
-                        AnkiDroidApp.instance.applicationContext,
-                        soundUri
-                    )
-                    length += metaRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)!!
-                        .toLong()
-                } catch (e: Exception) {
-                    Timber.e(
-                        e,
-                        "metaRetriever - Error setting Data Source for mediaRetriever (media doesn't exist or forbidden?)."
-                    )
-                }
+        /**
+         * expandSounds takes content with embedded sound file placeholders and expands them to reference the actual media
+         * file
+         *
+         * @param soundDir -- the base path of the media files
+         * @param content -- card content to be rendered that may contain embedded audio
+         * @return -- the same content but in a format that will render working play buttons when audio was embedded
+         */
+        fun expandSounds(soundDir: String, content: String): String {
+            if (!defaultLegacySchema) {
+                return addPlayIcons(content)
+            }
+            val stringBuilder = StringBuilder()
+            var contentLeft = content
+            Timber.d("expandSounds")
+            val matcher = SOUND_PATTERN.matcher(content)
+            // While there is matches of the pattern for sound markers
+            while (matcher.find()) {
+                // Get the sound file name
+                val sound = matcher.group(1)!!
+
+                // Construct the sound path
+                val soundPath = getSoundPath(soundDir, sound)
+
+                // Construct the new content, appending the substring from the beginning of the content left until the
+                // beginning of the sound marker
+                // and then appending the html code to add the play button
+                @Language("HTML")
+                val button =
+                    "<svg viewBox=\"0 0 64 64\"><circle cx=\"32\" cy=\"32\" r=\"29\" fill = \"lightgrey\"/>" +
+                        "<path d=\"M56.502,32.301l-37.502,20.101l0.329,-40.804l37.173,20.703Z\" fill = \"" +
+                        "black\"/>Replay</svg>"
+                val soundMarker = matcher.group()
+                val markerStart = contentLeft.indexOf(soundMarker)
+                stringBuilder.append(contentLeft.substring(0, markerStart))
+                // The <span> around the button (SVG or PNG image) is needed to make the vertical alignment work.
+                stringBuilder.append("<a class='replay-button replaybutton' href=\"playsound:")
+                    .append(soundPath).append("\">")
+                    .append("<span>").append(button)
+                    .append("</span></a>")
+                contentLeft = contentLeft.substring(markerStart + soundMarker.length)
+                Timber.v("Content left = %s", contentLeft)
             }
+
+            // unused code related to tts support taken out after v2.2alpha55
+            // if/when tts support is considered complete, these comment lines serve no purpose
+            stringBuilder.append(contentLeft)
+            return stringBuilder.toString()
+        }
+
+        /**
+         * @param soundDir -- base path to the media files.
+         * @param sound -- path to the sound file from the card content.
+         * @return absolute URI to the sound file.
+         */
+        fun getSoundPath(soundDir: String, sound: String): String {
+            val trimmedSound = sound.trim { it <= ' ' }
+            return if (hasURIScheme(trimmedSound)) {
+                trimmedSound
+            } else {
+                soundDir + Uri.encode(sound.trimEnd())
+            }
+        }
+
+        /**
+         * @param path -- path to the sound file from the card content.
+         * @return true if path is well-formed URI and contains URI scheme.
+         */
+        private fun hasURIScheme(path: String): Boolean {
+            val uriMatcher = sUriPattern.matcher(path.trim { it <= ' ' })
+            return uriMatcher.matches() && uriMatcher.group(2) != null
         }
-        return length
     }
+}
 
+interface SoundPlayer {
     /**
-     * Plays the given sound or video and sets playAllListener if available on media player to start next media.
-     * If videoView is null and the media is a video, then a request is sent to start the VideoPlayer Activity
+     * Plays the given sound or video.
+     * Video requires a surface: [hasVideoSurface]
+     * [playVideoExternallyCallback] will be called if this is unavailable
      */
     fun playSound(
         soundPath: String,
-        playAllListener: OnCompletionListener?,
-        videoView: VideoView?,
-        errorListener: OnErrorListener?
-    ) {
-        Timber.d("Playing single sound")
-        val completionListener = SingleSoundCompletionListener(playAllListener)
-        playSoundInternal(soundPath, completionListener, videoView, errorListener)
-    }
+        onCompletionListener: OnCompletionListener?,
+        errorListener: Sound.OnErrorListener?
+    )
 
-    /**
-     * Play or Pause the running sound. Called on pressing the content inside span tag.
-     */
-    @KotlinCleanup("?.let { }")
-    fun playOrPauseSound() {
-        mMediaPlayer ?: return
-        if (mMediaPlayer!!.isPlaying) {
-            mMediaPlayer!!.pause()
-        } else {
-            mMediaPlayer!!.start()
-        }
-    }
+    val hasVideoSurface: Boolean
 
     // When an audio finishes and I'm trying to replay it again, this method should check if the mMediaPlayer is null which means
     // the audio finished to return true, so that I would be able to play the same sound again.
-    @KotlinCleanup("simplify property with ?. ")
     val isCurrentAudioFinished: Boolean
+
+    /**
+     * The Uri of the currently playing audio (or `null` if no audio playing)
+     */
+    val currentAudioUri: String?
+
+    /**
+     * Stops the playing sounds.
+     */
+    fun stopSounds()
+
+    /**
+     * Play or Pause the running sound. Called on pressing the content inside span tag.
+     */
+    fun playOrPauseSound()
+
+    /** @return Whether the video was handled externally. Only used if [hasVideoSurface] is false */
+    var playVideoExternallyCallback: ((soundPath: String, onCompletion: OnCompletionListener) -> Boolean)?
+}
+
+open class SoundPlayerImpl : SoundPlayer {
+    override val currentAudioUri: String?
+        get() = mCurrentAudioUri?.toString()
+
+    override val isCurrentAudioFinished: Boolean
         get() = mMediaPlayer == null
 
     /**
-     * Plays a sound without ensuring that the playAllListener will release the audio
+     * Media player used to play the sounds. It's Nullable and that it is set only if a sound is playing or paused, otherwise it is null.
      */
-    @KotlinCleanup("remove timber - always true")
-    private fun playSoundInternal(
+    protected var mMediaPlayer: MediaPlayer? = null
+
+    private var mCurrentAudioUri: Uri? = null
+
+    /**
+     * AudioManager to request/release audio focus
+     */
+    private var mAudioManager: AudioManager? = null
+
+    private var mAudioFocusRequest: AudioFocusRequest? = null
+
+    override val hasVideoSurface: Boolean = false
+
+    /**
+     * Plays the given sound or video and sets playAllListener if available on media player to start next media.
+     * If videoView is null and the media is a video, then a request is sent to start the VideoPlayer Activity
+     */
+    override fun playSound(
         soundPath: String,
-        playAllListener: OnCompletionListener,
-        videoView: VideoView?,
-        errorListener: OnErrorListener?
+        onCompletionListener: OnCompletionListener?,
+        errorListener: Sound.OnErrorListener?
     ) {
-        Timber.d("Playing %s has listener? %b", soundPath, true)
-        val soundUri = Uri.parse(soundPath)
-        mCurrentAudioUri = soundUri
+        Timber.d("Playing single sound")
+        val completionListener = onCompletionListener ?: SingleSoundCompletionListener()
         val errorHandler = errorListener
-            ?: OnErrorListener { _: MediaPlayer?, what: Int, extra: Int, _: String? ->
+            ?: Sound.OnErrorListener { _: MediaPlayer?, what: Int, extra: Int, _: String? ->
                 Timber.w("Media Error: (%d, %d). Calling OnCompletionListener", what, extra)
                 CONTINUE_AUDIO
             }
-        if ("tts" == soundPath.substring(0, 3)) {
-            // TODO: give information about did
-//            ReadText.textToSpeech(soundPath.substring(4, soundPath.length()),
-//                    Integer.parseInt(soundPath.substring(3, 4)));
+        playSoundInternal(soundPath, completionListener, errorHandler)
+    }
+
+    /**
+     * Plays a sound without ensuring that the playAllListener will release the audio
+     */
+    private fun playSoundInternal(
+        soundPath: String,
+        completionListener: OnCompletionListener,
+        errorHandler: Sound.OnErrorListener
+    ) {
+        Timber.d("Playing %s", soundPath)
+        val soundUri = Uri.parse(soundPath)
+        mCurrentAudioUri = soundUri
+
+        val context = AnkiDroidApp.instance.applicationContext
+
+        val isVideo = isVideo(soundPath)
+        if (isVideo && !hasVideoSurface && playVideoExternallyCallback?.invoke(soundPath, completionListener) == true) {
             return
         }
-
+        // Play media
         fun playMedia() {
-            // Check if the file extension is that of a known video format
-            val extension =
-                soundPath.substring(soundPath.lastIndexOf(".") + 1).lowercase(Locale.getDefault())
-            var isVideo = listOf(*VIDEO_WHITELIST).contains(extension)
-            if (!isVideo) {
-                val guessedType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension)
-                isVideo = guessedType != null && guessedType.startsWith("video/")
-            }
-            // Also check that there is a video thumbnail, as some formats like mp4 can be audio only
-            isVideo = isVideo && hasVideoThumbnail(soundUri)
-            // No thumbnail: no video after all. (Or maybe not a video we can handle on the specific device.)
-            // If video file but no SurfaceHolder provided then ask AbstractFlashcardViewer to provide a VideoView
-            // holder
-            if (isVideo && videoView == null && mCallingActivity != null && mCallingActivity!!.get() != null) {
-                Timber.d("Requesting AbstractFlashcardViewer play video - no SurfaceHolder")
-                mediaCompletionListener = playAllListener
-                (mCallingActivity!!.get() as AbstractFlashcardViewer?)!!.playVideo(soundPath)
-                return
-            }
-            // Play media
             try {
                 // Create media player
                 if (mMediaPlayer == null) {
@@ -292,23 +410,15 @@ class Sound {
                     Timber.d("Resetting media for playback")
                     mMediaPlayer!!.reset()
                 }
-                if (mAudioManager == null) {
-                    mAudioManager = AnkiDroidApp.instance.applicationContext.getSystemService(
-                        Context.AUDIO_SERVICE
-                    ) as AudioManager
-                }
-                // Provide a VideoView to the MediaPlayer if valid video file
-                if (isVideo && videoView != null) {
-                    mMediaPlayer!!.setDisplay(videoView.holder)
-                    mMediaPlayer!!.setOnVideoSizeChangedListener { _: MediaPlayer?, width: Int, height: Int ->
-                        configureVideo(
-                            videoView,
-                            width,
-                            height
-                        )
-                    }
+                val mediaPlayer = mMediaPlayer!!
+                mAudioManager =
+                    mAudioManager ?: context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
+
+                if (isVideo) {
+                    prepareVideo(mediaPlayer)
                 }
-                mMediaPlayer!!.setOnErrorListener { mp: MediaPlayer?, which: Int, extra: Int ->
+
+                mediaPlayer.setOnErrorListener { mp: MediaPlayer?, which: Int, extra: Int ->
                     val errorHandling = errorHandler.onError(
                         mp,
                         which,
@@ -318,43 +428,43 @@ class Sound {
                     // returning false calls onComplete()
                     return@setOnErrorListener when (errorHandling) {
                         CONTINUE_AUDIO -> false
-                        OnErrorListener.ErrorHandling.RETRY_AUDIO -> {
+                        Sound.OnErrorListener.ErrorHandling.RETRY_AUDIO -> {
                             playMedia()
                             true
                         }
-                        OnErrorListener.ErrorHandling.STOP_AUDIO -> {
+                        Sound.OnErrorListener.ErrorHandling.STOP_AUDIO -> {
                             stopSounds()
                             true
                         }
                     }
                 }
                 // Setup the MediaPlayer
-                @KotlinCleanup("simplify with scope function on mediaPlayer")
-                mMediaPlayer!!.setDataSource(
-                    AnkiDroidApp.instance.applicationContext,
-                    soundUri
-                )
-                mMediaPlayer!!.setAudioAttributes(
+                mediaPlayer.setDataSource(context, soundUri)
+                mediaPlayer.setAudioAttributes(
                     AudioAttributes.Builder()
                         .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                         .build()
                 )
-                mMediaPlayer!!.setOnPreparedListener {
+                mediaPlayer.setOnPreparedListener {
                     Timber.d("Starting media player")
-                    mMediaPlayer!!.start()
+                    it.start()
                 }
-                mMediaPlayer!!.setOnCompletionListener(playAllListener)
-                mMediaPlayer!!.prepareAsync()
+                mediaPlayer.setOnCompletionListener(completionListener)
+                mediaPlayer.prepareAsync()
                 Timber.d("Requesting audio focus")
 
                 // Set mAudioFocusRequest for API 26 and above.
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                     mAudioFocusRequest =
                         AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
-                            .setOnAudioFocusChangeListener(afChangeListener)
+                            .setOnAudioFocusChangeListener(audioFocusChangeListener)
                             .build()
                 }
-                CompatHelper.compat.requestAudioFocus(mAudioManager!!, afChangeListener, mAudioFocusRequest)
+                CompatHelper.compat.requestAudioFocus(
+                    mAudioManager!!,
+                    audioFocusChangeListener,
+                    mAudioFocusRequest
+                )
             } catch (e: Exception) {
                 Timber.e(e, "playSounds - Error reproducing sound %s", soundPath)
                 when (
@@ -367,10 +477,10 @@ class Sound {
                 ) {
                     CONTINUE_AUDIO -> {
                         Timber.d("Force playing next sound.")
-                        playAllListener.onCompletion(mMediaPlayer)
+                        completionListener.onCompletion(mMediaPlayer)
                     }
-                    OnErrorListener.ErrorHandling.STOP_AUDIO -> stopSounds()
-                    OnErrorListener.ErrorHandling.RETRY_AUDIO -> playMedia()
+                    Sound.OnErrorListener.ErrorHandling.STOP_AUDIO -> stopSounds()
+                    Sound.OnErrorListener.ErrorHandling.RETRY_AUDIO -> playMedia()
                 }
             }
         }
@@ -378,65 +488,26 @@ class Sound {
         playMedia()
     }
 
-    @KotlinCleanup("simplify code with ?. or make uri non-null")
-    private fun hasVideoThumbnail(soundUri: Uri?): Boolean {
-        if (soundUri == null) {
-            return false
-        }
-        val path = soundUri.path ?: return false
-        return CompatHelper.compat.hasVideoThumbnail(path)
+    open fun prepareVideo(mediaPlayer: MediaPlayer) {
+        // in the base class: playVideoExternallyCallback should have been called
     }
 
-    val currentAudioUri: String?
-        get() = if (mCurrentAudioUri == null) {
-            null
-        } else {
-            mCurrentAudioUri.toString()
-        }
+    override var playVideoExternallyCallback: ((soundPath: String, onCompletion: OnCompletionListener) -> Boolean)? = null
 
-    fun notifyConfigurationChanged(videoView: VideoView) {
-        if (mMediaPlayer != null) {
-            configureVideo(videoView, mMediaPlayer!!.videoWidth, mMediaPlayer!!.videoHeight)
-        }
+    private fun isVideo(soundPath: String): Boolean {
+        // Check if the file extension is that of a known video format
+        val extension = soundPath.getFileExtension()
+        val isVideoExtension = listOf(*VIDEO_WHITELIST).contains(extension) || extension.isVideoMimeTypeExtension()
+        // Also check that there is a video thumbnail, as some formats like mp4 can be audio only
+        // No thumbnail: no video after all. (Or maybe not a video we can handle on the specific device.)
+        return isVideoExtension && CompatHelper.compat.hasVideoThumbnail(soundPath)
     }
 
-    /** #5414 - Ensures playing a single sound performs cleanup  */
-    private inner class SingleSoundCompletionListener(private val userCallback: OnCompletionListener?) :
-        OnCompletionListener {
-        override fun onCompletion(mp: MediaPlayer) {
-            Timber.d("Single Sound completed")
-            if (userCallback != null) {
-                userCallback.onCompletion(mp)
-            } else {
-                releaseSound()
-            }
-        }
-    }
-
-    /**
-     * Class used to play all sounds for a given card side
-     */
-    private inner class PlayAllCompletionListener(
-        /**
-         * Question/Answer
-         */
-        private val qa: SoundSide,
-        private val errorListener: OnErrorListener?
-    ) : OnCompletionListener {
-        /**
-         * next sound to play (onCompletion() is first called after the first (0) has been played)
-         */
-        private var mNextToPlay = 1
-        override fun onCompletion(mp: MediaPlayer) {
-            // If there is still more sounds to play for the current card, play the next one
-            if (mSoundPaths.containsKey(qa) && mNextToPlay < mSoundPaths[qa]!!.size) {
-                Timber.i("Play all: Playing next sound")
-                playSound(mSoundPaths[qa]!![mNextToPlay++], this, null, errorListener)
-            } else {
-                Timber.i("Play all: Completed - releasing sound")
-                releaseSound()
-            }
-        }
+    // TODO: This seems wrong
+    private fun String.getFileExtension() = substring(this.lastIndexOf(".") + 1).lowercase(Locale.getDefault())
+    private fun String.isVideoMimeTypeExtension(): Boolean {
+        val guessedType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(this) ?: return false
+        return guessedType.startsWith("video/")
     }
 
     /**
@@ -444,79 +515,48 @@ class Sound {
      */
     private fun releaseSound() {
         Timber.d("Releasing sounds and abandoning audio focus")
-        if (mMediaPlayer != null) {
+        mMediaPlayer?.let {
             // Required to remove warning: "mediaplayer went away with unhandled events"
             // https://stackoverflow.com/questions/9609479/android-mediaplayer-went-away-with-unhandled-events
-            mMediaPlayer!!.reset()
-            mMediaPlayer!!.release()
+            it.reset()
+            it.release()
             mMediaPlayer = null
         }
-        if (mAudioManager != null) {
+        mAudioManager?.let {
             // mAudioFocusRequest was initialised for API 26 and above in playSoundInternal().
-            CompatHelper.compat.abandonAudioFocus(mAudioManager!!, afChangeListener, mAudioFocusRequest)
+            CompatHelper.compat.abandonAudioFocus(it, audioFocusChangeListener, mAudioFocusRequest)
             mAudioManager = null
         }
     }
 
-    /**
-     * Stops the playing sounds.
-     */
-    fun stopSounds() {
-        if (mMediaPlayer != null) {
-            mMediaPlayer!!.stop()
+    override fun stopSounds() {
+        mMediaPlayer?.let {
+            it.stop()
+            // TODO: Inefficient. Determine whether we want to release or stop, don't do both
+            // Ensure `currentAudioUri` etc... still work when we do this
             releaseSound()
         }
-        ReadText.stopTts()
     }
 
-    /**
-     * Set the context for the calling activity (necessary for playing videos)
-     */
-    fun setContext(activityRef: WeakReference<Activity?>?) {
-        mCallingActivity = activityRef
-    }
-
-    fun hasQuestion(): Boolean {
-        return mSoundPaths.containsKey(SoundSide.QUESTION)
-    }
-
-    fun hasAnswer(): Boolean {
-        return mSoundPaths.containsKey(SoundSide.ANSWER)
+    override fun playOrPauseSound() {
+        mMediaPlayer?.let {
+            if (it.isPlaying) {
+                it.pause()
+            } else {
+                it.start()
+            }
+        }
     }
 
-    fun interface OnErrorListener {
-        fun onError(mp: MediaPlayer?, which: Int, extra: Int, path: String?): ErrorHandling
-
-        enum class ErrorHandling {
-            /** Stop playing audio */
-            STOP_AUDIO,
-
-            /** Continue to the next audio (if any) */
-            CONTINUE_AUDIO,
-
-            /** Retry the current audio */
-            RETRY_AUDIO
+    /** #5414 - Ensures playing a single sound performs cleanup  */
+    private inner class SingleSoundCompletionListener : OnCompletionListener {
+        override fun onCompletion(mp: MediaPlayer) {
+            Timber.d("Single Sound completed")
+            releaseSound()
         }
     }
 
     companion object {
-        /**
-         * Pattern used to identify the markers for sound files
-         */
-        val SOUND_PATTERN: Pattern = Pattern.compile("\\[sound:([^\\[\\]]*)]")
-
-        /**
-         * Pattern used to parse URI (according to http://tools.ietf.org/html/rfc3986#page-50)
-         */
-        private val sUriPattern =
-            Pattern.compile("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$")
-
-        /**
-         * OnCompletionListener so that external video player can notify to play next sound
-         */
-        var mediaCompletionListener: OnCompletionListener? = null
-            private set
-
         /**
          * Whitelist for video extensions
          */
@@ -525,113 +565,58 @@ class Sound {
         /**
          * Listener to handle audio focus. Currently blank because we're not respecting losing focus from other apps.
          */
-        private val afChangeListener = OnAudioFocusChangeListener { }
-
-        /** Extract SoundOrVideoTag instances from content where sound tags are in the form: [sound:filename.mp3]  */
-        @CheckResult
-        @KotlinCleanup("non-null param")
-        fun extractTagsFromLegacyContent(content: String?): List<SoundOrVideoTag> {
-            val matcher = SOUND_PATTERN.matcher(content!!)
-            // While there is matches of the pattern for sound markers
-            val ret: MutableList<SoundOrVideoTag> = ArrayList()
-            while (matcher.find()) {
-                // Get the sound file name
-                val sound = matcher.group(1)!!
-                ret.add(SoundOrVideoTag(sound))
-            }
-            return ret
-        }
-
-        /**
-         * expandSounds takes content with embedded sound file placeholders and expands them to reference the actual media
-         * file
-         *
-         * @param soundDir -- the base path of the media files
-         * @param content -- card content to be rendered that may contain embedded audio
-         * @return -- the same content but in a format that will render working play buttons when audio was embedded
-         */
-        fun expandSounds(soundDir: String, content: String): String {
-            if (!defaultLegacySchema) {
-                return addPlayIcons(content)
-            }
-            val stringBuilder = StringBuilder()
-            var contentLeft = content
-            Timber.d("expandSounds")
-            val matcher = SOUND_PATTERN.matcher(content)
-            // While there is matches of the pattern for sound markers
-            while (matcher.find()) {
-                // Get the sound file name
-                val sound = matcher.group(1)!!
-
-                // Construct the sound path
-                val soundPath = getSoundPath(soundDir, sound)
+        private val audioFocusChangeListener = OnAudioFocusChangeListener { }
+    }
+}
 
-                // Construct the new content, appending the substring from the beginning of the content left until the
-                // beginning of the sound marker
-                // and then appending the html code to add the play button
-                val button =
-                    "<svg viewBox=\"0 0 64 64\"><circle cx=\"32\" cy=\"32\" r=\"29\" fill = \"lightgrey\"/>" +
-                        "<path d=\"M56.502,32.301l-37.502,20.101l0.329,-40.804l37.173,20.703Z\" fill = \"" +
-                        "black\"/>Replay</svg>"
-                val soundMarker = matcher.group()
-                val markerStart = contentLeft.indexOf(soundMarker)
-                stringBuilder.append(contentLeft.substring(0, markerStart))
-                // The <span> around the button (SVG or PNG image) is needed to make the vertical alignment work.
-                stringBuilder.append("<a class='replay-button replaybutton' href=\"playsound:")
-                    .append(soundPath).append("\">")
-                    .append("<span>").append(button)
-                    .append("</span></a>")
-                contentLeft = contentLeft.substring(markerStart + soundMarker.length)
-                Timber.v("Content left = %s", contentLeft)
-            }
+class VideoPlayer(private val videoView: VideoView) : SoundPlayerImpl() {
 
-            // unused code related to tts support taken out after v2.2alpha55
-            // if/when tts support is considered complete, these comment lines serve no purpose
-            stringBuilder.append(contentLeft)
-            return stringBuilder.toString()
-        }
+    // don't call out to external video players
+    override val hasVideoSurface = true
 
-        private fun configureVideo(videoView: VideoView, videoWidth: Int, videoHeight: Int) {
-            // get the display
-            val context = AnkiDroidApp.instance.applicationContext
-            // adjust the size of the video so it fits on the screen
-            val videoProportion = videoWidth.toFloat() / videoHeight.toFloat()
-            val point = DisplayUtils.getDisplayDimensions(context)
-            val screenWidth = point.x
-            val screenHeight = point.y
-            val screenProportion = screenWidth.toFloat() / screenHeight.toFloat()
-            val lp = videoView.layoutParams
-            if (videoProportion > screenProportion) {
-                lp.width = screenWidth
-                lp.height = (screenWidth.toFloat() / videoProportion).toInt()
-            } else {
-                lp.width = (videoProportion * screenHeight.toFloat()).toInt()
-                lp.height = screenHeight
-            }
-            videoView.layoutParams = lp
+    /** Plays the given video */
+    fun play(
+        path: String,
+        onCompletionListener: OnCompletionListener?,
+        onErrorListener: Sound.OnErrorListener?
+    ) = playSound(path, onCompletionListener, onErrorListener)
+    fun notifyConfigurationChanged() {
+        mMediaPlayer?.let {
+            configureVideo(videoView, it.videoWidth, it.videoHeight)
         }
+    }
 
-        /**
-         * @param soundDir -- base path to the media files.
-         * @param sound -- path to the sound file from the card content.
-         * @return absolute URI to the sound file.
-         */
-        fun getSoundPath(soundDir: String, sound: String): String {
-            val trimmedSound = sound.trim { it <= ' ' }
-            return if (hasURIScheme(trimmedSound)) {
-                trimmedSound
-            } else {
-                soundDir + Uri.encode(sound.trimEnd())
-            }
+    override fun prepareVideo(mediaPlayer: MediaPlayer) {
+        mediaPlayer.setDisplay(videoView.holder)
+        mediaPlayer.setOnVideoSizeChangedListener { _, width: Int, height: Int ->
+            configureVideo(videoView, width, height)
         }
+    }
 
-        /**
-         * @param path -- path to the sound file from the card content.
-         * @return true if path is well-formed URI and contains URI scheme.
-         */
-        private fun hasURIScheme(path: String): Boolean {
-            val uriMatcher = sUriPattern.matcher(path.trim { it <= ' ' })
-            return uriMatcher.matches() && uriMatcher.group(2) != null
+    private fun configureVideo(videoView: VideoView, videoWidth: Int, videoHeight: Int) {
+        // get the display
+        val context = AnkiDroidApp.instance.applicationContext
+        // adjust the size of the video so it fits on the screen
+        val videoProportion = videoWidth.toFloat() / videoHeight.toFloat()
+        val point = DisplayUtils.getDisplayDimensions(context)
+        val screenWidth = point.x
+        val screenHeight = point.y
+        val screenProportion = screenWidth.toFloat() / screenHeight.toFloat()
+        val lp = videoView.layoutParams
+        if (videoProportion > screenProportion) {
+            lp.width = screenWidth
+            lp.height = (screenWidth.toFloat() / videoProportion).toInt()
+        } else {
+            lp.width = (videoProportion * screenHeight.toFloat()).toInt()
+            lp.height = screenHeight
         }
+        videoView.layoutParams = lp
     }
 }
+
+@Throws(Exception::class)
+private fun MediaMetadataRetriever.getDuration(context: Context, uri: Uri): Long {
+    this.setDataSource(context, uri)
+    val duration = this.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)
+    return duration!!.toLong()
+}
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerSoundRenderTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerSoundRenderTest.kt
index 49e9b9ef90dd..cec88ad419b6 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerSoundRenderTest.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/AbstractFlashcardViewerSoundRenderTest.kt
@@ -35,7 +35,7 @@ class AbstractFlashcardViewerSoundRenderTest : RobolectricTest() {
 
     /** Call this after a valid card has been added */
     private val sounds by lazy {
-        val ret = super.startRegularActivity<ReviewerSoundAccessor>()
+        val ret = super.startRegularActivity<Reviewer>()
         assertThat("activity was started before it had cards", ret.isDestroyed, equalTo(false))
         ret
     }
@@ -149,17 +149,7 @@ class AbstractFlashcardViewerSoundRenderTest : RobolectricTest() {
         addNoteUsingModelName("NoFrontSide", front, back)
     }
 
-    class ReviewerSoundAccessor : Reviewer() {
-        fun a(): ArrayList<String>? {
-            return super.mSoundPlayer.getSounds(Sound.SoundSide.ANSWER)
-        }
-
-        fun q(): ArrayList<String>? {
-            return super.mSoundPlayer.getSounds(Sound.SoundSide.QUESTION)
-        }
-
-        fun qa(): ArrayList<String>? {
-            return super.mSoundPlayer.getSounds(Sound.SoundSide.QUESTION_AND_ANSWER)
-        }
-    }
+    fun Reviewer.a() = mSoundPlayer.getSounds(Sound.SoundSide.ANSWER)
+    fun Reviewer.q() = mSoundPlayer.getSounds(Sound.SoundSide.QUESTION)
+    fun Reviewer.qa() = mSoundPlayer.getSounds(Sound.SoundSide.QUESTION_AND_ANSWER)
 }
