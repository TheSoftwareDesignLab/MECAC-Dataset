diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/RescheduleDialog.java b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/RescheduleDialog.java
index 91338f1a8b26..01245b6e64b7 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/RescheduleDialog.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/dialogs/RescheduleDialog.java
@@ -85,7 +85,7 @@ private static String getContentString(Resources resources, Card currentCard) {
         }
 
         String message = resources.getString(R.string.reschedule_card_dialog_warning_ease_reset, SchedV2.RESCHEDULE_FACTOR / 10);
-        if (currentCard.isDynamic()) {
+        if (currentCard.isInDynamicDeck()) {
             return message;
         }
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Card.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Card.java
index 13a68cad39d5..148701daa560 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Card.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Card.java
@@ -286,7 +286,7 @@ public HashMap<String, String> _getQA(boolean reload, boolean browser) {
             Note f = note(reload);
             Model m = model();
             JSONObject t = template();
-            long did = mODid != 0L ? mODid : mDid;
+            long did = isInDynamicDeck() ? mODid : mDid;
             if (browser) {
                 String bqfmt = t.getString("bqfmt");
                 String bafmt = t.getString("bafmt");
@@ -337,7 +337,7 @@ public void startTimer() {
      * Time limit for answering in milliseconds.
      */
     public int timeLimit() {
-        DeckConfig conf = mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid);
+        DeckConfig conf = mCol.getDecks().confForDid(!isInDynamicDeck() ? mDid : mODid);
         return conf.getInt("maxTaken") * 1000;
     }
 
@@ -605,7 +605,7 @@ public void setCol(Collection col) {
 
 
     public boolean showTimer() {
-        DeckConfig options = mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid);
+        DeckConfig options = mCol.getDecks().confForDid(!isInDynamicDeck() ? mDid : mODid);
         return DeckConfig.parseTimerOpt(options, true);
     }
 
@@ -694,7 +694,7 @@ public String getDueString() {
     private String nextDue() {
         long date;
         long due = getDue();
-        if (getODid() != 0) {
+        if (isInDynamicDeck()) {
             return AnkiDroidApp.getAppResources().getString(R.string.card_browser_due_filtered_card);
         } else if (getQueue() == Consts.QUEUE_TYPE_LRN) {
             date = due;
@@ -711,7 +711,7 @@ private String nextDue() {
     }
 
     /** Non libAnki */
-    public boolean isDynamic() {
+    public boolean isInDynamicDeck() {
         // In Anki Desktop, a card with oDue <> 0 && oDid == 0 is not marked as dynamic.
         return this.getODid() != 0;
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
index 046c441ac3a9..021f5120c3a8 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
@@ -50,7 +50,6 @@
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
-import androidx.sqlite.db.SupportSQLiteDatabase;
 import timber.log.Timber;
 
 
@@ -102,7 +101,7 @@ public void answerCard(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
             // init reps to graduation
             card.setLeft(_startingLeft(card));
             // dynamic?
-            if (card.getODid() != 0 && card.getType() == Consts.CARD_TYPE_REV) {
+            if (card.isInDynamicDeck() && card.getType() == Consts.CARD_TYPE_REV) {
                 if (_resched(card)) {
                     // reviews get their ivl boosted on first sight
                     card.setIvl(_dynIvlBoost(card));
@@ -162,7 +161,7 @@ public Queue countIdx(@NonNull Card card) {
     public int answerButtons(@NonNull Card card) {
         if (card.getODue() != 0) {
             // normal review in dyn deck?
-            if (card.getODid() != 0 && card.getQueue() == Consts.QUEUE_TYPE_REV) {
+            if (card.isInDynamicDeck() && card.getQueue() == Consts.QUEUE_TYPE_REV) {
                 return 4;
             }
             JSONObject conf = _lrnConf(card);
@@ -403,7 +402,7 @@ mDayCutoff, currentCardId(), mReportLimit)) {
     protected void _answerLrnCard(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
         JSONObject conf = _lrnConf(card);
         @Consts.CARD_TYPE int type;
-        if (card.getODid() != 0 && !card.getWasNew()) {
+        if (card.isInDynamicDeck() && !card.getWasNew()) {
             type = Consts.CARD_TYPE_RELEARNING;
         } else if (card.getType() == Consts.CARD_TYPE_REV) {
             type = Consts.CARD_TYPE_REV;
@@ -438,7 +437,7 @@ protected void _answerLrnCard(@NonNull Card card, @Consts.BUTTON_TYPE int ease)
                     // new card; no ivl adjustment
                     // pass
                 }
-                if (resched && card.getODid() != 0) {
+                if (resched && card.isInDynamicDeck()) {
                     card.setODue(mToday + 1);
                 }
             }
@@ -499,7 +498,7 @@ protected void _rescheduleAsRev(@NonNull Card card, @NonNull JSONObject conf, bo
         card.setType(Consts.CARD_TYPE_REV);
         // if we were dynamic, graduating means moving back to the old deck
         boolean resched = _resched(card);
-        if (card.getODid() != 0) {
+        if (card.isInDynamicDeck()) {
             card.setDid(card.getODid());
             card.setODue(0);
             card.setODid(0);
@@ -530,7 +529,7 @@ protected int _startingLeft(@NonNull Card card) {
     private int _graduatingIvl(@NonNull Card card, @NonNull JSONObject conf, boolean early, boolean adj) {
         if (card.getType() == Consts.CARD_TYPE_REV) {
             // lapsed card being relearnt
-            if (card.getODid() != 0) {
+            if (card.isInDynamicDeck()) {
                 if (conf.getBoolean("resched")) {
                     return _dynIvlBoost(card);
                 }
@@ -765,7 +764,7 @@ protected int _rescheduleLapse(@NonNull Card card) {
             card.setFactor(Math.max(1300, card.getFactor() - 200));
             card.setDue(mToday + card.getIvl());
             // if it's a filtered deck, update odue as well
-            if (card.getODid() != 0) {
+            if (card.isInDynamicDeck()) {
                 card.setODue(card.getDue());
             }
         }
@@ -816,7 +815,7 @@ private void _rescheduleRev(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
         } else {
             card.setDue(card.getODue());
         }
-        if (card.getODid() != 0) {
+        if (card.isInDynamicDeck()) {
             card.setDid(card.getODid());
             card.setODid(0);
             card.setODue(0);
@@ -969,7 +968,7 @@ private void _moveToDyn(long did, @NonNull List<Long> ids) {
 
 
     private int _dynIvlBoost(@NonNull Card card) {
-        if (card.getODid() == 0 || card.getType() != Consts.CARD_TYPE_REV || card.getFactor() == 0) {
+        if (!card.isInDynamicDeck() || card.getType() != Consts.CARD_TYPE_REV || card.getFactor() == 0) {
             Timber.e("error: deck is not a filtered deck");
             return 0;
         }
@@ -1004,7 +1003,7 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
                 if (card.getODue() != 0) {
                     card.setDue(card.getODue());
                 }
-                if (card.getODid() != 0) {
+                if (card.isInDynamicDeck()) {
                     card.setDid(card.getODid());
                 }
                 card.setODue(0);
@@ -1029,8 +1028,7 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
     @Override
     protected @NonNull JSONObject _newConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        // normal deck
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             return conf.getJSONObject("new");
         }
         // dynamic deck; override some attributes, use original deck for others
@@ -1056,8 +1054,7 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
     @Override
     protected @NonNull JSONObject _lapseConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        // normal deck
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             return conf.getJSONObject("lapse");
         }
         // dynamic deck; override some attributes, use original deck for others
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
index 2f06b7d747b1..86aa30baaa34 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
@@ -404,7 +404,7 @@ public Queue countIdx(@NonNull Card card) {
      * Overridden */
     public int answerButtons(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        if (card.getODid() != 0 && !conf.getBoolean("resched")) {
+        if (card.isInDynamicDeck() && !conf.getBoolean("resched")) {
             return 2;
         }
         return 4;
@@ -1342,7 +1342,7 @@ protected void _rescheduleAsRev(@NonNull Card card, @NonNull JSONObject conf, bo
             _rescheduleNew(card, conf, early);
         }
         // if we were dynamic, graduating means moving back to the old deck
-        if (card.getODid() != 0) {
+        if (card.isInDynamicDeck()) {
             _removeFromFiltered(card);
         }
     }
@@ -1656,7 +1656,7 @@ public int totalRevForCurrentDeck() {
     // Overridden: v1 does not deal with early
     protected void _answerRevCard(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
         int delay = 0;
-        boolean early = card.getODid() != 0 && (card.getODue() > mToday);
+        boolean early = card.isInDynamicDeck() && (card.getODue() > mToday);
         int type = early ? 3 : 1;
         if (ease == Consts.BUTTON_ONE) {
             delay = _rescheduleLapse(card);
@@ -1799,7 +1799,7 @@ protected int _constrainedIvl(double ivl, @NonNull JSONObject conf, double prev,
      * Number of days later than scheduled.
      */
     protected long _daysLate(Card card) {
-        long due = card.getODid() != 0 ? card.getODue() : card.getDue();
+        long due = card.isInDynamicDeck() ? card.getODue() : card.getDue();
         return Math.max(0, mToday - due);
     }
 
@@ -1817,7 +1817,7 @@ private void _updateEarlyRevIvl(@NonNull Card card, @Consts.BUTTON_TYPE int ease
 
     /** next interval for card when answered early+correctly */
     private int _earlyReviewIvl(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
-        if (card.getODid() == 0 || card.getType() != Consts.CARD_TYPE_REV || card.getFactor() == 0) {
+        if (!card.isInDynamicDeck() || card.getType() != Consts.CARD_TYPE_REV || card.getFactor() == 0) {
             throw new RuntimeException("Unexpected card parameters");
         }
         if (ease <= 1) {
@@ -2013,7 +2013,7 @@ protected void _moveToDyn(long did, @NonNull List<Long> ids, int start) {
 
 
     private void _removeFromFiltered(@NonNull Card card) {
-        if (card.getODid() != 0) {
+        if (card.isInDynamicDeck()) {
             card.setDid(card.getODid());
             card.setODue(0);
             card.setODid(0);
@@ -2022,7 +2022,7 @@ private void _removeFromFiltered(@NonNull Card card) {
 
 
     private void _restorePreviewCard(@NonNull Card card) {
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             throw new RuntimeException("ODid wasn't set");
         }
 
@@ -2087,8 +2087,7 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
     // Overridden: different delays for filtered cards.
     protected @NonNull JSONObject _newConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        // normal deck
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             return conf.getJSONObject("new");
         }
         // dynamic deck; override some attributes, use original deck for others
@@ -2110,8 +2109,7 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
     // Overridden: different delays for filtered cards.
     protected @NonNull JSONObject _lapseConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        // normal deck
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             return conf.getJSONObject("lapse");
         }
         // dynamic deck; override some attributes, use original deck for others
@@ -2131,11 +2129,9 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
 
     protected @NonNull JSONObject _revConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
-        // normal deck
-        if (card.getODid() == 0) {
+        if (!card.isInDynamicDeck()) {
             return conf.getJSONObject("rev");
         }
-        // dynamic deck
         return mCol.getDecks().confForDid(card.getODid()).getJSONObject("rev");
     }
 
@@ -2393,7 +2389,7 @@ protected long nextIvl(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
             return _lapseIvl(card, conf) * SECONDS_PER_DAY;
         } else {
             // review
-            boolean early = card.getODid() != 0 && (card.getODue() > mToday);
+            boolean early = card.isInDynamicDeck() && (card.getODue() > mToday);
             if (early) {
                 return _earlyReviewIvl(card, ease) * SECONDS_PER_DAY;
             } else {
