diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ModelBrowser.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ModelBrowser.kt
index a31f1395a9a4..8efc10a4dccc 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ModelBrowser.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ModelBrowser.kt
@@ -16,6 +16,7 @@
  ****************************************************************************************/
 package com.ichi2.anki
 
+import android.annotation.SuppressLint
 import android.content.Context
 import android.content.Intent
 import android.os.Bundle
@@ -27,6 +28,8 @@ import androidx.activity.result.contract.ActivityResultContracts
 import androidx.appcompat.app.ActionBar
 import com.afollestad.materialdialogs.MaterialDialog
 import com.afollestad.materialdialogs.customview.customView
+import com.afollestad.materialdialogs.input.input
+import com.afollestad.materialdialogs.list.listItemsSingleChoice
 import com.ichi2.anim.ActivityTransitionAnimation
 import com.ichi2.anki.CollectionManager.withCol
 import com.ichi2.anki.UIUtils.showThemedToast
@@ -64,14 +67,11 @@ class ModelBrowser : AnkiActivity() {
     private var mCardCounts: ArrayList<Int>? = null
     private var mModelIds: ArrayList<Long>? = null
     private var mModelDisplayList: ArrayList<DisplayPair>? = null
-    private var mNewModelLabels: ArrayList<String>? = null
-    private var mExistingModelNames: ArrayList<String>? = null
     private lateinit var mCol: Collection
     private var mActionBar: ActionBar? = null
 
     // Dialogue used in renaming
     private var modelNameInput: EditText? = null
-    private var mNewModelNames: ArrayList<String>? = null
 
     private var loadModelsJob: Job? = null
 
@@ -126,7 +126,7 @@ class ModelBrowser : AnkiActivity() {
                 return true
             }
             R.id.action_add_new_note_type -> {
-                addNewNoteTypeDialog()
+                showAddNewNoteTypeDialog()
                 return true
             }
         }
@@ -217,103 +217,93 @@ class ModelBrowser : AnkiActivity() {
         mActionBar!!.subtitle = resources.getQuantityString(R.plurals.model_browser_types_available, count, count)
     }
 
-    /*
-     *Creates the dialogue box to select a note type, add a name, and then clone it
+    /**
+     *   * Shows a single choice dialog titled “Add note type” with items such as:
+     *     * Add: Basic
+     *     * Add: Basic (type in the answer)
+     *     * ...
+     *     * Clone: Vocabulary
+     *
+     *   * When user selects one of these and presses Ok,
+     *     shows a text input dialog with the same title and a suggested name
+     *     such as “Basic”, “Vocabulary copy” or “Basic-ce43a”.
+     *
+     *   * When user Okays the new name, a new model with the provided name is created
+     *     based on the previously selected model.
      */
-    private fun addNewNoteTypeDialog() {
-        initializeNoteTypeList()
-        val addSelectionSpinner = Spinner(this)
-        val newModelAdapter = ArrayAdapter(this, R.layout.dropdown_deck_item, mNewModelLabels!!.toList())
-        addSelectionSpinner.adapter = newModelAdapter
-        MaterialDialog(this).show {
-            customView(view = addSelectionSpinner, scrollable = true, horizontalPadding = true)
-            title(R.string.model_browser_add)
-            positiveButton(R.string.dialog_ok) {
-                modelNameInput = FixedEditText(this@ModelBrowser)
-                modelNameInput?.let { modelNameEditText ->
-                    modelNameEditText.setSingleLine()
-                    val isStdModel = addSelectionSpinner.selectedItemPosition < mNewModelLabels!!.size
-                    // Try to find a unique model name. Add "clone" if cloning, and random digits if necessary.
-                    var suggestedName = mNewModelNames!![addSelectionSpinner.selectedItemPosition]
-                    if (!isStdModel) {
-                        suggestedName += " " + resources.getString(R.string.model_clone_suffix)
-                    }
-                    if (mExistingModelNames!!.contains(suggestedName)) {
-                        suggestedName = randomizeName(suggestedName)
-                    }
-                    modelNameEditText.setText(suggestedName)
-                    modelNameEditText.setSelection(modelNameEditText.text.length)
-
-                    // Create textbox to name new model
-                    MaterialDialog(this@ModelBrowser).show {
-                        customView(view = modelNameEditText, scrollable = true)
-                        title(R.string.model_browser_add)
-                        positiveButton(R.string.dialog_ok) {
-                            val modelName = modelNameEditText.text.toString()
-                            addNewNoteType(modelName, addSelectionSpinner.selectedItemPosition)
-                        }
-                        negativeButton(R.string.dialog_cancel)
-                        displayKeyboard(modelNameEditText)
-                    }
-                }
+    @SuppressLint("CheckResult") // listItemsSingleChoice() is annotated with @CheckResult ¯\_(ツ)_/¯
+    private fun showAddNewNoteTypeDialog() {
+        val addTemplate = resources.getString(R.string.model_browser_add_add)
+        val cloneTemplate = resources.getString(R.string.model_browser_add_clone)
+
+        open class ModelInfo(val name: String, val label: String)
+        class StandardModelInfo(val model: StdModels, name: String, label: String) : ModelInfo(name, label)
+        class UserModelInfo(val model: Model, name: String, label: String) : ModelInfo(name, label)
+
+        val infos = sequence {
+            StdModels.STD_MODELS.forEach { model ->
+                val name = model.defaultName
+                val label = String.format(addTemplate, name)
+                yield(StandardModelInfo(model, name, label))
+            }
+
+            mModels!!.forEach { model ->
+                val name = model.getString("name")
+                val label = String.format(cloneTemplate, name)
+                yield(UserModelInfo(model, name, label))
+            }
+        }.toList()
+
+        // TODO Instead of appending " copy", a string template should be used instead.
+        fun ModelInfo.makeSuggestedName(): String {
+            val suggestion = when (this) {
+                is StandardModelInfo -> name
+                else -> name + " " + resources.getString(R.string.model_clone_suffix)
             }
-            negativeButton(R.string.dialog_cancel)
+
+            val alreadyExists = infos.any { it is UserModelInfo && it.name == suggestion }
+
+            return if (alreadyExists) randomizeName(suggestion) else suggestion
         }
-    }
 
-    /**
-     * Add a new note type
-     * @param modelName name of the new model
-     * @param position position in dialog the user selected to add / clone the model type from
-     */
-    @KotlinCleanup("Use scope function while initializing oldModel + Invert and return early")
-    private fun addNewNoteType(modelName: String, position: Int) {
-        val model: Model
-        if (modelName.isNotEmpty()) {
-            val nbStdModels = StdModels.STD_MODELS.size
-            model = if (position < nbStdModels) {
-                StdModels.STD_MODELS[position].add(mCol)
+        // TODO This will happily accept names that already exist in the user model list.
+        //   If duplicate names are not undesirable, add a comment stating so.
+        fun addNewModel(sourceModelInfo: ModelInfo, newName: String) {
+            if (newName.isEmpty()) {
+                showToast(resources.getString(R.string.toast_empty_name))
+                return
+            }
+
+            val newModel = if (sourceModelInfo is StandardModelInfo) {
+                sourceModelInfo.model.add(mCol)
             } else {
-                // New model
-                // Model that is being cloned
-                val oldModel = mModels!![position - nbStdModels].deepClone()
-                val newModel = StdModels.BASIC_MODEL.add(mCol)
-                oldModel.put("id", newModel.getLong("id"))
-                oldModel
+                sourceModelInfo as UserModelInfo // Kotlin does not yet support sealed local classes
+                sourceModelInfo.model.deepClone().apply {
+                    put("id", StdModels.BASIC_MODEL.add(mCol).getLong("id"))
+                }
             }
-            model.put("name", modelName)
-            mCol.models.update(model)
+
+            newModel.put("name", newName)
+            mCol.models.update(newModel)
             fullRefresh()
-        } else {
-            showToast(resources.getString(R.string.toast_empty_name))
         }
-    }
 
-    /*
-     * retrieve list of note type in variable, which will going to be in use for adding/cloning note type
-     */
-    private fun initializeNoteTypeList() {
-        val add = resources.getString(R.string.model_browser_add_add)
-        val clone = resources.getString(R.string.model_browser_add_clone)
-
-        // Populates array adapters listing the mModels (includes prefixes/suffixes)
-        val existingModelSize = mModels!!.size
-        val stdModelSize = StdModels.STD_MODELS.size
-        mNewModelLabels = ArrayList(existingModelSize + stdModelSize)
-        mExistingModelNames = ArrayList(existingModelSize)
-
-        // Used to fetch model names
-        mNewModelNames = ArrayList(stdModelSize)
-        for (StdModels in StdModels.STD_MODELS) {
-            val defaultName = StdModels.defaultName
-            mNewModelLabels!!.add(String.format(add, defaultName))
-            mNewModelNames!!.add(defaultName)
-        }
-        for (model in mModels!!) {
-            val name = model.getString("name")
-            mNewModelLabels!!.add(String.format(clone, name))
-            mNewModelNames!!.add(name)
-            mExistingModelNames!!.add(name)
+        // TODO These dialogs are slightly confusing.
+        //   The first one says “Add note type ... Ok”, but it doesn't add anything straight away.
+        //   The second one also says “Add note type ... Ok”, and it is not mention the model
+        //   that you are cloning. I suggest reworking the strings so this is less confusing.
+        MaterialDialog(this).show {
+            title(R.string.model_browser_add)
+            positiveButton(R.string.dialog_ok)
+            listItemsSingleChoice(items = infos.map { it.label }) { _, index, _ ->
+                MaterialDialog(this@ModelBrowser).show {
+                    title(R.string.model_browser_add)
+                    positiveButton(R.string.dialog_ok)
+                    input(prefill = infos[index].makeSuggestedName()) { _, text ->
+                        addNewModel(infos[index], text.toString())
+                    }
+                }
+            }
         }
     }
 
@@ -348,7 +338,6 @@ class ModelBrowser : AnkiActivity() {
      * Displays a confirmation box asking if you want to rename the note type and then renames it if confirmed
      */
     private fun renameModelDialog() {
-        initializeNoteTypeList()
         modelNameInput = FixedEditText(this)
         modelNameInput?.let { modelNameEditText ->
             modelNameEditText.isSingleLine = true
@@ -360,15 +349,15 @@ class ModelBrowser : AnkiActivity() {
                 title(R.string.rename_model)
                 positiveButton(R.string.rename) {
                     val model = mModels!![mModelListPosition]
-                    var deckName = modelNameEditText.text.toString() // Anki desktop doesn't allow double quote characters in deck names
+                    var name = modelNameEditText.text.toString() // Anki desktop doesn't allow double quote characters in deck names
                         .replace("[\"\\n\\r]".toRegex(), "")
-                    if (mExistingModelNames!!.contains(deckName)) {
-                        deckName = randomizeName(deckName)
+                    if (mModels!!.any { it.getString("name") == name }) {
+                        name = randomizeName(name)
                     }
-                    if (deckName.isNotEmpty()) {
-                        model.put("name", deckName)
+                    if (name.isNotEmpty()) {
+                        model.put("name", name)
                         mCol.models.update(model)
-                        mModels!![mModelListPosition].put("name", deckName)
+                        mModels!![mModelListPosition].put("name", name)
                         mModelDisplayList!![mModelListPosition] = DisplayPair(
                             mModels!![mModelListPosition].getString("name"),
                             mCardCounts!![mModelListPosition]
