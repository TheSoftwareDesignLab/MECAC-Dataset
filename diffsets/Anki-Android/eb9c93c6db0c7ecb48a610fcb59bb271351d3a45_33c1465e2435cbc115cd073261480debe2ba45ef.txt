diff --git a/src/com/ichi2/anki/DeckManager.java b/src/com/ichi2/anki/DeckManager.java
index 74109ba72eb9..5c5a595d62e1 100644
--- a/src/com/ichi2/anki/DeckManager.java
+++ b/src/com/ichi2/anki/DeckManager.java
@@ -139,8 +139,6 @@ public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck,
         					deckInformation.mDeck = Deck.openDeck(deckpath, true, requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
         					deckInformation.mInitiallyRebuilt = true;
         					WidgetStatus.update(AnkiDroidApp.getInstance().getBaseContext(), WidgetStatus.getDeckStatus(deck));
-            		} else {
-            			deckInformation.mDeck.reset();
             		}
                 }
 			} else {
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
index 8487470ffc36..92a303db6f2a 100644
--- a/src/com/ichi2/anki/DeckTask.java
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -314,11 +314,10 @@ private TaskData doInBackgroundAnswerCard(TaskData... params) {
 	            if (oldCard != null) {
 	                deck.answerCard(oldCard, ease);
 	                Log.i(AnkiDroidApp.TAG, "leech flag: " + oldCard.getLeechFlag());
-
+	            } else if (DeckManager.deckIsOpenedInBigWidget(deck.getDeckPath())) {
 	                // first card in reviewer is retrieved
-	                if (DeckManager.deckIsOpenedInBigWidget(deck.getDeckPath())) {
-	                	newCard = AnkiDroidWidgetBig.getCard();
-	                }
+	            	Log.i(AnkiDroidApp.TAG, "doInBackgroundAnswerCard: get card from big widget");
+                	newCard = AnkiDroidWidgetBig.getCard();
 	            }
 	            if (newCard == null) {
 		            newCard = deck.getCard();	            	
@@ -343,7 +342,9 @@ private TaskData doInBackgroundAnswerCard(TaskData... params) {
 
     private TaskData doInBackgroundLoadDeck(TaskData... params) {
         String deckFilename = params[0].getString();
-        Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
+        int requestingActivity = params[0].getInt();
+
+        Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename + ", requesting activity = " + requestingActivity);
 
         Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();
 
@@ -362,7 +363,7 @@ private TaskData doInBackgroundLoadDeck(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
 
     	// load deck and set it as main deck
-        Deck deck = DeckManager.getDeck(deckFilename, params[0].getBoolean(), DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+        Deck deck = DeckManager.getDeck(deckFilename, requestingActivity == DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, requestingActivity);
         if (deck == null) {
             Log.i(AnkiDroidApp.TAG, "The database " + deckFilename + " could not be opened");
             BackupManager.cleanUpAfterBackupCreation(false);
@@ -703,7 +704,8 @@ private TaskData doInBackgroundRestoreDeck(TaskData... params) {
 
     private TaskData doInBackgroundSortCards(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundSortCards");
-		Collections.sort(params[0].getCards(), params[0].getComparator());
+        Comparator<? super HashMap<String, String>> comparator = params[0].getComparator();
+		Collections.sort(params[0].getCards(), comparator);
 		return null;
     }
 
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 630f943a96c8..96118eaaf4ca 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -103,10 +103,12 @@ public class Reviewer extends Activity implements IButtonListener{
     /**
      * Result codes that are returned when this activity finishes.
      */
-    public static final int RESULT_SESSION_COMPLETED = 1;
-    public static final int RESULT_NO_MORE_CARDS = 2;
-    public static final int RESULT_EDIT_CARD_RESET = 3;
-    public static final int RESULT_ANSWERING_ERROR = 4;
+    public static final int RESULT_DEFAULT = 50;
+    public static final int RESULT_SESSION_COMPLETED = 51;
+    public static final int RESULT_NO_MORE_CARDS = 52;
+    public static final int RESULT_EDIT_CARD_RESET = 53;
+    public static final int RESULT_ANSWERING_ERROR = 54;
+    public static final int RESULT_DECK_CLOSED = 55;
 
     /**
      * Possible values for update card handler
@@ -586,8 +588,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
         public void onPostExecute(DeckTask.TaskData result) {
             if (!result.getBoolean()) {
             	// RuntimeException occured on marking cards
-                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
-                closeReviewer(true);
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
             }
             mProgressDialog.dismiss();
         }
@@ -615,18 +616,16 @@ public void onPostExecute(DeckTask.TaskData result) {
             if (!result.getBoolean()) {
             	// RuntimeException occured on dismissing cards
                 Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
-                closeReviewer(true);
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
                 return;
             }
             // Check for no more cards before session complete. If they are both true,
             // no more cards will take precedence when returning to study options.
             if (mNoMoreCards) {
-                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                 mShowCongrats = true;
-                closeReviewer(true);
+                closeReviewer(RESULT_NO_MORE_CARDS, true);
             } else if (mSessionComplete) {
-                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
-                closeReviewer(true);
+                closeReviewer(RESULT_SESSION_COMPLETED, true);
             }
         }
     };
@@ -675,8 +674,7 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
         public void onPostExecute(DeckTask.TaskData result) {
             if (!result.getBoolean()) {
             	// RuntimeException occured on update cards
-                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
-                closeReviewer(true);
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
                 return;
             }
             mShakeActionStarted = false;
@@ -718,19 +716,16 @@ public void onProgressUpdate(DeckTask.TaskData... values) {
         public void onPostExecute(DeckTask.TaskData result) {
             if (!result.getBoolean()) {
             	// RuntimeException occured on answering cards
-                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
-                closeReviewer(true);
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
                 return;
             }
             // Check for no more cards before session complete. If they are both true,
             // no more cards will take precedence when returning to study options.
             if (mNoMoreCards) {
-                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                 mShowCongrats = true;
-                closeReviewer(true);
+                closeReviewer(RESULT_NO_MORE_CARDS, true);
             } else if (mSessionComplete) {
-                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
-                closeReviewer(true);
+                closeReviewer(RESULT_SESSION_COMPLETED, true);
             }
         }
     };
@@ -822,7 +817,7 @@ public void handleMessage(Message msg){
 	            }
 				break;
 			case MSG_ZEEMOTE_BUTTON_B:
-				closeReviewer(false);
+				closeReviewer(RESULT_DEFAULT, false);
 				break;
 			case MSG_ZEEMOTE_BUTTON_C:
 				if (DeckManager.getMainDeck().undoAvailable()){
@@ -863,8 +858,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // Make sure a deck is loaded before continuing.
         Deck deck = DeckManager.getMainDeck();
         if (deck == null) {
-            setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
-			finish();
+        	finishNoStorageAvailable();
 			return;
         } else {
             mMediaDir = setupMedia(deck);
@@ -973,12 +967,15 @@ protected void onResume() {
       super.onResume();
       Deck deck = DeckManager.getMainDeck();
       if (deck == null) {
-    	  finish();
+    	  Log.e(AnkiDroidApp.TAG, "Reviewer: Deck already closed, returning to study options");
+    	  closeReviewer(RESULT_DECK_CLOSED, false);
+    	  return;
       }
 
-      // check if deck is already opened in big widget. If yes, reload card (to make sure it's not answered yet) and close it in widget
-      if (DeckManager.mainIsOpenedInBigWidget()) {
-//	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(0, deck, null));
+      // check if deck is already opened in big widget. If yes, reload card (to make sure it's not answered yet)
+      if (DeckManager.deckIsOpenedInBigWidget(deck.getDeckPath()) && mCurrentCard != null) {
+    	  Log.i(AnkiDroidApp.TAG, "Reviewer: onResume: get card from big widget");
+    	  DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(0, deck, null));
       } else {
     	  restartTimer();
       }
@@ -1009,10 +1006,11 @@ protected void onStop() {
           if (deck != null) {
 	         	deck.commitToDB();
           }
-      }
-      if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
-    	  AnkiDroidWidgetBig.setCard(mCurrentCard);
-    	  AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_SHOW_QUESTION);
+          if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
+        	  Log.i(AnkiDroidApp.TAG, "Reviewer: onStop: updating big widget");
+        	  AnkiDroidWidgetBig.setCard(mCurrentCard);
+        	  AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_SHOW_QUESTION);
+          }
       }
       WidgetStatus.update(this, WidgetStatus.getDeckStatus(deck));
     }
@@ -1034,7 +1032,7 @@ protected void onDestroy() {
     public boolean onKeyDown(int keyCode, KeyEvent event)  {
         if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
         	Log.i(AnkiDroidApp.TAG, "Reviewer - onBackPressed()");
-        	closeReviewer(false);
+        	closeReviewer(RESULT_DEFAULT, false);
         	return true;
         }
          /** Enhancement 722: Hardware buttons for scrolling, I.Z. */
@@ -1413,8 +1411,7 @@ private void setLanguage(String language) {
 
 
     private void finishNoStorageAvailable() {
-        setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
-        closeReviewer(false);
+        closeReviewer(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE, false);
     }
 
 
@@ -2260,8 +2257,7 @@ private void updateCard(String content) {
             Model myModel = Model.getModel(currentDeck, mCurrentCard.getCardModelId(), false);
 		if (myModel == null) {
 			Log.e(AnkiDroidApp.TAG, "updateCard - no Model could be fetched. Closing Reviewer and showing db-error dialog");
-	                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
-	                closeReviewer(true);			
+	                closeReviewer(RESULT_ANSWERING_ERROR, true);			
 		}
             mBaseUrl = Utils.getBaseUrl(mMediaDir, myModel, currentDeck);
             int nightBackground = Themes.getNightModeCardBackground(this);
@@ -3004,7 +3000,7 @@ private void executeCommand(int which) {
 			}
     		break;
     	case GESTURE_EXIT:
-       	 	closeReviewer(false);
+       	 	closeReviewer(RESULT_DEFAULT, false);
     		break;
     	case GESTURE_UNDO:
     		if (DeckManager.getMainDeck().undoAvailable()) {
@@ -3093,17 +3089,24 @@ private String nextInterval(int ease) {
     }
 
 
-    private void closeReviewer(boolean saveDeck) {
-	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
-	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
-	mTimerHandler.removeCallbacks(removeChosenAnswerText);
-	longClickHandler.removeCallbacks(longClickTestRunnable);
-	longClickHandler.removeCallbacks(startLongClickAction);
+    private void closeReviewer(int result, boolean saveDeck) {
+    	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
+		mTimeoutHandler.removeCallbacks(mShowQuestionTask);
+		mTimerHandler.removeCallbacks(removeChosenAnswerText);
+		longClickHandler.removeCallbacks(longClickTestRunnable);
+		longClickHandler.removeCallbacks(startLongClickAction);
+
+		Reviewer.this.setResult(result);
 
-    	setOutAnimation(true);    		
+		setOutAnimation(true);    		
     	if (saveDeck) {
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(DeckManager.getMainDeck(), 0));
     	} else {
+            if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
+          	  Log.i(AnkiDroidApp.TAG, "Reviewer: closeReviewer: updating big widget");
+          	  AnkiDroidWidgetBig.setCard(mCurrentCard);
+          	  AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_SHOW_QUESTION);
+            }
     		finish();
     	}
     }
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 19bfd077296c..6ff762ff5df9 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -69,6 +69,7 @@
 import com.ichi2.compat.CompatV3;
 import com.ichi2.themes.StyledDialog;
 import com.ichi2.themes.Themes;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 import com.zeemote.zc.Controller;
 import com.zeemote.zc.event.ButtonEvent;
@@ -934,7 +935,7 @@ private void openReviewer() {
     		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
             reviewer.putExtra("deckFilename", mDeckFilename);
     		startActivityForResult(reviewer, REQUEST_REVIEW);
-        	if (getApiLevel() > 4) {
+        	if (getApiLevel() > 4 && !mStartedByBigWidget) {
        			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
         	}
     	} else if (mCurrentContentView == CONTENT_CONGRATS) {
@@ -2150,7 +2151,7 @@ private void openDeckPicker() {
         Intent decksPicker = new Intent(StudyOptions.this, DeckPicker.class);
         mInDeckPicker = true;
         startActivityForResult(decksPicker, PICK_DECK_REQUEST);
-    	if (getApiLevel() > 4) {
+    	if (getApiLevel() > 4 && !mStartedByBigWidget) {
     		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
     	}
         // Log.i(AnkiDroidApp.TAG, "openDeckPicker - Ending");
@@ -2259,7 +2260,7 @@ private void syncDeck(String conflictResolution) {
     protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
         super.onActivityResult(requestCode, resultCode, intent);
 
-        if (mStartedByBigWidget && (requestCode == REQUEST_REVIEW || (requestCode == PICK_DECK_REQUEST && resultCode != RESULT_OK))) {
+        if (mStartedByBigWidget && ((requestCode == REQUEST_REVIEW && resultCode == Reviewer.RESULT_DEFAULT) || (requestCode == PICK_DECK_REQUEST && resultCode != RESULT_OK))) {
         	DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
         	finish();
         	return;
@@ -2326,7 +2327,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent intent)
             // Log.i(AnkiDroidApp.TAG, "onActivityResult - deckSelected = " + deckSelected);
             if (DeckManager.getMainDeck() == null || !DeckManager.getMainDeckPath().equals(mDeckFilename)) {
                 boolean updateAllCards = (requestCode == DOWNLOAD_SHARED_DECK);
-                displayProgressDialogAndLoadDeck(updateAllCards);	
+                displayProgressDialogAndLoadDeck(updateAllCards);
             }
         } else if (requestCode == PREFERENCES_UPDATE) {
             restorePreferences();
@@ -2358,7 +2359,12 @@ protected void onActivityResult(int requestCode, int resultCode, Intent intent)
                 	showContentView(CONTENT_STUDY_OPTIONS);
                 	showDialog(DIALOG_DB_ERROR);
                     break;
-                default:
+                case Reviewer.RESULT_DECK_CLOSED:
+                	showContentView(CONTENT_STUDY_OPTIONS);
+                	mDeckFilename = PrefSettings.getSharedPrefs(getBaseContext()).getString("deckFilename", null);
+                	displayProgressDialogAndLoadDeck();
+                	break;
+                case Reviewer.RESULT_DEFAULT:
                     DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(DeckManager.getMainDeck(), 0));
                 	showContentView(CONTENT_STUDY_OPTIONS);
                     break;
@@ -2546,9 +2552,9 @@ private void displayProgressDialogAndLoadDeck(boolean updateAllCards) {
 
             if (updateAllCards) {
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS, mLoadDeckHandler,
-                        new DeckTask.TaskData(mDeckFilename, 0, true));
+                        new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, mDeckFilename));
             } else {
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(mDeckFilename, 0, true));
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, mDeckFilename));
             }
         } else {
             if (mDeckFilename == null) {
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
index cbeab9a05559..0fbc44426633 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetBig.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -16,8 +16,6 @@
 
 import java.io.File;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.concurrent.ExecutionException;
 
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.BackupManager;
@@ -66,7 +64,6 @@ public class AnkiDroidWidgetBig extends AppWidgetProvider {
     private static String sCurrentMessage;
     private static DeckStatus[] sTomorrowDues;
     private static boolean sWaitForAsyncTask = false;
-    private static AsyncTask<String, Void, DeckStatus[]> sGetTomorrowCountAsyncTask;
 
     private static Context sContext;
 
@@ -387,10 +384,7 @@ public void onStart(Intent intent, int startId) {
             		}
             	} else if (ACTION_OPENDECK.equals(action)) {
             		showProgressDialog();
-            		if (sGetTomorrowCountAsyncTask != null && sGetTomorrowCountAsyncTask.getStatus() == AsyncTask.Status.RUNNING) {
-            			sGetTomorrowCountAsyncTask.cancel(true);
-            		}
-            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(intent.getStringExtra(EXTRA_DECK_PATH), 0, false));
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, intent.getStringExtra(EXTRA_DECK_PATH)));
                 } else if (ACTION_CLOSEDECK.equals(action)) {
                 	if (sLoadedDeck != null) {
                 		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(sLoadedDeck.getDeckPath()));                		
@@ -431,9 +425,7 @@ public void onStart(Intent intent, int startId) {
                 	String deckpath = intent.getStringExtra(EXTRA_DECK_PATH);
                 	Intent newIntent = StudyOptions.getLoadDeckIntent(this, deckpath);
                 	if (deckpath != null) {
-                		if (sCurrentView == VIEW_NOTHING_DUE) {
-                			newIntent.putExtra(StudyOptions.EXTRA_START_REVIEWER, false);
-                		} else {
+                		if (sCurrentView != VIEW_NOTHING_DUE) {
                         	DeckManager.getDeck(deckpath, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);                			
                         	newIntent.putExtra(StudyOptions.EXTRA_START_REVIEWER, true);
                 		}
@@ -485,12 +477,10 @@ public void onStart(Intent intent, int startId) {
                 	}			
                 } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
                 	if (sTomorrowDues == null) {
-                		if (sGetTomorrowCountAsyncTask == null || sGetTomorrowCountAsyncTask.getStatus() != AsyncTask.Status.RUNNING) {
-                    		showProgressDialog();
-                    		sWaitForAsyncTask = true;
-                			sGetTomorrowCountAsyncTask = new GetTomorrowDueAsyncTask();
-                			sGetTomorrowCountAsyncTask.execute(PrefSettings.getSharedPrefs(AnkiDroidWidgetBig.UpdateService.this).getString("deckPath", AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
-        				}
+                		showProgressDialog();
+                		sWaitForAsyncTask = true;
+                		AsyncTask<String, Void, DeckStatus[]> getTomorrowDuesAsyncTask = new GetTomorrowDueAsyncTask();
+                		getTomorrowDuesAsyncTask.execute(PrefSettings.getSharedPrefs(AnkiDroidWidgetBig.UpdateService.this).getString("deckPath", AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
     				} else {
         	        	updateViews(VIEW_CONGRATS);
     				}
@@ -523,16 +513,7 @@ private synchronized RemoteViews buildUpdate(Context context) {
             Resources res = getResources();
             RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
 
-            if (sShowProgressDialog) {
-            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
-            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
-            	return updateViews;
-            } else {
-            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);            	
-            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
-            }
-
-            if (sCurrentView == VIEW_SHOW_HELP || sCurrentView == VIEW_CONGRATS) {
+            if (sCurrentView == VIEW_DECKS || sCurrentView == VIEW_SHOW_HELP || sCurrentView == VIEW_CONGRATS) {
             } else if (sLoadedDeck == null) {
             	sCurrentView = VIEW_DECKS;
             } else if (sCard == null) {
@@ -545,6 +526,15 @@ private synchronized RemoteViews buildUpdate(Context context) {
             	updateViews.setTextViewText(R.id.widget_big_message, "");				
             }
 
+            if (sShowProgressDialog) {
+            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
+            	return updateViews;
+            } else {
+            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);            	
+            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
+            }
+
             switch (sCurrentView) {
             case VIEW_CONGRATS:
             case VIEW_DECKS:
