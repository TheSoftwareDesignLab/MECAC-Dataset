diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt
new file mode 100644
index 000000000000..e158896a91bc
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/GestureParser.kt
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.con>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer
+
+import android.net.Uri
+import android.webkit.WebView
+import com.ichi2.anki.cardviewer.Gesture
+import kotlin.math.abs
+
+/**
+ * Parses gestures like taps and swipes based on coordinate data passed within an [Uri].
+ *
+ * @see parse
+ */
+object GestureParser {
+    private const val SWIPE_THRESHOLD_BASE = 18
+    private val gestureGrid =
+        listOf(
+            listOf(Gesture.TAP_TOP_LEFT, Gesture.TAP_TOP, Gesture.TAP_TOP_RIGHT),
+            listOf(Gesture.TAP_LEFT, Gesture.TAP_CENTER, Gesture.TAP_RIGHT),
+            listOf(Gesture.TAP_BOTTOM_LEFT, Gesture.TAP_BOTTOM, Gesture.TAP_BOTTOM_RIGHT),
+        )
+
+    /**
+     * Analyzes the given [Uri] and returns the corresponding [Gesture].
+     *
+     * @param uri The [Uri] containing gesture data.
+     * @param isScrolling whether the WebView is being scrolled.
+     * @param scale The current scale of the WebView.
+     * @param scrollX The horizontal scroll offset of the WebView.
+     * @param scrollY The vertical scroll offset of the WebView.
+     * @param measuredWidth The measured width of the WebView.
+     * @param measuredHeight The measured height of the WebView.
+     * @return The parsed [Gesture], or `null` if invalid or should be ignored.
+     */
+    fun parse(
+        uri: Uri,
+        isScrolling: Boolean,
+        scale: Float,
+        scrollX: Int,
+        scrollY: Int,
+        measuredWidth: Int,
+        measuredHeight: Int,
+    ): Gesture? {
+        if (isScrolling) return null
+        if (uri.host == "doubleTap") return Gesture.DOUBLE_TAP
+
+        val tapX = uri.getIntQuery("x") ?: return null
+        val tapY = uri.getIntQuery("y") ?: return null
+        val deltaX = uri.getIntQuery("deltaX") ?: return null
+        val deltaY = uri.getIntQuery("deltaY") ?: return null
+        val absDeltaX = abs(deltaX)
+        val absDeltaY = abs(deltaY)
+
+        val swipeThreshold = SWIPE_THRESHOLD_BASE / scale
+        if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) {
+            val scrollDirection = uri.getQueryParameter("scrollDirection")
+            return determineSwipeGesture(deltaX, deltaY, absDeltaX, absDeltaY, scrollDirection)
+        }
+
+        val row = getGridIndex(tapY, scrollY, measuredHeight, scale)
+        val column = getGridIndex(tapX, scrollX, measuredWidth, scale)
+        return gestureGrid[row][column]
+    }
+
+    /**
+     * Analyzes the given [Uri] and returns the corresponding [Gesture].
+     *
+     * @param uri The [Uri] containing gesture data.
+     * @param isScrolling whether the WebView is being scrolled.
+     * @param scale The current scale of the WebView.
+     * @param webView The source WebView, used to access its current scroll and size properties.
+     * @return The parsed [Gesture], or `null` if the gesture is invalid or should be ignored.
+     */
+    fun parse(
+        uri: Uri,
+        isScrolling: Boolean,
+        scale: Float,
+        webView: WebView,
+    ): Gesture? =
+        parse(
+            uri = uri,
+            isScrolling = isScrolling,
+            scale = scale,
+            scrollX = webView.scrollX,
+            scrollY = webView.scrollY,
+            measuredWidth = webView.measuredWidth,
+            measuredHeight = webView.measuredHeight,
+        )
+
+    /**
+     * Determines the swipe gesture based on deltas and scroll direction.
+     *
+     * @param scrollDirection Indicates whether the underlying web content at the gesture's origin
+     * is scrollable. This value is determined by the `getScrollDirection`
+     * function in `ankidroid.js` and is used to prevent custom swipe gestures
+     * from overriding the browser's native scrolling behavior. It can contain:
+     * - 'h': The content is horizontally scrollable.
+     * - 'v': The content is vertically scrollable.
+     * - "hv": The content is scrollable in both directions.
+     * - `null`: The content is not scrollable.
+     * @return The swipe [Gesture], or `null` if the swipe is in a direction that is scrollable
+     * by the underlying web content.
+     */
+    private fun determineSwipeGesture(
+        deltaX: Int,
+        deltaY: Int,
+        absDeltaX: Int,
+        absDeltaY: Int,
+        scrollDirection: String?,
+    ): Gesture? =
+        if (absDeltaX > absDeltaY) { // horizontal
+            when {
+                scrollDirection?.contains('h') == true -> null
+                deltaX > 0 -> Gesture.SWIPE_RIGHT
+                else -> Gesture.SWIPE_LEFT
+            }
+        } else { // vertical
+            when {
+                scrollDirection?.contains('v') == true -> null
+                deltaY > 0 -> Gesture.SWIPE_DOWN
+                else -> Gesture.SWIPE_UP
+            }
+        }
+
+    /**
+     * Calculates the grid index (row or column) for a tap coordinate.
+     *
+     * This function translates a raw screen tap coordinate into an index (0, 1, or 2) for one
+     * dimension of the 3x3 gesture grid. It accounts for the WebView's current scroll position
+     * and zoom level.
+     *
+     * @param tapPosition The raw client coordinate (X or Y) of the tap.
+     * @param scrolledDistance The distance the WebView is scrolled along that axis.
+     * @param dimensionSize The measured size (width or height) of the WebView.
+     * @return The calculated grid index, constrained to be between 0 and 2.
+     */
+    private fun getGridIndex(
+        tapPosition: Int,
+        scrolledDistance: Int,
+        dimensionSize: Int,
+        scale: Float,
+    ): Int {
+        if (dimensionSize == 0) return 0 // avoids dividing by 0
+        val scaledTap = tapPosition * scale
+        val adjustedTapPosition = scaledTap - scrolledDistance
+        return (adjustedTapPosition / (dimensionSize / 3)).toInt()
+    }
+
+    private fun Uri.getIntQuery(key: String) = getQueryParameter(key)?.toIntOrNull()
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
index c542b82b5ed8..52ffc8f51e1d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/ui/windows/reviewer/ReviewerFragment.kt
@@ -58,7 +58,6 @@ import com.ichi2.anki.CollectionManager
 import com.ichi2.anki.DispatchKeyEventListener
 import com.ichi2.anki.R
 import com.ichi2.anki.cardviewer.CardMediaPlayer
-import com.ichi2.anki.cardviewer.Gesture
 import com.ichi2.anki.common.utils.android.isRobolectric
 import com.ichi2.anki.dialogs.tags.TagsDialog
 import com.ichi2.anki.dialogs.tags.TagsDialogFactory
@@ -100,7 +99,6 @@ import com.ichi2.utils.dp
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.launch
-import kotlin.math.abs
 
 class ReviewerFragment :
     CardViewerFragment(R.layout.reviewer2),
@@ -578,57 +576,7 @@ class ReviewerFragment :
         override fun handleUrl(url: Uri): Boolean {
             return when (url.scheme) {
                 "gesture" -> {
-                    if (isScrolling) return true
-                    if (url.host == "doubleTap") {
-                        viewModel.onGesture(Gesture.DOUBLE_TAP)
-                        return true
-                    }
-
-                    fun Uri.getIntQuery(key: String) = getQueryParameter(key)?.toIntOrNull()
-                    val tapX = url.getIntQuery("x") ?: return false
-                    val tapY = url.getIntQuery("y") ?: return false
-                    val deltaX = url.getIntQuery("deltaX") ?: return false
-                    val deltaY = url.getIntQuery("deltaY") ?: return false
-                    val absDeltaX = abs(deltaX)
-                    val absDeltaY = abs(deltaY)
-
-                    val swipeThreshold = 18 / scale
-                    if (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold) {
-                        val scrollDirection = url.getQueryParameter("scrollDirection")
-                        val swipeGesture =
-                            if (absDeltaX > absDeltaY) { // horizontal
-                                if (scrollDirection?.contains('h') == true) return true
-                                if (deltaX > 0) { // right
-                                    Gesture.SWIPE_RIGHT
-                                } else { // left
-                                    Gesture.SWIPE_LEFT
-                                }
-                            } else { // vertical
-                                if (scrollDirection?.contains('v') == true) return true
-                                if (deltaY > 0) { // down
-                                    Gesture.SWIPE_DOWN
-                                } else { // top
-                                    Gesture.SWIPE_UP
-                                }
-                            }
-                        viewModel.onGesture(swipeGesture)
-                        return true
-                    }
-
-                    /** Gets the corresponding index of a dimension (X or Y) in the [gestureGrid] */
-                    fun getGridIndex(
-                        tapPosition: Int,
-                        scrolledDistance: Int,
-                        dimensionSize: Int,
-                    ): Int {
-                        val scaledTap = tapPosition * scale
-                        val adjustedTapPosition = scaledTap - scrolledDistance
-                        return (adjustedTapPosition / (dimensionSize / 3)).toInt()
-                    }
-
-                    val row = getGridIndex(tapY, webView.scrollY, webView.measuredHeight)
-                    val column = getGridIndex(tapX, webView.scrollX, webView.measuredWidth)
-                    val gesture = gestureGrid[row][column]
+                    val gesture = GestureParser.parse(url, isScrolling, scale, webView) ?: return true
                     viewModel.onGesture(gesture)
                     true
                 }
@@ -648,12 +596,5 @@ class ReviewerFragment :
 
     companion object {
         fun getIntent(context: Context): Intent = CardViewerActivity.getIntent(context, ReviewerFragment::class)
-
-        private val gestureGrid =
-            listOf(
-                listOf(Gesture.TAP_TOP_LEFT, Gesture.TAP_TOP, Gesture.TAP_TOP_RIGHT),
-                listOf(Gesture.TAP_LEFT, Gesture.TAP_CENTER, Gesture.TAP_RIGHT),
-                listOf(Gesture.TAP_BOTTOM_LEFT, Gesture.TAP_BOTTOM, Gesture.TAP_BOTTOM_RIGHT),
-            )
     }
 }
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt
new file mode 100644
index 000000000000..7cb47f3baad0
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/ui/windows/reviewer/GestureParserTest.kt
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2025 Brayan Oliveira <69634269+brayandso@users.noreply.github.con>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.ichi2.anki.ui.windows.reviewer
+
+import android.net.Uri
+import com.ichi2.anki.cardviewer.Gesture
+import io.mockk.every
+import io.mockk.mockk
+import org.junit.Test
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+
+class GestureParserTest {
+    // Avoids `java.lang.RuntimeException: Method scheme in android.net.Uri$Builder not mocked.`
+    // The other option is using Robolectric, but that runs much slower
+    private fun createMockUri(
+        host: String = "tapOrSwipe",
+        x: Int? = 100,
+        y: Int? = 100,
+        deltaX: Int? = 0,
+        deltaY: Int? = 0,
+        scrollDirection: String? = null,
+    ): Uri =
+        mockk {
+            every { this@mockk.host } returns host
+            every { getQueryParameter("x") } returns x?.toString()
+            every { getQueryParameter("y") } returns y?.toString()
+            every { getQueryParameter("deltaX") } returns deltaX?.toString()
+            every { getQueryParameter("deltaY") } returns deltaY?.toString()
+            every { getQueryParameter("scrollDirection") } returns scrollDirection
+        }
+
+    private fun parseGesture(
+        uri: Uri,
+        isScrolling: Boolean = false,
+        scale: Float = 1.0f,
+        scrollX: Int = 0,
+        scrollY: Int = 0,
+        measuredWidth: Int = 900,
+        measuredHeight: Int = 1500,
+    ): Gesture? =
+        GestureParser.parse(
+            uri,
+            isScrolling,
+            scale,
+            scrollX,
+            scrollY,
+            measuredWidth,
+            measuredHeight,
+        )
+
+    @Test
+    fun `parse returns null when isScrolling is true`() {
+        val uri = createMockUri()
+        val gesture = parseGesture(uri = uri, isScrolling = true)
+        assertNull(gesture, "Gesture should be null if scrolling")
+    }
+
+    @Test
+    fun `parse returns DOUBLE_TAP for doubleTap host`() {
+        val uri = createMockUri(host = "doubleTap")
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.DOUBLE_TAP, gesture)
+    }
+
+    @Test
+    fun `parse returns null if required parameters are missing`() {
+        val malformedUri = createMockUri(x = 100, y = null, deltaX = null)
+        val gesture = parseGesture(uri = malformedUri)
+        assertNull(gesture, "Gesture should be null if parameters are missing")
+    }
+
+    // Swipe tests
+
+    @Test
+    fun `parse detects SWIPE_RIGHT`() {
+        val uri = createMockUri(deltaX = 20, deltaY = 5)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.SWIPE_RIGHT, gesture)
+    }
+
+    @Test
+    fun `parse detects SWIPE_LEFT`() {
+        val uri = createMockUri(deltaX = -25, deltaY = 10)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.SWIPE_LEFT, gesture)
+    }
+
+    @Test
+    fun `parse detects SWIPE_DOWN`() {
+        val uri = createMockUri(deltaX = 5, deltaY = 20)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.SWIPE_DOWN, gesture)
+    }
+
+    @Test
+    fun `parse detects SWIPE_UP`() {
+        val uri = createMockUri(deltaX = 10, deltaY = -25)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.SWIPE_UP, gesture)
+    }
+
+    @Test
+    fun `parse ignores horizontal swipe if content can scroll horizontally`() {
+        val uri = createMockUri(deltaX = 25, scrollDirection = "h")
+        val gesture = parseGesture(uri = uri)
+        assertNull(gesture, "Horizontal swipe should be ignored")
+    }
+
+    @Test
+    fun `parse ignores vertical swipe if content can scroll vertically`() {
+        val uri = createMockUri(deltaY = 25, scrollDirection = "v")
+        val gesture = parseGesture(uri = uri)
+        assertNull(gesture, "Vertical swipe should be ignored")
+    }
+
+    @Test
+    fun `parse swipe threshold is adjusted by scale`() {
+        val uri = createMockUri(x = 50, y = 50, deltaX = 10)
+        val gesture = parseGesture(uri = uri, scale = 2.0f)
+        assertEquals(Gesture.SWIPE_RIGHT, gesture)
+    }
+
+    // Tap tests
+
+    @Test
+    fun `parse detects TAP_TOP_LEFT`() {
+        val uri = createMockUri(x = 150, y = 250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_TOP_LEFT, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_TOP`() {
+        val uri = createMockUri(x = 450, y = 250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_TOP, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_TOP_RIGHT`() {
+        val uri = createMockUri(x = 750, y = 250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_TOP_RIGHT, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_LEFT`() {
+        val uri = createMockUri(x = 150, y = 750)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_LEFT, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_CENTER`() {
+        val uri = createMockUri(x = 450, y = 750)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_CENTER, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_RIGHT`() {
+        val uri = createMockUri(x = 750, y = 750)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_RIGHT, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_BOTTOM_LEFT`() {
+        val uri = createMockUri(x = 150, y = 1250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_BOTTOM_LEFT, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_BOTTOM`() {
+        val uri = createMockUri(x = 450, y = 1250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_BOTTOM, gesture)
+    }
+
+    @Test
+    fun `parse detects TAP_BOTTOM_RIGHT`() {
+        val uri = createMockUri(x = 750, y = 1250)
+        val gesture = parseGesture(uri = uri)
+        assertEquals(Gesture.TAP_BOTTOM_RIGHT, gesture)
+    }
+
+    // Tap with scroll & scale
+
+    @Test
+    fun `parse detects tap correctly with scrolling`() {
+        val uri = createMockUri(x = 550, y = 950)
+        val gesture = parseGesture(uri = uri, scrollX = 100, scrollY = 200)
+        assertEquals(Gesture.TAP_CENTER, gesture)
+    }
+
+    @Test
+    fun `parse detects tap correctly with scaling`() {
+        val uri = createMockUri(x = 225, y = 375)
+        val gesture = parseGesture(uri = uri, scale = 2.0f)
+        assertEquals(Gesture.TAP_CENTER, gesture)
+    }
+}
