diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
index 000f74828b30..f6dda1d8d443 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.kt
@@ -85,6 +85,7 @@ import com.ichi2.libanki.Collection
 import com.ichi2.libanki.Consts.BUTTON_TYPE
 import com.ichi2.libanki.Sound.SoundSide
 import com.ichi2.libanki.sched.AbstractSched
+import com.ichi2.libanki.sched.SchedV2
 import com.ichi2.themes.Themes
 import com.ichi2.themes.Themes.getResFromAttr
 import com.ichi2.ui.FixedEditText
@@ -634,8 +635,8 @@ abstract class AbstractFlashcardViewer :
         super.onDestroy()
         // Tells the scheduler there is no more current cards. 0 is
         // not a valid id.
-        if (sched != null) {
-            sched!!.discardCurrentCard()
+        if (sched != null && sched is SchedV2) {
+            (sched!! as SchedV2).discardCurrentCard()
         }
         Timber.d("onDestroy()")
         mTTS.releaseTts(this)
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
index 04ec0bba12de..7c8e18840cfe 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.kt
@@ -96,7 +96,6 @@ import com.ichi2.libanki.Collection.CheckDatabaseResult
 import com.ichi2.libanki.importer.AnkiPackageImporter
 import com.ichi2.libanki.sched.AbstractDeckTreeNode
 import com.ichi2.libanki.sched.TreeNode
-import com.ichi2.libanki.sched.upgradeScheduler
 import com.ichi2.libanki.sync.CustomSyncServerUrlException
 import com.ichi2.libanki.sync.Syncer.ConnectionResultType
 import com.ichi2.libanki.utils.TimeManager
@@ -2703,7 +2702,7 @@ fun CollectionHelper.updateScheduler(context: Context) {
         // even if close fails.
         try {
             try {
-                getCol(context).newBackend.upgradeScheduler()
+                getCol(context).sched.upgradeToV2()
             } finally {
                 closeCollection(true, "sched upgrade")
             }
@@ -2713,6 +2712,6 @@ fun CollectionHelper.updateScheduler(context: Context) {
         }
     } else {
         // Can upgrade directly
-        getCol(context).newBackend.upgradeScheduler()
+        getCol(context).sched.upgradeToV2()
     }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
index d6c0c37fc7a7..6e0258e298e4 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.kt
@@ -1075,7 +1075,6 @@ open class Reviewer : AbstractFlashcardViewer() {
             Counts.Queue.NEW -> mNewCount!!.setSpan(UnderlineSpan(), 0, mNewCount!!.length, 0)
             Counts.Queue.LRN -> mLrnCount!!.setSpan(UnderlineSpan(), 0, mLrnCount!!.length, 0)
             Counts.Queue.REV -> mRevCount!!.setSpan(UnderlineSpan(), 0, mRevCount!!.length, 0)
-            else -> Timber.w("Unknown card type %s", sched!!.countIdx(mCurrentCard!!))
         }
         mTextBarNew.text = mNewCount
         mTextBarLearn.text = mLrnCount
diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.kt b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.kt
index f902ff7faed1..b47fc464b164 100644
--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.kt
@@ -259,7 +259,7 @@ open class CollectionTask<Progress, Result>(val task: TaskDelegateBase<Progress,
             Timber.d("doInBackgroundLoadDeckCounts")
             return try {
                 // Get due tree
-                col.sched.deckDueTree(collectionTask)!!
+                col.sched.deckDueTree(collectionTask)
             } catch (e: RuntimeException) {
                 Timber.e(e, "doInBackgroundLoadDeckCounts - error")
                 null
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.kt
index ee3a501fa30e..0171d9e94295 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.kt
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.kt
@@ -16,7 +16,6 @@
 package com.ichi2.libanki.sched
 
 import android.app.Activity
-import android.content.Context
 import androidx.annotation.VisibleForTesting
 import com.ichi2.anki.R
 import com.ichi2.anki.UIUtils.showThemedToast
@@ -24,7 +23,6 @@ import com.ichi2.async.CancelListener
 import com.ichi2.libanki.*
 import com.ichi2.libanki.Collection
 import com.ichi2.libanki.Consts.BUTTON_TYPE
-import com.ichi2.libanki.backend.exception.BackendNotSupportedException
 import timber.log.Timber
 import java.lang.ref.WeakReference
 
@@ -34,7 +32,7 @@ import java.lang.ref.WeakReference
  * reset`). Some promise only apply in normal use.
  *
  */
-abstract class AbstractSched(val col: Collection) {
+abstract class AbstractSched(col: Collection) : BaseSched(col) {
     /**
      * Pop the next card from the queue. null if finished.
      *
@@ -142,7 +140,7 @@ abstract class AbstractSched(val col: Collection) {
      * @param card A Card which is in a mode allowing review. I.e. neither suspended nor buried.
      * @return Which of the three numbers shown in reviewer/overview should the card be counted. 0:new, 1:rev, 2: any kind of learning.
      */
-    abstract fun countIdx(card: Card): Counts.Queue?
+    abstract fun countIdx(card: Card): Counts.Queue
 
     /**
      * @param card A card in a queue allowing review.
@@ -151,286 +149,23 @@ abstract class AbstractSched(val col: Collection) {
     abstract fun answerButtons(card: Card): Int
 
     /**
+     * specific-deck case not supported by the backend; UI only uses this
+     * for long-press on deck
      * @param did An id of a deck
      * @return Whether there is any buried cards in the deck
      */
     abstract fun haveBuried(did: Long): Boolean
 
     /**
-     * Unbury cards.
-     * @param type Which kind of cards should be unburied.
-     */
-    abstract fun unburyCardsForDeck(did: Long, type: UnburyType = UnburyType.ALL)
-    enum class UnburyType {
-        ALL, MANUAL, SIBLINGS
-    }
-
-    /**
-     * Unbury all buried cards in selected decks
-     */
-    fun unburyCardsForDeck(type: UnburyType = UnburyType.ALL) {
-        unburyCardsForDeck(col.decks.selected(), type)
-    }
-
-    /**
-     * Unbury all buried cards in all decks. Only used for tests.
-     */
-    open fun unburyCards() {
-        for (did in col.decks.allIds()) {
-            unburyCardsForDeck(did)
-        }
-    }
-
-    /**
-     * @param newc Extra number of NEW cards to see today in selected deck
-     * @param rev Extra number of REV cards to see today in selected deck
-     */
-    abstract fun extendLimits(newc: Int, rev: Int)
-
-    /**
-     * @param cancelListener A task that is potentially cancelled
-     * @return the due tree. null only if task is cancelled
-     */
-    abstract fun deckDueTree(cancelListener: CancelListener?): List<TreeNode<DeckDueTreeNode>>?
-
-    /**
-     * @return the due tree.
-     */
-    fun deckDueTree(): List<TreeNode<DeckDueTreeNode>> {
-        // without a cancelListener, guaranteed not null
-        return deckDueTree(cancelListener = null)!!
-    }
-
-    /**
-     * @return The tree of decks, without numbers
-     */
-    abstract fun<T : AbstractDeckTreeNode> quickDeckDueTree(): List<TreeNode<T>>
-
-    /**
-     * @return Number of new card in current deck and its descendants. Capped at reportLimit = 99999.
-     */
-    abstract fun totalNewForCurrentDeck(): Int
-
-    /** @return Number of review cards in current deck.
-     */
-    abstract fun totalRevForCurrentDeck(): Int
-
-    // In this abstract class for testing purpose only
-    /** Rebuild selected dynamic deck.  */
-    fun rebuildDyn() {
-        rebuildDyn(0)
-    }
-
-    /** Rebuild a dynamic deck.
-     * @param did The deck to rebuild. 0 means current deck.
-     */
-    abstract fun rebuildDyn(did: Long)
-
-    /** Remove all cards from a dynamic deck
-     * @param did The deck to empty. 0 means current deck.
-     */
-    abstract fun emptyDyn(did: Long)
-
-    /**
-     * i @param cids Cards to remove from their dynamic deck (it is assumed they are in one)
-     */
-    // In this abstract class for testing purpose only
-    abstract fun remFromDyn(cids: Iterable<Long>)
-    fun remFromDyn(cids: LongArray) {
-        remFromDyn(cids.toList())
-    }
-
-    /**
-     * @param card A random card
-     * @return The conf of the deck of the card.
-     */
-    // In this abstract class for testing purpose only
-    abstract fun _cardConf(card: Card): DeckConfig
-
-    /**
-     * @param context Some Context to access the lang
-     * @return A message to show to user when they reviewed the last card. Let them know if they can see learning card later today
-     * or if they could see more card today by extending review.
-     */
-    abstract fun finishedMsg(context: Context): CharSequence
-
-    /** @return whether there are any rev cards due.
-     */
-    abstract fun revDue(): Boolean
-
-    /** @return whether there are any new cards due.
-     */
-    abstract fun newDue(): Boolean
-
-    /** @return whether there are cards in learning, with review due the same
-     * day, in the selected decks.
-     */
-    abstract fun hasCardsTodayAfterStudyAheadLimit(): Boolean
-
-    /**
-     * @return Whether there are buried card is selected deck
-     */
-    abstract fun haveBuried(): Boolean
-
-    /**
-     * Return the next interval for a card and ease as a string.
-     *
-     * For a given card and ease, this returns a string that shows when the card will be shown again when the
-     * specific ease button (AGAIN, GOOD etc.) is touched. This uses unit symbols like “s” rather than names
-     * (“second”), like Anki desktop.
-     *
-     * @param context The app context, used for localization
-     * @param card The card being reviewed
-     * @param ease The button number (easy, good etc.)
-     * @return A string like “1 min” or “1.7 mo”
-     */
-    abstract fun nextIvlStr(context: Context, card: Card, @BUTTON_TYPE ease: Int): String
-
-    /**
-     * @param card A card
-     * @param ease a button, between 1 and answerButtons(card)
-     * @return the next interval for CARD, in seconds if ease is pressed.
-     */
-    // In this abstract class for testing purpose only
-    abstract fun nextIvl(card: Card, @BUTTON_TYPE ease: Int): Long
-
-    /**
-     * @param ids Id of cards to suspend
-     */
-    abstract fun suspendCards(ids: LongArray)
-
-    /**
-     * @param ids Id of cards to unsuspend
-     */
-    abstract fun unsuspendCards(ids: LongArray)
-
-    /**
-     * @param cids Ids of cards to bury
-     */
-    fun buryCards(cids: LongArray) {
-        buryCards(cids, manual = true)
-    }
-
-    /**
-     * @param cids Ids of the cards to bury
-     * @param manual Whether bury is made manually or not. Only useful for sched v2.
-     */
-    @VisibleForTesting
-    abstract fun buryCards(cids: LongArray, manual: Boolean)
-
-    /**
-     * Bury all cards for note until next session.
-     * @param nid The id of the targeted note.
-     */
-    abstract fun buryNote(nid: Long)
-
-    /**
-     * @param ids Ids of cards to put at the end of the new queue.
-     */
-    abstract fun forgetCards(ids: List<Long>)
-
-    /**
-     * Put cards in review queue with a new interval in days (min, max).
-     *
-     * @param ids The list of card ids to be affected
-     * @param imin the minimum interval (inclusive)
-     * @param imax The maximum interval (inclusive)
-     */
-    abstract fun reschedCards(ids: List<Long>, imin: Int, imax: Int)
-
-    /**
-     * @param ids Ids of cards to reset for export
-     */
-    abstract fun resetCards(ids: Array<Long>)
-
-    /**
-     * @param cids Ids of card to set to new and sort
-     * @param start The lowest due value for those cards
-     * @param step The step between two successive due value set to those cards
-     * @param shuffle Whether the list should be shuffled.
-     * @param shift Whether the cards already new should be shifted to make room for cards of cids
-     */
-    abstract fun sortCards(cids: List<Long>, start: Int, step: Int, shuffle: Boolean, shift: Boolean)
-
-    /**
-     * Randomize the cards of did
-     * @param did Id of a deck
-     */
-    abstract fun randomizeCards(did: Long)
-
-    /**
-     * Sort the cards of deck `id` by creation date of the note
-     * @param did Id of a deck
-     */
-    abstract fun orderCards(did: Long)
-
-    /**
-     * Sort or randomize all cards of all decks with this deck configuration.
-     * @param conf A deck configuration
-     */
-    abstract fun resortConf(conf: DeckConfig)
-
-    /**
-     * If the deck with id did is set to random order, then randomize their card.
-     * This is used to deal which are imported
-     * @param did Id of a deck
-     */
-    abstract fun maybeRandomizeDeck(did: Long)
-
-    /**
-
-     /**
-     * Unbury all buried card of the deck
-     * @param did An id of the deck
-     */
-     abstract fun unburyCardsForDeck(did: Long)
      * @return Name of the scheduler. std or std2 currently.
      */
     abstract val name: String
 
-    /**
-     * @return Number of days since creation of the collection.
-     */
-    abstract val today: Int
-
-    /**
-     * @return Timestamp of when the day ends. Takes into account hour at which day change for anki and timezone
-     */
-    abstract val dayCutoff: Long
-
     /** @return Number of repetitions today. Note that a repetition is the fact that the scheduler sent a card, and not the fact that the card was answered.
      * So buried, suspended, ... cards are also counted as repetitions.
      */
     abstract val reps: Int
 
-    /** @return Number of cards in the current decks, its descendants and ancestors.
-     */
-    abstract fun cardCount(): Int
-
-    /**
-     * Return an estimate, in minutes, for how long it will take to complete all the reps in `counts`.
-     *
-     * The estimator builds rates for each queue type by looking at 10 days of history from the revlog table. For
-     * efficiency, and to maintain the same rates for a review session, the rates are cached and reused until a
-     * reload is forced.
-     *
-     * Notes:
-     * - Because the revlog table does not record deck IDs, the rates cannot be reduced to a single deck and thus cover
-     * the whole collection which may be inaccurate for some decks.
-     * - There is no efficient way to determine how many lrn cards are generated by each new card. This estimator
-     * assumes 1 card is generated as a compromise.
-     * - If there is no revlog data to work with, reasonable defaults are chosen as a compromise to predicting 0 minutes.
-     *
-     * @param counts An array of [new, lrn, rev] counts from the scheduler's counts() method.
-     * @param reload Force rebuild of estimator rates using the revlog.
-     */
-    abstract fun eta(counts: Counts, reload: Boolean): Int
-
-    /** Same as above and force reload. */
-    fun eta(counts: Counts): Int {
-        return eta(counts, true)
-    }
-
     /**
      * @param contextReference An activity on which a message can be shown. Does not force the activity to remains in memory
      */
@@ -443,20 +178,6 @@ abstract class AbstractSched(val col: Collection) {
      * @param wasLeech Whether the card was a leech before the review was made (if false, remove the leech tag)
      */
     abstract fun undoReview(card: Card, wasLeech: Boolean)
-    interface LimitMethod {
-        fun operation(g: Deck): Int
-    }
-
-    /** Given a deck, compute the number of cards to see today, taking its pre-computed limit into consideration.  It
-     * considers either review or new cards. Used by WalkingCount to consider all subdecks and parents of a specific
-     * decks. */
-    interface CountMethod {
-        fun operation(did: Long, lim: Int): Int
-    }
-
-    /** Notifies the scheduler that there is no more current card. This is the case when a card is answered, when the
-     * scheduler is reset...  */
-    abstract fun discardCurrentCard()
 
     /** @return The button to press to enter "good" on a new card.
      */
@@ -464,22 +185,6 @@ abstract class AbstractSched(val col: Collection) {
     @get:VisibleForTesting
     abstract val goodNewButton: Int
 
-    /**
-     * @return The number of revlog in the collection
-     */
-    abstract fun logCount(): Int
-
-    abstract fun _new_timezone_enabled(): Boolean
-
-    /**
-     * Save the UTC west offset at the time of creation into the DB.
-     * Once stored, this activates the new timezone handling code.
-     */
-    @Throws(BackendNotSupportedException::class)
-    abstract fun set_creation_offset()
-    abstract fun clear_creation_offset()
-    abstract fun useNewTimezoneCode()
-
     companion object {
         /**
          * Tell the user the current card has leeched and whether it was suspended. Timber if no activity.
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BackendSched.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BackendSched.kt
deleted file mode 100644
index e58b4fa80122..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BackendSched.kt
+++ /dev/null
@@ -1,64 +0,0 @@
-/***************************************************************************************
- * Copyright (c) 2022 Ankitects Pty Ltd <http://apps.ankiweb.net>                       *
- *                                                                                      *
- * This program is free software; you can redistribute it and/or modify it under        *
- * the terms of the GNU General Public License as published by the Free Software        *
- * Foundation; either version 3 of the License, or (at your option) any later           *
- * version.                                                                             *
- *                                                                                      *
- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
- *                                                                                      *
- * You should have received a copy of the GNU General Public License along with         *
- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
- ****************************************************************************************/
-
-package com.ichi2.libanki.sched
-
-import anki.decks.DeckTreeNode
-import com.ichi2.libanki.CollectionV16
-import com.ichi2.libanki.utils.TimeManager
-
-// The desktop code stores these routines in sched/base.py, and all schedulers inherit them.
-// The presence of AbstractSched is going to complicate the introduction of the v3 scheduler,
-// so for now these are stored in a separate file.
-
-fun CollectionV16.deckTree(includeCounts: Boolean): DeckTreeNode {
-    return backend.deckTree(now = if (includeCounts) TimeManager.time.intTime() else 0)
-}
-
-/**
- * Mutate the backend reply into a format expected by legacy code. This is less efficient,
- * and AnkiDroid may wish to use .deckTree() in the future instead.
- */
-fun CollectionV16.deckTreeLegacy(includeCounts: Boolean): List<TreeNode<DeckDueTreeNode>> {
-    fun toLegacyNode(node: DeckTreeNode, parentName: String): TreeNode<DeckDueTreeNode> {
-        val thisName = if (parentName.isEmpty()) {
-            node.name
-        } else {
-            "$parentName::${node.name}"
-        }
-        val treeNode = TreeNode(
-            DeckDueTreeNode(
-                thisName,
-                node.deckId,
-                node.reviewCount,
-                node.learnCount,
-                node.newCount,
-                collapsed = node.collapsed,
-                filtered = node.filtered
-            )
-        )
-        treeNode.children.addAll(node.childrenList.asSequence().map { toLegacyNode(it, thisName) })
-        return treeNode
-    }
-    return toLegacyNode(deckTree(includeCounts), "").children
-}
-
-fun CollectionV16.upgradeScheduler() {
-    modSchema()
-    clearUndo()
-    backend.upgradeScheduler()
-    _loadScheduler()
-}
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BaseSched.kt b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BaseSched.kt
new file mode 100644
index 000000000000..9c6673841ebd
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/BaseSched.kt
@@ -0,0 +1,716 @@
+/***************************************************************************************
+ * Copyright (c) 2022 Ankitects Pty Ltd <https://apps.ankiweb.net>                      *
+ * The non-backend methods were mainly taken from the old schedulers and AbstractSched  *
+ * - see git history for authors.                                                       *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.libanki.sched
+
+import android.content.Context
+import android.graphics.Typeface
+import android.text.SpannableStringBuilder
+import android.text.style.StyleSpan
+import androidx.annotation.VisibleForTesting
+import anki.decks.DeckTreeNode
+import anki.scheduler.*
+import com.ichi2.anki.R
+import com.ichi2.async.CancelListener
+import com.ichi2.libanki.*
+import com.ichi2.libanki.Collection
+import com.ichi2.libanki.Consts.BUTTON_TYPE
+import com.ichi2.libanki.Consts.CARD_TYPE_RELEARNING
+import com.ichi2.libanki.Consts.QUEUE_TYPE_DAY_LEARN_RELEARN
+import com.ichi2.libanki.stats.Stats
+import com.ichi2.libanki.utils.TimeManager
+import com.ichi2.libanki.utils.TimeManager.time
+import net.ankiweb.rsdroid.RustCleanup
+
+/**
+ * Scheduler routines that are common to both V3 and V2.
+ *
+ * The open funs that reference the backend can only be used when
+ * BackendFactory.defaultLegacySchema is false, so for now, SchedV2
+ * will need to (conditionally) override them.
+ */
+abstract class BaseSched(val col: Collection) {
+    /** Update a V1 scheduler collection to V2. Requires full sync. */
+    fun upgradeToV2() {
+        col.modSchema()
+        col.clearUndo()
+        col.newBackend.backend.upgradeScheduler()
+        col._loadScheduler()
+    }
+
+    /**
+     * @param cids Ids of cards to bury
+     */
+    fun buryCards(cids: LongArray) {
+        buryCards(cids, manual = true)
+    }
+
+    /**
+     * @param ids Id of cards to suspend
+     */
+    open fun suspendCards(ids: LongArray) {
+        col.newBackend.backend.buryOrSuspendCards(
+            cardIds = ids.toList(),
+            noteIds = listOf(),
+            mode = BuryOrSuspendCardsRequest.Mode.SUSPEND
+        )
+    }
+
+    /**
+     * @param ids Id of cards to unsuspend
+     */
+    open fun unsuspendCards(ids: LongArray) {
+        col.newBackend.backend.restoreBuriedAndSuspendedCards(
+            cids = ids.toList()
+        )
+    }
+
+    /**
+     * @param cids Ids of the cards to bury
+     * @param manual Whether bury is made manually or not. Only useful for sched v2.
+     */
+    @VisibleForTesting
+    open fun buryCards(cids: LongArray, manual: Boolean) {
+        val mode = if (manual) {
+            BuryOrSuspendCardsRequest.Mode.BURY_USER
+        } else {
+            BuryOrSuspendCardsRequest.Mode.BURY_SCHED
+        }
+        col.newBackend.backend.buryOrSuspendCards(
+            cardIds = cids.toList(),
+            noteIds = listOf(),
+            mode = mode,
+        )
+    }
+
+    /**
+     * Bury all cards for note until next session.
+     * @param nid The id of the targeted note.
+     */
+    open fun buryNote(nid: Long) {
+        col.newBackend.backend.buryOrSuspendCards(
+            cardIds = listOf(),
+            noteIds = listOf(nid),
+            mode = BuryOrSuspendCardsRequest.Mode.BURY_USER
+        )
+    }
+
+    /**
+     * Unbury cards.
+     * @param type Which kind of cards should be unburied.
+     */
+    open fun unburyCardsForDeck(did: Long, type: UnburyType = UnburyType.ALL) {
+        val mode = when (type) {
+            UnburyType.ALL -> UnburyDeckRequest.Mode.ALL
+            UnburyType.MANUAL -> UnburyDeckRequest.Mode.USER_ONLY
+            UnburyType.SIBLINGS -> UnburyDeckRequest.Mode.SCHED_ONLY
+        }
+        col.newBackend.backend.unburyDeck(deckId = did, mode = mode)
+    }
+
+    enum class UnburyType {
+        ALL, MANUAL, SIBLINGS
+    }
+
+    /**
+     * Unbury all buried cards in selected decks
+     */
+    fun unburyCardsForDeck(type: UnburyType = UnburyType.ALL) {
+        unburyCardsForDeck(col.decks.selected(), type)
+    }
+
+    /**
+     * Unbury all buried cards in all decks. Only used for tests.
+     */
+    fun unburyCards() {
+        for (did in col.decks.allIds()) {
+            unburyCardsForDeck(did)
+        }
+    }
+
+    /**
+     * @return Whether there are buried card is selected deck
+     */
+    open fun haveBuried(): Boolean {
+        return col.newBackend.backend.congratsInfo().run {
+            haveUserBuried && haveSchedBuried
+        }
+    }
+
+    /** @return whether there are cards in learning, with review due the same
+     * day, in the selected decks.
+     */
+    open fun hasCardsTodayAfterStudyAheadLimit(): Boolean {
+        return col.newBackend.backend.congratsInfo().secsUntilNextLearn < 86_400
+    }
+
+    /**
+     * @param ids Ids of cards to put at the end of the new queue.
+     */
+    open fun forgetCards(ids: List<Long>) {
+        val request = scheduleCardsAsNewRequest {
+            cardIds.addAll(ids)
+            log = true
+            restorePosition = false
+            resetCounts = false
+        }
+        col.newBackend.backend.scheduleCardsAsNewRaw(request.toByteArray())
+    }
+
+    /**
+     * Put cards in review queue with a new interval in days (min, max).
+     *
+     * @param ids The list of card ids to be affected
+     * @param imin the minimum interval (inclusive)
+     * @param imax The maximum interval (inclusive)
+     */
+    open fun reschedCards(ids: List<Long>, imin: Int, imax: Int) {
+        // there is an available non-raw method, but the config key arg
+        // is not declared as optional
+        val request = setDueDateRequest {
+            cardIds.addAll(ids)
+            days = "$imin-$imax!"
+        }
+        col.newBackend.backend.setDueDateRaw(request.toByteArray())
+    }
+
+    /**
+     * @param cids Ids of card to set to new and sort
+     * @param start The lowest due value for those cards
+     * @param step The step between two successive due value set to those cards
+     * @param shuffle Whether the list should be shuffled.
+     * @param shift Whether the cards already new should be shifted to make room for cards of cids
+     */
+    @JvmOverloads
+    open fun sortCards(
+        cids: List<Long>,
+        start: Int,
+        step: Int = 1,
+        shuffle: Boolean = false,
+        shift: Boolean = false
+    ) {
+        col.newBackend.backend.sortCards(
+            cardIds = cids,
+            startingFrom = start,
+            stepSize = step,
+            randomize = shuffle,
+            shiftExisting = shift
+        )
+    }
+
+    /**
+     * Randomize the cards of did
+     * @param did Id of a deck
+     */
+    open fun randomizeCards(did: Long) {
+        col.newBackend.backend.sortDeck(deckId = did, randomize = true)
+    }
+
+    /**
+     * Sort the cards of deck `id` by creation date of the note
+     * @param did Id of a deck
+     */
+    open fun orderCards(did: Long) {
+        col.newBackend.backend.sortDeck(deckId = did, randomize = false)
+    }
+
+    /**
+     * @param newc Extra number of NEW cards to see today in selected deck
+     * @param rev Extra number of REV cards to see today in selected deck
+     */
+    open fun extendLimits(newc: Int, rev: Int) {
+        col.newBackend.backend.extendLimits(
+            deckId = col.decks.selected(),
+            newDelta = newc,
+            reviewDelta = rev,
+        )
+    }
+
+    /** Rebuild a dynamic deck.
+     * @param did The deck to rebuild. 0 means current deck.
+     */
+    open fun rebuildDyn(did: Long) {
+        col.newBackend.backend.rebuildFilteredDeck(did)
+    }
+
+    fun rebuildDyn() {
+        rebuildDyn(col.decks.selected())
+    }
+
+    /** Remove all cards from a dynamic deck
+     * @param did The deck to empty. 0 means current deck.
+     */
+    open fun emptyDyn(did: Long) {
+        col.newBackend.backend.emptyFilteredDeck(did)
+    }
+
+    /**
+     * @param cancelListener A task that is potentially cancelled
+     * @return the due tree. null only if task is cancelled
+     */
+    @RustCleanup("cancelListener ignored, and never null")
+    open fun deckDueTree(cancelListener: CancelListener?): List<TreeNode<DeckDueTreeNode>>? {
+        return deckTreeLegacy(true)
+    }
+
+    fun deckDueTree(): List<TreeNode<DeckDueTreeNode>> {
+        return deckDueTree(cancelListener = null)!!
+    }
+
+    /**
+     * @return The tree of decks, without numbers
+     */
+    @Suppress("unchecked_cast")
+    open fun <T : AbstractDeckTreeNode> quickDeckDueTree(): List<TreeNode<T>> {
+        return deckTreeLegacy(false) as List<TreeNode<T>>
+    }
+
+    /** Return the deck tree, in the native backend format. */
+    fun deckTree(includeCounts: Boolean): DeckTreeNode {
+        return col.newBackend.backend.deckTree(now = if (includeCounts) TimeManager.time.intTime() else 0)
+    }
+
+    /**
+     * Mutate the backend reply into a format expected by legacy code. This is less efficient,
+     * and AnkiDroid may wish to use .deckTree() in the future instead.
+     */
+    fun deckTreeLegacy(includeCounts: Boolean): List<TreeNode<DeckDueTreeNode>> {
+        fun toLegacyNode(node: DeckTreeNode, parentName: String): TreeNode<DeckDueTreeNode> {
+            val thisName = if (parentName.isEmpty()) {
+                node.name
+            } else {
+                "$parentName::${node.name}"
+            }
+            val treeNode = TreeNode(
+                DeckDueTreeNode(
+                    thisName,
+                    node.deckId,
+                    node.reviewCount,
+                    node.learnCount,
+                    node.newCount,
+                    collapsed = node.collapsed,
+                    filtered = node.filtered
+                )
+            )
+            treeNode.children.addAll(
+                node.childrenList.asSequence().map { toLegacyNode(it, thisName) }
+            )
+            return treeNode
+        }
+        return toLegacyNode(deckTree(includeCounts), "").children
+    }
+
+    /*
+    *************************************************************************
+    * The routines below can be used even when defaultLegacySchema is true
+    *************************************************************************
+    */
+
+    /**
+     * @param context Some Context to access the lang
+     * @return A message to show to user when they reviewed the last card. Let them know if they can see learning card later today
+     * or if they could see more card today by extending review.
+     */
+    @RustCleanup("remove once new congrats screen is the default")
+    fun finishedMsg(context: Context): CharSequence {
+        val sb = SpannableStringBuilder()
+        sb.append(context.getString(R.string.studyoptions_congrats_finished))
+        val boldSpan = StyleSpan(Typeface.BOLD)
+        sb.setSpan(boldSpan, 0, sb.length, 0)
+        sb.append(_nextDueMsg(context))
+        // sb.append("\n\n");
+        // sb.append(_tomorrowDueMsg(context));
+        return sb
+    }
+
+    fun _nextDueMsg(context: Context): String {
+        val sb = StringBuilder()
+        if (revDue()) {
+            sb.append("\n\n")
+            sb.append(context.getString(R.string.studyoptions_congrats_more_rev))
+        }
+        if (newDue()) {
+            sb.append("\n\n")
+            sb.append(context.getString(R.string.studyoptions_congrats_more_new))
+        }
+        if (haveBuried()) {
+            val now = " " + context.getString(R.string.sched_unbury_action)
+            sb.append("\n\n")
+            sb.append("").append(context.getString(R.string.sched_has_buried)).append(now)
+        }
+        if (col.decks.current().isStd) {
+            sb.append("\n\n")
+            sb.append(context.getString(R.string.studyoptions_congrats_custom))
+        }
+        return sb.toString()
+    }
+
+    /**
+     Backend doesn't provide a method to remove specific cards, because it does this automatically
+     when you do something like changing a card's deck.
+     * @param cids Cards to remove from their dynamic deck (it is assumed they are in one)
+     */
+    open fun emptyDyn(lim: String) {
+        col.db.execute(
+            "update cards set did = odid, " + _restoreQueueWhenEmptyingSnippet() +
+                ", due = (case when odue>0 then odue else due end), odue = 0, odid = 0, usn = ? where " + lim,
+            col.usn()
+        )
+    }
+
+    /**
+     * ugly fix for suspended cards being unsuspended when filtered deck emptied
+     * https://github.com/ankitects/anki/commit/fe493e31c4d73ae2bbd0c4d8c6b835974c0e290c
+     */
+    protected open fun _restoreQueueWhenEmptyingSnippet(): String {
+        return "queue = (case when queue < 0 then queue" +
+            "    when type in (1," + CARD_TYPE_RELEARNING + ") then " +
+            "(case when (case when odue then odue else due end) > 1000000000 then 1 else " +
+            "    " + QUEUE_TYPE_DAY_LEARN_RELEARN + " end) " +
+            "else " +
+            "    type " +
+            "end)"
+    }
+
+    fun remFromDyn(cids: Iterable<Long>?) {
+        emptyDyn("id IN " + Utils.ids2str(cids) + " AND odid")
+    }
+
+    fun remFromDyn(cids: LongArray) {
+        remFromDyn(cids.toList())
+    }
+
+    /**
+     * Completely reset cards for export.
+     */
+    @RustCleanup("remove once old apkg exporter dropped")
+    open fun resetCards(ids: Array<Long>) {
+        val nonNew: List<Long> = col.db.queryLongList(
+            "select id from cards where id in " + Utils.ids2str(ids) + " and (queue != " + Consts.QUEUE_TYPE_NEW + " or type != " + Consts.CARD_TYPE_NEW + ")"
+        )
+        col.db.execute("update cards set reps=0, lapses=0 where id in " + Utils.ids2str(nonNew))
+        forgetCards(nonNew)
+        col.log(*ids)
+    }
+
+    /**
+     * for post-import
+     */
+    @RustCleanup("remove after removing old apkg importer")
+    fun maybeRandomizeDeck(did: Long) {
+        val conf = col.decks.confForDid(did)
+        // in order due?
+        if (conf.getJSONObject("new").getInt("order") == Consts.NEW_CARDS_RANDOM) {
+            randomizeCards(did)
+        }
+    }
+
+    /**
+     * Sort or randomize all cards of all decks with this deck configuration.
+     * @param conf A deck configuration
+     */
+    fun resortConf(conf: DeckConfig) {
+        val dids = col.decks.didsForConf(conf)
+        for (did in dids) {
+            if (conf.getJSONObject("new").getLong("order") == 0L) {
+                randomizeCards(did)
+            } else {
+                orderCards(did)
+            }
+        }
+    }
+
+    fun logCount(): Int {
+        return col.db.queryScalar("SELECT count() FROM revlog")
+    }
+
+    fun _deckLimit(): String {
+        return Utils.ids2str(col.decks.active())
+    }
+
+    /**
+     * @return Number of new card in current deck and its descendants. Capped at [REPORT_LIMIT]
+     */
+    fun totalNewForCurrentDeck(): Int {
+        return col.db.queryScalar(
+            "SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_NEW + " LIMIT ?)",
+            REPORT_LIMIT
+        )
+    }
+
+    /** @return Number of review cards in current deck.
+     */
+    fun totalRevForCurrentDeck(): Int {
+        return col.db.queryScalar(
+            "SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN " + _deckLimit() + "  AND queue = " + Consts.QUEUE_TYPE_REV + " AND due <= ? LIMIT ?)",
+            today, REPORT_LIMIT
+        )
+    }
+
+    /**
+     * @return Number of days since creation of the collection.
+     */
+    open val today: Int
+        get() = _timingToday().daysElapsed
+
+    /**
+     * @return Timestamp of when the day ends. Takes into account hour at which day change for anki and timezone
+     */
+    open val dayCutoff: Long
+        get() = _timingToday().nextDayAt
+
+    /* internal */
+    fun _timingToday(): SchedTimingTodayResponse {
+        return if (true) { // (BackendFactory.defaultLegacySchema) {
+            @Suppress("useless_cast")
+            return col.backend.schedTimingTodayLegacy(
+                col.crt,
+                col.get_config("creationOffset", 0 as Int)!!,
+                time.intTime(),
+                _current_timezone_offset(),
+                _rolloverHour()
+            )
+        } else {
+            // this currently breaks a bunch of unit tests that assume a mocked time,
+            // as it uses the real time to calculate daysElapsed
+            col.newBackend.backend.schedTimingToday()
+        }
+    }
+
+    @Suppress("useless_cast")
+    fun _rolloverHour(): Int {
+        return col.get_config("rollover", 4 as Int)!!
+    }
+
+    @Suppress("useless_cast")
+    open fun _current_timezone_offset(): Int {
+        return localMinutesWest(time.intTime())
+    }
+
+    /**
+     * For the given timestamp, return minutes west of UTC in the local timezone.
+     *
+     * eg, Australia at +10 hours is -600.
+     * Includes the daylight savings offset if applicable.
+     *
+     * @param timestampSeconds The timestamp in seconds
+     * @return minutes west of UTC in the local timezone
+     */
+    fun localMinutesWest(timestampSeconds: Long): Int {
+        return col.backend.localMinutesWestLegacy(timestampSeconds)
+    }
+
+    /**
+     * Save the UTC west offset at the time of creation into the DB.
+     * Once stored, this activates the new timezone handling code.
+     */
+    fun set_creation_offset() {
+        val minsWest = localMinutesWest(col.crt)
+        col.set_config("creationOffset", minsWest)
+    }
+
+    // New timezone handling
+    // ////////////////////////////////////////////////////////////////////////
+
+    fun _new_timezone_enabled(): Boolean {
+        return col.has_config_not_null("creationOffset")
+    }
+
+    fun useNewTimezoneCode() {
+        set_creation_offset()
+    }
+
+    fun clear_creation_offset() {
+        col.remove_config("creationOffset")
+    }
+
+    /** true if there are any rev cards due.  */
+    open fun revDue(): Boolean {
+        return col.db
+            .queryScalar(
+                "SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_REV + " AND due <= ?" +
+                    " LIMIT 1",
+                today
+            ) != 0
+    }
+
+    /** true if there are any new cards due.  */
+    open fun newDue(): Boolean {
+        return col.db.queryScalar("SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_NEW + " LIMIT 1") != 0
+    }
+
+    /** @return Number of cards in the current deck and its descendants.
+     */
+    fun cardCount(): Int {
+        val dids = _deckLimit()
+        return col.db.queryScalar("SELECT count() FROM cards WHERE did IN $dids")
+    }
+
+    private val etaCache: DoubleArray = doubleArrayOf(-1.0, -1.0, -1.0, -1.0, -1.0, -1.0)
+
+    /**
+     * Return an estimate, in minutes, for how long it will take to complete all the reps in `counts`.
+     *
+     * The estimator builds rates for each queue type by looking at 10 days of history from the revlog table. For
+     * efficiency, and to maintain the same rates for a review session, the rates are cached and reused until a
+     * reload is forced.
+     *
+     * Notes:
+     * - Because the revlog table does not record deck IDs, the rates cannot be reduced to a single deck and thus cover
+     * the whole collection which may be inaccurate for some decks.
+     * - There is no efficient way to determine how many lrn cards are generated by each new card. This estimator
+     * assumes 1 card is generated as a compromise.
+     * - If there is no revlog data to work with, reasonable defaults are chosen as a compromise to predicting 0 minutes.
+     *
+     * @param counts An array of [new, lrn, rev] counts from the scheduler's counts() method.
+     * @param reload Force rebuild of estimator rates using the revlog.
+     */
+    fun eta(counts: Counts, reload: Boolean = true): Int {
+        var newRate: Double
+        var newTime: Double
+        var revRate: Double
+        var revTime: Double
+        var relrnRate: Double
+        var relrnTime: Double
+        if (reload || etaCache.get(0) == -1.0) {
+            col
+                .db
+                .query(
+                    "select " +
+                        "avg(case when type = " + Consts.CARD_TYPE_NEW + " then case when ease > 1 then 1.0 else 0.0 end else null end) as newRate, avg(case when type = " + Consts.CARD_TYPE_NEW + " then time else null end) as newTime, " +
+                        "avg(case when type in (" + Consts.CARD_TYPE_LRN + ", " + Consts.CARD_TYPE_RELEARNING + ") then case when ease > 1 then 1.0 else 0.0 end else null end) as revRate, avg(case when type in (" + Consts.CARD_TYPE_LRN + ", " + Consts.CARD_TYPE_RELEARNING + ") then time else null end) as revTime, " +
+                        "avg(case when type = " + Consts.CARD_TYPE_REV + " then case when ease > 1 then 1.0 else 0.0 end else null end) as relrnRate, avg(case when type = " + Consts.CARD_TYPE_REV + " then time else null end) as relrnTime " +
+                        "from revlog where id > " +
+                        "?",
+                    (col.sched.dayCutoff - (10 * Stats.SECONDS_PER_DAY)) * 1000
+                ).use { cur ->
+                    if (!cur.moveToFirst()) {
+                        return -1
+                    }
+                    newRate = cur.getDouble(0)
+                    newTime = cur.getDouble(1)
+                    revRate = cur.getDouble(2)
+                    revTime = cur.getDouble(3)
+                    relrnRate = cur.getDouble(4)
+                    relrnTime = cur.getDouble(5)
+                    if (!cur.isClosed()) {
+                        cur.close()
+                    }
+                }
+
+            // If the collection has no revlog data to work with, assume a 20 second average rep for that type
+            newTime = if (newTime == 0.0) 20000.0 else newTime
+            revTime = if (revTime == 0.0) 20000.0 else revTime
+            relrnTime = if (relrnTime == 0.0) 20000.0 else relrnTime
+            // And a 100% success rate
+            newRate = if (newRate == 0.0) 1.0 else newRate
+            revRate = if (revRate == 0.0) 1.0 else revRate
+            relrnRate = if (relrnRate == 0.0) 1.0 else relrnRate
+            etaCache[0] = newRate
+            etaCache[1] = newTime
+            etaCache[2] = revRate
+            etaCache[3] = revTime
+            etaCache[4] = relrnRate
+            etaCache[5] = relrnTime
+        } else {
+            newRate = etaCache.get(0)
+            newTime = etaCache.get(1)
+            revRate = etaCache.get(2)
+            revTime = etaCache.get(3)
+            relrnRate = etaCache.get(4)
+            relrnTime = etaCache.get(5)
+        }
+
+        // Calculate the total time for each queue based on the historical average duration per rep
+        val newTotal = newTime * counts.new
+        val relrnTotal = relrnTime * counts.lrn
+        val revTotal = revTime * counts.rev
+
+        // Now we have to predict how many additional relrn cards are going to be generated while reviewing the above
+        // queues, and how many relrn cards *those* reps will generate (and so on, until 0).
+
+        // Every queue has a failure rate, and each failure will become a relrn
+        var toRelrn = counts.new // Assume every new card becomes 1 relrn
+        toRelrn += Math.ceil((1 - relrnRate) * counts.lrn).toInt()
+        toRelrn += Math.ceil((1 - revRate) * counts.rev).toInt()
+
+        // Use the accuracy rate of the relrn queue to estimate how many reps we will end up with if the cards
+        // currently in relrn continue to fail at that rate. Loop through the failures of the failures until we end up
+        // with no predicted failures left.
+
+        // Cap the lower end of the success rate to ensure the loop ends (it could be 0 if no revlog history, or
+        // negative for other reasons). 5% seems reasonable to ensure the loop doesn't iterate too much.
+        relrnRate = Math.max(relrnRate, 0.05)
+        var futureReps = 0
+        do {
+            // Truncation ensures the failure rate always decreases
+            val failures = ((1 - relrnRate) * toRelrn).toInt()
+            futureReps += failures
+            toRelrn = failures
+        } while (toRelrn > 1)
+        val futureRelrnTotal = relrnTime * futureReps
+        return Math.round((newTotal + relrnTotal + revTotal + futureRelrnTotal) / 60000).toInt()
+    }
+
+    /** Used only by V1/V2, and unit tests.
+     * @param card A random card
+     * @return The conf of the deck of the card.
+     */
+    fun _cardConf(card: Card): DeckConfig {
+        return col.decks.confForDid(card.did)
+    }
+
+    /*
+      Next time reports ********************************************************
+      ***************************************
+     */
+    /**
+     * Return the next interval for a card and ease as a string.
+     *
+     * For a given card and ease, this returns a string that shows when the card will be shown again when the
+     * specific ease button (AGAIN, GOOD etc.) is touched. This uses unit symbols like “s” rather than names
+     * (“second”), like Anki desktop.
+     *
+     * @param context The app context, used for localization
+     * @param card The card being reviewed
+     * @param ease The button number (easy, good etc.)
+     * @return A string like “1 min” or “1.7 mo”
+     */
+    open fun nextIvlStr(context: Context, card: Card, @BUTTON_TYPE ease: Int): String {
+        val ivl: Long = nextIvl(card, ease)
+        if (ivl == 0L) {
+            return context.getString(R.string.sched_end)
+        }
+        var s = Utils.timeQuantityNextIvl(context, ivl)
+        if (ivl < col.get_config_int("collapseTime")) {
+            s = context.getString(R.string.less_than_time, s)
+        }
+        return s
+    }
+
+    /**
+     * @param card A card
+     * @param ease a button, between 1 and answerButtons(card)
+     * @return the next interval for CARD, in seconds if ease is pressed.
+     */
+    abstract fun nextIvl(card: Card, @BUTTON_TYPE ease: Int): Long
+
+    companion object {
+        const val REPORT_LIMIT = 99999
+    }
+}
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
index 07f1c625b083..aea09bd69c5d 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
@@ -875,9 +875,6 @@ private int _adjRevIvl(@NonNull Card card, int idealIvl) {
 
     @Override
     public void rebuildDyn(long did) {
-        if (did == 0) {
-            did = getCol().getDecks().selected();
-        }
         Deck deck = getCol().getDecks().get(did);
         if (deck.isStd()) {
             Timber.e("error: deck is not a filtered deck");
@@ -916,10 +913,7 @@ private List<Long> _fillDyn(@NonNull Deck deck) {
 
 
     @Override
-    public void emptyDyn(long did, String lim) {
-        if (lim == null) {
-            lim = "did = " + did;
-        }
+    public void emptyDyn(String lim) {
         getCol().log(getCol().getDb().queryLongList("select id from cards where " + lim));
         // move out of cram queue
         getCol().getDb().execute(
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
index d20cfbe80d9f..5ec2494d49a1 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
@@ -21,18 +21,12 @@
 
 import android.app.Activity;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteConstraintException;
-import android.graphics.Typeface;
-import android.text.SpannableStringBuilder;
 import android.text.TextUtils;
-import android.text.style.StyleSpan;
 import android.util.Pair;
 
-import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.anki.R;
 import com.ichi2.async.CancelListener;
 import com.ichi2.async.CollectionTask;
 import com.ichi2.async.TaskManager;
@@ -46,9 +40,6 @@
 import com.ichi2.libanki.Deck;
 import com.ichi2.libanki.DeckConfig;
 
-import com.ichi2.libanki.backend.exception.BackendNotSupportedException;
-import com.ichi2.libanki.backend.model.SchedTimingToday;
-import com.ichi2.libanki.backend.model.SchedTimingTodayProto;
 import com.ichi2.libanki.utils.Time;
 import com.ichi2.libanki.utils.TimeManager;
 import com.ichi2.utils.Assert;
@@ -60,7 +51,6 @@
 
 import net.ankiweb.rsdroid.BackendFactory;
 import net.ankiweb.rsdroid.RustCleanup;
-import net.ankiweb.rsdroid.RustV1Cleanup;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
@@ -77,12 +67,11 @@
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
+import anki.scheduler.SchedTimingTodayResponse;
 import timber.log.Timber;
 
-import static com.ichi2.libanki.Consts.CARD_TYPE_RELEARNING;
-import static com.ichi2.libanki.Consts.QUEUE_TYPE_DAY_LEARN_RELEARN;
 import static com.ichi2.async.CancelListener.isCancelled;
-import static com.ichi2.libanki.sched.AbstractSched.UnburyType.*;
+import static com.ichi2.libanki.sched.BaseSched.UnburyType.*;
 import static com.ichi2.libanki.sched.Counts.Queue.*;
 import static com.ichi2.libanki.sched.Counts.Queue;
 import static com.ichi2.libanki.stats.Stats.SECONDS_PER_DAY;
@@ -113,9 +102,6 @@ public class SchedV2 extends AbstractSched {
 
     private int mNewCardModulus;
 
-    // The content change, not the array
-    protected final @NonNull double[] mEtaCache = new double[] { -1, -1, -1, -1, -1, -1 };
-
     // Queues
     protected final @NonNull SimpleCardQueue mNewQueue = new SimpleCardQueue(this);
 
@@ -131,6 +117,18 @@ public class SchedV2 extends AbstractSched {
     // Not in libanki
     protected @Nullable WeakReference<Activity> mContextReference;
 
+    interface LimitMethod {
+        int operation(Deck g);
+    }
+
+    /** Given a deck, compute the number of cards to see today, taking its pre-computed limit into consideration.  It
+     * considers either review or new cards. Used by WalkingCount to consider all subdecks and parents of a specific
+     * decks. */
+    
+    interface CountMethod {
+        int operation(long did, int lim);
+    }
+
     /**
      * The card currently being reviewed.
      *
@@ -433,6 +431,11 @@ public void _updateStats(@NonNull Card card, @NonNull String type, long cnt) {
 
 
     public void extendLimits(int newc, int rev) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.extendLimits(newc, rev);
+            return;
+        }
+
         Deck cur = getCol().getDecks().current();
         List<Deck> decks = getCol().getDecks().parents(cur.getLong("id"));
         decks.add(cur);
@@ -564,8 +567,9 @@ protected int _walkingCount(@NonNull LimitMethod limFn, @NonNull CountMethod cnt
     public @NonNull
     List<? extends TreeNode<? extends AbstractDeckTreeNode>> quickDeckDueTree() {
         if (!BackendFactory.getDefaultLegacySchema()) {
-            return BackendSchedKt.deckTreeLegacy(getCol().getNewBackend(), false);
+            return super.quickDeckDueTree();
         }
+
         // Similar to deckDueList
         ArrayList<DeckTreeNode> allDecksSorted = new ArrayList<>();
         for (JSONObject deck : getCol().getDecks().allSorted()) {
@@ -581,15 +585,15 @@ List<? extends TreeNode<? extends AbstractDeckTreeNode>> quickDeckDueTree() {
     @RustCleanup("once defaultLegacySchema is removed, cancelListener can be removed")
     public List<TreeNode<DeckDueTreeNode>> deckDueTree(@Nullable CancelListener cancelListener) {
         if (!BackendFactory.getDefaultLegacySchema()) {
-            return BackendSchedKt.deckTreeLegacy(getCol().getNewBackend(), true);
-        } else {
-            _checkDay();
-            List<DeckDueTreeNode> allDecksSorted = deckDueList(cancelListener);
-            if (allDecksSorted == null) {
-                return null;
-            }
-            return _groupChildren(allDecksSorted, true);
+            return super.deckDueTree(null);
         }
+
+        _checkDay();
+        List<DeckDueTreeNode> allDecksSorted = deckDueList(cancelListener);
+        if (allDecksSorted == null) {
+            return null;
+        }
+        return _groupChildren(allDecksSorted, true);
     }
 
     /**
@@ -1005,11 +1009,6 @@ public int _deckNewLimitSingle(@NonNull Deck g, boolean considerCurrentCard) {
         return lim;
     }
 
-    public int totalNewForCurrentDeck() {
-        return getCol().getDb().queryScalar("SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_NEW + " LIMIT ?)",
-                                        mReportLimit);
-    }
-
     /**
      * Learning queues *********************************************************** ************************************
      */
@@ -1447,12 +1446,6 @@ protected void _logLrn(@NonNull Card card, @Consts.BUTTON_TYPE int ease, @NonNul
         log(card.getId(), getCol().usn(), ease, ivl, lastIvl, card.getFactor(), card.timeTaken(), type);
     }
 
-    @Override
-    public int logCount() {
-        return getCol().getDb().queryScalar("SELECT count() FROM revlog");
-    }
-
-
     protected void log(long id, int usn, @Consts.BUTTON_TYPE int ease, int ivl, int lastIvl, int factor, int timeTaken, @Consts.REVLOG_TYPE int type) {
         try {
             getCol().getDb().execute("INSERT INTO revlog VALUES (?,?,?,?,?,?,?,?,?)",
@@ -1647,13 +1640,6 @@ protected boolean _fillRev(boolean allowSibling) {
     }
 
 
-    public int totalRevForCurrentDeck() {
-        return getCol().getDb().queryScalar(
-                "SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN " + _deckLimit() + "  AND queue = " + Consts.QUEUE_TYPE_REV + " AND due <= ? LIMIT ?)",
-                mToday, mReportLimit);
-    }
-
-
     /**
      * Answering a review card **************************************************
      * *********************************************
@@ -1769,7 +1755,7 @@ public int _fuzzedIvl(int ivl) {
     }
 
 
-    public @NonNull Pair<Integer, Integer> _fuzzIvlRange(int ivl) {
+    public static @NonNull Pair<Integer, Integer> _fuzzIvlRange(int ivl) {
         int fuzz;
         if (ivl < 2) {
             return new Pair<>(1, 1);
@@ -1867,11 +1853,13 @@ private int _earlyReviewIvl(@NonNull Card card, @Consts.BUTTON_TYPE int ease) {
       *****************************
      */
 
-    // Overridden, because upstream implements exactly the same method in two different way for unknown reason
+    @Override
     public void rebuildDyn(long did) {
-        if (did == 0) {
-            did = getCol().getDecks().selected();
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.rebuildDyn(did);
+            return;
         }
+
         Deck deck = getCol().getDecks().get(did);
         if (deck.isStd()) {
             Timber.e("error: deck is not a filtered deck");
@@ -1921,26 +1909,12 @@ private int _fillDyn(Deck deck) {
 
 
     public void emptyDyn(long did) {
-        emptyDyn(did, null);
-    }
-
-
-    // Overridden: other queue in V1
-    public void emptyDyn(long did, String lim) {
-        if (lim == null) {
-            lim = "did = " + did;
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.emptyDyn(did);
+            return;
         }
-        getCol().log(getCol().getDb().queryLongList("select id from cards where " + lim));
 
-        getCol().getDb().execute(
-                "update cards set did = odid, " + _restoreQueueWhenEmptyingSnippet() +
-                ", due = (case when odue>0 then odue else due end), odue = 0, odid = 0, usn = ? where " + lim,
-                getCol().usn());
-    }
-
-
-    public void remFromDyn(Iterable<Long> cids) {
-        emptyDyn(0, "id IN " + Utils.ids2str(cids) + " AND odid");
+        emptyDyn("did = " + did);
     }
 
     /**
@@ -2079,11 +2053,6 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
      * Tools ******************************************************************** ***************************
      */
 
-    public @NonNull DeckConfig _cardConf(@NonNull Card card) {
-        return getCol().getDecks().confForDid(card.getDid());
-    }
-
-
     // Overridden: different delays for filtered cards.
     protected @NonNull JSONObject _newConf(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
@@ -2136,18 +2105,12 @@ protected boolean _checkLeech(@NonNull Card card, @NonNull JSONObject conf) {
     }
 
 
-    public @NonNull String _deckLimit() {
-        return Utils.ids2str(getCol().getDecks().active());
-    }
-
-
     private boolean _previewingCard(@NonNull Card card) {
         DeckConfig conf = _cardConf(card);
 
         return conf.isDyn() && !conf.getBoolean("resched");
     }
 
-
     private int _previewDelay(@NonNull Card card) {
         return _cardConf(card).optInt("previewDelay", 10) * 60;
     }
@@ -2159,18 +2122,14 @@ private int _previewDelay(@NonNull Card card) {
      */
 
     /* Overridden: other way to count time*/
-    @RustCleanup("remove timing == null check once JavaBackend is removed")
     public void _updateCutoff() {
         int oldToday = mToday == null ? 0 : mToday;
 
-        SchedTimingToday timing = _timingToday();
+        SchedTimingTodayResponse timing = _timingToday();
 
-        if (timing == null) {
-            mToday = _daysSinceCreation();
-            mDayCutoff = _dayCutoff();
-        } else if (_new_timezone_enabled()) {
-            mToday = timing.days_elapsed();
-            mDayCutoff = timing.next_day_at();
+        if (_new_timezone_enabled()) {
+            mToday = timing.getDaysElapsed();
+            mDayCutoff = timing.getNextDayAt();
         } else {
             mToday = _daysSinceCreation();
             mDayCutoff = _dayCutoff();
@@ -2222,85 +2181,6 @@ private int _daysSinceCreation() {
         return (int) (((getTime().intTimeMS() - c.getTimeInMillis()) / 1000) / SECONDS_PER_DAY);
     }
 
-    private int _rolloverHour() {
-        return getCol().get_config("rollover", 4);
-    }
-
-    // New timezone handling
-    //////////////////////////////////////////////////////////////////////////
-
-    @Override
-    public boolean _new_timezone_enabled() {
-        return getCol().has_config_not_null("creationOffset");
-    }
-
-    @Nullable
-    @RustV1Cleanup("switch to non-legacy backend method")
-    private SchedTimingToday _timingToday() {
-        /*
-         * Obtains Timing information for the current day.
-         *
-         * @param createdSecs A UNIX timestamp of the collection creation time
-         * @param createdMinsWest The offset west of UTC at the time of creation (eg UTC+10 hours is -600)
-         * @param nowSecs timestamp of the current time
-         * @param nowMinsWest The current offset west of UTC
-         * @param rolloverHour The hour of the day the rollover happens (eg 4 for 4am)
-         * @return Timing information for the current day. See [SchedTimingToday].
-         */
-        try {
-            return new SchedTimingTodayProto(getCol().getBackend().schedTimingTodayLegacy(
-                    getCol().getCrt(),
-                    _creation_timezone_offset(),
-                    getTime().intTime(),
-                    _current_timezone_offset(),
-                    _rolloverHour()));
-        } catch (BackendNotSupportedException e) {
-            Timber.w(e);
-            return null;
-        }
-    }
-
-    public int _current_timezone_offset() throws BackendNotSupportedException {
-        if (getCol().getServer()) {
-            return getCol().get_config("localOffset", 0);
-        } else {
-            return localMinutesWest(getTime().intTime());
-        }
-    }
-
-    /**
-     * For the given timestamp, return minutes west of UTC in the local timezone.
-     *
-     * eg, Australia at +10 hours is -600.<br>
-     * Includes the daylight savings offset if applicable.
-     *
-     * @param timestampSeconds The timestamp in seconds
-     * @return minutes west of UTC in the local timezone
-     */
-    private int localMinutesWest(long timestampSeconds) {
-        return getCol().getBackend().localMinutesWestLegacy(timestampSeconds);
-
-    }
-
-    private int _creation_timezone_offset() {
-        return getCol().get_config("creationOffset", 0);
-    }
-    
-    public void useNewTimezoneCode() {
-       set_creation_offset();
-    }
-
-    @Override
-    public void set_creation_offset() {
-        int minsWest = localMinutesWest(getCol().getCrt());
-        getCol().set_config("creationOffset", minsWest);
-    }
-
-    @Override
-    public void clear_creation_offset() {
-        getCol().remove_config("creationOffset");
-    }
-
     protected void update(@NonNull Deck g) {
         for (String t : new String[] { "new", "rev", "lrn", "time" }) {
             String key = t + "Today";
@@ -2320,57 +2200,6 @@ public void _checkDay() {
         }
     }
 
-
-    /**
-     * Deck finished state ******************************************************
-     * *****************************************
-     */
-
-    public @NonNull CharSequence finishedMsg(@NonNull Context context) {
-        SpannableStringBuilder sb = new SpannableStringBuilder();
-        sb.append(context.getString(R.string.studyoptions_congrats_finished));
-        StyleSpan boldSpan = new StyleSpan(Typeface.BOLD);
-        sb.setSpan(boldSpan, 0, sb.length(), 0);
-        sb.append(_nextDueMsg(context));
-        // sb.append("\n\n");
-        // sb.append(_tomorrowDueMsg(context));
-        return sb;
-    }
-
-
-    public @NonNull String _nextDueMsg(@NonNull Context context) {
-        StringBuilder sb = new StringBuilder();
-        if (revDue()) {
-            sb.append("\n\n");
-            sb.append(context.getString(R.string.studyoptions_congrats_more_rev));
-        }
-        if (newDue()) {
-            sb.append("\n\n");
-            sb.append(context.getString(R.string.studyoptions_congrats_more_new));
-        }
-        if (haveBuried()) {
-            String now = " " + context.getString(R.string.sched_unbury_action);
-            sb.append("\n\n");
-            sb.append("").append(context.getString(R.string.sched_has_buried)).append(now);
-        }
-        if (getCol().getDecks().current().isStd()) {
-            sb.append("\n\n");
-            sb.append(context.getString(R.string.studyoptions_congrats_custom));
-        }
-        return sb.toString();
-    }
-
-
-    /** true if there are any rev cards due. */
-    public boolean revDue() {
-        return getCol().getDb()
-                .queryScalar(
-                        "SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_REV + " AND due <= ?"
-                                + " LIMIT 1",
-                        mToday) != 0;
-    }
-
-
     /** true if there are cards in learning, with review due the same
      * day, in the selected decks. */
     /* not in upstream anki. As revDue and newDue, it's used to check
@@ -2379,18 +2208,16 @@ public boolean revDue() {
      * immediately. It answers whether cards will be due later in the
      * same deck. */
     public boolean hasCardsTodayAfterStudyAheadLimit() {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            return super.hasCardsTodayAfterStudyAheadLimit();
+        }
+
         return getCol().getDb().queryScalar(
                 "SELECT 1 FROM cards WHERE did IN " + _deckLimit()
                 + " AND queue = " + Consts.QUEUE_TYPE_LRN + " LIMIT 1") != 0;
     }
 
 
-    /** true if there are any new cards due. */
-    public boolean newDue() {
-        return getCol().getDb().queryScalar("SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = " + Consts.QUEUE_TYPE_NEW + " LIMIT 1") != 0;
-    }
-
-
     public boolean haveBuriedSiblings() {
         return haveBuriedSiblings(getCol().getDecks().active());
     }
@@ -2420,6 +2247,10 @@ private boolean haveManuallyBuried(@NonNull List<Long> allDecks) {
 
 
     public boolean haveBuried() {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            return super.haveBuried();
+        }
+
         return haveManuallyBuried() || haveBuriedSiblings();
     }
 
@@ -2429,31 +2260,6 @@ public boolean haveBuried() {
       ***************************************
      */
 
-    /**
-     * Return the next interval for a card and ease as a string.
-     *
-     * For a given card and ease, this returns a string that shows when the card will be shown again when the
-     * specific ease button (AGAIN, GOOD etc.) is touched. This uses unit symbols like “s” rather than names
-     * (“second”), like Anki desktop.
-     *
-     * @param context The app context, used for localization
-     * @param card The card being reviewed
-     * @param ease The button number (easy, good etc.)
-     * @return A string like “1 min” or “1.7 mo”
-     */
-    public @NonNull String nextIvlStr(@NonNull Context context, @NonNull Card card, @Consts.BUTTON_TYPE int ease) {
-        long ivl = nextIvl(card, ease);
-        if (ivl == 0) {
-            return context.getString(R.string.sched_end);
-        }
-        String s = Utils.timeQuantityNextIvl(context, ivl);
-        if (ivl < getCol().get_config_int("collapseTime")) {
-            s = context.getString(R.string.less_than_time, s);
-        }
-        return s;
-    }
-
-
     /**
      * Return the next interval for CARD, in seconds.
      */
@@ -2533,21 +2339,6 @@ protected String _restoreQueueSnippet() {
                 "end)  ";
     }
 
-    /**
-     * ugly fix for suspended cards being unsuspended when filtered deck emptied
-     * https://github.com/ankitects/anki/commit/fe493e31c4d73ae2bbd0c4d8c6b835974c0e290c
-     */
-    @NonNull
-    protected String _restoreQueueWhenEmptyingSnippet() {
-        return "queue = (case when queue < 0 then queue" +
-                "    when type in (1," + CARD_TYPE_RELEARNING + ") then " +
-                "(case when (case when odue then odue else due end) > 1000000000 then 1 else " +
-                "    " + QUEUE_TYPE_DAY_LEARN_RELEARN + " end) " +
-                "else " +
-                "    type " +
-                "end)";
-    }
-
     /**
      * Overridden: in V1 only sibling buried exits.*/
     protected @NonNull String queueIsBuriedSnippet() {
@@ -2560,6 +2351,11 @@ protected String _restoreQueueWhenEmptyingSnippet() {
      * Overridden: in V1 remove from dyn and lrn
      */
     public void suspendCards(@NonNull long[] ids) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.suspendCards(ids);
+            return;
+        }
+
         getCol().log(ids);
         getCol().getDb().execute(
                 "UPDATE cards SET queue = " + Consts.QUEUE_TYPE_SUSPENDED + ", mod = ?, usn = ? WHERE id IN "
@@ -2572,6 +2368,11 @@ public void suspendCards(@NonNull long[] ids) {
      * Unsuspend cards
      */
     public void unsuspendCards(@NonNull long[] ids) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.unsuspendCards(ids);
+            return;
+        }
+
         getCol().log(ids);
         getCol().getDb().execute(
                 "UPDATE cards SET " + _restoreQueueSnippet() + ", mod = ?, usn = ?"
@@ -2583,6 +2384,11 @@ public void unsuspendCards(@NonNull long[] ids) {
     // Overridden: V1 also remove from dyns and lrn
     @VisibleForTesting
     public void buryCards(@NonNull long[] cids, boolean manual) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.buryCards(cids, manual);
+            return;
+        }
+
         int queue = manual ? Consts.QUEUE_TYPE_MANUALLY_BURIED : Consts.QUEUE_TYPE_SIBLING_BURIED;
         getCol().log(cids);
         getCol().getDb().execute("update cards set queue=?,mod=?,usn=? where id in " + Utils.ids2str(cids),
@@ -2591,6 +2397,11 @@ public void buryCards(@NonNull long[] cids, boolean manual) {
 
     @Override
     public void unburyCardsForDeck(long did, @NonNull UnburyType type) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.unburyCardsForDeck(did, type);
+            return;
+        }
+
         List<Long> dids = getCol().getDecks().childDids(did, getCol().getDecks().childMap());
         dids.add(did);
         unburyCardsForDeck(type, dids);
@@ -2625,6 +2436,11 @@ public void unburyCardsForDeck(@NonNull UnburyType type, @Nullable List<Long> al
      * @param nid The id of the targeted note.
      */
     public void buryNote(long nid) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.buryNote(nid);
+            return;
+        }
+
         long[] cids = Utils.collection2Array(getCol().getDb().queryLongList(
                 "SELECT id FROM cards WHERE nid = ? AND queue >= " + Consts.CARD_TYPE_NEW, nid));
         buryCards(cids);
@@ -2678,6 +2494,13 @@ protected void _burySiblings(@NonNull Card card) {
 
     /** Put cards at the end of the new queue. */
     public void forgetCards(@NonNull List<Long> ids) {
+        // Currently disabled, as this causes a breakage in some tests due to
+        // the AnkiDroid implementation not using nextPos to determine next position.
+        //        if (!BackendFactory.getDefaultLegacySchema()) {
+        //            super.forgetCards(ids);
+        //            return;
+        //        }
+
         remFromDyn(ids);
         getCol().getDb().execute("update cards set type=" + Consts.CARD_TYPE_NEW + ",queue=" + Consts.QUEUE_TYPE_NEW + ",ivl=0,due=0,odue=0,factor="+Consts.STARTING_FACTOR +
                 " where id in " + Utils.ids2str(ids));
@@ -2696,6 +2519,13 @@ public void forgetCards(@NonNull List<Long> ids) {
      * @param imax The maximum interval (inclusive)
      */
     public void reschedCards(@NonNull List<Long> ids, int imin, int imax) {
+        // Currently disabled, as this causes a breakage in the V2 tests due to
+        // the use of a mocked time.
+        //        if (!BackendFactory.getDefaultLegacySchema()) {
+        //            super.reschedCards(ids, imin, imax);
+        //            return;
+        //        }
+
         ArrayList<Object[]> d = new ArrayList<>(ids.size());
         int t = mToday;
         long mod = getTime().intTime();
@@ -2711,31 +2541,17 @@ public void reschedCards(@NonNull List<Long> ids, int imin, int imax) {
         getCol().log(ids);
     }
 
-
-    /**
-     * Completely reset cards for export.
-     */
-    public void resetCards(@NonNull Long[] ids) {
-        List<Long> nonNew = getCol().getDb().queryLongList(
-                "select id from cards where id in " + Utils.ids2str(ids) + " and (queue != " + Consts.QUEUE_TYPE_NEW + " or type != " + Consts.CARD_TYPE_NEW + ")");
-        getCol().getDb().execute("update cards set reps=0, lapses=0 where id in " + Utils.ids2str(nonNew));
-        forgetCards(nonNew);
-        //noinspection RedundantCast
-        getCol().log((Object[]) ids); // Cast useful to indicate to indicate how to interpret varargs
-    }
-
-
     /**
      * Repositioning new cards **************************************************
      * *********************************************
      */
 
-    public void sortCards(@NonNull List<Long> cids, int start) {
-        sortCards(cids, start, 1, false, false);
-    }
-
-
     public void sortCards(@NonNull List<Long> cids, int start, int step, boolean shuffle, boolean shift) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.sortCards(cids, start, step, shuffle, shift);
+            return;
+        }
+
         String scids = Utils.ids2str(cids);
         long now = getTime().intTime();
         ArrayList<Long> nids = new ArrayList<>(cids.size());
@@ -2786,38 +2602,24 @@ public void sortCards(@NonNull List<Long> cids, int start, int step, boolean shu
 
 
     public void randomizeCards(long did) {
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.randomizeCards(did);
+            return;
+        }
+
         List<Long> cids = getCol().getDb().queryLongList("select id from cards where type = " + Consts.CARD_TYPE_NEW + " and did = ?", did);
         sortCards(cids, 1, 1, true, false);
     }
 
 
     public void orderCards(long did) {
-        List<Long> cids = getCol().getDb().queryLongList("SELECT id FROM cards WHERE type = " + Consts.CARD_TYPE_NEW + " AND did = ? ORDER BY nid", did);
-        sortCards(cids, 1, 1, false, false);
-    }
-
-
-    public void resortConf(@NonNull DeckConfig conf) {
-        List<Long> dids = getCol().getDecks().didsForConf(conf);
-        for (long did : dids) {
-            if (conf.getJSONObject("new").getLong("order") == 0) {
-                randomizeCards(did);
-            } else {
-                orderCards(did);
-            }
+        if (!BackendFactory.getDefaultLegacySchema()) {
+            super.orderCards(did);
+            return;
         }
-    }
 
-
-    /**
-     * for post-import
-     */
-    public void maybeRandomizeDeck(long did) {
-        DeckConfig conf = getCol().getDecks().confForDid(did);
-        // in order due?
-        if (conf.getJSONObject("new").getInt("order") == Consts.NEW_CARDS_RANDOM) {
-            randomizeCards(did);
-        }
+        List<Long> cids = getCol().getDb().queryLongList("SELECT id FROM cards WHERE type = " + Consts.CARD_TYPE_NEW + " AND did = ? ORDER BY nid", did);
+        sortCards(cids, 1, 1, false, false);
     }
 
 
@@ -2941,126 +2743,6 @@ protected void decrReps() {
         mReps--;
     }
 
-
-    /**
-     * Counts
-     */
-
-    public int cardCount() {
-        String dids = _deckLimit();
-        return getCol().getDb().queryScalar("SELECT count() FROM cards WHERE did IN " + dids);
-    }
-
-    /**
-     * Return an estimate, in minutes, for how long it will take to complete all the reps in {@code counts}.
-     *
-     * The estimator builds rates for each queue type by looking at 10 days of history from the revlog table. For
-     * efficiency, and to maintain the same rates for a review session, the rates are cached and reused until a
-     * reload is forced.
-     *
-     * Notes:
-     * - Because the revlog table does not record deck IDs, the rates cannot be reduced to a single deck and thus cover
-     * the whole collection which may be inaccurate for some decks.
-     * - There is no efficient way to determine how many lrn cards are generated by each new card. This estimator
-     * assumes 1 card is generated as a compromise.
-     * - If there is no revlog data to work with, reasonable defaults are chosen as a compromise to predicting 0 minutes.
-     *
-     * @param counts An array of [new, lrn, rev] counts from the scheduler's counts() method.
-     * @param reload Force rebuild of estimator rates using the revlog.
-     */
-    // Overridden because of the different queues in SchedV1 and V2
-    public int eta(Counts counts, boolean reload) {
-        double newRate;
-        double newTime;
-        double revRate;
-        double revTime;
-        double relrnRate;
-        double relrnTime;
-
-        if (reload || mEtaCache[0] == -1) {
-            try (Cursor cur = getCol()
-                        .getDb()
-                        .query("select "
-                                + "avg(case when type = " + Consts.CARD_TYPE_NEW + " then case when ease > 1 then 1.0 else 0.0 end else null end) as newRate, avg(case when type = " + Consts.CARD_TYPE_NEW + " then time else null end) as newTime, "
-                                + "avg(case when type in (" + Consts.CARD_TYPE_LRN + ", " + Consts.CARD_TYPE_RELEARNING + ") then case when ease > 1 then 1.0 else 0.0 end else null end) as revRate, avg(case when type in (" + Consts.CARD_TYPE_LRN + ", " + Consts.CARD_TYPE_RELEARNING + ") then time else null end) as revTime, "
-                                + "avg(case when type = " + Consts.CARD_TYPE_REV + " then case when ease > 1 then 1.0 else 0.0 end else null end) as relrnRate, avg(case when type = " + Consts.CARD_TYPE_REV + " then time else null end) as relrnTime "
-                                + "from revlog where id > "
-                                + "?",
-                               (getCol().getSched().getDayCutoff() - (10 * SECONDS_PER_DAY)) * 1000)) {
-                if (!cur.moveToFirst()) {
-                    return -1;
-                }
-
-                newRate = cur.getDouble(0);
-                newTime = cur.getDouble(1);
-                revRate = cur.getDouble(2);
-                revTime = cur.getDouble(3);
-                relrnRate = cur.getDouble(4);
-                relrnTime = cur.getDouble(5);
-
-                if (!cur.isClosed()) {
-                    cur.close();
-                }
-
-            }
-
-            // If the collection has no revlog data to work with, assume a 20 second average rep for that type
-            newTime = newTime == 0 ? 20000 : newTime;
-            revTime = revTime == 0 ? 20000 : revTime;
-            relrnTime = relrnTime == 0 ? 20000 : relrnTime;
-            // And a 100% success rate
-            newRate = newRate == 0 ? 1 : newRate;
-            revRate = revRate == 0 ? 1 : revRate;
-            relrnRate = relrnRate == 0 ? 1 : relrnRate;
-
-            mEtaCache[0] = newRate;
-            mEtaCache[1] = newTime;
-            mEtaCache[2] = revRate;
-            mEtaCache[3] = revTime;
-            mEtaCache[4] = relrnRate;
-            mEtaCache[5] = relrnTime;
-
-        } else {
-            newRate = mEtaCache[0];
-            newTime = mEtaCache[1];
-            revRate= mEtaCache[2];
-            revTime = mEtaCache[3];
-            relrnRate = mEtaCache[4];
-            relrnTime = mEtaCache[5];
-        }
-
-        // Calculate the total time for each queue based on the historical average duration per rep
-        double newTotal = newTime * counts.getNew();
-        double relrnTotal = relrnTime * counts.getLrn();
-        double revTotal = revTime * counts.getRev();
-
-        // Now we have to predict how many additional relrn cards are going to be generated while reviewing the above
-        // queues, and how many relrn cards *those* reps will generate (and so on, until 0).
-
-        // Every queue has a failure rate, and each failure will become a relrn
-        int toRelrn = counts.getNew(); // Assume every new card becomes 1 relrn
-        toRelrn += Math.ceil((1 - relrnRate) * counts.getLrn());
-        toRelrn += Math.ceil((1 - revRate) * counts.getRev());
-
-        // Use the accuracy rate of the relrn queue to estimate how many reps we will end up with if the cards
-        // currently in relrn continue to fail at that rate. Loop through the failures of the failures until we end up
-        // with no predicted failures left.
-
-        // Cap the lower end of the success rate to ensure the loop ends (it could be 0 if no revlog history, or
-        // negative for other reasons). 5% seems reasonable to ensure the loop doesn't iterate too much.
-        relrnRate = Math.max(relrnRate, 0.05);
-        int futureReps = 0;
-        do {
-            // Truncation ensures the failure rate always decreases
-            int failures = (int) ((1 - relrnRate) * toRelrn);
-            futureReps += failures;
-            toRelrn = failures;
-        } while (toRelrn > 1);
-        double futureRelrnTotal = relrnTime * futureReps;
-
-        return (int) Math.round((newTotal + relrnTotal + revTotal + futureRelrnTotal) / 60000);
-    }
-
     /**
      * Change the counts to reflect that `card` should not be counted anymore. In practice, it means that the card has
      * been sent to the reviewer. Either through `getCard()` or through `undo`. Assumes that card's queue has not yet
@@ -3150,7 +2832,8 @@ public Time getTime() {
     }
 
 
-    /** End #5666 */
+    /** Notifies the scheduler that there is no more current card. This is the case when a card is answered, when the
+     * scheduler is reset... #5666 */
     public void discardCurrentCard() {
         mCurrentCard = null;
         mCurrentCardParentsDid = null;
diff --git a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.kt b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.kt
index 5c534987ce14..a254c66c1164 100644
--- a/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.kt
+++ b/AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.kt
@@ -1015,16 +1015,16 @@ class SchedV2Test : RobolectricTest() {
         Assert.assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.queue)
         col.reset()
         assertNull(card)
-        col.sched.unburyCardsForDeck(AbstractSched.UnburyType.MANUAL)
+        col.sched.unburyCardsForDeck(BaseSched.UnburyType.MANUAL)
         c.load()
         Assert.assertEquals(QUEUE_TYPE_NEW, c.queue)
         c2.load()
         Assert.assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.queue)
-        col.sched.unburyCardsForDeck(AbstractSched.UnburyType.SIBLINGS)
+        col.sched.unburyCardsForDeck(BaseSched.UnburyType.SIBLINGS)
         c2.load()
         Assert.assertEquals(QUEUE_TYPE_NEW, c2.queue)
         col.sched.buryCards(longArrayOf(c.id, c2.id))
-        col.sched.unburyCardsForDeck(AbstractSched.UnburyType.ALL)
+        col.sched.unburyCardsForDeck(BaseSched.UnburyType.ALL)
         col.reset()
         Assert.assertEquals(Counts(2, 0, 0), col.sched.counts())
     }
diff --git a/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java b/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java
index a6f22c44eee3..344cd9daf25e 100644
--- a/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java
+++ b/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java
@@ -83,7 +83,7 @@ public static String without_unicode_isolation(String s) {
     }
 
     public static boolean checkRevIvl(Collection col, Card c, int targetIvl) {
-        Pair<Integer, Integer> min_max = ((SchedV2)col.getSched())._fuzzIvlRange(targetIvl);
+        Pair<Integer, Integer> min_max = SchedV2._fuzzIvlRange(targetIvl);
         return min_max.first <= c.getIvl() && c.getIvl() <= min_max.second;
     }
 
