diff --git a/src/com/ichi2/anki/AnkiDroidApp.java b/src/com/ichi2/anki/AnkiDroidApp.java
index 341bda7b85b8..a6ef26053172 100644
--- a/src/com/ichi2/anki/AnkiDroidApp.java
+++ b/src/com/ichi2/anki/AnkiDroidApp.java
@@ -126,6 +126,12 @@ public static String getStorageDirectory() {
         return Environment.getExternalStorageDirectory().getAbsolutePath();
     }
 
+
+    public static String getCollectionPath() {
+		String deckPath = PrefSettings.getSharedPrefs(sInstance.getApplicationContext()).getString("deckPath", AnkiDroidApp.getDefaultAnkiDroidDirectory());
+		return deckPath + AnkiDroidApp.COLLECTION_PATH;
+	}
+
     public static String getDefaultAnkiDroidDirectory() {
         return getStorageDirectory() + "/AnkiDroid";
     }
diff --git a/src/com/ichi2/anki/CardEditor.java b/src/com/ichi2/anki/CardEditor.java
index a2ca34972227..197fbe362a65 100644
--- a/src/com/ichi2/anki/CardEditor.java
+++ b/src/com/ichi2/anki/CardEditor.java
@@ -966,7 +966,7 @@ public void onClick(View v) {
 			builder.setTitle(R.string.deck);
 			for (JSONObject d : decks) {
 				try {
-					dialogDeckItems.add(DeckPicker.readableName(d.getString("name").split("::")));
+					dialogDeckItems.add(DeckPicker.readableDeckName(d.getString("name").split("::")));
 					dialogDeckIds.add(d.getLong("id"));
 				} catch (JSONException e) {
 					throw new RuntimeException(e);
diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index d6cd7261e1c9..ebafd30717b1 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -932,13 +932,8 @@ protected void onResume() {
 		}
 	}
 
-	private String getCollectionPath() {
-		String deckPath = PrefSettings.getSharedPrefs(getBaseContext()).getString("deckPath", AnkiDroidApp.getDefaultAnkiDroidDirectory());
-		return deckPath + AnkiDroidApp.COLLECTION_PATH;
-	}
-
 	private void loadCollection() {
-		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler, new DeckTask.TaskData(Collection.currentCollection(), getCollectionPath()));
+		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPEN_COLLECTION, mOpenCollectionHandler, new DeckTask.TaskData(Collection.currentCollection(), AnkiDroidApp.getCollectionPath()));
 	}
 
 	private void loadCounts() {
@@ -1052,7 +1047,7 @@ protected void onStop() {
 		if (!mDontSaveOnStop) {
 			WidgetStatus.update(this);
 			if (isFinishing()) {
-		        UIUtils.saveCollectionInBackground(mCol);
+				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseCollectionHandler, new TaskData(mCol));
 			}
 		}
 	}
@@ -1784,7 +1779,6 @@ public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuIn
     public boolean onKeyDown(int keyCode, KeyEvent event)  {
         if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
         	Log.i(AnkiDroidApp.TAG, "DeckPicker - onBackPressed()");
-			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseCollectionHandler, new TaskData(mCol));
         	finish();
             if (UIUtils.getApiLevel() > 4) {
                 ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.NONE);
@@ -1809,14 +1803,23 @@ private void registerExternalStorageListener() {
 			mUnmountReceiver = new BroadcastReceiver() {
 				@Override
 				public void onReceive(Context context, Intent intent) {
+					if (intent.getAction().equals(Intent.ACTION_MEDIA_EJECT)) {
+						if (mCol != null) {
+							mCol.close();
+						}
+			        	showDialog(DIALOG_SD_CARD_NOT_MOUNTED);
+					} else if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {
+			        	showDialog(DIALOG_LOAD_FAILED);
+					}
+
 		        	showDialog(DIALOG_SD_CARD_NOT_MOUNTED);
 				}
 			};
 			IntentFilter iFilter = new IntentFilter();
-			iFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
 
 			// ACTION_MEDIA_EJECT is never invoked (probably due to an android bug
-//			iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
+			iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
+			iFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
 			iFilter.addDataScheme("file");
 			registerReceiver(mUnmountReceiver, iFilter);
 		}
@@ -2108,7 +2111,7 @@ public void onPostExecute(TaskData result) {
 			@Override
 			public void onProgressUpdate(TaskData... values) {
 			}
-		}, new DeckTask.TaskData(getCollectionPath()));
+		}, new DeckTask.TaskData(AnkiDroidApp.getCollectionPath()));
     }
 
 
@@ -2194,7 +2197,7 @@ private void updateDecksList(TreeSet<Object[]> decks, int eta, int count) {
         for (Object[] d : decks) {
         	HashMap<String, String> m = new HashMap<String, String>();
         	String[] name = ((String[])d[0]);
-        	m.put("name", readableName(name));
+        	m.put("name", readableDeckName(name));
         	m.put("did", ((Long)d[1]).toString());
         	m.put("new", ((Integer)d[2]).toString());
         	m.put("lrn", ((Integer)d[3]).toString());
@@ -2332,7 +2335,7 @@ public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float ve
 //		// }
 //	}
 
-    public static String readableName(String[] name) {
+    public static String readableDeckName(String[] name) {
     	int len = name.length;
     	StringBuilder sb = new StringBuilder();
     	for (int i = 0; i < len; i++) {
diff --git a/src/com/ichi2/anki/DeckStatus.java b/src/com/ichi2/anki/DeckStatus.java
deleted file mode 100644
index bcf988ddff06..000000000000
--- a/src/com/ichi2/anki/DeckStatus.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.ichi2.anki;import com.ichi2.anki2.R;
-
-/**
- * Simple class to hold the current status of a deck.
- */
-public class DeckStatus {
-    public String mDeckPath;
-    public String mDeckName;
-    public int mNewCards;
-    public int mDueCards;
-    public int mFailedCards;
-    public int mEta;
-    public int mTime;
-
-    public DeckStatus(String deckPath, String deckName, int newCards, int dueCards,
-            int failedCards, int eta, int time) {
-        mDeckPath = deckPath;
-        mDeckName = deckName;
-        mNewCards = newCards;
-        mDueCards = dueCards;
-        mFailedCards = failedCards;
-        mEta = eta;
-        mTime = time;
-    }
-}
\ No newline at end of file
diff --git a/src/com/ichi2/anki/MetaDB.java b/src/com/ichi2/anki/MetaDB.java
index b04eb8753dc6..1622a81855d9 100644
--- a/src/com/ichi2/anki/MetaDB.java
+++ b/src/com/ichi2/anki/MetaDB.java
@@ -1,5 +1,6 @@
 package com.ichi2.anki;import com.ichi2.anki2.R;
 import com.ichi2.libanki.Utils;
+import com.ichi2.widget.DeckStatus;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -73,13 +74,14 @@ private static void openDB(Context context) {
                             + "dictionary INTEGER)");
             mMetaDb.execSQL(
                     "CREATE TABLE IF NOT EXISTS widgetStatus ("
-                    + "deckPath TEXT NOT NULL PRIMARY KEY, "
+                    + "deckId INTEGER NOT NULL PRIMARY KEY, "
+                    + "depth INTEGER NOT NULL, "
                     + "deckName TEXT NOT NULL, "
                     + "newCards INTEGER NOT NULL, "
+                    + "lrnCards INTEGER NOT NULL, "
                     + "dueCards INTEGER NOT NULL, "
-                    + "failedCards INTEGER NOT NULL, "
-            		+ "eta INTEGER NOT NULL, "
-            		+ "time INTEGER NOT NULL)");
+                    + "progress INTEGER NOT NULL, "
+            		+ "eta INTEGER NOT NULL)");
             mMetaDb.execSQL(
                     "CREATE TABLE IF NOT EXISTS intentInformation ("
                     + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
@@ -397,35 +399,35 @@ public static void storeLookupDictionary(Context context, String deckPath, int d
      * @return an array of {@link DeckStatus} objects, each representing the status of one of the known decks
      */
     public static DeckStatus[] getWidgetStatus(Context context) {
-        openDBIfClosed(context);
-        Cursor cursor = null;
-        try {
-            cursor = mMetaDb.query("widgetStatus",
-                    new String[]{"deckPath", "deckName", "newCards", "dueCards", "failedCards", "eta", "time"},
-                    null, null, null, null, "deckName");
-            int count = cursor.getCount();
-            DeckStatus[] decks = new DeckStatus[count];
-            for(int index = 0; index < count; ++index) {
-                if (!cursor.moveToNext()) {
-                    throw new SQLiteException("cursor count was incorrect");
-                }
-                decks[index] = new DeckStatus(
-                        cursor.getString(cursor.getColumnIndexOrThrow("deckPath")),
-                        cursor.getString(cursor.getColumnIndexOrThrow("deckName")),
-                        cursor.getInt(cursor.getColumnIndexOrThrow("newCards")),
-                        cursor.getInt(cursor.getColumnIndexOrThrow("dueCards")),
-                        cursor.getInt(cursor.getColumnIndexOrThrow("failedCards")),
-                        cursor.getInt(cursor.getColumnIndexOrThrow("eta")),
-                		cursor.getInt(cursor.getColumnIndexOrThrow("time")));
-            }
-            return decks;
-        } catch (SQLiteException e) {
-            Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
-        } finally {
-            if (cursor != null && !cursor.isClosed()) {
-                cursor.close();
-            }
-        }
+//        openDBIfClosed(context);
+//        Cursor cursor = null;
+//        try {
+//            cursor = mMetaDb.query("widgetStatus",
+//                    new String[]{"deckPath", "deckName", "newCards", "dueCards", "failedCards", "eta", "time"},
+//                    null, null, null, null, "deckName");
+//            int count = cursor.getCount();
+//            DeckStatus[] decks = new DeckStatus[count];
+//            for(int index = 0; index < count; ++index) {
+//                if (!cursor.moveToNext()) {
+//                    throw new SQLiteException("cursor count was incorrect");
+//                }
+//                decks[index] = new DeckStatus(
+//                        cursor.getString(cursor.getColumnIndexOrThrow("deckPath")),
+//                        cursor.getString(cursor.getColumnIndexOrThrow("deckName")),
+//                        cursor.getInt(cursor.getColumnIndexOrThrow("newCards")),
+//                        cursor.getInt(cursor.getColumnIndexOrThrow("dueCards")),
+//                        cursor.getInt(cursor.getColumnIndexOrThrow("failedCards")),
+//                        cursor.getInt(cursor.getColumnIndexOrThrow("eta")),
+//                		cursor.getInt(cursor.getColumnIndexOrThrow("time")));
+//            }
+//            return decks;
+//        } catch (SQLiteException e) {
+//            Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
+//        } finally {
+//            if (cursor != null && !cursor.isClosed()) {
+//                cursor.close();
+//            }
+//        }
         return new DeckStatus[0];
     }
 
@@ -433,25 +435,26 @@ public static DeckStatus[] getWidgetStatus(Context context) {
     /**
      * Return the current status of the widget.
      *
-     * @return an int array, containing due, time, eta, currentDeckdue
+     * @return an int array, containing due, progress, eta
      */
     public static int[] getWidgetSmallStatus(Context context) {
         openDBIfClosed(context);
         Cursor cursor = null;
         int due = 0;
+        int progress = 0;
         int eta = 0;
-        int time = 0;
         boolean noDeck = true;
         try {
             cursor = mMetaDb.query("widgetStatus",
-                    new String[]{"dueCards", "failedCards", "newCards", "time", "eta"},
+                    new String[]{"depth", "newCards", "lrnCards", "dueCards", "progress", "eta"},
                     null, null, null, null, null);
             while (cursor.moveToNext()) {
             	noDeck = false;
-            	int d = cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
-            	due += d;
-            	time += cursor.getInt(3);
-            	eta += cursor.getInt(4);
+            	if (cursor.getInt(0) == 1) {
+                	due += cursor.getInt(1) + cursor.getInt(2) + cursor.getInt(3);
+                	progress = cursor.getInt(4);
+                	eta = cursor.getInt(5);            		
+            	}
             }
         } catch (SQLiteException e) {
             Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
@@ -460,7 +463,7 @@ public static int[] getWidgetSmallStatus(Context context) {
                 cursor.close();
             }
         }
-        return new int[]{noDeck ? -1 : due, time, eta};
+        return new int[]{noDeck ? -1 : due, progress, eta};
     }
 
 
@@ -496,17 +499,20 @@ public static int getNotificationStatus(Context context) {
     public static void storeWidgetStatus(Context context, DeckStatus[] decks) {
         openDBIfClosed(context);
         try {
-            mMetaDb.beginTransaction();
-            // First clear all the existing content.
-            mMetaDb.execSQL("DELETE FROM widgetStatus");
-            for (DeckStatus deck : decks) {
-                mMetaDb.execSQL("INSERT INTO widgetStatus(deckPath, deckName, newCards, dueCards, failedCards, eta, time) "
-                        + "VALUES (?, ?, ?, ?, ?, ?, ?)",
-                        new Object[]{deck.mDeckPath, deck.mDeckName, deck.mNewCards, deck.mDueCards, deck.mFailedCards, deck.mEta, deck.mTime}
-                        );
+        	mMetaDb.beginTransaction();
+            try {
+                // First clear all the existing content.
+                mMetaDb.execSQL("DELETE FROM widgetStatus");
+                for (DeckStatus deck : decks) {
+                    mMetaDb.execSQL("INSERT INTO widgetStatus(deckId, depth, deckName, newCards, lrnCards, dueCards, progress, eta) "
+                            + "VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
+                            new Object[]{deck.mDeckId, deck.mDepth, deck.mDeckName, deck.mNewCards, deck.mLrnCards, deck.mDueCards, deck.mProgress, deck.mEta}
+                            );
+                }
+                mMetaDb.setTransactionSuccessful();
+            } finally {
+                mMetaDb.endTransaction();            	
             }
-            mMetaDb.setTransactionSuccessful();
-            mMetaDb.endTransaction();
         } catch (IllegalStateException e) {
             Log.e(AnkiDroidApp.TAG, "MetaDB.storeWidgetStatus: failed", e);
         } catch (SQLiteException e) {
diff --git a/src/com/ichi2/async/DeckTask.java b/src/com/ichi2/async/DeckTask.java
index f8f131559f2c..be826f6fc487 100644
--- a/src/com/ichi2/async/DeckTask.java
+++ b/src/com/ichi2/async/DeckTask.java
@@ -44,6 +44,7 @@
 import com.ichi2.libanki.Sched;
 import com.ichi2.libanki.Stats;
 import com.ichi2.libanki.Utils;
+import com.ichi2.widget.WidgetStatus;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import android.content.Context;
@@ -421,17 +422,17 @@ private TaskData doInBackgroundOpenCollection(TaskData... params) {
         if (col == null) {
         	return new TaskData(col);
         }
-	try {
+        try {
 	        if (reset) {
         		col.getSched().reset();
         	}
 	    	// load decks
         	TreeSet<Object[]> decks = col.getSched().deckDueTree(false);
         	return new TaskData(col, decks, 0);
-	} catch (RuntimeException e) {
+        } catch (RuntimeException e) {
 		col = null;
         	return new TaskData(col);
-	}
+        }
     }
 
 
@@ -439,20 +440,7 @@ private TaskData doInBackgroundLoadDeckCounts(TaskData... params) {
     	Collection col = params[0].getCollection();
        	try {
 	    	Sched sched = col.getSched();
-	    	// check if new day has rolled over and reset counts if yes
-	    	if (Utils.now() > sched.getDayCutoff()) {
-	    		sched._updateCutoff();
-	    	}
-	       	TreeSet<Object[]> decks = sched.deckDueTree(true);
-	       	int[] counts = new int[]{0, 0, 0};
-	       	for (Object[] deck : decks) {
-	       		if (((String[])deck[0]).length == 1) {
-	       			counts[0] += (Integer) deck[2];
-	       			counts[1] += (Integer) deck[3];
-	       			counts[2] += (Integer) deck[4];
-	       		}
-	       	}
-       		return new TaskData(new Object[]{decks, sched.eta(counts), col.cardCount()});
+       		return new TaskData(sched.deckCounts());
        	} catch (RuntimeException e) {
        		return null;
        	}
@@ -641,13 +629,14 @@ private TaskData doInBackgroundCloseCollection(TaskData... params) {
     	Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseCollection");
     	Collection col = params[0].getCollection();
     	if (col != null) {
-		try {
-	        	String path = col.getPath();
+    		WidgetStatus.waitToFinish();
+    		try {
+            	String path = col.getPath();
         		col.close(true);
         		BackupManager.performBackup(path);
-		} catch (RuntimeException e) {
-			Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseCollection: error occurred - collection not properly closed");
-		}
+    		} catch (RuntimeException e) {
+    			Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseCollection: error occurred - collection not properly closed");
+    		}
     	}
     	return null;
     }
diff --git a/src/com/ichi2/libanki/Sched.java b/src/com/ichi2/libanki/Sched.java
index 932e7e6fc2b7..1c077d9615fb 100644
--- a/src/com/ichi2/libanki/Sched.java
+++ b/src/com/ichi2/libanki/Sched.java
@@ -27,6 +27,7 @@
 import android.util.Log;
 
 import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.async.DeckTask.TaskData;
 
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -411,6 +412,24 @@ private int _walkingCount(LinkedList<Long> dids, Method limFn, Method cntFn) {
 	 * *******************************
 	 */
 
+	/** LIBANKI: not in libanki */
+	public Object[] deckCounts() {
+    	// check if new day has rolled over and reset counts if yes
+    	if (Utils.now() > mDayCutoff) {
+    		_updateCutoff();
+    	}
+       	TreeSet<Object[]> decks = deckDueTree(true);
+       	int[] counts = new int[]{0, 0, 0};
+       	for (Object[] deck : decks) {
+       		if (((String[])deck[0]).length == 1) {
+       			counts[0] += (Integer) deck[2];
+       			counts[1] += (Integer) deck[3];
+       			counts[2] += (Integer) deck[4];
+       		}
+       	}
+   		return new Object[]{decks, eta(counts), mCol.cardCount()};
+	}
+
 	/**
 	 * Returns [deckname, did, new, lrn, rev]
 	 */
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetMedium.java b/src/com/ichi2/widget/AnkiDroidWidgetMedium.java
index bf6b273a7f4b..744e4710ca29 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetMedium.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetMedium.java
@@ -15,7 +15,6 @@
 package com.ichi2.widget;
 
 import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.anki.DeckStatus;
 import com.ichi2.anki2.R;
 import com.ichi2.anki.StudyOptions;
 import com.tomgibara.android.veecheck.util.PrefSettings;
@@ -116,7 +115,7 @@ public static class UpdateService extends Service {
         private CharSequence getDeckStatusString(DeckStatus deck) {
             SpannableStringBuilder sb = new SpannableStringBuilder();
 
-            SpannableString red = new SpannableString(Integer.toString(deck.mFailedCards));
+            SpannableString red = new SpannableString(Integer.toString(deck.mLrnCards));
             red.setSpan(new ForegroundColorSpan(Color.RED), 0, red.length(),
                     Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
 
@@ -244,7 +243,7 @@ public void onReceive(Context context, Intent intent) {
                 updateViews.setTextViewText(R.id.anki_droid_status,
                     getDeckStatusString(deckStatus));
                 PendingIntent openPendingIntent = getOpenPendingIntent(context,
-                    deckStatus.mDeckPath);
+                    "");//deckStatus.mDeckPath);
                 updateViews.setOnClickPendingIntent(R.id.anki_droid_name, openPendingIntent);
                 updateViews.setOnClickPendingIntent(R.id.anki_droid_status, openPendingIntent);
                 // Enable or disable the prev and next buttons.
@@ -293,8 +292,8 @@ private void updateDueDecks() {
             }
             dueCardsCount = 0;
             for (DeckStatus deck : decks) {
-                if (deck.mDueCards + deck.mFailedCards + deck.mNewCards > 0) {
-                  dueCardsCount += deck.mDueCards + deck.mFailedCards + deck.mNewCards;
+                if (deck.mDueCards + deck.mLrnCards + deck.mNewCards > 0) {
+                  dueCardsCount += deck.mDueCards + deck.mLrnCards + deck.mNewCards;
                   dueDecks.add(deck);
                 }
             }
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetSmall.java b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
index 111019ac6787..9b9d395d001e 100644
--- a/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
@@ -66,8 +66,8 @@ public static class UpdateService extends Service {
         /** The cached number of total due cards. */
         private int dueCardsCount;
 
-        /** The cached amount of today's yes reps. */
-        private int reps;
+        /** Today's total progress */
+        private int progress;
 
         /** The cached estimated reviewing time. */
         private int eta;
@@ -137,13 +137,8 @@ public void onReceive(Context context, Intent intent) {
                 	int[] counts = WidgetStatus.fetchSmall(context);
                 	
                 	dueCardsCount = counts[0];
-                	reps = counts[1];
+                	progress = counts[1];
                 	eta = counts[2];
-                	int totalreps = reps + dueCardsCount;
-                	int progress = 0;
-                	if (totalreps != 0) {
-                		progress = (int) Math.round((100.0d * reps) / totalreps);
-                	}
         			if (dueCardsCount <= 0) {
         				if (dueCardsCount == 0) {
     		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.VISIBLE);        					
diff --git a/src/com/ichi2/widget/WidgetStatus.java b/src/com/ichi2/widget/WidgetStatus.java
index c4dc34b3f98c..644146be8e9e 100644
--- a/src/com/ichi2/widget/WidgetStatus.java
+++ b/src/com/ichi2/widget/WidgetStatus.java
@@ -16,9 +16,11 @@
 
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.BackupManager;
-import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.DeckPicker;
 import com.ichi2.anki.MetaDB;
 import com.ichi2.anki.services.NotificationService;
+import com.ichi2.async.DeckTask.TaskData;
+import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Decks;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
@@ -33,6 +35,8 @@
 import java.io.FileFilter;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.TreeSet;
 
 /**
  * The status of the widget.
@@ -45,6 +49,7 @@ public final class WidgetStatus {
 	private static boolean smallWidget = false;
 	private static boolean bigWidget = false;
 	private static boolean notification = false;
+
 	private static DeckStatus sDeckStatus;
 	private static AsyncTask<Context,Void,Context> sUpdateDeckStatusAsyncTask;
 
@@ -87,10 +92,20 @@ public static void update(Context context, DeckStatus deckStatus, boolean update
             sUpdateDeckStatusAsyncTask = new UpdateDeckStatusAsyncTask();
             sUpdateDeckStatusAsyncTask.execute(context);
         } else {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): not enabled");
+            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): already running or not enabled");
         }
     }
 
+    public static void waitToFinish() {
+        try {
+            if ((sUpdateDeckStatusAsyncTask != null) && (sUpdateDeckStatusAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
+            	Log.i(AnkiDroidApp.TAG, "WidgetStatus: wait to finish");
+            	sUpdateDeckStatusAsyncTask.get();
+            }
+        } catch (Exception e) {
+            return;
+        }
+    }
 
     /** Returns the status of each of the decks. */
     public static DeckStatus[] fetch(Context context) {
@@ -123,7 +138,8 @@ public static DeckStatus getDeckStatus(Decks deck) {
 //            eta = deck.getETA();
 //        }
 //        return new DeckStatus(deck.getDeckPath(), deck.getDeckName(), newCards, dueCards, failedCards, eta, reps);
-        return new DeckStatus("aaa", "aaa", 1, 1, 1, 1, 1);
+//        return new DeckStatus("aaa", "aaa", 1, 1, 1, 1, 1);
+        return null;
     }
 
 
@@ -142,89 +158,47 @@ protected Context doInBackground(Context... params) {
             }
 
             // For the deck information
-            ArrayList<DeckStatus> decks;
-
-            if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
-            	decks = new ArrayList<DeckStatus>(mDecks.length);
-            		for (DeckStatus m : mDecks) {
-            			if (m.mDeckPath.equals(sDeckStatus.mDeckPath)) {
-            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + sDeckStatus.mDeckPath);
-            				decks.add(sDeckStatus);
-            			} else {
-            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
-            				decks.add(m);
-            			}
+            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>();
+
+//            if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
+//            	decks = new ArrayList<DeckStatus>(mDecks.length);
+//            		for (DeckStatus m : mDecks) {
+//            			if (m.mDeckPath.equals(sDeckStatus.mDeckPath)) {
+//            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + sDeckStatus.mDeckPath);
+//            				decks.add(sDeckStatus);
+//            			} else {
+//            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
+//            				decks.add(m);
+//            			}
+//            		}
+//            } else {
+            	try {
+            		Collection col = Collection.currentCollection();
+            		Object[] di;
+            		float progress;
+            		if (col == null) {
+            			col = Collection.openCollection(AnkiDroidApp.getCollectionPath());
+                   		di = col.getSched().deckCounts();
+                   		progress = col.getSched().todaysProgress(null, true);
+                   		col.close(false);
+            		} else {
+                   		di = col.getSched().deckCounts();            			
+                   		progress = col.getSched().todaysProgress(null, true);
             		}
-            } else {
-                SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-                String deckPath = preferences.getString("deckPath", AnkiDroidApp.getDefaultAnkiDroidDirectory());
-
-                File dir = new File(deckPath);
-
-                File[] fileList = dir.listFiles(new AnkiFileFilter());
-                if (fileList == null || fileList.length == 0) {
-                    mDecks = EMPTY_DECK_STATUS;
-                    return context;
-                }
-
-                decks = new ArrayList<DeckStatus>(fileList.length);
-
-                for (File file : fileList) {
-                	String absPath = null;
-                    try {
-                        // Run through the decks and get the information
-                        absPath = file.getAbsolutePath();
-                        String deckName = file.getName().replaceAll(".anki", "");
-
-                        Log.i(AnkiDroidApp.TAG, "WidgetStatus: Found deck: " + absPath);
-
-//                        Decks deck = DeckManager.getDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS, false);
-//                        if (deck == null) {
-//                            Log.e(AnkiDroidApp.TAG, "Widget: Skipping null deck: " + absPath);
-//                            // Use the data from the last time we updated the deck, if available.
-////                            for (DeckStatus deckStatus : mDecks) {
-////                                if (absPath.equals(deckStatus.mDeckPath)) {
-////                                    Log.d(AnkiDroidApp.TAG, "Using previous value");
-////                                    decks.add(deckStatus);
-////                                    break;
-////                                }
-////                            }
-//                            continue;
-//                        }
-//                        int dueCards = 0;
-//                        int newCards = 0;
-//                        int failedCards = deck.getFailedSoonCount();
-//                        int eta = 0;
-//                        int reps = deck.getSessionFinishedCards();
-//
-//
-//                        if(!deck.hasFinishScheduler()) {
-//        	                dueCards = deck.getRevCount();
-//        	                newCards = deck.getNewCountToday();
-//        	                eta = deck.getETA();
-//                        }
-//
-//                        DeckManager.closeDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS);
-
-                        // Add the information about the deck
-//                        decks.add(new DeckStatus(absPath, deckName, newCards, dueCards, failedCards, eta, reps));
-                    } catch (SQLException e) {
-                        Log.i(AnkiDroidApp.TAG, "Widget: Problems on retrieving deck information");
-                        Log.e(AnkiDroidApp.TAG, e.toString());
-                        if (absPath != null) {
-//                            BackupManager.restoreDeckIfMissing(absPath);                    	
-                        }
-                    }
+            		int eta = (Integer) di[1];
+                    for (Object[] d : (TreeSet<Object[]>) di[0]) {
+                    	String[] name = ((String[])d[0]);
+                    	int newCount = (Integer) d[2];
+                    	int lrnCount = (Integer) d[3];
+                    	int revCount = (Integer) d[4];
+//                    	if (name.length == 1) {
+//                    	}
+                        decks.add(new DeckStatus((Long) d[1], name.length, DeckPicker.readableDeckName(name), newCount, lrnCount, revCount, (int) (progress * 100), eta));            			
+            		}
+                } catch (SQLException e) {
+                    Log.i(AnkiDroidApp.TAG, "Widget: Problems on retrieving deck information");
                 }
-            }
-
-            if (!decks.isEmpty() && decks.size() > 1) {
-                // Sort and reverse the list if there are decks
-                Log.i(AnkiDroidApp.TAG, "Sorting deck");
-
-                // Ordered by deck name
-                Collections.sort(decks, new ByNameComparator());
-            }
+//            }
 
             mDecks = decks.toArray(EMPTY_DECK_STATUS);
             return context;
@@ -257,32 +231,31 @@ protected void onPostExecute(Context context) {
                 context.startService(intent);
             }
         }
-
-    }
-
-    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
-    public static class ByDueComparator implements java.util.Comparator<DeckStatus> {
-        @Override
-        public int compare(DeckStatus deck1, DeckStatus deck2) {
-            // Reverse due cards number order
-            return deck2.mDueCards - deck1.mDueCards;
-        }
-    }
-
-
-    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
-    public static class ByNameComparator implements java.util.Comparator<DeckStatus> {
-        @Override
-        public int compare(DeckStatus deck1, DeckStatus deck2) {
-            return - deck2.mDeckName.compareTo(deck1.mDeckName);
-        }
     }
 
-    /** Filter for Anki files. */
-    public static final class AnkiFileFilter implements FileFilter {
-        @Override
-        public boolean accept(File pathname) {
-            return pathname.isFile() && pathname.getName().endsWith(".anki");
-        }
-    }
+//    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
+//    public static class ByDueComparator implements java.util.Comparator<DeckStatus> {
+//        @Override
+//        public int compare(DeckStatus deck1, DeckStatus deck2) {
+//            // Reverse due cards number order
+//            return deck2.mDueCards - deck1.mDueCards;
+//        }
+//    }
+//
+//
+//    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
+//    public static class ByNameComparator implements java.util.Comparator<DeckStatus> {
+//        @Override
+//        public int compare(DeckStatus deck1, DeckStatus deck2) {
+//            return - deck2.mDeckName.compareTo(deck1.mDeckName);
+//        }
+//    }
+//
+//    /** Filter for Anki files. */
+//    public static final class AnkiFileFilter implements FileFilter {
+//        @Override
+//        public boolean accept(File pathname) {
+//            return pathname.isFile() && pathname.getName().endsWith(".anki");
+//        }
+//    }
 }
