diff --git a/src/com/ichi2/anki/AbstractFlashcardViewer.java b/src/com/ichi2/anki/AbstractFlashcardViewer.java
index a7940c96133c..8aa2ed59b36b 100644
--- a/src/com/ichi2/anki/AbstractFlashcardViewer.java
+++ b/src/com/ichi2/anki/AbstractFlashcardViewer.java
@@ -793,7 +793,7 @@ public void onPostExecute(DeckTask.TaskData result) {
      */
     private void updateTypeAnswerInfo() {
         mTypeCorrect = null;
-        String q = mCurrentCard.getQuestion(false);
+        String q = mCurrentCard.q(false);
         Matcher m = sTypeAnsPat.matcher(q);
         int clozeIdx = 0;
         if (!m.find()) {
@@ -1537,7 +1537,7 @@ protected void showDeleteNoteDialog() {
         builder.setTitle(res.getString(R.string.delete_card_title));
         builder.setIcon(R.drawable.ic_dialog_alert);
         builder.setMessage(String.format(res.getString(R.string.delete_note_message),
-                Utils.stripHTML(mCurrentCard.getQuestion(true))));
+                Utils.stripHTML(mCurrentCard.q(true))));
         builder.setPositiveButton(res.getString(R.string.yes), new DialogInterface.OnClickListener() {
             @Override
             public void onClick(DialogInterface dialog, int which) {
@@ -2217,8 +2217,13 @@ protected void displayCardQuestion() {
         }
 
         setInterface();
-
-        String question = mCurrentCard.getQuestion(mCurrentSimpleInterface);
+        
+        String question;
+        if (mCurrentSimpleInterface) {
+            question = mCurrentCard.qSimple();
+        } else {
+            question = mCurrentCard.q();
+        }
         question = typeAnsQuestionFilter(question);
 
         if (mPrefFixArabic) {
@@ -2329,11 +2334,15 @@ protected void displayCardAnswer() {
         sDisplayAnswer = true;
         setFlipCardAnimation();
 
-        String answer = mCurrentCard.getAnswer(mCurrentSimpleInterface);
-        answer = typeAnsAnswerFilter(answer);
+        String answer;
+        if (mCurrentSimpleInterface) {
+            answer = mCurrentCard.aSimple();
+        } else {
+            answer = mCurrentCard.a();
+        }
 
         if (mDisplayKanjiInfo) {
-            answer = answer + addKanjiInfo(mCurrentCard.getQuestion(mCurrentSimpleInterface));
+            answer = answer + addKanjiInfo(mCurrentCard.q(mCurrentSimpleInterface));
         }
 
         String displayString = "";
@@ -2578,7 +2587,7 @@ protected void playSounds(boolean fromMenuButton) {
      */
     private static void readCardText(final Card card, final int cardSide) {
         if (MetaDB.LANGUAGES_QA_QUESTION == cardSide) {
-            ReadText.textToSpeech(Utils.stripHTML(card.getQuestion(true)), getDeckIdForCard(card), card.getOrd(),
+            ReadText.textToSpeech(Utils.stripHTML(card.q(true)), getDeckIdForCard(card), card.getOrd(),
                     MetaDB.LANGUAGES_QA_QUESTION);
         } else if (MetaDB.LANGUAGES_QA_ANSWER == cardSide) {
             ReadText.textToSpeech(Utils.stripHTML(card.getPureAnswerForReading()), getDeckIdForCard(card),
diff --git a/src/com/ichi2/async/DeckTask.java b/src/com/ichi2/async/DeckTask.java
index 4547794144d4..2f6b84db6e0a 100644
--- a/src/com/ichi2/async/DeckTask.java
+++ b/src/com/ichi2/async/DeckTask.java
@@ -416,7 +416,7 @@ private TaskData doInBackgroundUpdateNote(TaskData[] params) {
                         newCard = editCard;
                         newCard.load();
                         // reload qa-cache
-                        newCard.getQuestion(true);
+                        newCard.q(true);
                     } else {
                         newCard = getCard(sched);
                     }
diff --git a/src/com/ichi2/libanki/Card.java b/src/com/ichi2/libanki/Card.java
index a2dcbc6f441c..584850673385 100644
--- a/src/com/ichi2/libanki/Card.java
+++ b/src/com/ichi2/libanki/Card.java
@@ -1,6 +1,7 @@
 /****************************************************************************************
  * Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
  * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
+ * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
  *                                                                                      *
  * This program is free software; you can redistribute it and/or modify it under        *
  * the terms of the GNU General Public License as published by the Free Software        *
@@ -28,84 +29,92 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
+import java.util.Locale;
 
 /**
- * A card is a presentation of a note, and has two sides: a question and an answer. Any number of fields can appear on
- * each side. When you add a fact to Anki, cards which show that fact are generated. Some models generate one card,
- * others generate more than one.
- *
- * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Cards Type: 0=new, 1=learning, 2=due Queue: same as above, and:
- *      -1=suspended, -2=user buried, -3=sched buried Due is used differently for different queues. - new queue: note id
- *      or random int - rev queue: integer day - lrn queue: integer timestamp
+ A Card is the ultimate entity subject to review; it encapsulates the scheduling parameters (from which to derive
+ the next interval), the note it is derived from (from which field data is retrieved), its own ownership (which deck it
+ currently belongs to), and the retrieval of presentation elements (filled-in templates).
+ 
+ Card presentation has two components: the question (front) side and the answer (back) side. The presentation of the
+ card is derived from the template of the card's Card Type. The Card Type is a component of the Note Type (see Models)
+ that this card is derived from.
+ 
+ This class is responsible for:
+ - Storing and retrieving database entries that map to Cards in the Collection
+ - Providing the HTML representation of the Card's question and answer
+ - Recording the results of review (answer chosen, time taken, etc)
+
+ It does not:
+ - Generate new cards (see Collection)
+ - Store the templates or the style sheet (see Models)
+ 
+ Type: 0=new, 1=learning, 2=due
+ Queue: same as above, and:
+        -1=suspended, -2=user buried, -3=sched buried
+ Due is used differently for different queues.
+ - new queue: note id or random int
+ - rev queue: integer day
+ - lrn queue: integer timestamp
  */
-
 public class Card implements Cloneable {
 
     public static final int TYPE_NEW = 0;
     public static final int TYPE_LRN = 1;
     public static final int TYPE_REV = 2;
 
+    private Collection mCol;
+    private double mTimerStarted;
+    private double mTimerStopped; // Not in LibAnki. Used to calculate time taken if activity is stopped/resumed.
+
     // BEGIN SQL table entries
-    private long mId = 0;
+    private long mId;
     private long mNid;
     private long mDid;
     private int mOrd;
-    private long mCrt = Utils.intNow();
     private long mMod;
-    private int mType = 0;
-    private int mQueue = 0;
-    private long mDue = 0;
-    private int mIvl = 0;
-    private int mFactor = 0;
-    private int mReps = 0;
-    private int mLapses = 0;
-    private int mLeft = 0;
-    private int mUsn = 0;
-    private int mFlags = 0;
-    private long mODue = 0;
-    private long mODid = 0;
-    private String mData = "";
+    private int mUsn;
+    private int mType;
+    private int mQueue;
+    private long mDue;
+    private int mIvl;
+    private int mFactor;
+    private int mReps;
+    private int mLapses;
+    private int mLeft;
+    private long mODue;
+    private long mODid;
+    private int mFlags;
+    private String mData;
     // END SQL table entries
 
-    /** Last interval. Used to determine if a card is young or mature. */
-    private int mLastIvl;
-
     private HashMap<String, String> mQA;
     private Note mNote;
 
-    private double mTimerStarted;
-    private double mTimerStopped;
-    // private double mFuzz = 0;
+    // Used by Sched to determine which queue to move the card to after answering.
+    private boolean mWasNew;
 
-    // Leech flags, not read from database, only set to true during the actual
-    // suspension
-    private boolean mIsLeechTagged;
-    private boolean mIsLeechSuspended;
-
-    private boolean mWasNew = false;
-
-    private Collection mCol;
+    // Used by Sched to record the original interval in the revlog after answering.
+    private int mLastIvl;
 
 
     public Card(Collection col) {
-        this(col, 0);
+        this(col, null);
     }
 
 
-    public Card(Collection col, long id) {
+    public Card(Collection col, Long id) {
         mCol = col;
         mTimerStarted = Double.NaN;
         mQA = null;
         mNote = null;
-        if (id != 0) {
+        if (id != null) {
             mId = id;
             load();
         } else {
             // to flush, set nid, ord, and due
             mId = Utils.timestampID(mCol.getDb(), "cards");
             mDid = 1;
-            mCrt = Utils.intNow();
             mType = 0;
             mQueue = 0;
             mIvl = 0;
@@ -114,22 +123,20 @@ public Card(Collection col, long id) {
             mLapses = 0;
             mLeft = 0;
             mODue = 0;
+            mODid = 0;
             mFlags = 0;
             mData = "";
         }
     }
 
-    /**
-     * Reload Card details from db.
-     * @return True if the load was successful, false if no card with such id was found.
-     */
-    public boolean load() {
+
+    public void load() {
         Cursor cursor = null;
         try {
             cursor = mCol.getDb().getDatabase().rawQuery("SELECT * FROM cards WHERE id = " + mId, null);
             if (!cursor.moveToFirst()) {
                 Log.w(AnkiDroidApp.TAG, "Card.load: No card with id " + mId);
-                return false;
+                return;
             }
             mId = cursor.getLong(0);
             mNid = cursor.getLong(1);
@@ -156,41 +163,40 @@ public boolean load() {
         }
         mQA = null;
         mNote = null;
-        return true;
     }
 
 
     public void flush() {
-    	flush(true);
-    }
-    public void flush(boolean changeModUsn) {
-    	if (changeModUsn) {
-            mMod = Utils.intNow();
-            mUsn = mCol.usn();
-    	}
+        mMod = Utils.intNow();
+        mUsn = mCol.usn();
         // bug check
-        assert mQueue != 2 || mODue == 0 || mCol.getDecks().isDyn(mDid);
-        StringBuilder sb = new StringBuilder();
-        sb.append("INSERT OR REPLACE INTO cards VALUES (");
-        sb.append(mId).append(", ");
-        sb.append(mNid).append(", ");
-        sb.append(mDid).append(", ");
-        sb.append(mOrd).append(", ");
-        sb.append(mMod).append(", ");
-        sb.append(mUsn).append(", ");
-        sb.append(mType).append(", ");
-        sb.append(mQueue).append(", ");
-        sb.append(mDue).append(", ");
-        sb.append(mIvl).append(", ");
-        sb.append(mFactor).append(", ");
-        sb.append(mReps).append(", ");
-        sb.append(mLapses).append(", ");
-        sb.append(mLeft).append(", ");
-        sb.append(mODue).append(", ");
-        sb.append(mODid).append(", ");
-        sb.append(mFlags).append(", ");
-        sb.append("\"").append(mData).append("\")");
-        mCol.getDb().execute(sb.toString());
+        if ((mQueue == 2 && mODue != 0) && !mCol.getDecks().isDyn(mDid)) {
+            // TODO: runHook("odueInvalid");
+        }
+        assert (mDue < Long.valueOf("4294967296"));
+        mCol.getDb().execute(
+                "insert or replace into cards values " +
+                "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
+                new Object[]{
+                mId,
+                mNid,
+                mDid,
+                mOrd,
+                mMod,
+                mUsn,
+                mType,
+                mQueue,
+                mDue,
+                mIvl,
+                mFactor,
+                mReps,
+                mLapses,
+                mLeft,
+                mODue,
+                mODid,
+                mFlags,
+                mData
+        });
     }
 
 
@@ -198,7 +204,11 @@ public void flushSched() {
         mMod = Utils.intNow();
         mUsn = mCol.usn();
         // bug check
-        assert mQueue != 2 || mODue == 0 || mCol.getDecks().isDyn(mDid);
+        if ((mQueue == 2 && mODue != 0) && !mCol.getDecks().isDyn(mDid)) {
+            // TODO: runHook("odueInvalid");
+        }
+        assert (mDue < Long.valueOf("4294967296"));
+
         ContentValues values = new ContentValues();
         values.put("mod", mMod);
         values.put("usn", mUsn);
@@ -213,53 +223,45 @@ public void flushSched() {
         values.put("odue", mODue);
         values.put("odid", mODid);
         values.put("did", mDid);
+        // TODO: The update DB call sets mod=true. Verify if this is intended.
         mCol.getDb().update("cards", values, "id = " + mId, null);
     }
 
 
-    public String getQuestion(boolean simple) {
-        return getQuestion(false, simple);
+    public String q() {
+        return q(false);
     }
 
-    public String getQuestion(boolean reload, boolean simple) {
-        return getQuestion(reload, simple, false);
-    }
 
-    public String getQuestion(boolean reload, boolean simple, boolean browser) {
-        if (simple) {
-            return _getQA(reload).get("q");
-        } else {
-            return css() + _getQA(reload).get("q");
-        }
+    public String q(boolean reload) {
+        return q(reload, false);
     }
 
 
-    public String getAnswer(boolean simple) {
-        if (simple) {
-        	return _getQA(false).get("a").replaceAll("<hr[^>]*>", "<br>\u2500\u2500\u2500\u2500\u2500<br>");
-        } else {
-            return css() + _getQA(false).get("a");
-        }
+    public String q(boolean reload, boolean browser) {
+        return css() + _getQA(reload, browser).get("q");
     }
 
-    public String getPureAnswerForReading() {
-    	String s = _getQA(false).get("a");
-    	String target = "<hr id=answer>\n\n";
-    	int pos = s.indexOf(target);
-    	if(pos == -1)
-    		return s;
-    	return s.substring(pos + target.length());
+
+    public String a() {
+        return css() + _getQA().get("a");
     }
 
+
     public String css() {
         try {
-            return (new StringBuilder()).append("<style>").append(model().get("css")).append("</style>").toString();
+            return String.format(Locale.US, "<style>%s</style>", model().get("css"));
         } catch (JSONException e) {
             throw new RuntimeException(e);
         }
     }
 
 
+    public HashMap<String, String> _getQA() {
+        return _getQA(false);
+    }
+
+
     public HashMap<String, String> _getQA(boolean reload) {
         return _getQA(reload, false);
     }
@@ -267,14 +269,13 @@ public HashMap<String, String> _getQA(boolean reload) {
 
     public HashMap<String, String> _getQA(boolean reload, boolean browser) {
         if (mQA == null || reload) {
-            mQA = new HashMap<String, String>();
-            Note n = note(reload);
+            Note f = note(reload);
             JSONObject m = model();
             JSONObject t = template();
             Object[] data;
             try {
-                data = new Object[] { mId, n.getId(), m.getLong("id"), mODid != 0l ? mODid : mDid, mOrd,
-                        n.stringTags(), n.joinedFields() };
+                data = new Object[] { mId, f.getId(), m.getLong("id"), mODid != 0l ? mODid : mDid, mOrd,
+                        f.stringTags(), f.joinedFields() };
             } catch (JSONException e) {
                 throw new RuntimeException(e);
             }
@@ -288,7 +289,7 @@ public HashMap<String, String> _getQA(boolean reload, boolean browser) {
                     throw new RuntimeException(e);
                 }
             } else {
-            	mQA = mCol._renderQA(data);
+                mQA = mCol._renderQA(data);
             }
         }
         return mQA;
@@ -332,21 +333,8 @@ public void startTimer() {
     }
 
 
-     public void stopTimer() {
-    	 mTimerStopped = Utils.now();
-     }
-
-     public void resumeTimer() {
-         if (!Double.isNaN(mTimerStarted) && !Double.isNaN(mTimerStopped)) {
-        	mTimerStarted += Utils.now() - mTimerStopped;
-    	 	mTimerStopped = Double.NaN;
-         } else {
-        	 Log.i(AnkiDroidApp.TAG, "Card Timer: nothing to resume");
-         }
-     }
-
     /**
-     * Time taken to answer card, in integer MS.
+     * Time limit for answering in milliseconds.
      */
     public long timeLimit() {
         JSONObject conf = mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid);
@@ -358,9 +346,22 @@ public long timeLimit() {
     }
 
 
+    public boolean shouldShowTimer() {
+        try {
+            return mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid).getInt("timer") != 0;
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    /*
+     * Time taken to answer card, in integer MS.
+     */
     public long timeTaken() {
         long total = (long) ((Utils.now() - mTimerStarted) * 1000);
         // Workaround for 1449. Ensure we don't return negative times.
+        // TODO: Find the real cause of negative time taken.
         if (total < 0) {
             total = timeLimit();
         }
@@ -369,140 +370,58 @@ public long timeTaken() {
 
 
     public boolean isEmpty() {
-		ArrayList<Integer> ords = mCol.getModels().availOrds(model(),
-				Utils.joinFields(note().getFields()));
-        if (ords.contains(mOrd)) {
+        ArrayList<Integer> ords = mCol.getModels().availOrds(model(), Utils.joinFields(note().getFields()));
+        if (!ords.contains(mOrd)) {
             return true;
         }
         return false;
     }
 
 
-    /**
-     * The cardModel defines a field typeAnswer. If it is empty, then no answer should be typed. Otherwise a typed
-     * answer should be compared to the value of field related to a cards fact. A field is found based on the factId in
-     * the card and the fieldModelId. The fieldModel's id is found by searching with the typeAnswer name and cardModel's
-     * modelId
-     *
-     * @return 2 dimensional array with answer value at index=0 and fieldModel's class at index=1 null if typeAnswer is
-     *         empty (i.e. do not prompt for answer). Otherwise a string (which can be empty) from the actual field
-     *         value. The fieldModel's id is correctly hexafied and formatted for class attribute of span for formatting
+    /*
+     * ***********************************************************
+     * The methods below are not in LibAnki.
+     * ***********************************************************
      */
-    public String[] getComparedFieldAnswer() {
-        String[] returnArray = new String[2];
-        // CardModel myCardModel = this.getCardModel();
-        // String typeAnswer = myCardModel.getTypeAnswer();
-        // if (null == typeAnswer || 0 == typeAnswer.trim().length()) {
-        // returnArray[0] = null;
-        // }
-        // Model myModel = Model.getModel(mDeck, myCardModel.getModelId(),
-        // true);
-        // TreeMap<Long, FieldModel> fieldModels = myModel.getFieldModels();
-        // FieldModel myFieldModel = null;
-        // long myFieldModelId = 0l;
-        // for (TreeMap.Entry<Long, FieldModel> entry : fieldModels.entrySet())
-        // {
-        // myFieldModel = entry.getValue();
-        // myFieldModelId = myFieldModel.match(myCardModel.getModelId(),
-        // typeAnswer);
-        // if (myFieldModelId != 0l) {
-        // break;
-        // }
-        // }
-        // returnArray[0] = com.ichi2.anki.Field.fieldValuefromDb(this.mDeck,
-        // this.mFactId, myFieldModelId);
-        // returnArray[1] = "fm" + Long.toHexString(myFieldModelId);
-        return returnArray;
-    }
-
-
-    //
-    // /**
-    // // * Questions and answers
-    // // */
-    // public void rebuildQA(Deck deck) {
-    // rebuildQA(deck, true);
-    // }
-    // public void rebuildQA(Deck deck, boolean media) {
-    // // Format qa
-    // if (mFact != null && mCardModel != null) {
-    // HashMap<String, String> qa = CardModel.formatQA(mFact, mCardModel,
-    // _splitTags());
-    //
-    // if (media) {
-    // // Find old media references
-    // HashMap<String, Integer> files = new HashMap<String, Integer>();
-    // ArrayList<String> filesFromQA = Media.mediaFiles(mQuestion);
-    // filesFromQA.addAll(Media.mediaFiles(mAnswer));
-    // for (String f : filesFromQA) {
-    // if (files.containsKey(f)) {
-    // files.put(f, files.get(f) - 1);
-    // } else {
-    // files.put(f, -1);
-    // }
-    // }
-    // // Update q/a
-    // mQuestion = qa.get("question");
-    // mAnswer = qa.get("answer");
-    // // Determine media delta
-    // filesFromQA = Media.mediaFiles(mQuestion);
-    // filesFromQA.addAll(Media.mediaFiles(mAnswer));
-    // for (String f : filesFromQA) {
-    // if (files.containsKey(f)) {
-    // files.put(f, files.get(f) + 1);
-    // } else {
-    // files.put(f, 1);
-    // }
-    // }
-    // // Update media counts if we're attached to deck
-    // for (Entry<String, Integer> entry : files.entrySet()) {
-    // Media.updateMediaCount(deck, entry.getKey(), entry.getValue());
-    // }
-    // } else {
-    // // Update q/a
-    // mQuestion = qa.get("question");
-    // mAnswer = qa.get("answer");
-    // }
-    // setModified();
-    // }
-    // }
-    //
-    //
-    //
-    //
-    // public double getFuzz() {
-    // if (mFuzz == 0) {
-    // genFuzz();
-    // }
-    // return mFuzz;
-    // }
-    //
-    // public void genFuzz() {
-    // // Random rand = new Random();
-    // // mFuzz = 0.95 + (0.1 * rand.nextDouble());
-    // mFuzz = (double) Math.random();
-    // }
-    //
-    //
-    //
 
-    public long getId() {
-        return mId;
+
+    public String qSimple() {
+        return _getQA(false).get("q");
     }
 
 
-    public void setId(long id) {
-        mId = id;
+    public String aSimple() {
+        return _getQA(false).get("a").replaceAll("<hr[^>]*>", "<br>\u2500\u2500\u2500\u2500\u2500<br>");
     }
 
 
-    public long getMod() {
-        return mMod;
+    public String getPureAnswerForReading() {
+        String s = _getQA(false).get("a");
+        String target = "<hr id=answer>\n\n";
+        int pos = s.indexOf(target);
+        if (pos == -1)
+            return s;
+        return s.substring(pos + target.length());
     }
 
 
-    public void setMod() {
-        mMod = Utils.intNow();
+    public void stopTimer() {
+        mTimerStopped = Utils.now();
+    }
+
+
+    public void resumeTimer() {
+        if (!Double.isNaN(mTimerStarted) && !Double.isNaN(mTimerStopped)) {
+            mTimerStarted += Utils.now() - mTimerStopped;
+            mTimerStopped = Double.NaN;
+        } else {
+            Log.i(AnkiDroidApp.TAG, "Card Timer: nothing to resume");
+        }
+    }
+
+
+    public long getId() {
+        return mId;
     }
 
 
@@ -581,11 +500,6 @@ public void setDue(long due) {
     }
 
 
-    public int getLastIvl() {
-        return mLastIvl;
-    }
-
-
     public int getIvl() {
         return mIvl;
     }
@@ -626,55 +540,48 @@ public void setLapses(int lapses) {
     }
 
 
-    public void setLastIvl(int lastIvl) {
-        mLastIvl = lastIvl;
-    }
-
-
-    // Leech flag
-    public boolean getLeechFlag() {
-        return mIsLeechTagged;
+    public void setNid(long nid) {
+        mNid = nid;
     }
 
 
-    public void setLeechFlag(boolean flag) {
-        mIsLeechTagged = flag;
+    public void setOrd(int ord) {
+        mOrd = ord;
     }
 
 
-    // Suspended flag
-    public boolean getSuspendedFlag() {
-        return mIsLeechSuspended;
+    public int getOrd() {
+        return mOrd;
     }
 
 
-    public void setSuspendedFlag(boolean flag) {
-        mIsLeechSuspended = flag;
+    public void setDid(long did) {
+        mDid = did;
     }
 
 
-    public void setNid(long nid) {
-        mNid = nid;
+    public long getDid() {
+        return mDid;
     }
 
 
-    public void setOrd(int ord) {
-        mOrd = ord;
+    public boolean getWasNew() {
+        return mWasNew;
     }
 
 
-    public int getOrd() {
-        return mOrd;
+    public void setWasNew(boolean wasNew) {
+        mWasNew = wasNew;
     }
 
 
-    public void setDid(long did) {
-        mDid = did;
+    public int getLastIvl() {
+        return mLastIvl;
     }
 
 
-    public long getDid() {
-        return mDid;
+    public void setLastIvl(int ivl) {
+        mLastIvl = ivl;
     }
 
 
@@ -689,23 +596,17 @@ public void setCol(Collection col) {
         mCol = col;
     }
 
+
     public boolean showTimer() {
-    	return mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid).optInt("timer",1) != 0;
+        return mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid).optInt("timer", 1) != 0;
     }
 
+
     public Card clone() {
         try {
-            return (Card) super.clone();
+            return (Card)super.clone();
         } catch (CloneNotSupportedException e) {
             throw new RuntimeException(e);
         }
     }
-
-    public boolean getWasNew() {
-        return mWasNew;
-    }
-
-    public void setWasNew(boolean mWasNew) {
-        this.mWasNew = mWasNew;
-    }
 }
diff --git a/src/com/ichi2/libanki/Collection.java b/src/com/ichi2/libanki/Collection.java
index 1880d247033d..4296b314a662 100644
--- a/src/com/ichi2/libanki/Collection.java
+++ b/src/com/ichi2/libanki/Collection.java
@@ -1180,7 +1180,7 @@ public long undo() {
     	case UNDO_REVIEW:
             Card c = (Card) data[1];
             // write old data
-            c.flush(false);
+            c.flush();
             // and delete revlog entry
             long last = mDb.queryLongScalar("SELECT id FROM revlog WHERE cid = " + c.getId() + " ORDER BY id DESC LIMIT 1");
             mDb.execute("DELETE FROM revlog WHERE id = " + last);
@@ -1207,7 +1207,7 @@ public long undo() {
                     // Reloads the QA-cache.
                     // Requests the simple interface version, since the only difference
                     // is whether the CSS is added and that's not cached.
-                    card.getQuestion(true, true);
+                    card.q(true, true);
                 }
             }
             if (card == null) {
@@ -1220,18 +1220,18 @@ public long undo() {
 
     	case UNDO_BURY_NOTE:
     		for (Card cc : (ArrayList<Card>)data[2]) {
-    			cc.flush(false);
+    			cc.flush();
     		}
     		return (Long) data[3];
 
     	case UNDO_SUSPEND_CARD:
     		Card suspendedCard = (Card)data[1];
-    		suspendedCard.flush(false);
+    		suspendedCard.flush();
     		return suspendedCard.getId();
 
     	case UNDO_SUSPEND_NOTE:
     		for (Card ccc : (ArrayList<Card>) data[1]) {
-    			ccc.flush(false);
+    			ccc.flush();
     		}
     		return (Long) data[2];
 
@@ -1241,7 +1241,7 @@ public long undo() {
     		note2.flush(note2.getMod());
     		ids.add(note2.getId());
         		for (Card c4 : (ArrayList<Card>) data[2]) {
-        			c4.flush(false);
+        			c4.flush();
     			ids.add(c4.getId());
         		}
     		mDb.execute("DELETE FROM graves WHERE oid IN " + Utils.ids2str(Utils.arrayList2array(ids)));
