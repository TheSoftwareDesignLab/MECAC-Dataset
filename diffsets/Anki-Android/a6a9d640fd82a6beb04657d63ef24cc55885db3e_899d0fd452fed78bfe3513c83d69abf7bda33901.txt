diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
index 007af727e2ec..3d0aa1ad8b6c 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java
@@ -252,16 +252,16 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
         while (it.hasNext()) {
             DeckDueTreeNode node = it.next();
             String head = node.getNamePart(0);
-            // Compose the "tail" node list. The tail is a list of all the nodes that proceed
-            // the current one that contain the same name[0]. I.e., they are subdecks that stem
-            // from this node. This is our version of python's itertools.groupby.
-            List<DeckDueTreeNode> tail  = new ArrayList<>();
-            tail.add(node);
+            // Compose the "children" node list. The children is a list of all the nodes that proceed
+            // the current one that contain the same name[0], except for the current one itself.
+            // I.e., they are subdecks that stem from this node.
+            // This is our version of python's itertools.groupby.
+            List<DeckDueTreeNode> children  = new ArrayList<>();
             while (it.hasNext()) {
                 DeckDueTreeNode next = it.next();
                 if (head.equals(next.getNamePart(0))) {
                     // Same head - add to tail of current head.
-                    tail.add(next);
+                    children.add(next);
                 } else {
                     // We've iterated past this head, so step back in order to use this node as the
                     // head in the next iteration of the outer loop.
@@ -269,25 +269,14 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
                     break;
                 }
             }
-            Long did = null;
-            int rev = 0;
-            int _new = 0;
-            int lrn = 0;
-            List<DeckDueTreeNode> children = new ArrayList<>();
-            for (DeckDueTreeNode c : tail) {
-                if (c.getNames().length == 1) {
-                    // current node
-                    did = c.getDid();
-                    rev += c.getRevCount();
-                    lrn += c.getLrnCount();
-                    _new += c.getNewCount();
-                } else {
-                    // set new string to tail
-                    String[] newTail = new String[c.getNames().length-1];
-                    System.arraycopy(c.getNames(), 1, newTail, 0, c.getNames().length-1);
-                    c.setNames(newTail);
-                    children.add(c);
-                }
+            int rev = node.getRevCount();
+            int _new = node.getNewCount();
+            int lrn = node.getLrnCount();
+            for (DeckDueTreeNode c : children) {
+                // set new string to tail
+                String[] newTail = new String[c.getNames().length-1];
+                System.arraycopy(c.getNames(), 1, newTail, 0, c.getNames().length-1);
+                c.setNames(newTail);
             }
             children = _groupChildrenMain(children);
             // tally up children counts
@@ -297,13 +286,13 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
                 _new += ch.getNewCount();
             }
             // limit the counts to the deck's limits
-            JSONObject conf = mCol.getDecks().confForDid(did);
+            JSONObject conf = mCol.getDecks().confForDid(node.getDid());
             if (conf.getInt("dyn") == 0) {
-                JSONObject deck = mCol.getDecks().get(did);
+                JSONObject deck = mCol.getDecks().get(node.getDid());
                 rev = Math.max(0, Math.min(rev, conf.getJSONObject("rev").getInt("perDay") - deck.getJSONArray("revToday").getInt(1)));
                 _new = Math.max(0, Math.min(_new, conf.getJSONObject("new").getInt("perDay") - deck.getJSONArray("newToday").getInt(1)));
             }
-            tree.add(new DeckDueTreeNode(head, did, rev, lrn, _new, children));
+            tree.add(new DeckDueTreeNode(head, node.getDid(), rev, lrn, _new, children));
         }
         return tree;
     }
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
index 49dd2347e585..a923f970f5b7 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/sched/SchedV2.java
@@ -449,16 +449,12 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
         while (it.hasNext()) {
             DeckDueTreeNode node = it.next();
             String head = node.getNamePart(0);
-            // Compose the "tail" node list. The tail is a list of all the nodes that proceed
-            // the current one that contain the same name[0]. I.e., they are subdecks that stem
-            // from this node. This is our version of python's itertools.groupby.
-            List<DeckDueTreeNode> tail  = new ArrayList<>();
-            tail.add(node);
+            List<DeckDueTreeNode> children  = new ArrayList<>();
             while (it.hasNext()) {
                 DeckDueTreeNode next = it.next();
                 if (head.equals(next.getNamePart(0))) {
                     // Same head - add to tail of current head.
-                    tail.add(next);
+                    children.add(next);
                 } else {
                     // We've iterated past this head, so step back in order to use this node as the
                     // head in the next iteration of the outer loop.
@@ -466,25 +462,14 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
                     break;
                 }
             }
-            Long did = null;
-            int rev = 0;
-            int _new = 0;
-            int lrn = 0;
-            List<DeckDueTreeNode> children = new ArrayList<>();
-            for (DeckDueTreeNode c : tail) {
-                if (c.getNames().length == 1) {
-                    // current node
-                    did = c.getDid();
-                    rev += c.getRevCount();
-                    lrn += c.getLrnCount();
-                    _new += c.getNewCount();
-                } else {
-                    // set new string to tail
-                    String[] newTail = new String[c.getNames().length-1];
-                    System.arraycopy(c.getNames(), 1, newTail, 0, c.getNames().length-1);
-                    c.setNames(newTail);
-                    children.add(c);
-                }
+            int rev = node.getRevCount();
+            int _new = node.getNewCount();
+            int lrn = node.getLrnCount();
+            for (DeckDueTreeNode c : children) {
+                // set new string to tail
+                String[] newTail = new String[c.getNames().length-1];
+                System.arraycopy(c.getNames(), 1, newTail, 0, c.getNames().length-1);
+                c.setNames(newTail);
             }
             children = _groupChildrenMain(children);
             // tally up children counts
@@ -493,12 +478,12 @@ protected List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
                 _new += ch.getNewCount();
             }
             // limit the counts to the deck's limits
-            JSONObject conf = mCol.getDecks().confForDid(did);
+            JSONObject conf = mCol.getDecks().confForDid(node.getDid());
             if (conf.getInt("dyn") == 0) {
-                JSONObject deck = mCol.getDecks().get(did);
+                JSONObject deck = mCol.getDecks().get(node.getDid());
                 _new = Math.max(0, Math.min(_new, conf.getJSONObject("new").getInt("perDay") - deck.getJSONArray("newToday").getInt(1)));
             }
-            tree.add(new DeckDueTreeNode(head, did, rev, lrn, _new, children));
+            tree.add(new DeckDueTreeNode(head, node.getDid(), rev, lrn, _new, children));
         }
         return tree;
     }
