diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.java b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.java
index 8b65ae46998a..2dddb7ce6d94 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CollectionHelper.java
@@ -27,6 +27,7 @@
 import com.ichi2.anki.exception.StorageAccessException;
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Storage;
+import com.ichi2.preferences.PreferenceExtensions;
 
 import java.io.File;
 import java.io.IOException;
@@ -209,7 +210,10 @@ public static String getCollectionPath(Context context) {
      */
     public static String getCurrentAnkiDroidDirectory(Context context) {
         SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context.getApplicationContext());
-        return preferences.getString("deckPath", getDefaultAnkiDroidDirectory());
+        return PreferenceExtensions.getOrSetString(
+                preferences,
+                "deckPath",
+                CollectionHelper::getDefaultAnkiDroidDirectory);
     }
 
     /**
diff --git a/AnkiDroid/src/main/java/com/ichi2/preferences/PreferenceExtensions.java b/AnkiDroid/src/main/java/com/ichi2/preferences/PreferenceExtensions.java
new file mode 100644
index 000000000000..1e39aea21e88
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/preferences/PreferenceExtensions.java
@@ -0,0 +1,32 @@
+package com.ichi2.preferences;
+
+import android.content.SharedPreferences;
+
+import androidx.annotation.CheckResult;
+import androidx.annotation.NonNull;
+
+/** Extension methods over the SharedPreferences class */
+public class PreferenceExtensions {
+
+    /**
+     * Returns the string value specified by the key, or sets key to the result of the lambda and returns it.<br/>
+     * This is not designed to be used when bulk editing preferences.<br/>
+     * Defect #5828 - This is potentially not thread safe and could cause another preference commit to fail.
+     */
+    @CheckResult //Not truly an error as this has a side effect, but you should use a "set" API for perf.
+    public static String getOrSetString(@NonNull SharedPreferences target, @NonNull String key, @NonNull Supplier<String> supplier) {
+        if (target.contains(key)) {
+            //the default Is never returned. The value might be able be optimised, but the Android API should be better.
+            return target.getString(key, "");
+        }
+        String supplied = supplier.get();
+        target.edit().putString(key, supplied).apply();
+        return supplied;
+    }
+
+    /** TODO: Move this to Supplier in API 24 */
+    @FunctionalInterface
+    public interface Supplier<T> {
+        T get();
+    }
+}
diff --git a/AnkiDroid/src/test/java/com/ichi2/preferences/PreferenceExtensionsTest.java b/AnkiDroid/src/test/java/com/ichi2/preferences/PreferenceExtensionsTest.java
new file mode 100644
index 000000000000..e63e54212410
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/preferences/PreferenceExtensionsTest.java
@@ -0,0 +1,87 @@
+package com.ichi2.preferences;
+
+import android.content.SharedPreferences;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import static com.ichi2.testutils.AnkiAssert.assertDoesNotThrow;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+
+//Unknown issue: @CheckResult should provide warnings on this class when return value is unused, but doesn't.
+//TODO: The preference mock is messy
+@RunWith(PowerMockRunner.class)
+public class PreferenceExtensionsTest {
+
+    private static PreferenceExtensions.Supplier<String> UNUSED_SUPPLIER = () -> { throw new UnexpectedException();};
+    private static PreferenceExtensions.Supplier<String> EXCEPTION_SUPPLIER = () -> { throw new ExpectedException();};
+
+    private static final String VALID_KEY = "VALID";
+    private static final String VALID_RESULT = "WAS VALID KEY";
+    private static final String MISSING_KEY = "INVALID";
+    private static final String LAMBDA_RETURN = "LAMBDA";
+
+    @Mock
+    private SharedPreferences mMockReferences;
+
+    @Mock
+    private SharedPreferences.Editor mockEditor;
+
+    private String getOrSetString(String key, PreferenceExtensions.Supplier<String> supplier) {
+        return PreferenceExtensions.getOrSetString(mMockReferences, key, supplier);
+    }
+
+    @Before
+    public void setUp() {
+        Mockito.when(mMockReferences.contains(VALID_KEY)).thenReturn(true);
+        Mockito.when(mMockReferences.getString(eq(VALID_KEY), anyString())).thenReturn(VALID_RESULT);
+        Mockito.when(mMockReferences.edit()).thenReturn(mockEditor);
+        Mockito.when(mockEditor.putString(anyString(), anyString())).thenReturn(mockEditor);
+    }
+
+    private String getForMissingKey() {
+        return getOrSetString(MISSING_KEY, () -> LAMBDA_RETURN);
+    }
+
+    @Test
+    public void existingKeyReturnsMappedValue() {
+        String ret = getOrSetString(VALID_KEY, UNUSED_SUPPLIER);
+        assertEquals(ret, VALID_RESULT);
+    }
+
+    @Test
+    public void missingKeyReturnsLambdaValue() {
+        String ret = getForMissingKey();
+        assertEquals(ret, LAMBDA_RETURN);
+    }
+
+    @SuppressWarnings("unused")
+    @Test
+    public void missingKeySetsPreference() {
+        getForMissingKey();
+        Mockito.verify(mockEditor).putString(MISSING_KEY, LAMBDA_RETURN);
+        Mockito.verify(mockEditor).apply();
+    }
+
+    @SuppressWarnings("unused")
+    public void noLambdaExceptionIfKeyExists() {
+         assertDoesNotThrow(() -> getOrSetString(VALID_KEY, EXCEPTION_SUPPLIER));
+    }
+
+    @SuppressWarnings("unused")
+    @Test(expected = ExpectedException.class)
+    public void rethrowLambdaExceptionIfKeyIsMissing() {
+        getOrSetString(MISSING_KEY, EXCEPTION_SUPPLIER);
+    }
+
+    private static class ExpectedException extends RuntimeException {
+    }
+    private static class UnexpectedException extends RuntimeException {
+    }
+}
diff --git a/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java b/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java
new file mode 100644
index 000000000000..629b5849df35
--- /dev/null
+++ b/AnkiDroid/src/test/java/com/ichi2/testutils/AnkiAssert.java
@@ -0,0 +1,18 @@
+package com.ichi2.testutils;
+
+import androidx.annotation.NonNull;
+
+import org.junit.Assert;
+
+/** Assertion methods that aren't currently supported by our dependencies */
+public class AnkiAssert {
+
+    /** Helper to sort out "JUnit tests should include assert() or fail()" quality check */
+    public static void assertDoesNotThrow(@NonNull Runnable runnable) {
+        try {
+            runnable.run();
+        } catch (Exception e) {
+            Assert.fail();
+        }
+    }
+}
