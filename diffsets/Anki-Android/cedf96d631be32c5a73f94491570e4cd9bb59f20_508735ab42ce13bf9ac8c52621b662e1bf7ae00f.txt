diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
index 4718abad0f0b..1c2490bc7e24 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java
@@ -93,6 +93,7 @@
 import com.ichi2.anki.cardviewer.GestureProcessor;
 import com.ichi2.anki.cardviewer.MissingImageHandler;
 import com.ichi2.anki.cardviewer.OnRenderProcessGoneDelegate;
+import com.ichi2.anki.cardviewer.TTS;
 import com.ichi2.anki.cardviewer.TypeAnswer;
 import com.ichi2.anki.cardviewer.ViewerCommand;
 import com.ichi2.anki.dialogs.tags.TagsDialog;
@@ -368,6 +369,7 @@ public abstract class AbstractFlashcardViewer extends NavigationDrawerActivity i
 
     @VisibleForTesting
     final OnRenderProcessGoneDelegate mOnRenderProcessGoneDelegate = new OnRenderProcessGoneDelegate(this);
+    private final TTS mTTS = new TTS();
 
     // ----------------------------------------------------------------------------
     // LISTENERS
@@ -2108,10 +2110,10 @@ protected void playSounds(boolean doAudioReplay) {
                 // If the question is displayed or if the question should be replayed, read the question
                 if (mTtsInitialized) {
                     if (!sDisplayAnswer || doAudioReplay && replayQuestion) {
-                        readCardText(mCurrentCard, SoundSide.QUESTION);
+                        mTTS.readCardText(this, mCurrentCard, SoundSide.QUESTION);
                     }
                     if (sDisplayAnswer) {
-                        readCardText(mCurrentCard, SoundSide.ANSWER);
+                        mTTS.readCardText(this, mCurrentCard, SoundSide.ANSWER);
                     }
                 } else {
                     mReplayOnTtsInit = true;
@@ -2142,69 +2144,23 @@ private Sound.OnErrorListener getSoundErrorListener() {
     }
 
 
-    /**
-     * Reads the text (using TTS) for the given side of a card.
-     *
-     * @param card     The card to play TTS for
-     * @param cardSide The side of the current card to play TTS for
-     */
-    private void readCardText(final Card card, final SoundSide cardSide) {
-        final String cardSideContent;
-        if (SoundSide.QUESTION == cardSide) {
-            cardSideContent = card.q(true);
-        } else if (SoundSide.ANSWER == cardSide) {
-            cardSideContent = card.getPureAnswer();
-        } else {
-            Timber.w("Unrecognised cardSide");
-            return;
-        }
-        String clozeReplacement = this.getString(R.string.reviewer_tts_cloze_spoken_replacement);
-        ReadText.readCardSide(cardSide, cardSideContent, getDeckIdForCard(card), card.getOrd(), clozeReplacement);
-    }
-
     /**
      * Shows the dialogue for selecting TTS for the current card and cardside.
      */
     protected void showSelectTtsDialogue() {
         if (mTtsInitialized) {
-            if (!sDisplayAnswer) {
-                ReadText.selectTts(getTextForTts(mCurrentCard.q(true)), getDeckIdForCard(mCurrentCard), mCurrentCard.getOrd(),
-                        SoundSide.QUESTION);
-            } else {
-                ReadText.selectTts(getTextForTts(mCurrentCard.getPureAnswer()), getDeckIdForCard(mCurrentCard),
-                        mCurrentCard.getOrd(), SoundSide.ANSWER);
-            }
+            mTTS.selectTts(this, mCurrentCard, sDisplayAnswer ? SoundSide.ANSWER : SoundSide.QUESTION);
         }
     }
 
 
-    private String getTextForTts(String text) {
-        String clozeReplacement = this.getString(R.string.reviewer_tts_cloze_spoken_replacement);
-        String clozeReplaced = text.replace(TemplateFilters.CLOZE_DELETION_REPLACEMENT, clozeReplacement);
-        return Utils.stripHTML(clozeReplaced);
-    }
-
-
     /**
      * Returns the configuration for the current {@link Card}.
      *
      * @return The configuration for the current {@link Card}
      */
     private DeckConfig getConfigForCurrentCard() {
-        return getCol().getDecks().confForDid(getDeckIdForCard(mCurrentCard));
-    }
-
-
-    /**
-     * Returns the deck ID of the given {@link Card}.
-     *
-     * @param card The {@link Card} to get the deck ID
-     * @return The deck ID of the {@link Card}
-     */
-    private static long getDeckIdForCard(final Card card) {
-        // Try to get the configuration by the original deck ID (available in case of a cram deck),
-        // else use the direct deck ID (in case of a 'normal' deck.
-        return card.getODid() == 0 ? card.getDid() : card.getODid();
+        return getCol().getDecks().confForDid(CardUtils.getDeckIdForCard(mCurrentCard));
     }
 
 
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardUtils.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardUtils.java
index 0217c167ef39..8eb6685ef1ff 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardUtils.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardUtils.java
@@ -61,4 +61,16 @@ public static boolean isIn(long[] array, long val) {
         }
         return false;
     }
+
+    /**
+     * Returns the deck ID of the given {@link Card}.
+     *
+     * @param card The {@link Card} to get the deck ID
+     * @return The deck ID of the {@link Card}
+     */
+    public static long getDeckIdForCard(final Card card) {
+        // Try to get the configuration by the original deck ID (available in case of a cram deck),
+        // else use the direct deck ID (in case of a 'normal' deck.
+        return card.getODid() == 0 ? card.getDid() : card.getODid();
+    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/TTS.java b/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/TTS.java
new file mode 100644
index 000000000000..193fa6bce5ed
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/cardviewer/TTS.java
@@ -0,0 +1,98 @@
+/*
+ *  Copyright (c) 2021 Tyler Lewis <tyler.r.lewis1@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free Software
+ *  Foundation; either version 3 of the License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// This time, we're going to be doing the most that we can using ReadText.java. Rather than the reimplementation
+// that happened with branch Cloze_TTS_#9590.
+package com.ichi2.anki.cardviewer;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.speech.tts.TextToSpeech;
+
+import com.afollestad.materialdialogs.MaterialDialog;
+import com.ichi2.anki.AbstractFlashcardViewer;
+import com.ichi2.anki.CardUtils;
+import com.ichi2.anki.MetaDB;
+import com.ichi2.anki.R;
+import com.ichi2.anki.ReadText;
+import com.ichi2.libanki.Card;
+import com.ichi2.libanki.Sound;
+import com.ichi2.libanki.Utils;
+import com.ichi2.libanki.template.TemplateFilters;
+
+import java.util.ArrayList;
+
+import timber.log.Timber;
+
+public class TTS {
+    private ReadText mTTS;
+
+    /**
+     * Returns the card ordinal for TTS language storage.
+     *
+     * The ordinal of a Cloze card denotes the cloze deletion, causing the TTS
+     * language to be requested and stored on every new highest cloze deletion when
+     * used normally.
+     *
+     * @param card The card to check the type of before determining the ordinal.
+     * @return The card ordinal. If it's a Cloze card, returns 0.
+     */
+    private int getOrdUsingCardType(Card card) {
+        if (card.model().isCloze()) {
+            return 0;
+        } else {
+            return card.getOrd();
+        }
+    }
+
+    /**
+     * Reads the text (using TTS) for the given side of a card.
+     *
+     * @param card     The card to play TTS for
+     * @param cardSide The side of the current card to play TTS for
+     */
+    public void readCardText(Context context, final Card card, final Sound.SoundSide cardSide) {
+        final String cardSideContent;
+        if (Sound.SoundSide.QUESTION == cardSide) {
+            cardSideContent = card.q(true);
+        } else if (Sound.SoundSide.ANSWER == cardSide) {
+            cardSideContent = card.getPureAnswer();
+        } else {
+            Timber.w("Unrecognised cardSide");
+            return;
+        }
+        String clozeReplacement = context.getString(R.string.reviewer_tts_cloze_spoken_replacement);
+        mTTS.readCardSide(cardSide, cardSideContent, CardUtils.getDeckIdForCard(card), getOrdUsingCardType(card), clozeReplacement);
+    }
+
+    /**
+     * Ask the user what language they want.
+     *
+     * @param card The card to read text from
+     * @param qa   The card question or card answer
+     */
+    public void selectTts(Context context, Card card, Sound.SoundSide qa) {
+        String textToRead = qa == Sound.SoundSide.QUESTION ? card.q(true) : card.getPureAnswer();
+        // get the text from the card
+        mTTS.selectTts(getTextForTts(context, textToRead), CardUtils.getDeckIdForCard(card), getOrdUsingCardType(card), qa);
+    }
+
+    public String getTextForTts(Context context, String text) {
+        String clozeReplacement = context.getString(R.string.reviewer_tts_cloze_spoken_replacement);
+        String clozeReplaced = text.replace(TemplateFilters.CLOZE_DELETION_REPLACEMENT, clozeReplacement);
+        return Utils.stripHTML(clozeReplaced);
+    }
+}
