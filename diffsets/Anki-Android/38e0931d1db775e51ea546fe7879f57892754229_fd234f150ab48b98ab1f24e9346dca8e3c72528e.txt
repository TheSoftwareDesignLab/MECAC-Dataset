diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
index 15decacb0a5e..62e66fbe2594 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java
@@ -29,6 +29,7 @@
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 import android.content.res.Resources;
+import android.content.res.TypedArray;
 import android.database.SQLException;
 import android.graphics.PixelFormat;
 import android.net.Uri;
@@ -71,6 +72,7 @@
 import com.ichi2.anki.receiver.SdCardReceiver;
 import com.ichi2.anki.stats.AnkiStatsTaskHandler;
 import com.ichi2.anki.widgets.DeckAdapter;
+import com.ichi2.ui.DividerItemDecoration;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.async.DeckTask;
@@ -139,7 +141,6 @@ public class DeckPicker extends NavigationDrawerActivity implements
     private RecyclerView mRecyclerView;
     private LinearLayoutManager mRecyclerViewLayoutManager;
     private DeckAdapter mDeckListAdapter;
-    private List<Sched.DeckDueTreeNode> mDeckList;
 
     private TextView mTodayTextView;
 
@@ -155,9 +156,11 @@ public class DeckPicker extends NavigationDrawerActivity implements
     /**
      * Keep track of which deck was last given focus in the deck list. If we find that this value
      * has changed between deck list refreshes, we need to recenter the deck list to the new current
-     * deck (e.g., when a filtered deck was created in a study options fragment).
+     * deck.
      */
-    private Long mFocusedDeck;
+    private long mFocusedDeck;
+
+
 
     // ----------------------------------------------------------------------------
     // LISTENERS
@@ -184,9 +187,6 @@ public void onClick(View v) {
         public boolean onLongClick(View v) {
             long deckId = (long) v.getTag();
             Timber.i("DeckPicker:: Long tapped on deck with id %d", deckId);
-            if (mDeckList == null || mDeckList.size() == 0) {
-                return true;
-            }
             mContextMenuDid = deckId;
             String deckName = getCol().getDecks().name(mContextMenuDid);
             boolean hasSubdecks = getCol().getDecks().children(mContextMenuDid).size() > 0;
@@ -366,16 +366,15 @@ protected void onCreate(Bundle savedInstanceState) throws SQLException {
         initNavigationDrawer(mainView);
         setTitle(getResources().getString(R.string.app_name));
 
-        mDeckList = new ArrayList<>();
         mRecyclerView = (RecyclerView) findViewById(R.id.files);
-        mRecyclerView.addItemDecoration(new DividerItemDecoration(this, null, false, true));
+        mRecyclerView.addItemDecoration(new DividerItemDecoration(this));
 
         // specify a LinearLayoutManager for the RecyclerView
         mRecyclerViewLayoutManager = new LinearLayoutManager(this);
         mRecyclerView.setLayoutManager(mRecyclerViewLayoutManager);
 
         // create and set an adapter for the RecyclerView
-        mDeckListAdapter = new DeckAdapter(mDeckList, getResources(), getLayoutInflater(), this);
+        mDeckListAdapter = new DeckAdapter(getLayoutInflater(), this);
         mDeckListAdapter.setDeckClickListener(mDeckClickListener);
         mDeckListAdapter.setDeckExpanderClickListener(mDeckExpanderClickListener);
         mDeckListAdapter.setDeckLongClickListener(mDeckLongClickListener);
@@ -1551,87 +1550,19 @@ private void handleDeckSelection(long did) {
         getCol().getDecks().select(did);
         mFocusedDeck = did;
         openStudyOptions(false);
+        // Make sure the adapter knows about the new current deck so it will be correctly highlighted.
+        mDeckListAdapter.notifyDataSetChanged();
     }
 
 
-    /**
-     * Return true if deck is not a children of a collapsed deck
-     */
-    private boolean deckIsShown(List<Sched.DeckDueTreeNode> nodes, Long current) {
-        for (Sched.DeckDueTreeNode node : nodes) {
-            if (node.did == current) {
-                return true;
-            }
-            if (!getCol().getDecks().get(node.did).optBoolean("collapsed", false) && deckIsShown(node.children, current)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
     /**
      * Scroll the deck list so that it is centered on the current deck.
      *
      * @param did The deck ID of the deck to select.
      */
     private void scrollDecklistToDeck(long did) {
-        int position = findDeckPositionWithId(mDeckList, did, 0);
-        if (position > -1) {
-            mRecyclerViewLayoutManager.scrollToPositionWithOffset(position, (mRecyclerView.getHeight() / 2));
-        }
-    }
-
-    /**
-     * Given a list of {@link Sched.DeckDueTreeNode} objects, find the list position matching the id.
-     *
-     * @param nodes The list of {@link Sched.DeckDueTreeNode} objects
-     * @param did The deck id to find
-     * @param position The current deck's position in the list
-     *
-     * @return The position, if found, and -1 otherwise.
-     */
-    private int findDeckPositionWithId(List<Sched.DeckDueTreeNode> nodes, long did, int position) {
-        for (int i=0; i<nodes.size(); i++) {
-            // return the position if the deck ids match
-            if (nodes.get(i).did == did) {
-                // if we're at depth zero, return this loop's value
-                // otherwise return the position (the cardview we want)
-                return (nodes.get(i).depth == 0) ? i : position;
-            }
-
-            // keep searching through this node's children
-            if (nodes.get(i).children.size() > 0) {
-                // if we find the deck id, return this child's parent position
-                int childPosition = findDeckPositionWithId(nodes.get(i).children, did, (nodes.get(i).depth == 0) ? i : position);
-                if (childPosition > -1) {
-                    return childPosition;
-                }
-            }
-        }
-
-        return -1;
-    }
-
-    /**
-     * Given a list of {@link Sched.DeckDueTreeNode} objects, find the node matching the deck id.
-     *
-     * @param nodes The list of {@link Sched.DeckDueTreeNode} objects
-     * @param did The deck id to find
-     *
-     * @return The {@link Sched.DeckDueTreeNode}, if found, and null otherwise.
-     */
-    private Sched.DeckDueTreeNode findDeckWithId(List<Sched.DeckDueTreeNode> nodes, long did) {
-        for (int i=0; i<nodes.size(); i++) {
-            if (nodes.get(i).did == did) {
-                return nodes.get(i);
-            }
-
-            if (nodes.get(i).children.size() > 0) {
-                return findDeckWithId(nodes.get(i).children, did);
-            }
-        }
-
-        return null;
+        int position = mDeckListAdapter.findDeckPosition(did);
+        mRecyclerViewLayoutManager.scrollToPositionWithOffset(position, (mRecyclerView.getHeight() / 2));
     }
 
 
@@ -1644,10 +1575,6 @@ private Sched.DeckDueTreeNode findDeckWithId(List<Sched.DeckDueTreeNode> nodes,
      */
     private void updateDeckList() {
         DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_COUNTS, new DeckTask.TaskListener() {
-            // Totals accumulated as each deck is processed
-            private int nNew;
-            private int nLrn;
-            private int nRev;
 
             @Override
             public void onPreExecute() {
@@ -1662,14 +1589,12 @@ public void onPostExecute(TaskData result) {
                     return;
                 }
                 List<Sched.DeckDueTreeNode> nodes = (List<Sched.DeckDueTreeNode>) result.getObjArray()[0];
-                mDeckList.clear();
-                _renderDeckTree(nodes);
-                mDeckListAdapter.notifyDataSetChanged();
+                mDeckListAdapter.buildDeckList(nodes);
 
                 // Set the "x due in y minutes" subtitle
                 try {
-                    int eta = getCol().getSched().eta(new int[]{nNew, nLrn, nRev});
-                    int due = nNew + nLrn + nRev;
+                    int eta = mDeckListAdapter.getEta();
+                    int due = mDeckListAdapter.getDue();
                     Resources res = getResources();
                     if (getCol().cardCount() != -1) {
                         String time = "-";
@@ -1684,11 +1609,8 @@ public void onPostExecute(TaskData result) {
                     return;
                 }
 
-                Long current = getCol().getDecks().current().optLong("id");
-                if (!deckIsShown(nodes, current)) {
-                    // clear selection if deck is hidden
-                    //                    mDeckListView.clearChoices(); // TODO AVP
-                } else if (mFocusedDeck == null || !mFocusedDeck.equals(current)) {
+                long current = getCol().getDecks().current().optLong("id");
+                if (mFocusedDeck != current) {
                     scrollDecklistToDeck(current);
                     mFocusedDeck = current;
                 }
@@ -1709,55 +1631,6 @@ public void onProgressUpdate(TaskData... values) {
             public void onCancelled() {
             }
 
-
-            private void _renderDeckTree(List<Sched.DeckDueTreeNode> nodes) {
-                _renderDeckTree(nodes, 0);
-            }
-
-
-            private void _renderDeckTree(List<Sched.DeckDueTreeNode> nodes, int depth) {
-                for (Sched.DeckDueTreeNode node : nodes) {
-                    // if this node's parent is collapsed, don't add it to the deck list
-                    for (JSONObject parent : getCol().getDecks().parents(node.did)) {
-                        if (parent.optBoolean("collapsed")) {
-                            return;
-                        }
-                    }
-
-                    // add node to deck
-                    mDeckList.add(node);
-
-                    _deckRow(node, depth);
-                }
-            }
-
-
-            /**
-             * Create a row in the deck list using the given node.
-             *
-             * This method determines various visual elements of each row:
-             *  - Indenting level based on depth if it's a subdeck
-             *  - Addition of a unicode arrow to indicate subdeck status
-             *  - Addition of an indicator to notify collapsed state
-             *  - The type of padding given to each row
-             *
-             * NOTE: Each row in the list also contains the deck ID (did) which is later fetched
-             * to perform operations on the correct deck when the user interacts with the list.
-             *  @param node The row data.
-             * @param depth The subdeck level this node is at.
-             */
-            private void _deckRow(Sched.DeckDueTreeNode node, int depth) {
-                node.depth = depth;
-
-                // Add this node's counts to the totals if it's a parent deck
-                if (depth == 0) {
-                    nNew += node.newCount;
-                    nLrn += node.lrnCount;
-                    nRev += node.revCount;
-                }
-
-                _renderDeckTree(node.children, depth + 1);
-            }
         }, new TaskData(getCol()));
     }
 
@@ -1832,10 +1705,6 @@ public void onPositive(MaterialDialog dialog) {
                         Collection col = getCol();
                         if (col != null) {
                             if (col.getDecks().rename(col.getDecks().get(mContextMenuDid), newName)) {
-                                Sched.DeckDueTreeNode node = findDeckWithId(mDeckList, mContextMenuDid);
-                                if (node != null) {
-                                    node.names = new String[]{newName};
-                                }
                                 updateDeckList();
                             } else {
                                 try {
@@ -1864,7 +1733,7 @@ public void onNegative(MaterialDialog dialog) {
     // Callback to show confirm deck deletion dialog before deleting currently selected deck
     public void confirmDeckDeletion(DialogFragment parent) {
         Resources res = getResources();
-        if (!colIsOpen() || mDeckList == null || mDeckList.size() == 0) {
+        if (!colIsOpen()) {
             return;
         }
         String msg = "";
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/DividerItemDecoration.java b/AnkiDroid/src/main/java/com/ichi2/anki/DividerItemDecoration.java
deleted file mode 100644
index 5fda13e97efe..000000000000
--- a/AnkiDroid/src/main/java/com/ichi2/anki/DividerItemDecoration.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package com.ichi2.anki;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.util.AttributeSet;
-import android.view.View;
-
-/*
- * DividerItemDecoration, from https://gist.github.com/lapastillaroja/858caf1a82791b6c1a36
- */
-public class DividerItemDecoration extends RecyclerView.ItemDecoration {
-
-    private Drawable mDivider;
-    private boolean mShowFirstDivider = false;
-    private boolean mShowLastDivider = false;
-
-
-    public DividerItemDecoration(Context context, AttributeSet attrs) {
-        final TypedArray a = context.obtainStyledAttributes(attrs, new int[]{android.R.attr.listDivider});
-        mDivider = a.getDrawable(0);
-        a.recycle();
-    }
-
-    public DividerItemDecoration(Context context, AttributeSet attrs,
-        boolean showFirstDivider, boolean showLastDivider) {
-        this(context, attrs);
-
-        mShowFirstDivider = showFirstDivider;
-        mShowLastDivider = showLastDivider;
-    }
-
-    public DividerItemDecoration(Drawable divider) {
-        mDivider = divider;
-    }
-
-    public DividerItemDecoration(Drawable divider,
-        boolean showFirstDivider, boolean showLastDivider) {
-        this(divider);
-
-        mShowFirstDivider = showFirstDivider;
-        mShowLastDivider = showLastDivider;
-    }
-
-    @Override
-    public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
-        RecyclerView.State state) {
-        super.getItemOffsets(outRect, view, parent, state);
-
-        if (mDivider == null) {
-            return;
-        }
-        if (parent.getChildPosition(view) < 1) {
-            return;
-        }
-
-        if (getOrientation(parent) == LinearLayoutManager.VERTICAL) {
-            outRect.top = mDivider.getIntrinsicHeight();
-        } else {
-            outRect.left = mDivider.getIntrinsicWidth();
-        }
-    }
-
-    @Override
-    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
-        if (mDivider == null) {
-            super.onDrawOver(c, parent, state);
-            return;
-        }
-
-        // Initialization needed to avoid compiler warning
-        int left = 0, right = 0, top = 0, bottom = 0, size;
-        int orientation = getOrientation(parent);
-        int childCount = parent.getChildCount();
-
-        if (orientation == LinearLayoutManager.VERTICAL) {
-            size = mDivider.getIntrinsicHeight();
-            left = parent.getPaddingLeft();
-            right = parent.getWidth() - parent.getPaddingRight();
-        } else { //horizontal
-            size = mDivider.getIntrinsicWidth();
-            top = parent.getPaddingTop();
-            bottom = parent.getHeight() - parent.getPaddingBottom();
-        }
-
-        for (int i = mShowFirstDivider ? 0 : 1; i < childCount; i++) {
-            View child = parent.getChildAt(i);
-            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();
-
-            if (orientation == LinearLayoutManager.VERTICAL) {
-                top = child.getTop() - params.topMargin;
-                bottom = top + size;
-            } else { //horizontal
-                left = child.getLeft() - params.leftMargin;
-                right = left + size;
-            }
-            mDivider.setBounds(left, top, right, bottom);
-            mDivider.draw(c);
-        }
-
-        // show last divider
-        if (mShowLastDivider && childCount > 0) {
-            View child = parent.getChildAt(childCount - 1);
-            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();
-            if (orientation == LinearLayoutManager.VERTICAL) {
-                top = child.getBottom() + params.bottomMargin;
-                bottom = top + size;
-            } else { // horizontal
-                left = child.getRight() + params.rightMargin;
-                right = left + size;
-            }
-            mDivider.setBounds(left, top, right, bottom);
-            mDivider.draw(c);
-        }
-    }
-
-    private int getOrientation(RecyclerView parent) {
-        if (parent.getLayoutManager() instanceof LinearLayoutManager) {
-            LinearLayoutManager layoutManager = (LinearLayoutManager) parent.getLayoutManager();
-            return layoutManager.getOrientation();
-        } else {
-            throw new IllegalStateException(
-                    "DividerItemDecoration can only be used with a LinearLayoutManager.");
-        }
-    }
-}
\ No newline at end of file
diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java b/AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java
index d8ae62ab57fe..e15ab268dd4e 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java
@@ -1,150 +1,192 @@
+/****************************************************************************************
+ * Copyright (c) 2015 Houssam Salem <houssam.salem.au@gmail.com>                        *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
 package com.ichi2.anki.widgets;
 
 import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.support.v7.widget.RecyclerView;
-import android.view.*;
-import android.widget.*;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
 
 import com.ichi2.anki.CollectionHelper;
 import com.ichi2.anki.R;
-import com.ichi2.libanki.*;
+import com.ichi2.libanki.Collection;
+import com.ichi2.libanki.Sched;
 
-import java.util.List;
+import org.json.JSONObject;
 
-import timber.log.Timber;
+import java.util.ArrayList;
+import java.util.List;
 
 public class DeckAdapter extends RecyclerView.Adapter<DeckAdapter.ViewHolder> {
 
     private LayoutInflater mLayoutInflater;
     private List<Sched.DeckDueTreeNode> mDeckList;
-    private int zeroCountColor;
-    private int newCountColor;
-    private int learnCountColor;
-    private int reviewCountColor;
+    private int mZeroCountColor;
+    private int mNewCountColor;
+    private int mLearnCountColor;
+    private int mReviewCountColor;
+    private int mRowDefaultColor;
+    private int mRowCurrentColor;
+    private int mDeckNameDefaultColor;
+    private int mDeckNameDynColor;
+
+    // Listeners
     private View.OnClickListener mDeckClickListener;
     private View.OnClickListener mDeckExpanderClickListener;
     private View.OnLongClickListener mDeckLongClickListener;
-    private Context mContext;
+
+    private Collection mCol;
+
+    // Totals accumulated as each deck is processed
+    private int mNew;
+    private int mLrn;
+    private int mRev;
 
     // ViewHolder class to save inflated views for recycling
     public class ViewHolder extends RecyclerView.ViewHolder {
-        public RelativeLayout mDeckLayout;
-        public TextView mDeckExpander;
-        public TextView mDeckName;
-        public TextView mDeckNew, mDeckLearn, mDeckRev;
+        public RelativeLayout deckLayout;
+        public TextView deckExpander;
+        public TextView deckName;
+        public TextView deckNew, deckLearn, deckRev;
 
         public ViewHolder(View v) {
             super(v);
-            mDeckLayout = (RelativeLayout) v.findViewById(R.id.DeckPickerHoriz);
-            mDeckExpander = (TextView) v.findViewById(R.id.DeckPickerExpander);
-            mDeckName = (TextView) v.findViewById(R.id.DeckPickerName);
-            mDeckNew = (TextView) v.findViewById(R.id.deckpicker_new);
-            mDeckLearn = (TextView) v.findViewById(R.id.deckpicker_lrn);
-            mDeckRev = (TextView) v.findViewById(R.id.deckpicker_rev);
+            deckLayout = (RelativeLayout) v.findViewById(R.id.DeckPickerHoriz);
+            deckExpander = (TextView) v.findViewById(R.id.DeckPickerExpander);
+            deckName = (TextView) v.findViewById(R.id.DeckPickerName);
+            deckNew = (TextView) v.findViewById(R.id.deckpicker_new);
+            deckLearn = (TextView) v.findViewById(R.id.deckpicker_lrn);
+            deckRev = (TextView) v.findViewById(R.id.deckpicker_rev);
         }
     }
 
-    public DeckAdapter(List<Sched.DeckDueTreeNode> deckList, Resources resources,
-                       LayoutInflater layoutInflater, Context context) {
+    public DeckAdapter(LayoutInflater layoutInflater, Context context) {
         mLayoutInflater = layoutInflater;
-        mDeckList = deckList;
-
-        // Get the count colors from the theme attributes
-        int[] attrs = new int[] { R.attr.zeroCountColor, R.attr.newCountColor,
-                R.attr.learnCountColor, R.attr.reviewCountColor};
+        mCol = CollectionHelper.getInstance().getCol(context);
+        mDeckList = new ArrayList<>();
+        // Get the colors from the theme attributes
+        int[] attrs = new int[] {
+                R.attr.zeroCountColor,
+                R.attr.newCountColor,
+                R.attr.learnCountColor,
+                R.attr.reviewCountColor,
+                android.R.attr.colorBackground,
+                R.attr.currentDeckBackgroundColor,
+                android.R.attr.textColor,
+                R.attr.dynDeckColor};
         TypedArray ta = context.obtainStyledAttributes(attrs);
-        zeroCountColor = ta.getColor(0, R.color.zero_count);
-        newCountColor = ta.getColor(1, R.color.new_count);
-        learnCountColor = ta.getColor(2, R.color.learn_count);
-        reviewCountColor = ta.getColor(3, R.color.review_count);
-        mContext = context.getApplicationContext(); // don't hold ref to Activity
+        Resources res = context.getResources();
+        mZeroCountColor = ta.getColor(0, res.getColor(R.color.zero_count));
+        mNewCountColor = ta.getColor(1, res.getColor(R.color.new_count));
+        mLearnCountColor = ta.getColor(2, res.getColor(R.color.learn_count));
+        mReviewCountColor = ta.getColor(3, res.getColor(R.color.review_count));
+        mRowDefaultColor = ta.getColor(4, res.getColor(R.color.black));
+        mRowCurrentColor = ta.getColor(5, res.getColor(R.color.deckadapter_row_current));
+        mDeckNameDefaultColor = ta.getColor(6, res.getColor(R.color.black));
+        mDeckNameDynColor = ta.getColor(7, res.getColor(R.color.deckadapter_deck_name_dyn));
         ta.recycle();
     }
 
-    public void setDeckClickListener(View.OnClickListener mDeckClickListener) {
-        this.mDeckClickListener = mDeckClickListener;
+    public void setDeckClickListener(View.OnClickListener listener) {
+        mDeckClickListener = listener;
+    }
+
+    public void setDeckExpanderClickListener(View.OnClickListener listener) {
+        mDeckExpanderClickListener = listener;
     }
 
-    public void setDeckExpanderClickListener(View.OnClickListener mDeckExpanderClickListener) {
-        this.mDeckExpanderClickListener = mDeckExpanderClickListener;
+    public void setDeckLongClickListener(View.OnLongClickListener listener) {
+        mDeckLongClickListener = listener;
     }
 
-    public void setDeckLongClickListener(View.OnLongClickListener mDeckLongClickListener) {
-        this.mDeckLongClickListener = mDeckLongClickListener;
+
+    /**
+     * Consume a list of {@link Sched.DeckDueTreeNode}s to render a new deck list.
+     */
+    public void buildDeckList(List<Sched.DeckDueTreeNode> nodes) {
+        mDeckList.clear();
+        mNew = mLrn = mRev = 0;
+        processNodes(nodes);
+        notifyDataSetChanged();
     }
 
+
     @Override
     public DeckAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         View v = mLayoutInflater.inflate(R.layout.deck_item, parent, false);
         return new ViewHolder(v);
     }
 
-    // Replace the contents of a view (invoked by the layout manager)
+
     @Override
     public void onBindViewHolder(ViewHolder holder, int position) {
-        // update views for this node
+        // Update views for this node
         Sched.DeckDueTreeNode node = mDeckList.get(position);
-        Timber.d("DeckAdapter accessing collection...");
-        Collection col = CollectionHelper.getInstance().getCol(mContext);
-        boolean collapsed = col.getDecks().get(node.did).optBoolean("collapsed", false);
+        boolean collapsed = mCol.getDecks().get(node.did).optBoolean("collapsed", false);
 
-        // set expander and make expander clickable if needed
-        holder.mDeckExpander.setText(deckExpander(node.depth, collapsed, node.children.size()));
+        // Set expander and make it clickable if needed
+        holder.deckExpander.setText(deckExpander(node.depth, collapsed, node.children.size()));
         if (node.children.size() > 0) {
-            holder.mDeckExpander.setClickable(false);
-            holder.mDeckExpander.setTag(node.did);
-            holder.mDeckExpander.setOnClickListener(mDeckExpanderClickListener);
-        } else {
-            holder.mDeckExpander.setClickable(false);
+            holder.deckExpander.setTag(node.did);
+            holder.deckExpander.setOnClickListener(mDeckExpanderClickListener);
         }
 
-        // set deck name
-        holder.mDeckName.setText(node.names[0]);
-
-        // set deck new card count and color
-        holder.mDeckNew.setText(String.valueOf(node.newCount));
-        holder.mDeckNew.setTextColor((node.newCount == 0) ?
-                zeroCountColor : newCountColor);
-
-        // set deck learn card count and color
-        holder.mDeckLearn.setText(String.valueOf(node.lrnCount));
-        holder.mDeckLearn.setTextColor((node.lrnCount == 0) ?
-                zeroCountColor : learnCountColor);
+        // Set background colour. The current deck has its own color
+        if (node.did == mCol.getDecks().current().optLong("id")) {
+            holder.deckLayout.setBackgroundColor(mRowCurrentColor);
+        } else {
+            holder.deckLayout.setBackgroundColor(mRowDefaultColor);
+        }
 
-        // set deck review card count and color
-        holder.mDeckRev.setText(String.valueOf(node.revCount));
-        holder.mDeckRev.setTextColor((node.revCount == 0) ?
-                zeroCountColor : reviewCountColor);
+        // Set deck name and colour. Filtered decks have their own colour
+        holder.deckName.setText(node.names[0]);
+        if (mCol.getDecks().isDyn(node.did)) {
+            holder.deckName.setTextColor(mDeckNameDynColor);
+        } else {
+            holder.deckName.setTextColor(mDeckNameDefaultColor);
+        }
 
-        // store deck ID in layout's tag, for easy retrieval in our click listeners
-        holder.mDeckLayout.setTag(node.did);
+        // Set the card counts and their colors
+        holder.deckNew.setText(String.valueOf(node.newCount));
+        holder.deckNew.setTextColor((node.newCount == 0) ? mZeroCountColor : mNewCountColor);
+        holder.deckLearn.setText(String.valueOf(node.lrnCount));
+        holder.deckLearn.setTextColor((node.lrnCount == 0) ? mZeroCountColor : mLearnCountColor);
+        holder.deckRev.setText(String.valueOf(node.revCount));
+        holder.deckRev.setTextColor((node.revCount == 0) ? mZeroCountColor : mReviewCountColor);
 
-        // set click listeners
-        holder.mDeckLayout.setOnClickListener(mDeckClickListener);
-        holder.mDeckLayout.setOnLongClickListener(mDeckLongClickListener);
+        // Store deck ID in layout's tag for easy retrieval in our click listeners
+        holder.deckLayout.setTag(node.did);
 
-        // if this deck is the current deck, highlight it
-        //  if (node.did == getCol().getDecks().current().optLong("id")) {
-//                mDeckListView.setItemChecked(mOldDeckList.size(), true); // TODO
-        //   }
+        // Set click listeners
+        holder.deckLayout.setOnClickListener(mDeckClickListener);
+        holder.deckLayout.setOnLongClickListener(mDeckLongClickListener);
     }
 
     @Override
     public int getItemCount() {
-        // TODO
-        // If the default deck is empty, hide it
-        // We don't hide it if it's the only deck or if it has sub-decks
-//            if (node.did == 1 && cnt > 1 && node.children.size() == 0) {
-//                if (getCol().getDb().queryScalar("select 1 from cards where did = 1", false) == 0) {
-//                    mHideDefaultDeck = true;
-//                }
-//            }
-
         return mDeckList.size();
     }
 
+
     /**
      * Returns the name of the deck to be displayed in the deck list.
      * <p/>
@@ -153,7 +195,7 @@ public int getItemCount() {
      * for nested decks based on depth and an indicator of collapsed state.
      */
     private String deckExpander(int depth, boolean collapsed, int children) {
-        String s = new String();
+        String s;
         if (collapsed) {
             // add arrow pointing right if collapsed
             s = "\u25B7 ";
@@ -171,4 +213,71 @@ private String deckExpander(int depth, boolean collapsed, int children) {
             return new String(new char[depth]).replace("\0", "\u2009\u2009\u2009 ") + s;
         }
     }
+
+
+    private void processNodes(List<Sched.DeckDueTreeNode> nodes) {
+        processNodes(nodes, 0);
+    }
+
+
+    private void processNodes(List<Sched.DeckDueTreeNode> nodes, int depth) {
+        for (Sched.DeckDueTreeNode node : nodes) {
+            // If the default deck is empty, hide it by not adding it to the deck list.
+            // We don't hide it if it's the only deck or if it has sub-decks.
+            if (node.did == 1 && nodes.size() > 1 && node.children.size() == 0) {
+                if (mCol.getDb().queryScalar("select 1 from cards where did = 1") == 0) {
+                    continue;
+                }
+            }
+            // If any of this node's parents are collapsed, don't add it to the deck list
+            for (JSONObject parent : mCol.getDecks().parents(node.did)) {
+                if (parent.optBoolean("collapsed")) {
+                    return;
+                }
+            }
+            mDeckList.add(node);
+            // Keep track of the depth. It's used to determine visual properties like indenting later
+            node.depth = depth;
+
+            // Add this node's counts to the totals if it's a parent deck
+            if (depth == 0) {
+                mNew += node.newCount;
+                mLrn += node.lrnCount;
+                mRev += node.revCount;
+            }
+            // Process sub-decks
+            processNodes(node.children, depth + 1);
+        }
+    }
+
+
+    /**
+     * Return the position of the deck in the deck list. If the deck is a child of a collapsed deck
+     * (i.e., not visible in the deck list), then the position of the parent deck is returned instead.
+     *
+     * An invalid deck ID will return position 0.
+     */
+    public int findDeckPosition(long did) {
+        for (int i = 0; i < mDeckList.size(); i++) {
+            if (mDeckList.get(i).did == did) {
+                return i;
+            }
+        }
+        // If the deck is not in our list, we search again using the immediate parent
+        ArrayList<JSONObject> parents = mCol.getDecks().parents(did);
+        if (parents.size() == 0) {
+            return 0;
+        } else {
+            return findDeckPosition(parents.get(parents.size() - 1).optLong("id", 0));
+        }
+    }
+
+
+    public int getEta() {
+        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});
+    }
+
+    public int getDue() {
+        return mNew + mLrn + mRev;
+    }
 }
\ No newline at end of file
diff --git a/AnkiDroid/src/main/java/com/ichi2/ui/DividerItemDecoration.java b/AnkiDroid/src/main/java/com/ichi2/ui/DividerItemDecoration.java
new file mode 100644
index 000000000000..a88d3cb89aff
--- /dev/null
+++ b/AnkiDroid/src/main/java/com/ichi2/ui/DividerItemDecoration.java
@@ -0,0 +1,45 @@
+package com.ichi2.ui;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+
+import com.ichi2.anki.R;
+
+/**
+ * Copied and modified from http://stackoverflow.com/questions/24618829/27037230#27037230
+ */
+
+public class DividerItemDecoration extends RecyclerView.ItemDecoration {
+
+    private Drawable mDivider;
+
+    public DividerItemDecoration(Context context) {
+        int[] attrs = new int[] { R.attr.deckDivider };
+        TypedArray ta = context.obtainStyledAttributes(attrs);
+        mDivider = ta.getDrawable(0);
+        ta.recycle();
+    }
+
+    @Override
+    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
+        int left = parent.getPaddingLeft();
+        int right = parent.getWidth() - parent.getPaddingRight();
+
+        int childCount = parent.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            View child = parent.getChildAt(i);
+
+            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();
+
+            int top = child.getBottom() + params.bottomMargin;
+            int bottom = top + mDivider.getIntrinsicHeight();
+
+            mDivider.setBounds(left, top, right, bottom);
+            mDivider.draw(c);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/drawable/divider.xml b/AnkiDroid/src/main/res/drawable/divider.xml
new file mode 100644
index 000000000000..7a947249fca7
--- /dev/null
+++ b/AnkiDroid/src/main/res/drawable/divider.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <size
+        android:height="0.5dp" />
+    <solid android:color="#e5e5e5" />
+</shape>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/drawable/divider_dark.xml b/AnkiDroid/src/main/res/drawable/divider_dark.xml
new file mode 100644
index 000000000000..58faf3101016
--- /dev/null
+++ b/AnkiDroid/src/main/res/drawable/divider_dark.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <size
+        android:height="0.5dp" />
+    <solid android:color="#454545" />
+</shape>
\ No newline at end of file
diff --git a/AnkiDroid/src/main/res/values/attrs.xml b/AnkiDroid/src/main/res/values/attrs.xml
index 698cfddb383b..ed3a7b213f34 100644
--- a/AnkiDroid/src/main/res/values/attrs.xml
+++ b/AnkiDroid/src/main/res/values/attrs.xml
@@ -32,11 +32,15 @@
     <declare-styleable name="SeekBarPreference">
         <attr name="interval" format="integer" />
     </declare-styleable>
-    <!-- Card count colors -->
+    <!-- Deck list colors -->
+    <attr name="currentDeckBackgroundColor" format="color"/>
+    <attr name="dynDeckColor" format="color"/>
+    <!-- Deck list colors and divider -->
     <attr name="newCountColor" format="color"/>
     <attr name="learnCountColor" format="color"/>
     <attr name="reviewCountColor" format="color"/>
     <attr name="zeroCountColor" format="color"/>
+    <attr name="deckDivider" format="reference"/>
     <!-- Reviewer button colors -->
     <attr name="againButtonRef" format= "reference"/>
     <attr name="hardButtonRef" format= "reference"/>
diff --git a/AnkiDroid/src/main/res/values/colors.xml b/AnkiDroid/src/main/res/values/colors.xml
index 992789135299..be81405a2a59 100644
--- a/AnkiDroid/src/main/res/values/colors.xml
+++ b/AnkiDroid/src/main/res/values/colors.xml
@@ -75,6 +75,10 @@
     <color name="studyoptions_progressbar_young_blue">#8a8a8a</color>
     <color name="background_dark_blue">#10171d</color>
     <color name="reviewer_progressbar_session_blue">#a9a9a9</color>
+    <color name="deckadapter_row_current">#ececec</color>
+    <color name="deckadapter_row_current_night">#393939</color>
+    <color name="deckadapter_deck_name_dyn">#2222bb</color>
+    <color name="deckadapter_deck_name_dyn_night">#6699d6</color>
 
     <!-- Colors for the card counts, in the top bar, deck picker etc. -->
     <color name="new_count">@color/material_indigo_700</color>
@@ -86,8 +90,6 @@
     <color name="review_count_night">@color/material_green_200</color>
     <color name="zero_count_night">#202020</color>
     <color name="actionbar_background">#f5f5f5</color>
-    <color name="dyn_deck">#2222bb</color>
-    <color name="non_dyn_deck">#000000</color>
 
     <!-- Material Design: http://www.google.com/design/spec/style/color.html#color-color-palette -->
     <!-- Can eventually be shortened once settled on a color scheme -->
diff --git a/AnkiDroid/src/main/res/values/theme_dark.xml b/AnkiDroid/src/main/res/values/theme_dark.xml
index 45c8407a321e..f32848b0c827 100644
--- a/AnkiDroid/src/main/res/values/theme_dark.xml
+++ b/AnkiDroid/src/main/res/values/theme_dark.xml
@@ -14,6 +14,10 @@
         <item name="windowActionModeOverlay">true</item>
         <item name="actionBarThemeRef">@style/ActionBarDark</item>
         <item name="actionBarPopupThemeRef">@style/ActionBar.Popup.Dark</item>
+        <!-- Deck list colors and divider -->
+        <item name="currentDeckBackgroundColor">@color/deckadapter_row_current_night</item>
+        <item name="dynDeckColor">@color/deckadapter_deck_name_dyn_night</item>
+        <item name="deckDivider">@drawable/divider_dark</item>
         <!-- Reviewer colors -->
         <item name="topBarColor">@color/theme_primary_light_inv</item>
         <item name="newCountColor">@color/new_count_night</item>
diff --git a/AnkiDroid/src/main/res/values/theme_white.xml b/AnkiDroid/src/main/res/values/theme_white.xml
index ce6f1589f32c..be74ea3e3367 100644
--- a/AnkiDroid/src/main/res/values/theme_white.xml
+++ b/AnkiDroid/src/main/res/values/theme_white.xml
@@ -21,6 +21,10 @@
         <item name="popupTheme">@style/ActionBar.Popup</item>
         <!-- Dialog styles -->
         <item name="android:listPreferredItemHeight">56dip</item>
+        <!-- Deck list colors and divider -->
+        <item name="currentDeckBackgroundColor">@color/deckadapter_row_current</item>
+        <item name="dynDeckColor">@color/deckadapter_deck_name_dyn</item>
+        <item name="deckDivider">@drawable/divider</item>
         <!-- Reviewer colors -->
         <item name="topBarColor">@color/theme_primary_light</item>
         <item name="newCountColor">@color/new_count</item>
