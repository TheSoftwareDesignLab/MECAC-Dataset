diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
index 52c43ef510fc..63e1f386be50 100644
--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java
@@ -73,6 +73,7 @@
 import com.ichi2.libanki.Card;
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Consts;
+import com.ichi2.libanki.Decks;
 import com.ichi2.libanki.Note;
 import com.ichi2.libanki.Utils;
 import com.ichi2.themes.Themes;
@@ -92,7 +93,9 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Pattern;
 
@@ -127,6 +130,7 @@ public class CardBrowser extends NavigationDrawerActivity implements
     private int mColumn1Index;
     private int mColumn2Index;
 
+    //DEFECT: Doesn't need to be a local
     private long mNewDid;   // for change_deck
 
     private static final int EDIT_CARD = 0;
@@ -355,9 +359,28 @@ private long[] getSelectedCardIds() {
         return ids;
     }
 
-    private void changeDeck(int selectedDeck) {
+    @VisibleForTesting
+    void changeDeck(int deckPosition) {
         long[] ids = getSelectedCardIds();
-        mNewDid = mDropDownDecks.get(selectedDeck).getLong("id");
+
+        JSONObject selectedDeck = getValidDecksForChangeDeck().get(deckPosition);
+
+        try {
+            //#5932 - can't be dynamic
+            if (Decks.isDynamic(selectedDeck)) {
+                Timber.w("Attempted to change cards to dynamic deck. Cancelling operation.");
+                displayCouldNotChangeDeck();
+                return;
+            }
+        } catch (Exception e) {
+            displayCouldNotChangeDeck();
+            Timber.e(e);
+            return;
+        }
+
+        mNewDid = selectedDeck.getLong("id");
+
+        Timber.i("Changing selected cards to deck: %d", mNewDid);
 
         if (ids.length == 0) {
             endMultiSelectMode();
@@ -369,10 +392,15 @@ private void changeDeck(int selectedDeck) {
             mReloadRequired = true;
         }
 
-        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DISMISS_MULTI, mChangeDeckHandler,
-                new DeckTask.TaskData(new Object[]{ids, Collection.DismissType.CHANGE_DECK_MULTI, mNewDid}));
+        executeChangeDeckTask(ids, mNewDid);
+    }
+
+
+    private void displayCouldNotChangeDeck() {
+        UIUtils.showThemedToast(this, getString(R.string.card_browser_deck_change_error), true);
     }
 
+
     private Long getLastDeckId() {
         SharedPreferences state = getSharedPreferences(PERSISTENT_STATE_FILE,0);
         if (!state.contains(LAST_DECK_ID_KEY)) {
@@ -894,8 +922,9 @@ public boolean onOptionsItemSelected(MenuItem item) {
                 AlertDialog.Builder builderSingle = new AlertDialog.Builder(this);
                 builderSingle.setTitle(getString(R.string.move_all_to_deck));
 
+                //WARNING: changeDeck depends on this index, so any changes should be reflected there.
                 final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<String>(this, R.layout.dropdown_deck_item);
-                for (JSONObject deck : mDropDownDecks) {
+                for (JSONObject deck : getValidDecksForChangeDeck()) {
                     try {
                         arrayAdapter.add(deck.getString("name"));
                     } catch (JSONException e) {
@@ -1232,6 +1261,19 @@ private void updateCardInList(Card card, String updatedCardTags){
         }
     }
 
+    /** Returns the decks which are valid targets for "Change Deck" */
+    @VisibleForTesting
+    List<JSONObject> getValidDecksForChangeDeck() {
+        List<JSONObject> nonDynamicDecks = new ArrayList<>();
+        for (JSONObject d : mDropDownDecks) {
+            if (Decks.isDynamic(d)) {
+                continue;
+            }
+            nonDynamicDecks.add(d);
+        }
+        return nonDynamicDecks;
+    }
+
     private abstract class ListenerWithProgressBar extends DeckTask.TaskListener {
         @Override
         public void onPreExecute() {
@@ -1321,6 +1363,11 @@ protected void actualPostExecute(DeckTask.TaskData result) {
             mCardsAdapter.notifyDataSetChanged();
             invalidateOptionsMenu();    // maybe the availability of undo changed
 
+            if (!result.getBoolean()) {
+                Timber.i("mChangeDeckHandler failed, not offering undo");
+                displayCouldNotChangeDeck();
+                return;
+            }
             // snackbar to offer undo
             String deckName = getCol().getDecks().name(mNewDid);
             mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, String.format(getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {
@@ -2023,8 +2070,13 @@ long[] getCardIds() {
 
     @VisibleForTesting(otherwise = VisibleForTesting.NONE)
     void checkedCardsAtPositions(int[] positions) {
-        for (int i = 0; i < positions.length; i++) {
-            mCheckedCardPositions.add(positions[i]);
+        for (int position : positions) {
+            mCheckedCardPositions.add(position);
+            if (position >= mCards.size()) {
+                throw new IllegalStateException(
+                        String.format(Locale.US, "Attempted to check card at index %d. %d cards available",
+                                position, mCards.size()));
+            }
         }
         onSelectionChanged();
     }
@@ -2039,4 +2091,33 @@ public int checkedCardCount() {
         return mCheckedCardPositions.size();
     }
 
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public int getChangeDeckPositionFromId(long deckId) {
+        List<JSONObject> decks = getValidDecksForChangeDeck();
+        for (int i = 0; i < decks.size(); i++) {
+            JSONObject deck = decks.get(i);
+            if (deck.getLong("id") == deckId) {
+                return i;
+            }
+        }
+        throw new IllegalStateException(String.format(Locale.US, "Deck %d not found", deckId));
+    }
+
+
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public List<Long> getCheckedCardIds() {
+        List<Long> cardIds = new ArrayList<>();
+        for (Integer pos : mCheckedCardPositions) {
+            String id = mCards.get(pos).get("id");
+            cardIds.add(Long.valueOf(Objects.requireNonNull(id)));
+        }
+        return cardIds;
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE) //should only be called from changeDeck()
+    void executeChangeDeckTask(long[] ids, long newDid) {
+        mNewDid = newDid; //line required for unit tests, not necessary, but a noop in regular call.
+        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DISMISS_MULTI, mChangeDeckHandler,
+                new TaskData(new Object[]{ids, Collection.DismissType.CHANGE_DECK_MULTI, newDid}));
+    }
 }
diff --git a/AnkiDroid/src/main/java/com/ichi2/async/DeckTask.java b/AnkiDroid/src/main/java/com/ichi2/async/DeckTask.java
index 2668ff9f2ecc..8b971f1dc604 100644
--- a/AnkiDroid/src/main/java/com/ichi2/async/DeckTask.java
+++ b/AnkiDroid/src/main/java/com/ichi2/async/DeckTask.java
@@ -37,8 +37,8 @@
 import com.ichi2.libanki.Collection;
 import com.ichi2.libanki.Consts;
 import com.ichi2.libanki.DB;
+import com.ichi2.libanki.Decks;
 import com.ichi2.libanki.Note;
-import com.ichi2.libanki.Sched;
 import com.ichi2.libanki.Storage;
 import com.ichi2.libanki.Utils;
 import com.ichi2.libanki.importer.AnkiPackageImporter;
@@ -737,6 +737,28 @@ private TaskData doInBackgroundDismissNotes(TaskData... params) {
 
                     case CHANGE_DECK_MULTI: {
                         long newDid = (long) data[2];
+
+                        Timber.i("Changing %d cards to deck: '%d'", cards.length, newDid);
+                        JSONObject deckData = col.getDecks().get(newDid);
+
+                        if (Decks.isDynamic(deckData)) {
+                            //#5932 - can't change to a dynamic deck. Use "Rebuild"
+                            Timber.w("Attempted to move to dynamic deck. Cancelling task.");
+                            return new TaskData(false);
+                        }
+
+                        //Confirm that the deck exists (and is not the default)
+                        try {
+                            long actualId = deckData.getLong("id");
+                            if (actualId != newDid) {
+                                Timber.w("Attempted to move to deck %d, but got %d", newDid, actualId);
+                                return new TaskData(false);
+                            }
+                        } catch (Exception e) {
+                            Timber.e(e, "failed to check deck");
+                            return new TaskData(false);
+                        }
+
                         long[] changedCardIds = new long[cards.length];
                         for (int i = 0; i < cards.length; i++) {
                             changedCardIds[i] = cards[i].getId();
diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
index 52e55aa4421a..7257862bc8e9 100644
--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Decks.java
@@ -46,7 +46,9 @@
 import java.util.TreeMap;
 import java.util.regex.Pattern;
 
+import androidx.annotation.CheckResult;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import timber.log.Timber;
 
 // fixmes:
@@ -410,11 +412,12 @@ public int count() {
     }
 
     /** Obtains the deck from the DeckID, or default if the deck was not found */
+    @CheckResult
     public @NonNull JSONObject get(long did) {
         return get(did, true);
     }
 
-
+    @CheckResult
     public JSONObject get(long did, boolean _default) {
         if (mDecks.containsKey(did)) {
             return mDecks.get(did);
@@ -429,7 +432,8 @@ public JSONObject get(long did, boolean _default) {
     /**
      * Get deck with NAME, ignoring case.
      */
-    public JSONObject byName(String name) {
+    @CheckResult
+    public @Nullable JSONObject byName(String name) {
         for (JSONObject m : mDecks.values()) {
             if (equalName(m.getString("name"),name)) {
                 return m;
@@ -1065,4 +1069,8 @@ public boolean hasDeckOptions(long deckId) throws NoSuchDeckException {
     public void removeDeckOptions(long deckId) throws NoSuchDeckException {
         getDeckOrFail(deckId).remove("conf");
     }
+
+    public static boolean isDynamic(JSONObject deck) {
+        return deck.getInt("dyn") != 0;
+    }
 }
diff --git a/AnkiDroid/src/main/res/values/03-dialogs.xml b/AnkiDroid/src/main/res/values/03-dialogs.xml
index eefecbe505ec..237a2008e248 100644
--- a/AnkiDroid/src/main/res/values/03-dialogs.xml
+++ b/AnkiDroid/src/main/res/values/03-dialogs.xml
@@ -160,4 +160,7 @@
     <string name="integrity_check_insufficient_space">Check Database uses a large amount of temporary storage.\n\nIt is strongly recommended that you have at least %s free space on your device before continuing.</string>>
     <string name="integrity_check_insufficient_space_extra_content">\n\nYou currently have %s free.</string>
     <string name="video_creation_error">Could not play video</string>
+
+    <!-- Card Browser -->
+    <string name="card_browser_deck_change_error">Could not change deck</string>
 </resources>
diff --git a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
index 40ad5be031c0..11e1da7b3f69 100644
--- a/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
+++ b/AnkiDroid/src/test/java/com/ichi2/anki/CardBrowserTest.java
@@ -6,7 +6,9 @@
 
 import com.ichi2.libanki.Note;
 import com.ichi2.testutils.AnkiAssert;
+import com.ichi2.utils.JSONObject;
 
+import org.junit.Assert;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,6 +16,9 @@
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.shadows.ShadowActivity;
 
+import java.util.HashSet;
+import java.util.List;
+
 import javax.annotation.CheckReturnValue;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -22,6 +27,8 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.greaterThan;
+import static org.hamcrest.Matchers.hasItem;
+import static org.hamcrest.Matchers.not;
 import static org.hamcrest.core.Is.is;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -132,6 +139,113 @@ public void selectionsAreCorrectWhenNonExistingCardIsRemoved() {
         assertThat("Checked card after should have changed by 2 places", browser.hasCheckedCardAtPosition(4), is(true));
     }
 
+    @Test
+    public void canChangeDeckToRegularDeck() {
+        addDeck("Hello");
+        CardBrowser b = getBrowserWithNotes(5);
+
+        List<JSONObject> decks = b.getValidDecksForChangeDeck();
+
+        for (JSONObject d : decks) {
+            if (d.getString("name").equals("Hello")) {
+                return;
+            }
+        }
+        Assert.fail("Added deck was not found in the Card Browser");
+    }
+
+    @Test
+    public void cannotChangeDeckToDynamicDeck() {
+        //5932 - dynamic decks are meant to have cards added to them through "Rebuild".
+        addDynamicDeck("World");
+        CardBrowser b = getBrowserWithNotes(5);
+
+        List<JSONObject> decks = b.getValidDecksForChangeDeck();
+
+        for (JSONObject d : decks) {
+            if (d.getString("name").equals("World")) {
+                Assert.fail("Dynamic decks should not be transferred to by the browser.");
+            }
+        }
+
+    }
+
+    @Test
+    public void changeDeckIntegrationTestDynamicAndNon() {
+        addDeck("Hello");
+        addDynamicDeck("World");
+
+        HashSet<String> validNames = new HashSet<>();
+        validNames.add("Default");
+        validNames.add("Hello");
+
+        CardBrowser b = getBrowserWithNotes(5);
+
+        List<JSONObject> decks = b.getValidDecksForChangeDeck();
+        for (JSONObject d : decks) {
+            assertThat(validNames, hasItem(d.getString("name")));
+        }
+        assertThat("Additional unexpected decks were present", decks.size(), is(2));
+    }
+
+    @Test
+    public void moveToNonDynamicDeckWorks() {
+        addDeck("Foo");
+        addDynamicDeck("Bar");
+        long deckIdToChangeTo = addDeck("Hello");
+        addDeck("ZZ");
+        selectDefaultDeck();
+        CardBrowser b = getBrowserWithNotes(5);
+        b.checkedCardsAtPositions(new int[] {0, 2});
+
+        List<Long> cardIds = b.getCheckedCardIds();
+
+        for (Long cardId : cardIds) {
+            assertThat("Deck should have been changed yet", getCol().getCard(cardId).getDid(), not(deckIdToChangeTo));
+        }
+
+        final int deckPosition = b.getChangeDeckPositionFromId(deckIdToChangeTo);
+
+        //act
+        AnkiAssert.assertDoesNotThrow(() -> b.changeDeck(deckPosition));
+
+        //assert
+        for (Long cardId : cardIds) {
+            assertThat("Deck should be changed", getCol().getCard(cardId).getDid(), is(deckIdToChangeTo));
+        }
+    }
+
+    @Test
+    public void changeDeckViaTaskIsHandledCorrectly() {
+        long dynId = addDynamicDeck("World");
+        selectDefaultDeck();
+        CardBrowser b = getBrowserWithNotes(5);
+        b.checkedCardsAtPositions(new int[] {0, 2});
+
+        List<Long> cardIds = b.getCheckedCardIds();
+
+        b.executeChangeDeckTask(toLongArray(cardIds), dynId);
+
+        for (Long cardId: cardIds) {
+            assertThat("Deck should not be changed", getCol().getCard(cardId).getDid(), not(dynId));
+        }
+    }
+
+
+    private void selectDefaultDeck() {
+        getCol().getDecks().select(1);
+    }
+
+
+    private long addDynamicDeck(String name) {
+        return getCol().getDecks().newDyn(name);
+    }
+
+
+    private long addDeck(String deckName) {
+        return getCol().getDecks().id(deckName, true);
+    }
+
     private void deleteCardAtPosition(CardBrowser browser, int positionToCorrupt) {
         removeCardFromCollection(browser.getCardIds()[positionToCorrupt]);
         browser.clearCardData(positionToCorrupt);
@@ -159,6 +273,15 @@ private void selectMenuItem(CardBrowser browser, int action_select_all) {
         shadowActivity.clickMenuItem(action_select_all);
     }
 
+    //There has to be a better way :(
+    private long[] toLongArray(List<Long> list){
+        long[] ret = new long[list.size()];
+        for(int i = 0; i < ret.length; i++) {
+            ret[i] = list.get(i);
+        }
+        return ret;
+    }
+
 
     private CardBrowser getBrowserWithMultipleNotes() {
         return getBrowserWithNotes(3);
